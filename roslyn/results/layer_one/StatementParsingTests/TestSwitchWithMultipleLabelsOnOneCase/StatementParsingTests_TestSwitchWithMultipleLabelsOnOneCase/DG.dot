digraph G {
0 [label="EXTERNAL"];
1 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 144086"];
2 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 144087"];
3 [label="RuntimeHelpers.RunModuleConstructor(typeof(TestBase).Module.ModuleHandle); 144088"];
4 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 144089"];
5 [label="NullableAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 144090"];
6 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 144091"];
7 [label="NullableContextAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 144092"];
8 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 144093"];
9 [label="NullablePublicOnlyAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 144094"];
10 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 144095"];
11 [label="AllowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 144096"];
12 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 144097"];
13 [label="DisallowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 144098"];
14 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 144099"];
15 [label="MaybeNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 144100"];
16 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 144101"];
17 [label="MaybeNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 144102"];
18 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 144103"];
19 [label="NotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 144104"];
20 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 144105"];
21 [label="NotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 144106"];
22 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 144107"];
23 [label="MemberNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 144108"];
24 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 144109"];
25 [label="MemberNotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 144110"];
26 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 144111"];
27 [label="DoesNotReturnIfAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 144112"];
28 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 144113"];
29 [label="DoesNotReturnAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 144114"];
30 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 144115"];
31 [label="NotNullIfNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 144116"];
32 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 144117"];
33 [label="IsExternalInitTypeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 144118"];
34 [label="@'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 144119"];
35 [label="IAsyncDisposableDefinition = @'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 144120"];
36 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 144121"];
37 [label="AsyncStreamsTypes = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 144122"];
38 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 144123"];
39 [label="EnumeratorCancellationAttributeType = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 144124"];
40 [label="@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 144125"];
41 [label="NativeIntegerAttributeDefinition =\n@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 144126"];
42 [label="() => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic } 144127"];
43 [label="LazyThreadSafetyMode.PublicationOnly 144128"];
44 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 144129"];
45 [label="s_lazyDefaultVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 144130"];
46 [label="() => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic } 144131"];
47 [label="LazyThreadSafetyMode.PublicationOnly 144132"];
48 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 144133"];
49 [label="s_lazyLatestVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 144134"];
50 [label="RuntimeUtilities.IsCoreClrRuntime 144135"];
51 [label="'netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' 144136"];
52 [label="new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51') 144137"];
53 [label="RuntimeCorLibName = RuntimeUtilities.IsCoreClrRuntime\n            ? new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51')\n            : new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 144138"];
54 [label="() =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            } 144139"];
55 [label="LazyThreadSafetyMode.PublicationOnly 144140"];
56 [label="new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 144141"];
57 [label="s_winRtRefs = new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 144142"];
58 [label="() => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref } 144143"];
59 [label="LazyThreadSafetyMode.PublicationOnly 144144"];
60 [label="new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 144145"];
61 [label="s_portableRefsMinimal = new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 144146"];
62 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll') 144147"];
63 [label="LazyThreadSafetyMode.PublicationOnly 144148"];
64 [label="new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 144149"];
65 [label="s_systemCoreRef =\n            new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 144150"];
66 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll') 144151"];
67 [label="LazyThreadSafetyMode.PublicationOnly 144152"];
68 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144153"];
69 [label="s_systemCoreRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144154"];
70 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll') 144155"];
71 [label="LazyThreadSafetyMode.PublicationOnly 144156"];
72 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144157"];
73 [label="s_systemCoreRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144158"];
74 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll') 144159"];
75 [label="LazyThreadSafetyMode.PublicationOnly 144160"];
76 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144161"];
77 [label="s_systemWindowsFormsRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144162"];
78 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll') 144163"];
79 [label="LazyThreadSafetyMode.PublicationOnly 144164"];
80 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144165"];
81 [label="s_systemDrawingRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144166"];
82 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll') 144167"];
83 [label="LazyThreadSafetyMode.PublicationOnly 144168"];
84 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144169"];
85 [label="s_systemDataRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144170"];
86 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll') 144171"];
87 [label="LazyThreadSafetyMode.PublicationOnly 144172"];
88 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144173"];
89 [label="s_mscorlibRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144174"];
90 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll') 144175"];
91 [label="LazyThreadSafetyMode.PublicationOnly 144176"];
92 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144177"];
93 [label="s_mscorlibRefPortable = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144178"];
94 [label="() =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            } 144179"];
95 [label="LazyThreadSafetyMode.PublicationOnly 144180"];
96 [label="new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 144181"];
97 [label="s_aacorlibRef = new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 144182"];
98 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri') 144183"];
99 [label="LazyThreadSafetyMode.PublicationOnly 144184"];
100 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 144185"];
101 [label="s_mscorlibRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 144186"];
102 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll') 144187"];
103 [label="LazyThreadSafetyMode.PublicationOnly 144188"];
104 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144189"];
105 [label="s_mscorlibRef_silverlight = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144190"];
106 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll') 144191"];
107 [label="LazyThreadSafetyMode.PublicationOnly 144192"];
108 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144193"];
109 [label="s_desktopCSharpRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144194"];
110 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll') 144195"];
111 [label="LazyThreadSafetyMode.PublicationOnly 144196"];
112 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144197"];
113 [label="s_std20Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144198"];
114 [label="() => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll') 144199"];
115 [label="LazyThreadSafetyMode.PublicationOnly 144200"];
116 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144201"];
117 [label="s_46NetStandardFacade = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144202"];
118 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)') 144203"];
119 [label="LazyThreadSafetyMode.PublicationOnly 144204"];
120 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 144205"];
121 [label="s_systemDynamicRuntimeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 144206"];
122 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll') 144207"];
123 [label="LazyThreadSafetyMode.PublicationOnly 144208"];
124 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144209"];
125 [label="s_systemRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144210"];
126 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll') 144211"];
127 [label="LazyThreadSafetyMode.PublicationOnly 144212"];
128 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144213"];
129 [label="s_systemRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144214"];
130 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll') 144215"];
131 [label="LazyThreadSafetyMode.PublicationOnly 144216"];
132 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144217"];
133 [label="s_systemRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144218"];
134 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll') 144219"];
135 [label="LazyThreadSafetyMode.PublicationOnly 144220"];
136 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144221"];
137 [label="s_systemRef_v20 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144222"];
138 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll') 144223"];
139 [label="LazyThreadSafetyMode.PublicationOnly 144224"];
140 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144225"];
141 [label="s_systemXmlRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144226"];
142 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll') 144227"];
143 [label="LazyThreadSafetyMode.PublicationOnly 144228"];
144 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144229"];
145 [label="s_systemXmlLinqRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144230"];
146 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll') 144231"];
147 [label="LazyThreadSafetyMode.PublicationOnly 144232"];
148 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144233"];
149 [label="s_mscorlibFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144234"];
150 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll') 144235"];
151 [label="LazyThreadSafetyMode.PublicationOnly 144236"];
152 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144237"];
153 [label="s_systemRuntimeFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144238"];
154 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll') 144239"];
155 [label="LazyThreadSafetyMode.PublicationOnly 144240"];
156 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144241"];
157 [label="s_systemThreadingFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144242"];
158 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll') 144243"];
159 [label="LazyThreadSafetyMode.PublicationOnly 144244"];
160 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144245"];
161 [label="s_systemThreadingTasksFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144246"];
162 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll') 144247"];
163 [label="LazyThreadSafetyMode.PublicationOnly 144248"];
164 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144249"];
165 [label="s_mscorlibPP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144250"];
166 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll') 144251"];
167 [label="LazyThreadSafetyMode.PublicationOnly 144252"];
168 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144253"];
169 [label="s_systemRuntimePP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144254"];
170 [label="() => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll') 144255"];
171 [label="LazyThreadSafetyMode.PublicationOnly 144256"];
172 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144257"];
173 [label="s_FSharpTestLibraryRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 144258"];
174 [label="@'R:\\Invalid.dll' 144259"];
175 [label="fullPath: @'R:\\Invalid.dll' 144260"];
176 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 144261"];
177 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 144262"];
178 [label="InvalidRef = new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 144263"];
179 [label="MscorlibRef_v4_0_30316_17626 144264"];
180 [label="Net451.mscorlib 144265"];
181 [label="ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 144266"];
182 [label="s_scriptRefs = ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 144267"];
183 [label="'/*<bind>*/' 144268"];
184 [label="StartString = '/*<bind>*/' 144269"];
185 [label="'/*</bind>*/' 144270"];
186 [label="EndString = '/*</bind>*/' 144271"];
187 [label="@'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 144272"];
188 [label="SpanSource = @'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 144273"];
189 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 144274"];
190 [label="s_IAsyncEnumerable = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 144275"];
191 [label="param StatementParsingTests(ITestOutputHelper output) 144276"];
192 [label="param StatementParsingTests(this) 144277"];
193 [label="output 144278"];
194 [label="param ParsingTests(ITestOutputHelper output) 144279"];
195 [label="param ParsingTests(this) 144280"];
196 [label="param CSharpTestBase(this) 144281"];
197 [label="param CommonTestBase(this) 144282"];
198 [label="param TestBase(this) 144283"];
199 [label="_temp 144284"];
200 [label="_node 144285"];
201 [label="_treeEnumerator 144286"];
202 [label="_output 144287"];
203 [label="this._output 144288"];
204 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 144289"];
205 [label="param TestSwitchWithMultipleLabelsOnOneCase(this) 144290"];
206 [label="var text = 'switch (a) { case b: case c:; }'; 144291"];
207 [label="var statement = this.ParseStatement(text); 144292"];
208 [label="var statement = this.ParseStatement(text); 144293"];
209 [label="this.ParseStatement(text) 144294"];
210 [label="param ParseStatement(string text) 144295"];
211 [label="param ParseStatement(int offset = 0) 144296"];
212 [label="param ParseStatement(ParseOptions options = null) 144297"];
213 [label="param ParseStatement(this) 144298"];
214 [label="'\\r\\n' 144299"];
215 [label="CrLf = '\\r\\n' 144300"];
216 [label="CrLf 144301"];
217 [label="EndOfLine(CrLf) 144302"];
218 [label="param EndOfLine(string text) 144303"];
219 [label="param EndOfLine(bool elastic = false) 144304"];
220 [label="SyntaxTrivia trivia = null; 144305"];
221 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 144306"];
222 [label="elastic 144307"];
223 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 144308"];
224 [label="if (trivia != null)\n            {\n                return trivia;\n            } 144309"];
225 [label="if (trivia != null)\n            {\n                return trivia;\n            } 144310"];
226 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTrivia), r => new SyntaxTrivia(r)); 144311"];
227 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144312"];
228 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144313"];
229 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 144314"];
230 [label="param Create(SyntaxKind kind) 144315"];
231 [label="param Create(string text) 144316"];
232 [label="return new SyntaxTrivia(kind, text); 144317"];
233 [label="return new SyntaxTrivia(kind, text); 144318"];
234 [label="return new SyntaxTrivia(kind, text); 144319"];
235 [label="new SyntaxTrivia(kind, text) 144320"];
236 [label="param SyntaxTrivia(SyntaxKind kind) 144321"];
237 [label="param SyntaxTrivia(string text) 144322"];
238 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 144323"];
239 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 144324"];
240 [label="param SyntaxTrivia(this) 144325"];
241 [label="kind 144326"];
242 [label="diagnostics 144327"];
243 [label="annotations 144328"];
244 [label="new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 144329"];
245 [label="s_structuresTable\n            = new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 144330"];
246 [label="text 144331"];
247 [label="param SyntaxTrivia(this) 144332"];
248 [label="param CSharpSyntaxNode(SyntaxKind kind) 144333"];
249 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 144334"];
250 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 144335"];
251 [label="param CSharpSyntaxNode(int fullWidth) 144336"];
252 [label="param CSharpSyntaxNode(this) 144337"];
253 [label="kind 144338"];
254 [label="diagnostics 144339"];
255 [label="annotations 144340"];
256 [label="fullWidth 144341"];
257 [label="param CSharpSyntaxNode(this) 144342"];
258 [label="param CSharpSyntaxNode(this) 144343"];
259 [label="GreenStats.NoteGreen(this); 144344"];
260 [label="GreenStats.NoteGreen(this); 144345"];
261 [label="Text 144346"];
262 [label="this.Text 144347"];
263 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144348"];
264 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144349"];
265 [label="if (!elastic)\n            {\n                return trivia;\n            } 144350"];
266 [label="return trivia; 144351"];
267 [label="CarriageReturnLineFeed = EndOfLine(CrLf) 144352"];
268 [label="'\\n' 144353"];
269 [label="EndOfLine('\\n') 144354"];
270 [label="param EndOfLine(string text) 144355"];
271 [label="param EndOfLine(bool elastic = false) 144356"];
272 [label="SyntaxTrivia trivia = null; 144357"];
273 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 144358"];
274 [label="elastic 144359"];
275 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 144360"];
276 [label="if (trivia != null)\n            {\n                return trivia;\n            } 144361"];
277 [label="if (trivia != null)\n            {\n                return trivia;\n            } 144362"];
278 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144363"];
279 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144364"];
280 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 144365"];
281 [label="param Create(SyntaxKind kind) 144366"];
282 [label="param Create(string text) 144367"];
283 [label="return new SyntaxTrivia(kind, text); 144368"];
284 [label="return new SyntaxTrivia(kind, text); 144369"];
285 [label="return new SyntaxTrivia(kind, text); 144370"];
286 [label="new SyntaxTrivia(kind, text) 144371"];
287 [label="param SyntaxTrivia(SyntaxKind kind) 144372"];
288 [label="param SyntaxTrivia(string text) 144373"];
289 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 144374"];
290 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 144375"];
291 [label="param SyntaxTrivia(this) 144376"];
292 [label="kind 144377"];
293 [label="diagnostics 144378"];
294 [label="annotations 144379"];
295 [label="text 144380"];
296 [label="param SyntaxTrivia(this) 144381"];
297 [label="param CSharpSyntaxNode(SyntaxKind kind) 144382"];
298 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 144383"];
299 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 144384"];
300 [label="param CSharpSyntaxNode(int fullWidth) 144385"];
301 [label="param CSharpSyntaxNode(this) 144386"];
302 [label="kind 144387"];
303 [label="diagnostics 144388"];
304 [label="annotations 144389"];
305 [label="fullWidth 144390"];
306 [label="param CSharpSyntaxNode(this) 144391"];
307 [label="param CSharpSyntaxNode(this) 144392"];
308 [label="GreenStats.NoteGreen(this); 144393"];
309 [label="GreenStats.NoteGreen(this); 144394"];
310 [label="Text 144395"];
311 [label="this.Text 144396"];
312 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144397"];
313 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144398"];
314 [label="if (!elastic)\n            {\n                return trivia;\n            } 144399"];
315 [label="return trivia; 144400"];
316 [label="LineFeed = EndOfLine('\\n') 144401"];
317 [label="'\\r' 144402"];
318 [label="EndOfLine('\\r') 144403"];
319 [label="param EndOfLine(string text) 144404"];
320 [label="param EndOfLine(bool elastic = false) 144405"];
321 [label="SyntaxTrivia trivia = null; 144406"];
322 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 144407"];
323 [label="elastic 144408"];
324 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 144409"];
325 [label="if (trivia != null)\n            {\n                return trivia;\n            } 144410"];
326 [label="if (trivia != null)\n            {\n                return trivia;\n            } 144411"];
327 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144412"];
328 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144413"];
329 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 144414"];
330 [label="param Create(SyntaxKind kind) 144415"];
331 [label="param Create(string text) 144416"];
332 [label="return new SyntaxTrivia(kind, text); 144417"];
333 [label="return new SyntaxTrivia(kind, text); 144418"];
334 [label="return new SyntaxTrivia(kind, text); 144419"];
335 [label="new SyntaxTrivia(kind, text) 144420"];
336 [label="param SyntaxTrivia(SyntaxKind kind) 144421"];
337 [label="param SyntaxTrivia(string text) 144422"];
338 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 144423"];
339 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 144424"];
340 [label="param SyntaxTrivia(this) 144425"];
341 [label="kind 144426"];
342 [label="diagnostics 144427"];
343 [label="annotations 144428"];
344 [label="text 144429"];
345 [label="param SyntaxTrivia(this) 144430"];
346 [label="param CSharpSyntaxNode(SyntaxKind kind) 144431"];
347 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 144432"];
348 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 144433"];
349 [label="param CSharpSyntaxNode(int fullWidth) 144434"];
350 [label="param CSharpSyntaxNode(this) 144435"];
351 [label="kind 144436"];
352 [label="diagnostics 144437"];
353 [label="annotations 144438"];
354 [label="fullWidth 144439"];
355 [label="param CSharpSyntaxNode(this) 144440"];
356 [label="param CSharpSyntaxNode(this) 144441"];
357 [label="GreenStats.NoteGreen(this); 144442"];
358 [label="GreenStats.NoteGreen(this); 144443"];
359 [label="Text 144444"];
360 [label="this.Text 144445"];
361 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144446"];
362 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144447"];
363 [label="if (!elastic)\n            {\n                return trivia;\n            } 144448"];
364 [label="return trivia; 144449"];
365 [label="CarriageReturn = EndOfLine('\\r') 144450"];
366 [label="' ' 144451"];
367 [label="Whitespace(' ') 144452"];
368 [label="param Whitespace(string text) 144453"];
369 [label="param Whitespace(bool elastic = false) 144454"];
370 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 144455"];
371 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 144456"];
372 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 144457"];
373 [label="param Create(SyntaxKind kind) 144458"];
374 [label="param Create(string text) 144459"];
375 [label="return new SyntaxTrivia(kind, text); 144460"];
376 [label="return new SyntaxTrivia(kind, text); 144461"];
377 [label="return new SyntaxTrivia(kind, text); 144462"];
378 [label="new SyntaxTrivia(kind, text) 144463"];
379 [label="param SyntaxTrivia(SyntaxKind kind) 144464"];
380 [label="param SyntaxTrivia(string text) 144465"];
381 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 144466"];
382 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 144467"];
383 [label="param SyntaxTrivia(this) 144468"];
384 [label="kind 144469"];
385 [label="diagnostics 144470"];
386 [label="annotations 144471"];
387 [label="text 144472"];
388 [label="param SyntaxTrivia(this) 144473"];
389 [label="param CSharpSyntaxNode(SyntaxKind kind) 144474"];
390 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 144475"];
391 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 144476"];
392 [label="param CSharpSyntaxNode(int fullWidth) 144477"];
393 [label="param CSharpSyntaxNode(this) 144478"];
394 [label="kind 144479"];
395 [label="diagnostics 144480"];
396 [label="annotations 144481"];
397 [label="fullWidth 144482"];
398 [label="param CSharpSyntaxNode(this) 144483"];
399 [label="param CSharpSyntaxNode(this) 144484"];
400 [label="GreenStats.NoteGreen(this); 144485"];
401 [label="GreenStats.NoteGreen(this); 144486"];
402 [label="Text 144487"];
403 [label="this.Text 144488"];
404 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144489"];
405 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 144490"];
406 [label="if (!elastic)\n            {\n                return trivia;\n            } 144491"];
407 [label="return trivia; 144492"];
408 [label="Space = Whitespace(' ') 144493"];
409 [label="'\\t' 144494"];
410 [label="Whitespace('\\t') 144495"];
411 [label="param Whitespace(string text) 144496"];
412 [label="param Whitespace(bool elastic = false) 144497"];
413 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 144498"];
414 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 144499"];
415 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 144500"];
416 [label="param Create(SyntaxKind kind) 144501"];
417 [label="param Create(string text) 144502"];
418 [label="return new SyntaxTrivia(kind, text); 144503"];
419 [label="return new SyntaxTrivia(kind, text); 144504"];
420 [label="return new SyntaxTrivia(kind, text); 144505"];
421 [label="new SyntaxTrivia(kind, text) 144506"];
422 [label="param SyntaxTrivia(SyntaxKind kind) 144507"];
423 [label="param SyntaxTrivia(string text) 144508"];
424 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 144509"];
425 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 144510"];
426 [label="param SyntaxTrivia(this) 144511"];
427 [label="kind 144512"];
428 [label="diagnostics 144513"];
429 [label="annotations 144514"];
430 [label="text 144515"];
431 [label="param SyntaxTrivia(this) 144516"];
432 [label="param CSharpSyntaxNode(SyntaxKind kind) 144517"];
433 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 144518"];
434 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 144519"];
435 [label="param CSharpSyntaxNode(int fullWidth) 144520"];
436 [label="param CSharpSyntaxNode(this) 144521"];
437 [label="kind 144522"];
438 [label="diagnostics 144523"];
439 [label="annotations 144524"];
440 [label="fullWidth 144525"];
441 [label="param CSharpSyntaxNode(this) 144526"];
442 [label="param CSharpSyntaxNode(this) 144527"];
443 [label="GreenStats.NoteGreen(this); 144528"];
444 [label="GreenStats.NoteGreen(this); 144529"];
445 [label="Text 144530"];
446 [label="this.Text 144531"];
447 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144532"];
448 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 144533"];
449 [label="if (!elastic)\n            {\n                return trivia;\n            } 144534"];
450 [label="return trivia; 144535"];
451 [label="Tab = Whitespace('\\t') 144536"];
452 [label="CrLf 144537"];
453 [label="true 144538"];
454 [label="elastic: true 144539"];
455 [label="EndOfLine(CrLf, elastic: true) 144540"];
456 [label="param EndOfLine(string text) 144541"];
457 [label="param EndOfLine(bool elastic = false) 144542"];
458 [label="SyntaxTrivia trivia = null; 144543"];
459 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 144544"];
460 [label="elastic 144545"];
461 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 144546"];
462 [label="if (trivia != null)\n            {\n                return trivia;\n            } 144547"];
463 [label="if (trivia != null)\n            {\n                return trivia;\n            } 144548"];
464 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144549"];
465 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144550"];
466 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 144551"];
467 [label="param Create(SyntaxKind kind) 144552"];
468 [label="param Create(string text) 144553"];
469 [label="return new SyntaxTrivia(kind, text); 144554"];
470 [label="return new SyntaxTrivia(kind, text); 144555"];
471 [label="return new SyntaxTrivia(kind, text); 144556"];
472 [label="new SyntaxTrivia(kind, text) 144557"];
473 [label="param SyntaxTrivia(SyntaxKind kind) 144558"];
474 [label="param SyntaxTrivia(string text) 144559"];
475 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 144560"];
476 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 144561"];
477 [label="param SyntaxTrivia(this) 144562"];
478 [label="kind 144563"];
479 [label="diagnostics 144564"];
480 [label="annotations 144565"];
481 [label="text 144566"];
482 [label="param SyntaxTrivia(this) 144567"];
483 [label="param CSharpSyntaxNode(SyntaxKind kind) 144568"];
484 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 144569"];
485 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 144570"];
486 [label="param CSharpSyntaxNode(int fullWidth) 144571"];
487 [label="param CSharpSyntaxNode(this) 144572"];
488 [label="kind 144573"];
489 [label="diagnostics 144574"];
490 [label="annotations 144575"];
491 [label="fullWidth 144576"];
492 [label="param CSharpSyntaxNode(this) 144577"];
493 [label="param CSharpSyntaxNode(this) 144578"];
494 [label="GreenStats.NoteGreen(this); 144579"];
495 [label="GreenStats.NoteGreen(this); 144580"];
496 [label="Text 144581"];
497 [label="this.Text 144582"];
498 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144583"];
499 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144584"];
500 [label="if (!elastic)\n            {\n                return trivia;\n            } 144585"];
501 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144586"];
502 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144587"];
503 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 144588"];
504 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144589"];
505 [label="param SetAnnotations(SyntaxAnnotation[]? annotations) 144590"];
506 [label="param SetAnnotations(this) 144591"];
507 [label="this.Kind 144592"];
508 [label="get { return (SyntaxKind)this.RawKind; } 144593"];
509 [label="return (SyntaxKind)this.RawKind; 144594"];
510 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 144595"];
511 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 144596"];
512 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 144597"];
513 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 144598"];
514 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 144599"];
515 [label="param SyntaxTrivia(SyntaxKind kind) 144600"];
516 [label="param SyntaxTrivia(string text) 144601"];
517 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 144602"];
518 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 144603"];
519 [label="param SyntaxTrivia(this) 144604"];
520 [label="param SyntaxTrivia(this) 144605"];
521 [label="param CSharpSyntaxNode(this) 144606"];
522 [label="param CSharpSyntaxNode(this) 144607"];
523 [label="param CSharpSyntaxNode(this) 144608"];
524 [label="GreenStats.NoteGreen(this); 144609"];
525 [label="Text 144610"];
526 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144611"];
527 [label="ElasticCarriageReturnLineFeed = EndOfLine(CrLf, elastic: true) 144612"];
528 [label="'\\n' 144613"];
529 [label="true 144614"];
530 [label="elastic: true 144615"];
531 [label="EndOfLine('\\n', elastic: true) 144616"];
532 [label="param EndOfLine(string text) 144617"];
533 [label="param EndOfLine(bool elastic = false) 144618"];
534 [label="SyntaxTrivia trivia = null; 144619"];
535 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 144620"];
536 [label="elastic 144621"];
537 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 144622"];
538 [label="if (trivia != null)\n            {\n                return trivia;\n            } 144623"];
539 [label="if (trivia != null)\n            {\n                return trivia;\n            } 144624"];
540 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144625"];
541 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144626"];
542 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 144627"];
543 [label="param Create(SyntaxKind kind) 144628"];
544 [label="param Create(string text) 144629"];
545 [label="return new SyntaxTrivia(kind, text); 144630"];
546 [label="return new SyntaxTrivia(kind, text); 144631"];
547 [label="return new SyntaxTrivia(kind, text); 144632"];
548 [label="new SyntaxTrivia(kind, text) 144633"];
549 [label="param SyntaxTrivia(SyntaxKind kind) 144634"];
550 [label="param SyntaxTrivia(string text) 144635"];
551 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 144636"];
552 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 144637"];
553 [label="param SyntaxTrivia(this) 144638"];
554 [label="kind 144639"];
555 [label="diagnostics 144640"];
556 [label="annotations 144641"];
557 [label="text 144642"];
558 [label="param SyntaxTrivia(this) 144643"];
559 [label="param CSharpSyntaxNode(SyntaxKind kind) 144644"];
560 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 144645"];
561 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 144646"];
562 [label="param CSharpSyntaxNode(int fullWidth) 144647"];
563 [label="param CSharpSyntaxNode(this) 144648"];
564 [label="kind 144649"];
565 [label="diagnostics 144650"];
566 [label="annotations 144651"];
567 [label="fullWidth 144652"];
568 [label="param CSharpSyntaxNode(this) 144653"];
569 [label="param CSharpSyntaxNode(this) 144654"];
570 [label="GreenStats.NoteGreen(this); 144655"];
571 [label="GreenStats.NoteGreen(this); 144656"];
572 [label="Text 144657"];
573 [label="this.Text 144658"];
574 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144659"];
575 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144660"];
576 [label="if (!elastic)\n            {\n                return trivia;\n            } 144661"];
577 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144662"];
578 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144663"];
579 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 144664"];
580 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144665"];
581 [label="this.Kind 144666"];
582 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 144667"];
583 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 144668"];
584 [label="param SyntaxTrivia(this) 144669"];
585 [label="param SyntaxTrivia(this) 144670"];
586 [label="param CSharpSyntaxNode(this) 144671"];
587 [label="param CSharpSyntaxNode(this) 144672"];
588 [label="GreenStats.NoteGreen(this); 144673"];
589 [label="Text 144674"];
590 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144675"];
591 [label="ElasticLineFeed = EndOfLine('\\n', elastic: true) 144676"];
592 [label="'\\r' 144677"];
593 [label="true 144678"];
594 [label="elastic: true 144679"];
595 [label="EndOfLine('\\r', elastic: true) 144680"];
596 [label="param EndOfLine(string text) 144681"];
597 [label="param EndOfLine(bool elastic = false) 144682"];
598 [label="SyntaxTrivia trivia = null; 144683"];
599 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 144684"];
600 [label="elastic 144685"];
601 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 144686"];
602 [label="if (trivia != null)\n            {\n                return trivia;\n            } 144687"];
603 [label="if (trivia != null)\n            {\n                return trivia;\n            } 144688"];
604 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144689"];
605 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144690"];
606 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 144691"];
607 [label="param Create(SyntaxKind kind) 144692"];
608 [label="param Create(string text) 144693"];
609 [label="return new SyntaxTrivia(kind, text); 144694"];
610 [label="return new SyntaxTrivia(kind, text); 144695"];
611 [label="return new SyntaxTrivia(kind, text); 144696"];
612 [label="new SyntaxTrivia(kind, text) 144697"];
613 [label="param SyntaxTrivia(SyntaxKind kind) 144698"];
614 [label="param SyntaxTrivia(string text) 144699"];
615 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 144700"];
616 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 144701"];
617 [label="param SyntaxTrivia(this) 144702"];
618 [label="kind 144703"];
619 [label="diagnostics 144704"];
620 [label="annotations 144705"];
621 [label="text 144706"];
622 [label="param SyntaxTrivia(this) 144707"];
623 [label="param CSharpSyntaxNode(SyntaxKind kind) 144708"];
624 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 144709"];
625 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 144710"];
626 [label="param CSharpSyntaxNode(int fullWidth) 144711"];
627 [label="param CSharpSyntaxNode(this) 144712"];
628 [label="kind 144713"];
629 [label="diagnostics 144714"];
630 [label="annotations 144715"];
631 [label="fullWidth 144716"];
632 [label="param CSharpSyntaxNode(this) 144717"];
633 [label="param CSharpSyntaxNode(this) 144718"];
634 [label="GreenStats.NoteGreen(this); 144719"];
635 [label="GreenStats.NoteGreen(this); 144720"];
636 [label="Text 144721"];
637 [label="this.Text 144722"];
638 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144723"];
639 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 144724"];
640 [label="if (!elastic)\n            {\n                return trivia;\n            } 144725"];
641 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144726"];
642 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144727"];
643 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 144728"];
644 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144729"];
645 [label="this.Kind 144730"];
646 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 144731"];
647 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 144732"];
648 [label="param SyntaxTrivia(this) 144733"];
649 [label="param SyntaxTrivia(this) 144734"];
650 [label="param CSharpSyntaxNode(this) 144735"];
651 [label="param CSharpSyntaxNode(this) 144736"];
652 [label="GreenStats.NoteGreen(this); 144737"];
653 [label="Text 144738"];
654 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144739"];
655 [label="ElasticCarriageReturn = EndOfLine('\\r', elastic: true) 144740"];
656 [label="' ' 144741"];
657 [label="true 144742"];
658 [label="elastic: true 144743"];
659 [label="Whitespace(' ', elastic: true) 144744"];
660 [label="param Whitespace(string text) 144745"];
661 [label="param Whitespace(bool elastic = false) 144746"];
662 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 144747"];
663 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 144748"];
664 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 144749"];
665 [label="param Create(SyntaxKind kind) 144750"];
666 [label="param Create(string text) 144751"];
667 [label="return new SyntaxTrivia(kind, text); 144752"];
668 [label="return new SyntaxTrivia(kind, text); 144753"];
669 [label="return new SyntaxTrivia(kind, text); 144754"];
670 [label="new SyntaxTrivia(kind, text) 144755"];
671 [label="param SyntaxTrivia(SyntaxKind kind) 144756"];
672 [label="param SyntaxTrivia(string text) 144757"];
673 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 144758"];
674 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 144759"];
675 [label="param SyntaxTrivia(this) 144760"];
676 [label="kind 144761"];
677 [label="diagnostics 144762"];
678 [label="annotations 144763"];
679 [label="text 144764"];
680 [label="param SyntaxTrivia(this) 144765"];
681 [label="param CSharpSyntaxNode(SyntaxKind kind) 144766"];
682 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 144767"];
683 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 144768"];
684 [label="param CSharpSyntaxNode(int fullWidth) 144769"];
685 [label="param CSharpSyntaxNode(this) 144770"];
686 [label="kind 144771"];
687 [label="diagnostics 144772"];
688 [label="annotations 144773"];
689 [label="fullWidth 144774"];
690 [label="param CSharpSyntaxNode(this) 144775"];
691 [label="param CSharpSyntaxNode(this) 144776"];
692 [label="GreenStats.NoteGreen(this); 144777"];
693 [label="GreenStats.NoteGreen(this); 144778"];
694 [label="Text 144779"];
695 [label="this.Text 144780"];
696 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144781"];
697 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 144782"];
698 [label="if (!elastic)\n            {\n                return trivia;\n            } 144783"];
699 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144784"];
700 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144785"];
701 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 144786"];
702 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144787"];
703 [label="this.Kind 144788"];
704 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 144789"];
705 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 144790"];
706 [label="param SyntaxTrivia(this) 144791"];
707 [label="param SyntaxTrivia(this) 144792"];
708 [label="param CSharpSyntaxNode(this) 144793"];
709 [label="param CSharpSyntaxNode(this) 144794"];
710 [label="GreenStats.NoteGreen(this); 144795"];
711 [label="Text 144796"];
712 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144797"];
713 [label="ElasticSpace = Whitespace(' ', elastic: true) 144798"];
714 [label="'\\t' 144799"];
715 [label="true 144800"];
716 [label="elastic: true 144801"];
717 [label="Whitespace('\\t', elastic: true) 144802"];
718 [label="param Whitespace(string text) 144803"];
719 [label="param Whitespace(bool elastic = false) 144804"];
720 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 144805"];
721 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 144806"];
722 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 144807"];
723 [label="param Create(SyntaxKind kind) 144808"];
724 [label="param Create(string text) 144809"];
725 [label="return new SyntaxTrivia(kind, text); 144810"];
726 [label="return new SyntaxTrivia(kind, text); 144811"];
727 [label="return new SyntaxTrivia(kind, text); 144812"];
728 [label="new SyntaxTrivia(kind, text) 144813"];
729 [label="param SyntaxTrivia(SyntaxKind kind) 144814"];
730 [label="param SyntaxTrivia(string text) 144815"];
731 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 144816"];
732 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 144817"];
733 [label="param SyntaxTrivia(this) 144818"];
734 [label="kind 144819"];
735 [label="diagnostics 144820"];
736 [label="annotations 144821"];
737 [label="text 144822"];
738 [label="param SyntaxTrivia(this) 144823"];
739 [label="param CSharpSyntaxNode(SyntaxKind kind) 144824"];
740 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 144825"];
741 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 144826"];
742 [label="param CSharpSyntaxNode(int fullWidth) 144827"];
743 [label="param CSharpSyntaxNode(this) 144828"];
744 [label="kind 144829"];
745 [label="diagnostics 144830"];
746 [label="annotations 144831"];
747 [label="fullWidth 144832"];
748 [label="param CSharpSyntaxNode(this) 144833"];
749 [label="param CSharpSyntaxNode(this) 144834"];
750 [label="GreenStats.NoteGreen(this); 144835"];
751 [label="GreenStats.NoteGreen(this); 144836"];
752 [label="Text 144837"];
753 [label="this.Text 144838"];
754 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144839"];
755 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 144840"];
756 [label="if (!elastic)\n            {\n                return trivia;\n            } 144841"];
757 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144842"];
758 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144843"];
759 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 144844"];
760 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144845"];
761 [label="this.Kind 144846"];
762 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 144847"];
763 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 144848"];
764 [label="param SyntaxTrivia(this) 144849"];
765 [label="param SyntaxTrivia(this) 144850"];
766 [label="param CSharpSyntaxNode(this) 144851"];
767 [label="param CSharpSyntaxNode(this) 144852"];
768 [label="GreenStats.NoteGreen(this); 144853"];
769 [label="Text 144854"];
770 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144855"];
771 [label="ElasticTab = Whitespace('\\t', elastic: true) 144856"];
772 [label="string.Empty 144857"];
773 [label="true 144858"];
774 [label="elastic: true 144859"];
775 [label="Whitespace(string.Empty, elastic: true) 144860"];
776 [label="param Whitespace(string text) 144861"];
777 [label="param Whitespace(bool elastic = false) 144862"];
778 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 144863"];
779 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 144864"];
780 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 144865"];
781 [label="param Create(SyntaxKind kind) 144866"];
782 [label="param Create(string text) 144867"];
783 [label="return new SyntaxTrivia(kind, text); 144868"];
784 [label="return new SyntaxTrivia(kind, text); 144869"];
785 [label="return new SyntaxTrivia(kind, text); 144870"];
786 [label="new SyntaxTrivia(kind, text) 144871"];
787 [label="param SyntaxTrivia(SyntaxKind kind) 144872"];
788 [label="param SyntaxTrivia(string text) 144873"];
789 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 144874"];
790 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 144875"];
791 [label="param SyntaxTrivia(this) 144876"];
792 [label="kind 144877"];
793 [label="diagnostics 144878"];
794 [label="annotations 144879"];
795 [label="text 144880"];
796 [label="param SyntaxTrivia(this) 144881"];
797 [label="param CSharpSyntaxNode(SyntaxKind kind) 144882"];
798 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 144883"];
799 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 144884"];
800 [label="param CSharpSyntaxNode(int fullWidth) 144885"];
801 [label="param CSharpSyntaxNode(this) 144886"];
802 [label="kind 144887"];
803 [label="diagnostics 144888"];
804 [label="annotations 144889"];
805 [label="fullWidth 144890"];
806 [label="param CSharpSyntaxNode(this) 144891"];
807 [label="param CSharpSyntaxNode(this) 144892"];
808 [label="GreenStats.NoteGreen(this); 144893"];
809 [label="GreenStats.NoteGreen(this); 144894"];
810 [label="Text 144895"];
811 [label="this.Text 144896"];
812 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144897"];
813 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 144898"];
814 [label="if (!elastic)\n            {\n                return trivia;\n            } 144899"];
815 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144900"];
816 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144901"];
817 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 144902"];
818 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 144903"];
819 [label="this.Kind 144904"];
820 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 144905"];
821 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 144906"];
822 [label="param SyntaxTrivia(this) 144907"];
823 [label="param SyntaxTrivia(this) 144908"];
824 [label="param CSharpSyntaxNode(this) 144909"];
825 [label="param CSharpSyntaxNode(this) 144910"];
826 [label="GreenStats.NoteGreen(this); 144911"];
827 [label="Text 144912"];
828 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 144913"];
829 [label="ElasticZeroSpace = Whitespace(string.Empty, elastic: true) 144914"];
830 [label="s_xmlCarriageReturnLineFeed 144915"];
831 [label="public static SyntaxTrivia CarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturnLineFeed; 144916"];
832 [label="param operator(SyntaxTrivia trivia) 144917"];
833 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144918"];
834 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144919"];
835 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144920"];
836 [label="public static SyntaxTrivia LineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.LineFeed; 144921"];
837 [label="param operator(SyntaxTrivia trivia) 144922"];
838 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144923"];
839 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144924"];
840 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144925"];
841 [label="public static SyntaxTrivia CarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturn; 144926"];
842 [label="param operator(SyntaxTrivia trivia) 144927"];
843 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144928"];
844 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144929"];
845 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144930"];
846 [label="public static SyntaxTrivia Space { get; } = Syntax.InternalSyntax.SyntaxFactory.Space; 144931"];
847 [label="param operator(SyntaxTrivia trivia) 144932"];
848 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144933"];
849 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144934"];
850 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144935"];
851 [label="public static SyntaxTrivia Tab { get; } = Syntax.InternalSyntax.SyntaxFactory.Tab; 144936"];
852 [label="param operator(SyntaxTrivia trivia) 144937"];
853 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144938"];
854 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144939"];
855 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144940"];
856 [label="public static SyntaxTrivia ElasticCarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturnLineFeed; 144941"];
857 [label="param operator(SyntaxTrivia trivia) 144942"];
858 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144943"];
859 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144944"];
860 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144945"];
861 [label="public static SyntaxTrivia ElasticLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticLineFeed; 144946"];
862 [label="param operator(SyntaxTrivia trivia) 144947"];
863 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144948"];
864 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144949"];
865 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144950"];
866 [label="public static SyntaxTrivia ElasticCarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturn; 144951"];
867 [label="param operator(SyntaxTrivia trivia) 144952"];
868 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144953"];
869 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144954"];
870 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144955"];
871 [label="public static SyntaxTrivia ElasticSpace { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticSpace; 144956"];
872 [label="param operator(SyntaxTrivia trivia) 144957"];
873 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144958"];
874 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144959"];
875 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144960"];
876 [label="public static SyntaxTrivia ElasticTab { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticTab; 144961"];
877 [label="param operator(SyntaxTrivia trivia) 144962"];
878 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144963"];
879 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144964"];
880 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144965"];
881 [label="public static SyntaxTrivia ElasticMarker { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticZeroSpace; 144966"];
882 [label="param operator(SyntaxTrivia trivia) 144967"];
883 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144968"];
884 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144969"];
885 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 144970"];
886 [label="return SyntaxFactory.ParseStatement(text, offset, options); 144971"];
887 [label="return SyntaxFactory.ParseStatement(text, offset, options); 144972"];
888 [label="return SyntaxFactory.ParseStatement(text, offset, options); 144973"];
889 [label="return SyntaxFactory.ParseStatement(text, offset, options); 144974"];
890 [label="SyntaxFactory.ParseStatement(text, offset, options) 144975"];
891 [label="param ParseStatement(string text) 144976"];
892 [label="param ParseStatement(int offset = 0) 144977"];
893 [label="param ParseStatement(ParseOptions? options = null) 144978"];
894 [label="param ParseStatement(bool consumeFullText = true) 144979"];
895 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 144980"];
896 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 144981"];
897 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 144982"];
898 [label="MakeLexer(text, offset, (CSharpParseOptions?)options) 144983"];
899 [label="param MakeLexer(string text) 144984"];
900 [label="param MakeLexer(int offset) 144985"];
901 [label="param MakeLexer(CSharpParseOptions? options = null) 144986"];
902 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 144987"];
903 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 144988"];
904 [label="MakeSourceText(text, offset) 144989"];
905 [label="param MakeSourceText(string text) 144990"];
906 [label="param MakeSourceText(int offset) 144991"];
907 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 144992"];
908 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 144993"];
909 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 144994"];
910 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 144995"];
911 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 144996"];
912 [label="8 144997"];
913 [label="TriviaListInitialCapacity = 8 144998"];
914 [label="TokensLexed 144999"];
915 [label="'<<<<<<<' 145000"];
916 [label="s_conflictMarkerLength = '<<<<<<<'.Length 145001"];
917 [label="42 145002"];
918 [label="MaxCachedTokenSize = 42 145003"];
919 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 145004"];
920 [label="{\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            } 145005"];
921 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 145006"];
922 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 145007"];
923 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 145008"];
924 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 145009"];
925 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 145010"];
926 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 145011"];
927 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 145012"];
928 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 145013"];
929 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 145014"];
930 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 145015"];
931 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 145016"];
932 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 145017"];
933 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 145018"];
934 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 145019"];
935 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 145020"];
936 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 145021"];
937 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 145022"];
938 [label="s_stateTransitions = new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 145023"];
939 [label="new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 145024"];
940 [label="s_charProperties = new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 145025"];
941 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 145026"];
942 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 145027"];
943 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 145028"];
944 [label="new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default) 145029"];
945 [label="param Lexer(SourceText text) 145030"];
946 [label="param Lexer(CSharpParseOptions options) 145031"];
947 [label="param Lexer(bool allowPreprocessorDirectives = true) 145032"];
948 [label="param Lexer(bool interpolationFollowedByColon = false) 145033"];
949 [label="param Lexer(this) 145034"];
950 [label="text 145035"];
951 [label="param Lexer(this) 145036"];
952 [label="param AbstractLexer(SourceText text) 145037"];
953 [label="param AbstractLexer(this) 145038"];
954 [label="TextWindow 145039"];
955 [label="_errors 145040"];
956 [label="InvalidCharacter = char.MaxValue 145041"];
957 [label="2048 145042"];
958 [label="DefaultWindowLength = 2048 145043"];
959 [label="() => new char[DefaultWindowLength] 145044"];
960 [label="new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 145045"];
961 [label="s_windowPool = new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 145046"];
962 [label="this.TextWindow = new SlidingTextWindow(text); 145047"];
963 [label="this.TextWindow = new SlidingTextWindow(text); 145048"];
964 [label="new SlidingTextWindow(text) 145049"];
965 [label="param SlidingTextWindow(SourceText text) 145050"];
966 [label="param SlidingTextWindow(this) 145051"];
967 [label="_text 145052"];
968 [label="_basis 145053"];
969 [label="_offset 145054"];
970 [label="_textEnd 145055"];
971 [label="_characterWindow 145056"];
972 [label="_characterWindowCount 145057"];
973 [label="_lexemeStart 145058"];
974 [label="_strings 145059"];
975 [label="_text 145060"];
976 [label="_basis = 0; 145061"];
977 [label="_basis 145062"];
978 [label="_offset = 0; 145063"];
979 [label="_offset 145064"];
980 [label="_textEnd 145065"];
981 [label="_strings = StringTable.GetInstance(); 145066"];
982 [label="_strings 145067"];
983 [label="_characterWindow = s_windowPool.Allocate(); 145068"];
984 [label="_characterWindow 145069"];
985 [label="_lexemeStart = 0; 145070"];
986 [label="_lexemeStart 145071"];
987 [label="this.TextWindow 145072"];
988 [label="_options 145073"];
989 [label="_mode 145074"];
990 [label="_builder 145075"];
991 [label="_identBuffer 145076"];
992 [label="_identLen 145077"];
993 [label="_cache 145078"];
994 [label="_allowPreprocessorDirectives 145079"];
995 [label="_interpolationFollowedByColon 145080"];
996 [label="_xmlParser 145081"];
997 [label="_badTokenCount 145082"];
998 [label="10 145083"];
999 [label="new SyntaxListBuilder(10) 145084"];
1000 [label="_leadingTriviaCache = new SyntaxListBuilder(10) 145085"];
1001 [label="10 145086"];
1002 [label="new SyntaxListBuilder(10) 145087"];
1003 [label="_trailingTriviaCache = new SyntaxListBuilder(10) 145088"];
1004 [label="_createWhitespaceTriviaFunction 145089"];
1005 [label="_createQuickTokenFunction 145090"];
1006 [label="Debug.Assert(options != null); 145091"];
1007 [label="Debug.Assert(options != null); 145092"];
1008 [label="_options 145093"];
1009 [label="_builder = new StringBuilder(); 145094"];
1010 [label="_builder 145095"];
1011 [label="_identBuffer = new char[32]; 145096"];
1012 [label="_identBuffer 145097"];
1013 [label="512 145098"];
1014 [label="(key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            } 145099"];
1015 [label="CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 145100"];
1016 [label="s_keywordKindPool =\n            CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 145101"];
1017 [label="10 145102"];
1018 [label="MaxKeywordLength = 10 145103"];
1019 [label="_cache = new LexerCache(); 145104"];
1020 [label="new LexerCache() 145105"];
1021 [label="param LexerCache(this) 145106"];
1022 [label="_triviaMap 145107"];
1023 [label="_tokenMap 145108"];
1024 [label="_keywordKindMap 145109"];
1025 [label="_triviaMap = TextKeyedCache<SyntaxTrivia>.GetInstance(); 145110"];
1026 [label="_triviaMap 145111"];
1027 [label="_tokenMap = TextKeyedCache<SyntaxToken>.GetInstance(); 145112"];
1028 [label="_tokenMap 145113"];
1029 [label="_keywordKindMap = s_keywordKindPool.Allocate(); 145114"];
1030 [label="_keywordKindMap 145115"];
1031 [label="_cache 145116"];
1032 [label="_createQuickTokenFunction 145117"];
1033 [label="_allowPreprocessorDirectives 145118"];
1034 [label="_interpolationFollowedByColon 145119"];
1035 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 145120"];
1036 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 145121"];
1037 [label="MakeParser(lexer) 145122"];
1038 [label="param MakeParser(InternalSyntax.Lexer lexer) 145123"];
1039 [label="LastTerminatorState = (int)TerminatorState.IsEndOfRecordSignature 145124"];
1040 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 145125"];
1041 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 145126"];
1042 [label="new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null) 145127"];
1043 [label="param LanguageParser(Lexer lexer) 145128"];
1044 [label="param LanguageParser(CSharp.CSharpSyntaxNode oldTree) 145129"];
1045 [label="param LanguageParser(IEnumerable<TextChangeRange> changes) 145130"];
1046 [label="param LanguageParser(LexerMode lexerMode = LexerMode.Syntax) 145131"];
1047 [label="param LanguageParser(CancellationToken cancellationToken = default(CancellationToken)) 145132"];
1048 [label="param LanguageParser(this) 145133"];
1049 [label="() => new BlendedNode[32] 145134"];
1050 [label="2 145135"];
1051 [label="new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 145136"];
1052 [label="s_blendedNodesPool = new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 145137"];
1053 [label="lexer 145138"];
1054 [label="lexerMode 145139"];
1055 [label="oldTree 145140"];
1056 [label="changes 145141"];
1057 [label="false 145142"];
1058 [label="true 145143"];
1059 [label="cancellationToken 145144"];
1060 [label="param LanguageParser(this) 145145"];
1061 [label="param SyntaxParser(Lexer lexer) 145146"];
1062 [label="param SyntaxParser(LexerMode mode) 145147"];
1063 [label="param SyntaxParser(CSharp.CSharpSyntaxNode oldTree) 145148"];
1064 [label="param SyntaxParser(IEnumerable<TextChangeRange> changes) 145149"];
1065 [label="param SyntaxParser(bool allowModeReset) 145150"];
1066 [label="param SyntaxParser(bool preLexIfNotIncremental = false) 145151"];
1067 [label="param SyntaxParser(CancellationToken cancellationToken = default(CancellationToken)) 145152"];
1068 [label="param SyntaxParser(this) 145153"];
1069 [label="lexer 145154"];
1070 [label="_isIncremental 145155"];
1071 [label="_allowModeReset 145156"];
1072 [label="_mode 145157"];
1073 [label="_currentToken 145158"];
1074 [label="_lexedTokens 145159"];
1075 [label="_prevTokenTrailingTrivia 145160"];
1076 [label="_firstToken 145161"];
1077 [label="_tokenOffset 145162"];
1078 [label="_tokenCount 145163"];
1079 [label="_resetCount 145164"];
1080 [label="_resetStart 145165"];
1081 [label="_blendedTokens 145166"];
1082 [label="this.lexer 145167"];
1083 [label="_mode 145168"];
1084 [label="_allowModeReset 145169"];
1085 [label="this.cancellationToken 145170"];
1086 [label="_currentNode = default(BlendedNode); 145171"];
1087 [label="_currentNode 145172"];
1088 [label="_isIncremental = oldTree != null; 145173"];
1089 [label="_isIncremental = oldTree != null; 145174"];
1090 [label="_isIncremental 145175"];
1091 [label="this.IsIncremental 145176"];
1092 [label="get\n            {\n                return _isIncremental;\n            } 145177"];
1093 [label="return _isIncremental; 145178"];
1094 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 145179"];
1095 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 145180"];
1096 [label="_firstBlender = default(Blender); 145181"];
1097 [label="_firstBlender 145182"];
1098 [label="_lexedTokens = new ArrayElement<SyntaxToken>[32]; 145183"];
1099 [label="_lexedTokens 145184"];
1100 [label="this.IsIncremental 145185"];
1101 [label="get\n            {\n                return _isIncremental;\n            } 145186"];
1102 [label="return _isIncremental; 145187"];
1103 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 145188"];
1104 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 145189"];
1105 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 145190"];
1106 [label="this.PreLex() 145191"];
1107 [label="param PreLex(this) 145192"];
1108 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 145193"];
1109 [label="this.lexer.TextWindow.Text 145194"];
1110 [label="=> _text 145195"];
1111 [label="_text 145196"];
1112 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 145197"];
1113 [label="_lexedTokens = new ArrayElement<SyntaxToken>[size]; 145198"];
1114 [label="_lexedTokens 145199"];
1115 [label="var lexer = this.lexer; 145200"];
1116 [label="var mode = _mode; 145201"];
1117 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 145202"];
1118 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 145203"];
1119 [label="var token = lexer.Lex(mode); 145204"];
1120 [label="lexer.Lex(mode) 145205"];
1121 [label="param Lex(LexerMode mode) 145206"];
1122 [label="param Lex(this) 145207"];
1123 [label="TokensLexed++; 145208"];
1124 [label="_mode 145209"];
1125 [label="switch (_mode)\n            {\n                case LexerMode.Syntax:\n                case LexerMode.DebuggerSyntax:\n                    return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken();\n                case LexerMode.Directive:\n                    return this.LexDirectiveToken();\n            } 145210"];
1126 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 145211"];
1127 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 145212"];
1128 [label="param Start(this) 145213"];
1129 [label="TextWindow.Start() 145214"];
1130 [label="param Start(this) 145215"];
1131 [label="_lexemeStart 145216"];
1132 [label="TextWindow.Start(); 145217"];
1133 [label="_errors = null; 145218"];
1134 [label="_errors 145219"];
1135 [label="get\n            {\n                return _offset;\n            } 145220"];
1136 [label="return _offset; 145221"];
1137 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 145222"];
1138 [label="get\n            {\n                return _characterWindowCount;\n            } 145223"];
1139 [label="return _characterWindowCount; 145224"];
1140 [label="get\n            {\n                return _characterWindow;\n            } 145225"];
1141 [label="return _characterWindow; 145226"];
1142 [label="param AdvanceChar(int n) 145227"];
1143 [label="param AdvanceChar(this) 145228"];
1144 [label="_offset += n; 145229"];
1145 [label="_offset 145230"];
1146 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 145231"];
1147 [label="return _basis + _lexemeStart; 145232"];
1148 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 145233"];
1149 [label="param Reset(int position) 145234"];
1150 [label="param Reset(this) 145235"];
1151 [label="int relative = position - _basis; 145236"];
1152 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 145237"];
1153 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 145238"];
1154 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 145239"];
1155 [label="_offset 145240"];
1156 [label="this.LexSyntaxToken() 145241"];
1157 [label="param LexSyntaxToken(this) 145242"];
1158 [label="_leadingTriviaCache.Clear(); 145243"];
1159 [label="TextWindow.Position 145244"];
1160 [label="get\n            {\n                return _basis + _offset;\n            } 145245"];
1161 [label="return _basis + _offset; 145246"];
1162 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 145247"];
1163 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 145248"];
1164 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 145249"];
1165 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache) 145250"];
1166 [label="param LexSyntaxTrivia(bool afterFirstToken) 145251"];
1167 [label="param LexSyntaxTrivia(bool isTrailing) 145252"];
1168 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 145253"];
1169 [label="param LexSyntaxTrivia(this) 145254"];
1170 [label="bool onlyWhitespaceOnLine = !isTrailing; 145255"];
1171 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 145256"];
1172 [label="this.Start() 145257"];
1173 [label="param Start(this) 145258"];
1174 [label="TextWindow.Start() 145259"];
1175 [label="param Start(this) 145260"];
1176 [label="TextWindow.Start(); 145261"];
1177 [label="_errors = null; 145262"];
1178 [label="_errors 145263"];
1179 [label="this.Start(); 145264"];
1180 [label="TextWindow.PeekChar() 145265"];
1181 [label="param PeekChar(this) 145266"];
1182 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 145267"];
1183 [label="MoreChars() 145268"];
1184 [label="param MoreChars(this) 145269"];
1185 [label="if (_offset >= _characterWindowCount)\n            {\n                if (this.Position >= _textEnd)\n                {\n                    return false;\n                }\n\n                // if lexeme scanning is sufficiently into the char buffer, \n                // then refocus the window onto the lexeme\n                if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                }\n\n                if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                }\n\n                int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount);\n                _text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead);\n                _characterWindowCount += amountToRead;\n                return amountToRead > 0;\n            } 145270"];
1186 [label="this.Position 145271"];
1187 [label="get\n            {\n                return _basis + _offset;\n            } 145272"];
1188 [label="return _basis + _offset; 145273"];
1189 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 145274"];
1190 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 145275"];
1191 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 145276"];
1192 [label="if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                } 145277"];
1193 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 145278"];
1194 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 145279"];
1195 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 145280"];
1196 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 145281"];
1197 [label="_characterWindowCount += amountToRead; 145282"];
1198 [label="_characterWindowCount 145283"];
1199 [label="return amountToRead > 0; 145284"];
1200 [label="return amountToRead > 0; 145285"];
1201 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 145286"];
1202 [label="return _characterWindow[_offset]; 145287"];
1203 [label="char ch = TextWindow.PeekChar(); 145288"];
1204 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 145289"];
1205 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 145290"];
1206 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 145291"];
1207 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 145292"];
1208 [label="return; 145293"];
1209 [label="var leading = _leadingTriviaCache; 145294"];
1210 [label="var tokenInfo = default(TokenInfo); 145295"];
1211 [label="this.Start() 145296"];
1212 [label="param Start(this) 145297"];
1213 [label="TextWindow.Start() 145298"];
1214 [label="param Start(this) 145299"];
1215 [label="TextWindow.Start(); 145300"];
1216 [label="_errors = null; 145301"];
1217 [label="_errors 145302"];
1218 [label="this.Start(); 145303"];
1219 [label="this.ScanSyntaxToken(ref tokenInfo); 145304"];
1220 [label="this.ScanSyntaxToken(ref tokenInfo); 145305"];
1221 [label="this.ScanSyntaxToken(ref tokenInfo); 145306"];
1222 [label="get\n            {\n                return _basis + _offset;\n            } 145307"];
1223 [label="return _basis + _offset; 145308"];
1224 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 145309"];
1225 [label="return _characterWindow[_offset]; 145310"];
1226 [label="param ScanIdentifierOrKeyword(ref TokenInfo info) 145311"];
1227 [label="param ScanIdentifierOrKeyword(this) 145312"];
1228 [label="info.ContextualKind 145313"];
1229 [label="if (this.ScanIdentifier(ref info))\n            {\n                // check to see if it is an actual keyword\n                if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                }\n\n                return true;\n            }\n            else\n            {\n                info.Kind = SyntaxKind.None;\n                return false;\n            } 145314"];
1230 [label="this.ScanIdentifier(ref info) 145315"];
1231 [label="param ScanIdentifier(ref TokenInfo info) 145316"];
1232 [label="param ScanIdentifier(this) 145317"];
1233 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 145318"];
1234 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 145319"];
1235 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 145320"];
1236 [label="param Intern(char[] array) 145321"];
1237 [label="param Intern(int start) 145322"];
1238 [label="param Intern(int length) 145323"];
1239 [label="param Intern(this) 145324"];
1240 [label="return _strings.Add(array, start, length); 145325"];
1241 [label="return _strings.Add(array, start, length); 145326"];
1242 [label="return _strings.Add(array, start, length); 145327"];
1243 [label="return _strings.Add(array, start, length); 145328"];
1244 [label="if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                } 145329"];
1245 [label="if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    } 145330"];
1246 [label="this.ModeIs(LexerMode.Directive) 145331"];
1247 [label="param ModeIs(LexerMode mode) 145332"];
1248 [label="param ModeIs(this) 145333"];
1249 [label="return ModeOf(_mode) == mode; 145334"];
1250 [label="ModeOf(_mode) 145335"];
1251 [label="param ModeOf(LexerMode mode) 145336"];
1252 [label="return mode & LexerMode.MaskLexMode; 145337"];
1253 [label="return ModeOf(_mode) == mode; 145338"];
1254 [label="if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 145339"];
1255 [label="_cache.TryGetKeywordKind(info.Text, out info.Kind) 145340"];
1256 [label="param TryGetKeywordKind(string key) 145341"];
1257 [label="param TryGetKeywordKind(out SyntaxKind kind) 145342"];
1258 [label="param TryGetKeywordKind(this) 145343"];
1259 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 145344"];
1260 [label="new SyntaxKindEqualityComparer() 145345"];
1261 [label="param SyntaxKindEqualityComparer(this) 145346"];
1262 [label="public static IEqualityComparer<SyntaxKind> EqualityComparer { get; } = new SyntaxKindEqualityComparer(); 145347"];
1263 [label="kind = _keywordKindMap.GetOrMakeValue(key); 145348"];
1264 [label="kind = _keywordKindMap.GetOrMakeValue(key); 145349"];
1265 [label="kind = _keywordKindMap.GetOrMakeValue(key); 145350"];
1266 [label="param GetKeywordKind(string text) 145351"];
1267 [label="switch (text)\n            {\n                case 'bool':\n                    return SyntaxKind.BoolKeyword;\n                case 'byte':\n                    return SyntaxKind.ByteKeyword;\n                case 'sbyte':\n                    return SyntaxKind.SByteKeyword;\n                case 'short':\n                    return SyntaxKind.ShortKeyword;\n                case 'ushort':\n                    return SyntaxKind.UShortKeyword;\n                case 'int':\n                    return SyntaxKind.IntKeyword;\n                case 'uint':\n                    return SyntaxKind.UIntKeyword;\n                case 'long':\n                    return SyntaxKind.LongKeyword;\n                case 'ulong':\n                    return SyntaxKind.ULongKeyword;\n                case 'double':\n                    return SyntaxKind.DoubleKeyword;\n                case 'float':\n                    return SyntaxKind.FloatKeyword;\n                case 'decimal':\n                    return SyntaxKind.DecimalKeyword;\n                case 'string':\n                    return SyntaxKind.StringKeyword;\n                case 'char':\n                    return SyntaxKind.CharKeyword;\n                case 'void':\n                    return SyntaxKind.VoidKeyword;\n                case 'object':\n                    return SyntaxKind.ObjectKeyword;\n                case 'typeof':\n                    return SyntaxKind.TypeOfKeyword;\n                case 'sizeof':\n                    return SyntaxKind.SizeOfKeyword;\n                case 'null':\n                    return SyntaxKind.NullKeyword;\n                case 'true':\n                    return SyntaxKind.TrueKeyword;\n                case 'false':\n                    return SyntaxKind.FalseKeyword;\n                case 'if':\n                    return SyntaxKind.IfKeyword;\n                case 'else':\n                    return SyntaxKind.ElseKeyword;\n                case 'while':\n                    return SyntaxKind.WhileKeyword;\n                case 'for':\n                    return SyntaxKind.ForKeyword;\n                case 'foreach':\n                    return SyntaxKind.ForEachKeyword;\n                case 'do':\n                    return SyntaxKind.DoKeyword;\n                case 'switch':\n                    return SyntaxKind.SwitchKeyword;\n                case 'case':\n                    return SyntaxKind.CaseKeyword;\n                case 'default':\n                    return SyntaxKind.DefaultKeyword;\n                case 'lock':\n                    return SyntaxKind.LockKeyword;\n                case 'try':\n                    return SyntaxKind.TryKeyword;\n                case 'throw':\n                    return SyntaxKind.ThrowKeyword;\n                case 'catch':\n                    return SyntaxKind.CatchKeyword;\n                case 'finally':\n                    return SyntaxKind.FinallyKeyword;\n                case 'goto':\n                    return SyntaxKind.GotoKeyword;\n                case 'break':\n                    return SyntaxKind.BreakKeyword;\n                case 'continue':\n                    return SyntaxKind.ContinueKeyword;\n                case 'return':\n                    return SyntaxKind.ReturnKeyword;\n                case 'public':\n                    return SyntaxKind.PublicKeyword;\n                case 'private':\n                    return SyntaxKind.PrivateKeyword;\n                case 'internal':\n                    return SyntaxKind.InternalKeyword;\n                case 'protected':\n                    return SyntaxKind.ProtectedKeyword;\n                case 'static':\n                    return SyntaxKind.StaticKeyword;\n                case 'readonly':\n                    return SyntaxKind.ReadOnlyKeyword;\n                case 'sealed':\n                    return SyntaxKind.SealedKeyword;\n                case 'const':\n                    return SyntaxKind.ConstKeyword;\n                case 'fixed':\n                    return SyntaxKind.FixedKeyword;\n                case 'stackalloc':\n                    return SyntaxKind.StackAllocKeyword;\n                case 'volatile':\n                    return SyntaxKind.VolatileKeyword;\n                case 'new':\n                    return SyntaxKind.NewKeyword;\n                case 'override':\n                    return SyntaxKind.OverrideKeyword;\n                case 'abstract':\n                    return SyntaxKind.AbstractKeyword;\n                case 'virtual':\n                    return SyntaxKind.VirtualKeyword;\n                case 'event':\n                    return SyntaxKind.EventKeyword;\n                case 'extern':\n                    return SyntaxKind.ExternKeyword;\n                case 'ref':\n                    return SyntaxKind.RefKeyword;\n                case 'out':\n                    return SyntaxKind.OutKeyword;\n                case 'in':\n                    return SyntaxKind.InKeyword;\n                case 'is':\n                    return SyntaxKind.IsKeyword;\n                case 'as':\n                    return SyntaxKind.AsKeyword;\n                case 'params':\n                    return SyntaxKind.ParamsKeyword;\n                case '__arglist':\n                    return SyntaxKind.ArgListKeyword;\n                case '__makeref':\n                    return SyntaxKind.MakeRefKeyword;\n                case '__reftype':\n                    return SyntaxKind.RefTypeKeyword;\n                case '__refvalue':\n                    return SyntaxKind.RefValueKeyword;\n                case 'this':\n                    return SyntaxKind.ThisKeyword;\n                case 'base':\n                    return SyntaxKind.BaseKeyword;\n                case 'namespace':\n                    return SyntaxKind.NamespaceKeyword;\n                case 'using':\n                    return SyntaxKind.UsingKeyword;\n                case 'class':\n                    return SyntaxKind.ClassKeyword;\n                case 'struct':\n                    return SyntaxKind.StructKeyword;\n                case 'interface':\n                    return SyntaxKind.InterfaceKeyword;\n                case 'enum':\n                    return SyntaxKind.EnumKeyword;\n                case 'delegate':\n                    return SyntaxKind.DelegateKeyword;\n                case 'checked':\n                    return SyntaxKind.CheckedKeyword;\n                case 'unchecked':\n                    return SyntaxKind.UncheckedKeyword;\n                case 'unsafe':\n                    return SyntaxKind.UnsafeKeyword;\n                case 'operator':\n                    return SyntaxKind.OperatorKeyword;\n                case 'implicit':\n                    return SyntaxKind.ImplicitKeyword;\n                case 'explicit':\n                    return SyntaxKind.ExplicitKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 145352"];
1268 [label="return SyntaxKind.SwitchKeyword; 145353"];
1269 [label="return kind != SyntaxKind.None; 145354"];
1270 [label="if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 145355"];
1271 [label="SyntaxFacts.IsContextualKeyword(info.Kind) 145356"];
1272 [label="param IsContextualKeyword(SyntaxKind kind) 145357"];
1273 [label="switch (kind)\n            {\n                case SyntaxKind.YieldKeyword:\n                case SyntaxKind.PartialKeyword:\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.LetKeyword:\n                case SyntaxKind.ByKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                case SyntaxKind.AddKeyword:\n                case SyntaxKind.RemoveKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.AliasKeyword:\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.AssemblyKeyword:\n                case SyntaxKind.ModuleKeyword:\n                case SyntaxKind.TypeKeyword:\n                case SyntaxKind.GlobalKeyword:\n                case SyntaxKind.FieldKeyword:\n                case SyntaxKind.MethodKeyword:\n                case SyntaxKind.ParamKeyword:\n                case SyntaxKind.PropertyKeyword:\n                case SyntaxKind.TypeVarKeyword:\n                case SyntaxKind.NameOfKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.AwaitKeyword:\n                case SyntaxKind.WhenKeyword:\n                case SyntaxKind.UnderscoreToken:\n                case SyntaxKind.VarKeyword:\n                case SyntaxKind.OrKeyword:\n                case SyntaxKind.AndKeyword:\n                case SyntaxKind.NotKeyword:\n                case SyntaxKind.DataKeyword:\n                case SyntaxKind.WithKeyword:\n                case SyntaxKind.InitKeyword:\n                case SyntaxKind.RecordKeyword:\n                case SyntaxKind.ManagedKeyword:\n                case SyntaxKind.UnmanagedKeyword:\n                    return true;\n                default:\n                    return false;\n            } 145358"];
1274 [label="return false; 145359"];
1275 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 145360"];
1276 [label="return true; 145361"];
1277 [label="this.ScanSyntaxToken(ref tokenInfo); 145362"];
1278 [label="var errors = this.GetErrors(GetFullWidth(leading)); 145363"];
1279 [label="GetFullWidth(leading) 145364"];
1280 [label="param GetFullWidth(SyntaxListBuilder builder) 145365"];
1281 [label="int width = 0; 145366"];
1282 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 145367"];
1283 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 145368"];
1284 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 145369"];
1285 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 145370"];
1286 [label="return width; 145371"];
1287 [label="var errors = this.GetErrors(GetFullWidth(leading)); 145372"];
1288 [label="this.GetErrors(GetFullWidth(leading)) 145373"];
1289 [label="param GetErrors(int leadingTriviaWidth) 145374"];
1290 [label="param GetErrors(this) 145375"];
1291 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 145376"];
1292 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 145377"];
1293 [label="return null; 145378"];
1294 [label="var errors = this.GetErrors(GetFullWidth(leading)); 145379"];
1295 [label="_trailingTriviaCache.Clear(); 145380"];
1296 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 145381"];
1297 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 145382"];
1298 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache) 145383"];
1299 [label="param LexSyntaxTrivia(bool afterFirstToken) 145384"];
1300 [label="param LexSyntaxTrivia(bool isTrailing) 145385"];
1301 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 145386"];
1302 [label="param LexSyntaxTrivia(this) 145387"];
1303 [label="bool onlyWhitespaceOnLine = !isTrailing; 145388"];
1304 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 145389"];
1305 [label="this.Start() 145390"];
1306 [label="param Start(this) 145391"];
1307 [label="TextWindow.Start() 145392"];
1308 [label="param Start(this) 145393"];
1309 [label="TextWindow.Start(); 145394"];
1310 [label="_errors = null; 145395"];
1311 [label="_errors 145396"];
1312 [label="this.Start(); 145397"];
1313 [label="TextWindow.PeekChar() 145398"];
1314 [label="param PeekChar(this) 145399"];
1315 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 145400"];
1316 [label="char ch = TextWindow.PeekChar(); 145401"];
1317 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 145402"];
1318 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 145403"];
1319 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 145404"];
1320 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 145405"];
1321 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 145406"];
1322 [label="param AdvanceChar(this) 145407"];
1323 [label="_offset 145408"];
1324 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 145409"];
1325 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 145410"];
1326 [label="return _offset - _lexemeStart; 145411"];
1327 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 145412"];
1328 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList) 145413"];
1329 [label="param AddTrivia(CSharpSyntaxNode trivia) 145414"];
1330 [label="param AddTrivia(ref SyntaxListBuilder list) 145415"];
1331 [label="param AddTrivia(this) 145416"];
1332 [label="this.HasErrors 145417"];
1333 [label="get { return _errors != null; } 145418"];
1334 [label="return _errors != null; 145419"];
1335 [label="return _errors != null; 145420"];
1336 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 145421"];
1337 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 145422"];
1338 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 145423"];
1339 [label="list.Add(trivia); 145424"];
1340 [label="list.Add(trivia); 145425"];
1341 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 145426"];
1342 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 145427"];
1343 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 145428"];
1344 [label="return; 145429"];
1345 [label="var trailing = _trailingTriviaCache; 145430"];
1346 [label="return Create(ref tokenInfo, leading, trailing, errors); 145431"];
1347 [label="return Create(ref tokenInfo, leading, trailing, errors); 145432"];
1348 [label="return Create(ref tokenInfo, leading, trailing, errors); 145433"];
1349 [label="return Create(ref tokenInfo, leading, trailing, errors); 145434"];
1350 [label="Create(ref tokenInfo, leading, trailing, errors) 145435"];
1351 [label="param Create(ref TokenInfo info) 145436"];
1352 [label="param Create(SyntaxListBuilder leading) 145437"];
1353 [label="param Create(SyntaxListBuilder trailing) 145438"];
1354 [label="param Create(SyntaxDiagnosticInfo[] errors) 145439"];
1355 [label="param Create(this) 145440"];
1356 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 145441"];
1357 [label="var leadingNode = leading?.ToListNode(); 145442"];
1358 [label="var trailingNode = trailing?.ToListNode(); 145443"];
1359 [label="SyntaxToken token; 145444"];
1360 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 145445"];
1361 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 145446"];
1362 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 145447"];
1363 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 145448"];
1364 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 145449"];
1365 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 145450"];
1366 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 145451"];
1367 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 145452"];
1368 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 145453"];
1369 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 145454"];
1370 [label="param Token(GreenNode leading) 145455"];
1371 [label="param Token(SyntaxKind kind) 145456"];
1372 [label="param Token(GreenNode trailing) 145457"];
1373 [label="FirstTokenWithWellKnownText = SyntaxKind.TildeToken 145458"];
1374 [label="LastTokenWithWellKnownText = SyntaxKind.EndOfFileToken 145459"];
1375 [label="1 145460"];
1376 [label="(int)LastTokenWithWellKnownText + 1 145461"];
1377 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 145462"];
1378 [label="s_tokensWithNoTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 145463"];
1379 [label="1 145464"];
1380 [label="(int)LastTokenWithWellKnownText + 1 145465"];
1381 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 145466"];
1382 [label="s_tokensWithElasticTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 145467"];
1383 [label="1 145468"];
1384 [label="(int)LastTokenWithWellKnownText + 1 145469"];
1385 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 145470"];
1386 [label="s_tokensWithSingleTrailingSpace = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 145471"];
1387 [label="1 145472"];
1388 [label="(int)LastTokenWithWellKnownText + 1 145473"];
1389 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 145474"];
1390 [label="s_tokensWithSingleTrailingCRLF = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 145475"];
1391 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxToken), r => new SyntaxToken(r)); 145476"];
1392 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 145477"];
1393 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 145478"];
1394 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 145479"];
1395 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 145480"];
1396 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 145481"];
1397 [label="new SyntaxToken(kind) 145482"];
1398 [label="param SyntaxToken(SyntaxKind kind) 145483"];
1399 [label="param SyntaxToken(this) 145484"];
1400 [label="kind 145485"];
1401 [label="param SyntaxToken(this) 145486"];
1402 [label="param CSharpSyntaxNode(SyntaxKind kind) 145487"];
1403 [label="param CSharpSyntaxNode(this) 145488"];
1404 [label="kind 145489"];
1405 [label="param CSharpSyntaxNode(this) 145490"];
1406 [label="param CSharpSyntaxNode(this) 145491"];
1407 [label="GreenStats.NoteGreen(this); 145492"];
1408 [label="GreenStats.NoteGreen(this); 145493"];
1409 [label="this.Text 145494"];
1410 [label="get { return SyntaxFacts.GetText(this.Kind); } 145495"];
1411 [label="this.Kind 145496"];
1412 [label="get { return (SyntaxKind)this.RawKind; } 145497"];
1413 [label="return (SyntaxKind)this.RawKind; 145498"];
1414 [label="return SyntaxFacts.GetText(this.Kind); 145499"];
1415 [label="SyntaxFacts.GetText(this.Kind) 145500"];
1416 [label="param GetText(SyntaxKind kind) 145501"];
1417 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 145502"];
1418 [label="return '~'; 145503"];
1419 [label="FullWidth = this.Text.Length; 145504"];
1420 [label="FullWidth 145505"];
1421 [label="this.flags |= NodeFlags.IsNotMissing; 145506"];
1422 [label="this.flags 145507"];
1423 [label="s_tokensWithNoTrivia[(int)kind].Value 145508"];
1424 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithTrivia), r => new SyntaxTokenWithTrivia(r)); 145509"];
1425 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 145510"];
1426 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 145511"];
1427 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 145512"];
1428 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 145513"];
1429 [label="new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace) 145514"];
1430 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 145515"];
1431 [label="param SyntaxTokenWithTrivia(GreenNode leading) 145516"];
1432 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 145517"];
1433 [label="param SyntaxTokenWithTrivia(this) 145518"];
1434 [label="kind 145519"];
1435 [label="param SyntaxTokenWithTrivia(this) 145520"];
1436 [label="param SyntaxToken(SyntaxKind kind) 145521"];
1437 [label="param SyntaxToken(this) 145522"];
1438 [label="kind 145523"];
1439 [label="param SyntaxToken(this) 145524"];
1440 [label="param CSharpSyntaxNode(SyntaxKind kind) 145525"];
1441 [label="param CSharpSyntaxNode(this) 145526"];
1442 [label="kind 145527"];
1443 [label="param CSharpSyntaxNode(this) 145528"];
1444 [label="param CSharpSyntaxNode(this) 145529"];
1445 [label="GreenStats.NoteGreen(this); 145530"];
1446 [label="GreenStats.NoteGreen(this); 145531"];
1447 [label="this.Text 145532"];
1448 [label="get { return SyntaxFacts.GetText(this.Kind); } 145533"];
1449 [label="this.Kind 145534"];
1450 [label="get { return (SyntaxKind)this.RawKind; } 145535"];
1451 [label="return (SyntaxKind)this.RawKind; 145536"];
1452 [label="return SyntaxFacts.GetText(this.Kind); 145537"];
1453 [label="SyntaxFacts.GetText(this.Kind) 145538"];
1454 [label="param GetText(SyntaxKind kind) 145539"];
1455 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 145540"];
1456 [label="return '~'; 145541"];
1457 [label="FullWidth = this.Text.Length; 145542"];
1458 [label="FullWidth 145543"];
1459 [label="this.flags |= NodeFlags.IsNotMissing; 145544"];
1460 [label="this.flags 145545"];
1461 [label="LeadingField 145546"];
1462 [label="TrailingField 145547"];
1463 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 145548"];
1464 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 145549"];
1465 [label="this.AdjustFlagsAndWidth(leading); 145550"];
1466 [label="this.AdjustFlagsAndWidth(leading); 145551"];
1467 [label="this.LeadingField 145552"];
1468 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 145553"];
1469 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 145554"];
1470 [label="this.AdjustFlagsAndWidth(trailing); 145555"];
1471 [label="this.AdjustFlagsAndWidth(trailing); 145556"];
1472 [label="this.TrailingField 145557"];
1473 [label="s_tokensWithElasticTrivia[(int)kind].Value 145558"];
1474 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 145559"];
1475 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 145560"];
1476 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 145561"];
1477 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 145562"];
1478 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space) 145563"];
1479 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 145564"];
1480 [label="param SyntaxTokenWithTrivia(GreenNode leading) 145565"];
1481 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 145566"];
1482 [label="param SyntaxTokenWithTrivia(this) 145567"];
1483 [label="kind 145568"];
1484 [label="param SyntaxTokenWithTrivia(this) 145569"];
1485 [label="param SyntaxToken(SyntaxKind kind) 145570"];
1486 [label="param SyntaxToken(this) 145571"];
1487 [label="kind 145572"];
1488 [label="param SyntaxToken(this) 145573"];
1489 [label="param CSharpSyntaxNode(SyntaxKind kind) 145574"];
1490 [label="param CSharpSyntaxNode(this) 145575"];
1491 [label="kind 145576"];
1492 [label="param CSharpSyntaxNode(this) 145577"];
1493 [label="param CSharpSyntaxNode(this) 145578"];
1494 [label="GreenStats.NoteGreen(this); 145579"];
1495 [label="GreenStats.NoteGreen(this); 145580"];
1496 [label="this.Text 145581"];
1497 [label="get { return SyntaxFacts.GetText(this.Kind); } 145582"];
1498 [label="this.Kind 145583"];
1499 [label="get { return (SyntaxKind)this.RawKind; } 145584"];
1500 [label="return (SyntaxKind)this.RawKind; 145585"];
1501 [label="return SyntaxFacts.GetText(this.Kind); 145586"];
1502 [label="SyntaxFacts.GetText(this.Kind) 145587"];
1503 [label="param GetText(SyntaxKind kind) 145588"];
1504 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 145589"];
1505 [label="return '~'; 145590"];
1506 [label="FullWidth = this.Text.Length; 145591"];
1507 [label="FullWidth 145592"];
1508 [label="this.flags |= NodeFlags.IsNotMissing; 145593"];
1509 [label="this.flags 145594"];
1510 [label="LeadingField 145595"];
1511 [label="TrailingField 145596"];
1512 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 145597"];
1513 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 145598"];
1514 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 145599"];
1515 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 145600"];
1516 [label="this.AdjustFlagsAndWidth(trailing); 145601"];
1517 [label="this.AdjustFlagsAndWidth(trailing); 145602"];
1518 [label="this.TrailingField 145603"];
1519 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 145604"];
1520 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 145605"];
1521 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 145606"];
1522 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 145607"];
1523 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 145608"];
1524 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed) 145609"];
1525 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 145610"];
1526 [label="param SyntaxTokenWithTrivia(GreenNode leading) 145611"];
1527 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 145612"];
1528 [label="param SyntaxTokenWithTrivia(this) 145613"];
1529 [label="kind 145614"];
1530 [label="param SyntaxTokenWithTrivia(this) 145615"];
1531 [label="param SyntaxToken(SyntaxKind kind) 145616"];
1532 [label="param SyntaxToken(this) 145617"];
1533 [label="kind 145618"];
1534 [label="param SyntaxToken(this) 145619"];
1535 [label="param CSharpSyntaxNode(SyntaxKind kind) 145620"];
1536 [label="param CSharpSyntaxNode(this) 145621"];
1537 [label="kind 145622"];
1538 [label="param CSharpSyntaxNode(this) 145623"];
1539 [label="param CSharpSyntaxNode(this) 145624"];
1540 [label="GreenStats.NoteGreen(this); 145625"];
1541 [label="GreenStats.NoteGreen(this); 145626"];
1542 [label="this.Text 145627"];
1543 [label="get { return SyntaxFacts.GetText(this.Kind); } 145628"];
1544 [label="this.Kind 145629"];
1545 [label="get { return (SyntaxKind)this.RawKind; } 145630"];
1546 [label="return (SyntaxKind)this.RawKind; 145631"];
1547 [label="return SyntaxFacts.GetText(this.Kind); 145632"];
1548 [label="SyntaxFacts.GetText(this.Kind) 145633"];
1549 [label="param GetText(SyntaxKind kind) 145634"];
1550 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 145635"];
1551 [label="return '~'; 145636"];
1552 [label="FullWidth = this.Text.Length; 145637"];
1553 [label="FullWidth 145638"];
1554 [label="this.flags |= NodeFlags.IsNotMissing; 145639"];
1555 [label="this.flags 145640"];
1556 [label="LeadingField 145641"];
1557 [label="TrailingField 145642"];
1558 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 145643"];
1559 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 145644"];
1560 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 145645"];
1561 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 145646"];
1562 [label="this.AdjustFlagsAndWidth(trailing); 145647"];
1563 [label="this.AdjustFlagsAndWidth(trailing); 145648"];
1564 [label="this.TrailingField 145649"];
1565 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 145650"];
1566 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 145651"];
1567 [label="param SyntaxToken(SyntaxKind kind) 145652"];
1568 [label="kind 145653"];
1569 [label="param CSharpSyntaxNode(SyntaxKind kind) 145654"];
1570 [label="kind 145655"];
1571 [label="param CSharpSyntaxNode(this) 145656"];
1572 [label="GreenStats.NoteGreen(this); 145657"];
1573 [label="return (SyntaxKind)this.RawKind; 145658"];
1574 [label="return SyntaxFacts.GetText(this.Kind); 145659"];
1575 [label="param GetText(SyntaxKind kind) 145660"];
1576 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 145661"];
1577 [label="return '!'; 145662"];
1578 [label="FullWidth = this.Text.Length; 145663"];
1579 [label="FullWidth 145664"];
1580 [label="this.flags |= NodeFlags.IsNotMissing; 145665"];
1581 [label="this.flags 145666"];
1582 [label="s_tokensWithNoTrivia[(int)kind].Value 145667"];
1583 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 145668"];
1584 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 145669"];
1585 [label="kind 145670"];
1586 [label="param SyntaxToken(SyntaxKind kind) 145671"];
1587 [label="kind 145672"];
1588 [label="param CSharpSyntaxNode(SyntaxKind kind) 145673"];
1589 [label="kind 145674"];
1590 [label="param CSharpSyntaxNode(this) 145675"];
1591 [label="GreenStats.NoteGreen(this); 145676"];
1592 [label="return (SyntaxKind)this.RawKind; 145677"];
1593 [label="return SyntaxFacts.GetText(this.Kind); 145678"];
1594 [label="param GetText(SyntaxKind kind) 145679"];
1595 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 145680"];
1596 [label="return '!'; 145681"];
1597 [label="FullWidth = this.Text.Length; 145682"];
1598 [label="FullWidth 145683"];
1599 [label="this.flags |= NodeFlags.IsNotMissing; 145684"];
1600 [label="this.flags 145685"];
1601 [label="this.AdjustFlagsAndWidth(leading); 145686"];
1602 [label="s_tokensWithElasticTrivia[(int)kind].Value 145687"];
1603 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 145688"];
1604 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 145689"];
1605 [label="kind 145690"];
1606 [label="param SyntaxToken(SyntaxKind kind) 145691"];
1607 [label="kind 145692"];
1608 [label="param CSharpSyntaxNode(SyntaxKind kind) 145693"];
1609 [label="kind 145694"];
1610 [label="param CSharpSyntaxNode(this) 145695"];
1611 [label="GreenStats.NoteGreen(this); 145696"];
1612 [label="return (SyntaxKind)this.RawKind; 145697"];
1613 [label="return SyntaxFacts.GetText(this.Kind); 145698"];
1614 [label="param GetText(SyntaxKind kind) 145699"];
1615 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 145700"];
1616 [label="return '!'; 145701"];
1617 [label="FullWidth = this.Text.Length; 145702"];
1618 [label="FullWidth 145703"];
1619 [label="this.flags |= NodeFlags.IsNotMissing; 145704"];
1620 [label="this.flags 145705"];
1621 [label="this.AdjustFlagsAndWidth(trailing); 145706"];
1622 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 145707"];
1623 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 145708"];
1624 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 145709"];
1625 [label="kind 145710"];
1626 [label="param SyntaxToken(SyntaxKind kind) 145711"];
1627 [label="kind 145712"];
1628 [label="param CSharpSyntaxNode(SyntaxKind kind) 145713"];
1629 [label="kind 145714"];
1630 [label="param CSharpSyntaxNode(this) 145715"];
1631 [label="GreenStats.NoteGreen(this); 145716"];
1632 [label="return (SyntaxKind)this.RawKind; 145717"];
1633 [label="return SyntaxFacts.GetText(this.Kind); 145718"];
1634 [label="param GetText(SyntaxKind kind) 145719"];
1635 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 145720"];
1636 [label="return '!'; 145721"];
1637 [label="FullWidth = this.Text.Length; 145722"];
1638 [label="FullWidth 145723"];
1639 [label="this.flags |= NodeFlags.IsNotMissing; 145724"];
1640 [label="this.flags 145725"];
1641 [label="this.AdjustFlagsAndWidth(trailing); 145726"];
1642 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 145727"];
1643 [label="return '$'; 145728"];
1644 [label="FullWidth = this.Text.Length; 145729"];
1645 [label="FullWidth 145730"];
1646 [label="return '$'; 145731"];
1647 [label="FullWidth = this.Text.Length; 145732"];
1648 [label="FullWidth 145733"];
1649 [label="this.AdjustFlagsAndWidth(leading); 145734"];
1650 [label="return '$'; 145735"];
1651 [label="FullWidth = this.Text.Length; 145736"];
1652 [label="FullWidth 145737"];
1653 [label="this.AdjustFlagsAndWidth(trailing); 145738"];
1654 [label="return '$'; 145739"];
1655 [label="FullWidth = this.Text.Length; 145740"];
1656 [label="FullWidth 145741"];
1657 [label="this.AdjustFlagsAndWidth(trailing); 145742"];
1658 [label="return '%'; 145743"];
1659 [label="FullWidth = this.Text.Length; 145744"];
1660 [label="FullWidth 145745"];
1661 [label="return '%'; 145746"];
1662 [label="FullWidth = this.Text.Length; 145747"];
1663 [label="FullWidth 145748"];
1664 [label="this.AdjustFlagsAndWidth(leading); 145749"];
1665 [label="return '%'; 145750"];
1666 [label="FullWidth = this.Text.Length; 145751"];
1667 [label="FullWidth 145752"];
1668 [label="this.AdjustFlagsAndWidth(trailing); 145753"];
1669 [label="return '%'; 145754"];
1670 [label="FullWidth = this.Text.Length; 145755"];
1671 [label="FullWidth 145756"];
1672 [label="this.AdjustFlagsAndWidth(trailing); 145757"];
1673 [label="return '^'; 145758"];
1674 [label="FullWidth = this.Text.Length; 145759"];
1675 [label="FullWidth 145760"];
1676 [label="return '^'; 145761"];
1677 [label="FullWidth = this.Text.Length; 145762"];
1678 [label="FullWidth 145763"];
1679 [label="this.AdjustFlagsAndWidth(leading); 145764"];
1680 [label="return '^'; 145765"];
1681 [label="FullWidth = this.Text.Length; 145766"];
1682 [label="FullWidth 145767"];
1683 [label="this.AdjustFlagsAndWidth(trailing); 145768"];
1684 [label="return '^'; 145769"];
1685 [label="FullWidth = this.Text.Length; 145770"];
1686 [label="FullWidth 145771"];
1687 [label="this.AdjustFlagsAndWidth(trailing); 145772"];
1688 [label="return '&'; 145773"];
1689 [label="FullWidth = this.Text.Length; 145774"];
1690 [label="FullWidth 145775"];
1691 [label="return '&'; 145776"];
1692 [label="FullWidth = this.Text.Length; 145777"];
1693 [label="FullWidth 145778"];
1694 [label="this.AdjustFlagsAndWidth(leading); 145779"];
1695 [label="return '&'; 145780"];
1696 [label="FullWidth = this.Text.Length; 145781"];
1697 [label="FullWidth 145782"];
1698 [label="this.AdjustFlagsAndWidth(trailing); 145783"];
1699 [label="return '&'; 145784"];
1700 [label="FullWidth = this.Text.Length; 145785"];
1701 [label="FullWidth 145786"];
1702 [label="this.AdjustFlagsAndWidth(trailing); 145787"];
1703 [label="return '*'; 145788"];
1704 [label="FullWidth = this.Text.Length; 145789"];
1705 [label="FullWidth 145790"];
1706 [label="return '*'; 145791"];
1707 [label="FullWidth = this.Text.Length; 145792"];
1708 [label="FullWidth 145793"];
1709 [label="this.AdjustFlagsAndWidth(leading); 145794"];
1710 [label="return '*'; 145795"];
1711 [label="FullWidth = this.Text.Length; 145796"];
1712 [label="FullWidth 145797"];
1713 [label="this.AdjustFlagsAndWidth(trailing); 145798"];
1714 [label="return '*'; 145799"];
1715 [label="FullWidth = this.Text.Length; 145800"];
1716 [label="FullWidth 145801"];
1717 [label="this.AdjustFlagsAndWidth(trailing); 145802"];
1718 [label="return '('; 145803"];
1719 [label="FullWidth = this.Text.Length; 145804"];
1720 [label="FullWidth 145805"];
1721 [label="return '('; 145806"];
1722 [label="FullWidth = this.Text.Length; 145807"];
1723 [label="FullWidth 145808"];
1724 [label="this.AdjustFlagsAndWidth(leading); 145809"];
1725 [label="return '('; 145810"];
1726 [label="FullWidth = this.Text.Length; 145811"];
1727 [label="FullWidth 145812"];
1728 [label="this.AdjustFlagsAndWidth(trailing); 145813"];
1729 [label="return '('; 145814"];
1730 [label="FullWidth = this.Text.Length; 145815"];
1731 [label="FullWidth 145816"];
1732 [label="this.AdjustFlagsAndWidth(trailing); 145817"];
1733 [label="return ')'; 145818"];
1734 [label="FullWidth = this.Text.Length; 145819"];
1735 [label="FullWidth 145820"];
1736 [label="return ')'; 145821"];
1737 [label="FullWidth = this.Text.Length; 145822"];
1738 [label="FullWidth 145823"];
1739 [label="this.AdjustFlagsAndWidth(leading); 145824"];
1740 [label="return ')'; 145825"];
1741 [label="FullWidth = this.Text.Length; 145826"];
1742 [label="FullWidth 145827"];
1743 [label="this.AdjustFlagsAndWidth(trailing); 145828"];
1744 [label="return ')'; 145829"];
1745 [label="FullWidth = this.Text.Length; 145830"];
1746 [label="FullWidth 145831"];
1747 [label="this.AdjustFlagsAndWidth(trailing); 145832"];
1748 [label="return '-'; 145833"];
1749 [label="FullWidth = this.Text.Length; 145834"];
1750 [label="FullWidth 145835"];
1751 [label="return '-'; 145836"];
1752 [label="FullWidth = this.Text.Length; 145837"];
1753 [label="FullWidth 145838"];
1754 [label="this.AdjustFlagsAndWidth(leading); 145839"];
1755 [label="return '-'; 145840"];
1756 [label="FullWidth = this.Text.Length; 145841"];
1757 [label="FullWidth 145842"];
1758 [label="this.AdjustFlagsAndWidth(trailing); 145843"];
1759 [label="return '-'; 145844"];
1760 [label="FullWidth = this.Text.Length; 145845"];
1761 [label="FullWidth 145846"];
1762 [label="this.AdjustFlagsAndWidth(trailing); 145847"];
1763 [label="return '+'; 145848"];
1764 [label="FullWidth = this.Text.Length; 145849"];
1765 [label="FullWidth 145850"];
1766 [label="return '+'; 145851"];
1767 [label="FullWidth = this.Text.Length; 145852"];
1768 [label="FullWidth 145853"];
1769 [label="this.AdjustFlagsAndWidth(leading); 145854"];
1770 [label="return '+'; 145855"];
1771 [label="FullWidth = this.Text.Length; 145856"];
1772 [label="FullWidth 145857"];
1773 [label="this.AdjustFlagsAndWidth(trailing); 145858"];
1774 [label="return '+'; 145859"];
1775 [label="FullWidth = this.Text.Length; 145860"];
1776 [label="FullWidth 145861"];
1777 [label="this.AdjustFlagsAndWidth(trailing); 145862"];
1778 [label="return '='; 145863"];
1779 [label="FullWidth = this.Text.Length; 145864"];
1780 [label="FullWidth 145865"];
1781 [label="return '='; 145866"];
1782 [label="FullWidth = this.Text.Length; 145867"];
1783 [label="FullWidth 145868"];
1784 [label="this.AdjustFlagsAndWidth(leading); 145869"];
1785 [label="return '='; 145870"];
1786 [label="FullWidth = this.Text.Length; 145871"];
1787 [label="FullWidth 145872"];
1788 [label="this.AdjustFlagsAndWidth(trailing); 145873"];
1789 [label="return '='; 145874"];
1790 [label="FullWidth = this.Text.Length; 145875"];
1791 [label="FullWidth 145876"];
1792 [label="this.AdjustFlagsAndWidth(trailing); 145877"];
1793 [label="return '{'; 145878"];
1794 [label="FullWidth = this.Text.Length; 145879"];
1795 [label="FullWidth 145880"];
1796 [label="return '{'; 145881"];
1797 [label="FullWidth = this.Text.Length; 145882"];
1798 [label="FullWidth 145883"];
1799 [label="this.AdjustFlagsAndWidth(leading); 145884"];
1800 [label="return '{'; 145885"];
1801 [label="FullWidth = this.Text.Length; 145886"];
1802 [label="FullWidth 145887"];
1803 [label="this.AdjustFlagsAndWidth(trailing); 145888"];
1804 [label="return '{'; 145889"];
1805 [label="FullWidth = this.Text.Length; 145890"];
1806 [label="FullWidth 145891"];
1807 [label="this.AdjustFlagsAndWidth(trailing); 145892"];
1808 [label="return '}'; 145893"];
1809 [label="FullWidth = this.Text.Length; 145894"];
1810 [label="FullWidth 145895"];
1811 [label="return '}'; 145896"];
1812 [label="FullWidth = this.Text.Length; 145897"];
1813 [label="FullWidth 145898"];
1814 [label="this.AdjustFlagsAndWidth(leading); 145899"];
1815 [label="return '}'; 145900"];
1816 [label="FullWidth = this.Text.Length; 145901"];
1817 [label="FullWidth 145902"];
1818 [label="this.AdjustFlagsAndWidth(trailing); 145903"];
1819 [label="return '}'; 145904"];
1820 [label="FullWidth = this.Text.Length; 145905"];
1821 [label="FullWidth 145906"];
1822 [label="this.AdjustFlagsAndWidth(trailing); 145907"];
1823 [label="return '['; 145908"];
1824 [label="FullWidth = this.Text.Length; 145909"];
1825 [label="FullWidth 145910"];
1826 [label="return '['; 145911"];
1827 [label="FullWidth = this.Text.Length; 145912"];
1828 [label="FullWidth 145913"];
1829 [label="this.AdjustFlagsAndWidth(leading); 145914"];
1830 [label="return '['; 145915"];
1831 [label="FullWidth = this.Text.Length; 145916"];
1832 [label="FullWidth 145917"];
1833 [label="this.AdjustFlagsAndWidth(trailing); 145918"];
1834 [label="return '['; 145919"];
1835 [label="FullWidth = this.Text.Length; 145920"];
1836 [label="FullWidth 145921"];
1837 [label="this.AdjustFlagsAndWidth(trailing); 145922"];
1838 [label="return ']'; 145923"];
1839 [label="FullWidth = this.Text.Length; 145924"];
1840 [label="FullWidth 145925"];
1841 [label="return ']'; 145926"];
1842 [label="FullWidth = this.Text.Length; 145927"];
1843 [label="FullWidth 145928"];
1844 [label="this.AdjustFlagsAndWidth(leading); 145929"];
1845 [label="return ']'; 145930"];
1846 [label="FullWidth = this.Text.Length; 145931"];
1847 [label="FullWidth 145932"];
1848 [label="this.AdjustFlagsAndWidth(trailing); 145933"];
1849 [label="return ']'; 145934"];
1850 [label="FullWidth = this.Text.Length; 145935"];
1851 [label="FullWidth 145936"];
1852 [label="this.AdjustFlagsAndWidth(trailing); 145937"];
1853 [label="return '|'; 145938"];
1854 [label="FullWidth = this.Text.Length; 145939"];
1855 [label="FullWidth 145940"];
1856 [label="return '|'; 145941"];
1857 [label="FullWidth = this.Text.Length; 145942"];
1858 [label="FullWidth 145943"];
1859 [label="this.AdjustFlagsAndWidth(leading); 145944"];
1860 [label="return '|'; 145945"];
1861 [label="FullWidth = this.Text.Length; 145946"];
1862 [label="FullWidth 145947"];
1863 [label="this.AdjustFlagsAndWidth(trailing); 145948"];
1864 [label="return '|'; 145949"];
1865 [label="FullWidth = this.Text.Length; 145950"];
1866 [label="FullWidth 145951"];
1867 [label="this.AdjustFlagsAndWidth(trailing); 145952"];
1868 [label="return '\\\\'; 145953"];
1869 [label="FullWidth = this.Text.Length; 145954"];
1870 [label="FullWidth 145955"];
1871 [label="return '\\\\'; 145956"];
1872 [label="FullWidth = this.Text.Length; 145957"];
1873 [label="FullWidth 145958"];
1874 [label="this.AdjustFlagsAndWidth(leading); 145959"];
1875 [label="return '\\\\'; 145960"];
1876 [label="FullWidth = this.Text.Length; 145961"];
1877 [label="FullWidth 145962"];
1878 [label="this.AdjustFlagsAndWidth(trailing); 145963"];
1879 [label="return '\\\\'; 145964"];
1880 [label="FullWidth = this.Text.Length; 145965"];
1881 [label="FullWidth 145966"];
1882 [label="this.AdjustFlagsAndWidth(trailing); 145967"];
1883 [label="return ':'; 145968"];
1884 [label="FullWidth = this.Text.Length; 145969"];
1885 [label="FullWidth 145970"];
1886 [label="return ':'; 145971"];
1887 [label="FullWidth = this.Text.Length; 145972"];
1888 [label="FullWidth 145973"];
1889 [label="this.AdjustFlagsAndWidth(leading); 145974"];
1890 [label="return ':'; 145975"];
1891 [label="FullWidth = this.Text.Length; 145976"];
1892 [label="FullWidth 145977"];
1893 [label="this.AdjustFlagsAndWidth(trailing); 145978"];
1894 [label="return ':'; 145979"];
1895 [label="FullWidth = this.Text.Length; 145980"];
1896 [label="FullWidth 145981"];
1897 [label="this.AdjustFlagsAndWidth(trailing); 145982"];
1898 [label="return ';'; 145983"];
1899 [label="FullWidth = this.Text.Length; 145984"];
1900 [label="FullWidth 145985"];
1901 [label="return ';'; 145986"];
1902 [label="FullWidth = this.Text.Length; 145987"];
1903 [label="FullWidth 145988"];
1904 [label="this.AdjustFlagsAndWidth(leading); 145989"];
1905 [label="return ';'; 145990"];
1906 [label="FullWidth = this.Text.Length; 145991"];
1907 [label="FullWidth 145992"];
1908 [label="this.AdjustFlagsAndWidth(trailing); 145993"];
1909 [label="return ';'; 145994"];
1910 [label="FullWidth = this.Text.Length; 145995"];
1911 [label="FullWidth 145996"];
1912 [label="this.AdjustFlagsAndWidth(trailing); 145997"];
1913 [label="return '\\''; 145998"];
1914 [label="FullWidth = this.Text.Length; 145999"];
1915 [label="FullWidth 146000"];
1916 [label="return '\\''; 146001"];
1917 [label="FullWidth = this.Text.Length; 146002"];
1918 [label="FullWidth 146003"];
1919 [label="this.AdjustFlagsAndWidth(leading); 146004"];
1920 [label="return '\\''; 146005"];
1921 [label="FullWidth = this.Text.Length; 146006"];
1922 [label="FullWidth 146007"];
1923 [label="this.AdjustFlagsAndWidth(trailing); 146008"];
1924 [label="return '\\''; 146009"];
1925 [label="FullWidth = this.Text.Length; 146010"];
1926 [label="FullWidth 146011"];
1927 [label="this.AdjustFlagsAndWidth(trailing); 146012"];
1928 [label="return '''; 146013"];
1929 [label="FullWidth = this.Text.Length; 146014"];
1930 [label="FullWidth 146015"];
1931 [label="return '''; 146016"];
1932 [label="FullWidth = this.Text.Length; 146017"];
1933 [label="FullWidth 146018"];
1934 [label="this.AdjustFlagsAndWidth(leading); 146019"];
1935 [label="return '''; 146020"];
1936 [label="FullWidth = this.Text.Length; 146021"];
1937 [label="FullWidth 146022"];
1938 [label="this.AdjustFlagsAndWidth(trailing); 146023"];
1939 [label="return '''; 146024"];
1940 [label="FullWidth = this.Text.Length; 146025"];
1941 [label="FullWidth 146026"];
1942 [label="this.AdjustFlagsAndWidth(trailing); 146027"];
1943 [label="return '<'; 146028"];
1944 [label="FullWidth = this.Text.Length; 146029"];
1945 [label="FullWidth 146030"];
1946 [label="return '<'; 146031"];
1947 [label="FullWidth = this.Text.Length; 146032"];
1948 [label="FullWidth 146033"];
1949 [label="this.AdjustFlagsAndWidth(leading); 146034"];
1950 [label="return '<'; 146035"];
1951 [label="FullWidth = this.Text.Length; 146036"];
1952 [label="FullWidth 146037"];
1953 [label="this.AdjustFlagsAndWidth(trailing); 146038"];
1954 [label="return '<'; 146039"];
1955 [label="FullWidth = this.Text.Length; 146040"];
1956 [label="FullWidth 146041"];
1957 [label="this.AdjustFlagsAndWidth(trailing); 146042"];
1958 [label="return ','; 146043"];
1959 [label="FullWidth = this.Text.Length; 146044"];
1960 [label="FullWidth 146045"];
1961 [label="return ','; 146046"];
1962 [label="FullWidth = this.Text.Length; 146047"];
1963 [label="FullWidth 146048"];
1964 [label="this.AdjustFlagsAndWidth(leading); 146049"];
1965 [label="return ','; 146050"];
1966 [label="FullWidth = this.Text.Length; 146051"];
1967 [label="FullWidth 146052"];
1968 [label="this.AdjustFlagsAndWidth(trailing); 146053"];
1969 [label="return ','; 146054"];
1970 [label="FullWidth = this.Text.Length; 146055"];
1971 [label="FullWidth 146056"];
1972 [label="this.AdjustFlagsAndWidth(trailing); 146057"];
1973 [label="return '>'; 146058"];
1974 [label="FullWidth = this.Text.Length; 146059"];
1975 [label="FullWidth 146060"];
1976 [label="return '>'; 146061"];
1977 [label="FullWidth = this.Text.Length; 146062"];
1978 [label="FullWidth 146063"];
1979 [label="this.AdjustFlagsAndWidth(leading); 146064"];
1980 [label="return '>'; 146065"];
1981 [label="FullWidth = this.Text.Length; 146066"];
1982 [label="FullWidth 146067"];
1983 [label="this.AdjustFlagsAndWidth(trailing); 146068"];
1984 [label="return '>'; 146069"];
1985 [label="FullWidth = this.Text.Length; 146070"];
1986 [label="FullWidth 146071"];
1987 [label="this.AdjustFlagsAndWidth(trailing); 146072"];
1988 [label="return '.'; 146073"];
1989 [label="FullWidth = this.Text.Length; 146074"];
1990 [label="FullWidth 146075"];
1991 [label="return '.'; 146076"];
1992 [label="FullWidth = this.Text.Length; 146077"];
1993 [label="FullWidth 146078"];
1994 [label="this.AdjustFlagsAndWidth(leading); 146079"];
1995 [label="return '.'; 146080"];
1996 [label="FullWidth = this.Text.Length; 146081"];
1997 [label="FullWidth 146082"];
1998 [label="this.AdjustFlagsAndWidth(trailing); 146083"];
1999 [label="return '.'; 146084"];
2000 [label="FullWidth = this.Text.Length; 146085"];
2001 [label="FullWidth 146086"];
2002 [label="this.AdjustFlagsAndWidth(trailing); 146087"];
2003 [label="return '?'; 146088"];
2004 [label="FullWidth = this.Text.Length; 146089"];
2005 [label="FullWidth 146090"];
2006 [label="return '?'; 146091"];
2007 [label="FullWidth = this.Text.Length; 146092"];
2008 [label="FullWidth 146093"];
2009 [label="this.AdjustFlagsAndWidth(leading); 146094"];
2010 [label="return '?'; 146095"];
2011 [label="FullWidth = this.Text.Length; 146096"];
2012 [label="FullWidth 146097"];
2013 [label="this.AdjustFlagsAndWidth(trailing); 146098"];
2014 [label="return '?'; 146099"];
2015 [label="FullWidth = this.Text.Length; 146100"];
2016 [label="FullWidth 146101"];
2017 [label="this.AdjustFlagsAndWidth(trailing); 146102"];
2018 [label="return '#'; 146103"];
2019 [label="FullWidth = this.Text.Length; 146104"];
2020 [label="FullWidth 146105"];
2021 [label="return '#'; 146106"];
2022 [label="FullWidth = this.Text.Length; 146107"];
2023 [label="FullWidth 146108"];
2024 [label="this.AdjustFlagsAndWidth(leading); 146109"];
2025 [label="return '#'; 146110"];
2026 [label="FullWidth = this.Text.Length; 146111"];
2027 [label="FullWidth 146112"];
2028 [label="this.AdjustFlagsAndWidth(trailing); 146113"];
2029 [label="return '#'; 146114"];
2030 [label="FullWidth = this.Text.Length; 146115"];
2031 [label="FullWidth 146116"];
2032 [label="this.AdjustFlagsAndWidth(trailing); 146117"];
2033 [label="return '/'; 146118"];
2034 [label="FullWidth = this.Text.Length; 146119"];
2035 [label="FullWidth 146120"];
2036 [label="return '/'; 146121"];
2037 [label="FullWidth = this.Text.Length; 146122"];
2038 [label="FullWidth 146123"];
2039 [label="this.AdjustFlagsAndWidth(leading); 146124"];
2040 [label="return '/'; 146125"];
2041 [label="FullWidth = this.Text.Length; 146126"];
2042 [label="FullWidth 146127"];
2043 [label="this.AdjustFlagsAndWidth(trailing); 146128"];
2044 [label="return '/'; 146129"];
2045 [label="FullWidth = this.Text.Length; 146130"];
2046 [label="FullWidth 146131"];
2047 [label="this.AdjustFlagsAndWidth(trailing); 146132"];
2048 [label="return '..'; 146133"];
2049 [label="FullWidth = this.Text.Length; 146134"];
2050 [label="FullWidth 146135"];
2051 [label="return '..'; 146136"];
2052 [label="FullWidth = this.Text.Length; 146137"];
2053 [label="FullWidth 146138"];
2054 [label="this.AdjustFlagsAndWidth(leading); 146139"];
2055 [label="return '..'; 146140"];
2056 [label="FullWidth = this.Text.Length; 146141"];
2057 [label="FullWidth 146142"];
2058 [label="this.AdjustFlagsAndWidth(trailing); 146143"];
2059 [label="return '..'; 146144"];
2060 [label="FullWidth = this.Text.Length; 146145"];
2061 [label="FullWidth 146146"];
2062 [label="this.AdjustFlagsAndWidth(trailing); 146147"];
2063 [label="return string.Empty; 146148"];
2064 [label="FullWidth = this.Text.Length; 146149"];
2065 [label="FullWidth 146150"];
2066 [label="return string.Empty; 146151"];
2067 [label="FullWidth = this.Text.Length; 146152"];
2068 [label="FullWidth 146153"];
2069 [label="this.AdjustFlagsAndWidth(leading); 146154"];
2070 [label="return string.Empty; 146155"];
2071 [label="FullWidth = this.Text.Length; 146156"];
2072 [label="FullWidth 146157"];
2073 [label="this.AdjustFlagsAndWidth(trailing); 146158"];
2074 [label="return string.Empty; 146159"];
2075 [label="FullWidth = this.Text.Length; 146160"];
2076 [label="FullWidth 146161"];
2077 [label="this.AdjustFlagsAndWidth(trailing); 146162"];
2078 [label="return '/>'; 146163"];
2079 [label="FullWidth = this.Text.Length; 146164"];
2080 [label="FullWidth 146165"];
2081 [label="return '/>'; 146166"];
2082 [label="FullWidth = this.Text.Length; 146167"];
2083 [label="FullWidth 146168"];
2084 [label="this.AdjustFlagsAndWidth(leading); 146169"];
2085 [label="return '/>'; 146170"];
2086 [label="FullWidth = this.Text.Length; 146171"];
2087 [label="FullWidth 146172"];
2088 [label="this.AdjustFlagsAndWidth(trailing); 146173"];
2089 [label="return '/>'; 146174"];
2090 [label="FullWidth = this.Text.Length; 146175"];
2091 [label="FullWidth 146176"];
2092 [label="this.AdjustFlagsAndWidth(trailing); 146177"];
2093 [label="return '</'; 146178"];
2094 [label="FullWidth = this.Text.Length; 146179"];
2095 [label="FullWidth 146180"];
2096 [label="return '</'; 146181"];
2097 [label="FullWidth = this.Text.Length; 146182"];
2098 [label="FullWidth 146183"];
2099 [label="this.AdjustFlagsAndWidth(leading); 146184"];
2100 [label="return '</'; 146185"];
2101 [label="FullWidth = this.Text.Length; 146186"];
2102 [label="FullWidth 146187"];
2103 [label="this.AdjustFlagsAndWidth(trailing); 146188"];
2104 [label="return '</'; 146189"];
2105 [label="FullWidth = this.Text.Length; 146190"];
2106 [label="FullWidth 146191"];
2107 [label="this.AdjustFlagsAndWidth(trailing); 146192"];
2108 [label="return '<!--'; 146193"];
2109 [label="FullWidth = this.Text.Length; 146194"];
2110 [label="FullWidth 146195"];
2111 [label="return '<!--'; 146196"];
2112 [label="FullWidth = this.Text.Length; 146197"];
2113 [label="FullWidth 146198"];
2114 [label="this.AdjustFlagsAndWidth(leading); 146199"];
2115 [label="return '<!--'; 146200"];
2116 [label="FullWidth = this.Text.Length; 146201"];
2117 [label="FullWidth 146202"];
2118 [label="this.AdjustFlagsAndWidth(trailing); 146203"];
2119 [label="return '<!--'; 146204"];
2120 [label="FullWidth = this.Text.Length; 146205"];
2121 [label="FullWidth 146206"];
2122 [label="this.AdjustFlagsAndWidth(trailing); 146207"];
2123 [label="return '-->'; 146208"];
2124 [label="FullWidth = this.Text.Length; 146209"];
2125 [label="FullWidth 146210"];
2126 [label="return '-->'; 146211"];
2127 [label="FullWidth = this.Text.Length; 146212"];
2128 [label="FullWidth 146213"];
2129 [label="this.AdjustFlagsAndWidth(leading); 146214"];
2130 [label="return '-->'; 146215"];
2131 [label="FullWidth = this.Text.Length; 146216"];
2132 [label="FullWidth 146217"];
2133 [label="this.AdjustFlagsAndWidth(trailing); 146218"];
2134 [label="return '-->'; 146219"];
2135 [label="FullWidth = this.Text.Length; 146220"];
2136 [label="FullWidth 146221"];
2137 [label="this.AdjustFlagsAndWidth(trailing); 146222"];
2138 [label="return '<![CDATA['; 146223"];
2139 [label="FullWidth = this.Text.Length; 146224"];
2140 [label="FullWidth 146225"];
2141 [label="return '<![CDATA['; 146226"];
2142 [label="FullWidth = this.Text.Length; 146227"];
2143 [label="FullWidth 146228"];
2144 [label="this.AdjustFlagsAndWidth(leading); 146229"];
2145 [label="return '<![CDATA['; 146230"];
2146 [label="FullWidth = this.Text.Length; 146231"];
2147 [label="FullWidth 146232"];
2148 [label="this.AdjustFlagsAndWidth(trailing); 146233"];
2149 [label="return '<![CDATA['; 146234"];
2150 [label="FullWidth = this.Text.Length; 146235"];
2151 [label="FullWidth 146236"];
2152 [label="this.AdjustFlagsAndWidth(trailing); 146237"];
2153 [label="return ']]>'; 146238"];
2154 [label="FullWidth = this.Text.Length; 146239"];
2155 [label="FullWidth 146240"];
2156 [label="return ']]>'; 146241"];
2157 [label="FullWidth = this.Text.Length; 146242"];
2158 [label="FullWidth 146243"];
2159 [label="this.AdjustFlagsAndWidth(leading); 146244"];
2160 [label="return ']]>'; 146245"];
2161 [label="FullWidth = this.Text.Length; 146246"];
2162 [label="FullWidth 146247"];
2163 [label="this.AdjustFlagsAndWidth(trailing); 146248"];
2164 [label="return ']]>'; 146249"];
2165 [label="FullWidth = this.Text.Length; 146250"];
2166 [label="FullWidth 146251"];
2167 [label="this.AdjustFlagsAndWidth(trailing); 146252"];
2168 [label="return '<?'; 146253"];
2169 [label="FullWidth = this.Text.Length; 146254"];
2170 [label="FullWidth 146255"];
2171 [label="return '<?'; 146256"];
2172 [label="FullWidth = this.Text.Length; 146257"];
2173 [label="FullWidth 146258"];
2174 [label="this.AdjustFlagsAndWidth(leading); 146259"];
2175 [label="return '<?'; 146260"];
2176 [label="FullWidth = this.Text.Length; 146261"];
2177 [label="FullWidth 146262"];
2178 [label="this.AdjustFlagsAndWidth(trailing); 146263"];
2179 [label="return '<?'; 146264"];
2180 [label="FullWidth = this.Text.Length; 146265"];
2181 [label="FullWidth 146266"];
2182 [label="this.AdjustFlagsAndWidth(trailing); 146267"];
2183 [label="return '?>'; 146268"];
2184 [label="FullWidth = this.Text.Length; 146269"];
2185 [label="FullWidth 146270"];
2186 [label="return '?>'; 146271"];
2187 [label="FullWidth = this.Text.Length; 146272"];
2188 [label="FullWidth 146273"];
2189 [label="this.AdjustFlagsAndWidth(leading); 146274"];
2190 [label="return '?>'; 146275"];
2191 [label="FullWidth = this.Text.Length; 146276"];
2192 [label="FullWidth 146277"];
2193 [label="this.AdjustFlagsAndWidth(trailing); 146278"];
2194 [label="return '?>'; 146279"];
2195 [label="FullWidth = this.Text.Length; 146280"];
2196 [label="FullWidth 146281"];
2197 [label="this.AdjustFlagsAndWidth(trailing); 146282"];
2198 [label="return '||'; 146283"];
2199 [label="FullWidth = this.Text.Length; 146284"];
2200 [label="FullWidth 146285"];
2201 [label="return '||'; 146286"];
2202 [label="FullWidth = this.Text.Length; 146287"];
2203 [label="FullWidth 146288"];
2204 [label="this.AdjustFlagsAndWidth(leading); 146289"];
2205 [label="return '||'; 146290"];
2206 [label="FullWidth = this.Text.Length; 146291"];
2207 [label="FullWidth 146292"];
2208 [label="this.AdjustFlagsAndWidth(trailing); 146293"];
2209 [label="return '||'; 146294"];
2210 [label="FullWidth = this.Text.Length; 146295"];
2211 [label="FullWidth 146296"];
2212 [label="this.AdjustFlagsAndWidth(trailing); 146297"];
2213 [label="return '&&'; 146298"];
2214 [label="FullWidth = this.Text.Length; 146299"];
2215 [label="FullWidth 146300"];
2216 [label="return '&&'; 146301"];
2217 [label="FullWidth = this.Text.Length; 146302"];
2218 [label="FullWidth 146303"];
2219 [label="this.AdjustFlagsAndWidth(leading); 146304"];
2220 [label="return '&&'; 146305"];
2221 [label="FullWidth = this.Text.Length; 146306"];
2222 [label="FullWidth 146307"];
2223 [label="this.AdjustFlagsAndWidth(trailing); 146308"];
2224 [label="return '&&'; 146309"];
2225 [label="FullWidth = this.Text.Length; 146310"];
2226 [label="FullWidth 146311"];
2227 [label="this.AdjustFlagsAndWidth(trailing); 146312"];
2228 [label="return '--'; 146313"];
2229 [label="FullWidth = this.Text.Length; 146314"];
2230 [label="FullWidth 146315"];
2231 [label="return '--'; 146316"];
2232 [label="FullWidth = this.Text.Length; 146317"];
2233 [label="FullWidth 146318"];
2234 [label="this.AdjustFlagsAndWidth(leading); 146319"];
2235 [label="return '--'; 146320"];
2236 [label="FullWidth = this.Text.Length; 146321"];
2237 [label="FullWidth 146322"];
2238 [label="this.AdjustFlagsAndWidth(trailing); 146323"];
2239 [label="return '--'; 146324"];
2240 [label="FullWidth = this.Text.Length; 146325"];
2241 [label="FullWidth 146326"];
2242 [label="this.AdjustFlagsAndWidth(trailing); 146327"];
2243 [label="return '++'; 146328"];
2244 [label="FullWidth = this.Text.Length; 146329"];
2245 [label="FullWidth 146330"];
2246 [label="return '++'; 146331"];
2247 [label="FullWidth = this.Text.Length; 146332"];
2248 [label="FullWidth 146333"];
2249 [label="this.AdjustFlagsAndWidth(leading); 146334"];
2250 [label="return '++'; 146335"];
2251 [label="FullWidth = this.Text.Length; 146336"];
2252 [label="FullWidth 146337"];
2253 [label="this.AdjustFlagsAndWidth(trailing); 146338"];
2254 [label="return '++'; 146339"];
2255 [label="FullWidth = this.Text.Length; 146340"];
2256 [label="FullWidth 146341"];
2257 [label="this.AdjustFlagsAndWidth(trailing); 146342"];
2258 [label="return '::'; 146343"];
2259 [label="FullWidth = this.Text.Length; 146344"];
2260 [label="FullWidth 146345"];
2261 [label="return '::'; 146346"];
2262 [label="FullWidth = this.Text.Length; 146347"];
2263 [label="FullWidth 146348"];
2264 [label="this.AdjustFlagsAndWidth(leading); 146349"];
2265 [label="return '::'; 146350"];
2266 [label="FullWidth = this.Text.Length; 146351"];
2267 [label="FullWidth 146352"];
2268 [label="this.AdjustFlagsAndWidth(trailing); 146353"];
2269 [label="return '::'; 146354"];
2270 [label="FullWidth = this.Text.Length; 146355"];
2271 [label="FullWidth 146356"];
2272 [label="this.AdjustFlagsAndWidth(trailing); 146357"];
2273 [label="return '??'; 146358"];
2274 [label="FullWidth = this.Text.Length; 146359"];
2275 [label="FullWidth 146360"];
2276 [label="return '??'; 146361"];
2277 [label="FullWidth = this.Text.Length; 146362"];
2278 [label="FullWidth 146363"];
2279 [label="this.AdjustFlagsAndWidth(leading); 146364"];
2280 [label="return '??'; 146365"];
2281 [label="FullWidth = this.Text.Length; 146366"];
2282 [label="FullWidth 146367"];
2283 [label="this.AdjustFlagsAndWidth(trailing); 146368"];
2284 [label="return '??'; 146369"];
2285 [label="FullWidth = this.Text.Length; 146370"];
2286 [label="FullWidth 146371"];
2287 [label="this.AdjustFlagsAndWidth(trailing); 146372"];
2288 [label="return '->'; 146373"];
2289 [label="FullWidth = this.Text.Length; 146374"];
2290 [label="FullWidth 146375"];
2291 [label="return '->'; 146376"];
2292 [label="FullWidth = this.Text.Length; 146377"];
2293 [label="FullWidth 146378"];
2294 [label="this.AdjustFlagsAndWidth(leading); 146379"];
2295 [label="return '->'; 146380"];
2296 [label="FullWidth = this.Text.Length; 146381"];
2297 [label="FullWidth 146382"];
2298 [label="this.AdjustFlagsAndWidth(trailing); 146383"];
2299 [label="return '->'; 146384"];
2300 [label="FullWidth = this.Text.Length; 146385"];
2301 [label="FullWidth 146386"];
2302 [label="this.AdjustFlagsAndWidth(trailing); 146387"];
2303 [label="return '!='; 146388"];
2304 [label="FullWidth = this.Text.Length; 146389"];
2305 [label="FullWidth 146390"];
2306 [label="return '!='; 146391"];
2307 [label="FullWidth = this.Text.Length; 146392"];
2308 [label="FullWidth 146393"];
2309 [label="this.AdjustFlagsAndWidth(leading); 146394"];
2310 [label="return '!='; 146395"];
2311 [label="FullWidth = this.Text.Length; 146396"];
2312 [label="FullWidth 146397"];
2313 [label="this.AdjustFlagsAndWidth(trailing); 146398"];
2314 [label="return '!='; 146399"];
2315 [label="FullWidth = this.Text.Length; 146400"];
2316 [label="FullWidth 146401"];
2317 [label="this.AdjustFlagsAndWidth(trailing); 146402"];
2318 [label="return '=='; 146403"];
2319 [label="FullWidth = this.Text.Length; 146404"];
2320 [label="FullWidth 146405"];
2321 [label="return '=='; 146406"];
2322 [label="FullWidth = this.Text.Length; 146407"];
2323 [label="FullWidth 146408"];
2324 [label="this.AdjustFlagsAndWidth(leading); 146409"];
2325 [label="return '=='; 146410"];
2326 [label="FullWidth = this.Text.Length; 146411"];
2327 [label="FullWidth 146412"];
2328 [label="this.AdjustFlagsAndWidth(trailing); 146413"];
2329 [label="return '=='; 146414"];
2330 [label="FullWidth = this.Text.Length; 146415"];
2331 [label="FullWidth 146416"];
2332 [label="this.AdjustFlagsAndWidth(trailing); 146417"];
2333 [label="return '=>'; 146418"];
2334 [label="FullWidth = this.Text.Length; 146419"];
2335 [label="FullWidth 146420"];
2336 [label="return '=>'; 146421"];
2337 [label="FullWidth = this.Text.Length; 146422"];
2338 [label="FullWidth 146423"];
2339 [label="this.AdjustFlagsAndWidth(leading); 146424"];
2340 [label="return '=>'; 146425"];
2341 [label="FullWidth = this.Text.Length; 146426"];
2342 [label="FullWidth 146427"];
2343 [label="this.AdjustFlagsAndWidth(trailing); 146428"];
2344 [label="return '=>'; 146429"];
2345 [label="FullWidth = this.Text.Length; 146430"];
2346 [label="FullWidth 146431"];
2347 [label="this.AdjustFlagsAndWidth(trailing); 146432"];
2348 [label="return '<='; 146433"];
2349 [label="FullWidth = this.Text.Length; 146434"];
2350 [label="FullWidth 146435"];
2351 [label="return '<='; 146436"];
2352 [label="FullWidth = this.Text.Length; 146437"];
2353 [label="FullWidth 146438"];
2354 [label="this.AdjustFlagsAndWidth(leading); 146439"];
2355 [label="return '<='; 146440"];
2356 [label="FullWidth = this.Text.Length; 146441"];
2357 [label="FullWidth 146442"];
2358 [label="this.AdjustFlagsAndWidth(trailing); 146443"];
2359 [label="return '<='; 146444"];
2360 [label="FullWidth = this.Text.Length; 146445"];
2361 [label="FullWidth 146446"];
2362 [label="this.AdjustFlagsAndWidth(trailing); 146447"];
2363 [label="return '<<'; 146448"];
2364 [label="FullWidth = this.Text.Length; 146449"];
2365 [label="FullWidth 146450"];
2366 [label="return '<<'; 146451"];
2367 [label="FullWidth = this.Text.Length; 146452"];
2368 [label="FullWidth 146453"];
2369 [label="this.AdjustFlagsAndWidth(leading); 146454"];
2370 [label="return '<<'; 146455"];
2371 [label="FullWidth = this.Text.Length; 146456"];
2372 [label="FullWidth 146457"];
2373 [label="this.AdjustFlagsAndWidth(trailing); 146458"];
2374 [label="return '<<'; 146459"];
2375 [label="FullWidth = this.Text.Length; 146460"];
2376 [label="FullWidth 146461"];
2377 [label="this.AdjustFlagsAndWidth(trailing); 146462"];
2378 [label="return '<<='; 146463"];
2379 [label="FullWidth = this.Text.Length; 146464"];
2380 [label="FullWidth 146465"];
2381 [label="return '<<='; 146466"];
2382 [label="FullWidth = this.Text.Length; 146467"];
2383 [label="FullWidth 146468"];
2384 [label="this.AdjustFlagsAndWidth(leading); 146469"];
2385 [label="return '<<='; 146470"];
2386 [label="FullWidth = this.Text.Length; 146471"];
2387 [label="FullWidth 146472"];
2388 [label="this.AdjustFlagsAndWidth(trailing); 146473"];
2389 [label="return '<<='; 146474"];
2390 [label="FullWidth = this.Text.Length; 146475"];
2391 [label="FullWidth 146476"];
2392 [label="this.AdjustFlagsAndWidth(trailing); 146477"];
2393 [label="return '>='; 146478"];
2394 [label="FullWidth = this.Text.Length; 146479"];
2395 [label="FullWidth 146480"];
2396 [label="return '>='; 146481"];
2397 [label="FullWidth = this.Text.Length; 146482"];
2398 [label="FullWidth 146483"];
2399 [label="this.AdjustFlagsAndWidth(leading); 146484"];
2400 [label="return '>='; 146485"];
2401 [label="FullWidth = this.Text.Length; 146486"];
2402 [label="FullWidth 146487"];
2403 [label="this.AdjustFlagsAndWidth(trailing); 146488"];
2404 [label="return '>='; 146489"];
2405 [label="FullWidth = this.Text.Length; 146490"];
2406 [label="FullWidth 146491"];
2407 [label="this.AdjustFlagsAndWidth(trailing); 146492"];
2408 [label="return '>>'; 146493"];
2409 [label="FullWidth = this.Text.Length; 146494"];
2410 [label="FullWidth 146495"];
2411 [label="return '>>'; 146496"];
2412 [label="FullWidth = this.Text.Length; 146497"];
2413 [label="FullWidth 146498"];
2414 [label="this.AdjustFlagsAndWidth(leading); 146499"];
2415 [label="return '>>'; 146500"];
2416 [label="FullWidth = this.Text.Length; 146501"];
2417 [label="FullWidth 146502"];
2418 [label="this.AdjustFlagsAndWidth(trailing); 146503"];
2419 [label="return '>>'; 146504"];
2420 [label="FullWidth = this.Text.Length; 146505"];
2421 [label="FullWidth 146506"];
2422 [label="this.AdjustFlagsAndWidth(trailing); 146507"];
2423 [label="return '>>='; 146508"];
2424 [label="FullWidth = this.Text.Length; 146509"];
2425 [label="FullWidth 146510"];
2426 [label="return '>>='; 146511"];
2427 [label="FullWidth = this.Text.Length; 146512"];
2428 [label="FullWidth 146513"];
2429 [label="this.AdjustFlagsAndWidth(leading); 146514"];
2430 [label="return '>>='; 146515"];
2431 [label="FullWidth = this.Text.Length; 146516"];
2432 [label="FullWidth 146517"];
2433 [label="this.AdjustFlagsAndWidth(trailing); 146518"];
2434 [label="return '>>='; 146519"];
2435 [label="FullWidth = this.Text.Length; 146520"];
2436 [label="FullWidth 146521"];
2437 [label="this.AdjustFlagsAndWidth(trailing); 146522"];
2438 [label="return '/='; 146523"];
2439 [label="FullWidth = this.Text.Length; 146524"];
2440 [label="FullWidth 146525"];
2441 [label="return '/='; 146526"];
2442 [label="FullWidth = this.Text.Length; 146527"];
2443 [label="FullWidth 146528"];
2444 [label="this.AdjustFlagsAndWidth(leading); 146529"];
2445 [label="return '/='; 146530"];
2446 [label="FullWidth = this.Text.Length; 146531"];
2447 [label="FullWidth 146532"];
2448 [label="this.AdjustFlagsAndWidth(trailing); 146533"];
2449 [label="return '/='; 146534"];
2450 [label="FullWidth = this.Text.Length; 146535"];
2451 [label="FullWidth 146536"];
2452 [label="this.AdjustFlagsAndWidth(trailing); 146537"];
2453 [label="return '*='; 146538"];
2454 [label="FullWidth = this.Text.Length; 146539"];
2455 [label="FullWidth 146540"];
2456 [label="return '*='; 146541"];
2457 [label="FullWidth = this.Text.Length; 146542"];
2458 [label="FullWidth 146543"];
2459 [label="this.AdjustFlagsAndWidth(leading); 146544"];
2460 [label="return '*='; 146545"];
2461 [label="FullWidth = this.Text.Length; 146546"];
2462 [label="FullWidth 146547"];
2463 [label="this.AdjustFlagsAndWidth(trailing); 146548"];
2464 [label="return '*='; 146549"];
2465 [label="FullWidth = this.Text.Length; 146550"];
2466 [label="FullWidth 146551"];
2467 [label="this.AdjustFlagsAndWidth(trailing); 146552"];
2468 [label="return '|='; 146553"];
2469 [label="FullWidth = this.Text.Length; 146554"];
2470 [label="FullWidth 146555"];
2471 [label="return '|='; 146556"];
2472 [label="FullWidth = this.Text.Length; 146557"];
2473 [label="FullWidth 146558"];
2474 [label="this.AdjustFlagsAndWidth(leading); 146559"];
2475 [label="return '|='; 146560"];
2476 [label="FullWidth = this.Text.Length; 146561"];
2477 [label="FullWidth 146562"];
2478 [label="this.AdjustFlagsAndWidth(trailing); 146563"];
2479 [label="return '|='; 146564"];
2480 [label="FullWidth = this.Text.Length; 146565"];
2481 [label="FullWidth 146566"];
2482 [label="this.AdjustFlagsAndWidth(trailing); 146567"];
2483 [label="return '&='; 146568"];
2484 [label="FullWidth = this.Text.Length; 146569"];
2485 [label="FullWidth 146570"];
2486 [label="return '&='; 146571"];
2487 [label="FullWidth = this.Text.Length; 146572"];
2488 [label="FullWidth 146573"];
2489 [label="this.AdjustFlagsAndWidth(leading); 146574"];
2490 [label="return '&='; 146575"];
2491 [label="FullWidth = this.Text.Length; 146576"];
2492 [label="FullWidth 146577"];
2493 [label="this.AdjustFlagsAndWidth(trailing); 146578"];
2494 [label="return '&='; 146579"];
2495 [label="FullWidth = this.Text.Length; 146580"];
2496 [label="FullWidth 146581"];
2497 [label="this.AdjustFlagsAndWidth(trailing); 146582"];
2498 [label="return '+='; 146583"];
2499 [label="FullWidth = this.Text.Length; 146584"];
2500 [label="FullWidth 146585"];
2501 [label="return '+='; 146586"];
2502 [label="FullWidth = this.Text.Length; 146587"];
2503 [label="FullWidth 146588"];
2504 [label="this.AdjustFlagsAndWidth(leading); 146589"];
2505 [label="return '+='; 146590"];
2506 [label="FullWidth = this.Text.Length; 146591"];
2507 [label="FullWidth 146592"];
2508 [label="this.AdjustFlagsAndWidth(trailing); 146593"];
2509 [label="return '+='; 146594"];
2510 [label="FullWidth = this.Text.Length; 146595"];
2511 [label="FullWidth 146596"];
2512 [label="this.AdjustFlagsAndWidth(trailing); 146597"];
2513 [label="return '-='; 146598"];
2514 [label="FullWidth = this.Text.Length; 146599"];
2515 [label="FullWidth 146600"];
2516 [label="return '-='; 146601"];
2517 [label="FullWidth = this.Text.Length; 146602"];
2518 [label="FullWidth 146603"];
2519 [label="this.AdjustFlagsAndWidth(leading); 146604"];
2520 [label="return '-='; 146605"];
2521 [label="FullWidth = this.Text.Length; 146606"];
2522 [label="FullWidth 146607"];
2523 [label="this.AdjustFlagsAndWidth(trailing); 146608"];
2524 [label="return '-='; 146609"];
2525 [label="FullWidth = this.Text.Length; 146610"];
2526 [label="FullWidth 146611"];
2527 [label="this.AdjustFlagsAndWidth(trailing); 146612"];
2528 [label="return '^='; 146613"];
2529 [label="FullWidth = this.Text.Length; 146614"];
2530 [label="FullWidth 146615"];
2531 [label="return '^='; 146616"];
2532 [label="FullWidth = this.Text.Length; 146617"];
2533 [label="FullWidth 146618"];
2534 [label="this.AdjustFlagsAndWidth(leading); 146619"];
2535 [label="return '^='; 146620"];
2536 [label="FullWidth = this.Text.Length; 146621"];
2537 [label="FullWidth 146622"];
2538 [label="this.AdjustFlagsAndWidth(trailing); 146623"];
2539 [label="return '^='; 146624"];
2540 [label="FullWidth = this.Text.Length; 146625"];
2541 [label="FullWidth 146626"];
2542 [label="this.AdjustFlagsAndWidth(trailing); 146627"];
2543 [label="return '%='; 146628"];
2544 [label="FullWidth = this.Text.Length; 146629"];
2545 [label="FullWidth 146630"];
2546 [label="return '%='; 146631"];
2547 [label="FullWidth = this.Text.Length; 146632"];
2548 [label="FullWidth 146633"];
2549 [label="this.AdjustFlagsAndWidth(leading); 146634"];
2550 [label="return '%='; 146635"];
2551 [label="FullWidth = this.Text.Length; 146636"];
2552 [label="FullWidth 146637"];
2553 [label="this.AdjustFlagsAndWidth(trailing); 146638"];
2554 [label="return '%='; 146639"];
2555 [label="FullWidth = this.Text.Length; 146640"];
2556 [label="FullWidth 146641"];
2557 [label="this.AdjustFlagsAndWidth(trailing); 146642"];
2558 [label="return '??='; 146643"];
2559 [label="FullWidth = this.Text.Length; 146644"];
2560 [label="FullWidth 146645"];
2561 [label="return '??='; 146646"];
2562 [label="FullWidth = this.Text.Length; 146647"];
2563 [label="FullWidth 146648"];
2564 [label="this.AdjustFlagsAndWidth(leading); 146649"];
2565 [label="return '??='; 146650"];
2566 [label="FullWidth = this.Text.Length; 146651"];
2567 [label="FullWidth 146652"];
2568 [label="this.AdjustFlagsAndWidth(trailing); 146653"];
2569 [label="return '??='; 146654"];
2570 [label="FullWidth = this.Text.Length; 146655"];
2571 [label="FullWidth 146656"];
2572 [label="this.AdjustFlagsAndWidth(trailing); 146657"];
2573 [label="return 'bool'; 146658"];
2574 [label="FullWidth = this.Text.Length; 146659"];
2575 [label="FullWidth 146660"];
2576 [label="return 'bool'; 146661"];
2577 [label="FullWidth = this.Text.Length; 146662"];
2578 [label="FullWidth 146663"];
2579 [label="this.AdjustFlagsAndWidth(leading); 146664"];
2580 [label="return 'bool'; 146665"];
2581 [label="FullWidth = this.Text.Length; 146666"];
2582 [label="FullWidth 146667"];
2583 [label="this.AdjustFlagsAndWidth(trailing); 146668"];
2584 [label="return 'bool'; 146669"];
2585 [label="FullWidth = this.Text.Length; 146670"];
2586 [label="FullWidth 146671"];
2587 [label="this.AdjustFlagsAndWidth(trailing); 146672"];
2588 [label="return 'byte'; 146673"];
2589 [label="FullWidth = this.Text.Length; 146674"];
2590 [label="FullWidth 146675"];
2591 [label="return 'byte'; 146676"];
2592 [label="FullWidth = this.Text.Length; 146677"];
2593 [label="FullWidth 146678"];
2594 [label="this.AdjustFlagsAndWidth(leading); 146679"];
2595 [label="return 'byte'; 146680"];
2596 [label="FullWidth = this.Text.Length; 146681"];
2597 [label="FullWidth 146682"];
2598 [label="this.AdjustFlagsAndWidth(trailing); 146683"];
2599 [label="return 'byte'; 146684"];
2600 [label="FullWidth = this.Text.Length; 146685"];
2601 [label="FullWidth 146686"];
2602 [label="this.AdjustFlagsAndWidth(trailing); 146687"];
2603 [label="return 'sbyte'; 146688"];
2604 [label="FullWidth = this.Text.Length; 146689"];
2605 [label="FullWidth 146690"];
2606 [label="return 'sbyte'; 146691"];
2607 [label="FullWidth = this.Text.Length; 146692"];
2608 [label="FullWidth 146693"];
2609 [label="this.AdjustFlagsAndWidth(leading); 146694"];
2610 [label="return 'sbyte'; 146695"];
2611 [label="FullWidth = this.Text.Length; 146696"];
2612 [label="FullWidth 146697"];
2613 [label="this.AdjustFlagsAndWidth(trailing); 146698"];
2614 [label="return 'sbyte'; 146699"];
2615 [label="FullWidth = this.Text.Length; 146700"];
2616 [label="FullWidth 146701"];
2617 [label="this.AdjustFlagsAndWidth(trailing); 146702"];
2618 [label="return 'short'; 146703"];
2619 [label="FullWidth = this.Text.Length; 146704"];
2620 [label="FullWidth 146705"];
2621 [label="return 'short'; 146706"];
2622 [label="FullWidth = this.Text.Length; 146707"];
2623 [label="FullWidth 146708"];
2624 [label="this.AdjustFlagsAndWidth(leading); 146709"];
2625 [label="return 'short'; 146710"];
2626 [label="FullWidth = this.Text.Length; 146711"];
2627 [label="FullWidth 146712"];
2628 [label="this.AdjustFlagsAndWidth(trailing); 146713"];
2629 [label="return 'short'; 146714"];
2630 [label="FullWidth = this.Text.Length; 146715"];
2631 [label="FullWidth 146716"];
2632 [label="this.AdjustFlagsAndWidth(trailing); 146717"];
2633 [label="return 'ushort'; 146718"];
2634 [label="FullWidth = this.Text.Length; 146719"];
2635 [label="FullWidth 146720"];
2636 [label="return 'ushort'; 146721"];
2637 [label="FullWidth = this.Text.Length; 146722"];
2638 [label="FullWidth 146723"];
2639 [label="this.AdjustFlagsAndWidth(leading); 146724"];
2640 [label="return 'ushort'; 146725"];
2641 [label="FullWidth = this.Text.Length; 146726"];
2642 [label="FullWidth 146727"];
2643 [label="this.AdjustFlagsAndWidth(trailing); 146728"];
2644 [label="return 'ushort'; 146729"];
2645 [label="FullWidth = this.Text.Length; 146730"];
2646 [label="FullWidth 146731"];
2647 [label="this.AdjustFlagsAndWidth(trailing); 146732"];
2648 [label="return 'int'; 146733"];
2649 [label="FullWidth = this.Text.Length; 146734"];
2650 [label="FullWidth 146735"];
2651 [label="return 'int'; 146736"];
2652 [label="FullWidth = this.Text.Length; 146737"];
2653 [label="FullWidth 146738"];
2654 [label="this.AdjustFlagsAndWidth(leading); 146739"];
2655 [label="return 'int'; 146740"];
2656 [label="FullWidth = this.Text.Length; 146741"];
2657 [label="FullWidth 146742"];
2658 [label="this.AdjustFlagsAndWidth(trailing); 146743"];
2659 [label="return 'int'; 146744"];
2660 [label="FullWidth = this.Text.Length; 146745"];
2661 [label="FullWidth 146746"];
2662 [label="this.AdjustFlagsAndWidth(trailing); 146747"];
2663 [label="return 'uint'; 146748"];
2664 [label="FullWidth = this.Text.Length; 146749"];
2665 [label="FullWidth 146750"];
2666 [label="return 'uint'; 146751"];
2667 [label="FullWidth = this.Text.Length; 146752"];
2668 [label="FullWidth 146753"];
2669 [label="this.AdjustFlagsAndWidth(leading); 146754"];
2670 [label="return 'uint'; 146755"];
2671 [label="FullWidth = this.Text.Length; 146756"];
2672 [label="FullWidth 146757"];
2673 [label="this.AdjustFlagsAndWidth(trailing); 146758"];
2674 [label="return 'uint'; 146759"];
2675 [label="FullWidth = this.Text.Length; 146760"];
2676 [label="FullWidth 146761"];
2677 [label="this.AdjustFlagsAndWidth(trailing); 146762"];
2678 [label="return 'long'; 146763"];
2679 [label="FullWidth = this.Text.Length; 146764"];
2680 [label="FullWidth 146765"];
2681 [label="return 'long'; 146766"];
2682 [label="FullWidth = this.Text.Length; 146767"];
2683 [label="FullWidth 146768"];
2684 [label="this.AdjustFlagsAndWidth(leading); 146769"];
2685 [label="return 'long'; 146770"];
2686 [label="FullWidth = this.Text.Length; 146771"];
2687 [label="FullWidth 146772"];
2688 [label="this.AdjustFlagsAndWidth(trailing); 146773"];
2689 [label="return 'long'; 146774"];
2690 [label="FullWidth = this.Text.Length; 146775"];
2691 [label="FullWidth 146776"];
2692 [label="this.AdjustFlagsAndWidth(trailing); 146777"];
2693 [label="return 'ulong'; 146778"];
2694 [label="FullWidth = this.Text.Length; 146779"];
2695 [label="FullWidth 146780"];
2696 [label="return 'ulong'; 146781"];
2697 [label="FullWidth = this.Text.Length; 146782"];
2698 [label="FullWidth 146783"];
2699 [label="this.AdjustFlagsAndWidth(leading); 146784"];
2700 [label="return 'ulong'; 146785"];
2701 [label="FullWidth = this.Text.Length; 146786"];
2702 [label="FullWidth 146787"];
2703 [label="this.AdjustFlagsAndWidth(trailing); 146788"];
2704 [label="return 'ulong'; 146789"];
2705 [label="FullWidth = this.Text.Length; 146790"];
2706 [label="FullWidth 146791"];
2707 [label="this.AdjustFlagsAndWidth(trailing); 146792"];
2708 [label="return 'double'; 146793"];
2709 [label="FullWidth = this.Text.Length; 146794"];
2710 [label="FullWidth 146795"];
2711 [label="return 'double'; 146796"];
2712 [label="FullWidth = this.Text.Length; 146797"];
2713 [label="FullWidth 146798"];
2714 [label="this.AdjustFlagsAndWidth(leading); 146799"];
2715 [label="return 'double'; 146800"];
2716 [label="FullWidth = this.Text.Length; 146801"];
2717 [label="FullWidth 146802"];
2718 [label="this.AdjustFlagsAndWidth(trailing); 146803"];
2719 [label="return 'double'; 146804"];
2720 [label="FullWidth = this.Text.Length; 146805"];
2721 [label="FullWidth 146806"];
2722 [label="this.AdjustFlagsAndWidth(trailing); 146807"];
2723 [label="return 'float'; 146808"];
2724 [label="FullWidth = this.Text.Length; 146809"];
2725 [label="FullWidth 146810"];
2726 [label="return 'float'; 146811"];
2727 [label="FullWidth = this.Text.Length; 146812"];
2728 [label="FullWidth 146813"];
2729 [label="this.AdjustFlagsAndWidth(leading); 146814"];
2730 [label="return 'float'; 146815"];
2731 [label="FullWidth = this.Text.Length; 146816"];
2732 [label="FullWidth 146817"];
2733 [label="this.AdjustFlagsAndWidth(trailing); 146818"];
2734 [label="return 'float'; 146819"];
2735 [label="FullWidth = this.Text.Length; 146820"];
2736 [label="FullWidth 146821"];
2737 [label="this.AdjustFlagsAndWidth(trailing); 146822"];
2738 [label="return 'decimal'; 146823"];
2739 [label="FullWidth = this.Text.Length; 146824"];
2740 [label="FullWidth 146825"];
2741 [label="return 'decimal'; 146826"];
2742 [label="FullWidth = this.Text.Length; 146827"];
2743 [label="FullWidth 146828"];
2744 [label="this.AdjustFlagsAndWidth(leading); 146829"];
2745 [label="return 'decimal'; 146830"];
2746 [label="FullWidth = this.Text.Length; 146831"];
2747 [label="FullWidth 146832"];
2748 [label="this.AdjustFlagsAndWidth(trailing); 146833"];
2749 [label="return 'decimal'; 146834"];
2750 [label="FullWidth = this.Text.Length; 146835"];
2751 [label="FullWidth 146836"];
2752 [label="this.AdjustFlagsAndWidth(trailing); 146837"];
2753 [label="return 'string'; 146838"];
2754 [label="FullWidth = this.Text.Length; 146839"];
2755 [label="FullWidth 146840"];
2756 [label="return 'string'; 146841"];
2757 [label="FullWidth = this.Text.Length; 146842"];
2758 [label="FullWidth 146843"];
2759 [label="this.AdjustFlagsAndWidth(leading); 146844"];
2760 [label="return 'string'; 146845"];
2761 [label="FullWidth = this.Text.Length; 146846"];
2762 [label="FullWidth 146847"];
2763 [label="this.AdjustFlagsAndWidth(trailing); 146848"];
2764 [label="return 'string'; 146849"];
2765 [label="FullWidth = this.Text.Length; 146850"];
2766 [label="FullWidth 146851"];
2767 [label="this.AdjustFlagsAndWidth(trailing); 146852"];
2768 [label="return 'char'; 146853"];
2769 [label="FullWidth = this.Text.Length; 146854"];
2770 [label="FullWidth 146855"];
2771 [label="return 'char'; 146856"];
2772 [label="FullWidth = this.Text.Length; 146857"];
2773 [label="FullWidth 146858"];
2774 [label="this.AdjustFlagsAndWidth(leading); 146859"];
2775 [label="return 'char'; 146860"];
2776 [label="FullWidth = this.Text.Length; 146861"];
2777 [label="FullWidth 146862"];
2778 [label="this.AdjustFlagsAndWidth(trailing); 146863"];
2779 [label="return 'char'; 146864"];
2780 [label="FullWidth = this.Text.Length; 146865"];
2781 [label="FullWidth 146866"];
2782 [label="this.AdjustFlagsAndWidth(trailing); 146867"];
2783 [label="return 'void'; 146868"];
2784 [label="FullWidth = this.Text.Length; 146869"];
2785 [label="FullWidth 146870"];
2786 [label="return 'void'; 146871"];
2787 [label="FullWidth = this.Text.Length; 146872"];
2788 [label="FullWidth 146873"];
2789 [label="this.AdjustFlagsAndWidth(leading); 146874"];
2790 [label="return 'void'; 146875"];
2791 [label="FullWidth = this.Text.Length; 146876"];
2792 [label="FullWidth 146877"];
2793 [label="this.AdjustFlagsAndWidth(trailing); 146878"];
2794 [label="return 'void'; 146879"];
2795 [label="FullWidth = this.Text.Length; 146880"];
2796 [label="FullWidth 146881"];
2797 [label="this.AdjustFlagsAndWidth(trailing); 146882"];
2798 [label="return 'object'; 146883"];
2799 [label="FullWidth = this.Text.Length; 146884"];
2800 [label="FullWidth 146885"];
2801 [label="return 'object'; 146886"];
2802 [label="FullWidth = this.Text.Length; 146887"];
2803 [label="FullWidth 146888"];
2804 [label="this.AdjustFlagsAndWidth(leading); 146889"];
2805 [label="return 'object'; 146890"];
2806 [label="FullWidth = this.Text.Length; 146891"];
2807 [label="FullWidth 146892"];
2808 [label="this.AdjustFlagsAndWidth(trailing); 146893"];
2809 [label="return 'object'; 146894"];
2810 [label="FullWidth = this.Text.Length; 146895"];
2811 [label="FullWidth 146896"];
2812 [label="this.AdjustFlagsAndWidth(trailing); 146897"];
2813 [label="return 'typeof'; 146898"];
2814 [label="FullWidth = this.Text.Length; 146899"];
2815 [label="FullWidth 146900"];
2816 [label="return 'typeof'; 146901"];
2817 [label="FullWidth = this.Text.Length; 146902"];
2818 [label="FullWidth 146903"];
2819 [label="this.AdjustFlagsAndWidth(leading); 146904"];
2820 [label="return 'typeof'; 146905"];
2821 [label="FullWidth = this.Text.Length; 146906"];
2822 [label="FullWidth 146907"];
2823 [label="this.AdjustFlagsAndWidth(trailing); 146908"];
2824 [label="return 'typeof'; 146909"];
2825 [label="FullWidth = this.Text.Length; 146910"];
2826 [label="FullWidth 146911"];
2827 [label="this.AdjustFlagsAndWidth(trailing); 146912"];
2828 [label="return 'sizeof'; 146913"];
2829 [label="FullWidth = this.Text.Length; 146914"];
2830 [label="FullWidth 146915"];
2831 [label="return 'sizeof'; 146916"];
2832 [label="FullWidth = this.Text.Length; 146917"];
2833 [label="FullWidth 146918"];
2834 [label="this.AdjustFlagsAndWidth(leading); 146919"];
2835 [label="return 'sizeof'; 146920"];
2836 [label="FullWidth = this.Text.Length; 146921"];
2837 [label="FullWidth 146922"];
2838 [label="this.AdjustFlagsAndWidth(trailing); 146923"];
2839 [label="return 'sizeof'; 146924"];
2840 [label="FullWidth = this.Text.Length; 146925"];
2841 [label="FullWidth 146926"];
2842 [label="this.AdjustFlagsAndWidth(trailing); 146927"];
2843 [label="return 'null'; 146928"];
2844 [label="FullWidth = this.Text.Length; 146929"];
2845 [label="FullWidth 146930"];
2846 [label="return 'null'; 146931"];
2847 [label="FullWidth = this.Text.Length; 146932"];
2848 [label="FullWidth 146933"];
2849 [label="this.AdjustFlagsAndWidth(leading); 146934"];
2850 [label="return 'null'; 146935"];
2851 [label="FullWidth = this.Text.Length; 146936"];
2852 [label="FullWidth 146937"];
2853 [label="this.AdjustFlagsAndWidth(trailing); 146938"];
2854 [label="return 'null'; 146939"];
2855 [label="FullWidth = this.Text.Length; 146940"];
2856 [label="FullWidth 146941"];
2857 [label="this.AdjustFlagsAndWidth(trailing); 146942"];
2858 [label="return 'true'; 146943"];
2859 [label="FullWidth = this.Text.Length; 146944"];
2860 [label="FullWidth 146945"];
2861 [label="return 'true'; 146946"];
2862 [label="FullWidth = this.Text.Length; 146947"];
2863 [label="FullWidth 146948"];
2864 [label="this.AdjustFlagsAndWidth(leading); 146949"];
2865 [label="return 'true'; 146950"];
2866 [label="FullWidth = this.Text.Length; 146951"];
2867 [label="FullWidth 146952"];
2868 [label="this.AdjustFlagsAndWidth(trailing); 146953"];
2869 [label="return 'true'; 146954"];
2870 [label="FullWidth = this.Text.Length; 146955"];
2871 [label="FullWidth 146956"];
2872 [label="this.AdjustFlagsAndWidth(trailing); 146957"];
2873 [label="return 'false'; 146958"];
2874 [label="FullWidth = this.Text.Length; 146959"];
2875 [label="FullWidth 146960"];
2876 [label="return 'false'; 146961"];
2877 [label="FullWidth = this.Text.Length; 146962"];
2878 [label="FullWidth 146963"];
2879 [label="this.AdjustFlagsAndWidth(leading); 146964"];
2880 [label="return 'false'; 146965"];
2881 [label="FullWidth = this.Text.Length; 146966"];
2882 [label="FullWidth 146967"];
2883 [label="this.AdjustFlagsAndWidth(trailing); 146968"];
2884 [label="return 'false'; 146969"];
2885 [label="FullWidth = this.Text.Length; 146970"];
2886 [label="FullWidth 146971"];
2887 [label="this.AdjustFlagsAndWidth(trailing); 146972"];
2888 [label="return 'if'; 146973"];
2889 [label="FullWidth = this.Text.Length; 146974"];
2890 [label="FullWidth 146975"];
2891 [label="return 'if'; 146976"];
2892 [label="FullWidth = this.Text.Length; 146977"];
2893 [label="FullWidth 146978"];
2894 [label="this.AdjustFlagsAndWidth(leading); 146979"];
2895 [label="return 'if'; 146980"];
2896 [label="FullWidth = this.Text.Length; 146981"];
2897 [label="FullWidth 146982"];
2898 [label="this.AdjustFlagsAndWidth(trailing); 146983"];
2899 [label="return 'if'; 146984"];
2900 [label="FullWidth = this.Text.Length; 146985"];
2901 [label="FullWidth 146986"];
2902 [label="this.AdjustFlagsAndWidth(trailing); 146987"];
2903 [label="return 'else'; 146988"];
2904 [label="FullWidth = this.Text.Length; 146989"];
2905 [label="FullWidth 146990"];
2906 [label="return 'else'; 146991"];
2907 [label="FullWidth = this.Text.Length; 146992"];
2908 [label="FullWidth 146993"];
2909 [label="this.AdjustFlagsAndWidth(leading); 146994"];
2910 [label="return 'else'; 146995"];
2911 [label="FullWidth = this.Text.Length; 146996"];
2912 [label="FullWidth 146997"];
2913 [label="this.AdjustFlagsAndWidth(trailing); 146998"];
2914 [label="return 'else'; 146999"];
2915 [label="FullWidth = this.Text.Length; 147000"];
2916 [label="FullWidth 147001"];
2917 [label="this.AdjustFlagsAndWidth(trailing); 147002"];
2918 [label="return 'while'; 147003"];
2919 [label="FullWidth = this.Text.Length; 147004"];
2920 [label="FullWidth 147005"];
2921 [label="return 'while'; 147006"];
2922 [label="FullWidth = this.Text.Length; 147007"];
2923 [label="FullWidth 147008"];
2924 [label="this.AdjustFlagsAndWidth(leading); 147009"];
2925 [label="return 'while'; 147010"];
2926 [label="FullWidth = this.Text.Length; 147011"];
2927 [label="FullWidth 147012"];
2928 [label="this.AdjustFlagsAndWidth(trailing); 147013"];
2929 [label="return 'while'; 147014"];
2930 [label="FullWidth = this.Text.Length; 147015"];
2931 [label="FullWidth 147016"];
2932 [label="this.AdjustFlagsAndWidth(trailing); 147017"];
2933 [label="return 'for'; 147018"];
2934 [label="FullWidth = this.Text.Length; 147019"];
2935 [label="FullWidth 147020"];
2936 [label="return 'for'; 147021"];
2937 [label="FullWidth = this.Text.Length; 147022"];
2938 [label="FullWidth 147023"];
2939 [label="this.AdjustFlagsAndWidth(leading); 147024"];
2940 [label="return 'for'; 147025"];
2941 [label="FullWidth = this.Text.Length; 147026"];
2942 [label="FullWidth 147027"];
2943 [label="this.AdjustFlagsAndWidth(trailing); 147028"];
2944 [label="return 'for'; 147029"];
2945 [label="FullWidth = this.Text.Length; 147030"];
2946 [label="FullWidth 147031"];
2947 [label="this.AdjustFlagsAndWidth(trailing); 147032"];
2948 [label="return 'foreach'; 147033"];
2949 [label="FullWidth = this.Text.Length; 147034"];
2950 [label="FullWidth 147035"];
2951 [label="return 'foreach'; 147036"];
2952 [label="FullWidth = this.Text.Length; 147037"];
2953 [label="FullWidth 147038"];
2954 [label="this.AdjustFlagsAndWidth(leading); 147039"];
2955 [label="return 'foreach'; 147040"];
2956 [label="FullWidth = this.Text.Length; 147041"];
2957 [label="FullWidth 147042"];
2958 [label="this.AdjustFlagsAndWidth(trailing); 147043"];
2959 [label="return 'foreach'; 147044"];
2960 [label="FullWidth = this.Text.Length; 147045"];
2961 [label="FullWidth 147046"];
2962 [label="this.AdjustFlagsAndWidth(trailing); 147047"];
2963 [label="return 'do'; 147048"];
2964 [label="FullWidth = this.Text.Length; 147049"];
2965 [label="FullWidth 147050"];
2966 [label="return 'do'; 147051"];
2967 [label="FullWidth = this.Text.Length; 147052"];
2968 [label="FullWidth 147053"];
2969 [label="this.AdjustFlagsAndWidth(leading); 147054"];
2970 [label="return 'do'; 147055"];
2971 [label="FullWidth = this.Text.Length; 147056"];
2972 [label="FullWidth 147057"];
2973 [label="this.AdjustFlagsAndWidth(trailing); 147058"];
2974 [label="return 'do'; 147059"];
2975 [label="FullWidth = this.Text.Length; 147060"];
2976 [label="FullWidth 147061"];
2977 [label="this.AdjustFlagsAndWidth(trailing); 147062"];
2978 [label="return 'switch'; 147063"];
2979 [label="FullWidth = this.Text.Length; 147064"];
2980 [label="FullWidth 147065"];
2981 [label="return 'switch'; 147066"];
2982 [label="FullWidth = this.Text.Length; 147067"];
2983 [label="FullWidth 147068"];
2984 [label="this.AdjustFlagsAndWidth(leading); 147069"];
2985 [label="return 'switch'; 147070"];
2986 [label="FullWidth = this.Text.Length; 147071"];
2987 [label="FullWidth 147072"];
2988 [label="this.AdjustFlagsAndWidth(trailing); 147073"];
2989 [label="return 'switch'; 147074"];
2990 [label="FullWidth = this.Text.Length; 147075"];
2991 [label="FullWidth 147076"];
2992 [label="this.AdjustFlagsAndWidth(trailing); 147077"];
2993 [label="return 'case'; 147078"];
2994 [label="FullWidth = this.Text.Length; 147079"];
2995 [label="FullWidth 147080"];
2996 [label="return 'case'; 147081"];
2997 [label="FullWidth = this.Text.Length; 147082"];
2998 [label="FullWidth 147083"];
2999 [label="this.AdjustFlagsAndWidth(leading); 147084"];
3000 [label="return 'case'; 147085"];
3001 [label="FullWidth = this.Text.Length; 147086"];
3002 [label="FullWidth 147087"];
3003 [label="this.AdjustFlagsAndWidth(trailing); 147088"];
3004 [label="return 'case'; 147089"];
3005 [label="FullWidth = this.Text.Length; 147090"];
3006 [label="FullWidth 147091"];
3007 [label="this.AdjustFlagsAndWidth(trailing); 147092"];
3008 [label="return 'default'; 147093"];
3009 [label="FullWidth = this.Text.Length; 147094"];
3010 [label="FullWidth 147095"];
3011 [label="return 'default'; 147096"];
3012 [label="FullWidth = this.Text.Length; 147097"];
3013 [label="FullWidth 147098"];
3014 [label="this.AdjustFlagsAndWidth(leading); 147099"];
3015 [label="return 'default'; 147100"];
3016 [label="FullWidth = this.Text.Length; 147101"];
3017 [label="FullWidth 147102"];
3018 [label="this.AdjustFlagsAndWidth(trailing); 147103"];
3019 [label="return 'default'; 147104"];
3020 [label="FullWidth = this.Text.Length; 147105"];
3021 [label="FullWidth 147106"];
3022 [label="this.AdjustFlagsAndWidth(trailing); 147107"];
3023 [label="return 'try'; 147108"];
3024 [label="FullWidth = this.Text.Length; 147109"];
3025 [label="FullWidth 147110"];
3026 [label="return 'try'; 147111"];
3027 [label="FullWidth = this.Text.Length; 147112"];
3028 [label="FullWidth 147113"];
3029 [label="this.AdjustFlagsAndWidth(leading); 147114"];
3030 [label="return 'try'; 147115"];
3031 [label="FullWidth = this.Text.Length; 147116"];
3032 [label="FullWidth 147117"];
3033 [label="this.AdjustFlagsAndWidth(trailing); 147118"];
3034 [label="return 'try'; 147119"];
3035 [label="FullWidth = this.Text.Length; 147120"];
3036 [label="FullWidth 147121"];
3037 [label="this.AdjustFlagsAndWidth(trailing); 147122"];
3038 [label="return 'catch'; 147123"];
3039 [label="FullWidth = this.Text.Length; 147124"];
3040 [label="FullWidth 147125"];
3041 [label="return 'catch'; 147126"];
3042 [label="FullWidth = this.Text.Length; 147127"];
3043 [label="FullWidth 147128"];
3044 [label="this.AdjustFlagsAndWidth(leading); 147129"];
3045 [label="return 'catch'; 147130"];
3046 [label="FullWidth = this.Text.Length; 147131"];
3047 [label="FullWidth 147132"];
3048 [label="this.AdjustFlagsAndWidth(trailing); 147133"];
3049 [label="return 'catch'; 147134"];
3050 [label="FullWidth = this.Text.Length; 147135"];
3051 [label="FullWidth 147136"];
3052 [label="this.AdjustFlagsAndWidth(trailing); 147137"];
3053 [label="return 'finally'; 147138"];
3054 [label="FullWidth = this.Text.Length; 147139"];
3055 [label="FullWidth 147140"];
3056 [label="return 'finally'; 147141"];
3057 [label="FullWidth = this.Text.Length; 147142"];
3058 [label="FullWidth 147143"];
3059 [label="this.AdjustFlagsAndWidth(leading); 147144"];
3060 [label="return 'finally'; 147145"];
3061 [label="FullWidth = this.Text.Length; 147146"];
3062 [label="FullWidth 147147"];
3063 [label="this.AdjustFlagsAndWidth(trailing); 147148"];
3064 [label="return 'finally'; 147149"];
3065 [label="FullWidth = this.Text.Length; 147150"];
3066 [label="FullWidth 147151"];
3067 [label="this.AdjustFlagsAndWidth(trailing); 147152"];
3068 [label="return 'lock'; 147153"];
3069 [label="FullWidth = this.Text.Length; 147154"];
3070 [label="FullWidth 147155"];
3071 [label="return 'lock'; 147156"];
3072 [label="FullWidth = this.Text.Length; 147157"];
3073 [label="FullWidth 147158"];
3074 [label="this.AdjustFlagsAndWidth(leading); 147159"];
3075 [label="return 'lock'; 147160"];
3076 [label="FullWidth = this.Text.Length; 147161"];
3077 [label="FullWidth 147162"];
3078 [label="this.AdjustFlagsAndWidth(trailing); 147163"];
3079 [label="return 'lock'; 147164"];
3080 [label="FullWidth = this.Text.Length; 147165"];
3081 [label="FullWidth 147166"];
3082 [label="this.AdjustFlagsAndWidth(trailing); 147167"];
3083 [label="return 'goto'; 147168"];
3084 [label="FullWidth = this.Text.Length; 147169"];
3085 [label="FullWidth 147170"];
3086 [label="return 'goto'; 147171"];
3087 [label="FullWidth = this.Text.Length; 147172"];
3088 [label="FullWidth 147173"];
3089 [label="this.AdjustFlagsAndWidth(leading); 147174"];
3090 [label="return 'goto'; 147175"];
3091 [label="FullWidth = this.Text.Length; 147176"];
3092 [label="FullWidth 147177"];
3093 [label="this.AdjustFlagsAndWidth(trailing); 147178"];
3094 [label="return 'goto'; 147179"];
3095 [label="FullWidth = this.Text.Length; 147180"];
3096 [label="FullWidth 147181"];
3097 [label="this.AdjustFlagsAndWidth(trailing); 147182"];
3098 [label="return 'break'; 147183"];
3099 [label="FullWidth = this.Text.Length; 147184"];
3100 [label="FullWidth 147185"];
3101 [label="return 'break'; 147186"];
3102 [label="FullWidth = this.Text.Length; 147187"];
3103 [label="FullWidth 147188"];
3104 [label="this.AdjustFlagsAndWidth(leading); 147189"];
3105 [label="return 'break'; 147190"];
3106 [label="FullWidth = this.Text.Length; 147191"];
3107 [label="FullWidth 147192"];
3108 [label="this.AdjustFlagsAndWidth(trailing); 147193"];
3109 [label="return 'break'; 147194"];
3110 [label="FullWidth = this.Text.Length; 147195"];
3111 [label="FullWidth 147196"];
3112 [label="this.AdjustFlagsAndWidth(trailing); 147197"];
3113 [label="return 'continue'; 147198"];
3114 [label="FullWidth = this.Text.Length; 147199"];
3115 [label="FullWidth 147200"];
3116 [label="return 'continue'; 147201"];
3117 [label="FullWidth = this.Text.Length; 147202"];
3118 [label="FullWidth 147203"];
3119 [label="this.AdjustFlagsAndWidth(leading); 147204"];
3120 [label="return 'continue'; 147205"];
3121 [label="FullWidth = this.Text.Length; 147206"];
3122 [label="FullWidth 147207"];
3123 [label="this.AdjustFlagsAndWidth(trailing); 147208"];
3124 [label="return 'continue'; 147209"];
3125 [label="FullWidth = this.Text.Length; 147210"];
3126 [label="FullWidth 147211"];
3127 [label="this.AdjustFlagsAndWidth(trailing); 147212"];
3128 [label="return 'return'; 147213"];
3129 [label="FullWidth = this.Text.Length; 147214"];
3130 [label="FullWidth 147215"];
3131 [label="return 'return'; 147216"];
3132 [label="FullWidth = this.Text.Length; 147217"];
3133 [label="FullWidth 147218"];
3134 [label="this.AdjustFlagsAndWidth(leading); 147219"];
3135 [label="return 'return'; 147220"];
3136 [label="FullWidth = this.Text.Length; 147221"];
3137 [label="FullWidth 147222"];
3138 [label="this.AdjustFlagsAndWidth(trailing); 147223"];
3139 [label="return 'return'; 147224"];
3140 [label="FullWidth = this.Text.Length; 147225"];
3141 [label="FullWidth 147226"];
3142 [label="this.AdjustFlagsAndWidth(trailing); 147227"];
3143 [label="return 'throw'; 147228"];
3144 [label="FullWidth = this.Text.Length; 147229"];
3145 [label="FullWidth 147230"];
3146 [label="return 'throw'; 147231"];
3147 [label="FullWidth = this.Text.Length; 147232"];
3148 [label="FullWidth 147233"];
3149 [label="this.AdjustFlagsAndWidth(leading); 147234"];
3150 [label="return 'throw'; 147235"];
3151 [label="FullWidth = this.Text.Length; 147236"];
3152 [label="FullWidth 147237"];
3153 [label="this.AdjustFlagsAndWidth(trailing); 147238"];
3154 [label="return 'throw'; 147239"];
3155 [label="FullWidth = this.Text.Length; 147240"];
3156 [label="FullWidth 147241"];
3157 [label="this.AdjustFlagsAndWidth(trailing); 147242"];
3158 [label="return 'public'; 147243"];
3159 [label="FullWidth = this.Text.Length; 147244"];
3160 [label="FullWidth 147245"];
3161 [label="return 'public'; 147246"];
3162 [label="FullWidth = this.Text.Length; 147247"];
3163 [label="FullWidth 147248"];
3164 [label="this.AdjustFlagsAndWidth(leading); 147249"];
3165 [label="return 'public'; 147250"];
3166 [label="FullWidth = this.Text.Length; 147251"];
3167 [label="FullWidth 147252"];
3168 [label="this.AdjustFlagsAndWidth(trailing); 147253"];
3169 [label="return 'public'; 147254"];
3170 [label="FullWidth = this.Text.Length; 147255"];
3171 [label="FullWidth 147256"];
3172 [label="this.AdjustFlagsAndWidth(trailing); 147257"];
3173 [label="return 'private'; 147258"];
3174 [label="FullWidth = this.Text.Length; 147259"];
3175 [label="FullWidth 147260"];
3176 [label="return 'private'; 147261"];
3177 [label="FullWidth = this.Text.Length; 147262"];
3178 [label="FullWidth 147263"];
3179 [label="this.AdjustFlagsAndWidth(leading); 147264"];
3180 [label="return 'private'; 147265"];
3181 [label="FullWidth = this.Text.Length; 147266"];
3182 [label="FullWidth 147267"];
3183 [label="this.AdjustFlagsAndWidth(trailing); 147268"];
3184 [label="return 'private'; 147269"];
3185 [label="FullWidth = this.Text.Length; 147270"];
3186 [label="FullWidth 147271"];
3187 [label="this.AdjustFlagsAndWidth(trailing); 147272"];
3188 [label="return 'internal'; 147273"];
3189 [label="FullWidth = this.Text.Length; 147274"];
3190 [label="FullWidth 147275"];
3191 [label="return 'internal'; 147276"];
3192 [label="FullWidth = this.Text.Length; 147277"];
3193 [label="FullWidth 147278"];
3194 [label="this.AdjustFlagsAndWidth(leading); 147279"];
3195 [label="return 'internal'; 147280"];
3196 [label="FullWidth = this.Text.Length; 147281"];
3197 [label="FullWidth 147282"];
3198 [label="this.AdjustFlagsAndWidth(trailing); 147283"];
3199 [label="return 'internal'; 147284"];
3200 [label="FullWidth = this.Text.Length; 147285"];
3201 [label="FullWidth 147286"];
3202 [label="this.AdjustFlagsAndWidth(trailing); 147287"];
3203 [label="return 'protected'; 147288"];
3204 [label="FullWidth = this.Text.Length; 147289"];
3205 [label="FullWidth 147290"];
3206 [label="return 'protected'; 147291"];
3207 [label="FullWidth = this.Text.Length; 147292"];
3208 [label="FullWidth 147293"];
3209 [label="this.AdjustFlagsAndWidth(leading); 147294"];
3210 [label="return 'protected'; 147295"];
3211 [label="FullWidth = this.Text.Length; 147296"];
3212 [label="FullWidth 147297"];
3213 [label="this.AdjustFlagsAndWidth(trailing); 147298"];
3214 [label="return 'protected'; 147299"];
3215 [label="FullWidth = this.Text.Length; 147300"];
3216 [label="FullWidth 147301"];
3217 [label="this.AdjustFlagsAndWidth(trailing); 147302"];
3218 [label="return 'static'; 147303"];
3219 [label="FullWidth = this.Text.Length; 147304"];
3220 [label="FullWidth 147305"];
3221 [label="return 'static'; 147306"];
3222 [label="FullWidth = this.Text.Length; 147307"];
3223 [label="FullWidth 147308"];
3224 [label="this.AdjustFlagsAndWidth(leading); 147309"];
3225 [label="return 'static'; 147310"];
3226 [label="FullWidth = this.Text.Length; 147311"];
3227 [label="FullWidth 147312"];
3228 [label="this.AdjustFlagsAndWidth(trailing); 147313"];
3229 [label="return 'static'; 147314"];
3230 [label="FullWidth = this.Text.Length; 147315"];
3231 [label="FullWidth 147316"];
3232 [label="this.AdjustFlagsAndWidth(trailing); 147317"];
3233 [label="return 'readonly'; 147318"];
3234 [label="FullWidth = this.Text.Length; 147319"];
3235 [label="FullWidth 147320"];
3236 [label="return 'readonly'; 147321"];
3237 [label="FullWidth = this.Text.Length; 147322"];
3238 [label="FullWidth 147323"];
3239 [label="this.AdjustFlagsAndWidth(leading); 147324"];
3240 [label="return 'readonly'; 147325"];
3241 [label="FullWidth = this.Text.Length; 147326"];
3242 [label="FullWidth 147327"];
3243 [label="this.AdjustFlagsAndWidth(trailing); 147328"];
3244 [label="return 'readonly'; 147329"];
3245 [label="FullWidth = this.Text.Length; 147330"];
3246 [label="FullWidth 147331"];
3247 [label="this.AdjustFlagsAndWidth(trailing); 147332"];
3248 [label="return 'sealed'; 147333"];
3249 [label="FullWidth = this.Text.Length; 147334"];
3250 [label="FullWidth 147335"];
3251 [label="return 'sealed'; 147336"];
3252 [label="FullWidth = this.Text.Length; 147337"];
3253 [label="FullWidth 147338"];
3254 [label="this.AdjustFlagsAndWidth(leading); 147339"];
3255 [label="return 'sealed'; 147340"];
3256 [label="FullWidth = this.Text.Length; 147341"];
3257 [label="FullWidth 147342"];
3258 [label="this.AdjustFlagsAndWidth(trailing); 147343"];
3259 [label="return 'sealed'; 147344"];
3260 [label="FullWidth = this.Text.Length; 147345"];
3261 [label="FullWidth 147346"];
3262 [label="this.AdjustFlagsAndWidth(trailing); 147347"];
3263 [label="return 'const'; 147348"];
3264 [label="FullWidth = this.Text.Length; 147349"];
3265 [label="FullWidth 147350"];
3266 [label="return 'const'; 147351"];
3267 [label="FullWidth = this.Text.Length; 147352"];
3268 [label="FullWidth 147353"];
3269 [label="this.AdjustFlagsAndWidth(leading); 147354"];
3270 [label="return 'const'; 147355"];
3271 [label="FullWidth = this.Text.Length; 147356"];
3272 [label="FullWidth 147357"];
3273 [label="this.AdjustFlagsAndWidth(trailing); 147358"];
3274 [label="return 'const'; 147359"];
3275 [label="FullWidth = this.Text.Length; 147360"];
3276 [label="FullWidth 147361"];
3277 [label="this.AdjustFlagsAndWidth(trailing); 147362"];
3278 [label="return 'fixed'; 147363"];
3279 [label="FullWidth = this.Text.Length; 147364"];
3280 [label="FullWidth 147365"];
3281 [label="return 'fixed'; 147366"];
3282 [label="FullWidth = this.Text.Length; 147367"];
3283 [label="FullWidth 147368"];
3284 [label="this.AdjustFlagsAndWidth(leading); 147369"];
3285 [label="return 'fixed'; 147370"];
3286 [label="FullWidth = this.Text.Length; 147371"];
3287 [label="FullWidth 147372"];
3288 [label="this.AdjustFlagsAndWidth(trailing); 147373"];
3289 [label="return 'fixed'; 147374"];
3290 [label="FullWidth = this.Text.Length; 147375"];
3291 [label="FullWidth 147376"];
3292 [label="this.AdjustFlagsAndWidth(trailing); 147377"];
3293 [label="return 'stackalloc'; 147378"];
3294 [label="FullWidth = this.Text.Length; 147379"];
3295 [label="FullWidth 147380"];
3296 [label="return 'stackalloc'; 147381"];
3297 [label="FullWidth = this.Text.Length; 147382"];
3298 [label="FullWidth 147383"];
3299 [label="this.AdjustFlagsAndWidth(leading); 147384"];
3300 [label="return 'stackalloc'; 147385"];
3301 [label="FullWidth = this.Text.Length; 147386"];
3302 [label="FullWidth 147387"];
3303 [label="this.AdjustFlagsAndWidth(trailing); 147388"];
3304 [label="return 'stackalloc'; 147389"];
3305 [label="FullWidth = this.Text.Length; 147390"];
3306 [label="FullWidth 147391"];
3307 [label="this.AdjustFlagsAndWidth(trailing); 147392"];
3308 [label="return 'volatile'; 147393"];
3309 [label="FullWidth = this.Text.Length; 147394"];
3310 [label="FullWidth 147395"];
3311 [label="return 'volatile'; 147396"];
3312 [label="FullWidth = this.Text.Length; 147397"];
3313 [label="FullWidth 147398"];
3314 [label="this.AdjustFlagsAndWidth(leading); 147399"];
3315 [label="return 'volatile'; 147400"];
3316 [label="FullWidth = this.Text.Length; 147401"];
3317 [label="FullWidth 147402"];
3318 [label="this.AdjustFlagsAndWidth(trailing); 147403"];
3319 [label="return 'volatile'; 147404"];
3320 [label="FullWidth = this.Text.Length; 147405"];
3321 [label="FullWidth 147406"];
3322 [label="this.AdjustFlagsAndWidth(trailing); 147407"];
3323 [label="return 'new'; 147408"];
3324 [label="FullWidth = this.Text.Length; 147409"];
3325 [label="FullWidth 147410"];
3326 [label="return 'new'; 147411"];
3327 [label="FullWidth = this.Text.Length; 147412"];
3328 [label="FullWidth 147413"];
3329 [label="this.AdjustFlagsAndWidth(leading); 147414"];
3330 [label="return 'new'; 147415"];
3331 [label="FullWidth = this.Text.Length; 147416"];
3332 [label="FullWidth 147417"];
3333 [label="this.AdjustFlagsAndWidth(trailing); 147418"];
3334 [label="return 'new'; 147419"];
3335 [label="FullWidth = this.Text.Length; 147420"];
3336 [label="FullWidth 147421"];
3337 [label="this.AdjustFlagsAndWidth(trailing); 147422"];
3338 [label="return 'override'; 147423"];
3339 [label="FullWidth = this.Text.Length; 147424"];
3340 [label="FullWidth 147425"];
3341 [label="return 'override'; 147426"];
3342 [label="FullWidth = this.Text.Length; 147427"];
3343 [label="FullWidth 147428"];
3344 [label="this.AdjustFlagsAndWidth(leading); 147429"];
3345 [label="return 'override'; 147430"];
3346 [label="FullWidth = this.Text.Length; 147431"];
3347 [label="FullWidth 147432"];
3348 [label="this.AdjustFlagsAndWidth(trailing); 147433"];
3349 [label="return 'override'; 147434"];
3350 [label="FullWidth = this.Text.Length; 147435"];
3351 [label="FullWidth 147436"];
3352 [label="this.AdjustFlagsAndWidth(trailing); 147437"];
3353 [label="return 'abstract'; 147438"];
3354 [label="FullWidth = this.Text.Length; 147439"];
3355 [label="FullWidth 147440"];
3356 [label="return 'abstract'; 147441"];
3357 [label="FullWidth = this.Text.Length; 147442"];
3358 [label="FullWidth 147443"];
3359 [label="this.AdjustFlagsAndWidth(leading); 147444"];
3360 [label="return 'abstract'; 147445"];
3361 [label="FullWidth = this.Text.Length; 147446"];
3362 [label="FullWidth 147447"];
3363 [label="this.AdjustFlagsAndWidth(trailing); 147448"];
3364 [label="return 'abstract'; 147449"];
3365 [label="FullWidth = this.Text.Length; 147450"];
3366 [label="FullWidth 147451"];
3367 [label="this.AdjustFlagsAndWidth(trailing); 147452"];
3368 [label="return 'virtual'; 147453"];
3369 [label="FullWidth = this.Text.Length; 147454"];
3370 [label="FullWidth 147455"];
3371 [label="return 'virtual'; 147456"];
3372 [label="FullWidth = this.Text.Length; 147457"];
3373 [label="FullWidth 147458"];
3374 [label="this.AdjustFlagsAndWidth(leading); 147459"];
3375 [label="return 'virtual'; 147460"];
3376 [label="FullWidth = this.Text.Length; 147461"];
3377 [label="FullWidth 147462"];
3378 [label="this.AdjustFlagsAndWidth(trailing); 147463"];
3379 [label="return 'virtual'; 147464"];
3380 [label="FullWidth = this.Text.Length; 147465"];
3381 [label="FullWidth 147466"];
3382 [label="this.AdjustFlagsAndWidth(trailing); 147467"];
3383 [label="return 'event'; 147468"];
3384 [label="FullWidth = this.Text.Length; 147469"];
3385 [label="FullWidth 147470"];
3386 [label="return 'event'; 147471"];
3387 [label="FullWidth = this.Text.Length; 147472"];
3388 [label="FullWidth 147473"];
3389 [label="this.AdjustFlagsAndWidth(leading); 147474"];
3390 [label="return 'event'; 147475"];
3391 [label="FullWidth = this.Text.Length; 147476"];
3392 [label="FullWidth 147477"];
3393 [label="this.AdjustFlagsAndWidth(trailing); 147478"];
3394 [label="return 'event'; 147479"];
3395 [label="FullWidth = this.Text.Length; 147480"];
3396 [label="FullWidth 147481"];
3397 [label="this.AdjustFlagsAndWidth(trailing); 147482"];
3398 [label="return 'extern'; 147483"];
3399 [label="FullWidth = this.Text.Length; 147484"];
3400 [label="FullWidth 147485"];
3401 [label="return 'extern'; 147486"];
3402 [label="FullWidth = this.Text.Length; 147487"];
3403 [label="FullWidth 147488"];
3404 [label="this.AdjustFlagsAndWidth(leading); 147489"];
3405 [label="return 'extern'; 147490"];
3406 [label="FullWidth = this.Text.Length; 147491"];
3407 [label="FullWidth 147492"];
3408 [label="this.AdjustFlagsAndWidth(trailing); 147493"];
3409 [label="return 'extern'; 147494"];
3410 [label="FullWidth = this.Text.Length; 147495"];
3411 [label="FullWidth 147496"];
3412 [label="this.AdjustFlagsAndWidth(trailing); 147497"];
3413 [label="return 'ref'; 147498"];
3414 [label="FullWidth = this.Text.Length; 147499"];
3415 [label="FullWidth 147500"];
3416 [label="return 'ref'; 147501"];
3417 [label="FullWidth = this.Text.Length; 147502"];
3418 [label="FullWidth 147503"];
3419 [label="this.AdjustFlagsAndWidth(leading); 147504"];
3420 [label="return 'ref'; 147505"];
3421 [label="FullWidth = this.Text.Length; 147506"];
3422 [label="FullWidth 147507"];
3423 [label="this.AdjustFlagsAndWidth(trailing); 147508"];
3424 [label="return 'ref'; 147509"];
3425 [label="FullWidth = this.Text.Length; 147510"];
3426 [label="FullWidth 147511"];
3427 [label="this.AdjustFlagsAndWidth(trailing); 147512"];
3428 [label="return 'out'; 147513"];
3429 [label="FullWidth = this.Text.Length; 147514"];
3430 [label="FullWidth 147515"];
3431 [label="return 'out'; 147516"];
3432 [label="FullWidth = this.Text.Length; 147517"];
3433 [label="FullWidth 147518"];
3434 [label="this.AdjustFlagsAndWidth(leading); 147519"];
3435 [label="return 'out'; 147520"];
3436 [label="FullWidth = this.Text.Length; 147521"];
3437 [label="FullWidth 147522"];
3438 [label="this.AdjustFlagsAndWidth(trailing); 147523"];
3439 [label="return 'out'; 147524"];
3440 [label="FullWidth = this.Text.Length; 147525"];
3441 [label="FullWidth 147526"];
3442 [label="this.AdjustFlagsAndWidth(trailing); 147527"];
3443 [label="return 'in'; 147528"];
3444 [label="FullWidth = this.Text.Length; 147529"];
3445 [label="FullWidth 147530"];
3446 [label="return 'in'; 147531"];
3447 [label="FullWidth = this.Text.Length; 147532"];
3448 [label="FullWidth 147533"];
3449 [label="this.AdjustFlagsAndWidth(leading); 147534"];
3450 [label="return 'in'; 147535"];
3451 [label="FullWidth = this.Text.Length; 147536"];
3452 [label="FullWidth 147537"];
3453 [label="this.AdjustFlagsAndWidth(trailing); 147538"];
3454 [label="return 'in'; 147539"];
3455 [label="FullWidth = this.Text.Length; 147540"];
3456 [label="FullWidth 147541"];
3457 [label="this.AdjustFlagsAndWidth(trailing); 147542"];
3458 [label="return 'is'; 147543"];
3459 [label="FullWidth = this.Text.Length; 147544"];
3460 [label="FullWidth 147545"];
3461 [label="return 'is'; 147546"];
3462 [label="FullWidth = this.Text.Length; 147547"];
3463 [label="FullWidth 147548"];
3464 [label="this.AdjustFlagsAndWidth(leading); 147549"];
3465 [label="return 'is'; 147550"];
3466 [label="FullWidth = this.Text.Length; 147551"];
3467 [label="FullWidth 147552"];
3468 [label="this.AdjustFlagsAndWidth(trailing); 147553"];
3469 [label="return 'is'; 147554"];
3470 [label="FullWidth = this.Text.Length; 147555"];
3471 [label="FullWidth 147556"];
3472 [label="this.AdjustFlagsAndWidth(trailing); 147557"];
3473 [label="return 'as'; 147558"];
3474 [label="FullWidth = this.Text.Length; 147559"];
3475 [label="FullWidth 147560"];
3476 [label="return 'as'; 147561"];
3477 [label="FullWidth = this.Text.Length; 147562"];
3478 [label="FullWidth 147563"];
3479 [label="this.AdjustFlagsAndWidth(leading); 147564"];
3480 [label="return 'as'; 147565"];
3481 [label="FullWidth = this.Text.Length; 147566"];
3482 [label="FullWidth 147567"];
3483 [label="this.AdjustFlagsAndWidth(trailing); 147568"];
3484 [label="return 'as'; 147569"];
3485 [label="FullWidth = this.Text.Length; 147570"];
3486 [label="FullWidth 147571"];
3487 [label="this.AdjustFlagsAndWidth(trailing); 147572"];
3488 [label="return 'params'; 147573"];
3489 [label="FullWidth = this.Text.Length; 147574"];
3490 [label="FullWidth 147575"];
3491 [label="return 'params'; 147576"];
3492 [label="FullWidth = this.Text.Length; 147577"];
3493 [label="FullWidth 147578"];
3494 [label="this.AdjustFlagsAndWidth(leading); 147579"];
3495 [label="return 'params'; 147580"];
3496 [label="FullWidth = this.Text.Length; 147581"];
3497 [label="FullWidth 147582"];
3498 [label="this.AdjustFlagsAndWidth(trailing); 147583"];
3499 [label="return 'params'; 147584"];
3500 [label="FullWidth = this.Text.Length; 147585"];
3501 [label="FullWidth 147586"];
3502 [label="this.AdjustFlagsAndWidth(trailing); 147587"];
3503 [label="return '__arglist'; 147588"];
3504 [label="FullWidth = this.Text.Length; 147589"];
3505 [label="FullWidth 147590"];
3506 [label="return '__arglist'; 147591"];
3507 [label="FullWidth = this.Text.Length; 147592"];
3508 [label="FullWidth 147593"];
3509 [label="this.AdjustFlagsAndWidth(leading); 147594"];
3510 [label="return '__arglist'; 147595"];
3511 [label="FullWidth = this.Text.Length; 147596"];
3512 [label="FullWidth 147597"];
3513 [label="this.AdjustFlagsAndWidth(trailing); 147598"];
3514 [label="return '__arglist'; 147599"];
3515 [label="FullWidth = this.Text.Length; 147600"];
3516 [label="FullWidth 147601"];
3517 [label="this.AdjustFlagsAndWidth(trailing); 147602"];
3518 [label="return '__makeref'; 147603"];
3519 [label="FullWidth = this.Text.Length; 147604"];
3520 [label="FullWidth 147605"];
3521 [label="return '__makeref'; 147606"];
3522 [label="FullWidth = this.Text.Length; 147607"];
3523 [label="FullWidth 147608"];
3524 [label="this.AdjustFlagsAndWidth(leading); 147609"];
3525 [label="return '__makeref'; 147610"];
3526 [label="FullWidth = this.Text.Length; 147611"];
3527 [label="FullWidth 147612"];
3528 [label="this.AdjustFlagsAndWidth(trailing); 147613"];
3529 [label="return '__makeref'; 147614"];
3530 [label="FullWidth = this.Text.Length; 147615"];
3531 [label="FullWidth 147616"];
3532 [label="this.AdjustFlagsAndWidth(trailing); 147617"];
3533 [label="return '__reftype'; 147618"];
3534 [label="FullWidth = this.Text.Length; 147619"];
3535 [label="FullWidth 147620"];
3536 [label="return '__reftype'; 147621"];
3537 [label="FullWidth = this.Text.Length; 147622"];
3538 [label="FullWidth 147623"];
3539 [label="this.AdjustFlagsAndWidth(leading); 147624"];
3540 [label="return '__reftype'; 147625"];
3541 [label="FullWidth = this.Text.Length; 147626"];
3542 [label="FullWidth 147627"];
3543 [label="this.AdjustFlagsAndWidth(trailing); 147628"];
3544 [label="return '__reftype'; 147629"];
3545 [label="FullWidth = this.Text.Length; 147630"];
3546 [label="FullWidth 147631"];
3547 [label="this.AdjustFlagsAndWidth(trailing); 147632"];
3548 [label="return '__refvalue'; 147633"];
3549 [label="FullWidth = this.Text.Length; 147634"];
3550 [label="FullWidth 147635"];
3551 [label="return '__refvalue'; 147636"];
3552 [label="FullWidth = this.Text.Length; 147637"];
3553 [label="FullWidth 147638"];
3554 [label="this.AdjustFlagsAndWidth(leading); 147639"];
3555 [label="return '__refvalue'; 147640"];
3556 [label="FullWidth = this.Text.Length; 147641"];
3557 [label="FullWidth 147642"];
3558 [label="this.AdjustFlagsAndWidth(trailing); 147643"];
3559 [label="return '__refvalue'; 147644"];
3560 [label="FullWidth = this.Text.Length; 147645"];
3561 [label="FullWidth 147646"];
3562 [label="this.AdjustFlagsAndWidth(trailing); 147647"];
3563 [label="return 'this'; 147648"];
3564 [label="FullWidth = this.Text.Length; 147649"];
3565 [label="FullWidth 147650"];
3566 [label="return 'this'; 147651"];
3567 [label="FullWidth = this.Text.Length; 147652"];
3568 [label="FullWidth 147653"];
3569 [label="this.AdjustFlagsAndWidth(leading); 147654"];
3570 [label="return 'this'; 147655"];
3571 [label="FullWidth = this.Text.Length; 147656"];
3572 [label="FullWidth 147657"];
3573 [label="this.AdjustFlagsAndWidth(trailing); 147658"];
3574 [label="return 'this'; 147659"];
3575 [label="FullWidth = this.Text.Length; 147660"];
3576 [label="FullWidth 147661"];
3577 [label="this.AdjustFlagsAndWidth(trailing); 147662"];
3578 [label="return 'base'; 147663"];
3579 [label="FullWidth = this.Text.Length; 147664"];
3580 [label="FullWidth 147665"];
3581 [label="return 'base'; 147666"];
3582 [label="FullWidth = this.Text.Length; 147667"];
3583 [label="FullWidth 147668"];
3584 [label="this.AdjustFlagsAndWidth(leading); 147669"];
3585 [label="return 'base'; 147670"];
3586 [label="FullWidth = this.Text.Length; 147671"];
3587 [label="FullWidth 147672"];
3588 [label="this.AdjustFlagsAndWidth(trailing); 147673"];
3589 [label="return 'base'; 147674"];
3590 [label="FullWidth = this.Text.Length; 147675"];
3591 [label="FullWidth 147676"];
3592 [label="this.AdjustFlagsAndWidth(trailing); 147677"];
3593 [label="return 'namespace'; 147678"];
3594 [label="FullWidth = this.Text.Length; 147679"];
3595 [label="FullWidth 147680"];
3596 [label="return 'namespace'; 147681"];
3597 [label="FullWidth = this.Text.Length; 147682"];
3598 [label="FullWidth 147683"];
3599 [label="this.AdjustFlagsAndWidth(leading); 147684"];
3600 [label="return 'namespace'; 147685"];
3601 [label="FullWidth = this.Text.Length; 147686"];
3602 [label="FullWidth 147687"];
3603 [label="this.AdjustFlagsAndWidth(trailing); 147688"];
3604 [label="return 'namespace'; 147689"];
3605 [label="FullWidth = this.Text.Length; 147690"];
3606 [label="FullWidth 147691"];
3607 [label="this.AdjustFlagsAndWidth(trailing); 147692"];
3608 [label="return 'using'; 147693"];
3609 [label="FullWidth = this.Text.Length; 147694"];
3610 [label="FullWidth 147695"];
3611 [label="return 'using'; 147696"];
3612 [label="FullWidth = this.Text.Length; 147697"];
3613 [label="FullWidth 147698"];
3614 [label="this.AdjustFlagsAndWidth(leading); 147699"];
3615 [label="return 'using'; 147700"];
3616 [label="FullWidth = this.Text.Length; 147701"];
3617 [label="FullWidth 147702"];
3618 [label="this.AdjustFlagsAndWidth(trailing); 147703"];
3619 [label="return 'using'; 147704"];
3620 [label="FullWidth = this.Text.Length; 147705"];
3621 [label="FullWidth 147706"];
3622 [label="this.AdjustFlagsAndWidth(trailing); 147707"];
3623 [label="return 'class'; 147708"];
3624 [label="FullWidth = this.Text.Length; 147709"];
3625 [label="FullWidth 147710"];
3626 [label="return 'class'; 147711"];
3627 [label="FullWidth = this.Text.Length; 147712"];
3628 [label="FullWidth 147713"];
3629 [label="this.AdjustFlagsAndWidth(leading); 147714"];
3630 [label="return 'class'; 147715"];
3631 [label="FullWidth = this.Text.Length; 147716"];
3632 [label="FullWidth 147717"];
3633 [label="this.AdjustFlagsAndWidth(trailing); 147718"];
3634 [label="return 'class'; 147719"];
3635 [label="FullWidth = this.Text.Length; 147720"];
3636 [label="FullWidth 147721"];
3637 [label="this.AdjustFlagsAndWidth(trailing); 147722"];
3638 [label="return 'struct'; 147723"];
3639 [label="FullWidth = this.Text.Length; 147724"];
3640 [label="FullWidth 147725"];
3641 [label="return 'struct'; 147726"];
3642 [label="FullWidth = this.Text.Length; 147727"];
3643 [label="FullWidth 147728"];
3644 [label="this.AdjustFlagsAndWidth(leading); 147729"];
3645 [label="return 'struct'; 147730"];
3646 [label="FullWidth = this.Text.Length; 147731"];
3647 [label="FullWidth 147732"];
3648 [label="this.AdjustFlagsAndWidth(trailing); 147733"];
3649 [label="return 'struct'; 147734"];
3650 [label="FullWidth = this.Text.Length; 147735"];
3651 [label="FullWidth 147736"];
3652 [label="this.AdjustFlagsAndWidth(trailing); 147737"];
3653 [label="return 'interface'; 147738"];
3654 [label="FullWidth = this.Text.Length; 147739"];
3655 [label="FullWidth 147740"];
3656 [label="return 'interface'; 147741"];
3657 [label="FullWidth = this.Text.Length; 147742"];
3658 [label="FullWidth 147743"];
3659 [label="this.AdjustFlagsAndWidth(leading); 147744"];
3660 [label="return 'interface'; 147745"];
3661 [label="FullWidth = this.Text.Length; 147746"];
3662 [label="FullWidth 147747"];
3663 [label="this.AdjustFlagsAndWidth(trailing); 147748"];
3664 [label="return 'interface'; 147749"];
3665 [label="FullWidth = this.Text.Length; 147750"];
3666 [label="FullWidth 147751"];
3667 [label="this.AdjustFlagsAndWidth(trailing); 147752"];
3668 [label="return 'enum'; 147753"];
3669 [label="FullWidth = this.Text.Length; 147754"];
3670 [label="FullWidth 147755"];
3671 [label="return 'enum'; 147756"];
3672 [label="FullWidth = this.Text.Length; 147757"];
3673 [label="FullWidth 147758"];
3674 [label="this.AdjustFlagsAndWidth(leading); 147759"];
3675 [label="return 'enum'; 147760"];
3676 [label="FullWidth = this.Text.Length; 147761"];
3677 [label="FullWidth 147762"];
3678 [label="this.AdjustFlagsAndWidth(trailing); 147763"];
3679 [label="return 'enum'; 147764"];
3680 [label="FullWidth = this.Text.Length; 147765"];
3681 [label="FullWidth 147766"];
3682 [label="this.AdjustFlagsAndWidth(trailing); 147767"];
3683 [label="return 'delegate'; 147768"];
3684 [label="FullWidth = this.Text.Length; 147769"];
3685 [label="FullWidth 147770"];
3686 [label="return 'delegate'; 147771"];
3687 [label="FullWidth = this.Text.Length; 147772"];
3688 [label="FullWidth 147773"];
3689 [label="this.AdjustFlagsAndWidth(leading); 147774"];
3690 [label="return 'delegate'; 147775"];
3691 [label="FullWidth = this.Text.Length; 147776"];
3692 [label="FullWidth 147777"];
3693 [label="this.AdjustFlagsAndWidth(trailing); 147778"];
3694 [label="return 'delegate'; 147779"];
3695 [label="FullWidth = this.Text.Length; 147780"];
3696 [label="FullWidth 147781"];
3697 [label="this.AdjustFlagsAndWidth(trailing); 147782"];
3698 [label="return 'checked'; 147783"];
3699 [label="FullWidth = this.Text.Length; 147784"];
3700 [label="FullWidth 147785"];
3701 [label="return 'checked'; 147786"];
3702 [label="FullWidth = this.Text.Length; 147787"];
3703 [label="FullWidth 147788"];
3704 [label="this.AdjustFlagsAndWidth(leading); 147789"];
3705 [label="return 'checked'; 147790"];
3706 [label="FullWidth = this.Text.Length; 147791"];
3707 [label="FullWidth 147792"];
3708 [label="this.AdjustFlagsAndWidth(trailing); 147793"];
3709 [label="return 'checked'; 147794"];
3710 [label="FullWidth = this.Text.Length; 147795"];
3711 [label="FullWidth 147796"];
3712 [label="this.AdjustFlagsAndWidth(trailing); 147797"];
3713 [label="return 'unchecked'; 147798"];
3714 [label="FullWidth = this.Text.Length; 147799"];
3715 [label="FullWidth 147800"];
3716 [label="return 'unchecked'; 147801"];
3717 [label="FullWidth = this.Text.Length; 147802"];
3718 [label="FullWidth 147803"];
3719 [label="this.AdjustFlagsAndWidth(leading); 147804"];
3720 [label="return 'unchecked'; 147805"];
3721 [label="FullWidth = this.Text.Length; 147806"];
3722 [label="FullWidth 147807"];
3723 [label="this.AdjustFlagsAndWidth(trailing); 147808"];
3724 [label="return 'unchecked'; 147809"];
3725 [label="FullWidth = this.Text.Length; 147810"];
3726 [label="FullWidth 147811"];
3727 [label="this.AdjustFlagsAndWidth(trailing); 147812"];
3728 [label="return 'unsafe'; 147813"];
3729 [label="FullWidth = this.Text.Length; 147814"];
3730 [label="FullWidth 147815"];
3731 [label="return 'unsafe'; 147816"];
3732 [label="FullWidth = this.Text.Length; 147817"];
3733 [label="FullWidth 147818"];
3734 [label="this.AdjustFlagsAndWidth(leading); 147819"];
3735 [label="return 'unsafe'; 147820"];
3736 [label="FullWidth = this.Text.Length; 147821"];
3737 [label="FullWidth 147822"];
3738 [label="this.AdjustFlagsAndWidth(trailing); 147823"];
3739 [label="return 'unsafe'; 147824"];
3740 [label="FullWidth = this.Text.Length; 147825"];
3741 [label="FullWidth 147826"];
3742 [label="this.AdjustFlagsAndWidth(trailing); 147827"];
3743 [label="return 'operator'; 147828"];
3744 [label="FullWidth = this.Text.Length; 147829"];
3745 [label="FullWidth 147830"];
3746 [label="return 'operator'; 147831"];
3747 [label="FullWidth = this.Text.Length; 147832"];
3748 [label="FullWidth 147833"];
3749 [label="this.AdjustFlagsAndWidth(leading); 147834"];
3750 [label="return 'operator'; 147835"];
3751 [label="FullWidth = this.Text.Length; 147836"];
3752 [label="FullWidth 147837"];
3753 [label="this.AdjustFlagsAndWidth(trailing); 147838"];
3754 [label="return 'operator'; 147839"];
3755 [label="FullWidth = this.Text.Length; 147840"];
3756 [label="FullWidth 147841"];
3757 [label="this.AdjustFlagsAndWidth(trailing); 147842"];
3758 [label="return 'explicit'; 147843"];
3759 [label="FullWidth = this.Text.Length; 147844"];
3760 [label="FullWidth 147845"];
3761 [label="return 'explicit'; 147846"];
3762 [label="FullWidth = this.Text.Length; 147847"];
3763 [label="FullWidth 147848"];
3764 [label="this.AdjustFlagsAndWidth(leading); 147849"];
3765 [label="return 'explicit'; 147850"];
3766 [label="FullWidth = this.Text.Length; 147851"];
3767 [label="FullWidth 147852"];
3768 [label="this.AdjustFlagsAndWidth(trailing); 147853"];
3769 [label="return 'explicit'; 147854"];
3770 [label="FullWidth = this.Text.Length; 147855"];
3771 [label="FullWidth 147856"];
3772 [label="this.AdjustFlagsAndWidth(trailing); 147857"];
3773 [label="return 'implicit'; 147858"];
3774 [label="FullWidth = this.Text.Length; 147859"];
3775 [label="FullWidth 147860"];
3776 [label="return 'implicit'; 147861"];
3777 [label="FullWidth = this.Text.Length; 147862"];
3778 [label="FullWidth 147863"];
3779 [label="this.AdjustFlagsAndWidth(leading); 147864"];
3780 [label="return 'implicit'; 147865"];
3781 [label="FullWidth = this.Text.Length; 147866"];
3782 [label="FullWidth 147867"];
3783 [label="this.AdjustFlagsAndWidth(trailing); 147868"];
3784 [label="return 'implicit'; 147869"];
3785 [label="FullWidth = this.Text.Length; 147870"];
3786 [label="FullWidth 147871"];
3787 [label="this.AdjustFlagsAndWidth(trailing); 147872"];
3788 [label="return 'yield'; 147873"];
3789 [label="FullWidth = this.Text.Length; 147874"];
3790 [label="FullWidth 147875"];
3791 [label="return 'yield'; 147876"];
3792 [label="FullWidth = this.Text.Length; 147877"];
3793 [label="FullWidth 147878"];
3794 [label="this.AdjustFlagsAndWidth(leading); 147879"];
3795 [label="return 'yield'; 147880"];
3796 [label="FullWidth = this.Text.Length; 147881"];
3797 [label="FullWidth 147882"];
3798 [label="this.AdjustFlagsAndWidth(trailing); 147883"];
3799 [label="return 'yield'; 147884"];
3800 [label="FullWidth = this.Text.Length; 147885"];
3801 [label="FullWidth 147886"];
3802 [label="this.AdjustFlagsAndWidth(trailing); 147887"];
3803 [label="return 'partial'; 147888"];
3804 [label="FullWidth = this.Text.Length; 147889"];
3805 [label="FullWidth 147890"];
3806 [label="return 'partial'; 147891"];
3807 [label="FullWidth = this.Text.Length; 147892"];
3808 [label="FullWidth 147893"];
3809 [label="this.AdjustFlagsAndWidth(leading); 147894"];
3810 [label="return 'partial'; 147895"];
3811 [label="FullWidth = this.Text.Length; 147896"];
3812 [label="FullWidth 147897"];
3813 [label="this.AdjustFlagsAndWidth(trailing); 147898"];
3814 [label="return 'partial'; 147899"];
3815 [label="FullWidth = this.Text.Length; 147900"];
3816 [label="FullWidth 147901"];
3817 [label="this.AdjustFlagsAndWidth(trailing); 147902"];
3818 [label="return 'alias'; 147903"];
3819 [label="FullWidth = this.Text.Length; 147904"];
3820 [label="FullWidth 147905"];
3821 [label="return 'alias'; 147906"];
3822 [label="FullWidth = this.Text.Length; 147907"];
3823 [label="FullWidth 147908"];
3824 [label="this.AdjustFlagsAndWidth(leading); 147909"];
3825 [label="return 'alias'; 147910"];
3826 [label="FullWidth = this.Text.Length; 147911"];
3827 [label="FullWidth 147912"];
3828 [label="this.AdjustFlagsAndWidth(trailing); 147913"];
3829 [label="return 'alias'; 147914"];
3830 [label="FullWidth = this.Text.Length; 147915"];
3831 [label="FullWidth 147916"];
3832 [label="this.AdjustFlagsAndWidth(trailing); 147917"];
3833 [label="return 'global'; 147918"];
3834 [label="FullWidth = this.Text.Length; 147919"];
3835 [label="FullWidth 147920"];
3836 [label="return 'global'; 147921"];
3837 [label="FullWidth = this.Text.Length; 147922"];
3838 [label="FullWidth 147923"];
3839 [label="this.AdjustFlagsAndWidth(leading); 147924"];
3840 [label="return 'global'; 147925"];
3841 [label="FullWidth = this.Text.Length; 147926"];
3842 [label="FullWidth 147927"];
3843 [label="this.AdjustFlagsAndWidth(trailing); 147928"];
3844 [label="return 'global'; 147929"];
3845 [label="FullWidth = this.Text.Length; 147930"];
3846 [label="FullWidth 147931"];
3847 [label="this.AdjustFlagsAndWidth(trailing); 147932"];
3848 [label="return 'assembly'; 147933"];
3849 [label="FullWidth = this.Text.Length; 147934"];
3850 [label="FullWidth 147935"];
3851 [label="return 'assembly'; 147936"];
3852 [label="FullWidth = this.Text.Length; 147937"];
3853 [label="FullWidth 147938"];
3854 [label="this.AdjustFlagsAndWidth(leading); 147939"];
3855 [label="return 'assembly'; 147940"];
3856 [label="FullWidth = this.Text.Length; 147941"];
3857 [label="FullWidth 147942"];
3858 [label="this.AdjustFlagsAndWidth(trailing); 147943"];
3859 [label="return 'assembly'; 147944"];
3860 [label="FullWidth = this.Text.Length; 147945"];
3861 [label="FullWidth 147946"];
3862 [label="this.AdjustFlagsAndWidth(trailing); 147947"];
3863 [label="return 'module'; 147948"];
3864 [label="FullWidth = this.Text.Length; 147949"];
3865 [label="FullWidth 147950"];
3866 [label="return 'module'; 147951"];
3867 [label="FullWidth = this.Text.Length; 147952"];
3868 [label="FullWidth 147953"];
3869 [label="this.AdjustFlagsAndWidth(leading); 147954"];
3870 [label="return 'module'; 147955"];
3871 [label="FullWidth = this.Text.Length; 147956"];
3872 [label="FullWidth 147957"];
3873 [label="this.AdjustFlagsAndWidth(trailing); 147958"];
3874 [label="return 'module'; 147959"];
3875 [label="FullWidth = this.Text.Length; 147960"];
3876 [label="FullWidth 147961"];
3877 [label="this.AdjustFlagsAndWidth(trailing); 147962"];
3878 [label="return 'type'; 147963"];
3879 [label="FullWidth = this.Text.Length; 147964"];
3880 [label="FullWidth 147965"];
3881 [label="return 'type'; 147966"];
3882 [label="FullWidth = this.Text.Length; 147967"];
3883 [label="FullWidth 147968"];
3884 [label="this.AdjustFlagsAndWidth(leading); 147969"];
3885 [label="return 'type'; 147970"];
3886 [label="FullWidth = this.Text.Length; 147971"];
3887 [label="FullWidth 147972"];
3888 [label="this.AdjustFlagsAndWidth(trailing); 147973"];
3889 [label="return 'type'; 147974"];
3890 [label="FullWidth = this.Text.Length; 147975"];
3891 [label="FullWidth 147976"];
3892 [label="this.AdjustFlagsAndWidth(trailing); 147977"];
3893 [label="return 'field'; 147978"];
3894 [label="FullWidth = this.Text.Length; 147979"];
3895 [label="FullWidth 147980"];
3896 [label="return 'field'; 147981"];
3897 [label="FullWidth = this.Text.Length; 147982"];
3898 [label="FullWidth 147983"];
3899 [label="this.AdjustFlagsAndWidth(leading); 147984"];
3900 [label="return 'field'; 147985"];
3901 [label="FullWidth = this.Text.Length; 147986"];
3902 [label="FullWidth 147987"];
3903 [label="this.AdjustFlagsAndWidth(trailing); 147988"];
3904 [label="return 'field'; 147989"];
3905 [label="FullWidth = this.Text.Length; 147990"];
3906 [label="FullWidth 147991"];
3907 [label="this.AdjustFlagsAndWidth(trailing); 147992"];
3908 [label="return 'method'; 147993"];
3909 [label="FullWidth = this.Text.Length; 147994"];
3910 [label="FullWidth 147995"];
3911 [label="return 'method'; 147996"];
3912 [label="FullWidth = this.Text.Length; 147997"];
3913 [label="FullWidth 147998"];
3914 [label="this.AdjustFlagsAndWidth(leading); 147999"];
3915 [label="return 'method'; 148000"];
3916 [label="FullWidth = this.Text.Length; 148001"];
3917 [label="FullWidth 148002"];
3918 [label="this.AdjustFlagsAndWidth(trailing); 148003"];
3919 [label="return 'method'; 148004"];
3920 [label="FullWidth = this.Text.Length; 148005"];
3921 [label="FullWidth 148006"];
3922 [label="this.AdjustFlagsAndWidth(trailing); 148007"];
3923 [label="return 'param'; 148008"];
3924 [label="FullWidth = this.Text.Length; 148009"];
3925 [label="FullWidth 148010"];
3926 [label="return 'param'; 148011"];
3927 [label="FullWidth = this.Text.Length; 148012"];
3928 [label="FullWidth 148013"];
3929 [label="this.AdjustFlagsAndWidth(leading); 148014"];
3930 [label="return 'param'; 148015"];
3931 [label="FullWidth = this.Text.Length; 148016"];
3932 [label="FullWidth 148017"];
3933 [label="this.AdjustFlagsAndWidth(trailing); 148018"];
3934 [label="return 'param'; 148019"];
3935 [label="FullWidth = this.Text.Length; 148020"];
3936 [label="FullWidth 148021"];
3937 [label="this.AdjustFlagsAndWidth(trailing); 148022"];
3938 [label="return 'property'; 148023"];
3939 [label="FullWidth = this.Text.Length; 148024"];
3940 [label="FullWidth 148025"];
3941 [label="return 'property'; 148026"];
3942 [label="FullWidth = this.Text.Length; 148027"];
3943 [label="FullWidth 148028"];
3944 [label="this.AdjustFlagsAndWidth(leading); 148029"];
3945 [label="return 'property'; 148030"];
3946 [label="FullWidth = this.Text.Length; 148031"];
3947 [label="FullWidth 148032"];
3948 [label="this.AdjustFlagsAndWidth(trailing); 148033"];
3949 [label="return 'property'; 148034"];
3950 [label="FullWidth = this.Text.Length; 148035"];
3951 [label="FullWidth 148036"];
3952 [label="this.AdjustFlagsAndWidth(trailing); 148037"];
3953 [label="return 'typevar'; 148038"];
3954 [label="FullWidth = this.Text.Length; 148039"];
3955 [label="FullWidth 148040"];
3956 [label="return 'typevar'; 148041"];
3957 [label="FullWidth = this.Text.Length; 148042"];
3958 [label="FullWidth 148043"];
3959 [label="this.AdjustFlagsAndWidth(leading); 148044"];
3960 [label="return 'typevar'; 148045"];
3961 [label="FullWidth = this.Text.Length; 148046"];
3962 [label="FullWidth 148047"];
3963 [label="this.AdjustFlagsAndWidth(trailing); 148048"];
3964 [label="return 'typevar'; 148049"];
3965 [label="FullWidth = this.Text.Length; 148050"];
3966 [label="FullWidth 148051"];
3967 [label="this.AdjustFlagsAndWidth(trailing); 148052"];
3968 [label="return 'get'; 148053"];
3969 [label="FullWidth = this.Text.Length; 148054"];
3970 [label="FullWidth 148055"];
3971 [label="return 'get'; 148056"];
3972 [label="FullWidth = this.Text.Length; 148057"];
3973 [label="FullWidth 148058"];
3974 [label="this.AdjustFlagsAndWidth(leading); 148059"];
3975 [label="return 'get'; 148060"];
3976 [label="FullWidth = this.Text.Length; 148061"];
3977 [label="FullWidth 148062"];
3978 [label="this.AdjustFlagsAndWidth(trailing); 148063"];
3979 [label="return 'get'; 148064"];
3980 [label="FullWidth = this.Text.Length; 148065"];
3981 [label="FullWidth 148066"];
3982 [label="this.AdjustFlagsAndWidth(trailing); 148067"];
3983 [label="return 'set'; 148068"];
3984 [label="FullWidth = this.Text.Length; 148069"];
3985 [label="FullWidth 148070"];
3986 [label="return 'set'; 148071"];
3987 [label="FullWidth = this.Text.Length; 148072"];
3988 [label="FullWidth 148073"];
3989 [label="this.AdjustFlagsAndWidth(leading); 148074"];
3990 [label="return 'set'; 148075"];
3991 [label="FullWidth = this.Text.Length; 148076"];
3992 [label="FullWidth 148077"];
3993 [label="this.AdjustFlagsAndWidth(trailing); 148078"];
3994 [label="return 'set'; 148079"];
3995 [label="FullWidth = this.Text.Length; 148080"];
3996 [label="FullWidth 148081"];
3997 [label="this.AdjustFlagsAndWidth(trailing); 148082"];
3998 [label="return 'add'; 148083"];
3999 [label="FullWidth = this.Text.Length; 148084"];
4000 [label="FullWidth 148085"];
4001 [label="return 'add'; 148086"];
4002 [label="FullWidth = this.Text.Length; 148087"];
4003 [label="FullWidth 148088"];
4004 [label="this.AdjustFlagsAndWidth(leading); 148089"];
4005 [label="return 'add'; 148090"];
4006 [label="FullWidth = this.Text.Length; 148091"];
4007 [label="FullWidth 148092"];
4008 [label="this.AdjustFlagsAndWidth(trailing); 148093"];
4009 [label="return 'add'; 148094"];
4010 [label="FullWidth = this.Text.Length; 148095"];
4011 [label="FullWidth 148096"];
4012 [label="this.AdjustFlagsAndWidth(trailing); 148097"];
4013 [label="return 'remove'; 148098"];
4014 [label="FullWidth = this.Text.Length; 148099"];
4015 [label="FullWidth 148100"];
4016 [label="return 'remove'; 148101"];
4017 [label="FullWidth = this.Text.Length; 148102"];
4018 [label="FullWidth 148103"];
4019 [label="this.AdjustFlagsAndWidth(leading); 148104"];
4020 [label="return 'remove'; 148105"];
4021 [label="FullWidth = this.Text.Length; 148106"];
4022 [label="FullWidth 148107"];
4023 [label="this.AdjustFlagsAndWidth(trailing); 148108"];
4024 [label="return 'remove'; 148109"];
4025 [label="FullWidth = this.Text.Length; 148110"];
4026 [label="FullWidth 148111"];
4027 [label="this.AdjustFlagsAndWidth(trailing); 148112"];
4028 [label="return 'where'; 148113"];
4029 [label="FullWidth = this.Text.Length; 148114"];
4030 [label="FullWidth 148115"];
4031 [label="return 'where'; 148116"];
4032 [label="FullWidth = this.Text.Length; 148117"];
4033 [label="FullWidth 148118"];
4034 [label="this.AdjustFlagsAndWidth(leading); 148119"];
4035 [label="return 'where'; 148120"];
4036 [label="FullWidth = this.Text.Length; 148121"];
4037 [label="FullWidth 148122"];
4038 [label="this.AdjustFlagsAndWidth(trailing); 148123"];
4039 [label="return 'where'; 148124"];
4040 [label="FullWidth = this.Text.Length; 148125"];
4041 [label="FullWidth 148126"];
4042 [label="this.AdjustFlagsAndWidth(trailing); 148127"];
4043 [label="return 'from'; 148128"];
4044 [label="FullWidth = this.Text.Length; 148129"];
4045 [label="FullWidth 148130"];
4046 [label="return 'from'; 148131"];
4047 [label="FullWidth = this.Text.Length; 148132"];
4048 [label="FullWidth 148133"];
4049 [label="this.AdjustFlagsAndWidth(leading); 148134"];
4050 [label="return 'from'; 148135"];
4051 [label="FullWidth = this.Text.Length; 148136"];
4052 [label="FullWidth 148137"];
4053 [label="this.AdjustFlagsAndWidth(trailing); 148138"];
4054 [label="return 'from'; 148139"];
4055 [label="FullWidth = this.Text.Length; 148140"];
4056 [label="FullWidth 148141"];
4057 [label="this.AdjustFlagsAndWidth(trailing); 148142"];
4058 [label="return 'group'; 148143"];
4059 [label="FullWidth = this.Text.Length; 148144"];
4060 [label="FullWidth 148145"];
4061 [label="return 'group'; 148146"];
4062 [label="FullWidth = this.Text.Length; 148147"];
4063 [label="FullWidth 148148"];
4064 [label="this.AdjustFlagsAndWidth(leading); 148149"];
4065 [label="return 'group'; 148150"];
4066 [label="FullWidth = this.Text.Length; 148151"];
4067 [label="FullWidth 148152"];
4068 [label="this.AdjustFlagsAndWidth(trailing); 148153"];
4069 [label="return 'group'; 148154"];
4070 [label="FullWidth = this.Text.Length; 148155"];
4071 [label="FullWidth 148156"];
4072 [label="this.AdjustFlagsAndWidth(trailing); 148157"];
4073 [label="return 'join'; 148158"];
4074 [label="FullWidth = this.Text.Length; 148159"];
4075 [label="FullWidth 148160"];
4076 [label="return 'join'; 148161"];
4077 [label="FullWidth = this.Text.Length; 148162"];
4078 [label="FullWidth 148163"];
4079 [label="this.AdjustFlagsAndWidth(leading); 148164"];
4080 [label="return 'join'; 148165"];
4081 [label="FullWidth = this.Text.Length; 148166"];
4082 [label="FullWidth 148167"];
4083 [label="this.AdjustFlagsAndWidth(trailing); 148168"];
4084 [label="return 'join'; 148169"];
4085 [label="FullWidth = this.Text.Length; 148170"];
4086 [label="FullWidth 148171"];
4087 [label="this.AdjustFlagsAndWidth(trailing); 148172"];
4088 [label="return 'into'; 148173"];
4089 [label="FullWidth = this.Text.Length; 148174"];
4090 [label="FullWidth 148175"];
4091 [label="return 'into'; 148176"];
4092 [label="FullWidth = this.Text.Length; 148177"];
4093 [label="FullWidth 148178"];
4094 [label="this.AdjustFlagsAndWidth(leading); 148179"];
4095 [label="return 'into'; 148180"];
4096 [label="FullWidth = this.Text.Length; 148181"];
4097 [label="FullWidth 148182"];
4098 [label="this.AdjustFlagsAndWidth(trailing); 148183"];
4099 [label="return 'into'; 148184"];
4100 [label="FullWidth = this.Text.Length; 148185"];
4101 [label="FullWidth 148186"];
4102 [label="this.AdjustFlagsAndWidth(trailing); 148187"];
4103 [label="return 'let'; 148188"];
4104 [label="FullWidth = this.Text.Length; 148189"];
4105 [label="FullWidth 148190"];
4106 [label="return 'let'; 148191"];
4107 [label="FullWidth = this.Text.Length; 148192"];
4108 [label="FullWidth 148193"];
4109 [label="this.AdjustFlagsAndWidth(leading); 148194"];
4110 [label="return 'let'; 148195"];
4111 [label="FullWidth = this.Text.Length; 148196"];
4112 [label="FullWidth 148197"];
4113 [label="this.AdjustFlagsAndWidth(trailing); 148198"];
4114 [label="return 'let'; 148199"];
4115 [label="FullWidth = this.Text.Length; 148200"];
4116 [label="FullWidth 148201"];
4117 [label="this.AdjustFlagsAndWidth(trailing); 148202"];
4118 [label="return 'by'; 148203"];
4119 [label="FullWidth = this.Text.Length; 148204"];
4120 [label="FullWidth 148205"];
4121 [label="return 'by'; 148206"];
4122 [label="FullWidth = this.Text.Length; 148207"];
4123 [label="FullWidth 148208"];
4124 [label="this.AdjustFlagsAndWidth(leading); 148209"];
4125 [label="return 'by'; 148210"];
4126 [label="FullWidth = this.Text.Length; 148211"];
4127 [label="FullWidth 148212"];
4128 [label="this.AdjustFlagsAndWidth(trailing); 148213"];
4129 [label="return 'by'; 148214"];
4130 [label="FullWidth = this.Text.Length; 148215"];
4131 [label="FullWidth 148216"];
4132 [label="this.AdjustFlagsAndWidth(trailing); 148217"];
4133 [label="return 'select'; 148218"];
4134 [label="FullWidth = this.Text.Length; 148219"];
4135 [label="FullWidth 148220"];
4136 [label="return 'select'; 148221"];
4137 [label="FullWidth = this.Text.Length; 148222"];
4138 [label="FullWidth 148223"];
4139 [label="this.AdjustFlagsAndWidth(leading); 148224"];
4140 [label="return 'select'; 148225"];
4141 [label="FullWidth = this.Text.Length; 148226"];
4142 [label="FullWidth 148227"];
4143 [label="this.AdjustFlagsAndWidth(trailing); 148228"];
4144 [label="return 'select'; 148229"];
4145 [label="FullWidth = this.Text.Length; 148230"];
4146 [label="FullWidth 148231"];
4147 [label="this.AdjustFlagsAndWidth(trailing); 148232"];
4148 [label="return 'orderby'; 148233"];
4149 [label="FullWidth = this.Text.Length; 148234"];
4150 [label="FullWidth 148235"];
4151 [label="return 'orderby'; 148236"];
4152 [label="FullWidth = this.Text.Length; 148237"];
4153 [label="FullWidth 148238"];
4154 [label="this.AdjustFlagsAndWidth(leading); 148239"];
4155 [label="return 'orderby'; 148240"];
4156 [label="FullWidth = this.Text.Length; 148241"];
4157 [label="FullWidth 148242"];
4158 [label="this.AdjustFlagsAndWidth(trailing); 148243"];
4159 [label="return 'orderby'; 148244"];
4160 [label="FullWidth = this.Text.Length; 148245"];
4161 [label="FullWidth 148246"];
4162 [label="this.AdjustFlagsAndWidth(trailing); 148247"];
4163 [label="return 'on'; 148248"];
4164 [label="FullWidth = this.Text.Length; 148249"];
4165 [label="FullWidth 148250"];
4166 [label="return 'on'; 148251"];
4167 [label="FullWidth = this.Text.Length; 148252"];
4168 [label="FullWidth 148253"];
4169 [label="this.AdjustFlagsAndWidth(leading); 148254"];
4170 [label="return 'on'; 148255"];
4171 [label="FullWidth = this.Text.Length; 148256"];
4172 [label="FullWidth 148257"];
4173 [label="this.AdjustFlagsAndWidth(trailing); 148258"];
4174 [label="return 'on'; 148259"];
4175 [label="FullWidth = this.Text.Length; 148260"];
4176 [label="FullWidth 148261"];
4177 [label="this.AdjustFlagsAndWidth(trailing); 148262"];
4178 [label="return 'equals'; 148263"];
4179 [label="FullWidth = this.Text.Length; 148264"];
4180 [label="FullWidth 148265"];
4181 [label="return 'equals'; 148266"];
4182 [label="FullWidth = this.Text.Length; 148267"];
4183 [label="FullWidth 148268"];
4184 [label="this.AdjustFlagsAndWidth(leading); 148269"];
4185 [label="return 'equals'; 148270"];
4186 [label="FullWidth = this.Text.Length; 148271"];
4187 [label="FullWidth 148272"];
4188 [label="this.AdjustFlagsAndWidth(trailing); 148273"];
4189 [label="return 'equals'; 148274"];
4190 [label="FullWidth = this.Text.Length; 148275"];
4191 [label="FullWidth 148276"];
4192 [label="this.AdjustFlagsAndWidth(trailing); 148277"];
4193 [label="return 'ascending'; 148278"];
4194 [label="FullWidth = this.Text.Length; 148279"];
4195 [label="FullWidth 148280"];
4196 [label="return 'ascending'; 148281"];
4197 [label="FullWidth = this.Text.Length; 148282"];
4198 [label="FullWidth 148283"];
4199 [label="this.AdjustFlagsAndWidth(leading); 148284"];
4200 [label="return 'ascending'; 148285"];
4201 [label="FullWidth = this.Text.Length; 148286"];
4202 [label="FullWidth 148287"];
4203 [label="this.AdjustFlagsAndWidth(trailing); 148288"];
4204 [label="return 'ascending'; 148289"];
4205 [label="FullWidth = this.Text.Length; 148290"];
4206 [label="FullWidth 148291"];
4207 [label="this.AdjustFlagsAndWidth(trailing); 148292"];
4208 [label="return 'descending'; 148293"];
4209 [label="FullWidth = this.Text.Length; 148294"];
4210 [label="FullWidth 148295"];
4211 [label="return 'descending'; 148296"];
4212 [label="FullWidth = this.Text.Length; 148297"];
4213 [label="FullWidth 148298"];
4214 [label="this.AdjustFlagsAndWidth(leading); 148299"];
4215 [label="return 'descending'; 148300"];
4216 [label="FullWidth = this.Text.Length; 148301"];
4217 [label="FullWidth 148302"];
4218 [label="this.AdjustFlagsAndWidth(trailing); 148303"];
4219 [label="return 'descending'; 148304"];
4220 [label="FullWidth = this.Text.Length; 148305"];
4221 [label="FullWidth 148306"];
4222 [label="this.AdjustFlagsAndWidth(trailing); 148307"];
4223 [label="return 'nameof'; 148308"];
4224 [label="FullWidth = this.Text.Length; 148309"];
4225 [label="FullWidth 148310"];
4226 [label="return 'nameof'; 148311"];
4227 [label="FullWidth = this.Text.Length; 148312"];
4228 [label="FullWidth 148313"];
4229 [label="this.AdjustFlagsAndWidth(leading); 148314"];
4230 [label="return 'nameof'; 148315"];
4231 [label="FullWidth = this.Text.Length; 148316"];
4232 [label="FullWidth 148317"];
4233 [label="this.AdjustFlagsAndWidth(trailing); 148318"];
4234 [label="return 'nameof'; 148319"];
4235 [label="FullWidth = this.Text.Length; 148320"];
4236 [label="FullWidth 148321"];
4237 [label="this.AdjustFlagsAndWidth(trailing); 148322"];
4238 [label="return 'async'; 148323"];
4239 [label="FullWidth = this.Text.Length; 148324"];
4240 [label="FullWidth 148325"];
4241 [label="return 'async'; 148326"];
4242 [label="FullWidth = this.Text.Length; 148327"];
4243 [label="FullWidth 148328"];
4244 [label="this.AdjustFlagsAndWidth(leading); 148329"];
4245 [label="return 'async'; 148330"];
4246 [label="FullWidth = this.Text.Length; 148331"];
4247 [label="FullWidth 148332"];
4248 [label="this.AdjustFlagsAndWidth(trailing); 148333"];
4249 [label="return 'async'; 148334"];
4250 [label="FullWidth = this.Text.Length; 148335"];
4251 [label="FullWidth 148336"];
4252 [label="this.AdjustFlagsAndWidth(trailing); 148337"];
4253 [label="return 'await'; 148338"];
4254 [label="FullWidth = this.Text.Length; 148339"];
4255 [label="FullWidth 148340"];
4256 [label="return 'await'; 148341"];
4257 [label="FullWidth = this.Text.Length; 148342"];
4258 [label="FullWidth 148343"];
4259 [label="this.AdjustFlagsAndWidth(leading); 148344"];
4260 [label="return 'await'; 148345"];
4261 [label="FullWidth = this.Text.Length; 148346"];
4262 [label="FullWidth 148347"];
4263 [label="this.AdjustFlagsAndWidth(trailing); 148348"];
4264 [label="return 'await'; 148349"];
4265 [label="FullWidth = this.Text.Length; 148350"];
4266 [label="FullWidth 148351"];
4267 [label="this.AdjustFlagsAndWidth(trailing); 148352"];
4268 [label="return 'when'; 148353"];
4269 [label="FullWidth = this.Text.Length; 148354"];
4270 [label="FullWidth 148355"];
4271 [label="return 'when'; 148356"];
4272 [label="FullWidth = this.Text.Length; 148357"];
4273 [label="FullWidth 148358"];
4274 [label="this.AdjustFlagsAndWidth(leading); 148359"];
4275 [label="return 'when'; 148360"];
4276 [label="FullWidth = this.Text.Length; 148361"];
4277 [label="FullWidth 148362"];
4278 [label="this.AdjustFlagsAndWidth(trailing); 148363"];
4279 [label="return 'when'; 148364"];
4280 [label="FullWidth = this.Text.Length; 148365"];
4281 [label="FullWidth 148366"];
4282 [label="this.AdjustFlagsAndWidth(trailing); 148367"];
4283 [label="return 'or'; 148368"];
4284 [label="FullWidth = this.Text.Length; 148369"];
4285 [label="FullWidth 148370"];
4286 [label="return 'or'; 148371"];
4287 [label="FullWidth = this.Text.Length; 148372"];
4288 [label="FullWidth 148373"];
4289 [label="this.AdjustFlagsAndWidth(leading); 148374"];
4290 [label="return 'or'; 148375"];
4291 [label="FullWidth = this.Text.Length; 148376"];
4292 [label="FullWidth 148377"];
4293 [label="this.AdjustFlagsAndWidth(trailing); 148378"];
4294 [label="return 'or'; 148379"];
4295 [label="FullWidth = this.Text.Length; 148380"];
4296 [label="FullWidth 148381"];
4297 [label="this.AdjustFlagsAndWidth(trailing); 148382"];
4298 [label="return 'and'; 148383"];
4299 [label="FullWidth = this.Text.Length; 148384"];
4300 [label="FullWidth 148385"];
4301 [label="return 'and'; 148386"];
4302 [label="FullWidth = this.Text.Length; 148387"];
4303 [label="FullWidth 148388"];
4304 [label="this.AdjustFlagsAndWidth(leading); 148389"];
4305 [label="return 'and'; 148390"];
4306 [label="FullWidth = this.Text.Length; 148391"];
4307 [label="FullWidth 148392"];
4308 [label="this.AdjustFlagsAndWidth(trailing); 148393"];
4309 [label="return 'and'; 148394"];
4310 [label="FullWidth = this.Text.Length; 148395"];
4311 [label="FullWidth 148396"];
4312 [label="this.AdjustFlagsAndWidth(trailing); 148397"];
4313 [label="return 'not'; 148398"];
4314 [label="FullWidth = this.Text.Length; 148399"];
4315 [label="FullWidth 148400"];
4316 [label="return 'not'; 148401"];
4317 [label="FullWidth = this.Text.Length; 148402"];
4318 [label="FullWidth 148403"];
4319 [label="this.AdjustFlagsAndWidth(leading); 148404"];
4320 [label="return 'not'; 148405"];
4321 [label="FullWidth = this.Text.Length; 148406"];
4322 [label="FullWidth 148407"];
4323 [label="this.AdjustFlagsAndWidth(trailing); 148408"];
4324 [label="return 'not'; 148409"];
4325 [label="FullWidth = this.Text.Length; 148410"];
4326 [label="FullWidth 148411"];
4327 [label="this.AdjustFlagsAndWidth(trailing); 148412"];
4328 [label="return 'data'; 148413"];
4329 [label="FullWidth = this.Text.Length; 148414"];
4330 [label="FullWidth 148415"];
4331 [label="return 'data'; 148416"];
4332 [label="FullWidth = this.Text.Length; 148417"];
4333 [label="FullWidth 148418"];
4334 [label="this.AdjustFlagsAndWidth(leading); 148419"];
4335 [label="return 'data'; 148420"];
4336 [label="FullWidth = this.Text.Length; 148421"];
4337 [label="FullWidth 148422"];
4338 [label="this.AdjustFlagsAndWidth(trailing); 148423"];
4339 [label="return 'data'; 148424"];
4340 [label="FullWidth = this.Text.Length; 148425"];
4341 [label="FullWidth 148426"];
4342 [label="this.AdjustFlagsAndWidth(trailing); 148427"];
4343 [label="return 'with'; 148428"];
4344 [label="FullWidth = this.Text.Length; 148429"];
4345 [label="FullWidth 148430"];
4346 [label="return 'with'; 148431"];
4347 [label="FullWidth = this.Text.Length; 148432"];
4348 [label="FullWidth 148433"];
4349 [label="this.AdjustFlagsAndWidth(leading); 148434"];
4350 [label="return 'with'; 148435"];
4351 [label="FullWidth = this.Text.Length; 148436"];
4352 [label="FullWidth 148437"];
4353 [label="this.AdjustFlagsAndWidth(trailing); 148438"];
4354 [label="return 'with'; 148439"];
4355 [label="FullWidth = this.Text.Length; 148440"];
4356 [label="FullWidth 148441"];
4357 [label="this.AdjustFlagsAndWidth(trailing); 148442"];
4358 [label="return 'init'; 148443"];
4359 [label="FullWidth = this.Text.Length; 148444"];
4360 [label="FullWidth 148445"];
4361 [label="return 'init'; 148446"];
4362 [label="FullWidth = this.Text.Length; 148447"];
4363 [label="FullWidth 148448"];
4364 [label="this.AdjustFlagsAndWidth(leading); 148449"];
4365 [label="return 'init'; 148450"];
4366 [label="FullWidth = this.Text.Length; 148451"];
4367 [label="FullWidth 148452"];
4368 [label="this.AdjustFlagsAndWidth(trailing); 148453"];
4369 [label="return 'init'; 148454"];
4370 [label="FullWidth = this.Text.Length; 148455"];
4371 [label="FullWidth 148456"];
4372 [label="this.AdjustFlagsAndWidth(trailing); 148457"];
4373 [label="return 'record'; 148458"];
4374 [label="FullWidth = this.Text.Length; 148459"];
4375 [label="FullWidth 148460"];
4376 [label="return 'record'; 148461"];
4377 [label="FullWidth = this.Text.Length; 148462"];
4378 [label="FullWidth 148463"];
4379 [label="this.AdjustFlagsAndWidth(leading); 148464"];
4380 [label="return 'record'; 148465"];
4381 [label="FullWidth = this.Text.Length; 148466"];
4382 [label="FullWidth 148467"];
4383 [label="this.AdjustFlagsAndWidth(trailing); 148468"];
4384 [label="return 'record'; 148469"];
4385 [label="FullWidth = this.Text.Length; 148470"];
4386 [label="FullWidth 148471"];
4387 [label="this.AdjustFlagsAndWidth(trailing); 148472"];
4388 [label="return 'managed'; 148473"];
4389 [label="FullWidth = this.Text.Length; 148474"];
4390 [label="FullWidth 148475"];
4391 [label="return 'managed'; 148476"];
4392 [label="FullWidth = this.Text.Length; 148477"];
4393 [label="FullWidth 148478"];
4394 [label="this.AdjustFlagsAndWidth(leading); 148479"];
4395 [label="return 'managed'; 148480"];
4396 [label="FullWidth = this.Text.Length; 148481"];
4397 [label="FullWidth 148482"];
4398 [label="this.AdjustFlagsAndWidth(trailing); 148483"];
4399 [label="return 'managed'; 148484"];
4400 [label="FullWidth = this.Text.Length; 148485"];
4401 [label="FullWidth 148486"];
4402 [label="this.AdjustFlagsAndWidth(trailing); 148487"];
4403 [label="return 'unmanaged'; 148488"];
4404 [label="FullWidth = this.Text.Length; 148489"];
4405 [label="FullWidth 148490"];
4406 [label="return 'unmanaged'; 148491"];
4407 [label="FullWidth = this.Text.Length; 148492"];
4408 [label="FullWidth 148493"];
4409 [label="this.AdjustFlagsAndWidth(leading); 148494"];
4410 [label="return 'unmanaged'; 148495"];
4411 [label="FullWidth = this.Text.Length; 148496"];
4412 [label="FullWidth 148497"];
4413 [label="this.AdjustFlagsAndWidth(trailing); 148498"];
4414 [label="return 'unmanaged'; 148499"];
4415 [label="FullWidth = this.Text.Length; 148500"];
4416 [label="FullWidth 148501"];
4417 [label="this.AdjustFlagsAndWidth(trailing); 148502"];
4418 [label="return 'elif'; 148503"];
4419 [label="FullWidth = this.Text.Length; 148504"];
4420 [label="FullWidth 148505"];
4421 [label="return 'elif'; 148506"];
4422 [label="FullWidth = this.Text.Length; 148507"];
4423 [label="FullWidth 148508"];
4424 [label="this.AdjustFlagsAndWidth(leading); 148509"];
4425 [label="return 'elif'; 148510"];
4426 [label="FullWidth = this.Text.Length; 148511"];
4427 [label="FullWidth 148512"];
4428 [label="this.AdjustFlagsAndWidth(trailing); 148513"];
4429 [label="return 'elif'; 148514"];
4430 [label="FullWidth = this.Text.Length; 148515"];
4431 [label="FullWidth 148516"];
4432 [label="this.AdjustFlagsAndWidth(trailing); 148517"];
4433 [label="return 'endif'; 148518"];
4434 [label="FullWidth = this.Text.Length; 148519"];
4435 [label="FullWidth 148520"];
4436 [label="return 'endif'; 148521"];
4437 [label="FullWidth = this.Text.Length; 148522"];
4438 [label="FullWidth 148523"];
4439 [label="this.AdjustFlagsAndWidth(leading); 148524"];
4440 [label="return 'endif'; 148525"];
4441 [label="FullWidth = this.Text.Length; 148526"];
4442 [label="FullWidth 148527"];
4443 [label="this.AdjustFlagsAndWidth(trailing); 148528"];
4444 [label="return 'endif'; 148529"];
4445 [label="FullWidth = this.Text.Length; 148530"];
4446 [label="FullWidth 148531"];
4447 [label="this.AdjustFlagsAndWidth(trailing); 148532"];
4448 [label="return 'region'; 148533"];
4449 [label="FullWidth = this.Text.Length; 148534"];
4450 [label="FullWidth 148535"];
4451 [label="return 'region'; 148536"];
4452 [label="FullWidth = this.Text.Length; 148537"];
4453 [label="FullWidth 148538"];
4454 [label="this.AdjustFlagsAndWidth(leading); 148539"];
4455 [label="return 'region'; 148540"];
4456 [label="FullWidth = this.Text.Length; 148541"];
4457 [label="FullWidth 148542"];
4458 [label="this.AdjustFlagsAndWidth(trailing); 148543"];
4459 [label="return 'region'; 148544"];
4460 [label="FullWidth = this.Text.Length; 148545"];
4461 [label="FullWidth 148546"];
4462 [label="this.AdjustFlagsAndWidth(trailing); 148547"];
4463 [label="return 'endregion'; 148548"];
4464 [label="FullWidth = this.Text.Length; 148549"];
4465 [label="FullWidth 148550"];
4466 [label="return 'endregion'; 148551"];
4467 [label="FullWidth = this.Text.Length; 148552"];
4468 [label="FullWidth 148553"];
4469 [label="this.AdjustFlagsAndWidth(leading); 148554"];
4470 [label="return 'endregion'; 148555"];
4471 [label="FullWidth = this.Text.Length; 148556"];
4472 [label="FullWidth 148557"];
4473 [label="this.AdjustFlagsAndWidth(trailing); 148558"];
4474 [label="return 'endregion'; 148559"];
4475 [label="FullWidth = this.Text.Length; 148560"];
4476 [label="FullWidth 148561"];
4477 [label="this.AdjustFlagsAndWidth(trailing); 148562"];
4478 [label="return 'define'; 148563"];
4479 [label="FullWidth = this.Text.Length; 148564"];
4480 [label="FullWidth 148565"];
4481 [label="return 'define'; 148566"];
4482 [label="FullWidth = this.Text.Length; 148567"];
4483 [label="FullWidth 148568"];
4484 [label="this.AdjustFlagsAndWidth(leading); 148569"];
4485 [label="return 'define'; 148570"];
4486 [label="FullWidth = this.Text.Length; 148571"];
4487 [label="FullWidth 148572"];
4488 [label="this.AdjustFlagsAndWidth(trailing); 148573"];
4489 [label="return 'define'; 148574"];
4490 [label="FullWidth = this.Text.Length; 148575"];
4491 [label="FullWidth 148576"];
4492 [label="this.AdjustFlagsAndWidth(trailing); 148577"];
4493 [label="return 'undef'; 148578"];
4494 [label="FullWidth = this.Text.Length; 148579"];
4495 [label="FullWidth 148580"];
4496 [label="return 'undef'; 148581"];
4497 [label="FullWidth = this.Text.Length; 148582"];
4498 [label="FullWidth 148583"];
4499 [label="this.AdjustFlagsAndWidth(leading); 148584"];
4500 [label="return 'undef'; 148585"];
4501 [label="FullWidth = this.Text.Length; 148586"];
4502 [label="FullWidth 148587"];
4503 [label="this.AdjustFlagsAndWidth(trailing); 148588"];
4504 [label="return 'undef'; 148589"];
4505 [label="FullWidth = this.Text.Length; 148590"];
4506 [label="FullWidth 148591"];
4507 [label="this.AdjustFlagsAndWidth(trailing); 148592"];
4508 [label="return 'warning'; 148593"];
4509 [label="FullWidth = this.Text.Length; 148594"];
4510 [label="FullWidth 148595"];
4511 [label="return 'warning'; 148596"];
4512 [label="FullWidth = this.Text.Length; 148597"];
4513 [label="FullWidth 148598"];
4514 [label="this.AdjustFlagsAndWidth(leading); 148599"];
4515 [label="return 'warning'; 148600"];
4516 [label="FullWidth = this.Text.Length; 148601"];
4517 [label="FullWidth 148602"];
4518 [label="this.AdjustFlagsAndWidth(trailing); 148603"];
4519 [label="return 'warning'; 148604"];
4520 [label="FullWidth = this.Text.Length; 148605"];
4521 [label="FullWidth 148606"];
4522 [label="this.AdjustFlagsAndWidth(trailing); 148607"];
4523 [label="return 'error'; 148608"];
4524 [label="FullWidth = this.Text.Length; 148609"];
4525 [label="FullWidth 148610"];
4526 [label="return 'error'; 148611"];
4527 [label="FullWidth = this.Text.Length; 148612"];
4528 [label="FullWidth 148613"];
4529 [label="this.AdjustFlagsAndWidth(leading); 148614"];
4530 [label="return 'error'; 148615"];
4531 [label="FullWidth = this.Text.Length; 148616"];
4532 [label="FullWidth 148617"];
4533 [label="this.AdjustFlagsAndWidth(trailing); 148618"];
4534 [label="return 'error'; 148619"];
4535 [label="FullWidth = this.Text.Length; 148620"];
4536 [label="FullWidth 148621"];
4537 [label="this.AdjustFlagsAndWidth(trailing); 148622"];
4538 [label="return 'line'; 148623"];
4539 [label="FullWidth = this.Text.Length; 148624"];
4540 [label="FullWidth 148625"];
4541 [label="return 'line'; 148626"];
4542 [label="FullWidth = this.Text.Length; 148627"];
4543 [label="FullWidth 148628"];
4544 [label="this.AdjustFlagsAndWidth(leading); 148629"];
4545 [label="return 'line'; 148630"];
4546 [label="FullWidth = this.Text.Length; 148631"];
4547 [label="FullWidth 148632"];
4548 [label="this.AdjustFlagsAndWidth(trailing); 148633"];
4549 [label="return 'line'; 148634"];
4550 [label="FullWidth = this.Text.Length; 148635"];
4551 [label="FullWidth 148636"];
4552 [label="this.AdjustFlagsAndWidth(trailing); 148637"];
4553 [label="return 'pragma'; 148638"];
4554 [label="FullWidth = this.Text.Length; 148639"];
4555 [label="FullWidth 148640"];
4556 [label="return 'pragma'; 148641"];
4557 [label="FullWidth = this.Text.Length; 148642"];
4558 [label="FullWidth 148643"];
4559 [label="this.AdjustFlagsAndWidth(leading); 148644"];
4560 [label="return 'pragma'; 148645"];
4561 [label="FullWidth = this.Text.Length; 148646"];
4562 [label="FullWidth 148647"];
4563 [label="this.AdjustFlagsAndWidth(trailing); 148648"];
4564 [label="return 'pragma'; 148649"];
4565 [label="FullWidth = this.Text.Length; 148650"];
4566 [label="FullWidth 148651"];
4567 [label="this.AdjustFlagsAndWidth(trailing); 148652"];
4568 [label="return 'hidden'; 148653"];
4569 [label="FullWidth = this.Text.Length; 148654"];
4570 [label="FullWidth 148655"];
4571 [label="return 'hidden'; 148656"];
4572 [label="FullWidth = this.Text.Length; 148657"];
4573 [label="FullWidth 148658"];
4574 [label="this.AdjustFlagsAndWidth(leading); 148659"];
4575 [label="return 'hidden'; 148660"];
4576 [label="FullWidth = this.Text.Length; 148661"];
4577 [label="FullWidth 148662"];
4578 [label="this.AdjustFlagsAndWidth(trailing); 148663"];
4579 [label="return 'hidden'; 148664"];
4580 [label="FullWidth = this.Text.Length; 148665"];
4581 [label="FullWidth 148666"];
4582 [label="this.AdjustFlagsAndWidth(trailing); 148667"];
4583 [label="return 'checksum'; 148668"];
4584 [label="FullWidth = this.Text.Length; 148669"];
4585 [label="FullWidth 148670"];
4586 [label="return 'checksum'; 148671"];
4587 [label="FullWidth = this.Text.Length; 148672"];
4588 [label="FullWidth 148673"];
4589 [label="this.AdjustFlagsAndWidth(leading); 148674"];
4590 [label="return 'checksum'; 148675"];
4591 [label="FullWidth = this.Text.Length; 148676"];
4592 [label="FullWidth 148677"];
4593 [label="this.AdjustFlagsAndWidth(trailing); 148678"];
4594 [label="return 'checksum'; 148679"];
4595 [label="FullWidth = this.Text.Length; 148680"];
4596 [label="FullWidth 148681"];
4597 [label="this.AdjustFlagsAndWidth(trailing); 148682"];
4598 [label="return 'disable'; 148683"];
4599 [label="FullWidth = this.Text.Length; 148684"];
4600 [label="FullWidth 148685"];
4601 [label="return 'disable'; 148686"];
4602 [label="FullWidth = this.Text.Length; 148687"];
4603 [label="FullWidth 148688"];
4604 [label="this.AdjustFlagsAndWidth(leading); 148689"];
4605 [label="return 'disable'; 148690"];
4606 [label="FullWidth = this.Text.Length; 148691"];
4607 [label="FullWidth 148692"];
4608 [label="this.AdjustFlagsAndWidth(trailing); 148693"];
4609 [label="return 'disable'; 148694"];
4610 [label="FullWidth = this.Text.Length; 148695"];
4611 [label="FullWidth 148696"];
4612 [label="this.AdjustFlagsAndWidth(trailing); 148697"];
4613 [label="return 'restore'; 148698"];
4614 [label="FullWidth = this.Text.Length; 148699"];
4615 [label="FullWidth 148700"];
4616 [label="return 'restore'; 148701"];
4617 [label="FullWidth = this.Text.Length; 148702"];
4618 [label="FullWidth 148703"];
4619 [label="this.AdjustFlagsAndWidth(leading); 148704"];
4620 [label="return 'restore'; 148705"];
4621 [label="FullWidth = this.Text.Length; 148706"];
4622 [label="FullWidth 148707"];
4623 [label="this.AdjustFlagsAndWidth(trailing); 148708"];
4624 [label="return 'restore'; 148709"];
4625 [label="FullWidth = this.Text.Length; 148710"];
4626 [label="FullWidth 148711"];
4627 [label="this.AdjustFlagsAndWidth(trailing); 148712"];
4628 [label="return 'r'; 148713"];
4629 [label="FullWidth = this.Text.Length; 148714"];
4630 [label="FullWidth 148715"];
4631 [label="return 'r'; 148716"];
4632 [label="FullWidth = this.Text.Length; 148717"];
4633 [label="FullWidth 148718"];
4634 [label="this.AdjustFlagsAndWidth(leading); 148719"];
4635 [label="return 'r'; 148720"];
4636 [label="FullWidth = this.Text.Length; 148721"];
4637 [label="FullWidth 148722"];
4638 [label="this.AdjustFlagsAndWidth(trailing); 148723"];
4639 [label="return 'r'; 148724"];
4640 [label="FullWidth = this.Text.Length; 148725"];
4641 [label="FullWidth 148726"];
4642 [label="this.AdjustFlagsAndWidth(trailing); 148727"];
4643 [label="return '$\\''; 148728"];
4644 [label="FullWidth = this.Text.Length; 148729"];
4645 [label="FullWidth 148730"];
4646 [label="return '$\\''; 148731"];
4647 [label="FullWidth = this.Text.Length; 148732"];
4648 [label="FullWidth 148733"];
4649 [label="this.AdjustFlagsAndWidth(leading); 148734"];
4650 [label="return '$\\''; 148735"];
4651 [label="FullWidth = this.Text.Length; 148736"];
4652 [label="FullWidth 148737"];
4653 [label="this.AdjustFlagsAndWidth(trailing); 148738"];
4654 [label="return '$\\''; 148739"];
4655 [label="FullWidth = this.Text.Length; 148740"];
4656 [label="FullWidth 148741"];
4657 [label="this.AdjustFlagsAndWidth(trailing); 148742"];
4658 [label="return '\\''; 148743"];
4659 [label="FullWidth = this.Text.Length; 148744"];
4660 [label="FullWidth 148745"];
4661 [label="return '\\''; 148746"];
4662 [label="FullWidth = this.Text.Length; 148747"];
4663 [label="FullWidth 148748"];
4664 [label="this.AdjustFlagsAndWidth(leading); 148749"];
4665 [label="return '\\''; 148750"];
4666 [label="FullWidth = this.Text.Length; 148751"];
4667 [label="FullWidth 148752"];
4668 [label="this.AdjustFlagsAndWidth(trailing); 148753"];
4669 [label="return '\\''; 148754"];
4670 [label="FullWidth = this.Text.Length; 148755"];
4671 [label="FullWidth 148756"];
4672 [label="this.AdjustFlagsAndWidth(trailing); 148757"];
4673 [label="return '$@\\''; 148758"];
4674 [label="FullWidth = this.Text.Length; 148759"];
4675 [label="FullWidth 148760"];
4676 [label="return '$@\\''; 148761"];
4677 [label="FullWidth = this.Text.Length; 148762"];
4678 [label="FullWidth 148763"];
4679 [label="this.AdjustFlagsAndWidth(leading); 148764"];
4680 [label="return '$@\\''; 148765"];
4681 [label="FullWidth = this.Text.Length; 148766"];
4682 [label="FullWidth 148767"];
4683 [label="this.AdjustFlagsAndWidth(trailing); 148768"];
4684 [label="return '$@\\''; 148769"];
4685 [label="FullWidth = this.Text.Length; 148770"];
4686 [label="FullWidth 148771"];
4687 [label="this.AdjustFlagsAndWidth(trailing); 148772"];
4688 [label="return 'load'; 148773"];
4689 [label="FullWidth = this.Text.Length; 148774"];
4690 [label="FullWidth 148775"];
4691 [label="return 'load'; 148776"];
4692 [label="FullWidth = this.Text.Length; 148777"];
4693 [label="FullWidth 148778"];
4694 [label="this.AdjustFlagsAndWidth(leading); 148779"];
4695 [label="return 'load'; 148780"];
4696 [label="FullWidth = this.Text.Length; 148781"];
4697 [label="FullWidth 148782"];
4698 [label="this.AdjustFlagsAndWidth(trailing); 148783"];
4699 [label="return 'load'; 148784"];
4700 [label="FullWidth = this.Text.Length; 148785"];
4701 [label="FullWidth 148786"];
4702 [label="this.AdjustFlagsAndWidth(trailing); 148787"];
4703 [label="return 'nullable'; 148788"];
4704 [label="FullWidth = this.Text.Length; 148789"];
4705 [label="FullWidth 148790"];
4706 [label="return 'nullable'; 148791"];
4707 [label="FullWidth = this.Text.Length; 148792"];
4708 [label="FullWidth 148793"];
4709 [label="this.AdjustFlagsAndWidth(leading); 148794"];
4710 [label="return 'nullable'; 148795"];
4711 [label="FullWidth = this.Text.Length; 148796"];
4712 [label="FullWidth 148797"];
4713 [label="this.AdjustFlagsAndWidth(trailing); 148798"];
4714 [label="return 'nullable'; 148799"];
4715 [label="FullWidth = this.Text.Length; 148800"];
4716 [label="FullWidth 148801"];
4717 [label="this.AdjustFlagsAndWidth(trailing); 148802"];
4718 [label="return 'enable'; 148803"];
4719 [label="FullWidth = this.Text.Length; 148804"];
4720 [label="FullWidth 148805"];
4721 [label="return 'enable'; 148806"];
4722 [label="FullWidth = this.Text.Length; 148807"];
4723 [label="FullWidth 148808"];
4724 [label="this.AdjustFlagsAndWidth(leading); 148809"];
4725 [label="return 'enable'; 148810"];
4726 [label="FullWidth = this.Text.Length; 148811"];
4727 [label="FullWidth 148812"];
4728 [label="this.AdjustFlagsAndWidth(trailing); 148813"];
4729 [label="return 'enable'; 148814"];
4730 [label="FullWidth = this.Text.Length; 148815"];
4731 [label="FullWidth 148816"];
4732 [label="this.AdjustFlagsAndWidth(trailing); 148817"];
4733 [label="return 'warnings'; 148818"];
4734 [label="FullWidth = this.Text.Length; 148819"];
4735 [label="FullWidth 148820"];
4736 [label="return 'warnings'; 148821"];
4737 [label="FullWidth = this.Text.Length; 148822"];
4738 [label="FullWidth 148823"];
4739 [label="this.AdjustFlagsAndWidth(leading); 148824"];
4740 [label="return 'warnings'; 148825"];
4741 [label="FullWidth = this.Text.Length; 148826"];
4742 [label="FullWidth 148827"];
4743 [label="this.AdjustFlagsAndWidth(trailing); 148828"];
4744 [label="return 'warnings'; 148829"];
4745 [label="FullWidth = this.Text.Length; 148830"];
4746 [label="FullWidth 148831"];
4747 [label="this.AdjustFlagsAndWidth(trailing); 148832"];
4748 [label="return 'annotations'; 148833"];
4749 [label="FullWidth = this.Text.Length; 148834"];
4750 [label="FullWidth 148835"];
4751 [label="return 'annotations'; 148836"];
4752 [label="FullWidth = this.Text.Length; 148837"];
4753 [label="FullWidth 148838"];
4754 [label="this.AdjustFlagsAndWidth(leading); 148839"];
4755 [label="return 'annotations'; 148840"];
4756 [label="FullWidth = this.Text.Length; 148841"];
4757 [label="FullWidth 148842"];
4758 [label="this.AdjustFlagsAndWidth(trailing); 148843"];
4759 [label="return 'annotations'; 148844"];
4760 [label="FullWidth = this.Text.Length; 148845"];
4761 [label="FullWidth 148846"];
4762 [label="this.AdjustFlagsAndWidth(trailing); 148847"];
4763 [label="return 'var'; 148848"];
4764 [label="FullWidth = this.Text.Length; 148849"];
4765 [label="FullWidth 148850"];
4766 [label="return 'var'; 148851"];
4767 [label="FullWidth = this.Text.Length; 148852"];
4768 [label="FullWidth 148853"];
4769 [label="this.AdjustFlagsAndWidth(leading); 148854"];
4770 [label="return 'var'; 148855"];
4771 [label="FullWidth = this.Text.Length; 148856"];
4772 [label="FullWidth 148857"];
4773 [label="this.AdjustFlagsAndWidth(trailing); 148858"];
4774 [label="return 'var'; 148859"];
4775 [label="FullWidth = this.Text.Length; 148860"];
4776 [label="FullWidth 148861"];
4777 [label="this.AdjustFlagsAndWidth(trailing); 148862"];
4778 [label="return '_'; 148863"];
4779 [label="FullWidth = this.Text.Length; 148864"];
4780 [label="FullWidth 148865"];
4781 [label="return '_'; 148866"];
4782 [label="FullWidth = this.Text.Length; 148867"];
4783 [label="FullWidth 148868"];
4784 [label="this.AdjustFlagsAndWidth(leading); 148869"];
4785 [label="return '_'; 148870"];
4786 [label="FullWidth = this.Text.Length; 148871"];
4787 [label="FullWidth 148872"];
4788 [label="this.AdjustFlagsAndWidth(trailing); 148873"];
4789 [label="return '_'; 148874"];
4790 [label="FullWidth = this.Text.Length; 148875"];
4791 [label="FullWidth 148876"];
4792 [label="this.AdjustFlagsAndWidth(trailing); 148877"];
4793 [label="return SyntaxToken.Create(kind, leading, trailing); 148878"];
4794 [label="return SyntaxToken.Create(kind, leading, trailing); 148879"];
4795 [label="return SyntaxToken.Create(kind, leading, trailing); 148880"];
4796 [label="SyntaxToken.Create(kind, leading, trailing) 148881"];
4797 [label="param Create(SyntaxKind kind) 148882"];
4798 [label="param Create(GreenNode leading) 148883"];
4799 [label="param Create(GreenNode trailing) 148884"];
4800 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 148885"];
4801 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 148886"];
4802 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 148887"];
4803 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 148888"];
4804 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 148889"];
4805 [label="if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 148890"];
4806 [label="return s_tokensWithSingleTrailingSpace[(int)kind].Value; 148891"];
4807 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 148892"];
4808 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 148893"];
4809 [label="return token; 148894"];
4810 [label="this.AddLexedToken(token); 148895"];
4811 [label="this.AddLexedToken(token) 148896"];
4812 [label="param AddLexedToken(SyntaxToken token) 148897"];
4813 [label="param AddLexedToken(this) 148898"];
4814 [label="Debug.Assert(token != null); 148899"];
4815 [label="Debug.Assert(token != null); 148900"];
4816 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 148901"];
4817 [label="_lexedTokens[_tokenCount].Value = token; 148902"];
4818 [label="_lexedTokens[_tokenCount].Value 148903"];
4819 [label="_tokenCount 148904"];
4820 [label="this.AddLexedToken(token); 148905"];
4821 [label="token.Kind 148906"];
4822 [label="get { return (SyntaxKind)this.RawKind; } 148907"];
4823 [label="return (SyntaxKind)this.RawKind; 148908"];
4824 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 148909"];
4825 [label="TextWindow.Start(); 148910"];
4826 [label="get\n            {\n                return _lexemeStart;\n            } 148911"];
4827 [label="return _lexemeStart; 148912"];
4828 [label="param LookupToken(char[] textBuffer) 148913"];
4829 [label="param LookupToken(int keyStart) 148914"];
4830 [label="param LookupToken(int keyLength) 148915"];
4831 [label="param LookupToken(int hashCode) 148916"];
4832 [label="param LookupToken(Func<SyntaxToken> createTokenFunction) 148917"];
4833 [label="param LookupToken(this) 148918"];
4834 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 148919"];
4835 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 148920"];
4836 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 148921"];
4837 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 148922"];
4838 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 148923"];
4839 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 148924"];
4840 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 148925"];
4841 [label="value = createTokenFunction(); 148926"];
4842 [label="value = createTokenFunction(); 148927"];
4843 [label="param CreateQuickToken(this) 148928"];
4844 [label="TextWindow.Width 148929"];
4845 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 148930"];
4846 [label="var quickWidth = TextWindow.Width; 148931"];
4847 [label="TextWindow.LexemeStartPosition 148932"];
4848 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 148933"];
4849 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 148934"];
4850 [label="TextWindow.Reset(TextWindow.LexemeStartPosition) 148935"];
4851 [label="param Reset(int position) 148936"];
4852 [label="param Reset(this) 148937"];
4853 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 148938"];
4854 [label="this.LexSyntaxToken() 148939"];
4855 [label="param LexSyntaxToken(this) 148940"];
4856 [label="_leadingTriviaCache.Clear(); 148941"];
4857 [label="TextWindow.Position 148942"];
4858 [label="get\n            {\n                return _basis + _offset;\n            } 148943"];
4859 [label="param LexSyntaxTrivia(bool afterFirstToken) 148944"];
4860 [label="param LexSyntaxTrivia(bool isTrailing) 148945"];
4861 [label="bool onlyWhitespaceOnLine = !isTrailing; 148946"];
4862 [label="TextWindow.Start(); 148947"];
4863 [label="this.Start(); 148948"];
4864 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 148949"];
4865 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 148950"];
4866 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 148951"];
4867 [label="return; 148952"];
4868 [label="this.Start(); 148953"];
4869 [label="var errors = this.GetErrors(GetFullWidth(leading)); 148954"];
4870 [label="GetFullWidth(leading) 148955"];
4871 [label="param GetFullWidth(SyntaxListBuilder builder) 148956"];
4872 [label="int width = 0; 148957"];
4873 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 148958"];
4874 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 148959"];
4875 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 148960"];
4876 [label="return width; 148961"];
4877 [label="var errors = this.GetErrors(GetFullWidth(leading)); 148962"];
4878 [label="this.GetErrors(GetFullWidth(leading)) 148963"];
4879 [label="param GetErrors(int leadingTriviaWidth) 148964"];
4880 [label="param GetErrors(this) 148965"];
4881 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 148966"];
4882 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 148967"];
4883 [label="return null; 148968"];
4884 [label="var errors = this.GetErrors(GetFullWidth(leading)); 148969"];
4885 [label="param LexSyntaxTrivia(bool afterFirstToken) 148970"];
4886 [label="param Create(ref TokenInfo info) 148971"];
4887 [label="param Create(SyntaxDiagnosticInfo[] errors) 148972"];
4888 [label="param Create(this) 148973"];
4889 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 148974"];
4890 [label="SyntaxToken token; 148975"];
4891 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 148976"];
4892 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 148977"];
4893 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 148978"];
4894 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 148979"];
4895 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 148980"];
4896 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 148981"];
4897 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 148982"];
4898 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 148983"];
4899 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 148984"];
4900 [label="param Token(GreenNode leading) 148985"];
4901 [label="param Token(SyntaxKind kind) 148986"];
4902 [label="param Token(GreenNode trailing) 148987"];
4903 [label="return SyntaxToken.Create(kind, leading, trailing); 148988"];
4904 [label="return SyntaxToken.Create(kind, leading, trailing); 148989"];
4905 [label="return SyntaxToken.Create(kind, leading, trailing); 148990"];
4906 [label="SyntaxToken.Create(kind, leading, trailing) 148991"];
4907 [label="param Create(SyntaxKind kind) 148992"];
4908 [label="param Create(GreenNode leading) 148993"];
4909 [label="param Create(GreenNode trailing) 148994"];
4910 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 148995"];
4911 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 148996"];
4912 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 148997"];
4913 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 148998"];
4914 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 148999"];
4915 [label="return s_tokensWithNoTrivia[(int)kind].Value; 149000"];
4916 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 149001"];
4917 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 149002"];
4918 [label="return token; 149003"];
4919 [label="var token = this.LexSyntaxToken(); 149004"];
4920 [label="Debug.Assert(quickWidth == token.FullWidth); 149005"];
4921 [label="return token; 149006"];
4922 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 149007"];
4923 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 149008"];
4924 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 149009"];
4925 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 149010"];
4926 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 149011"];
4927 [label="return value; 149012"];
4928 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 149013"];
4929 [label="this.AddLexedToken(token); 149014"];
4930 [label="param AddLexedToken(SyntaxToken token) 149015"];
4931 [label="Debug.Assert(token != null); 149016"];
4932 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 149017"];
4933 [label="_lexedTokens[_tokenCount].Value = token; 149018"];
4934 [label="_lexedTokens[_tokenCount].Value 149019"];
4935 [label="get { return (SyntaxKind)this.RawKind; } 149020"];
4936 [label="return (SyntaxKind)this.RawKind; 149021"];
4937 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 149022"];
4938 [label="TextWindow.Start(); 149023"];
4939 [label="TextWindow.Width 149024"];
4940 [label="var quickWidth = TextWindow.Width; 149025"];
4941 [label="TextWindow.Position 149026"];
4942 [label="param LexSyntaxTrivia(bool afterFirstToken) 149027"];
4943 [label="param LexSyntaxTrivia(bool isTrailing) 149028"];
4944 [label="bool onlyWhitespaceOnLine = !isTrailing; 149029"];
4945 [label="this.Start(); 149030"];
4946 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 149031"];
4947 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 149032"];
4948 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 149033"];
4949 [label="return; 149034"];
4950 [label="this.Start(); 149035"];
4951 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 149036"];
4952 [label="param TryGetKeywordKind(out SyntaxKind kind) 149037"];
4953 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 149038"];
4954 [label="return SyntaxKind.None; 149039"];
4955 [label="param GetContextualKeywordKind(string text) 149040"];
4956 [label="switch (text)\n            {\n                case 'yield':\n                    return SyntaxKind.YieldKeyword;\n                case 'partial':\n                    return SyntaxKind.PartialKeyword;\n                case 'from':\n                    return SyntaxKind.FromKeyword;\n                case 'group':\n                    return SyntaxKind.GroupKeyword;\n                case 'join':\n                    return SyntaxKind.JoinKeyword;\n                case 'into':\n                    return SyntaxKind.IntoKeyword;\n                case 'let':\n                    return SyntaxKind.LetKeyword;\n                case 'by':\n                    return SyntaxKind.ByKeyword;\n                case 'where':\n                    return SyntaxKind.WhereKeyword;\n                case 'select':\n                    return SyntaxKind.SelectKeyword;\n                case 'get':\n                    return SyntaxKind.GetKeyword;\n                case 'set':\n                    return SyntaxKind.SetKeyword;\n                case 'add':\n                    return SyntaxKind.AddKeyword;\n                case 'remove':\n                    return SyntaxKind.RemoveKeyword;\n                case 'orderby':\n                    return SyntaxKind.OrderByKeyword;\n                case 'alias':\n                    return SyntaxKind.AliasKeyword;\n                case 'on':\n                    return SyntaxKind.OnKeyword;\n                case 'equals':\n                    return SyntaxKind.EqualsKeyword;\n                case 'ascending':\n                    return SyntaxKind.AscendingKeyword;\n                case 'descending':\n                    return SyntaxKind.DescendingKeyword;\n                case 'assembly':\n                    return SyntaxKind.AssemblyKeyword;\n                case 'module':\n                    return SyntaxKind.ModuleKeyword;\n                case 'type':\n                    return SyntaxKind.TypeKeyword;\n                case 'field':\n                    return SyntaxKind.FieldKeyword;\n                case 'method':\n                    return SyntaxKind.MethodKeyword;\n                case 'param':\n                    return SyntaxKind.ParamKeyword;\n                case 'property':\n                    return SyntaxKind.PropertyKeyword;\n                case 'typevar':\n                    return SyntaxKind.TypeVarKeyword;\n                case 'global':\n                    return SyntaxKind.GlobalKeyword;\n                case 'async':\n                    return SyntaxKind.AsyncKeyword;\n                case 'await':\n                    return SyntaxKind.AwaitKeyword;\n                case 'when':\n                    return SyntaxKind.WhenKeyword;\n                case 'nameof':\n                    return SyntaxKind.NameOfKeyword;\n                case '_':\n                    return SyntaxKind.UnderscoreToken;\n                case 'var':\n                    return SyntaxKind.VarKeyword;\n                case 'and':\n                    return SyntaxKind.AndKeyword;\n                case 'or':\n                    return SyntaxKind.OrKeyword;\n                case 'not':\n                    return SyntaxKind.NotKeyword;\n                case 'data':\n                    return SyntaxKind.DataKeyword;\n                case 'with':\n                    return SyntaxKind.WithKeyword;\n                case 'init':\n                    return SyntaxKind.InitKeyword;\n                case 'record':\n                    return SyntaxKind.RecordKeyword;\n                case 'managed':\n                    return SyntaxKind.ManagedKeyword;\n                case 'unmanaged':\n                    return SyntaxKind.UnmanagedKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 149041"];
4957 [label="return SyntaxKind.None; 149042"];
4958 [label="kind = _keywordKindMap.GetOrMakeValue(key); 149043"];
4959 [label="return kind != SyntaxKind.None; 149044"];
4960 [label="info.Kind 149045"];
4961 [label="info.ContextualKind 149046"];
4962 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 149047"];
4963 [label="this.ScanSyntaxToken(ref tokenInfo); 149048"];
4964 [label="var errors = this.GetErrors(GetFullWidth(leading)); 149049"];
4965 [label="GetFullWidth(leading) 149050"];
4966 [label="param GetFullWidth(SyntaxListBuilder builder) 149051"];
4967 [label="int width = 0; 149052"];
4968 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 149053"];
4969 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 149054"];
4970 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 149055"];
4971 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 149056"];
4972 [label="return width; 149057"];
4973 [label="var errors = this.GetErrors(GetFullWidth(leading)); 149058"];
4974 [label="this.GetErrors(GetFullWidth(leading)) 149059"];
4975 [label="param GetErrors(int leadingTriviaWidth) 149060"];
4976 [label="param GetErrors(this) 149061"];
4977 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 149062"];
4978 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 149063"];
4979 [label="return null; 149064"];
4980 [label="var errors = this.GetErrors(GetFullWidth(leading)); 149065"];
4981 [label="param LexSyntaxTrivia(bool afterFirstToken) 149066"];
4982 [label="param LexSyntaxTrivia(bool isTrailing) 149067"];
4983 [label="bool onlyWhitespaceOnLine = !isTrailing; 149068"];
4984 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 149069"];
4985 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 149070"];
4986 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 149071"];
4987 [label="return; 149072"];
4988 [label="param Create(SyntaxDiagnosticInfo[] errors) 149073"];
4989 [label="param Create(this) 149074"];
4990 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 149075"];
4991 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 149076"];
4992 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 149077"];
4993 [label="SyntaxToken token; 149078"];
4994 [label="token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode); 149079"];
4995 [label="SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode) 149080"];
4996 [label="param Identifier(SyntaxKind contextualKind) 149081"];
4997 [label="param Identifier(GreenNode leading) 149082"];
4998 [label="param Identifier(string text) 149083"];
4999 [label="param Identifier(string valueText) 149084"];
5000 [label="param Identifier(GreenNode trailing) 149085"];
5001 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 149086"];
5002 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 149087"];
5003 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 149088"];
5004 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 149089"];
5005 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 149090"];
5006 [label="SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing) 149091"];
5007 [label="param Identifier(SyntaxKind contextualKind) 149092"];
5008 [label="param Identifier(GreenNode leading) 149093"];
5009 [label="param Identifier(string text) 149094"];
5010 [label="param Identifier(string valueText) 149095"];
5011 [label="param Identifier(GreenNode trailing) 149096"];
5012 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 149097"];
5013 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 149098"];
5014 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 149099"];
5015 [label="return Identifier(leading, text, trailing); 149100"];
5016 [label="return Identifier(leading, text, trailing); 149101"];
5017 [label="return Identifier(leading, text, trailing); 149102"];
5018 [label="Identifier(leading, text, trailing) 149103"];
5019 [label="param Identifier(GreenNode leading) 149104"];
5020 [label="param Identifier(string text) 149105"];
5021 [label="param Identifier(GreenNode trailing) 149106"];
5022 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 149107"];
5023 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 149108"];
5024 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 149109"];
5025 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 149110"];
5026 [label="return Identifier(text); 149111"];
5027 [label="Identifier(text) 149112"];
5028 [label="param Identifier(string text) 149113"];
5029 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifier), r => new SyntaxIdentifier(r)); 149114"];
5030 [label="return new SyntaxIdentifier(text); 149115"];
5031 [label="return new SyntaxIdentifier(text); 149116"];
5032 [label="new SyntaxIdentifier(text) 149117"];
5033 [label="param SyntaxIdentifier(string text) 149118"];
5034 [label="param SyntaxIdentifier(this) 149119"];
5035 [label="SyntaxKind.IdentifierToken 149120"];
5036 [label="text 149121"];
5037 [label="param SyntaxIdentifier(this) 149122"];
5038 [label="param SyntaxToken(SyntaxKind kind) 149123"];
5039 [label="param SyntaxToken(int fullWidth) 149124"];
5040 [label="param SyntaxToken(this) 149125"];
5041 [label="kind 149126"];
5042 [label="fullWidth 149127"];
5043 [label="param SyntaxToken(this) 149128"];
5044 [label="param CSharpSyntaxNode(SyntaxKind kind) 149129"];
5045 [label="param CSharpSyntaxNode(int fullWidth) 149130"];
5046 [label="param CSharpSyntaxNode(this) 149131"];
5047 [label="kind 149132"];
5048 [label="fullWidth 149133"];
5049 [label="param CSharpSyntaxNode(this) 149134"];
5050 [label="param CSharpSyntaxNode(this) 149135"];
5051 [label="GreenStats.NoteGreen(this); 149136"];
5052 [label="GreenStats.NoteGreen(this); 149137"];
5053 [label="this.flags |= NodeFlags.IsNotMissing; 149138"];
5054 [label="this.flags 149139"];
5055 [label="TextField 149140"];
5056 [label="this.TextField 149141"];
5057 [label="return Identifier(text); 149142"];
5058 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 149143"];
5059 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 149144"];
5060 [label="Debug.Assert(quickWidth == token.FullWidth); 149145"];
5061 [label="value = createTokenFunction(); 149146"];
5062 [label="this.AddLexedToken(token); 149147"];
5063 [label="param AddLexedToken(SyntaxToken token) 149148"];
5064 [label="Debug.Assert(token != null); 149149"];
5065 [label="_lexedTokens[_tokenCount].Value 149150"];
5066 [label="get { return (SyntaxKind)this.RawKind; } 149151"];
5067 [label="return (SyntaxKind)this.RawKind; 149152"];
5068 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 149153"];
5069 [label="TextWindow.Start(); 149154"];
5070 [label="TextWindow.Width 149155"];
5071 [label="var quickWidth = TextWindow.Width; 149156"];
5072 [label="param LexSyntaxTrivia(bool afterFirstToken) 149157"];
5073 [label="param LexSyntaxTrivia(bool isTrailing) 149158"];
5074 [label="bool onlyWhitespaceOnLine = !isTrailing; 149159"];
5075 [label="this.Start(); 149160"];
5076 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 149161"];
5077 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 149162"];
5078 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 149163"];
5079 [label="return; 149164"];
5080 [label="this.Start(); 149165"];
5081 [label="var errors = this.GetErrors(GetFullWidth(leading)); 149166"];
5082 [label="GetFullWidth(leading) 149167"];
5083 [label="param GetFullWidth(SyntaxListBuilder builder) 149168"];
5084 [label="int width = 0; 149169"];
5085 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 149170"];
5086 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 149171"];
5087 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 149172"];
5088 [label="return width; 149173"];
5089 [label="var errors = this.GetErrors(GetFullWidth(leading)); 149174"];
5090 [label="this.GetErrors(GetFullWidth(leading)) 149175"];
5091 [label="param GetErrors(int leadingTriviaWidth) 149176"];
5092 [label="param GetErrors(this) 149177"];
5093 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 149178"];
5094 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 149179"];
5095 [label="return null; 149180"];
5096 [label="var errors = this.GetErrors(GetFullWidth(leading)); 149181"];
5097 [label="param AddTrivia(this) 149182"];
5098 [label="this.HasErrors 149183"];
5099 [label="get { return _errors != null; } 149184"];
5100 [label="return _errors != null; 149185"];
5101 [label="return _errors != null; 149186"];
5102 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 149187"];
5103 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 149188"];
5104 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 149189"];
5105 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 149190"];
5106 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 149191"];
5107 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 149192"];
5108 [label="return; 149193"];
5109 [label="param Create(SyntaxDiagnosticInfo[] errors) 149194"];
5110 [label="param Create(this) 149195"];
5111 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 149196"];
5112 [label="SyntaxToken token; 149197"];
5113 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 149198"];
5114 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 149199"];
5115 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 149200"];
5116 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 149201"];
5117 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 149202"];
5118 [label="if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 149203"];
5119 [label="return s_tokensWithSingleTrailingSpace[(int)kind].Value; 149204"];
5120 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 149205"];
5121 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 149206"];
5122 [label="Debug.Assert(quickWidth == token.FullWidth); 149207"];
5123 [label="this.AddLexedToken(token); 149208"];
5124 [label="param AddLexedToken(SyntaxToken token) 149209"];
5125 [label="Debug.Assert(token != null); 149210"];
5126 [label="_lexedTokens[_tokenCount].Value 149211"];
5127 [label="get { return (SyntaxKind)this.RawKind; } 149212"];
5128 [label="return (SyntaxKind)this.RawKind; 149213"];
5129 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 149214"];
5130 [label="TextWindow.Start(); 149215"];
5131 [label="var quickWidth = TextWindow.Width; 149216"];
5132 [label="param LexSyntaxTrivia(bool afterFirstToken) 149217"];
5133 [label="param LexSyntaxTrivia(bool isTrailing) 149218"];
5134 [label="bool onlyWhitespaceOnLine = !isTrailing; 149219"];
5135 [label="this.Start(); 149220"];
5136 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 149221"];
5137 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 149222"];
5138 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 149223"];
5139 [label="return; 149224"];
5140 [label="this.Start(); 149225"];
5141 [label="var errors = this.GetErrors(GetFullWidth(leading)); 149226"];
5142 [label="GetFullWidth(leading) 149227"];
5143 [label="param GetFullWidth(SyntaxListBuilder builder) 149228"];
5144 [label="int width = 0; 149229"];
5145 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 149230"];
5146 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 149231"];
5147 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 149232"];
5148 [label="return width; 149233"];
5149 [label="var errors = this.GetErrors(GetFullWidth(leading)); 149234"];
5150 [label="this.GetErrors(GetFullWidth(leading)) 149235"];
5151 [label="param GetErrors(int leadingTriviaWidth) 149236"];
5152 [label="param GetErrors(this) 149237"];
5153 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 149238"];
5154 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 149239"];
5155 [label="return null; 149240"];
5156 [label="var errors = this.GetErrors(GetFullWidth(leading)); 149241"];
5157 [label="param AddTrivia(this) 149242"];
5158 [label="this.HasErrors 149243"];
5159 [label="get { return _errors != null; } 149244"];
5160 [label="return _errors != null; 149245"];
5161 [label="return _errors != null; 149246"];
5162 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 149247"];
5163 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 149248"];
5164 [label="param Create(SyntaxDiagnosticInfo[] errors) 149249"];
5165 [label="param Create(this) 149250"];
5166 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 149251"];
5167 [label="SyntaxToken token; 149252"];
5168 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 149253"];
5169 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 149254"];
5170 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 149255"];
5171 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 149256"];
5172 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 149257"];
5173 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 149258"];
5174 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 149259"];
5175 [label="Debug.Assert(quickWidth == token.FullWidth); 149260"];
5176 [label="param TryGetKeywordKind(out SyntaxKind kind) 149261"];
5177 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 149262"];
5178 [label="return SyntaxKind.CaseKeyword; 149263"];
5179 [label="if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 149264"];
5180 [label="SyntaxFacts.IsContextualKeyword(info.Kind) 149265"];
5181 [label="param IsContextualKeyword(SyntaxKind kind) 149266"];
5182 [label="switch (kind)\n            {\n                case SyntaxKind.YieldKeyword:\n                case SyntaxKind.PartialKeyword:\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.LetKeyword:\n                case SyntaxKind.ByKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                case SyntaxKind.AddKeyword:\n                case SyntaxKind.RemoveKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.AliasKeyword:\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.AssemblyKeyword:\n                case SyntaxKind.ModuleKeyword:\n                case SyntaxKind.TypeKeyword:\n                case SyntaxKind.GlobalKeyword:\n                case SyntaxKind.FieldKeyword:\n                case SyntaxKind.MethodKeyword:\n                case SyntaxKind.ParamKeyword:\n                case SyntaxKind.PropertyKeyword:\n                case SyntaxKind.TypeVarKeyword:\n                case SyntaxKind.NameOfKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.AwaitKeyword:\n                case SyntaxKind.WhenKeyword:\n                case SyntaxKind.UnderscoreToken:\n                case SyntaxKind.VarKeyword:\n                case SyntaxKind.OrKeyword:\n                case SyntaxKind.AndKeyword:\n                case SyntaxKind.NotKeyword:\n                case SyntaxKind.DataKeyword:\n                case SyntaxKind.WithKeyword:\n                case SyntaxKind.InitKeyword:\n                case SyntaxKind.RecordKeyword:\n                case SyntaxKind.ManagedKeyword:\n                case SyntaxKind.UnmanagedKeyword:\n                    return true;\n                default:\n                    return false;\n            } 149267"];
5183 [label="return false; 149268"];
5184 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 149269"];
5185 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 149270"];
5186 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 149271"];
5187 [label="return null; 149272"];
5188 [label="var errors = this.GetErrors(GetFullWidth(leading)); 149273"];
5189 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 149274"];
5190 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 149275"];
5191 [label="param AddTrivia(this) 149276"];
5192 [label="this.HasErrors 149277"];
5193 [label="get { return _errors != null; } 149278"];
5194 [label="return _errors != null; 149279"];
5195 [label="return _errors != null; 149280"];
5196 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 149281"];
5197 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 149282"];
5198 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 149283"];
5199 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 149284"];
5200 [label="return; 149285"];
5201 [label="param Create(SyntaxDiagnosticInfo[] errors) 149286"];
5202 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 149287"];
5203 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 149288"];
5204 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 149289"];
5205 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 149290"];
5206 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 149291"];
5207 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 149292"];
5208 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 149293"];
5209 [label="Debug.Assert(quickWidth == token.FullWidth); 149294"];
5210 [label="this.AddLexedToken(token); 149295"];
5211 [label="param AddLexedToken(SyntaxToken token) 149296"];
5212 [label="Debug.Assert(token != null); 149297"];
5213 [label="_lexedTokens[_tokenCount].Value 149298"];
5214 [label="get { return (SyntaxKind)this.RawKind; } 149299"];
5215 [label="return (SyntaxKind)this.RawKind; 149300"];
5216 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 149301"];
5217 [label="TextWindow.Start(); 149302"];
5218 [label="var quickWidth = TextWindow.Width; 149303"];
5219 [label="param LexSyntaxTrivia(bool afterFirstToken) 149304"];
5220 [label="param LexSyntaxTrivia(bool isTrailing) 149305"];
5221 [label="bool onlyWhitespaceOnLine = !isTrailing; 149306"];
5222 [label="this.Start(); 149307"];
5223 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 149308"];
5224 [label="return; 149309"];
5225 [label="this.Start(); 149310"];
5226 [label="param TryGetKeywordKind(out SyntaxKind kind) 149311"];
5227 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 149312"];
5228 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 149313"];
5229 [label="var errors = this.GetErrors(GetFullWidth(leading)); 149314"];
5230 [label="GetFullWidth(leading) 149315"];
5231 [label="param GetFullWidth(SyntaxListBuilder builder) 149316"];
5232 [label="int width = 0; 149317"];
5233 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 149318"];
5234 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 149319"];
5235 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 149320"];
5236 [label="return width; 149321"];
5237 [label="var errors = this.GetErrors(GetFullWidth(leading)); 149322"];
5238 [label="this.GetErrors(GetFullWidth(leading)) 149323"];
5239 [label="param GetErrors(int leadingTriviaWidth) 149324"];
5240 [label="param GetErrors(this) 149325"];
5241 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 149326"];
5242 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 149327"];
5243 [label="return null; 149328"];
5244 [label="var errors = this.GetErrors(GetFullWidth(leading)); 149329"];
5245 [label="param Create(SyntaxDiagnosticInfo[] errors) 149330"];
5246 [label="param Create(this) 149331"];
5247 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 149332"];
5248 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 149333"];
5249 [label="SyntaxToken token; 149334"];
5250 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 149335"];
5251 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 149336"];
5252 [label="Debug.Assert(quickWidth == token.FullWidth); 149337"];
5253 [label="param AddTrivia(this) 149338"];
5254 [label="get { return _errors != null; } 149339"];
5255 [label="return _errors != null; 149340"];
5256 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 149341"];
5257 [label="return (SyntaxKind)this.RawKind; 149342"];
5258 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 149343"];
5259 [label="this.Position 149344"];
5260 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 149345"];
5261 [label="return false; 149346"];
5262 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 149347"];
5263 [label="return InvalidCharacter; 149348"];
5264 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 149349"];
5265 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 149350"];
5266 [label="SyntaxFacts.IsWhitespace(ch) 149351"];
5267 [label="param IsWhitespace(char ch) 149352"];
5268 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 149353"];
5269 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 149354"];
5270 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 149355"];
5271 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 149356"];
5272 [label="SyntaxFacts.IsNewLine(ch) 149357"];
5273 [label="param IsNewLine(char ch) 149358"];
5274 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 149359"];
5275 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 149360"];
5276 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 149361"];
5277 [label="return; 149362"];
5278 [label="param LexSyntaxTrivia(bool afterFirstToken) 149363"];
5279 [label="param LexSyntaxTrivia(bool isTrailing) 149364"];
5280 [label="bool onlyWhitespaceOnLine = !isTrailing; 149365"];
5281 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 149366"];
5282 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 149367"];
5283 [label="return false; 149368"];
5284 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 149369"];
5285 [label="return InvalidCharacter; 149370"];
5286 [label="param IsReallyAtEnd(this) 149371"];
5287 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 149372"];
5288 [label="Position 149373"];
5289 [label="get\n            {\n                return _basis + _offset;\n            } 149374"];
5290 [label="return _basis + _offset; 149375"];
5291 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 149376"];
5292 [label="ConsList<Directive>.Empty 149377"];
5293 [label="new DirectiveStack(ConsList<Directive>.Empty) 149378"];
5294 [label="param DirectiveStack(ConsList<Directive> directives) 149379"];
5295 [label="param DirectiveStack(this) 149380"];
5296 [label="_directives 149381"];
5297 [label="Empty = new DirectiveStack(ConsList<Directive>.Empty) 149382"];
5298 [label="null 149383"];
5299 [label="new DirectiveStack(null) 149384"];
5300 [label="param DirectiveStack(ConsList<Directive> directives) 149385"];
5301 [label="param DirectiveStack(this) 149386"];
5302 [label="_directives 149387"];
5303 [label="Null = new DirectiveStack(null) 149388"];
5304 [label="param HasUnfinishedIf(this) 149389"];
5305 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 149390"];
5306 [label="GetPreviousIfElifElseOrRegion(_directives) 149391"];
5307 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 149392"];
5308 [label="var current = directives; 149393"];
5309 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 149394"];
5310 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 149395"];
5311 [label="return current; 149396"];
5312 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 149397"];
5313 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 149398"];
5314 [label="param HasUnfinishedRegion(this) 149399"];
5315 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 149400"];
5316 [label="GetPreviousIfElifElseOrRegion(_directives) 149401"];
5317 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 149402"];
5318 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 149403"];
5319 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 149404"];
5320 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 149405"];
5321 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 149406"];
5322 [label="var errors = this.GetErrors(GetFullWidth(leading)); 149407"];
5323 [label="param GetFullWidth(SyntaxListBuilder builder) 149408"];
5324 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 149409"];
5325 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 149410"];
5326 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 149411"];
5327 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 149412"];
5328 [label="return null; 149413"];
5329 [label="var errors = this.GetErrors(GetFullWidth(leading)); 149414"];
5330 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 149415"];
5331 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 149416"];
5332 [label="SyntaxFacts.IsWhitespace(ch) 149417"];
5333 [label="param IsWhitespace(char ch) 149418"];
5334 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 149419"];
5335 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 149420"];
5336 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 149421"];
5337 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 149422"];
5338 [label="SyntaxFacts.IsNewLine(ch) 149423"];
5339 [label="param IsNewLine(char ch) 149424"];
5340 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 149425"];
5341 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 149426"];
5342 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 149427"];
5343 [label="return; 149428"];
5344 [label="param Create(SyntaxDiagnosticInfo[] errors) 149429"];
5345 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 149430"];
5346 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 149431"];
5347 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 149432"];
5348 [label="param Token(GreenNode leading) 149433"];
5349 [label="param Token(SyntaxKind kind) 149434"];
5350 [label="param Token(GreenNode trailing) 149435"];
5351 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 149436"];
5352 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 149437"];
5353 [label="this.AddLexedToken(token); 149438"];
5354 [label="param AddLexedToken(SyntaxToken token) 149439"];
5355 [label="Debug.Assert(token != null); 149440"];
5356 [label="_lexedTokens[_tokenCount].Value 149441"];
5357 [label="get { return (SyntaxKind)this.RawKind; } 149442"];
5358 [label="return (SyntaxKind)this.RawKind; 149443"];
5359 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 149444"];
5360 [label="this.PreLex(); 149445"];
5361 [label="new SyntaxListPool() 149446"];
5362 [label="_pool = new SyntaxListPool() 149447"];
5363 [label="_syntaxFactoryContext 149448"];
5364 [label="_syntaxFactory 149449"];
5365 [label="_recursionDepth 149450"];
5366 [label="_termState 149451"];
5367 [label="_isInTry 149452"];
5368 [label="_checkedTopLevelStatementsFeatureAvailability 149453"];
5369 [label="_syntaxFactoryContext = new SyntaxFactoryContext(); 149454"];
5370 [label="_syntaxFactoryContext 149455"];
5371 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 149456"];
5372 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 149457"];
5373 [label="_syntaxFactory 149458"];
5374 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 149459"];
5375 [label="parser.ParseStatement() 149460"];
5376 [label="param ParseStatement(this) 149461"];
5377 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 149462"];
5378 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 149463"];
5379 [label="ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))) 149464"];
5380 [label="param ParseWithStackGuard(Func<TNode> parseFunc) 149465"];
5381 [label="param ParseWithStackGuard(Func<TNode> createEmptyNodeFunc) 149466"];
5382 [label="param ParseWithStackGuard(this) 149467"];
5383 [label="Debug.Assert(_recursionDepth == 0); 149468"];
5384 [label="Debug.Assert(_recursionDepth == 0); 149469"];
5385 [label="return parseFunc(); 149470"];
5386 [label="return parseFunc(); 149471"];
5387 [label="=> ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 149472"];
5388 [label="ParseAttributeDeclarations() 149473"];
5389 [label="param ParseAttributeDeclarations(this) 149474"];
5390 [label="var attributes = _pool.Allocate<AttributeListSyntax>(); 149475"];
5391 [label="var saveTerm = _termState; 149476"];
5392 [label="_termState |= TerminatorState.IsAttributeDeclarationTerminator; 149477"];
5393 [label="_termState 149478"];
5394 [label="this.IsPossibleAttributeDeclaration() 149479"];
5395 [label="param IsPossibleAttributeDeclaration(this) 149480"];
5396 [label="this.CurrentToken 149481"];
5397 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149482"];
5398 [label="this.FetchCurrentToken() 149483"];
5399 [label="param FetchCurrentToken(this) 149484"];
5400 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 149485"];
5401 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 149486"];
5402 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 149487"];
5403 [label="return _lexedTokens[_tokenOffset]; 149488"];
5404 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 149489"];
5405 [label="_currentToken 149490"];
5406 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 149491"];
5407 [label="this.CurrentToken.Kind 149492"];
5408 [label="get { return (SyntaxKind)this.RawKind; } 149493"];
5409 [label="return (SyntaxKind)this.RawKind; 149494"];
5410 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 149495"];
5411 [label="_termState 149496"];
5412 [label="return attributes.ToList(); 149497"];
5413 [label="_pool.Free(attributes); 149498"];
5414 [label="_pool.Free(attributes); 149499"];
5415 [label="false 149500"];
5416 [label="isGlobal: false 149501"];
5417 [label="ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 149502"];
5418 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 149503"];
5419 [label="param ParseStatementCore(bool isGlobal) 149504"];
5420 [label="param ParseStatementCore(this) 149505"];
5421 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 149506"];
5422 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 149507"];
5423 [label="canReuseStatement(attributes, isGlobal) 149508"];
5424 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 149509"];
5425 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 149510"];
5426 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 149511"];
5427 [label="this.IsIncrementalAndFactoryContextMatches 149512"];
5428 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 149513"];
5429 [label="base.IsIncremental 149514"];
5430 [label="get\n            {\n                return _isIncremental;\n            } 149515"];
5431 [label="return _isIncremental; 149516"];
5432 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 149517"];
5433 [label="return false; 149518"];
5434 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 149519"];
5435 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 149520"];
5436 [label="this.GetResetPoint() 149521"];
5437 [label="param GetResetPoint(this) 149522"];
5438 [label="base.GetResetPoint() 149523"];
5439 [label="param GetResetPoint(this) 149524"];
5440 [label="CurrentTokenPosition 149525"];
5441 [label="=> _firstToken + _tokenOffset 149526"];
5442 [label="_firstToken + _tokenOffset 149527"];
5443 [label="var pos = CurrentTokenPosition; 149528"];
5444 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 149529"];
5445 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 149530"];
5446 [label="_resetStart 149531"];
5447 [label="_resetCount 149532"];
5448 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 149533"];
5449 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 149534"];
5450 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 149535"];
5451 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 149536"];
5452 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 149537"];
5453 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 149538"];
5454 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 149539"];
5455 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 149540"];
5456 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 149541"];
5457 [label="param ResetPoint(TerminatorState terminatorState) 149542"];
5458 [label="param ResetPoint(bool isInTry) 149543"];
5459 [label="param ResetPoint(bool isInAsync) 149544"];
5460 [label="param ResetPoint(int queryDepth) 149545"];
5461 [label="param ResetPoint(this) 149546"];
5462 [label="this.BaseResetPoint 149547"];
5463 [label="this.TerminatorState 149548"];
5464 [label="this.IsInTry 149549"];
5465 [label="this.IsInAsync 149550"];
5466 [label="this.QueryDepth 149551"];
5467 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 149552"];
5468 [label="_recursionDepth 149553"];
5469 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 149554"];
5470 [label="StatementSyntax result; 149555"];
5471 [label="this.CurrentToken 149556"];
5472 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149557"];
5473 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 149558"];
5474 [label="switch (this.CurrentToken.Kind)\n                {\n                    case SyntaxKind.FixedKeyword:\n                        return this.ParseFixedStatement(attributes);\n                    case SyntaxKind.BreakKeyword:\n                        return this.ParseBreakStatement(attributes);\n                    case SyntaxKind.ContinueKeyword:\n                        return this.ParseContinueStatement(attributes);\n                    case SyntaxKind.TryKeyword:\n                    case SyntaxKind.CatchKeyword:\n                    case SyntaxKind.FinallyKeyword:\n                        return this.ParseTryStatement(attributes);\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                        return this.ParseCheckedStatement(attributes);\n                    case SyntaxKind.DoKeyword:\n                        return this.ParseDoStatement(attributes);\n                    case SyntaxKind.ForKeyword:\n                        return this.ParseForOrForEachStatement(attributes);\n                    case SyntaxKind.ForEachKeyword:\n                        return this.ParseForEachStatement(attributes, awaitTokenOpt: null);\n                    case SyntaxKind.GotoKeyword:\n                        return this.ParseGotoStatement(attributes);\n                    case SyntaxKind.IfKeyword:\n                        return this.ParseIfStatement(attributes);\n                    case SyntaxKind.ElseKeyword:\n                        // Including 'else' keyword to handle 'else without if' error cases \n                        return this.ParseMisplacedElse(attributes);\n                    case SyntaxKind.LockKeyword:\n                        return this.ParseLockStatement(attributes);\n                    case SyntaxKind.ReturnKeyword:\n                        return this.ParseReturnStatement(attributes);\n                    case SyntaxKind.SwitchKeyword:\n                        return this.ParseSwitchStatement(attributes);\n                    case SyntaxKind.ThrowKeyword:\n                        return this.ParseThrowStatement(attributes);\n                    case SyntaxKind.UnsafeKeyword:\n                        result = TryParseStatementStartingWithUnsafe(attributes);\n                        if (result != null)\n                            return result;\n                        break;\n                    case SyntaxKind.UsingKeyword:\n                        return ParseStatementStartingWithUsing(attributes);\n                    case SyntaxKind.WhileKeyword:\n                        return this.ParseWhileStatement(attributes);\n                    case SyntaxKind.OpenBraceToken:\n                        return this.ParseBlock(attributes);\n                    case SyntaxKind.SemicolonToken:\n                        return _syntaxFactory.EmptyStatement(attributes, this.EatToken());\n                    case SyntaxKind.IdentifierToken:\n                        result = TryParseStatementStartingWithIdentifier(attributes, isGlobal);\n                        if (result != null)\n                            return result;\n                        break;\n                } 149559"];
5475 [label="this.CurrentToken.Kind 149560"];
5476 [label="get { return (SyntaxKind)this.RawKind; } 149561"];
5477 [label="return (SyntaxKind)this.RawKind; 149562"];
5478 [label="return this.ParseSwitchStatement(attributes); 149563"];
5479 [label="this.ParseSwitchStatement(attributes) 149564"];
5480 [label="param ParseSwitchStatement(SyntaxList<AttributeListSyntax> attributes) 149565"];
5481 [label="param ParseSwitchStatement(this) 149566"];
5482 [label="this.CurrentToken 149567"];
5483 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149568"];
5484 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.SwitchKeyword); 149569"];
5485 [label="this.CurrentToken.Kind 149570"];
5486 [label="get { return (SyntaxKind)this.RawKind; } 149571"];
5487 [label="var @switch = this.EatToken(SyntaxKind.SwitchKeyword); 149572"];
5488 [label="this.EatToken(SyntaxKind.SwitchKeyword) 149573"];
5489 [label="param EatToken(SyntaxKind kind) 149574"];
5490 [label="param EatToken(this) 149575"];
5491 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 149576"];
5492 [label="SyntaxFacts.IsAnyToken(kind) 149577"];
5493 [label="param IsAnyToken(SyntaxKind kind) 149578"];
5494 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 149579"];
5495 [label="return true; 149580"];
5496 [label="this.CurrentToken 149581"];
5497 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149582"];
5498 [label="var ct = this.CurrentToken; 149583"];
5499 [label="ct.Kind 149584"];
5500 [label="get { return (SyntaxKind)this.RawKind; } 149585"];
5501 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 149586"];
5502 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 149587"];
5503 [label="MoveToNextToken() 149588"];
5504 [label="param MoveToNextToken(this) 149589"];
5505 [label="_currentToken.GetTrailingTrivia() 149590"];
5506 [label="param GetTrailingTrivia(this) 149591"];
5507 [label="return this.TrailingField; 149592"];
5508 [label="_prevTokenTrailingTrivia = _currentToken.GetTrailingTrivia(); 149593"];
5509 [label="_prevTokenTrailingTrivia 149594"];
5510 [label="_currentToken = null; 149595"];
5511 [label="_currentToken 149596"];
5512 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 149597"];
5513 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 149598"];
5514 [label="_tokenOffset 149599"];
5515 [label="MoveToNextToken(); 149600"];
5516 [label="return ct; 149601"];
5517 [label="this.ParseExpressionCore() 149602"];
5518 [label="param ParseExpressionCore(this) 149603"];
5519 [label="return this.ParseSubExpression(Precedence.Expression); 149604"];
5520 [label="this.ParseSubExpression(Precedence.Expression) 149605"];
5521 [label="param ParseSubExpression(Precedence precedence) 149606"];
5522 [label="param ParseSubExpression(this) 149607"];
5523 [label="_recursionDepth 149608"];
5524 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 149609"];
5525 [label="var result = ParseSubExpressionCore(precedence); 149610"];
5526 [label="ParseSubExpressionCore(precedence) 149611"];
5527 [label="param ParseSubExpressionCore(Precedence precedence) 149612"];
5528 [label="param ParseSubExpressionCore(this) 149613"];
5529 [label="ExpressionSyntax leftOperand; 149614"];
5530 [label="Precedence newPrecedence = 0; 149615"];
5531 [label="this.CurrentToken 149616"];
5532 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149617"];
5533 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 149618"];
5534 [label="return _lexedTokens[_tokenOffset]; 149619"];
5535 [label="var tk = this.CurrentToken.Kind; 149620"];
5536 [label="this.CurrentToken.Kind 149621"];
5537 [label="get { return (SyntaxKind)this.RawKind; } 149622"];
5538 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 149623"];
5539 [label="IsInvalidSubExpression(tk) 149624"];
5540 [label="param IsInvalidSubExpression(SyntaxKind kind) 149625"];
5541 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 149626"];
5542 [label="return false; 149627"];
5543 [label="if (IsExpectedPrefixUnaryOperator(tk))\n            {\n                var opKind = SyntaxFacts.GetPrefixUnaryExpression(tk);\n                newPrecedence = GetPrecedence(opKind);\n                var opToken = this.EatToken();\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.PrefixUnaryExpression(opKind, opToken, operand);\n            }\n            else if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 149628"];
5544 [label="IsExpectedPrefixUnaryOperator(tk) 149629"];
5545 [label="param IsExpectedPrefixUnaryOperator(SyntaxKind kind) 149630"];
5546 [label="return SyntaxFacts.IsPrefixUnaryExpression(kind) && kind != SyntaxKind.RefKeyword && kind != SyntaxKind.OutKeyword; 149631"];
5547 [label="SyntaxFacts.IsPrefixUnaryExpression(kind) 149632"];
5548 [label="param IsPrefixUnaryExpression(SyntaxKind token) 149633"];
5549 [label="return GetPrefixUnaryExpression(token) != SyntaxKind.None; 149634"];
5550 [label="GetPrefixUnaryExpression(token) 149635"];
5551 [label="param GetPrefixUnaryExpression(SyntaxKind token) 149636"];
5552 [label="switch (token)\n            {\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.UnaryPlusExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.UnaryMinusExpression;\n                case SyntaxKind.TildeToken:\n                    return SyntaxKind.BitwiseNotExpression;\n                case SyntaxKind.ExclamationToken:\n                    return SyntaxKind.LogicalNotExpression;\n                case SyntaxKind.PlusPlusToken:\n                    return SyntaxKind.PreIncrementExpression;\n                case SyntaxKind.MinusMinusToken:\n                    return SyntaxKind.PreDecrementExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.AddressOfExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.PointerIndirectionExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.IndexExpression;\n                default:\n                    return SyntaxKind.None;\n            } 149637"];
5553 [label="return SyntaxKind.None; 149638"];
5554 [label="if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 149639"];
5555 [label="IsAwaitExpression() 149640"];
5556 [label="param IsAwaitExpression(this) 149641"];
5557 [label="this.CurrentToken 149642"];
5558 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149643"];
5559 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 149644"];
5560 [label="this.CurrentToken.ContextualKind 149645"];
5561 [label="get\n            {\n                return this.Kind;\n            } 149646"];
5562 [label="this.Kind 149647"];
5563 [label="get { return (SyntaxKind)this.RawKind; } 149648"];
5564 [label="return this.Kind; 149649"];
5565 [label="return false; 149650"];
5566 [label="if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 149651"];
5567 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 149652"];
5568 [label="this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false) 149653"];
5569 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 149654"];
5570 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 149655"];
5571 [label="param IsQueryExpression(this) 149656"];
5572 [label="this.CurrentToken 149657"];
5573 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149658"];
5574 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 149659"];
5575 [label="this.CurrentToken.ContextualKind 149660"];
5576 [label="get\n            {\n                return this.Kind;\n            } 149661"];
5577 [label="this.Kind 149662"];
5578 [label="get { return (SyntaxKind)this.RawKind; } 149663"];
5579 [label="return this.Kind; 149664"];
5580 [label="return false; 149665"];
5581 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 149666"];
5582 [label="this.CurrentToken 149667"];
5583 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 149668"];
5584 [label="this.CurrentToken.ContextualKind 149669"];
5585 [label="get\n            {\n                return this.Kind;\n            } 149670"];
5586 [label="this.Kind 149671"];
5587 [label="get { return (SyntaxKind)this.RawKind; } 149672"];
5588 [label="return this.Kind; 149673"];
5589 [label="if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 149674"];
5590 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 149675"];
5591 [label="this.IsPossibleDeconstructionLeft(precedence) 149676"];
5592 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 149677"];
5593 [label="param IsPossibleDeconstructionLeft(this) 149678"];
5594 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 149679"];
5595 [label="this.CurrentToken 149680"];
5596 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149681"];
5597 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 149682"];
5598 [label="this.CurrentToken.IsIdentifierVar() 149683"];
5599 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 149684"];
5600 [label="node.ContextualKind 149685"];
5601 [label="get\n            {\n                return this.Kind;\n            } 149686"];
5602 [label="return node.ContextualKind == SyntaxKind.VarKeyword; 149687"];
5603 [label="this.CurrentToken 149688"];
5604 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149689"];
5605 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 149690"];
5606 [label="this.CurrentToken.Kind 149691"];
5607 [label="get { return (SyntaxKind)this.RawKind; } 149692"];
5608 [label="IsPredefinedType(this.CurrentToken.Kind) 149693"];
5609 [label="param IsPredefinedType(SyntaxKind keyword) 149694"];
5610 [label="return SyntaxFacts.IsPredefinedType(keyword); 149695"];
5611 [label="SyntaxFacts.IsPredefinedType(keyword) 149696"];
5612 [label="param IsPredefinedType(SyntaxKind kind) 149697"];
5613 [label="switch (kind)\n            {\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.VoidKeyword:\n                    return true;\n                default:\n                    return false;\n            } 149698"];
5614 [label="return false; 149699"];
5615 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 149700"];
5616 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 149701"];
5617 [label="return false; 149702"];
5618 [label="leftOperand = this.ParseTerm(precedence); 149703"];
5619 [label="this.ParseTerm(precedence) 149704"];
5620 [label="param ParseTerm(Precedence precedence) 149705"];
5621 [label="=> this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 149706"];
5622 [label="precedence 149707"];
5623 [label="ParseTermWithoutPostfix(precedence) 149708"];
5624 [label="param ParseTermWithoutPostfix(Precedence precedence) 149709"];
5625 [label="param ParseTermWithoutPostfix(this) 149710"];
5626 [label="this.CurrentToken 149711"];
5627 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149712"];
5628 [label="var tk = this.CurrentToken.Kind; 149713"];
5629 [label="this.CurrentToken.Kind 149714"];
5630 [label="get { return (SyntaxKind)this.RawKind; } 149715"];
5631 [label="switch (tk)\n            {\n                case SyntaxKind.TypeOfKeyword:\n                    return this.ParseTypeOfExpression();\n                case SyntaxKind.DefaultKeyword:\n                    return this.ParseDefaultExpression();\n                case SyntaxKind.SizeOfKeyword:\n                    return this.ParseSizeOfExpression();\n                case SyntaxKind.MakeRefKeyword:\n                    return this.ParseMakeRefExpression();\n                case SyntaxKind.RefTypeKeyword:\n                    return this.ParseRefTypeExpression();\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                    return this.ParseCheckedOrUncheckedExpression();\n                case SyntaxKind.RefValueKeyword:\n                    return this.ParseRefValueExpression();\n                case SyntaxKind.ColonColonToken:\n                    // misplaced ::\n                    // Calling ParseAliasQualifiedName will cause us to create a missing identifier node that then\n                    // properly consumes the :: and the reset of the alias name afterwards.\n                    return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return this.ParseLambdaExpression();\n                case SyntaxKind.StaticKeyword:\n                    if (this.IsPossibleAnonymousMethodExpression())\n                    {\n                        return this.ParseAnonymousMethodExpression();\n                    }\n                    else if (this.IsPossibleLambdaExpression(precedence))\n                    {\n                        return this.ParseLambdaExpression();\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.IdentifierToken:\n                    if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.ThisKeyword:\n                    return _syntaxFactory.ThisExpression(this.EatToken());\n                case SyntaxKind.BaseKeyword:\n                    return ParseBaseExpression();\n\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.FalseKeyword:\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                    return _syntaxFactory.LiteralExpression(SyntaxFacts.GetLiteralExpression(tk), this.EatToken());\n                case SyntaxKind.InterpolatedStringStartToken:\n                    throw new NotImplementedException(); // this should not occur because these tokens are produced and parsed immediately\n                case SyntaxKind.InterpolatedStringToken:\n                    return this.ParseInterpolatedStringToken();\n                case SyntaxKind.OpenParenToken:\n                    return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence);\n                case SyntaxKind.NewKeyword:\n                    return this.ParseNewExpression();\n                case SyntaxKind.StackAllocKeyword:\n                    return this.ParseStackAllocExpression();\n                case SyntaxKind.DelegateKeyword:\n                    return this.ParseAnonymousMethodExpression();\n                case SyntaxKind.RefKeyword:\n                    // ref is not expected to appear in this position.\n                    return this.AddError(ParsePossibleRefExpression(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                default:\n                    // check for intrinsic type followed by '.'\n                    if (IsPredefinedType(tk))\n                    {\n                        var expr = _syntaxFactory.PredefinedType(this.EatToken());\n\n                        if (this.CurrentToken.Kind != SyntaxKind.DotToken || tk == SyntaxKind.VoidKeyword)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n                    else\n                    {\n                        var expr = this.CreateMissingIdentifierName();\n\n                        if (tk == SyntaxKind.EndOfFileToken)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_ExpressionExpected);\n                        }\n                        else\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n            } 149716"];
5632 [label="return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence); 149717"];
5633 [label="this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence) 149718"];
5634 [label="param ParseCastOrParenExpressionOrLambdaOrTuple(Precedence precedence) 149719"];
5635 [label="param ParseCastOrParenExpressionOrLambdaOrTuple(this) 149720"];
5636 [label="this.CurrentToken 149721"];
5637 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149722"];
5638 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.OpenParenToken); 149723"];
5639 [label="this.CurrentToken.Kind 149724"];
5640 [label="get { return (SyntaxKind)this.RawKind; } 149725"];
5641 [label="this.GetResetPoint() 149726"];
5642 [label="param GetResetPoint(this) 149727"];
5643 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 149728"];
5644 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 149729"];
5645 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 149730"];
5646 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 149731"];
5647 [label="param ResetPoint(TerminatorState terminatorState) 149732"];
5648 [label="param ResetPoint(bool isInTry) 149733"];
5649 [label="param ResetPoint(bool isInAsync) 149734"];
5650 [label="param ResetPoint(int queryDepth) 149735"];
5651 [label="param ResetPoint(this) 149736"];
5652 [label="this.BaseResetPoint 149737"];
5653 [label="this.TerminatorState 149738"];
5654 [label="this.IsInTry 149739"];
5655 [label="this.IsInAsync 149740"];
5656 [label="this.QueryDepth 149741"];
5657 [label="var resetPoint = this.GetResetPoint(); 149742"];
5658 [label="if (ScanParenthesizedImplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 149743"];
5659 [label="ScanParenthesizedImplicitlyTypedLambda(precedence) 149744"];
5660 [label="param ScanParenthesizedImplicitlyTypedLambda(Precedence precedence) 149745"];
5661 [label="param ScanParenthesizedImplicitlyTypedLambda(this) 149746"];
5662 [label="if (!(precedence <= Precedence.Lambda))\n            {\n                return false;\n            } 149747"];
5663 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 149748"];
5664 [label="this.PeekToken(1) 149749"];
5665 [label="param PeekToken(int n) 149750"];
5666 [label="param PeekToken(this) 149751"];
5667 [label="Debug.Assert(n >= 0); 149752"];
5668 [label="Debug.Assert(n >= 0); 149753"];
5669 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 149754"];
5670 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 149755"];
5671 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 149756"];
5672 [label="return _lexedTokens[_tokenOffset + n]; 149757"];
5673 [label="this.PeekToken(1).Kind 149758"];
5674 [label="get { return (SyntaxKind)this.RawKind; } 149759"];
5675 [label="this.IsInQuery 149760"];
5676 [label="get { return _syntaxFactoryContext.IsInQuery; } 149761"];
5677 [label="return _syntaxFactoryContext.IsInQuery; 149762"];
5678 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 149763"];
5679 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 149764"];
5680 [label="this.PeekToken(2) 149765"];
5681 [label="param PeekToken(int n) 149766"];
5682 [label="param PeekToken(this) 149767"];
5683 [label="Debug.Assert(n >= 0); 149768"];
5684 [label="Debug.Assert(n >= 0); 149769"];
5685 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 149770"];
5686 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 149771"];
5687 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 149772"];
5688 [label="return _lexedTokens[_tokenOffset + n]; 149773"];
5689 [label="this.PeekToken(2).Kind 149774"];
5690 [label="get { return (SyntaxKind)this.RawKind; } 149775"];
5691 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 149776"];
5692 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 149777"];
5693 [label="this.PeekToken(1) 149778"];
5694 [label="param PeekToken(int n) 149779"];
5695 [label="param PeekToken(this) 149780"];
5696 [label="Debug.Assert(n >= 0); 149781"];
5697 [label="Debug.Assert(n >= 0); 149782"];
5698 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 149783"];
5699 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 149784"];
5700 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 149785"];
5701 [label="return _lexedTokens[_tokenOffset + n]; 149786"];
5702 [label="IsTrueIdentifier(this.PeekToken(1)) 149787"];
5703 [label="param IsTrueIdentifier(SyntaxToken token) 149788"];
5704 [label="param IsTrueIdentifier(this) 149789"];
5705 [label="token.Kind 149790"];
5706 [label="get { return (SyntaxKind)this.RawKind; } 149791"];
5707 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 149792"];
5708 [label="this.IsInQuery 149793"];
5709 [label="get { return _syntaxFactoryContext.IsInQuery; } 149794"];
5710 [label="return _syntaxFactoryContext.IsInQuery; 149795"];
5711 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 149796"];
5712 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 149797"];
5713 [label="this.PeekToken(2) 149798"];
5714 [label="param PeekToken(int n) 149799"];
5715 [label="param PeekToken(this) 149800"];
5716 [label="Debug.Assert(n >= 0); 149801"];
5717 [label="Debug.Assert(n >= 0); 149802"];
5718 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 149803"];
5719 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 149804"];
5720 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 149805"];
5721 [label="return _lexedTokens[_tokenOffset + n]; 149806"];
5722 [label="this.PeekToken(2).Kind 149807"];
5723 [label="get { return (SyntaxKind)this.RawKind; } 149808"];
5724 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 149809"];
5725 [label="this.PeekToken(3) 149810"];
5726 [label="param PeekToken(int n) 149811"];
5727 [label="param PeekToken(this) 149812"];
5728 [label="Debug.Assert(n >= 0); 149813"];
5729 [label="Debug.Assert(n >= 0); 149814"];
5730 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 149815"];
5731 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 149816"];
5732 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 149817"];
5733 [label="return _lexedTokens[_tokenOffset + n]; 149818"];
5734 [label="this.PeekToken(3).Kind 149819"];
5735 [label="get { return (SyntaxKind)this.RawKind; } 149820"];
5736 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 149821"];
5737 [label="if (this.PeekToken(1).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(2).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 149822"];
5738 [label="this.PeekToken(1) 149823"];
5739 [label="param PeekToken(int n) 149824"];
5740 [label="param PeekToken(this) 149825"];
5741 [label="Debug.Assert(n >= 0); 149826"];
5742 [label="Debug.Assert(n >= 0); 149827"];
5743 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 149828"];
5744 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 149829"];
5745 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 149830"];
5746 [label="return _lexedTokens[_tokenOffset + n]; 149831"];
5747 [label="this.PeekToken(1).Kind 149832"];
5748 [label="get { return (SyntaxKind)this.RawKind; } 149833"];
5749 [label="if (this.PeekToken(1).Kind == SyntaxKind.ParamsKeyword)\n            {\n                return true;\n            } 149834"];
5750 [label="this.PeekToken(1) 149835"];
5751 [label="param PeekToken(int n) 149836"];
5752 [label="param PeekToken(this) 149837"];
5753 [label="Debug.Assert(n >= 0); 149838"];
5754 [label="Debug.Assert(n >= 0); 149839"];
5755 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 149840"];
5756 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 149841"];
5757 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 149842"];
5758 [label="return _lexedTokens[_tokenOffset + n]; 149843"];
5759 [label="this.PeekToken(1).Kind 149844"];
5760 [label="get { return (SyntaxKind)this.RawKind; } 149845"];
5761 [label="return false; 149846"];
5762 [label="if (ScanParenthesizedImplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 149847"];
5763 [label="if (this.ScanCast())\n                {\n                    if (!IsCurrentTokenQueryKeywordInQuery())\n                    {\n                        // Looks like a cast, so parse it as one.\n                        this.Reset(ref resetPoint);\n                        var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                        var type = this.ParseType();\n                        var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                        var expr = this.ParseSubExpression(Precedence.Cast);\n                        return _syntaxFactory.CastExpression(openParen, type, closeParen, expr);\n                    }\n                } 149848"];
5764 [label="this.ScanCast() 149849"];
5765 [label="param ScanCast(bool forPattern = false) 149850"];
5766 [label="param ScanCast(this) 149851"];
5767 [label="this.CurrentToken 149852"];
5768 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149853"];
5769 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 149854"];
5770 [label="if (this.CurrentToken.Kind != SyntaxKind.OpenParenToken)\n            {\n                return false;\n            } 149855"];
5771 [label="this.CurrentToken.Kind 149856"];
5772 [label="get { return (SyntaxKind)this.RawKind; } 149857"];
5773 [label="this.EatToken() 149858"];
5774 [label="param EatToken(this) 149859"];
5775 [label="this.CurrentToken 149860"];
5776 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149861"];
5777 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 149862"];
5778 [label="var ct = this.CurrentToken; 149863"];
5779 [label="MoveToNextToken() 149864"];
5780 [label="param MoveToNextToken(this) 149865"];
5781 [label="param GetTrailingTrivia(this) 149866"];
5782 [label="return null; 149867"];
5783 [label="_prevTokenTrailingTrivia 149868"];
5784 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 149869"];
5785 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 149870"];
5786 [label="_tokenOffset 149871"];
5787 [label="MoveToNextToken(); 149872"];
5788 [label="return ct; 149873"];
5789 [label="this.EatToken(); 149874"];
5790 [label="var type = this.ScanType(forPattern: forPattern); 149875"];
5791 [label="this.ScanType(forPattern: forPattern) 149876"];
5792 [label="param ScanType(bool forPattern = false) 149877"];
5793 [label="param ScanType(this) 149878"];
5794 [label="return ScanType(out _, forPattern); 149879"];
5795 [label="return ScanType(out _, forPattern); 149880"];
5796 [label="ScanType(out _, forPattern) 149881"];
5797 [label="param ScanType(out SyntaxToken lastTokenOfType) 149882"];
5798 [label="param ScanType(bool forPattern = false) 149883"];
5799 [label="param ScanType(this) 149884"];
5800 [label="forPattern 149885"];
5801 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 149886"];
5802 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 149887"];
5803 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 149888"];
5804 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 149889"];
5805 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 149890"];
5806 [label="param PeekToken(int n) 149891"];
5807 [label="param PeekToken(this) 149892"];
5808 [label="Debug.Assert(n >= 0); 149893"];
5809 [label="Debug.Assert(n >= 0); 149894"];
5810 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 149895"];
5811 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 149896"];
5812 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 149897"];
5813 [label="return _lexedTokens[_tokenOffset + n]; 149898"];
5814 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 149899"];
5815 [label="param ScanNamedTypePart(this) 149900"];
5816 [label="this.CurrentToken 149901"];
5817 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149902"];
5818 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 149903"];
5819 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 149904"];
5820 [label="this.CurrentToken.Kind 149905"];
5821 [label="get { return (SyntaxKind)this.RawKind; } 149906"];
5822 [label="this.IsTrueIdentifier() 149907"];
5823 [label="param IsTrueIdentifier(this) 149908"];
5824 [label="this.CurrentToken 149909"];
5825 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149910"];
5826 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 149911"];
5827 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 149912"];
5828 [label="this.CurrentToken.Kind 149913"];
5829 [label="get { return (SyntaxKind)this.RawKind; } 149914"];
5830 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 149915"];
5831 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 149916"];
5832 [label="this.CurrentToken 149917"];
5833 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149918"];
5834 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 149919"];
5835 [label="this.CurrentToken.ContextualKind 149920"];
5836 [label="get\n            {\n                return this.Kind;\n            } 149921"];
5837 [label="return false; 149922"];
5838 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 149923"];
5839 [label="IsCurrentTokenQueryKeywordInQuery() 149924"];
5840 [label="param IsCurrentTokenQueryKeywordInQuery(this) 149925"];
5841 [label="this.IsInQuery 149926"];
5842 [label="get { return _syntaxFactoryContext.IsInQuery; } 149927"];
5843 [label="return _syntaxFactoryContext.IsInQuery; 149928"];
5844 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 149929"];
5845 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 149930"];
5846 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 149931"];
5847 [label="IsCurrentTokenWhereOfConstraintClause() 149932"];
5848 [label="param IsCurrentTokenWhereOfConstraintClause(this) 149933"];
5849 [label="this.CurrentToken 149934"];
5850 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149935"];
5851 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 149936"];
5852 [label="this.CurrentToken.ContextualKind 149937"];
5853 [label="get\n            {\n                return this.Kind;\n            } 149938"];
5854 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 149939"];
5855 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 149940"];
5856 [label="return true; 149941"];
5857 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 149942"];
5858 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 149943"];
5859 [label="this.EatToken() 149944"];
5860 [label="param EatToken(this) 149945"];
5861 [label="this.CurrentToken 149946"];
5862 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149947"];
5863 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 149948"];
5864 [label="var ct = this.CurrentToken; 149949"];
5865 [label="MoveToNextToken() 149950"];
5866 [label="param GetTrailingTrivia(this) 149951"];
5867 [label="return null; 149952"];
5868 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 149953"];
5869 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 149954"];
5870 [label="_tokenOffset 149955"];
5871 [label="MoveToNextToken(); 149956"];
5872 [label="return ct; 149957"];
5873 [label="lastTokenOfType = this.EatToken(); 149958"];
5874 [label="this.CurrentToken 149959"];
5875 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149960"];
5876 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 149961"];
5877 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 149962"];
5878 [label="return _lexedTokens[_tokenOffset]; 149963"];
5879 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                return this.ScanPossibleTypeArgumentList(ref lastTokenOfType, out _);\n            }\n            else\n            {\n                return ScanTypeFlags.NonGenericTypeOrExpression;\n            } 149964"];
5880 [label="this.CurrentToken.Kind 149965"];
5881 [label="get { return (SyntaxKind)this.RawKind; } 149966"];
5882 [label="return ScanTypeFlags.NonGenericTypeOrExpression; 149967"];
5883 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 149968"];
5884 [label="param IsDotOrColonColon(this) 149969"];
5885 [label="this.CurrentToken 149970"];
5886 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149971"];
5887 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 149972"];
5888 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 149973"];
5889 [label="this.CurrentToken.Kind 149974"];
5890 [label="get { return (SyntaxKind)this.RawKind; } 149975"];
5891 [label="this.CurrentToken 149976"];
5892 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149977"];
5893 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 149978"];
5894 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 149979"];
5895 [label="this.CurrentToken.Kind 149980"];
5896 [label="get { return (SyntaxKind)this.RawKind; } 149981"];
5897 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 149982"];
5898 [label="param IsMakingProgress(ref int lastTokenPosition) 149983"];
5899 [label="param IsMakingProgress(bool assertIfFalse = true) 149984"];
5900 [label="param IsMakingProgress(this) 149985"];
5901 [label="CurrentTokenPosition 149986"];
5902 [label="=> _firstToken + _tokenOffset 149987"];
5903 [label="_firstToken + _tokenOffset 149988"];
5904 [label="var pos = CurrentTokenPosition; 149989"];
5905 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 149990"];
5906 [label="lastTokenPosition = pos; 149991"];
5907 [label="return true; 149992"];
5908 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 149993"];
5909 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 149994"];
5910 [label="if (type == ScanTypeFlags.NotType)\n            {\n                return false;\n            } 149995"];
5911 [label="this.CurrentToken 149996"];
5912 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 149997"];
5913 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 149998"];
5914 [label="if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n            {\n                return false;\n            } 149999"];
5915 [label="this.CurrentToken.Kind 150000"];
5916 [label="get { return (SyntaxKind)this.RawKind; } 150001"];
5917 [label="this.EatToken() 150002"];
5918 [label="param EatToken(this) 150003"];
5919 [label="this.CurrentToken 150004"];
5920 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150005"];
5921 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 150006"];
5922 [label="MoveToNextToken() 150007"];
5923 [label="param MoveToNextToken(this) 150008"];
5924 [label="param GetTrailingTrivia(this) 150009"];
5925 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 150010"];
5926 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 150011"];
5927 [label="_tokenOffset 150012"];
5928 [label="MoveToNextToken(); 150013"];
5929 [label="this.EatToken(); 150014"];
5930 [label="switch (type)\n            {\n                // If we have any of the following, we know it must be a cast:\n                // 1) (Goo*)bar;\n                // 2) (Goo?)bar;\n                // 3) '(int)bar' or '(int[])bar'\n                // 4) (G::Goo)bar\n                case ScanTypeFlags.PointerOrMultiplication:\n                case ScanTypeFlags.NullableType:\n                case ScanTypeFlags.MustBeType:\n                case ScanTypeFlags.AliasQualifiedName:\n                    // The thing between parens is unambiguously a type.\n                    // In a pattern, we need more lookahead to confirm it is a cast and not\n                    // a parenthesized type pattern.  In this case the tokens that\n                    // have both unary and binary operator forms may appear in their unary form\n                    // following a cast.\n                    return !forPattern || this.CurrentToken.Kind switch\n                    {\n                        SyntaxKind.PlusToken => true,\n                        SyntaxKind.MinusToken => true,\n                        SyntaxKind.AmpersandToken => true,\n                        SyntaxKind.AsteriskToken => true,\n                        SyntaxKind.DotDotToken => true,\n                        _ => CanFollowCast(this.CurrentToken.Kind)\n                    };\n\n                case ScanTypeFlags.GenericTypeOrMethod:\n                case ScanTypeFlags.GenericTypeOrExpression:\n                case ScanTypeFlags.NonGenericTypeOrExpression:\n                case ScanTypeFlags.TupleType:\n                    // check for ambiguous type or expression followed by disambiguating token.  i.e.\n                    //\n                    // '(A)b' is a cast.  But '(A)+b' is not a cast.  \n                    return CanFollowCast(this.CurrentToken.Kind);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(type);\n            } 150015"];
5931 [label="this.CurrentToken 150016"];
5932 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150017"];
5933 [label="return _lexedTokens[_tokenOffset]; 150018"];
5934 [label="return CanFollowCast(this.CurrentToken.Kind); 150019"];
5935 [label="this.CurrentToken.Kind 150020"];
5936 [label="get { return (SyntaxKind)this.RawKind; } 150021"];
5937 [label="CanFollowCast(this.CurrentToken.Kind) 150022"];
5938 [label="param CanFollowCast(SyntaxKind kind) 150023"];
5939 [label="switch (kind)\n            {\n                case SyntaxKind.AsKeyword:\n                case SyntaxKind.IsKeyword:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.EqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.QuestionToken:\n                case SyntaxKind.ColonToken:\n                case SyntaxKind.BarBarToken:\n                case SyntaxKind.AmpersandAmpersandToken:\n                case SyntaxKind.BarToken:\n                case SyntaxKind.CaretToken:\n                case SyntaxKind.AmpersandToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.LessThanLessThanToken:\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                case SyntaxKind.PlusToken:\n                case SyntaxKind.MinusToken:\n                case SyntaxKind.AsteriskToken:\n                case SyntaxKind.SlashToken:\n                case SyntaxKind.PercentToken:\n                case SyntaxKind.PlusPlusToken:\n                case SyntaxKind.MinusMinusToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.DotToken:\n                case SyntaxKind.MinusGreaterThanToken:\n                case SyntaxKind.QuestionQuestionToken:\n                case SyntaxKind.EndOfFileToken:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.EqualsGreaterThanToken:\n                case SyntaxKind.DotDotToken:\n                    return false;\n                default:\n                    return true;\n            } 150024"];
5940 [label="return false; 150025"];
5941 [label="this.Reset(ref resetPoint); 150026"];
5942 [label="this.Reset(ref resetPoint) 150027"];
5943 [label="param Reset(ref ResetPoint state) 150028"];
5944 [label="param Reset(this) 150029"];
5945 [label="_termState 150030"];
5946 [label="_isInTry 150031"];
5947 [label="_syntaxFactoryContext.IsInAsync 150032"];
5948 [label="_syntaxFactoryContext.QueryDepth 150033"];
5949 [label="base.Reset(ref state.BaseResetPoint); 150034"];
5950 [label="base.Reset(ref state.BaseResetPoint) 150035"];
5951 [label="param Reset(ref ResetPoint point) 150036"];
5952 [label="param Reset(this) 150037"];
5953 [label="var offset = point.Position - _firstToken; 150038"];
5954 [label="Debug.Assert(offset >= 0); 150039"];
5955 [label="Debug.Assert(offset >= 0); 150040"];
5956 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 150041"];
5957 [label="_mode 150042"];
5958 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 150043"];
5959 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 150044"];
5960 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 150045"];
5961 [label="_tokenOffset 150046"];
5962 [label="_currentToken = null; 150047"];
5963 [label="_currentToken 150048"];
5964 [label="_currentNode = default(BlendedNode); 150049"];
5965 [label="_currentNode 150050"];
5966 [label="_prevTokenTrailingTrivia 150051"];
5967 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 150052"];
5968 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 150053"];
5969 [label="base.Reset(ref state.BaseResetPoint); 150054"];
5970 [label="this.Reset(ref resetPoint); 150055"];
5971 [label="if (this.ScanExplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 150056"];
5972 [label="this.ScanExplicitlyTypedLambda(precedence) 150057"];
5973 [label="param ScanExplicitlyTypedLambda(Precedence precedence) 150058"];
5974 [label="param ScanExplicitlyTypedLambda(this) 150059"];
5975 [label="if (!(precedence <= Precedence.Lambda))\n            {\n                return false;\n            } 150060"];
5976 [label="this.GetResetPoint() 150061"];
5977 [label="param GetResetPoint(this) 150062"];
5978 [label="_firstToken + _tokenOffset 150063"];
5979 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 150064"];
5980 [label="_resetCount 150065"];
5981 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 150066"];
5982 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 150067"];
5983 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 150068"];
5984 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 150069"];
5985 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 150070"];
5986 [label="param ResetPoint(this) 150071"];
5987 [label="var resetPoint = this.GetResetPoint(); 150072"];
5988 [label="bool foundParameterModifier = false; 150073"];
5989 [label="while (true)\n                {\n                    // Advance past the open paren or comma.\n                    this.EatToken();\n\n                    // Eat 'out' or 'ref' for cases [3, 6]. Even though not allowed in a lambda,\n                    // we treat `params` similarly for better error recovery.\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.RefKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                            {\n                                this.EatToken();\n                            }\n                            break;\n                        case SyntaxKind.OutKeyword:\n                        case SyntaxKind.InKeyword:\n                        case SyntaxKind.ParamsKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            break;\n                    }\n\n                    if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        return foundParameterModifier;\n                    }\n\n                    // NOTE: advances CurrentToken\n                    if (this.ScanType() == ScanTypeFlags.NotType)\n                    {\n                        return false;\n                    }\n\n                    if (this.IsTrueIdentifier())\n                    {\n                        // eat the identifier\n                        this.EatToken();\n                    }\n\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.EndOfFileToken:\n                            return foundParameterModifier;\n\n                        case SyntaxKind.CommaToken:\n                            if (foundParameterModifier)\n                            {\n                                return true;\n                            }\n\n                            continue;\n\n                        case SyntaxKind.CloseParenToken:\n                            return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken;\n\n                        default:\n                            return false;\n                    }\n                } 150074"];
5990 [label="this.EatToken() 150075"];
5991 [label="param EatToken(this) 150076"];
5992 [label="this.CurrentToken 150077"];
5993 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150078"];
5994 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150079"];
5995 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 150080"];
5996 [label="MoveToNextToken() 150081"];
5997 [label="param MoveToNextToken(this) 150082"];
5998 [label="param GetTrailingTrivia(this) 150083"];
5999 [label="return null; 150084"];
6000 [label="_prevTokenTrailingTrivia 150085"];
6001 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 150086"];
6002 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 150087"];
6003 [label="_tokenOffset 150088"];
6004 [label="MoveToNextToken(); 150089"];
6005 [label="this.EatToken(); 150090"];
6006 [label="this.CurrentToken 150091"];
6007 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150092"];
6008 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150093"];
6009 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 150094"];
6010 [label="return _lexedTokens[_tokenOffset]; 150095"];
6011 [label="switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.RefKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                            {\n                                this.EatToken();\n                            }\n                            break;\n                        case SyntaxKind.OutKeyword:\n                        case SyntaxKind.InKeyword:\n                        case SyntaxKind.ParamsKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            break;\n                    } 150096"];
6012 [label="this.CurrentToken.Kind 150097"];
6013 [label="get { return (SyntaxKind)this.RawKind; } 150098"];
6014 [label="this.CurrentToken 150099"];
6015 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150100"];
6016 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 150101"];
6017 [label="if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        return foundParameterModifier;\n                    } 150102"];
6018 [label="this.CurrentToken.Kind 150103"];
6019 [label="get { return (SyntaxKind)this.RawKind; } 150104"];
6020 [label="if (this.ScanType() == ScanTypeFlags.NotType)\n                    {\n                        return false;\n                    } 150105"];
6021 [label="this.ScanType() 150106"];
6022 [label="param ScanType(bool forPattern = false) 150107"];
6023 [label="param ScanType(this) 150108"];
6024 [label="return ScanType(out _, forPattern); 150109"];
6025 [label="return ScanType(out _, forPattern); 150110"];
6026 [label="ScanType(out _, forPattern) 150111"];
6027 [label="param ScanType(out SyntaxToken lastTokenOfType) 150112"];
6028 [label="param ScanType(bool forPattern = false) 150113"];
6029 [label="param ScanType(this) 150114"];
6030 [label="forPattern 150115"];
6031 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 150116"];
6032 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 150117"];
6033 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 150118"];
6034 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 150119"];
6035 [label="Debug.Assert(n >= 0); 150120"];
6036 [label="Debug.Assert(n >= 0); 150121"];
6037 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150122"];
6038 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 150123"];
6039 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 150124"];
6040 [label="this.CurrentToken 150125"];
6041 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150126"];
6042 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 150127"];
6043 [label="this.CurrentToken.Kind 150128"];
6044 [label="get { return (SyntaxKind)this.RawKind; } 150129"];
6045 [label="this.IsTrueIdentifier() 150130"];
6046 [label="param IsTrueIdentifier(this) 150131"];
6047 [label="this.CurrentToken 150132"];
6048 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150133"];
6049 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 150134"];
6050 [label="this.CurrentToken.Kind 150135"];
6051 [label="get { return (SyntaxKind)this.RawKind; } 150136"];
6052 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 150137"];
6053 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 150138"];
6054 [label="this.CurrentToken 150139"];
6055 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150140"];
6056 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 150141"];
6057 [label="this.CurrentToken.ContextualKind 150142"];
6058 [label="get\n            {\n                return this.Kind;\n            } 150143"];
6059 [label="return false; 150144"];
6060 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 150145"];
6061 [label="IsCurrentTokenQueryKeywordInQuery() 150146"];
6062 [label="param IsCurrentTokenQueryKeywordInQuery(this) 150147"];
6063 [label="this.IsInQuery 150148"];
6064 [label="get { return _syntaxFactoryContext.IsInQuery; } 150149"];
6065 [label="return _syntaxFactoryContext.IsInQuery; 150150"];
6066 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 150151"];
6067 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 150152"];
6068 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 150153"];
6069 [label="IsCurrentTokenWhereOfConstraintClause() 150154"];
6070 [label="param IsCurrentTokenWhereOfConstraintClause(this) 150155"];
6071 [label="this.CurrentToken 150156"];
6072 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150157"];
6073 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 150158"];
6074 [label="this.CurrentToken.ContextualKind 150159"];
6075 [label="get\n            {\n                return this.Kind;\n            } 150160"];
6076 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 150161"];
6077 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 150162"];
6078 [label="return true; 150163"];
6079 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 150164"];
6080 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 150165"];
6081 [label="this.EatToken() 150166"];
6082 [label="this.CurrentToken 150167"];
6083 [label="MoveToNextToken() 150168"];
6084 [label="param GetTrailingTrivia(this) 150169"];
6085 [label="return null; 150170"];
6086 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 150171"];
6087 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 150172"];
6088 [label="MoveToNextToken(); 150173"];
6089 [label="this.CurrentToken 150174"];
6090 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150175"];
6091 [label="this.CurrentToken.Kind 150176"];
6092 [label="this.CurrentToken 150177"];
6093 [label="this.CurrentToken.Kind 150178"];
6094 [label="this.CurrentToken 150179"];
6095 [label="this.CurrentToken.Kind 150180"];
6096 [label="param IsMakingProgress(bool assertIfFalse = true) 150181"];
6097 [label="CurrentTokenPosition 150182"];
6098 [label="this.IsTrueIdentifier() 150183"];
6099 [label="param IsTrueIdentifier(this) 150184"];
6100 [label="this.CurrentToken 150185"];
6101 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150186"];
6102 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 150187"];
6103 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 150188"];
6104 [label="this.CurrentToken.Kind 150189"];
6105 [label="get { return (SyntaxKind)this.RawKind; } 150190"];
6106 [label="return false; 150191"];
6107 [label="if (this.IsTrueIdentifier())\n                    {\n                        // eat the identifier\n                        this.EatToken();\n                    } 150192"];
6108 [label="this.CurrentToken 150193"];
6109 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150194"];
6110 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 150195"];
6111 [label="switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.EndOfFileToken:\n                            return foundParameterModifier;\n\n                        case SyntaxKind.CommaToken:\n                            if (foundParameterModifier)\n                            {\n                                return true;\n                            }\n\n                            continue;\n\n                        case SyntaxKind.CloseParenToken:\n                            return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken;\n\n                        default:\n                            return false;\n                    } 150196"];
6112 [label="this.CurrentToken.Kind 150197"];
6113 [label="get { return (SyntaxKind)this.RawKind; } 150198"];
6114 [label="return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken; 150199"];
6115 [label="this.PeekToken(1) 150200"];
6116 [label="param PeekToken(int n) 150201"];
6117 [label="Debug.Assert(n >= 0); 150202"];
6118 [label="Debug.Assert(n >= 0); 150203"];
6119 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150204"];
6120 [label="this.PeekToken(1).Kind 150205"];
6121 [label="get { return (SyntaxKind)this.RawKind; } 150206"];
6122 [label="this.Reset(ref resetPoint); 150207"];
6123 [label="this.Reset(ref resetPoint) 150208"];
6124 [label="param Reset(ref ResetPoint state) 150209"];
6125 [label="Debug.Assert(offset >= 0); 150210"];
6126 [label="Debug.Assert(offset >= 0); 150211"];
6127 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 150212"];
6128 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 150213"];
6129 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 150214"];
6130 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 150215"];
6131 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 150216"];
6132 [label="this.Reset(ref resetPoint); 150217"];
6133 [label="this.Release(ref resetPoint); 150218"];
6134 [label="this.Release(ref resetPoint) 150219"];
6135 [label="param Release(ref ResetPoint state) 150220"];
6136 [label="param Release(this) 150221"];
6137 [label="base.Release(ref state.BaseResetPoint); 150222"];
6138 [label="base.Release(ref state.BaseResetPoint) 150223"];
6139 [label="param Release(ref ResetPoint point) 150224"];
6140 [label="param Release(this) 150225"];
6141 [label="Debug.Assert(_resetCount == point.ResetCount); 150226"];
6142 [label="_resetCount 150227"];
6143 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 150228"];
6144 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 150229"];
6145 [label="base.Release(ref state.BaseResetPoint); 150230"];
6146 [label="this.Release(ref resetPoint); 150231"];
6147 [label="if (this.ScanExplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 150232"];
6148 [label="this.Reset(ref resetPoint); 150233"];
6149 [label="this.Reset(ref resetPoint) 150234"];
6150 [label="param Reset(ref ResetPoint state) 150235"];
6151 [label="param Reset(this) 150236"];
6152 [label="_termState 150237"];
6153 [label="_isInTry 150238"];
6154 [label="_syntaxFactoryContext.IsInAsync 150239"];
6155 [label="_syntaxFactoryContext.QueryDepth 150240"];
6156 [label="base.Reset(ref state.BaseResetPoint); 150241"];
6157 [label="base.Reset(ref state.BaseResetPoint) 150242"];
6158 [label="param Reset(this) 150243"];
6159 [label="var offset = point.Position - _firstToken; 150244"];
6160 [label="Debug.Assert(offset >= 0); 150245"];
6161 [label="Debug.Assert(offset >= 0); 150246"];
6162 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 150247"];
6163 [label="_mode 150248"];
6164 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 150249"];
6165 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 150250"];
6166 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 150251"];
6167 [label="_currentToken = null; 150252"];
6168 [label="_currentToken 150253"];
6169 [label="_currentNode = default(BlendedNode); 150254"];
6170 [label="_currentNode 150255"];
6171 [label="_prevTokenTrailingTrivia 150256"];
6172 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 150257"];
6173 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 150258"];
6174 [label="base.Reset(ref state.BaseResetPoint); 150259"];
6175 [label="this.Reset(ref resetPoint); 150260"];
6176 [label="var openParen = this.EatToken(SyntaxKind.OpenParenToken); 150261"];
6177 [label="this.EatToken(SyntaxKind.OpenParenToken) 150262"];
6178 [label="param EatToken(SyntaxKind kind) 150263"];
6179 [label="param EatToken(this) 150264"];
6180 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 150265"];
6181 [label="SyntaxFacts.IsAnyToken(kind) 150266"];
6182 [label="param IsAnyToken(SyntaxKind kind) 150267"];
6183 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 150268"];
6184 [label="return true; 150269"];
6185 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150270"];
6186 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 150271"];
6187 [label="return _lexedTokens[_tokenOffset]; 150272"];
6188 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 150273"];
6189 [label="param GetTrailingTrivia(this) 150274"];
6190 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 150275"];
6191 [label="MoveToNextToken(); 150276"];
6192 [label="return ct; 150277"];
6193 [label="var expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true); 150278"];
6194 [label="var expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true); 150279"];
6195 [label="this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true) 150280"];
6196 [label="param ParseExpressionOrDeclaration(ParseTypeMode mode) 150281"];
6197 [label="param ParseExpressionOrDeclaration(MessageID feature) 150282"];
6198 [label="param ParseExpressionOrDeclaration(bool permitTupleDesignation) 150283"];
6199 [label="param ParseExpressionOrDeclaration(this) 150284"];
6200 [label="return IsPossibleDeclarationExpression(mode, permitTupleDesignation)\n                ? this.ParseDeclarationExpression(mode, feature)\n                : this.ParseSubExpression(Precedence.Expression); 150285"];
6201 [label="return IsPossibleDeclarationExpression(mode, permitTupleDesignation)\n                ? this.ParseDeclarationExpression(mode, feature)\n                : this.ParseSubExpression(Precedence.Expression); 150286"];
6202 [label="IsPossibleDeclarationExpression(mode, permitTupleDesignation) 150287"];
6203 [label="param IsPossibleDeclarationExpression(ParseTypeMode mode) 150288"];
6204 [label="param IsPossibleDeclarationExpression(bool permitTupleDesignation) 150289"];
6205 [label="param IsPossibleDeclarationExpression(this) 150290"];
6206 [label="this.IsInAsync 150291"];
6207 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 150292"];
6208 [label="return _syntaxFactoryContext.IsInAsync; 150293"];
6209 [label="if (this.IsInAsync && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                // can't be a declaration expression.\n                return false;\n            } 150294"];
6210 [label="this.GetResetPoint() 150295"];
6211 [label="param GetResetPoint(this) 150296"];
6212 [label="_firstToken + _tokenOffset 150297"];
6213 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 150298"];
6214 [label="_resetCount 150299"];
6215 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 150300"];
6216 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 150301"];
6217 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 150302"];
6218 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 150303"];
6219 [label="param ResetPoint(this) 150304"];
6220 [label="var resetPoint = this.GetResetPoint(); 150305"];
6221 [label="IsVarType() 150306"];
6222 [label="param IsVarType(this) 150307"];
6223 [label="this.CurrentToken 150308"];
6224 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150309"];
6225 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150310"];
6226 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 150311"];
6227 [label="if (!this.CurrentToken.IsIdentifierVar())\n            {\n                return false;\n            } 150312"];
6228 [label="this.CurrentToken.IsIdentifierVar() 150313"];
6229 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 150314"];
6230 [label="return false; 150315"];
6231 [label="bool typeIsVar = IsVarType(); 150316"];
6232 [label="SyntaxToken lastTokenOfType; 150317"];
6233 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 150318"];
6234 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 150319"];
6235 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 150320"];
6236 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 150321"];
6237 [label="Debug.Assert(n >= 0); 150322"];
6238 [label="Debug.Assert(n >= 0); 150323"];
6239 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150324"];
6240 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 150325"];
6241 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 150326"];
6242 [label="this.CurrentToken 150327"];
6243 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150328"];
6244 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 150329"];
6245 [label="this.CurrentToken.Kind 150330"];
6246 [label="get { return (SyntaxKind)this.RawKind; } 150331"];
6247 [label="this.IsTrueIdentifier() 150332"];
6248 [label="param IsTrueIdentifier(this) 150333"];
6249 [label="this.CurrentToken 150334"];
6250 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150335"];
6251 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 150336"];
6252 [label="this.CurrentToken.Kind 150337"];
6253 [label="get { return (SyntaxKind)this.RawKind; } 150338"];
6254 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 150339"];
6255 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 150340"];
6256 [label="this.CurrentToken 150341"];
6257 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150342"];
6258 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 150343"];
6259 [label="this.CurrentToken.ContextualKind 150344"];
6260 [label="get\n            {\n                return this.Kind;\n            } 150345"];
6261 [label="return false; 150346"];
6262 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 150347"];
6263 [label="IsCurrentTokenQueryKeywordInQuery() 150348"];
6264 [label="param IsCurrentTokenQueryKeywordInQuery(this) 150349"];
6265 [label="this.IsInQuery 150350"];
6266 [label="get { return _syntaxFactoryContext.IsInQuery; } 150351"];
6267 [label="return _syntaxFactoryContext.IsInQuery; 150352"];
6268 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 150353"];
6269 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 150354"];
6270 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 150355"];
6271 [label="IsCurrentTokenWhereOfConstraintClause() 150356"];
6272 [label="param IsCurrentTokenWhereOfConstraintClause(this) 150357"];
6273 [label="this.CurrentToken 150358"];
6274 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150359"];
6275 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 150360"];
6276 [label="this.CurrentToken.ContextualKind 150361"];
6277 [label="get\n            {\n                return this.Kind;\n            } 150362"];
6278 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 150363"];
6279 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 150364"];
6280 [label="return true; 150365"];
6281 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 150366"];
6282 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 150367"];
6283 [label="this.EatToken() 150368"];
6284 [label="this.CurrentToken 150369"];
6285 [label="MoveToNextToken() 150370"];
6286 [label="param GetTrailingTrivia(this) 150371"];
6287 [label="return null; 150372"];
6288 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 150373"];
6289 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 150374"];
6290 [label="MoveToNextToken(); 150375"];
6291 [label="this.CurrentToken 150376"];
6292 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150377"];
6293 [label="this.CurrentToken.Kind 150378"];
6294 [label="this.CurrentToken 150379"];
6295 [label="this.CurrentToken.Kind 150380"];
6296 [label="this.CurrentToken 150381"];
6297 [label="this.CurrentToken.Kind 150382"];
6298 [label="param IsMakingProgress(bool assertIfFalse = true) 150383"];
6299 [label="CurrentTokenPosition 150384"];
6300 [label="lastTokenOfType.Kind 150385"];
6301 [label="get { return (SyntaxKind)this.RawKind; } 150386"];
6302 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 150387"];
6303 [label="IsPredefinedType(lastTokenOfType.Kind) 150388"];
6304 [label="param IsPredefinedType(SyntaxKind keyword) 150389"];
6305 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 150390"];
6306 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 150391"];
6307 [label="ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))) 150392"];
6308 [label="param ScanDesignation(bool permitTuple) 150393"];
6309 [label="param ScanDesignation(this) 150394"];
6310 [label="this.CurrentToken 150395"];
6311 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150396"];
6312 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 150397"];
6313 [label="switch (this.CurrentToken.Kind)\n            {\n                default:\n                    return false;\n                case SyntaxKind.IdentifierToken:\n                    bool result = this.IsTrueIdentifier();\n                    this.EatToken();\n                    return result;\n                case SyntaxKind.OpenParenToken:\n                    if (!permitTuple)\n                    {\n                        return false;\n                    }\n\n                    bool sawComma = false;\n                    while (true)\n                    {\n                        this.EatToken(); // consume the `(` or `,`\n                        if (!ScanDesignation(permitTuple: true))\n                        {\n                            return false;\n                        }\n                        switch (this.CurrentToken.Kind)\n                        {\n                            case SyntaxKind.CloseParenToken:\n                                this.EatToken();\n                                return sawComma;\n                            case SyntaxKind.CommaToken:\n                                sawComma = true;\n                                continue;\n                            default:\n                                return false;\n                        }\n                    }\n            } 150398"];
6314 [label="this.CurrentToken.Kind 150399"];
6315 [label="get { return (SyntaxKind)this.RawKind; } 150400"];
6316 [label="return false; 150401"];
6317 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 150402"];
6318 [label="return false; 150403"];
6319 [label="this.Reset(ref resetPoint); 150404"];
6320 [label="this.Reset(ref resetPoint) 150405"];
6321 [label="param Reset(ref ResetPoint state) 150406"];
6322 [label="Debug.Assert(offset >= 0); 150407"];
6323 [label="Debug.Assert(offset >= 0); 150408"];
6324 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 150409"];
6325 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 150410"];
6326 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 150411"];
6327 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 150412"];
6328 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 150413"];
6329 [label="this.Reset(ref resetPoint); 150414"];
6330 [label="this.Release(ref resetPoint); 150415"];
6331 [label="this.Release(ref resetPoint) 150416"];
6332 [label="param Release(ref ResetPoint state) 150417"];
6333 [label="base.Release(ref state.BaseResetPoint); 150418"];
6334 [label="param Release(ref ResetPoint point) 150419"];
6335 [label="Debug.Assert(_resetCount == point.ResetCount); 150420"];
6336 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 150421"];
6337 [label="base.Release(ref state.BaseResetPoint); 150422"];
6338 [label="this.Release(ref resetPoint); 150423"];
6339 [label="this.ParseSubExpression(Precedence.Expression) 150424"];
6340 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 150425"];
6341 [label="ExpressionSyntax leftOperand; 150426"];
6342 [label="Precedence newPrecedence = 0; 150427"];
6343 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150428"];
6344 [label="return _lexedTokens[_tokenOffset]; 150429"];
6345 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 150430"];
6346 [label="IsInvalidSubExpression(tk) 150431"];
6347 [label="param IsInvalidSubExpression(SyntaxKind kind) 150432"];
6348 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 150433"];
6349 [label="return false; 150434"];
6350 [label="param IsAwaitExpression(this) 150435"];
6351 [label="this.CurrentToken 150436"];
6352 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150437"];
6353 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 150438"];
6354 [label="this.CurrentToken.ContextualKind 150439"];
6355 [label="get\n            {\n                return this.Kind;\n            } 150440"];
6356 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 150441"];
6357 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 150442"];
6358 [label="param IsQueryExpression(this) 150443"];
6359 [label="this.CurrentToken 150444"];
6360 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150445"];
6361 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 150446"];
6362 [label="this.CurrentToken.ContextualKind 150447"];
6363 [label="get\n            {\n                return this.Kind;\n            } 150448"];
6364 [label="leftOperand = this.ParseTerm(precedence); 150449"];
6365 [label="param ParseTerm(Precedence precedence) 150450"];
6366 [label="precedence 150451"];
6367 [label="param ParseTermWithoutPostfix(Precedence precedence) 150452"];
6368 [label="this.IsTrueIdentifier() 150453"];
6369 [label="param IsTrueIdentifier(this) 150454"];
6370 [label="this.CurrentToken 150455"];
6371 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150456"];
6372 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 150457"];
6373 [label="this.CurrentToken.Kind 150458"];
6374 [label="get { return (SyntaxKind)this.RawKind; } 150459"];
6375 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 150460"];
6376 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 150461"];
6377 [label="this.CurrentToken 150462"];
6378 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150463"];
6379 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 150464"];
6380 [label="this.CurrentToken.ContextualKind 150465"];
6381 [label="get\n            {\n                return this.Kind;\n            } 150466"];
6382 [label="return false; 150467"];
6383 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 150468"];
6384 [label="IsCurrentTokenQueryKeywordInQuery() 150469"];
6385 [label="param IsCurrentTokenQueryKeywordInQuery(this) 150470"];
6386 [label="this.IsInQuery 150471"];
6387 [label="get { return _syntaxFactoryContext.IsInQuery; } 150472"];
6388 [label="return _syntaxFactoryContext.IsInQuery; 150473"];
6389 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 150474"];
6390 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 150475"];
6391 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 150476"];
6392 [label="IsCurrentTokenWhereOfConstraintClause() 150477"];
6393 [label="param IsCurrentTokenWhereOfConstraintClause(this) 150478"];
6394 [label="this.CurrentToken 150479"];
6395 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150480"];
6396 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 150481"];
6397 [label="this.CurrentToken.ContextualKind 150482"];
6398 [label="get\n            {\n                return this.Kind;\n            } 150483"];
6399 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 150484"];
6400 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 150485"];
6401 [label="return true; 150486"];
6402 [label="if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    } 150487"];
6403 [label="this.IsPossibleAnonymousMethodExpression() 150488"];
6404 [label="param IsPossibleAnonymousMethodExpression(this) 150489"];
6405 [label="var tokenIndex = 0; 150490"];
6406 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 150491"];
6407 [label="this.PeekToken(tokenIndex) 150492"];
6408 [label="param PeekToken(int n) 150493"];
6409 [label="param PeekToken(this) 150494"];
6410 [label="Debug.Assert(n >= 0); 150495"];
6411 [label="Debug.Assert(n >= 0); 150496"];
6412 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150497"];
6413 [label="return _lexedTokens[_tokenOffset + n]; 150498"];
6414 [label="this.PeekToken(tokenIndex).Kind 150499"];
6415 [label="get { return (SyntaxKind)this.RawKind; } 150500"];
6416 [label="this.PeekToken(tokenIndex) 150501"];
6417 [label="param PeekToken(int n) 150502"];
6418 [label="param PeekToken(this) 150503"];
6419 [label="Debug.Assert(n >= 0); 150504"];
6420 [label="Debug.Assert(n >= 0); 150505"];
6421 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150506"];
6422 [label="return _lexedTokens[_tokenOffset + n]; 150507"];
6423 [label="this.PeekToken(tokenIndex).ContextualKind 150508"];
6424 [label="get\n            {\n                return this.Kind;\n            } 150509"];
6425 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 150510"];
6426 [label="return this.PeekToken(tokenIndex).Kind == SyntaxKind.DelegateKeyword; 150511"];
6427 [label="this.PeekToken(tokenIndex) 150512"];
6428 [label="param PeekToken(int n) 150513"];
6429 [label="param PeekToken(this) 150514"];
6430 [label="Debug.Assert(n >= 0); 150515"];
6431 [label="Debug.Assert(n >= 0); 150516"];
6432 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150517"];
6433 [label="return _lexedTokens[_tokenOffset + n]; 150518"];
6434 [label="this.PeekToken(tokenIndex).Kind 150519"];
6435 [label="get { return (SyntaxKind)this.RawKind; } 150520"];
6436 [label="if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 150521"];
6437 [label="if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 150522"];
6438 [label="this.IsPossibleLambdaExpression(precedence) 150523"];
6439 [label="param IsPossibleLambdaExpression(Precedence precedence) 150524"];
6440 [label="param IsPossibleLambdaExpression(this) 150525"];
6441 [label="this.CurrentToken 150526"];
6442 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150527"];
6443 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 150528"];
6444 [label="this.CurrentToken.Kind 150529"];
6445 [label="get { return (SyntaxKind)this.RawKind; } 150530"];
6446 [label="this.CurrentToken 150531"];
6447 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150532"];
6448 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 150533"];
6449 [label="this.IsTrueIdentifier(this.CurrentToken) 150534"];
6450 [label="param IsTrueIdentifier(SyntaxToken token) 150535"];
6451 [label="param IsTrueIdentifier(this) 150536"];
6452 [label="token.Kind 150537"];
6453 [label="get { return (SyntaxKind)this.RawKind; } 150538"];
6454 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 150539"];
6455 [label="this.IsInQuery 150540"];
6456 [label="get { return _syntaxFactoryContext.IsInQuery; } 150541"];
6457 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 150542"];
6458 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 150543"];
6459 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 150544"];
6460 [label="if (precedence > Precedence.Lambda)\n            {\n                return false;\n            } 150545"];
6461 [label="int peekIndex; 150546"];
6462 [label="bool seenStatic; 150547"];
6463 [label="this.CurrentToken 150548"];
6464 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150549"];
6465 [label="if (this.CurrentToken.Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 1;\n                seenStatic = true;\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 2;\n                seenStatic = true;\n            }\n            else\n            {\n                peekIndex = 0;\n                seenStatic = false;\n            } 150550"];
6466 [label="this.CurrentToken.Kind 150551"];
6467 [label="get { return (SyntaxKind)this.RawKind; } 150552"];
6468 [label="this.CurrentToken 150553"];
6469 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 2;\n                seenStatic = true;\n            }\n            else\n            {\n                peekIndex = 0;\n                seenStatic = false;\n            } 150554"];
6470 [label="this.CurrentToken.ContextualKind 150555"];
6471 [label="get\n            {\n                return this.Kind;\n            } 150556"];
6472 [label="peekIndex = 0; 150557"];
6473 [label="seenStatic = false; 150558"];
6474 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on => then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static =>`\n                // 2. `async static =>`\n\n                // This is an error case, but we have enough code in front of us to be certain\n                // the user was trying to write a static lambda.\n                return true;\n            } 150559"];
6475 [label="this.PeekToken(peekIndex) 150560"];
6476 [label="param PeekToken(int n) 150561"];
6477 [label="param PeekToken(this) 150562"];
6478 [label="Debug.Assert(n >= 0); 150563"];
6479 [label="Debug.Assert(n >= 0); 150564"];
6480 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150565"];
6481 [label="this.PeekToken(peekIndex).Kind 150566"];
6482 [label="get { return (SyntaxKind)this.RawKind; } 150567"];
6483 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 150568"];
6484 [label="this.PeekToken(peekIndex) 150569"];
6485 [label="param PeekToken(int n) 150570"];
6486 [label="param PeekToken(this) 150571"];
6487 [label="Debug.Assert(n >= 0); 150572"];
6488 [label="Debug.Assert(n >= 0); 150573"];
6489 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150574"];
6490 [label="this.PeekToken(peekIndex).Kind 150575"];
6491 [label="get { return (SyntaxKind)this.RawKind; } 150576"];
6492 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 150577"];
6493 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 150578"];
6494 [label="this.PeekToken(peekIndex + 1) 150579"];
6495 [label="param PeekToken(int n) 150580"];
6496 [label="param PeekToken(this) 150581"];
6497 [label="Debug.Assert(n >= 0); 150582"];
6498 [label="Debug.Assert(n >= 0); 150583"];
6499 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150584"];
6500 [label="this.PeekToken(peekIndex + 1).Kind 150585"];
6501 [label="get { return (SyntaxKind)this.RawKind; } 150586"];
6502 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 150587"];
6503 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.OpenParenToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on ( then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static (...\n                // 2. `async static (...\n                return true;\n            } 150588"];
6504 [label="this.PeekToken(peekIndex) 150589"];
6505 [label="param PeekToken(int n) 150590"];
6506 [label="param PeekToken(this) 150591"];
6507 [label="Debug.Assert(n >= 0); 150592"];
6508 [label="Debug.Assert(n >= 0); 150593"];
6509 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150594"];
6510 [label="this.PeekToken(peekIndex).Kind 150595"];
6511 [label="get { return (SyntaxKind)this.RawKind; } 150596"];
6512 [label="if (this.PeekToken(peekIndex).ContextualKind != SyntaxKind.AsyncKeyword)\n            {\n                return false;\n            } 150597"];
6513 [label="this.PeekToken(peekIndex) 150598"];
6514 [label="param PeekToken(int n) 150599"];
6515 [label="param PeekToken(this) 150600"];
6516 [label="Debug.Assert(n >= 0); 150601"];
6517 [label="Debug.Assert(n >= 0); 150602"];
6518 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150603"];
6519 [label="this.PeekToken(peekIndex).ContextualKind 150604"];
6520 [label="get\n            {\n                return this.Kind;\n            } 150605"];
6521 [label="return false; 150606"];
6522 [label="if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 150607"];
6523 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 150608"];
6524 [label="this.IsPossibleDeconstructionLeft(precedence) 150609"];
6525 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 150610"];
6526 [label="return this.ParseAliasQualifiedName(NameOptions.InExpression); 150611"];
6527 [label="this.ParseAliasQualifiedName(NameOptions.InExpression) 150612"];
6528 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 150613"];
6529 [label="param ParseAliasQualifiedName(this) 150614"];
6530 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 150615"];
6531 [label="this.ParseSimpleName(allowedParts) 150616"];
6532 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 150617"];
6533 [label="param ParseSimpleName(this) 150618"];
6534 [label="var id = this.ParseIdentifierName(); 150619"];
6535 [label="this.ParseIdentifierName() 150620"];
6536 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 150621"];
6537 [label="param ParseIdentifierName(this) 150622"];
6538 [label="this.IsIncrementalAndFactoryContextMatches 150623"];
6539 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 150624"];
6540 [label="base.IsIncremental 150625"];
6541 [label="get\n            {\n                return _isIncremental;\n            } 150626"];
6542 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 150627"];
6543 [label="return false; 150628"];
6544 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 150629"];
6545 [label="var tk = ParseIdentifierToken(code); 150630"];
6546 [label="ParseIdentifierToken(code) 150631"];
6547 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 150632"];
6548 [label="param ParseIdentifierToken(this) 150633"];
6549 [label="this.CurrentToken 150634"];
6550 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150635"];
6551 [label="var ctk = this.CurrentToken.Kind; 150636"];
6552 [label="this.CurrentToken.Kind 150637"];
6553 [label="get { return (SyntaxKind)this.RawKind; } 150638"];
6554 [label="if (ctk == SyntaxKind.IdentifierToken)\n            {\n                // Error tolerance for IntelliSense. Consider the following case: [EditorBrowsable( partial class Goo {\n                // } Because we're parsing an attribute argument we'll end up consuming the 'partial' identifier and\n                // we'll eventually end up in a pretty confused state.  Because of that it becomes very difficult to\n                // show the correct parameter help in this case.  So, when we see 'partial' we check if it's being used\n                // as an identifier or as a contextual keyword.  If it's the latter then we bail out.  See\n                // Bug: vswhidbey/542125\n                if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                }\n\n                SyntaxToken identifierToken = this.EatToken();\n\n                if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                }\n\n                return identifierToken;\n            }\n            else\n            {\n                var name = CreateMissingIdentifierToken();\n                name = this.AddError(name, code);\n                return name;\n            } 150639"];
6555 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 150640"];
6556 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 150641"];
6557 [label="this.CurrentToken 150642"];
6558 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150643"];
6559 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 150644"];
6560 [label="this.CurrentToken.ContextualKind 150645"];
6561 [label="get\n            {\n                return this.Kind;\n            } 150646"];
6562 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 150647"];
6563 [label="IsCurrentTokenQueryKeywordInQuery() 150648"];
6564 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 150649"];
6565 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 150650"];
6566 [label="this.EatToken() 150651"];
6567 [label="param GetTrailingTrivia(this) 150652"];
6568 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 150653"];
6569 [label="MoveToNextToken(); 150654"];
6570 [label="SyntaxToken identifierToken = this.EatToken(); 150655"];
6571 [label="this.IsInAsync 150656"];
6572 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 150657"];
6573 [label="return _syntaxFactoryContext.IsInAsync; 150658"];
6574 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 150659"];
6575 [label="return identifierToken; 150660"];
6576 [label="var tk = ParseIdentifierToken(code); 150661"];
6577 [label="return SyntaxFactory.IdentifierName(tk); 150662"];
6578 [label="return SyntaxFactory.IdentifierName(tk); 150663"];
6579 [label="param CSharpSyntaxNode(SyntaxKind kind) 150664"];
6580 [label="param CSharpSyntaxNode(this) 150665"];
6581 [label="kind 150666"];
6582 [label="param CSharpSyntaxNode(this) 150667"];
6583 [label="param CSharpSyntaxNode(this) 150668"];
6584 [label="GreenStats.NoteGreen(this); 150669"];
6585 [label="GreenStats.NoteGreen(this); 150670"];
6586 [label="var id = this.ParseIdentifierName(); 150671"];
6587 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 150672"];
6588 [label="SimpleNameSyntax name = id; 150673"];
6589 [label="this.CurrentToken 150674"];
6590 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150675"];
6591 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150676"];
6592 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 150677"];
6593 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 150678"];
6594 [label="this.CurrentToken.Kind 150679"];
6595 [label="get { return (SyntaxKind)this.RawKind; } 150680"];
6596 [label="return name; 150681"];
6597 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 150682"];
6598 [label="this.CurrentToken 150683"];
6599 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150684"];
6600 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 150685"];
6601 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 150686"];
6602 [label="this.CurrentToken.Kind 150687"];
6603 [label="get { return (SyntaxKind)this.RawKind; } 150688"];
6604 [label="return name; 150689"];
6605 [label="return this.ParseAliasQualifiedName(NameOptions.InExpression); 150690"];
6606 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 150691"];
6607 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 150692"];
6608 [label="return ParseExpressionContinued(leftOperand, precedence); 150693"];
6609 [label="return ParseExpressionContinued(leftOperand, precedence); 150694"];
6610 [label="ParseExpressionContinued(leftOperand, precedence) 150695"];
6611 [label="param ParseExpressionContinued(ExpressionSyntax leftOperand) 150696"];
6612 [label="param ParseExpressionContinued(Precedence precedence) 150697"];
6613 [label="param ParseExpressionContinued(this) 150698"];
6614 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 150699"];
6615 [label="this.CurrentToken 150700"];
6616 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150701"];
6617 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 150702"];
6618 [label="var tk = this.CurrentToken.ContextualKind; 150703"];
6619 [label="this.CurrentToken.ContextualKind 150704"];
6620 [label="get\n            {\n                return this.Kind;\n            } 150705"];
6621 [label="bool isAssignmentOperator = false; 150706"];
6622 [label="SyntaxKind opKind; 150707"];
6623 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 150708"];
6624 [label="IsExpectedBinaryOperator(tk) 150709"];
6625 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 150710"];
6626 [label="return SyntaxFacts.IsBinaryExpression(kind); 150711"];
6627 [label="SyntaxFacts.IsBinaryExpression(kind) 150712"];
6628 [label="param IsBinaryExpression(SyntaxKind token) 150713"];
6629 [label="return GetBinaryExpression(token) != SyntaxKind.None; 150714"];
6630 [label="GetBinaryExpression(token) 150715"];
6631 [label="param GetBinaryExpression(SyntaxKind token) 150716"];
6632 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 150717"];
6633 [label="return SyntaxKind.None; 150718"];
6634 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 150719"];
6635 [label="IsExpectedAssignmentOperator(tk) 150720"];
6636 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 150721"];
6637 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 150722"];
6638 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 150723"];
6639 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 150724"];
6640 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 150725"];
6641 [label="return false; 150726"];
6642 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 150727"];
6643 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 150728"];
6644 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 150729"];
6645 [label="CurrentToken 150730"];
6646 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150731"];
6647 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 150732"];
6648 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 150733"];
6649 [label="CurrentToken.Kind 150734"];
6650 [label="get { return (SyntaxKind)this.RawKind; } 150735"];
6651 [label="return leftOperand; 150736"];
6652 [label="_ = GetPrecedence(result.Kind); 150737"];
6653 [label="result.Kind 150738"];
6654 [label="get { return (SyntaxKind)this.RawKind; } 150739"];
6655 [label="_ = GetPrecedence(result.Kind); 150740"];
6656 [label="GetPrecedence(result.Kind) 150741"];
6657 [label="param GetPrecedence(SyntaxKind op) 150742"];
6658 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 150743"];
6659 [label="return Precedence.Primary; 150744"];
6660 [label="_recursionDepth 150745"];
6661 [label="return result; 150746"];
6662 [label="this.CurrentToken 150747"];
6663 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150748"];
6664 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 150749"];
6665 [label="if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        var firstArg = _syntaxFactory.Argument(nameColon: null, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 150750"];
6666 [label="this.CurrentToken.Kind 150751"];
6667 [label="get { return (SyntaxKind)this.RawKind; } 150752"];
6668 [label="expression.Kind 150753"];
6669 [label="get { return (SyntaxKind)this.RawKind; } 150754"];
6670 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 150755"];
6671 [label="this.CurrentToken 150756"];
6672 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150757"];
6673 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 150758"];
6674 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 150759"];
6675 [label="this.CurrentToken.Kind 150760"];
6676 [label="get { return (SyntaxKind)this.RawKind; } 150761"];
6677 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 150762"];
6678 [label="var closeParen = this.EatToken(SyntaxKind.CloseParenToken); 150763"];
6679 [label="this.EatToken(SyntaxKind.CloseParenToken) 150764"];
6680 [label="param EatToken(SyntaxKind kind) 150765"];
6681 [label="param EatToken(this) 150766"];
6682 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 150767"];
6683 [label="SyntaxFacts.IsAnyToken(kind) 150768"];
6684 [label="param IsAnyToken(SyntaxKind kind) 150769"];
6685 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 150770"];
6686 [label="return true; 150771"];
6687 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 150772"];
6688 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 150773"];
6689 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 150774"];
6690 [label="MoveToNextToken(); 150775"];
6691 [label="return ct; 150776"];
6692 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 150777"];
6693 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 150778"];
6694 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 150779"];
6695 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 150780"];
6696 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 150781"];
6697 [label="param TryGetNode(int kind) 150782"];
6698 [label="param TryGetNode(GreenNode child1) 150783"];
6699 [label="param TryGetNode(GreenNode child2) 150784"];
6700 [label="param TryGetNode(GreenNode child3) 150785"];
6701 [label="param TryGetNode(SyntaxFactoryContext context) 150786"];
6702 [label="param TryGetNode(out int hash) 150787"];
6703 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 150788"];
6704 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 150789"];
6705 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 150790"];
6706 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 150791"];
6707 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 150792"];
6708 [label="GetNodeFlags(context) 150793"];
6709 [label="param GetNodeFlags(SyntaxFactoryContext context) 150794"];
6710 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 150795"];
6711 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 150796"];
6712 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 150797"];
6713 [label="return flags; 150798"];
6714 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 150799"];
6715 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 150800"];
6716 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 150801"];
6717 [label="param CSharpSyntaxNode(this) 150802"];
6718 [label="GreenStats.NoteGreen(this); 150803"];
6719 [label="param SetFactoryContext(SyntaxFactoryContext context) 150804"];
6720 [label="param SetFactoryContext(this) 150805"];
6721 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 150806"];
6722 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 150807"];
6723 [label="this.Release(ref resetPoint); 150808"];
6724 [label="this.Release(ref resetPoint) 150809"];
6725 [label="param Release(ref ResetPoint state) 150810"];
6726 [label="param Release(this) 150811"];
6727 [label="base.Release(ref state.BaseResetPoint); 150812"];
6728 [label="base.Release(ref state.BaseResetPoint) 150813"];
6729 [label="param Release(ref ResetPoint point) 150814"];
6730 [label="param Release(this) 150815"];
6731 [label="Debug.Assert(_resetCount == point.ResetCount); 150816"];
6732 [label="_resetCount 150817"];
6733 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 150818"];
6734 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 150819"];
6735 [label="base.Release(ref state.BaseResetPoint); 150820"];
6736 [label="this.Release(ref resetPoint); 150821"];
6737 [label="return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence); 150822"];
6738 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 150823"];
6739 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 150824"];
6740 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150825"];
6741 [label="return ParseExpressionContinued(leftOperand, precedence); 150826"];
6742 [label="ParseExpressionContinued(leftOperand, precedence) 150827"];
6743 [label="param ParseExpressionContinued(Precedence precedence) 150828"];
6744 [label="param ParseExpressionContinued(this) 150829"];
6745 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 150830"];
6746 [label="this.CurrentToken 150831"];
6747 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150832"];
6748 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 150833"];
6749 [label="var tk = this.CurrentToken.ContextualKind; 150834"];
6750 [label="this.CurrentToken.ContextualKind 150835"];
6751 [label="get\n            {\n                return this.Kind;\n            } 150836"];
6752 [label="this.Kind 150837"];
6753 [label="bool isAssignmentOperator = false; 150838"];
6754 [label="SyntaxKind opKind; 150839"];
6755 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 150840"];
6756 [label="IsExpectedBinaryOperator(tk) 150841"];
6757 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 150842"];
6758 [label="return SyntaxFacts.IsBinaryExpression(kind); 150843"];
6759 [label="SyntaxFacts.IsBinaryExpression(kind) 150844"];
6760 [label="param IsBinaryExpression(SyntaxKind token) 150845"];
6761 [label="return GetBinaryExpression(token) != SyntaxKind.None; 150846"];
6762 [label="GetBinaryExpression(token) 150847"];
6763 [label="param GetBinaryExpression(SyntaxKind token) 150848"];
6764 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 150849"];
6765 [label="return SyntaxKind.None; 150850"];
6766 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 150851"];
6767 [label="IsExpectedAssignmentOperator(tk) 150852"];
6768 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 150853"];
6769 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 150854"];
6770 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 150855"];
6771 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 150856"];
6772 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 150857"];
6773 [label="return false; 150858"];
6774 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 150859"];
6775 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 150860"];
6776 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 150861"];
6777 [label="CurrentToken 150862"];
6778 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150863"];
6779 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 150864"];
6780 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 150865"];
6781 [label="CurrentToken.Kind 150866"];
6782 [label="get { return (SyntaxKind)this.RawKind; } 150867"];
6783 [label="_ = GetPrecedence(result.Kind); 150868"];
6784 [label="result.Kind 150869"];
6785 [label="get { return (SyntaxKind)this.RawKind; } 150870"];
6786 [label="_ = GetPrecedence(result.Kind); 150871"];
6787 [label="GetPrecedence(result.Kind) 150872"];
6788 [label="param GetPrecedence(SyntaxKind op) 150873"];
6789 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 150874"];
6790 [label="return Precedence.Primary; 150875"];
6791 [label="var expression = this.ParseExpressionCore(); 150876"];
6792 [label="SyntaxToken openParen; 150877"];
6793 [label="SyntaxToken closeParen; 150878"];
6794 [label="expression.Kind 150879"];
6795 [label="get { return (SyntaxKind)this.RawKind; } 150880"];
6796 [label="if (expression.Kind == SyntaxKind.ParenthesizedExpression)\n            {\n                var parenExpression = (ParenthesizedExpressionSyntax)expression;\n                openParen = parenExpression.OpenParenToken;\n                expression = parenExpression.Expression;\n                closeParen = parenExpression.CloseParenToken;\n\n                Debug.Assert(parenExpression.GetDiagnostics().Length == 0);\n            }\n            else if (expression.Kind == SyntaxKind.TupleExpression)\n            {\n                // As a special case, when a tuple literal is the governing expression of\n                // a switch statement we permit the switch statement's own parentheses to be omitted.\n                // LDM 2018-04-04.\n                openParen = closeParen = null;\n            }\n            else\n            {\n                // Some other expression has appeared without parens. Give a syntax error.\n                openParen = SyntaxFactory.MissingToken(SyntaxKind.OpenParenToken);\n                expression = this.AddError(expression, ErrorCode.ERR_SwitchGoverningExpressionRequiresParens);\n                closeParen = SyntaxFactory.MissingToken(SyntaxKind.CloseParenToken);\n            } 150881"];
6797 [label="var parenExpression = (ParenthesizedExpressionSyntax)expression; 150882"];
6798 [label="openParen = parenExpression.OpenParenToken; 150883"];
6799 [label="expression = parenExpression.Expression; 150884"];
6800 [label="closeParen = parenExpression.CloseParenToken; 150885"];
6801 [label="Debug.Assert(parenExpression.GetDiagnostics().Length == 0); 150886"];
6802 [label="Debug.Assert(parenExpression.GetDiagnostics().Length == 0); 150887"];
6803 [label="var openBrace = this.EatToken(SyntaxKind.OpenBraceToken); 150888"];
6804 [label="this.EatToken(SyntaxKind.OpenBraceToken) 150889"];
6805 [label="param EatToken(SyntaxKind kind) 150890"];
6806 [label="param EatToken(this) 150891"];
6807 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 150892"];
6808 [label="SyntaxFacts.IsAnyToken(kind) 150893"];
6809 [label="param IsAnyToken(SyntaxKind kind) 150894"];
6810 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 150895"];
6811 [label="return true; 150896"];
6812 [label="this.CurrentToken 150897"];
6813 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150898"];
6814 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 150899"];
6815 [label="ct.Kind 150900"];
6816 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 150901"];
6817 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 150902"];
6818 [label="MoveToNextToken(); 150903"];
6819 [label="var sections = _pool.Allocate<SwitchSectionSyntax>(); 150904"];
6820 [label="this.IsPossibleSwitchSection() 150905"];
6821 [label="param IsPossibleSwitchSection(this) 150906"];
6822 [label="this.CurrentToken 150907"];
6823 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150908"];
6824 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150909"];
6825 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 150910"];
6826 [label="return (this.CurrentToken.Kind == SyntaxKind.CaseKeyword) ||\n                   (this.CurrentToken.Kind == SyntaxKind.DefaultKeyword && this.PeekToken(1).Kind != SyntaxKind.OpenParenToken); 150911"];
6827 [label="this.CurrentToken.Kind 150912"];
6828 [label="get { return (SyntaxKind)this.RawKind; } 150913"];
6829 [label="while (this.IsPossibleSwitchSection())\n                {\n                    var swcase = this.ParseSwitchSection();\n                    sections.Add(swcase);\n                } 150914"];
6830 [label="this.ParseSwitchSection() 150915"];
6831 [label="param ParseSwitchSection(this) 150916"];
6832 [label="this.IsPossibleSwitchSection() 150917"];
6833 [label="param IsPossibleSwitchSection(this) 150918"];
6834 [label="Debug.Assert(this.IsPossibleSwitchSection()); 150919"];
6835 [label="var labels = _pool.Allocate<SwitchLabelSyntax>(); 150920"];
6836 [label="var statements = _pool.Allocate<StatementSyntax>(); 150921"];
6837 [label="SyntaxToken specifier; 150922"];
6838 [label="SwitchLabelSyntax label; 150923"];
6839 [label="SyntaxToken colon; 150924"];
6840 [label="this.CurrentToken 150925"];
6841 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150926"];
6842 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 150927"];
6843 [label="if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = _syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    } 150928"];
6844 [label="this.CurrentToken.Kind 150929"];
6845 [label="get { return (SyntaxKind)this.RawKind; } 150930"];
6846 [label="ExpressionSyntax expression; 150931"];
6847 [label="this.EatToken() 150932"];
6848 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 150933"];
6849 [label="MoveToNextToken(); 150934"];
6850 [label="specifier = this.EatToken(); 150935"];
6851 [label="this.CurrentToken 150936"];
6852 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 150937"];
6853 [label="return _lexedTokens[_tokenOffset]; 150938"];
6854 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        } 150939"];
6855 [label="this.CurrentToken.Kind 150940"];
6856 [label="get { return (SyntaxKind)this.RawKind; } 150941"];
6857 [label="ParseExpressionOrPatternForSwitchStatement() 150942"];
6858 [label="param ParseExpressionOrPatternForSwitchStatement(this) 150943"];
6859 [label="ParseExpressionOrPatternForSwitchStatementCore() 150944"];
6860 [label="param ParseExpressionOrPatternForSwitchStatementCore(this) 150945"];
6861 [label="var pattern = ParsePattern(Precedence.Conditional, whenIsKeyword: true); 150946"];
6862 [label="var pattern = ParsePattern(Precedence.Conditional, whenIsKeyword: true); 150947"];
6863 [label="ParsePattern(Precedence.Conditional, whenIsKeyword: true) 150948"];
6864 [label="param ParsePattern(Precedence precedence) 150949"];
6865 [label="param ParsePattern(bool afterIs = false) 150950"];
6866 [label="param ParsePattern(bool whenIsKeyword = false) 150951"];
6867 [label="param ParsePattern(this) 150952"];
6868 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 150953"];
6869 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 150954"];
6870 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 150955"];
6871 [label="ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword) 150956"];
6872 [label="param ParseDisjunctivePattern(Precedence precedence) 150957"];
6873 [label="param ParseDisjunctivePattern(bool afterIs) 150958"];
6874 [label="param ParseDisjunctivePattern(bool whenIsKeyword) 150959"];
6875 [label="param ParseDisjunctivePattern(this) 150960"];
6876 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 150961"];
6877 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 150962"];
6878 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 150963"];
6879 [label="ParseConjunctivePattern(precedence, afterIs, whenIsKeyword) 150964"];
6880 [label="param ParseConjunctivePattern(Precedence precedence) 150965"];
6881 [label="param ParseConjunctivePattern(bool afterIs) 150966"];
6882 [label="param ParseConjunctivePattern(bool whenIsKeyword) 150967"];
6883 [label="param ParseConjunctivePattern(this) 150968"];
6884 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 150969"];
6885 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 150970"];
6886 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 150971"];
6887 [label="ParseNegatedPattern(precedence, afterIs, whenIsKeyword) 150972"];
6888 [label="param ParseNegatedPattern(Precedence precedence) 150973"];
6889 [label="param ParseNegatedPattern(bool afterIs) 150974"];
6890 [label="param ParseNegatedPattern(bool whenIsKeyword) 150975"];
6891 [label="param ParseNegatedPattern(this) 150976"];
6892 [label="this.CurrentToken 150977"];
6893 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150978"];
6894 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.NotKeyword)\n            {\n                var notToken = ConvertToKeyword(this.EatToken());\n                var pattern = ParseNegatedPattern(precedence, afterIs, whenIsKeyword);\n                var result = _syntaxFactory.UnaryPattern(notToken, pattern);\n                return CheckFeatureAvailability(result, MessageID.IDS_FeatureNotPattern);\n            }\n            else\n            {\n                return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword);\n            } 150979"];
6895 [label="this.CurrentToken.ContextualKind 150980"];
6896 [label="get\n            {\n                return this.Kind;\n            } 150981"];
6897 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 150982"];
6898 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 150983"];
6899 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 150984"];
6900 [label="ParsePrimaryPattern(precedence, afterIs, whenIsKeyword) 150985"];
6901 [label="param ParsePrimaryPattern(Precedence precedence) 150986"];
6902 [label="param ParsePrimaryPattern(bool afterIs) 150987"];
6903 [label="param ParsePrimaryPattern(bool whenIsKeyword) 150988"];
6904 [label="param ParsePrimaryPattern(this) 150989"];
6905 [label="this.CurrentToken 150990"];
6906 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150991"];
6907 [label="var tk = this.CurrentToken.Kind; 150992"];
6908 [label="this.CurrentToken.Kind 150993"];
6909 [label="get { return (SyntaxKind)this.RawKind; } 150994"];
6910 [label="switch (tk)\n            {\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return _syntaxFactory.ConstantPattern(this.ParseIdentifierName(ErrorCode.ERR_MissingPattern));\n            } 150995"];
6911 [label="CurrentToken 150996"];
6912 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 150997"];
6913 [label="if (CurrentToken.ContextualKind == SyntaxKind.UnderscoreToken)\n            {\n                return _syntaxFactory.DiscardPattern(this.EatContextualToken(SyntaxKind.UnderscoreToken));\n            } 150998"];
6914 [label="CurrentToken.ContextualKind 150999"];
6915 [label="get\n            {\n                return this.Kind;\n            } 151000"];
6916 [label="CurrentToken 151001"];
6917 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151002"];
6918 [label="switch (CurrentToken.Kind)\n            {\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                    // this is a relational pattern.\n                    var relationalToken = this.EatToken();\n                    Debug.Assert(precedence < Precedence.Shift);\n                    var expression = this.ParseSubExpression(Precedence.Relational);\n                    var result = _syntaxFactory.RelationalPattern(relationalToken, expression);\n                    return CheckFeatureAvailability(result, MessageID.IDS_FeatureRelationalPattern);\n            } 151003"];
6919 [label="CurrentToken.Kind 151004"];
6920 [label="get { return (SyntaxKind)this.RawKind; } 151005"];
6921 [label="this.GetResetPoint() 151006"];
6922 [label="param GetResetPoint(this) 151007"];
6923 [label="var resetPoint = this.GetResetPoint(); 151008"];
6924 [label="TypeSyntax type = null; 151009"];
6925 [label="LooksLikeTypeOfPattern() 151010"];
6926 [label="param LooksLikeTypeOfPattern(this) 151011"];
6927 [label="CurrentToken 151012"];
6928 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151013"];
6929 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151014"];
6930 [label="var tk = CurrentToken.Kind; 151015"];
6931 [label="CurrentToken.Kind 151016"];
6932 [label="get { return (SyntaxKind)this.RawKind; } 151017"];
6933 [label="if (SyntaxFacts.IsPredefinedType(tk))\n            {\n                return true;\n            } 151018"];
6934 [label="SyntaxFacts.IsPredefinedType(tk) 151019"];
6935 [label="param IsPredefinedType(SyntaxKind kind) 151020"];
6936 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 151021"];
6937 [label="this.CurrentToken 151022"];
6938 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151023"];
6939 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151024"];
6940 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 151025"];
6941 [label="this.CurrentToken.ContextualKind 151026"];
6942 [label="get\n            {\n                return this.Kind;\n            } 151027"];
6943 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 151028"];
6944 [label="this.CurrentToken 151029"];
6945 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151030"];
6946 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151031"];
6947 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 151032"];
6948 [label="this.CurrentToken.ContextualKind 151033"];
6949 [label="get\n            {\n                return this.Kind;\n            } 151034"];
6950 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 151035"];
6951 [label="return true; 151036"];
6952 [label="if (LooksLikeTypeOfPattern())\n                {\n                    type = this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern);\n                    if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    }\n                } 151037"];
6953 [label="afterIs 151038"];
6954 [label="type = this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern); 151039"];
6955 [label="this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern) 151040"];
6956 [label="param ParseType(ParseTypeMode mode = ParseTypeMode.Normal) 151041"];
6957 [label="param ParseType(this) 151042"];
6958 [label="this.CurrentToken 151043"];
6959 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151044"];
6960 [label="if (this.CurrentToken.Kind == SyntaxKind.RefKeyword)\n            {\n                var refKeyword = this.EatToken();\n                refKeyword = this.CheckFeatureAvailability(refKeyword, MessageID.IDS_FeatureRefLocalsReturns);\n\n                SyntaxToken readonlyKeyword = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                {\n                    readonlyKeyword = this.EatToken();\n                    readonlyKeyword = this.CheckFeatureAvailability(readonlyKeyword, MessageID.IDS_FeatureReadOnlyReferences);\n                }\n\n                var type = ParseTypeCore(ParseTypeMode.AfterRef);\n                return _syntaxFactory.RefType(refKeyword, readonlyKeyword, type);\n            } 151045"];
6961 [label="this.CurrentToken.Kind 151046"];
6962 [label="get { return (SyntaxKind)this.RawKind; } 151047"];
6963 [label="return ParseTypeCore(mode); 151048"];
6964 [label="return ParseTypeCore(mode); 151049"];
6965 [label="return ParseTypeCore(mode); 151050"];
6966 [label="param ParseUnderlyingType(ParseTypeMode mode) 151051"];
6967 [label="param ParseUnderlyingType(NameOptions options = NameOptions.None) 151052"];
6968 [label="param ParseUnderlyingType(this) 151053"];
6969 [label="this.CurrentToken 151054"];
6970 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151055"];
6971 [label="if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, mode == ParseTypeMode.Parameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return _syntaxFactory.PredefinedType(token);\n            } 151056"];
6972 [label="this.CurrentToken.Kind 151057"];
6973 [label="get { return (SyntaxKind)this.RawKind; } 151058"];
6974 [label="IsPredefinedType(this.CurrentToken.Kind) 151059"];
6975 [label="param IsPredefinedType(SyntaxKind keyword) 151060"];
6976 [label="IsTrueIdentifier() 151061"];
6977 [label="param IsTrueIdentifier(this) 151062"];
6978 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 151063"];
6979 [label="this.CurrentToken 151064"];
6980 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151065"];
6981 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 151066"];
6982 [label="this.CurrentToken.ContextualKind 151067"];
6983 [label="get\n            {\n                return this.Kind;\n            } 151068"];
6984 [label="if (IsTrueIdentifier() || this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                return this.ParseQualifiedName(options);\n            } 151069"];
6985 [label="return this.ParseQualifiedName(options); 151070"];
6986 [label="this.ParseQualifiedName(options) 151071"];
6987 [label="param ParseQualifiedName(NameOptions options = NameOptions.None) 151072"];
6988 [label="param ParseQualifiedName(this) 151073"];
6989 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 151074"];
6990 [label="this.ParseAliasQualifiedName(options) 151075"];
6991 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 151076"];
6992 [label="param ParseAliasQualifiedName(this) 151077"];
6993 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 151078"];
6994 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 151079"];
6995 [label="this.IsIncrementalAndFactoryContextMatches 151080"];
6996 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 151081"];
6997 [label="base.IsIncremental 151082"];
6998 [label="get\n            {\n                return _isIncremental;\n            } 151083"];
6999 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 151084"];
7000 [label="return false; 151085"];
7001 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 151086"];
7002 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 151087"];
7003 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 151088"];
7004 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 151089"];
7005 [label="this.CurrentToken 151090"];
7006 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151091"];
7007 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 151092"];
7008 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 151093"];
7009 [label="IsCurrentTokenQueryKeywordInQuery() 151094"];
7010 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 151095"];
7011 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 151096"];
7012 [label="param GetTrailingTrivia(this) 151097"];
7013 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 151098"];
7014 [label="MoveToNextToken(); 151099"];
7015 [label="this.IsInAsync 151100"];
7016 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 151101"];
7017 [label="return _syntaxFactoryContext.IsInAsync; 151102"];
7018 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 151103"];
7019 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 151104"];
7020 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 151105"];
7021 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 151106"];
7022 [label="this.CurrentToken.Kind 151107"];
7023 [label="get { return (SyntaxKind)this.RawKind; } 151108"];
7024 [label="this.CurrentToken 151109"];
7025 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151110"];
7026 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 151111"];
7027 [label="this.CurrentToken.Kind 151112"];
7028 [label="get { return (SyntaxKind)this.RawKind; } 151113"];
7029 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 151114"];
7030 [label="this.IsDotOrColonColon() 151115"];
7031 [label="param IsDotOrColonColon(this) 151116"];
7032 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151117"];
7033 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 151118"];
7034 [label="this.CurrentToken 151119"];
7035 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151120"];
7036 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151121"];
7037 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 151122"];
7038 [label="this.CurrentToken.Kind 151123"];
7039 [label="get { return (SyntaxKind)this.RawKind; } 151124"];
7040 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 151125"];
7041 [label="return name; 151126"];
7042 [label="return this.ParseQualifiedName(options); 151127"];
7043 [label="param IsMakingProgress(bool assertIfFalse = true) 151128"];
7044 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 151129"];
7045 [label="CanTokenFollowTypeInPattern(precedence) 151130"];
7046 [label="param CanTokenFollowTypeInPattern(Precedence precedence) 151131"];
7047 [label="param CanTokenFollowTypeInPattern(this) 151132"];
7048 [label="this.CurrentToken 151133"];
7049 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151134"];
7050 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151135"];
7051 [label="switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.CloseBraceToken:   // for efficiency, test some tokens that can follow a type pattern\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                    return true;\n                case SyntaxKind.DotToken:\n                    // int.MaxValue is an expression, not a type.\n                    return false;\n                case var kind:\n                    // If we find what looks like a continuation of an expression, it is not a type.\n                    return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence;\n            } 151136"];
7052 [label="this.CurrentToken.Kind 151137"];
7053 [label="get { return (SyntaxKind)this.RawKind; } 151138"];
7054 [label="return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence; 151139"];
7055 [label="SyntaxFacts.IsBinaryExpressionOperatorToken(kind) 151140"];
7056 [label="param IsBinaryExpressionOperatorToken(SyntaxKind token) 151141"];
7057 [label="return GetBinaryExpression(token) != SyntaxKind.None; 151142"];
7058 [label="GetBinaryExpression(token) 151143"];
7059 [label="param GetBinaryExpression(SyntaxKind token) 151144"];
7060 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 151145"];
7061 [label="return SyntaxKind.None; 151146"];
7062 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 151147"];
7063 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 151148"];
7064 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 151149"];
7065 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 151150"];
7066 [label="ParsePatternContinued(type, precedence, whenIsKeyword) 151151"];
7067 [label="param ParsePatternContinued(TypeSyntax type) 151152"];
7068 [label="param ParsePatternContinued(Precedence precedence) 151153"];
7069 [label="param ParsePatternContinued(bool whenIsKeyword) 151154"];
7070 [label="param ParsePatternContinued(this) 151155"];
7071 [label=".Kind 151156"];
7072 [label="get { return (SyntaxKind)this.RawKind; } 151157"];
7073 [label="if (type?.Kind == SyntaxKind.IdentifierName)\n            {\n                var typeIdentifier = (IdentifierNameSyntax)type;\n                var typeIdentifierToken = typeIdentifier.Identifier;\n                if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                }\n            } 151158"];
7074 [label="var typeIdentifier = (IdentifierNameSyntax)type; 151159"];
7075 [label="var typeIdentifierToken = typeIdentifier.Identifier; 151160"];
7076 [label="typeIdentifierToken.ContextualKind 151161"];
7077 [label="get\n            {\n                return this.Kind;\n            } 151162"];
7078 [label="if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                } 151163"];
7079 [label="this.CurrentToken 151164"];
7080 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151165"];
7081 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151166"];
7082 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken && (type != null || !looksLikeCast()))\n            {\n                // It is possible this is a parenthesized (constant) expression.\n                // We normalize later.\n                ParseSubpatternList(\n                    openToken: out SyntaxToken openParenToken,\n                    subPatterns: out SeparatedSyntaxList<SubpatternSyntax> subPatterns,\n                    closeToken: out SyntaxToken closeParenToken,\n                    openKind: SyntaxKind.OpenParenToken,\n                    closeKind: SyntaxKind.CloseParenToken);\n\n                parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause0);\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n\n                if (type == null &&\n                    propertyPatternClause0 == null &&\n                    designation0 == null &&\n                    subPatterns.Count == 1 &&\n                    subPatterns.SeparatorCount == 0 &&\n                    subPatterns[0].NameColon == null)\n                {\n                    var subpattern = subPatterns[0].Pattern;\n                    switch (subpattern)\n                    {\n                        case ConstantPatternSyntax cp:\n                            // There is an ambiguity between a positional pattern `(` pattern `)`\n                            // and a constant expression pattern that happens to be parenthesized.\n                            // Per 2017-11-20 LDM we treat such syntax as a parenthesized expression always.\n                            ExpressionSyntax expression = _syntaxFactory.ParenthesizedExpression(openParenToken, cp.Expression, closeParenToken);\n                            expression = ParseExpressionContinued(expression, precedence);\n                            return _syntaxFactory.ConstantPattern(expression);\n                        default:\n                            var parenthesizedPattern = _syntaxFactory.ParenthesizedPattern(openParenToken, subPatterns[0].Pattern, closeParenToken);\n                            return CheckFeatureAvailability(parenthesizedPattern, MessageID.IDS_FeatureParenthesizedPattern);\n                    }\n                }\n\n                var positionalPatternClause = _syntaxFactory.PositionalPatternClause(openParenToken, subPatterns, closeParenToken);\n                var result = _syntaxFactory.RecursivePattern(type, positionalPatternClause, propertyPatternClause0, designation0);\n                return result;\n            } 151167"];
7083 [label="this.CurrentToken.Kind 151168"];
7084 [label="get { return (SyntaxKind)this.RawKind; } 151169"];
7085 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 151170"];
7086 [label="parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause) 151171"];
7087 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 151172"];
7088 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 151173"];
7089 [label="propertyPatternClauseResult = null; 151174"];
7090 [label="this.CurrentToken 151175"];
7091 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151176"];
7092 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151177"];
7093 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                } 151178"];
7094 [label="this.CurrentToken.Kind 151179"];
7095 [label="get { return (SyntaxKind)this.RawKind; } 151180"];
7096 [label="return false; 151181"];
7097 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 151182"];
7098 [label="if (type != null)\n            {\n                if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                }\n            } 151183"];
7099 [label="if (type != null)\n            {\n                if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                }\n            } 151184"];
7100 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 151185"];
7101 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 151186"];
7102 [label="parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation) 151187"];
7103 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 151188"];
7104 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 151189"];
7105 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 151190"];
7106 [label="designationResult = null; 151191"];
7107 [label="this.IsTrueIdentifier() 151192"];
7108 [label="param IsTrueIdentifier(this) 151193"];
7109 [label="return false; 151194"];
7110 [label="if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                } 151195"];
7111 [label="return false; 151196"];
7112 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 151197"];
7113 [label="if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    } 151198"];
7114 [label="if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    } 151199"];
7115 [label="ConvertTypeToExpression(type, out var expression) 151200"];
7116 [label="param ConvertTypeToExpression(TypeSyntax type) 151201"];
7117 [label="param ConvertTypeToExpression(out ExpressionSyntax expr) 151202"];
7118 [label="param ConvertTypeToExpression(bool permitTypeArguments = false) 151203"];
7119 [label="param ConvertTypeToExpression(this) 151204"];
7120 [label="expr = null; 151205"];
7121 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 151206"];
7122 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 151207"];
7123 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 151208"];
7124 [label="expr = s; 151209"];
7125 [label="return true; 151210"];
7126 [label="expression = ParseExpressionContinued(expression, precedence); 151211"];
7127 [label="expression = ParseExpressionContinued(expression, precedence); 151212"];
7128 [label="ParseExpressionContinued(expression, precedence) 151213"];
7129 [label="param ParseExpressionContinued(ExpressionSyntax leftOperand) 151214"];
7130 [label="param ParseExpressionContinued(Precedence precedence) 151215"];
7131 [label="param ParseExpressionContinued(this) 151216"];
7132 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 151217"];
7133 [label="this.CurrentToken 151218"];
7134 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151219"];
7135 [label="var tk = this.CurrentToken.ContextualKind; 151220"];
7136 [label="this.CurrentToken.ContextualKind 151221"];
7137 [label="get\n            {\n                return this.Kind;\n            } 151222"];
7138 [label="bool isAssignmentOperator = false; 151223"];
7139 [label="SyntaxKind opKind; 151224"];
7140 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 151225"];
7141 [label="IsExpectedBinaryOperator(tk) 151226"];
7142 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 151227"];
7143 [label="return SyntaxFacts.IsBinaryExpression(kind); 151228"];
7144 [label="SyntaxFacts.IsBinaryExpression(kind) 151229"];
7145 [label="param IsBinaryExpression(SyntaxKind token) 151230"];
7146 [label="return GetBinaryExpression(token) != SyntaxKind.None; 151231"];
7147 [label="GetBinaryExpression(token) 151232"];
7148 [label="param GetBinaryExpression(SyntaxKind token) 151233"];
7149 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 151234"];
7150 [label="return SyntaxKind.None; 151235"];
7151 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 151236"];
7152 [label="IsExpectedAssignmentOperator(tk) 151237"];
7153 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 151238"];
7154 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 151239"];
7155 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 151240"];
7156 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 151241"];
7157 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 151242"];
7158 [label="return false; 151243"];
7159 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 151244"];
7160 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 151245"];
7161 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 151246"];
7162 [label="CurrentToken 151247"];
7163 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151248"];
7164 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 151249"];
7165 [label="CurrentToken.Kind 151250"];
7166 [label="get { return (SyntaxKind)this.RawKind; } 151251"];
7167 [label="return _syntaxFactory.ConstantPattern(expression); 151252"];
7168 [label="return _syntaxFactory.ConstantPattern(expression); 151253"];
7169 [label="return _syntaxFactory.ConstantPattern(expression); 151254"];
7170 [label="param TryGetNode(int kind) 151255"];
7171 [label="param TryGetNode(GreenNode child1) 151256"];
7172 [label="param TryGetNode(SyntaxFactoryContext context) 151257"];
7173 [label="param TryGetNode(out int hash) 151258"];
7174 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 151259"];
7175 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 151260"];
7176 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 151261"];
7177 [label="GetNodeFlags(context) 151262"];
7178 [label="param GetNodeFlags(SyntaxFactoryContext context) 151263"];
7179 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 151264"];
7180 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 151265"];
7181 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 151266"];
7182 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 151267"];
7183 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 151268"];
7184 [label="param SetFactoryContext(SyntaxFactoryContext context) 151269"];
7185 [label="param SetFactoryContext(this) 151270"];
7186 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 151271"];
7187 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 151272"];
7188 [label="if (p != null)\n                    return p; 151273"];
7189 [label="if (p != null)\n                    return p; 151274"];
7190 [label="return p; 151275"];
7191 [label="this.Release(ref resetPoint); 151276"];
7192 [label="this.Release(ref resetPoint) 151277"];
7193 [label="param Release(ref ResetPoint state) 151278"];
7194 [label="base.Release(ref state.BaseResetPoint); 151279"];
7195 [label="param Release(ref ResetPoint point) 151280"];
7196 [label="Debug.Assert(_resetCount == point.ResetCount); 151281"];
7197 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 151282"];
7198 [label="base.Release(ref state.BaseResetPoint); 151283"];
7199 [label="this.Release(ref resetPoint); 151284"];
7200 [label="this.CurrentToken 151285"];
7201 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151286"];
7202 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151287"];
7203 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.AndKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseNegatedPattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.AndPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureAndPattern);\n            } 151288"];
7204 [label="this.CurrentToken.ContextualKind 151289"];
7205 [label="get\n            {\n                return this.Kind;\n            } 151290"];
7206 [label="return result; 151291"];
7207 [label="this.CurrentToken 151292"];
7208 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151293"];
7209 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151294"];
7210 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.OrKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.OrPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureOrPattern);\n            } 151295"];
7211 [label="this.CurrentToken.ContextualKind 151296"];
7212 [label="get\n            {\n                return this.Kind;\n            } 151297"];
7213 [label="return result; 151298"];
7214 [label="pattern switch\n            {\n                ConstantPatternSyntax cp => cp.Expression,\n                TypePatternSyntax tp when ConvertTypeToExpression(tp.Type, out ExpressionSyntax expr) => expr,\n                DiscardPatternSyntax dp => _syntaxFactory.IdentifierName(ConvertToIdentifier(dp.UnderscoreToken)),\n                var p => p,\n            } 151299"];
7215 [label="return pattern switch\n            {\n                ConstantPatternSyntax cp => cp.Expression,\n                TypePatternSyntax tp when ConvertTypeToExpression(tp.Type, out ExpressionSyntax expr) => expr,\n                DiscardPatternSyntax dp => _syntaxFactory.IdentifierName(ConvertToIdentifier(dp.UnderscoreToken)),\n                var p => p,\n            }; 151300"];
7216 [label="return CheckRecursivePatternFeature(ParseExpressionOrPatternForSwitchStatementCore()); 151301"];
7217 [label="CheckRecursivePatternFeature(ParseExpressionOrPatternForSwitchStatementCore()) 151302"];
7218 [label="param CheckRecursivePatternFeature(CSharpSyntaxNode node) 151303"];
7219 [label="param CheckRecursivePatternFeature(this) 151304"];
7220 [label="node.Kind 151305"];
7221 [label="get { return (SyntaxKind)this.RawKind; } 151306"];
7222 [label="switch (node.Kind)\n            {\n                case SyntaxKind.RecursivePattern:\n                case SyntaxKind.DiscardPattern:\n                case SyntaxKind.VarPattern when ((VarPatternSyntax)node).Designation.Kind == SyntaxKind.ParenthesizedVariableDesignation:\n                    return this.CheckFeatureAvailability(node, MessageID.IDS_FeatureRecursivePatterns);\n                default:\n                    return node;\n            } 151307"];
7223 [label="return node; 151308"];
7224 [label="var node = ParseExpressionOrPatternForSwitchStatement(); 151309"];
7225 [label="this.CurrentToken 151310"];
7226 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151311"];
7227 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex); 151312"];
7228 [label="this.CurrentToken.ContextualKind 151313"];
7229 [label="get\n            {\n                return this.Kind;\n            } 151314"];
7230 [label="node.Kind 151315"];
7231 [label="get { return (SyntaxKind)this.RawKind; } 151316"];
7232 [label="if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement); 151317"];
7233 [label="if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            } 151318"];
7234 [label="colon = this.EatToken(SyntaxKind.ColonToken); 151319"];
7235 [label="this.EatToken(SyntaxKind.ColonToken) 151320"];
7236 [label="param EatToken(SyntaxKind kind) 151321"];
7237 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 151322"];
7238 [label="SyntaxFacts.IsAnyToken(kind) 151323"];
7239 [label="param IsAnyToken(SyntaxKind kind) 151324"];
7240 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 151325"];
7241 [label="return true; 151326"];
7242 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 151327"];
7243 [label="MoveToNextToken(); 151328"];
7244 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 151329"];
7245 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 151330"];
7246 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 151331"];
7247 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 151332"];
7248 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 151333"];
7249 [label="param TryGetNode(SyntaxFactoryContext context) 151334"];
7250 [label="param GetNodeFlags(SyntaxFactoryContext context) 151335"];
7251 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 151336"];
7252 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 151337"];
7253 [label="param SetFactoryContext(SyntaxFactoryContext context) 151338"];
7254 [label="param SetFactoryContext(this) 151339"];
7255 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 151340"];
7256 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 151341"];
7257 [label="labels.Add(label); 151342"];
7258 [label="IsPossibleSwitchSection() 151343"];
7259 [label="param IsPossibleSwitchSection(this) 151344"];
7260 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 151345"];
7261 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 151346"];
7262 [label="do\n                {\n                    SyntaxToken specifier;\n                    SwitchLabelSyntax label;\n                    SyntaxToken colon;\n                    if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = _syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    }\n\n                    labels.Add(label);\n                }\n                while (IsPossibleSwitchSection()); 151347"];
7263 [label="SyntaxToken specifier; 151348"];
7264 [label="SwitchLabelSyntax label; 151349"];
7265 [label="SyntaxToken colon; 151350"];
7266 [label="ExpressionSyntax expression; 151351"];
7267 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 151352"];
7268 [label="MoveToNextToken(); 151353"];
7269 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 151354"];
7270 [label="param ParsePattern(Precedence precedence) 151355"];
7271 [label="param ParsePattern(bool whenIsKeyword = false) 151356"];
7272 [label="param ParseDisjunctivePattern(Precedence precedence) 151357"];
7273 [label="param ParseDisjunctivePattern(bool whenIsKeyword) 151358"];
7274 [label="param ParseConjunctivePattern(Precedence precedence) 151359"];
7275 [label="param ParseConjunctivePattern(bool whenIsKeyword) 151360"];
7276 [label="param ParseNegatedPattern(Precedence precedence) 151361"];
7277 [label="param ParseNegatedPattern(bool whenIsKeyword) 151362"];
7278 [label="param ParsePrimaryPattern(Precedence precedence) 151363"];
7279 [label="param ParsePrimaryPattern(bool whenIsKeyword) 151364"];
7280 [label="this.CurrentToken 151365"];
7281 [label="var tk = this.CurrentToken.Kind; 151366"];
7282 [label="this.CurrentToken.Kind 151367"];
7283 [label="get { return (SyntaxKind)this.RawKind; } 151368"];
7284 [label="switch (tk)\n            {\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return _syntaxFactory.ConstantPattern(this.ParseIdentifierName(ErrorCode.ERR_MissingPattern));\n            } 151369"];
7285 [label="CurrentToken 151370"];
7286 [label="if (CurrentToken.ContextualKind == SyntaxKind.UnderscoreToken)\n            {\n                return _syntaxFactory.DiscardPattern(this.EatContextualToken(SyntaxKind.UnderscoreToken));\n            } 151371"];
7287 [label="CurrentToken.ContextualKind 151372"];
7288 [label="get\n            {\n                return this.Kind;\n            } 151373"];
7289 [label="CurrentToken 151374"];
7290 [label="switch (CurrentToken.Kind)\n            {\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                    // this is a relational pattern.\n                    var relationalToken = this.EatToken();\n                    Debug.Assert(precedence < Precedence.Shift);\n                    var expression = this.ParseSubExpression(Precedence.Relational);\n                    var result = _syntaxFactory.RelationalPattern(relationalToken, expression);\n                    return CheckFeatureAvailability(result, MessageID.IDS_FeatureRelationalPattern);\n            } 151375"];
7291 [label="CurrentToken.Kind 151376"];
7292 [label="get { return (SyntaxKind)this.RawKind; } 151377"];
7293 [label="var resetPoint = this.GetResetPoint(); 151378"];
7294 [label="TypeSyntax type = null; 151379"];
7295 [label="if (SyntaxFacts.IsPredefinedType(tk))\n            {\n                return true;\n            } 151380"];
7296 [label="SyntaxFacts.IsPredefinedType(tk) 151381"];
7297 [label="param IsPredefinedType(SyntaxKind kind) 151382"];
7298 [label="get { return (SyntaxKind)this.RawKind; } 151383"];
7299 [label="afterIs 151384"];
7300 [label="this.CurrentToken 151385"];
7301 [label="if (this.CurrentToken.Kind == SyntaxKind.RefKeyword)\n            {\n                var refKeyword = this.EatToken();\n                refKeyword = this.CheckFeatureAvailability(refKeyword, MessageID.IDS_FeatureRefLocalsReturns);\n\n                SyntaxToken readonlyKeyword = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                {\n                    readonlyKeyword = this.EatToken();\n                    readonlyKeyword = this.CheckFeatureAvailability(readonlyKeyword, MessageID.IDS_FeatureReadOnlyReferences);\n                }\n\n                var type = ParseTypeCore(ParseTypeMode.AfterRef);\n                return _syntaxFactory.RefType(refKeyword, readonlyKeyword, type);\n            } 151386"];
7302 [label="this.CurrentToken.Kind 151387"];
7303 [label="get { return (SyntaxKind)this.RawKind; } 151388"];
7304 [label="param ParseUnderlyingType(ParseTypeMode mode) 151389"];
7305 [label="param ParseUnderlyingType(NameOptions options = NameOptions.None) 151390"];
7306 [label="this.CurrentToken 151391"];
7307 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151392"];
7308 [label="if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, mode == ParseTypeMode.Parameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return _syntaxFactory.PredefinedType(token);\n            } 151393"];
7309 [label="this.CurrentToken.Kind 151394"];
7310 [label="get { return (SyntaxKind)this.RawKind; } 151395"];
7311 [label="IsPredefinedType(this.CurrentToken.Kind) 151396"];
7312 [label="param IsPredefinedType(SyntaxKind keyword) 151397"];
7313 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 151398"];
7314 [label="this.CurrentToken 151399"];
7315 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151400"];
7316 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 151401"];
7317 [label="param ParseQualifiedName(NameOptions options = NameOptions.None) 151402"];
7318 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 151403"];
7319 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 151404"];
7320 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 151405"];
7321 [label="this.IsIncrementalAndFactoryContextMatches 151406"];
7322 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 151407"];
7323 [label="base.IsIncremental 151408"];
7324 [label="get\n            {\n                return _isIncremental;\n            } 151409"];
7325 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 151410"];
7326 [label="return false; 151411"];
7327 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 151412"];
7328 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 151413"];
7329 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 151414"];
7330 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 151415"];
7331 [label="this.CurrentToken 151416"];
7332 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151417"];
7333 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 151418"];
7334 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 151419"];
7335 [label="IsCurrentTokenQueryKeywordInQuery() 151420"];
7336 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 151421"];
7337 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 151422"];
7338 [label="param GetTrailingTrivia(this) 151423"];
7339 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 151424"];
7340 [label="MoveToNextToken(); 151425"];
7341 [label="this.IsInAsync 151426"];
7342 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 151427"];
7343 [label="return _syntaxFactoryContext.IsInAsync; 151428"];
7344 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 151429"];
7345 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 151430"];
7346 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 151431"];
7347 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 151432"];
7348 [label="this.CurrentToken.Kind 151433"];
7349 [label="get { return (SyntaxKind)this.RawKind; } 151434"];
7350 [label="this.CurrentToken 151435"];
7351 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151436"];
7352 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 151437"];
7353 [label="this.CurrentToken.Kind 151438"];
7354 [label="get { return (SyntaxKind)this.RawKind; } 151439"];
7355 [label="this.IsDotOrColonColon() 151440"];
7356 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151441"];
7357 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 151442"];
7358 [label="this.CurrentToken 151443"];
7359 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151444"];
7360 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 151445"];
7361 [label="this.CurrentToken.Kind 151446"];
7362 [label="get { return (SyntaxKind)this.RawKind; } 151447"];
7363 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 151448"];
7364 [label="param IsMakingProgress(bool assertIfFalse = true) 151449"];
7365 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 151450"];
7366 [label="CanTokenFollowTypeInPattern(precedence) 151451"];
7367 [label="param CanTokenFollowTypeInPattern(Precedence precedence) 151452"];
7368 [label="param CanTokenFollowTypeInPattern(this) 151453"];
7369 [label="this.CurrentToken 151454"];
7370 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151455"];
7371 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151456"];
7372 [label="switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.CloseBraceToken:   // for efficiency, test some tokens that can follow a type pattern\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                    return true;\n                case SyntaxKind.DotToken:\n                    // int.MaxValue is an expression, not a type.\n                    return false;\n                case var kind:\n                    // If we find what looks like a continuation of an expression, it is not a type.\n                    return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence;\n            } 151457"];
7373 [label="this.CurrentToken.Kind 151458"];
7374 [label="get { return (SyntaxKind)this.RawKind; } 151459"];
7375 [label="return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence; 151460"];
7376 [label="SyntaxFacts.IsBinaryExpressionOperatorToken(kind) 151461"];
7377 [label="param IsBinaryExpressionOperatorToken(SyntaxKind token) 151462"];
7378 [label="return GetBinaryExpression(token) != SyntaxKind.None; 151463"];
7379 [label="GetBinaryExpression(token) 151464"];
7380 [label="param GetBinaryExpression(SyntaxKind token) 151465"];
7381 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 151466"];
7382 [label="return SyntaxKind.None; 151467"];
7383 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 151468"];
7384 [label="param ParsePatternContinued(Precedence precedence) 151469"];
7385 [label="param ParsePatternContinued(bool whenIsKeyword) 151470"];
7386 [label=".Kind 151471"];
7387 [label="get { return (SyntaxKind)this.RawKind; } 151472"];
7388 [label="if (type?.Kind == SyntaxKind.IdentifierName)\n            {\n                var typeIdentifier = (IdentifierNameSyntax)type;\n                var typeIdentifierToken = typeIdentifier.Identifier;\n                if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                }\n            } 151473"];
7389 [label="var typeIdentifier = (IdentifierNameSyntax)type; 151474"];
7390 [label="var typeIdentifierToken = typeIdentifier.Identifier; 151475"];
7391 [label="typeIdentifierToken.ContextualKind 151476"];
7392 [label="get\n            {\n                return this.Kind;\n            } 151477"];
7393 [label="if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                } 151478"];
7394 [label="this.CurrentToken 151479"];
7395 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151480"];
7396 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken && (type != null || !looksLikeCast()))\n            {\n                // It is possible this is a parenthesized (constant) expression.\n                // We normalize later.\n                ParseSubpatternList(\n                    openToken: out SyntaxToken openParenToken,\n                    subPatterns: out SeparatedSyntaxList<SubpatternSyntax> subPatterns,\n                    closeToken: out SyntaxToken closeParenToken,\n                    openKind: SyntaxKind.OpenParenToken,\n                    closeKind: SyntaxKind.CloseParenToken);\n\n                parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause0);\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n\n                if (type == null &&\n                    propertyPatternClause0 == null &&\n                    designation0 == null &&\n                    subPatterns.Count == 1 &&\n                    subPatterns.SeparatorCount == 0 &&\n                    subPatterns[0].NameColon == null)\n                {\n                    var subpattern = subPatterns[0].Pattern;\n                    switch (subpattern)\n                    {\n                        case ConstantPatternSyntax cp:\n                            // There is an ambiguity between a positional pattern `(` pattern `)`\n                            // and a constant expression pattern that happens to be parenthesized.\n                            // Per 2017-11-20 LDM we treat such syntax as a parenthesized expression always.\n                            ExpressionSyntax expression = _syntaxFactory.ParenthesizedExpression(openParenToken, cp.Expression, closeParenToken);\n                            expression = ParseExpressionContinued(expression, precedence);\n                            return _syntaxFactory.ConstantPattern(expression);\n                        default:\n                            var parenthesizedPattern = _syntaxFactory.ParenthesizedPattern(openParenToken, subPatterns[0].Pattern, closeParenToken);\n                            return CheckFeatureAvailability(parenthesizedPattern, MessageID.IDS_FeatureParenthesizedPattern);\n                    }\n                }\n\n                var positionalPatternClause = _syntaxFactory.PositionalPatternClause(openParenToken, subPatterns, closeParenToken);\n                var result = _syntaxFactory.RecursivePattern(type, positionalPatternClause, propertyPatternClause0, designation0);\n                return result;\n            } 151481"];
7397 [label="this.CurrentToken.Kind 151482"];
7398 [label="get { return (SyntaxKind)this.RawKind; } 151483"];
7399 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 151484"];
7400 [label="parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause) 151485"];
7401 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 151486"];
7402 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 151487"];
7403 [label="propertyPatternClauseResult = null; 151488"];
7404 [label="this.CurrentToken 151489"];
7405 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151490"];
7406 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151491"];
7407 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                } 151492"];
7408 [label="this.CurrentToken.Kind 151493"];
7409 [label="get { return (SyntaxKind)this.RawKind; } 151494"];
7410 [label="return false; 151495"];
7411 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 151496"];
7412 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 151497"];
7413 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 151498"];
7414 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 151499"];
7415 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 151500"];
7416 [label="designationResult = null; 151501"];
7417 [label="this.IsTrueIdentifier() 151502"];
7418 [label="param IsTrueIdentifier(this) 151503"];
7419 [label="return false; 151504"];
7420 [label="if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                } 151505"];
7421 [label="param ConvertTypeToExpression(out ExpressionSyntax expr) 151506"];
7422 [label="param ConvertTypeToExpression(bool permitTypeArguments = false) 151507"];
7423 [label="param ConvertTypeToExpression(this) 151508"];
7424 [label="expr = null; 151509"];
7425 [label="expression = ParseExpressionContinued(expression, precedence); 151510"];
7426 [label="param ParseExpressionContinued(Precedence precedence) 151511"];
7427 [label="param ParseExpressionContinued(this) 151512"];
7428 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 151513"];
7429 [label="this.CurrentToken 151514"];
7430 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151515"];
7431 [label="var tk = this.CurrentToken.ContextualKind; 151516"];
7432 [label="this.CurrentToken.ContextualKind 151517"];
7433 [label="get\n            {\n                return this.Kind;\n            } 151518"];
7434 [label="bool isAssignmentOperator = false; 151519"];
7435 [label="SyntaxKind opKind; 151520"];
7436 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 151521"];
7437 [label="IsExpectedBinaryOperator(tk) 151522"];
7438 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 151523"];
7439 [label="return SyntaxFacts.IsBinaryExpression(kind); 151524"];
7440 [label="SyntaxFacts.IsBinaryExpression(kind) 151525"];
7441 [label="param IsBinaryExpression(SyntaxKind token) 151526"];
7442 [label="return GetBinaryExpression(token) != SyntaxKind.None; 151527"];
7443 [label="GetBinaryExpression(token) 151528"];
7444 [label="param GetBinaryExpression(SyntaxKind token) 151529"];
7445 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 151530"];
7446 [label="return SyntaxKind.None; 151531"];
7447 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 151532"];
7448 [label="IsExpectedAssignmentOperator(tk) 151533"];
7449 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 151534"];
7450 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 151535"];
7451 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 151536"];
7452 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 151537"];
7453 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 151538"];
7454 [label="return false; 151539"];
7455 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 151540"];
7456 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 151541"];
7457 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 151542"];
7458 [label="CurrentToken 151543"];
7459 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151544"];
7460 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 151545"];
7461 [label="CurrentToken.Kind 151546"];
7462 [label="get { return (SyntaxKind)this.RawKind; } 151547"];
7463 [label="param TryGetNode(SyntaxFactoryContext context) 151548"];
7464 [label="param GetNodeFlags(SyntaxFactoryContext context) 151549"];
7465 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 151550"];
7466 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 151551"];
7467 [label="param SetFactoryContext(SyntaxFactoryContext context) 151552"];
7468 [label="param SetFactoryContext(this) 151553"];
7469 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 151554"];
7470 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 151555"];
7471 [label="this.Release(ref resetPoint); 151556"];
7472 [label="param Release(ref ResetPoint state) 151557"];
7473 [label="base.Release(ref state.BaseResetPoint); 151558"];
7474 [label="param Release(ref ResetPoint point) 151559"];
7475 [label="Debug.Assert(_resetCount == point.ResetCount); 151560"];
7476 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 151561"];
7477 [label="base.Release(ref state.BaseResetPoint); 151562"];
7478 [label="this.Release(ref resetPoint); 151563"];
7479 [label="this.CurrentToken 151564"];
7480 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151565"];
7481 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.AndKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseNegatedPattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.AndPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureAndPattern);\n            } 151566"];
7482 [label="this.CurrentToken.ContextualKind 151567"];
7483 [label="get\n            {\n                return this.Kind;\n            } 151568"];
7484 [label="this.CurrentToken 151569"];
7485 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151570"];
7486 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.OrKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.OrPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureOrPattern);\n            } 151571"];
7487 [label="this.CurrentToken.ContextualKind 151572"];
7488 [label="get\n            {\n                return this.Kind;\n            } 151573"];
7489 [label="pattern switch\n            {\n                ConstantPatternSyntax cp => cp.Expression,\n                TypePatternSyntax tp when ConvertTypeToExpression(tp.Type, out ExpressionSyntax expr) => expr,\n                DiscardPatternSyntax dp => _syntaxFactory.IdentifierName(ConvertToIdentifier(dp.UnderscoreToken)),\n                var p => p,\n            } 151574"];
7490 [label="param CheckRecursivePatternFeature(this) 151575"];
7491 [label="this.CurrentToken 151576"];
7492 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151577"];
7493 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex); 151578"];
7494 [label="this.CurrentToken.ContextualKind 151579"];
7495 [label="get\n            {\n                return this.Kind;\n            } 151580"];
7496 [label="node.Kind 151581"];
7497 [label="get { return (SyntaxKind)this.RawKind; } 151582"];
7498 [label="if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement); 151583"];
7499 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 151584"];
7500 [label="SyntaxFacts.IsAnyToken(kind) 151585"];
7501 [label="param IsAnyToken(SyntaxKind kind) 151586"];
7502 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 151587"];
7503 [label="return true; 151588"];
7504 [label="param GetTrailingTrivia(this) 151589"];
7505 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 151590"];
7506 [label="MoveToNextToken(); 151591"];
7507 [label="param GetNodeFlags(SyntaxFactoryContext context) 151592"];
7508 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 151593"];
7509 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 151594"];
7510 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 151595"];
7511 [label="this.CurrentToken 151596"];
7512 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151597"];
7513 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151598"];
7514 [label="this.CurrentToken.Kind 151599"];
7515 [label="get { return (SyntaxKind)this.RawKind; } 151600"];
7516 [label="CSharpSyntaxNode tmp = labels[labels.Count - 1]; 151601"];
7517 [label="CSharpSyntaxNode tmp = labels[labels.Count - 1]; 151602"];
7518 [label="this.ParseStatements(ref tmp, statements, true); 151603"];
7519 [label="this.ParseStatements(ref tmp, statements, true); 151604"];
7520 [label="this.ParseStatements(ref tmp, statements, true); 151605"];
7521 [label="this.ParseStatements(ref tmp, statements, true) 151606"];
7522 [label="param ParseStatements(ref CSharpSyntaxNode previousNode) 151607"];
7523 [label="param ParseStatements(SyntaxListBuilder<StatementSyntax> statements) 151608"];
7524 [label="param ParseStatements(bool stopOnSwitchSections) 151609"];
7525 [label="param ParseStatements(this) 151610"];
7526 [label="var saveTerm = _termState; 151611"];
7527 [label="_termState |= TerminatorState.IsPossibleStatementStartOrStop; 151612"];
7528 [label="_termState 151613"];
7529 [label="if (stopOnSwitchSections)\n            {\n                _termState |= TerminatorState.IsSwitchSectionStart;\n            } 151614"];
7530 [label="_termState |= TerminatorState.IsSwitchSectionStart; 151615"];
7531 [label="_termState 151616"];
7532 [label="int lastTokenPosition = -1; 151617"];
7533 [label="this.CurrentToken 151618"];
7534 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151619"];
7535 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151620"];
7536 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 151621"];
7537 [label="this.CurrentToken.Kind 151622"];
7538 [label="get { return (SyntaxKind)this.RawKind; } 151623"];
7539 [label="this.CurrentToken 151624"];
7540 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151625"];
7541 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151626"];
7542 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 151627"];
7543 [label="this.CurrentToken.Kind 151628"];
7544 [label="get { return (SyntaxKind)this.RawKind; } 151629"];
7545 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 151630"];
7546 [label="this.IsPossibleSwitchSection() 151631"];
7547 [label="param IsPossibleSwitchSection(this) 151632"];
7548 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151633"];
7549 [label="this.CurrentToken 151634"];
7550 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151635"];
7551 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151636"];
7552 [label="this.CurrentToken.Kind 151637"];
7553 [label="get { return (SyntaxKind)this.RawKind; } 151638"];
7554 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 151639"];
7555 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 151640"];
7556 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 151641"];
7557 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 151642"];
7558 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 151643"];
7559 [label="IsMakingProgress(ref lastTokenPosition) 151644"];
7560 [label="param IsMakingProgress(ref int lastTokenPosition) 151645"];
7561 [label="param IsMakingProgress(bool assertIfFalse = true) 151646"];
7562 [label="param IsMakingProgress(this) 151647"];
7563 [label="_firstToken + _tokenOffset 151648"];
7564 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 151649"];
7565 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 151650"];
7566 [label="if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                } 151651"];
7567 [label="this.IsPossibleStatement(acceptAccessibilityMods: true) 151652"];
7568 [label="param IsPossibleStatement(bool acceptAccessibilityMods) 151653"];
7569 [label="param IsPossibleStatement(this) 151654"];
7570 [label="this.CurrentToken 151655"];
7571 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151656"];
7572 [label="var tk = this.CurrentToken.Kind; 151657"];
7573 [label="this.CurrentToken.Kind 151658"];
7574 [label="get { return (SyntaxKind)this.RawKind; } 151659"];
7575 [label="switch (tk)\n            {\n                case SyntaxKind.FixedKeyword:\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.ThrowKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                case SyntaxKind.RefKeyword:\n                case SyntaxKind.ExternKeyword:\n                case SyntaxKind.OpenBracketToken:\n                    return true;\n\n                case SyntaxKind.IdentifierToken:\n                    return IsTrueIdentifier();\n\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.FinallyKeyword:\n                    return !_isInTry;\n\n                // Accessibility modifiers are not legal in a statement,\n                // but a common mistake for local functions. Parse to give a\n                // better error message.\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PrivateKeyword:\n                    return acceptAccessibilityMods;\n                default:\n                    return IsPredefinedType(tk)\n                        || IsPossibleExpression();\n            } 151660"];
7576 [label="return true; 151661"];
7577 [label="if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                } 151662"];
7578 [label="this.ParsePossiblyAttributedStatement() 151663"];
7579 [label="var attributes = _pool.Allocate<AttributeListSyntax>(); 151664"];
7580 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 151665"];
7581 [label="this.CurrentToken.Kind 151666"];
7582 [label="get { return (SyntaxKind)this.RawKind; } 151667"];
7583 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 151668"];
7584 [label="false 151669"];
7585 [label="isGlobal: false 151670"];
7586 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 151671"];
7587 [label="param ParseStatementCore(bool isGlobal) 151672"];
7588 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 151673"];
7589 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 151674"];
7590 [label="canReuseStatement(attributes, isGlobal) 151675"];
7591 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 151676"];
7592 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 151677"];
7593 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 151678"];
7594 [label="this.IsIncrementalAndFactoryContextMatches 151679"];
7595 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 151680"];
7596 [label="base.IsIncremental 151681"];
7597 [label="get\n            {\n                return _isIncremental;\n            } 151682"];
7598 [label="return _isIncremental; 151683"];
7599 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 151684"];
7600 [label="return false; 151685"];
7601 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 151686"];
7602 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 151687"];
7603 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 151688"];
7604 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 151689"];
7605 [label="StatementSyntax result; 151690"];
7606 [label="return _syntaxFactory.EmptyStatement(attributes, this.EatToken()); 151691"];
7607 [label="this.EatToken() 151692"];
7608 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 151693"];
7609 [label="MoveToNextToken(); 151694"];
7610 [label="return _syntaxFactory.EmptyStatement(attributes, this.EatToken()); 151695"];
7611 [label="return _syntaxFactory.EmptyStatement(attributes, this.EatToken()); 151696"];
7612 [label="return _syntaxFactory.EmptyStatement(attributes, this.EatToken()); 151697"];
7613 [label="param TryGetNode(int kind) 151698"];
7614 [label="param TryGetNode(GreenNode child1) 151699"];
7615 [label="param TryGetNode(GreenNode child2) 151700"];
7616 [label="param TryGetNode(SyntaxFactoryContext context) 151701"];
7617 [label="param TryGetNode(out int hash) 151702"];
7618 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 151703"];
7619 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 151704"];
7620 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 151705"];
7621 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 151706"];
7622 [label="GetNodeFlags(context) 151707"];
7623 [label="param GetNodeFlags(SyntaxFactoryContext context) 151708"];
7624 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 151709"];
7625 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 151710"];
7626 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 151711"];
7627 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 151712"];
7628 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 151713"];
7629 [label="param SetFactoryContext(SyntaxFactoryContext context) 151714"];
7630 [label="param SetFactoryContext(this) 151715"];
7631 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 151716"];
7632 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 151717"];
7633 [label="_recursionDepth 151718"];
7634 [label="this.Release(ref resetPointBeforeStatement); 151719"];
7635 [label="this.Release(ref resetPointBeforeStatement) 151720"];
7636 [label="param Release(ref ResetPoint state) 151721"];
7637 [label="base.Release(ref state.BaseResetPoint); 151722"];
7638 [label="param Release(ref ResetPoint point) 151723"];
7639 [label="Debug.Assert(_resetCount == point.ResetCount); 151724"];
7640 [label="_resetCount 151725"];
7641 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 151726"];
7642 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 151727"];
7643 [label="base.Release(ref state.BaseResetPoint); 151728"];
7644 [label="this.Release(ref resetPointBeforeStatement); 151729"];
7645 [label="var statement = this.ParsePossiblyAttributedStatement(); 151730"];
7646 [label="if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    } 151731"];
7647 [label="if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    } 151732"];
7648 [label="statements.Add(statement); 151733"];
7649 [label="statements.Add(statement); 151734"];
7650 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 151735"];
7651 [label="_termState 151736"];
7652 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 151737"];
7653 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 151738"];
7654 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 151739"];
7655 [label="return _syntaxFactory.SwitchSection(labels, statements); 151740"];
7656 [label="return _syntaxFactory.SwitchSection(labels, statements); 151741"];
7657 [label="return _syntaxFactory.SwitchSection(labels, statements); 151742"];
7658 [label="return _syntaxFactory.SwitchSection(labels, statements); 151743"];
7659 [label="param TryGetNode(SyntaxFactoryContext context) 151744"];
7660 [label="GetNodeFlags(context) 151745"];
7661 [label="param GetNodeFlags(SyntaxFactoryContext context) 151746"];
7662 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 151747"];
7663 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 151748"];
7664 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 151749"];
7665 [label="param SetFactoryContext(SyntaxFactoryContext context) 151750"];
7666 [label="param SetFactoryContext(this) 151751"];
7667 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 151752"];
7668 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 151753"];
7669 [label="_pool.Free(statements); 151754"];
7670 [label="_pool.Free(statements); 151755"];
7671 [label="_pool.Free(labels); 151756"];
7672 [label="_pool.Free(labels); 151757"];
7673 [label="var swcase = this.ParseSwitchSection(); 151758"];
7674 [label="sections.Add(swcase); 151759"];
7675 [label="sections.Add(swcase); 151760"];
7676 [label="this.CurrentToken 151761"];
7677 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151762"];
7678 [label="this.CurrentToken.Kind 151763"];
7679 [label="var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken); 151764"];
7680 [label="this.EatToken(SyntaxKind.CloseBraceToken) 151765"];
7681 [label="param EatToken(SyntaxKind kind) 151766"];
7682 [label="param EatToken(this) 151767"];
7683 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 151768"];
7684 [label="SyntaxFacts.IsAnyToken(kind) 151769"];
7685 [label="param IsAnyToken(SyntaxKind kind) 151770"];
7686 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 151771"];
7687 [label="return true; 151772"];
7688 [label="this.CurrentToken 151773"];
7689 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151774"];
7690 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 151775"];
7691 [label="ct.Kind 151776"];
7692 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 151777"];
7693 [label="param GetTrailingTrivia(this) 151778"];
7694 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 151779"];
7695 [label="MoveToNextToken(); 151780"];
7696 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 151781"];
7697 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 151782"];
7698 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 151783"];
7699 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 151784"];
7700 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 151785"];
7701 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 151786"];
7702 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 151787"];
7703 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 151788"];
7704 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 151789"];
7705 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 151790"];
7706 [label="param CSharpSyntaxNode(this) 151791"];
7707 [label="GreenStats.NoteGreen(this); 151792"];
7708 [label="param SetFactoryContext(SyntaxFactoryContext context) 151793"];
7709 [label="param SetFactoryContext(this) 151794"];
7710 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 151795"];
7711 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 151796"];
7712 [label="_pool.Free(sections); 151797"];
7713 [label="_pool.Free(sections); 151798"];
7714 [label="this.Release(ref resetPointBeforeStatement); 151799"];
7715 [label="this.Release(ref resetPointBeforeStatement) 151800"];
7716 [label="param Release(ref ResetPoint state) 151801"];
7717 [label="param Release(this) 151802"];
7718 [label="base.Release(ref state.BaseResetPoint); 151803"];
7719 [label="base.Release(ref state.BaseResetPoint) 151804"];
7720 [label="param Release(ref ResetPoint point) 151805"];
7721 [label="param Release(this) 151806"];
7722 [label="Debug.Assert(_resetCount == point.ResetCount); 151807"];
7723 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 151808"];
7724 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 151809"];
7725 [label="_resetStart = -1; 151810"];
7726 [label="_resetStart 151811"];
7727 [label="base.Release(ref state.BaseResetPoint); 151812"];
7728 [label="this.Release(ref resetPointBeforeStatement); 151813"];
7729 [label="var node = parser.ParseStatement(); 151814"];
7730 [label="if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node); 151815"];
7731 [label="node = parser.ConsumeUnexpectedTokens(node); 151816"];
7732 [label="parser.ConsumeUnexpectedTokens(node) 151817"];
7733 [label="param ConsumeUnexpectedTokens(TNode node) 151818"];
7734 [label="param ConsumeUnexpectedTokens(this) 151819"];
7735 [label="this.CurrentToken 151820"];
7736 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 151821"];
7737 [label="this.FetchCurrentToken() 151822"];
7738 [label="param FetchCurrentToken(this) 151823"];
7739 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 151824"];
7740 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 151825"];
7741 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 151826"];
7742 [label="if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken) return node; 151827"];
7743 [label="this.CurrentToken.Kind 151828"];
7744 [label="get { return (SyntaxKind)this.RawKind; } 151829"];
7745 [label="return node; 151830"];
7746 [label="return (StatementSyntax)node.CreateRed(); 151831"];
7747 [label="return (StatementSyntax)node.CreateRed(); 151832"];
7748 [label="return (StatementSyntax)node.CreateRed(); 151833"];
7749 [label="param CSharpSyntaxNode(GreenNode green) 151834"];
7750 [label="param CSharpSyntaxNode(SyntaxNode? parent) 151835"];
7751 [label="param CSharpSyntaxNode(int position) 151836"];
7752 [label="param CSharpSyntaxNode(this) 151837"];
7753 [label="green 151838"];
7754 [label="parent 151839"];
7755 [label="position 151840"];
7756 [label="param CSharpSyntaxNode(this) 151841"];
7757 [label="param CSharpSyntaxNode(this) 151842"];
7758 [label="CustomAssert.NotNull(statement); 151843"];
7759 [label="CustomAssert.Equal(SyntaxKind.SwitchStatement, statement.Kind()); 151844"];
7760 [label="statement.Kind() 151845"];
7761 [label="param Kind(this) 151846"];
7762 [label="return (SyntaxKind)this.Green.RawKind; 151847"];
7763 [label="CustomAssert.Equal(SyntaxKind.SwitchStatement, statement.Kind()); 151848"];
7764 [label="CustomAssert.Equal(text, statement.ToString()); 151849"];
7765 [label="CustomAssert.Equal(text, statement.ToString()); 151850"];
7766 [label="CustomAssert.Equal(text, statement.ToString()); 151851"];
7767 [label="=> true 151852"];
7768 [label="true 151853"];
7769 [label="CustomAssert.Equal(text, statement.ToString()); 151854"];
7770 [label="param WriteTokenTo(System.IO.TextWriter writer) 151855"];
7771 [label="param WriteTokenTo(bool leading) 151856"];
7772 [label="param WriteTokenTo(bool trailing) 151857"];
7773 [label="param WriteTokenTo(this) 151858"];
7774 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 151859"];
7775 [label="this.Text 151860"];
7776 [label="get { return SyntaxFacts.GetText(this.Kind); } 151861"];
7777 [label="this.Kind 151862"];
7778 [label="get { return (SyntaxKind)this.RawKind; } 151863"];
7779 [label="return (SyntaxKind)this.RawKind; 151864"];
7780 [label="return SyntaxFacts.GetText(this.Kind); 151865"];
7781 [label="SyntaxFacts.GetText(this.Kind) 151866"];
7782 [label="param GetText(SyntaxKind kind) 151867"];
7783 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 151868"];
7784 [label="return 'switch'; 151869"];
7785 [label="writer.Write(this.Text); 151870"];
7786 [label="writer.Write(this.Text); 151871"];
7787 [label="if (trailing)\n            {\n                var trivia = this.GetTrailingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 151872"];
7788 [label="this.GetTrailingTrivia() 151873"];
7789 [label="param GetTrailingTrivia(this) 151874"];
7790 [label="return this.TrailingField; 151875"];
7791 [label="var trivia = this.GetTrailingTrivia(); 151876"];
7792 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 151877"];
7793 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 151878"];
7794 [label="trivia.WriteTo(writer, true, true); 151879"];
7795 [label="trivia.WriteTo(writer, true, true); 151880"];
7796 [label="=> true 151881"];
7797 [label="true 151882"];
7798 [label="param WriteTriviaTo(System.IO.TextWriter writer) 151883"];
7799 [label="param WriteTriviaTo(this) 151884"];
7800 [label="writer.Write(Text); 151885"];
7801 [label="writer.Write(Text); 151886"];
7802 [label="this.GetLeadingTrivia() 151887"];
7803 [label="param GetLeadingTrivia(this) 151888"];
7804 [label="return null; 151889"];
7805 [label="var trivia = this.GetLeadingTrivia(); 151890"];
7806 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 151891"];
7807 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 151892"];
7808 [label="return '('; 151893"];
7809 [label="param GetTrailingTrivia(this) 151894"];
7810 [label="var trivia = this.GetTrailingTrivia(); 151895"];
7811 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 151896"];
7812 [label="get { return this.TextField; } 151897"];
7813 [label="return this.TextField; 151898"];
7814 [label="param GetLeadingTrivia(this) 151899"];
7815 [label="return this.LeadingField; 151900"];
7816 [label="var trivia = this.GetLeadingTrivia(); 151901"];
7817 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 151902"];
7818 [label="return ')'; 151903"];
7819 [label="=> true 151904"];
7820 [label="return this.LeadingField; 151905"];
7821 [label="var trivia = this.GetLeadingTrivia(); 151906"];
7822 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 151907"];
7823 [label="return '{'; 151908"];
7824 [label="=> true 151909"];
7825 [label="return this.LeadingField; 151910"];
7826 [label="var trivia = this.GetLeadingTrivia(); 151911"];
7827 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 151912"];
7828 [label="return 'case'; 151913"];
7829 [label="=> true 151914"];
7830 [label="return this.LeadingField; 151915"];
7831 [label="var trivia = this.GetLeadingTrivia(); 151916"];
7832 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 151917"];
7833 [label="return ':'; 151918"];
7834 [label="=> true 151919"];
7835 [label="return this.LeadingField; 151920"];
7836 [label="var trivia = this.GetLeadingTrivia(); 151921"];
7837 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 151922"];
7838 [label="return ';'; 151923"];
7839 [label="=> true 151924"];
7840 [label="return '}'; 151925"];
7841 [label="CustomAssert.Equal(0, statement.Errors().Length); 151926"];
7842 [label="CustomAssert.Equal(0, statement.Errors().Length); 151927"];
7843 [label="statement.Errors() 151928"];
7844 [label="param Errors(this SyntaxNode node) 151929"];
7845 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 151930"];
7846 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 151931"];
7847 [label="node.Green.ErrorsOrWarnings(errorsOnly: true) 151932"];
7848 [label="param ErrorsOrWarnings(this GreenNode node) 151933"];
7849 [label="param ErrorsOrWarnings(bool errorsOnly) 151934"];
7850 [label="ArrayBuilder<DiagnosticInfo> b = ArrayBuilder<DiagnosticInfo>.GetInstance(); 151935"];
7851 [label="var l = new SyntaxDiagnosticInfoList(node); 151936"];
7852 [label="foreach (var item in l)\n            {\n                if (item.Severity == (errorsOnly ? DiagnosticSeverity.Error : DiagnosticSeverity.Warning))\n                    b.Add(item);\n            } 151937"];
7853 [label="return b.ToImmutableAndFree(); 151938"];
7854 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 151939"];
7855 [label="CustomAssert.Equal(0, statement.Errors().Length); 151940"];
7856 [label="var ss = (SwitchStatementSyntax)statement; 151941"];
7857 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 151942"];
7858 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 151943"];
7859 [label="ss.SwitchKeyword 151944"];
7860 [label="=> true 151945"];
7861 [label="true 151946"];
7862 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 151947"];
7863 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 151948"];
7864 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 151949"];
7865 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 151950"];
7866 [label="ss.SwitchKeyword 151951"];
7867 [label="=> true 151952"];
7868 [label="true 151953"];
7869 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 151954"];
7870 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 151955"];
7871 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 151956"];
7872 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 151957"];
7873 [label="ss.OpenParenToken 151958"];
7874 [label="=> true 151959"];
7875 [label="true 151960"];
7876 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 151961"];
7877 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 151962"];
7878 [label="CustomAssert.NotNull(ss.Expression); 151963"];
7879 [label="ss.Expression 151964"];
7880 [label="param CSharpSyntaxNode(GreenNode green) 151965"];
7881 [label="param CSharpSyntaxNode(SyntaxNode? parent) 151966"];
7882 [label="param CSharpSyntaxNode(int position) 151967"];
7883 [label="param CSharpSyntaxNode(this) 151968"];
7884 [label="param CSharpSyntaxNode(this) 151969"];
7885 [label="CustomAssert.Equal('a', ss.Expression.ToString()); 151970"];
7886 [label="ss.Expression.ToString() 151971"];
7887 [label="param ToString(this) 151972"];
7888 [label="this.Identifier.Text 151973"];
7889 [label="get { return this.TextField; } 151974"];
7890 [label="return this.Identifier.Text; 151975"];
7891 [label="CustomAssert.Equal('a', ss.Expression.ToString()); 151976"];
7892 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 151977"];
7893 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 151978"];
7894 [label="ss.CloseParenToken 151979"];
7895 [label="=> true 151980"];
7896 [label="true 151981"];
7897 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 151982"];
7898 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 151983"];
7899 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 151984"];
7900 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 151985"];
7901 [label="ss.OpenBraceToken 151986"];
7902 [label="=> true 151987"];
7903 [label="true 151988"];
7904 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 151989"];
7905 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 151990"];
7906 [label="CustomAssert.Equal(1, ss.Sections.Count); 151991"];
7907 [label="CustomAssert.Equal(1, ss.Sections.Count); 151992"];
7908 [label="ss.Sections 151993"];
7909 [label="param CSharpSyntaxNode(GreenNode green) 151994"];
7910 [label="param CSharpSyntaxNode(SyntaxNode? parent) 151995"];
7911 [label="param CSharpSyntaxNode(int position) 151996"];
7912 [label="param CSharpSyntaxNode(this) 151997"];
7913 [label="param CSharpSyntaxNode(this) 151998"];
7914 [label="CustomAssert.Equal(2, ss.Sections[0].Labels.Count); 151999"];
7915 [label="CustomAssert.Equal(2, ss.Sections[0].Labels.Count); 152000"];
7916 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 152001"];
7917 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 152002"];
7918 [label="ss.Sections[0].Labels[0].Keyword 152003"];
7919 [label="param CSharpSyntaxNode(GreenNode green) 152004"];
7920 [label="param CSharpSyntaxNode(SyntaxNode? parent) 152005"];
7921 [label="param CSharpSyntaxNode(int position) 152006"];
7922 [label="param CSharpSyntaxNode(this) 152007"];
7923 [label="param CSharpSyntaxNode(this) 152008"];
7924 [label="=> true 152009"];
7925 [label="true 152010"];
7926 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 152011"];
7927 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 152012"];
7928 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 152013"];
7929 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 152014"];
7930 [label="ss.Sections[0].Labels[0].Keyword 152015"];
7931 [label="=> true 152016"];
7932 [label="true 152017"];
7933 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 152018"];
7934 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 152019"];
7935 [label="var caseLabelSyntax = ss.Sections[0].Labels[0] as CaseSwitchLabelSyntax; 152020"];
7936 [label="var caseLabelSyntax = ss.Sections[0].Labels[0] as CaseSwitchLabelSyntax; 152021"];
7937 [label="CustomAssert.NotNull(caseLabelSyntax); 152022"];
7938 [label="CustomAssert.NotNull(caseLabelSyntax.Value); 152023"];
7939 [label="caseLabelSyntax.Value 152024"];
7940 [label="param CSharpSyntaxNode(GreenNode green) 152025"];
7941 [label="param CSharpSyntaxNode(SyntaxNode? parent) 152026"];
7942 [label="param CSharpSyntaxNode(int position) 152027"];
7943 [label="param CSharpSyntaxNode(this) 152028"];
7944 [label="param CSharpSyntaxNode(this) 152029"];
7945 [label="CustomAssert.Equal('b', caseLabelSyntax.Value.ToString()); 152030"];
7946 [label="caseLabelSyntax.Value.ToString() 152031"];
7947 [label="param ToString(this) 152032"];
7948 [label="this.Identifier.Text 152033"];
7949 [label="get { return this.TextField; } 152034"];
7950 [label="return this.Identifier.Text; 152035"];
7951 [label="CustomAssert.Equal('b', caseLabelSyntax.Value.ToString()); 152036"];
7952 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[1].Keyword); 152037"];
7953 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[1].Keyword); 152038"];
7954 [label="ss.Sections[0].Labels[1].Keyword 152039"];
7955 [label="param CSharpSyntaxNode(GreenNode green) 152040"];
7956 [label="param CSharpSyntaxNode(SyntaxNode? parent) 152041"];
7957 [label="param CSharpSyntaxNode(int position) 152042"];
7958 [label="param CSharpSyntaxNode(this) 152043"];
7959 [label="param CSharpSyntaxNode(this) 152044"];
7960 [label="=> true 152045"];
7961 [label="true 152046"];
7962 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[1].Keyword); 152047"];
7963 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[1].Keyword.Kind()); 152048"];
7964 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[1].Keyword.Kind()); 152049"];
7965 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[1].Keyword.Kind()); 152050"];
7966 [label="ss.Sections[0].Labels[1].Keyword 152051"];
7967 [label="=> true 152052"];
7968 [label="true 152053"];
7969 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[1].Keyword.Kind()); 152054"];
7970 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[1].Keyword.Kind()); 152055"];
7971 [label="var caseLabelSyntax2 = ss.Sections[0].Labels[1] as CaseSwitchLabelSyntax; 152056"];
7972 [label="var caseLabelSyntax2 = ss.Sections[0].Labels[1] as CaseSwitchLabelSyntax; 152057"];
7973 [label="CustomAssert.NotNull(caseLabelSyntax2); 152058"];
7974 [label="CustomAssert.NotNull(caseLabelSyntax2.Value); 152059"];
7975 [label="caseLabelSyntax2.Value 152060"];
7976 [label="param CSharpSyntaxNode(GreenNode green) 152061"];
7977 [label="param CSharpSyntaxNode(SyntaxNode? parent) 152062"];
7978 [label="param CSharpSyntaxNode(int position) 152063"];
7979 [label="param CSharpSyntaxNode(this) 152064"];
7980 [label="param CSharpSyntaxNode(this) 152065"];
7981 [label="CustomAssert.Equal('c', caseLabelSyntax2.Value.ToString()); 152066"];
7982 [label="caseLabelSyntax2.Value.ToString() 152067"];
7983 [label="param ToString(this) 152068"];
7984 [label="this.Identifier.Text 152069"];
7985 [label="get { return this.TextField; } 152070"];
7986 [label="return this.Identifier.Text; 152071"];
7987 [label="CustomAssert.Equal('c', caseLabelSyntax2.Value.ToString()); 152072"];
7988 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].ColonToken); 152073"];
7989 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].ColonToken); 152074"];
7990 [label="ss.Sections[0].Labels[0].ColonToken 152075"];
7991 [label="=> true 152076"];
7992 [label="true 152077"];
7993 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].ColonToken); 152078"];
7994 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].ColonToken); 152079"];
7995 [label="CustomAssert.Equal(1, ss.Sections[0].Statements.Count); 152080"];
7996 [label="CustomAssert.Equal(1, ss.Sections[0].Statements.Count); 152081"];
7997 [label="ss.Sections[0].Statements 152082"];
7998 [label="param CSharpSyntaxNode(GreenNode green) 152083"];
7999 [label="param CSharpSyntaxNode(SyntaxNode? parent) 152084"];
8000 [label="param CSharpSyntaxNode(int position) 152085"];
8001 [label="param CSharpSyntaxNode(this) 152086"];
8002 [label="param CSharpSyntaxNode(this) 152087"];
8003 [label="CustomAssert.Equal(';', ss.Sections[0].Statements[0].ToString()); 152088"];
8004 [label="CustomAssert.Equal(';', ss.Sections[0].Statements[0].ToString()); 152089"];
8005 [label="=> true 152090"];
8006 [label="true 152091"];
8007 [label="param WriteTokenTo(bool leading) 152092"];
8008 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 152093"];
8009 [label="this.Text 152094"];
8010 [label="this.Kind 152095"];
8011 [label="SyntaxFacts.GetText(this.Kind) 152096"];
8012 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 152097"];
8013 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 152098"];
8014 [label="ss.CloseBraceToken 152099"];
8015 [label="=> true 152100"];
8016 [label="true 152101"];
8017 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 152102"];
8018 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 152103"];
2 -> 0;
2 -> 1;
3 -> 1;
5 -> 4;
7 -> 6;
9 -> 8;
11 -> 10;
13 -> 12;
15 -> 14;
17 -> 16;
19 -> 18;
21 -> 20;
23 -> 22;
25 -> 24;
27 -> 26;
29 -> 28;
31 -> 30;
33 -> 32;
35 -> 34;
37 -> 36;
39 -> 38;
41 -> 40;
42 -> 0;
43 -> 0;
44 -> 42;
44 -> 43;
44 -> 0;
45 -> 44;
46 -> 0;
47 -> 0;
48 -> 46;
48 -> 47;
48 -> 44;
49 -> 48;
50 -> 0;
51 -> 50;
52 -> 51;
52 -> 50;
53 -> 52;
55 -> 0;
56 -> 54;
56 -> 55;
57 -> 56;
58 -> 0;
59 -> 0;
60 -> 58;
60 -> 59;
60 -> 0;
61 -> 60;
62 -> 0;
63 -> 0;
64 -> 62;
64 -> 63;
64 -> 48;
65 -> 64;
66 -> 0;
67 -> 0;
68 -> 66;
68 -> 67;
68 -> 64;
69 -> 68;
70 -> 0;
71 -> 0;
72 -> 70;
72 -> 71;
72 -> 68;
73 -> 72;
74 -> 0;
75 -> 0;
76 -> 74;
76 -> 75;
76 -> 0;
77 -> 76;
78 -> 0;
79 -> 0;
80 -> 78;
80 -> 79;
80 -> 0;
81 -> 80;
82 -> 0;
83 -> 0;
84 -> 82;
84 -> 83;
84 -> 0;
85 -> 84;
86 -> 0;
87 -> 0;
88 -> 86;
88 -> 87;
88 -> 72;
89 -> 88;
90 -> 0;
91 -> 0;
92 -> 90;
92 -> 91;
92 -> 0;
93 -> 92;
95 -> 0;
96 -> 94;
96 -> 95;
97 -> 96;
98 -> 0;
99 -> 0;
100 -> 98;
100 -> 99;
100 -> 88;
101 -> 100;
102 -> 0;
103 -> 0;
104 -> 102;
104 -> 103;
104 -> 0;
105 -> 104;
106 -> 0;
107 -> 0;
108 -> 106;
108 -> 107;
108 -> 0;
109 -> 108;
110 -> 0;
111 -> 0;
112 -> 110;
112 -> 111;
112 -> 0;
113 -> 112;
114 -> 0;
115 -> 0;
116 -> 114;
116 -> 115;
116 -> 0;
117 -> 116;
118 -> 0;
119 -> 0;
120 -> 118;
120 -> 119;
120 -> 0;
121 -> 120;
122 -> 0;
123 -> 0;
124 -> 122;
124 -> 123;
124 -> 100;
125 -> 124;
126 -> 0;
127 -> 0;
128 -> 126;
128 -> 127;
128 -> 124;
129 -> 128;
130 -> 0;
131 -> 0;
132 -> 130;
132 -> 131;
132 -> 128;
133 -> 132;
134 -> 0;
135 -> 0;
136 -> 134;
136 -> 135;
136 -> 132;
137 -> 136;
138 -> 0;
139 -> 0;
140 -> 138;
140 -> 139;
140 -> 0;
141 -> 140;
142 -> 0;
143 -> 0;
144 -> 142;
144 -> 143;
144 -> 0;
145 -> 144;
146 -> 0;
147 -> 0;
148 -> 146;
148 -> 147;
148 -> 136;
149 -> 148;
150 -> 0;
151 -> 0;
152 -> 150;
152 -> 151;
152 -> 0;
153 -> 152;
154 -> 0;
155 -> 0;
156 -> 154;
156 -> 155;
156 -> 0;
157 -> 156;
158 -> 0;
159 -> 0;
160 -> 158;
160 -> 159;
160 -> 0;
161 -> 160;
162 -> 0;
163 -> 0;
164 -> 162;
164 -> 163;
164 -> 148;
165 -> 164;
166 -> 0;
167 -> 0;
168 -> 166;
168 -> 167;
168 -> 0;
169 -> 168;
170 -> 0;
171 -> 0;
172 -> 170;
172 -> 171;
172 -> 0;
173 -> 172;
175 -> 174;
177 -> 175;
177 -> 176;
178 -> 177;
180 -> 0;
180 -> 179;
181 -> 180;
181 -> 0;
182 -> 181;
184 -> 183;
186 -> 185;
188 -> 187;
190 -> 189;
191 -> 1;
192 -> 1;
193 -> 191;
193 -> 1;
194 -> 193;
194 -> 192;
195 -> 192;
196 -> 195;
197 -> 196;
198 -> 197;
199 -> 198;
199 -> 197;
200 -> 195;
200 -> 192;
201 -> 195;
201 -> 192;
202 -> 195;
202 -> 192;
203 -> 194;
203 -> 195;
203 -> 192;
204 -> 1;
204 -> 2;
204 -> 199;
204 -> 200;
204 -> 201;
204 -> 203;
205 -> 1;
206 -> 1;
207 -> 206;
207 -> 1;
208 -> 1;
209 -> 1;
210 -> 207;
210 -> 209;
211 -> 208;
211 -> 209;
212 -> 208;
212 -> 209;
213 -> 205;
213 -> 209;
215 -> 214;
216 -> 215;
218 -> 216;
218 -> 217;
219 -> 217;
220 -> 217;
221 -> 218;
221 -> 217;
222 -> 219;
222 -> 221;
223 -> 0;
223 -> 222;
224 -> 217;
225 -> 223;
225 -> 224;
225 -> 217;
227 -> 0;
227 -> 217;
228 -> 218;
228 -> 217;
229 -> 217;
230 -> 227;
230 -> 229;
231 -> 228;
231 -> 229;
232 -> 230;
232 -> 229;
233 -> 231;
233 -> 229;
234 -> 229;
235 -> 229;
236 -> 232;
236 -> 235;
237 -> 233;
237 -> 235;
238 -> 234;
238 -> 235;
239 -> 234;
239 -> 235;
240 -> 234;
240 -> 235;
241 -> 236;
241 -> 235;
242 -> 238;
242 -> 235;
243 -> 239;
243 -> 235;
245 -> 244;
246 -> 237;
246 -> 235;
247 -> 235;
248 -> 241;
248 -> 247;
249 -> 242;
249 -> 247;
250 -> 243;
250 -> 247;
251 -> 246;
251 -> 247;
252 -> 240;
252 -> 247;
253 -> 248;
253 -> 247;
254 -> 249;
254 -> 247;
255 -> 250;
255 -> 247;
256 -> 251;
256 -> 247;
257 -> 247;
258 -> 257;
258 -> 253;
258 -> 254;
258 -> 255;
258 -> 256;
258 -> 247;
259 -> 257;
259 -> 247;
260 -> 259;
260 -> 258;
260 -> 247;
261 -> 240;
261 -> 235;
262 -> 237;
262 -> 240;
262 -> 235;
263 -> 236;
263 -> 0;
263 -> 235;
264 -> 234;
264 -> 217;
265 -> 219;
265 -> 217;
266 -> 264;
266 -> 265;
267 -> 266;
270 -> 268;
270 -> 269;
271 -> 269;
272 -> 269;
273 -> 270;
273 -> 269;
274 -> 271;
274 -> 273;
275 -> 0;
275 -> 274;
276 -> 269;
277 -> 275;
277 -> 276;
277 -> 269;
278 -> 0;
278 -> 269;
279 -> 270;
279 -> 269;
280 -> 269;
281 -> 278;
281 -> 280;
282 -> 279;
282 -> 280;
283 -> 281;
283 -> 280;
284 -> 282;
284 -> 280;
285 -> 280;
286 -> 280;
287 -> 283;
287 -> 286;
288 -> 284;
288 -> 286;
289 -> 285;
289 -> 286;
290 -> 285;
290 -> 286;
291 -> 285;
291 -> 286;
292 -> 287;
292 -> 286;
293 -> 289;
293 -> 286;
294 -> 290;
294 -> 286;
295 -> 288;
295 -> 286;
296 -> 286;
297 -> 292;
297 -> 296;
298 -> 293;
298 -> 296;
299 -> 294;
299 -> 296;
300 -> 295;
300 -> 296;
301 -> 291;
301 -> 296;
302 -> 297;
302 -> 296;
303 -> 298;
303 -> 296;
304 -> 299;
304 -> 296;
305 -> 300;
305 -> 296;
306 -> 296;
307 -> 306;
307 -> 302;
307 -> 303;
307 -> 304;
307 -> 305;
307 -> 296;
308 -> 306;
308 -> 296;
309 -> 308;
309 -> 307;
309 -> 296;
310 -> 291;
310 -> 286;
311 -> 288;
311 -> 291;
311 -> 286;
312 -> 287;
312 -> 0;
312 -> 286;
313 -> 285;
313 -> 269;
314 -> 271;
314 -> 269;
315 -> 313;
315 -> 314;
316 -> 315;
319 -> 317;
319 -> 318;
320 -> 318;
321 -> 318;
322 -> 319;
322 -> 318;
323 -> 320;
323 -> 322;
324 -> 0;
324 -> 323;
325 -> 318;
326 -> 324;
326 -> 325;
326 -> 318;
327 -> 0;
327 -> 318;
328 -> 319;
328 -> 318;
329 -> 318;
330 -> 327;
330 -> 329;
331 -> 328;
331 -> 329;
332 -> 330;
332 -> 329;
333 -> 331;
333 -> 329;
334 -> 329;
335 -> 329;
336 -> 332;
336 -> 335;
337 -> 333;
337 -> 335;
338 -> 334;
338 -> 335;
339 -> 334;
339 -> 335;
340 -> 334;
340 -> 335;
341 -> 336;
341 -> 335;
342 -> 338;
342 -> 335;
343 -> 339;
343 -> 335;
344 -> 337;
344 -> 335;
345 -> 335;
346 -> 341;
346 -> 345;
347 -> 342;
347 -> 345;
348 -> 343;
348 -> 345;
349 -> 344;
349 -> 345;
350 -> 340;
350 -> 345;
351 -> 346;
351 -> 345;
352 -> 347;
352 -> 345;
353 -> 348;
353 -> 345;
354 -> 349;
354 -> 345;
355 -> 345;
356 -> 355;
356 -> 351;
356 -> 352;
356 -> 353;
356 -> 354;
356 -> 345;
357 -> 355;
357 -> 345;
358 -> 357;
358 -> 356;
358 -> 345;
359 -> 340;
359 -> 335;
360 -> 337;
360 -> 340;
360 -> 335;
361 -> 336;
361 -> 0;
361 -> 335;
362 -> 334;
362 -> 318;
363 -> 320;
363 -> 318;
364 -> 362;
364 -> 363;
365 -> 364;
368 -> 366;
368 -> 367;
369 -> 367;
370 -> 0;
370 -> 367;
371 -> 368;
371 -> 367;
372 -> 367;
373 -> 370;
373 -> 372;
374 -> 371;
374 -> 372;
375 -> 373;
375 -> 372;
376 -> 374;
376 -> 372;
377 -> 372;
378 -> 372;
379 -> 375;
379 -> 378;
380 -> 376;
380 -> 378;
381 -> 377;
381 -> 378;
382 -> 377;
382 -> 378;
383 -> 377;
383 -> 378;
384 -> 379;
384 -> 378;
385 -> 381;
385 -> 378;
386 -> 382;
386 -> 378;
387 -> 380;
387 -> 378;
388 -> 378;
389 -> 384;
389 -> 388;
390 -> 385;
390 -> 388;
391 -> 386;
391 -> 388;
392 -> 387;
392 -> 388;
393 -> 383;
393 -> 388;
394 -> 389;
394 -> 388;
395 -> 390;
395 -> 388;
396 -> 391;
396 -> 388;
397 -> 392;
397 -> 388;
398 -> 388;
399 -> 398;
399 -> 394;
399 -> 395;
399 -> 396;
399 -> 397;
399 -> 388;
400 -> 398;
400 -> 388;
401 -> 400;
401 -> 399;
401 -> 388;
402 -> 383;
402 -> 378;
403 -> 380;
403 -> 383;
403 -> 378;
404 -> 379;
404 -> 0;
404 -> 378;
405 -> 377;
405 -> 367;
406 -> 369;
406 -> 367;
407 -> 405;
407 -> 406;
408 -> 407;
411 -> 409;
411 -> 410;
412 -> 410;
413 -> 0;
413 -> 410;
414 -> 411;
414 -> 410;
415 -> 410;
416 -> 413;
416 -> 415;
417 -> 414;
417 -> 415;
418 -> 416;
418 -> 415;
419 -> 417;
419 -> 415;
420 -> 415;
421 -> 415;
422 -> 418;
422 -> 421;
423 -> 419;
423 -> 421;
424 -> 420;
424 -> 421;
425 -> 420;
425 -> 421;
426 -> 420;
426 -> 421;
427 -> 422;
427 -> 421;
428 -> 424;
428 -> 421;
429 -> 425;
429 -> 421;
430 -> 423;
430 -> 421;
431 -> 421;
432 -> 427;
432 -> 431;
433 -> 428;
433 -> 431;
434 -> 429;
434 -> 431;
435 -> 430;
435 -> 431;
436 -> 426;
436 -> 431;
437 -> 432;
437 -> 431;
438 -> 433;
438 -> 431;
439 -> 434;
439 -> 431;
440 -> 435;
440 -> 431;
441 -> 431;
442 -> 441;
442 -> 437;
442 -> 438;
442 -> 439;
442 -> 440;
442 -> 431;
443 -> 441;
443 -> 431;
444 -> 443;
444 -> 442;
444 -> 431;
445 -> 426;
445 -> 421;
446 -> 423;
446 -> 426;
446 -> 421;
447 -> 422;
447 -> 0;
447 -> 421;
448 -> 420;
448 -> 410;
449 -> 412;
449 -> 410;
450 -> 448;
450 -> 449;
451 -> 450;
452 -> 215;
454 -> 453;
456 -> 452;
456 -> 455;
457 -> 454;
457 -> 455;
458 -> 455;
459 -> 456;
459 -> 455;
460 -> 457;
460 -> 459;
461 -> 0;
461 -> 460;
462 -> 455;
463 -> 461;
463 -> 462;
463 -> 455;
464 -> 0;
464 -> 455;
465 -> 456;
465 -> 455;
466 -> 455;
467 -> 464;
467 -> 466;
468 -> 465;
468 -> 466;
469 -> 467;
469 -> 466;
470 -> 468;
470 -> 466;
471 -> 466;
472 -> 466;
473 -> 469;
473 -> 472;
474 -> 470;
474 -> 472;
475 -> 471;
475 -> 472;
476 -> 471;
476 -> 472;
477 -> 471;
477 -> 472;
478 -> 473;
478 -> 472;
479 -> 475;
479 -> 472;
480 -> 476;
480 -> 472;
481 -> 474;
481 -> 472;
482 -> 472;
483 -> 478;
483 -> 482;
484 -> 479;
484 -> 482;
485 -> 480;
485 -> 482;
486 -> 481;
486 -> 482;
487 -> 477;
487 -> 482;
488 -> 483;
488 -> 482;
489 -> 484;
489 -> 482;
490 -> 485;
490 -> 482;
491 -> 486;
491 -> 482;
492 -> 482;
493 -> 492;
493 -> 488;
493 -> 489;
493 -> 490;
493 -> 491;
493 -> 482;
494 -> 492;
494 -> 482;
495 -> 494;
495 -> 493;
495 -> 482;
496 -> 477;
496 -> 472;
497 -> 474;
497 -> 477;
497 -> 472;
498 -> 473;
498 -> 0;
498 -> 472;
499 -> 471;
499 -> 455;
500 -> 457;
500 -> 455;
501 -> 499;
501 -> 455;
502 -> 455;
503 -> 0;
503 -> 502;
503 -> 455;
504 -> 501;
504 -> 502;
504 -> 495;
504 -> 496;
504 -> 497;
504 -> 503;
504 -> 0;
504 -> 455;
505 -> 504;
505 -> 502;
506 -> 504;
506 -> 502;
507 -> 502;
508 -> 506;
508 -> 507;
509 -> 508;
509 -> 504;
509 -> 507;
510 -> 509;
510 -> 502;
511 -> 506;
511 -> 504;
511 -> 502;
512 -> 505;
512 -> 502;
513 -> 502;
514 -> 502;
515 -> 510;
515 -> 514;
516 -> 511;
516 -> 514;
517 -> 511;
517 -> 514;
518 -> 512;
518 -> 514;
519 -> 513;
519 -> 514;
520 -> 514;
521 -> 519;
521 -> 520;
522 -> 520;
523 -> 522;
523 -> 515;
523 -> 517;
523 -> 518;
523 -> 516;
523 -> 511;
523 -> 520;
524 -> 522;
524 -> 520;
525 -> 519;
525 -> 514;
526 -> 515;
526 -> 0;
526 -> 514;
527 -> 523;
530 -> 529;
532 -> 528;
532 -> 531;
533 -> 530;
533 -> 531;
534 -> 531;
535 -> 532;
535 -> 531;
536 -> 533;
536 -> 535;
537 -> 0;
537 -> 536;
538 -> 531;
539 -> 537;
539 -> 538;
539 -> 531;
540 -> 0;
540 -> 531;
541 -> 532;
541 -> 531;
542 -> 531;
543 -> 540;
543 -> 542;
544 -> 541;
544 -> 542;
545 -> 543;
545 -> 542;
546 -> 544;
546 -> 542;
547 -> 542;
548 -> 542;
549 -> 545;
549 -> 548;
550 -> 546;
550 -> 548;
551 -> 547;
551 -> 548;
552 -> 547;
552 -> 548;
553 -> 547;
553 -> 548;
554 -> 549;
554 -> 548;
555 -> 551;
555 -> 548;
556 -> 552;
556 -> 548;
557 -> 550;
557 -> 548;
558 -> 548;
559 -> 554;
559 -> 558;
560 -> 555;
560 -> 558;
561 -> 556;
561 -> 558;
562 -> 557;
562 -> 558;
563 -> 553;
563 -> 558;
564 -> 559;
564 -> 558;
565 -> 560;
565 -> 558;
566 -> 561;
566 -> 558;
567 -> 562;
567 -> 558;
568 -> 558;
569 -> 568;
569 -> 564;
569 -> 565;
569 -> 566;
569 -> 567;
569 -> 558;
570 -> 568;
570 -> 558;
571 -> 570;
571 -> 569;
571 -> 558;
572 -> 553;
572 -> 548;
573 -> 550;
573 -> 553;
573 -> 548;
574 -> 549;
574 -> 0;
574 -> 548;
575 -> 547;
575 -> 531;
576 -> 533;
576 -> 531;
577 -> 575;
577 -> 531;
578 -> 531;
579 -> 0;
579 -> 578;
579 -> 531;
580 -> 577;
580 -> 578;
580 -> 571;
580 -> 572;
580 -> 573;
580 -> 579;
580 -> 523;
580 -> 531;
581 -> 578;
582 -> 578;
583 -> 578;
584 -> 582;
584 -> 583;
585 -> 583;
586 -> 584;
586 -> 585;
587 -> 585;
588 -> 587;
588 -> 585;
589 -> 584;
589 -> 583;
590 -> 580;
590 -> 0;
590 -> 583;
591 -> 580;
594 -> 593;
596 -> 592;
596 -> 595;
597 -> 594;
597 -> 595;
598 -> 595;
599 -> 596;
599 -> 595;
600 -> 597;
600 -> 599;
601 -> 0;
601 -> 600;
602 -> 595;
603 -> 601;
603 -> 602;
603 -> 595;
604 -> 0;
604 -> 595;
605 -> 596;
605 -> 595;
606 -> 595;
607 -> 604;
607 -> 606;
608 -> 605;
608 -> 606;
609 -> 607;
609 -> 606;
610 -> 608;
610 -> 606;
611 -> 606;
612 -> 606;
613 -> 609;
613 -> 612;
614 -> 610;
614 -> 612;
615 -> 611;
615 -> 612;
616 -> 611;
616 -> 612;
617 -> 611;
617 -> 612;
618 -> 613;
618 -> 612;
619 -> 615;
619 -> 612;
620 -> 616;
620 -> 612;
621 -> 614;
621 -> 612;
622 -> 612;
623 -> 618;
623 -> 622;
624 -> 619;
624 -> 622;
625 -> 620;
625 -> 622;
626 -> 621;
626 -> 622;
627 -> 617;
627 -> 622;
628 -> 623;
628 -> 622;
629 -> 624;
629 -> 622;
630 -> 625;
630 -> 622;
631 -> 626;
631 -> 622;
632 -> 622;
633 -> 632;
633 -> 628;
633 -> 629;
633 -> 630;
633 -> 631;
633 -> 622;
634 -> 632;
634 -> 622;
635 -> 634;
635 -> 633;
635 -> 622;
636 -> 617;
636 -> 612;
637 -> 614;
637 -> 617;
637 -> 612;
638 -> 613;
638 -> 0;
638 -> 612;
639 -> 611;
639 -> 595;
640 -> 597;
640 -> 595;
641 -> 639;
641 -> 595;
642 -> 595;
643 -> 0;
643 -> 642;
643 -> 595;
644 -> 641;
644 -> 642;
644 -> 635;
644 -> 636;
644 -> 637;
644 -> 643;
644 -> 580;
644 -> 595;
645 -> 642;
646 -> 642;
647 -> 642;
648 -> 646;
648 -> 647;
649 -> 647;
650 -> 648;
650 -> 649;
651 -> 649;
652 -> 651;
652 -> 649;
653 -> 648;
653 -> 647;
654 -> 644;
654 -> 0;
654 -> 647;
655 -> 644;
658 -> 657;
660 -> 656;
660 -> 659;
661 -> 658;
661 -> 659;
662 -> 0;
662 -> 659;
663 -> 660;
663 -> 659;
664 -> 659;
665 -> 662;
665 -> 664;
666 -> 663;
666 -> 664;
667 -> 665;
667 -> 664;
668 -> 666;
668 -> 664;
669 -> 664;
670 -> 664;
671 -> 667;
671 -> 670;
672 -> 668;
672 -> 670;
673 -> 669;
673 -> 670;
674 -> 669;
674 -> 670;
675 -> 669;
675 -> 670;
676 -> 671;
676 -> 670;
677 -> 673;
677 -> 670;
678 -> 674;
678 -> 670;
679 -> 672;
679 -> 670;
680 -> 670;
681 -> 676;
681 -> 680;
682 -> 677;
682 -> 680;
683 -> 678;
683 -> 680;
684 -> 679;
684 -> 680;
685 -> 675;
685 -> 680;
686 -> 681;
686 -> 680;
687 -> 682;
687 -> 680;
688 -> 683;
688 -> 680;
689 -> 684;
689 -> 680;
690 -> 680;
691 -> 690;
691 -> 686;
691 -> 687;
691 -> 688;
691 -> 689;
691 -> 680;
692 -> 690;
692 -> 680;
693 -> 692;
693 -> 691;
693 -> 680;
694 -> 675;
694 -> 670;
695 -> 672;
695 -> 675;
695 -> 670;
696 -> 671;
696 -> 0;
696 -> 670;
697 -> 669;
697 -> 659;
698 -> 661;
698 -> 659;
699 -> 697;
699 -> 659;
700 -> 659;
701 -> 0;
701 -> 700;
701 -> 659;
702 -> 699;
702 -> 700;
702 -> 693;
702 -> 694;
702 -> 695;
702 -> 701;
702 -> 644;
702 -> 659;
703 -> 700;
704 -> 700;
705 -> 700;
706 -> 704;
706 -> 705;
707 -> 705;
708 -> 706;
708 -> 707;
709 -> 707;
710 -> 709;
710 -> 707;
711 -> 706;
711 -> 705;
712 -> 702;
712 -> 0;
712 -> 705;
713 -> 702;
716 -> 715;
718 -> 714;
718 -> 717;
719 -> 716;
719 -> 717;
720 -> 0;
720 -> 717;
721 -> 718;
721 -> 717;
722 -> 717;
723 -> 720;
723 -> 722;
724 -> 721;
724 -> 722;
725 -> 723;
725 -> 722;
726 -> 724;
726 -> 722;
727 -> 722;
728 -> 722;
729 -> 725;
729 -> 728;
730 -> 726;
730 -> 728;
731 -> 727;
731 -> 728;
732 -> 727;
732 -> 728;
733 -> 727;
733 -> 728;
734 -> 729;
734 -> 728;
735 -> 731;
735 -> 728;
736 -> 732;
736 -> 728;
737 -> 730;
737 -> 728;
738 -> 728;
739 -> 734;
739 -> 738;
740 -> 735;
740 -> 738;
741 -> 736;
741 -> 738;
742 -> 737;
742 -> 738;
743 -> 733;
743 -> 738;
744 -> 739;
744 -> 738;
745 -> 740;
745 -> 738;
746 -> 741;
746 -> 738;
747 -> 742;
747 -> 738;
748 -> 738;
749 -> 748;
749 -> 744;
749 -> 745;
749 -> 746;
749 -> 747;
749 -> 738;
750 -> 748;
750 -> 738;
751 -> 750;
751 -> 749;
751 -> 738;
752 -> 733;
752 -> 728;
753 -> 730;
753 -> 733;
753 -> 728;
754 -> 729;
754 -> 0;
754 -> 728;
755 -> 727;
755 -> 717;
756 -> 719;
756 -> 717;
757 -> 755;
757 -> 717;
758 -> 717;
759 -> 0;
759 -> 758;
759 -> 717;
760 -> 757;
760 -> 758;
760 -> 751;
760 -> 752;
760 -> 753;
760 -> 759;
760 -> 702;
760 -> 717;
761 -> 758;
762 -> 758;
763 -> 758;
764 -> 762;
764 -> 763;
765 -> 763;
766 -> 764;
766 -> 765;
767 -> 765;
768 -> 767;
768 -> 765;
769 -> 764;
769 -> 763;
770 -> 760;
770 -> 0;
770 -> 763;
771 -> 760;
772 -> 0;
774 -> 773;
776 -> 772;
776 -> 775;
777 -> 774;
777 -> 775;
778 -> 0;
778 -> 775;
779 -> 776;
779 -> 775;
780 -> 775;
781 -> 778;
781 -> 780;
782 -> 779;
782 -> 780;
783 -> 781;
783 -> 780;
784 -> 782;
784 -> 780;
785 -> 780;
786 -> 780;
787 -> 783;
787 -> 786;
788 -> 784;
788 -> 786;
789 -> 785;
789 -> 786;
790 -> 785;
790 -> 786;
791 -> 785;
791 -> 786;
792 -> 787;
792 -> 786;
793 -> 789;
793 -> 786;
794 -> 790;
794 -> 786;
795 -> 788;
795 -> 786;
796 -> 786;
797 -> 792;
797 -> 796;
798 -> 793;
798 -> 796;
799 -> 794;
799 -> 796;
800 -> 795;
800 -> 796;
801 -> 791;
801 -> 796;
802 -> 797;
802 -> 796;
803 -> 798;
803 -> 796;
804 -> 799;
804 -> 796;
805 -> 800;
805 -> 796;
806 -> 796;
807 -> 806;
807 -> 802;
807 -> 803;
807 -> 804;
807 -> 805;
807 -> 796;
808 -> 806;
808 -> 796;
809 -> 808;
809 -> 807;
809 -> 796;
810 -> 791;
810 -> 786;
811 -> 788;
811 -> 791;
811 -> 786;
812 -> 787;
812 -> 0;
812 -> 786;
813 -> 785;
813 -> 775;
814 -> 777;
814 -> 775;
815 -> 813;
815 -> 775;
816 -> 775;
817 -> 0;
817 -> 816;
817 -> 775;
818 -> 815;
818 -> 816;
818 -> 809;
818 -> 810;
818 -> 811;
818 -> 817;
818 -> 760;
818 -> 775;
819 -> 816;
820 -> 816;
821 -> 816;
822 -> 820;
822 -> 821;
823 -> 821;
824 -> 822;
824 -> 823;
825 -> 823;
826 -> 825;
826 -> 823;
827 -> 822;
827 -> 821;
828 -> 818;
828 -> 0;
828 -> 821;
829 -> 818;
832 -> 267;
832 -> 831;
833 -> 831;
834 -> 832;
834 -> 831;
835 -> 833;
835 -> 834;
835 -> 260;
835 -> 261;
835 -> 262;
835 -> 831;
837 -> 316;
837 -> 836;
838 -> 836;
839 -> 837;
839 -> 836;
840 -> 838;
840 -> 839;
840 -> 309;
840 -> 310;
840 -> 311;
840 -> 836;
842 -> 365;
842 -> 841;
843 -> 841;
844 -> 842;
844 -> 841;
845 -> 843;
845 -> 844;
845 -> 358;
845 -> 359;
845 -> 360;
845 -> 841;
847 -> 408;
847 -> 846;
848 -> 846;
849 -> 847;
849 -> 846;
850 -> 848;
850 -> 849;
850 -> 401;
850 -> 402;
850 -> 403;
850 -> 846;
852 -> 451;
852 -> 851;
853 -> 851;
854 -> 852;
854 -> 851;
855 -> 853;
855 -> 854;
855 -> 444;
855 -> 445;
855 -> 446;
855 -> 851;
857 -> 527;
857 -> 856;
858 -> 856;
859 -> 857;
859 -> 856;
860 -> 858;
860 -> 859;
860 -> 818;
860 -> 856;
862 -> 591;
862 -> 861;
863 -> 861;
864 -> 862;
864 -> 861;
865 -> 863;
865 -> 864;
865 -> 860;
865 -> 861;
867 -> 655;
867 -> 866;
868 -> 866;
869 -> 867;
869 -> 866;
870 -> 868;
870 -> 869;
870 -> 865;
870 -> 866;
872 -> 713;
872 -> 871;
873 -> 871;
874 -> 872;
874 -> 871;
875 -> 873;
875 -> 874;
875 -> 870;
875 -> 871;
877 -> 771;
877 -> 876;
878 -> 876;
879 -> 877;
879 -> 876;
880 -> 878;
880 -> 879;
880 -> 875;
880 -> 876;
882 -> 829;
882 -> 881;
883 -> 881;
884 -> 882;
884 -> 881;
885 -> 883;
885 -> 884;
885 -> 880;
885 -> 881;
886 -> 210;
886 -> 209;
887 -> 211;
887 -> 209;
888 -> 212;
888 -> 209;
889 -> 209;
890 -> 209;
891 -> 886;
891 -> 890;
892 -> 887;
892 -> 890;
893 -> 888;
893 -> 890;
894 -> 889;
894 -> 890;
895 -> 891;
895 -> 890;
896 -> 892;
896 -> 890;
897 -> 893;
897 -> 890;
898 -> 890;
899 -> 895;
899 -> 898;
900 -> 896;
900 -> 898;
901 -> 897;
901 -> 898;
902 -> 899;
902 -> 898;
903 -> 900;
903 -> 898;
904 -> 898;
905 -> 902;
905 -> 904;
906 -> 903;
906 -> 904;
907 -> 905;
907 -> 904;
908 -> 0;
908 -> 904;
909 -> 904;
910 -> 906;
910 -> 904;
911 -> 907;
911 -> 910;
911 -> 904;
913 -> 912;
916 -> 915;
918 -> 917;
929 -> 920;
929 -> 919;
930 -> 921;
930 -> 919;
931 -> 922;
931 -> 919;
932 -> 923;
932 -> 919;
933 -> 924;
933 -> 919;
934 -> 925;
934 -> 919;
935 -> 926;
935 -> 919;
936 -> 927;
936 -> 919;
937 -> 928;
937 -> 919;
938 -> 919;
940 -> 939;
941 -> 0;
941 -> 898;
942 -> 941;
942 -> 901;
942 -> 898;
943 -> 898;
944 -> 898;
945 -> 911;
945 -> 944;
946 -> 942;
946 -> 944;
947 -> 943;
947 -> 944;
948 -> 943;
948 -> 944;
949 -> 943;
949 -> 944;
950 -> 945;
950 -> 944;
951 -> 944;
952 -> 950;
952 -> 951;
953 -> 949;
953 -> 951;
954 -> 953;
954 -> 951;
955 -> 953;
955 -> 951;
956 -> 0;
958 -> 957;
960 -> 959;
961 -> 960;
962 -> 952;
962 -> 951;
963 -> 951;
964 -> 951;
965 -> 962;
965 -> 964;
966 -> 963;
966 -> 964;
967 -> 966;
967 -> 964;
968 -> 966;
968 -> 964;
969 -> 966;
969 -> 964;
970 -> 966;
970 -> 964;
971 -> 966;
971 -> 964;
972 -> 966;
972 -> 964;
973 -> 966;
973 -> 964;
974 -> 966;
974 -> 964;
975 -> 965;
975 -> 966;
975 -> 964;
976 -> 964;
977 -> 976;
977 -> 966;
977 -> 964;
978 -> 964;
979 -> 978;
979 -> 966;
979 -> 964;
980 -> 965;
980 -> 911;
980 -> 966;
980 -> 964;
981 -> 964;
982 -> 981;
982 -> 966;
982 -> 964;
983 -> 961;
983 -> 960;
983 -> 964;
984 -> 983;
984 -> 966;
984 -> 964;
985 -> 964;
986 -> 985;
986 -> 966;
986 -> 964;
987 -> 963;
987 -> 953;
987 -> 951;
988 -> 949;
988 -> 944;
989 -> 949;
989 -> 944;
990 -> 949;
990 -> 944;
991 -> 949;
991 -> 944;
992 -> 949;
992 -> 944;
993 -> 949;
993 -> 944;
994 -> 949;
994 -> 944;
995 -> 949;
995 -> 944;
996 -> 949;
996 -> 944;
997 -> 949;
997 -> 944;
998 -> 944;
999 -> 998;
999 -> 944;
1000 -> 999;
1000 -> 949;
1000 -> 944;
1001 -> 944;
1002 -> 1001;
1002 -> 944;
1003 -> 1002;
1003 -> 949;
1003 -> 944;
1004 -> 949;
1004 -> 944;
1005 -> 949;
1005 -> 944;
1006 -> 944;
1007 -> 946;
1007 -> 1006;
1007 -> 944;
1008 -> 946;
1008 -> 949;
1008 -> 944;
1009 -> 944;
1010 -> 1009;
1010 -> 949;
1010 -> 944;
1011 -> 944;
1012 -> 1011;
1012 -> 949;
1012 -> 944;
1015 -> 1013;
1015 -> 1014;
1016 -> 1015;
1018 -> 1017;
1019 -> 944;
1020 -> 944;
1021 -> 1019;
1021 -> 1020;
1022 -> 1021;
1022 -> 1020;
1023 -> 1021;
1023 -> 1020;
1024 -> 1021;
1024 -> 1020;
1025 -> 1020;
1026 -> 1025;
1026 -> 1021;
1026 -> 1020;
1027 -> 1020;
1028 -> 1027;
1028 -> 1021;
1028 -> 1020;
1029 -> 1016;
1029 -> 1015;
1029 -> 1020;
1030 -> 1029;
1030 -> 1021;
1030 -> 1020;
1031 -> 1019;
1031 -> 949;
1031 -> 944;
1032 -> 949;
1032 -> 944;
1033 -> 947;
1033 -> 949;
1033 -> 944;
1034 -> 948;
1034 -> 949;
1034 -> 944;
1035 -> 943;
1035 -> 890;
1036 -> 1035;
1036 -> 890;
1037 -> 890;
1038 -> 1036;
1038 -> 1037;
1039 -> 0;
1040 -> 1038;
1040 -> 1037;
1041 -> 1037;
1042 -> 1037;
1043 -> 1040;
1043 -> 1042;
1044 -> 1041;
1044 -> 1042;
1045 -> 1041;
1045 -> 1042;
1046 -> 1041;
1046 -> 1042;
1047 -> 1041;
1047 -> 1042;
1048 -> 1041;
1048 -> 1042;
1051 -> 1049;
1051 -> 1050;
1052 -> 1051;
1053 -> 1043;
1053 -> 1042;
1054 -> 1046;
1054 -> 1042;
1055 -> 1044;
1055 -> 1042;
1056 -> 1045;
1056 -> 1042;
1057 -> 1042;
1058 -> 1042;
1059 -> 1047;
1059 -> 1042;
1060 -> 1042;
1061 -> 1053;
1061 -> 1060;
1062 -> 1054;
1062 -> 1060;
1063 -> 1055;
1063 -> 1060;
1064 -> 1056;
1064 -> 1060;
1065 -> 1057;
1065 -> 1060;
1066 -> 1058;
1066 -> 1060;
1067 -> 1059;
1067 -> 1060;
1068 -> 1048;
1068 -> 1060;
1069 -> 1068;
1069 -> 1060;
1070 -> 1068;
1070 -> 1060;
1071 -> 1068;
1071 -> 1060;
1072 -> 1068;
1072 -> 1060;
1073 -> 1068;
1073 -> 1060;
1074 -> 1068;
1074 -> 1060;
1075 -> 1068;
1075 -> 1060;
1076 -> 1068;
1076 -> 1060;
1077 -> 1068;
1077 -> 1060;
1078 -> 1068;
1078 -> 1060;
1079 -> 1068;
1079 -> 1060;
1080 -> 1068;
1080 -> 1060;
1081 -> 1068;
1081 -> 1060;
1082 -> 1061;
1082 -> 1068;
1082 -> 1060;
1083 -> 1062;
1083 -> 1068;
1083 -> 1060;
1084 -> 1065;
1084 -> 1068;
1084 -> 1060;
1085 -> 1067;
1085 -> 1068;
1085 -> 1060;
1086 -> 1060;
1087 -> 1086;
1087 -> 1068;
1087 -> 1060;
1088 -> 1060;
1089 -> 1063;
1089 -> 1088;
1089 -> 1060;
1090 -> 1089;
1090 -> 1068;
1090 -> 1060;
1091 -> 1060;
1092 -> 1068;
1092 -> 1091;
1093 -> 1092;
1093 -> 1090;
1093 -> 1091;
1094 -> 1093;
1094 -> 1060;
1095 -> 1094;
1095 -> 1065;
1095 -> 1060;
1096 -> 1095;
1097 -> 1096;
1097 -> 1068;
1097 -> 1095;
1098 -> 1095;
1099 -> 1098;
1099 -> 1068;
1099 -> 1095;
1100 -> 1060;
1101 -> 1068;
1101 -> 1100;
1102 -> 1101;
1102 -> 1090;
1102 -> 1100;
1103 -> 1102;
1103 -> 1060;
1104 -> 1066;
1104 -> 1103;
1104 -> 1060;
1105 -> 1104;
1105 -> 1067;
1105 -> 1041;
1105 -> 1060;
1106 -> 1105;
1107 -> 1068;
1107 -> 1106;
1108 -> 1106;
1109 -> 1106;
1110 -> 1107;
1110 -> 1082;
1110 -> 987;
1110 -> 1109;
1111 -> 1110;
1111 -> 975;
1111 -> 1109;
1112 -> 1111;
1112 -> 1106;
1113 -> 1112;
1113 -> 1106;
1114 -> 1113;
1114 -> 1107;
1114 -> 1106;
1115 -> 1107;
1115 -> 1082;
1115 -> 1106;
1116 -> 1107;
1116 -> 1083;
1116 -> 1106;
1117 -> 1106;
1118 -> 1117;
1118 -> 1112;
1118 -> 1106;
1119 -> 1116;
1119 -> 1118;
1120 -> 1118;
1121 -> 1119;
1121 -> 1120;
1122 -> 1115;
1122 -> 1120;
1123 -> 914;
1123 -> 1120;
1124 -> 1121;
1124 -> 1122;
1124 -> 1120;
1125 -> 1122;
1125 -> 1124;
1125 -> 1120;
1126 -> 1122;
1126 -> 987;
1126 -> 955;
1126 -> 1008;
1126 -> 1124;
1126 -> 1010;
1126 -> 1012;
1126 -> 992;
1126 -> 1031;
1126 -> 1033;
1126 -> 1034;
1126 -> 996;
1126 -> 997;
1126 -> 1000;
1126 -> 1003;
1126 -> 1004;
1126 -> 1032;
1126 -> 975;
1126 -> 977;
1126 -> 979;
1126 -> 980;
1126 -> 984;
1126 -> 972;
1126 -> 986;
1126 -> 982;
1126 -> 911;
1126 -> 999;
1126 -> 1002;
1126 -> 0;
1126 -> 1009;
1126 -> 1011;
1126 -> 1026;
1126 -> 1028;
1126 -> 1030;
1126 -> 1029;
1126 -> 1027;
1126 -> 1025;
1126 -> 981;
1126 -> 983;
1126 -> 1125;
1127 -> 1125;
1128 -> 1126;
1128 -> 1127;
1129 -> 1127;
1130 -> 1128;
1130 -> 1126;
1130 -> 1129;
1131 -> 1130;
1131 -> 1126;
1131 -> 1129;
1132 -> 1127;
1133 -> 1127;
1134 -> 1133;
1134 -> 1128;
1134 -> 1127;
1135 -> 1126;
1135 -> 1127;
1136 -> 1135;
1136 -> 1126;
1136 -> 1127;
1137 -> 1126;
1137 -> 1136;
1137 -> 1131;
1137 -> 1134;
1137 -> 1125;
1138 -> 1126;
1138 -> 1127;
1139 -> 1138;
1139 -> 1137;
1139 -> 1127;
1140 -> 1126;
1140 -> 1127;
1141 -> 1140;
1141 -> 1139;
1141 -> 1127;
1142 -> 1126;
1142 -> 1127;
1143 -> 1126;
1143 -> 1127;
1144 -> 1143;
1144 -> 1141;
1144 -> 1142;
1144 -> 1127;
1145 -> 1144;
1145 -> 1143;
1145 -> 1127;
1146 -> 1126;
1146 -> 1127;
1147 -> 1146;
1147 -> 1141;
1147 -> 1127;
1148 -> 1126;
1148 -> 1147;
1148 -> 1141;
1148 -> 1145;
1148 -> 1125;
1149 -> 1126;
1149 -> 1127;
1150 -> 1126;
1150 -> 1127;
1151 -> 1149;
1151 -> 1150;
1151 -> 1148;
1151 -> 1127;
1152 -> 1127;
1153 -> 1151;
1153 -> 1152;
1153 -> 1127;
1154 -> 1151;
1154 -> 1150;
1154 -> 1148;
1154 -> 1127;
1155 -> 1151;
1155 -> 1150;
1155 -> 1153;
1156 -> 1125;
1157 -> 1122;
1157 -> 1156;
1158 -> 1157;
1158 -> 1155;
1158 -> 1156;
1159 -> 1156;
1160 -> 1157;
1160 -> 1158;
1160 -> 1159;
1161 -> 1160;
1161 -> 1158;
1161 -> 1159;
1162 -> 1161;
1162 -> 1156;
1163 -> 1156;
1164 -> 1157;
1164 -> 1158;
1164 -> 1156;
1165 -> 1156;
1166 -> 1162;
1166 -> 1165;
1167 -> 1163;
1167 -> 1165;
1168 -> 1164;
1168 -> 1165;
1169 -> 1157;
1169 -> 1165;
1170 -> 1167;
1170 -> 1165;
1171 -> 1165;
1172 -> 1171;
1173 -> 1169;
1173 -> 1172;
1174 -> 1172;
1175 -> 1173;
1175 -> 1158;
1175 -> 1174;
1176 -> 1172;
1177 -> 1172;
1178 -> 1177;
1178 -> 1173;
1178 -> 1172;
1179 -> 1171;
1180 -> 1171;
1181 -> 1169;
1181 -> 1158;
1181 -> 1180;
1182 -> 1181;
1182 -> 1158;
1182 -> 1180;
1183 -> 1180;
1184 -> 1181;
1184 -> 1183;
1185 -> 1184;
1185 -> 1158;
1185 -> 1183;
1186 -> 1185;
1187 -> 1184;
1187 -> 1186;
1188 -> 1187;
1188 -> 1158;
1188 -> 1186;
1189 -> 1188;
1189 -> 1185;
1190 -> 1185;
1191 -> 1184;
1191 -> 1158;
1191 -> 1175;
1191 -> 1190;
1191 -> 1185;
1192 -> 1184;
1192 -> 1158;
1192 -> 1175;
1192 -> 1178;
1192 -> 1185;
1193 -> 1184;
1193 -> 1158;
1193 -> 1185;
1194 -> 1184;
1194 -> 1158;
1194 -> 1175;
1194 -> 1178;
1194 -> 1185;
1195 -> 1184;
1195 -> 1158;
1195 -> 1185;
1196 -> 1194;
1196 -> 1185;
1197 -> 1184;
1197 -> 1196;
1197 -> 1194;
1197 -> 1185;
1198 -> 1197;
1198 -> 1184;
1198 -> 1185;
1199 -> 1185;
1200 -> 1194;
1200 -> 1199;
1200 -> 1185;
1201 -> 1200;
1201 -> 1180;
1202 -> 1181;
1202 -> 1196;
1202 -> 1198;
1202 -> 1180;
1203 -> 1202;
1203 -> 1171;
1204 -> 1171;
1205 -> 1203;
1205 -> 1204;
1205 -> 1171;
1206 -> 1205;
1207 -> 1203;
1207 -> 1171;
1208 -> 1207;
1209 -> 1157;
1209 -> 1196;
1209 -> 1168;
1209 -> 1156;
1210 -> 1156;
1211 -> 1156;
1212 -> 1157;
1212 -> 1211;
1213 -> 1211;
1214 -> 1212;
1214 -> 1196;
1214 -> 1213;
1215 -> 1211;
1216 -> 1211;
1217 -> 1216;
1217 -> 1212;
1217 -> 1211;
1218 -> 1156;
1219 -> 1210;
1219 -> 1156;
1220 -> 1219;
1220 -> 1157;
1220 -> 1196;
1220 -> 1198;
1220 -> 1168;
1220 -> 1214;
1220 -> 1217;
1220 -> 1210;
1220 -> 1156;
1221 -> 1156;
1222 -> 1220;
1222 -> 1221;
1223 -> 1222;
1223 -> 1220;
1223 -> 1221;
1224 -> 1220;
1224 -> 1223;
1224 -> 1221;
1225 -> 1220;
1225 -> 1223;
1225 -> 1221;
1226 -> 1220;
1226 -> 1221;
1227 -> 1220;
1227 -> 1221;
1228 -> 0;
1228 -> 1226;
1228 -> 1221;
1229 -> 1226;
1229 -> 1221;
1230 -> 1221;
1231 -> 1229;
1231 -> 1230;
1232 -> 1227;
1232 -> 1230;
1233 -> 1231;
1233 -> 1230;
1234 -> 1233;
1234 -> 1232;
1234 -> 1225;
1234 -> 1228;
1234 -> 1230;
1235 -> 1230;
1236 -> 1234;
1236 -> 1235;
1237 -> 1234;
1237 -> 1235;
1238 -> 1234;
1238 -> 1235;
1239 -> 1234;
1239 -> 1235;
1240 -> 1236;
1240 -> 1235;
1241 -> 1237;
1241 -> 1235;
1242 -> 1238;
1242 -> 1235;
1243 -> 1239;
1243 -> 1234;
1243 -> 1240;
1243 -> 1241;
1243 -> 1242;
1243 -> 1235;
1244 -> 1243;
1245 -> 0;
1245 -> 1244;
1246 -> 1244;
1247 -> 1245;
1247 -> 1246;
1248 -> 1227;
1248 -> 1246;
1249 -> 1248;
1249 -> 1243;
1249 -> 1246;
1250 -> 1246;
1251 -> 1249;
1251 -> 1250;
1252 -> 1251;
1252 -> 0;
1252 -> 1250;
1253 -> 1252;
1253 -> 1247;
1253 -> 1246;
1254 -> 1243;
1254 -> 1253;
1255 -> 1253;
1256 -> 1254;
1256 -> 1255;
1257 -> 1254;
1257 -> 1255;
1258 -> 1227;
1258 -> 1243;
1258 -> 1255;
1259 -> 1256;
1259 -> 1018;
1259 -> 1255;
1261 -> 1260;
1262 -> 1260;
1263 -> 1256;
1263 -> 1255;
1264 -> 1263;
1264 -> 1258;
1264 -> 1243;
1264 -> 1255;
1265 -> 1255;
1266 -> 1264;
1266 -> 1265;
1267 -> 1266;
1267 -> 1265;
1268 -> 0;
1268 -> 1267;
1269 -> 1268;
1269 -> 0;
1269 -> 1255;
1270 -> 1243;
1270 -> 1268;
1270 -> 1269;
1271 -> 1269;
1272 -> 1270;
1272 -> 1271;
1273 -> 1272;
1273 -> 1271;
1274 -> 1273;
1275 -> 1243;
1275 -> 1268;
1275 -> 0;
1275 -> 1244;
1276 -> 1243;
1277 -> 1243;
1277 -> 1276;
1277 -> 1268;
1277 -> 1156;
1278 -> 1209;
1278 -> 1156;
1279 -> 1156;
1280 -> 1278;
1280 -> 1279;
1281 -> 1279;
1282 -> 1279;
1283 -> 1280;
1283 -> 1282;
1283 -> 1279;
1284 -> 1283;
1285 -> 1284;
1285 -> 1280;
1285 -> 1277;
1285 -> 1283;
1286 -> 1281;
1286 -> 1279;
1287 -> 1286;
1287 -> 1156;
1288 -> 1156;
1289 -> 1287;
1289 -> 1288;
1290 -> 1157;
1290 -> 1288;
1291 -> 1288;
1292 -> 1290;
1292 -> 1277;
1292 -> 1291;
1292 -> 1288;
1293 -> 1292;
1294 -> 1293;
1294 -> 1156;
1295 -> 1157;
1295 -> 1277;
1295 -> 1156;
1296 -> 1156;
1297 -> 1157;
1297 -> 1295;
1297 -> 1156;
1298 -> 1156;
1299 -> 1296;
1299 -> 1298;
1300 -> 1296;
1300 -> 1298;
1301 -> 1297;
1301 -> 1298;
1302 -> 1157;
1302 -> 1298;
1303 -> 1300;
1303 -> 1298;
1304 -> 1298;
1305 -> 1304;
1306 -> 1302;
1306 -> 1305;
1307 -> 1305;
1308 -> 1306;
1308 -> 1295;
1308 -> 1307;
1309 -> 1305;
1310 -> 1305;
1311 -> 1310;
1311 -> 1306;
1311 -> 1305;
1312 -> 1304;
1313 -> 1304;
1314 -> 1302;
1314 -> 1295;
1314 -> 1313;
1315 -> 1314;
1315 -> 1295;
1315 -> 1313;
1316 -> 1314;
1316 -> 1304;
1317 -> 1304;
1318 -> 1316;
1318 -> 1317;
1318 -> 1304;
1319 -> 1302;
1319 -> 1295;
1319 -> 1308;
1319 -> 1311;
1319 -> 1318;
1320 -> 1318;
1321 -> 1319;
1321 -> 1320;
1322 -> 1319;
1322 -> 1320;
1323 -> 1322;
1323 -> 1319;
1323 -> 1320;
1324 -> 1319;
1324 -> 1323;
1324 -> 1320;
1325 -> 1319;
1325 -> 1320;
1326 -> 1325;
1326 -> 1323;
1326 -> 1320;
1327 -> 1301;
1327 -> 1318;
1328 -> 1318;
1329 -> 1326;
1329 -> 1328;
1330 -> 1327;
1330 -> 1328;
1331 -> 1302;
1331 -> 1328;
1332 -> 1328;
1333 -> 1331;
1333 -> 1332;
1334 -> 1332;
1335 -> 1333;
1335 -> 1326;
1335 -> 1334;
1335 -> 1332;
1336 -> 1335;
1336 -> 1328;
1337 -> 1328;
1338 -> 1330;
1338 -> 1337;
1338 -> 1328;
1339 -> 1329;
1339 -> 1328;
1340 -> 1330;
1340 -> 1339;
1340 -> 1326;
1340 -> 1328;
1341 -> 1340;
1341 -> 1313;
1342 -> 1340;
1343 -> 1340;
1343 -> 1304;
1344 -> 1343;
1345 -> 1157;
1345 -> 1340;
1345 -> 1330;
1345 -> 1156;
1346 -> 1277;
1346 -> 1156;
1347 -> 1209;
1347 -> 1156;
1348 -> 1345;
1348 -> 1156;
1349 -> 1294;
1349 -> 1156;
1350 -> 1156;
1351 -> 1346;
1351 -> 1350;
1352 -> 1347;
1352 -> 1350;
1353 -> 1348;
1353 -> 1350;
1354 -> 1349;
1354 -> 1350;
1355 -> 1157;
1355 -> 1350;
1356 -> 1351;
1356 -> 1277;
1356 -> 0;
1356 -> 1350;
1357 -> 1352;
1357 -> 1340;
1357 -> 1311;
1357 -> 1330;
1357 -> 1350;
1358 -> 1353;
1358 -> 1357;
1358 -> 1350;
1359 -> 1350;
1360 -> 1351;
1360 -> 1277;
1360 -> 1350;
1361 -> 1351;
1361 -> 1277;
1361 -> 1360;
1362 -> 1351;
1362 -> 1277;
1362 -> 1361;
1363 -> 1361;
1364 -> 1362;
1364 -> 1363;
1365 -> 1364;
1365 -> 0;
1365 -> 1363;
1366 -> 1357;
1366 -> 1361;
1367 -> 1351;
1367 -> 1277;
1367 -> 1361;
1368 -> 1358;
1368 -> 1361;
1369 -> 1361;
1370 -> 1366;
1370 -> 1369;
1371 -> 1367;
1371 -> 1369;
1372 -> 1368;
1372 -> 1369;
1373 -> 0;
1374 -> 0;
1376 -> 1374;
1376 -> 1375;
1377 -> 1376;
1378 -> 1377;
1380 -> 1374;
1380 -> 1379;
1381 -> 1380;
1382 -> 1381;
1384 -> 1374;
1384 -> 1383;
1385 -> 1384;
1386 -> 1385;
1388 -> 1374;
1388 -> 1387;
1389 -> 1388;
1390 -> 1389;
1392 -> 1373;
1393 -> 1392;
1393 -> 1374;
1394 -> 1378;
1394 -> 1377;
1394 -> 1392;
1394 -> 1393;
1395 -> 1392;
1395 -> 1393;
1396 -> 1393;
1397 -> 1393;
1398 -> 1395;
1398 -> 1397;
1399 -> 1396;
1399 -> 1397;
1400 -> 1398;
1400 -> 1397;
1401 -> 1397;
1402 -> 1400;
1402 -> 1401;
1403 -> 1399;
1403 -> 1401;
1404 -> 1402;
1404 -> 1401;
1405 -> 1401;
1406 -> 1405;
1406 -> 1404;
1406 -> 1401;
1407 -> 1405;
1407 -> 1401;
1408 -> 1407;
1408 -> 1406;
1408 -> 1401;
1409 -> 1397;
1410 -> 1399;
1410 -> 1409;
1411 -> 1409;
1412 -> 1410;
1412 -> 1411;
1413 -> 1412;
1413 -> 1408;
1413 -> 1411;
1414 -> 1413;
1414 -> 1409;
1415 -> 1409;
1416 -> 1414;
1416 -> 1415;
1417 -> 1416;
1417 -> 1415;
1418 -> 1417;
1419 -> 1418;
1419 -> 1397;
1420 -> 1419;
1420 -> 1399;
1420 -> 1397;
1421 -> 1399;
1421 -> 1408;
1421 -> 0;
1421 -> 1397;
1422 -> 1421;
1422 -> 1399;
1422 -> 1397;
1423 -> 1396;
1423 -> 1394;
1423 -> 1393;
1425 -> 1382;
1425 -> 1381;
1425 -> 1392;
1425 -> 1393;
1426 -> 1392;
1426 -> 1393;
1427 -> 829;
1427 -> 1393;
1428 -> 1393;
1429 -> 1393;
1430 -> 1426;
1430 -> 1429;
1431 -> 1427;
1431 -> 1429;
1432 -> 1427;
1432 -> 1429;
1433 -> 1428;
1433 -> 1429;
1434 -> 1430;
1434 -> 1429;
1435 -> 1429;
1436 -> 1434;
1436 -> 1435;
1437 -> 1433;
1437 -> 1435;
1438 -> 1436;
1438 -> 1435;
1439 -> 1435;
1440 -> 1438;
1440 -> 1439;
1441 -> 1437;
1441 -> 1439;
1442 -> 1440;
1442 -> 1439;
1443 -> 1439;
1444 -> 1443;
1444 -> 1442;
1444 -> 1439;
1445 -> 1443;
1445 -> 1439;
1446 -> 1445;
1446 -> 1444;
1446 -> 1439;
1447 -> 1435;
1448 -> 1437;
1448 -> 1447;
1449 -> 1447;
1450 -> 1448;
1450 -> 1449;
1451 -> 1450;
1451 -> 1446;
1451 -> 1449;
1452 -> 1451;
1452 -> 1447;
1453 -> 1447;
1454 -> 1452;
1454 -> 1453;
1455 -> 1454;
1455 -> 1453;
1456 -> 1455;
1457 -> 1456;
1457 -> 1435;
1458 -> 1457;
1458 -> 1437;
1458 -> 1435;
1459 -> 1437;
1459 -> 1446;
1459 -> 0;
1459 -> 1435;
1460 -> 1459;
1460 -> 1437;
1460 -> 1435;
1461 -> 1433;
1461 -> 1429;
1462 -> 1433;
1462 -> 1429;
1463 -> 1429;
1464 -> 1431;
1464 -> 1463;
1464 -> 1429;
1465 -> 1431;
1465 -> 1464;
1466 -> 1433;
1466 -> 1465;
1466 -> 1446;
1466 -> 1458;
1466 -> 1460;
1466 -> 1461;
1466 -> 1462;
1466 -> 885;
1466 -> 1464;
1467 -> 1431;
1467 -> 1433;
1467 -> 1464;
1468 -> 1429;
1469 -> 1432;
1469 -> 1468;
1469 -> 1429;
1470 -> 1432;
1470 -> 1469;
1471 -> 1433;
1471 -> 1470;
1471 -> 1466;
1471 -> 1467;
1471 -> 1469;
1472 -> 1432;
1472 -> 1433;
1472 -> 1469;
1473 -> 1428;
1473 -> 1425;
1473 -> 1393;
1474 -> 1386;
1474 -> 1385;
1474 -> 1392;
1474 -> 1393;
1475 -> 1392;
1475 -> 1393;
1476 -> 1393;
1477 -> 408;
1477 -> 1393;
1478 -> 1393;
1479 -> 1475;
1479 -> 1478;
1480 -> 1476;
1480 -> 1478;
1481 -> 1477;
1481 -> 1478;
1482 -> 1476;
1482 -> 1478;
1483 -> 1479;
1483 -> 1478;
1484 -> 1478;
1485 -> 1483;
1485 -> 1484;
1486 -> 1482;
1486 -> 1484;
1487 -> 1485;
1487 -> 1484;
1488 -> 1484;
1489 -> 1487;
1489 -> 1488;
1490 -> 1486;
1490 -> 1488;
1491 -> 1489;
1491 -> 1488;
1492 -> 1488;
1493 -> 1492;
1493 -> 1491;
1493 -> 1488;
1494 -> 1492;
1494 -> 1488;
1495 -> 1494;
1495 -> 1493;
1495 -> 1488;
1496 -> 1484;
1497 -> 1486;
1497 -> 1496;
1498 -> 1496;
1499 -> 1497;
1499 -> 1498;
1500 -> 1499;
1500 -> 1495;
1500 -> 1498;
1501 -> 1500;
1501 -> 1496;
1502 -> 1496;
1503 -> 1501;
1503 -> 1502;
1504 -> 1503;
1504 -> 1502;
1505 -> 1504;
1506 -> 1505;
1506 -> 1484;
1507 -> 1506;
1507 -> 1486;
1507 -> 1484;
1508 -> 1486;
1508 -> 1495;
1508 -> 0;
1508 -> 1484;
1509 -> 1508;
1509 -> 1486;
1509 -> 1484;
1510 -> 1482;
1510 -> 1478;
1511 -> 1482;
1511 -> 1478;
1512 -> 1478;
1513 -> 1480;
1513 -> 1512;
1513 -> 1478;
1514 -> 1478;
1515 -> 1481;
1515 -> 1514;
1515 -> 1478;
1516 -> 1481;
1516 -> 1515;
1517 -> 1482;
1517 -> 1516;
1517 -> 1495;
1517 -> 1507;
1517 -> 1509;
1517 -> 1510;
1517 -> 1511;
1517 -> 850;
1517 -> 1515;
1518 -> 1481;
1518 -> 1482;
1518 -> 1515;
1519 -> 1476;
1519 -> 1474;
1519 -> 1393;
1520 -> 1390;
1520 -> 1389;
1520 -> 1392;
1520 -> 1393;
1521 -> 1392;
1521 -> 1393;
1522 -> 1393;
1523 -> 267;
1523 -> 1393;
1524 -> 1393;
1525 -> 1521;
1525 -> 1524;
1526 -> 1522;
1526 -> 1524;
1527 -> 1523;
1527 -> 1524;
1528 -> 1522;
1528 -> 1524;
1529 -> 1525;
1529 -> 1524;
1530 -> 1524;
1531 -> 1529;
1531 -> 1530;
1532 -> 1528;
1532 -> 1530;
1533 -> 1531;
1533 -> 1530;
1534 -> 1530;
1535 -> 1533;
1535 -> 1534;
1536 -> 1532;
1536 -> 1534;
1537 -> 1535;
1537 -> 1534;
1538 -> 1534;
1539 -> 1538;
1539 -> 1537;
1539 -> 1534;
1540 -> 1538;
1540 -> 1534;
1541 -> 1540;
1541 -> 1539;
1541 -> 1534;
1542 -> 1530;
1543 -> 1532;
1543 -> 1542;
1544 -> 1542;
1545 -> 1543;
1545 -> 1544;
1546 -> 1545;
1546 -> 1541;
1546 -> 1544;
1547 -> 1546;
1547 -> 1542;
1548 -> 1542;
1549 -> 1547;
1549 -> 1548;
1550 -> 1549;
1550 -> 1548;
1551 -> 1550;
1552 -> 1551;
1552 -> 1530;
1553 -> 1552;
1553 -> 1532;
1553 -> 1530;
1554 -> 1532;
1554 -> 1541;
1554 -> 0;
1554 -> 1530;
1555 -> 1554;
1555 -> 1532;
1555 -> 1530;
1556 -> 1528;
1556 -> 1524;
1557 -> 1528;
1557 -> 1524;
1558 -> 1524;
1559 -> 1526;
1559 -> 1558;
1559 -> 1524;
1560 -> 1524;
1561 -> 1527;
1561 -> 1560;
1561 -> 1524;
1562 -> 1527;
1562 -> 1561;
1563 -> 1528;
1563 -> 1562;
1563 -> 1541;
1563 -> 1553;
1563 -> 1555;
1563 -> 1556;
1563 -> 1557;
1563 -> 835;
1563 -> 1561;
1564 -> 1527;
1564 -> 1528;
1564 -> 1561;
1565 -> 1522;
1565 -> 1520;
1565 -> 1393;
1566 -> 1378;
1566 -> 1377;
1566 -> 1393;
1567 -> 1396;
1567 -> 1397;
1568 -> 1567;
1568 -> 1397;
1569 -> 1568;
1569 -> 1401;
1570 -> 1569;
1570 -> 1401;
1571 -> 1405;
1571 -> 1570;
1571 -> 1401;
1572 -> 1407;
1572 -> 1571;
1572 -> 1401;
1573 -> 1412;
1573 -> 1572;
1573 -> 1411;
1574 -> 1573;
1574 -> 1409;
1575 -> 1574;
1575 -> 1415;
1576 -> 1575;
1576 -> 1415;
1577 -> 1576;
1578 -> 1577;
1578 -> 1397;
1579 -> 1578;
1579 -> 1399;
1579 -> 1397;
1580 -> 1399;
1580 -> 1572;
1580 -> 0;
1580 -> 1397;
1581 -> 1580;
1581 -> 1399;
1581 -> 1397;
1582 -> 1396;
1582 -> 1566;
1582 -> 1393;
1583 -> 1382;
1583 -> 1381;
1583 -> 1393;
1584 -> 1428;
1584 -> 1429;
1585 -> 1584;
1585 -> 1429;
1586 -> 1585;
1586 -> 1435;
1587 -> 1586;
1587 -> 1435;
1588 -> 1587;
1588 -> 1439;
1589 -> 1588;
1589 -> 1439;
1590 -> 1443;
1590 -> 1589;
1590 -> 1439;
1591 -> 1445;
1591 -> 1590;
1591 -> 1439;
1592 -> 1450;
1592 -> 1591;
1592 -> 1449;
1593 -> 1592;
1593 -> 1447;
1594 -> 1593;
1594 -> 1453;
1595 -> 1594;
1595 -> 1453;
1596 -> 1595;
1597 -> 1596;
1597 -> 1435;
1598 -> 1597;
1598 -> 1437;
1598 -> 1435;
1599 -> 1437;
1599 -> 1591;
1599 -> 0;
1599 -> 1435;
1600 -> 1599;
1600 -> 1437;
1600 -> 1435;
1601 -> 1433;
1601 -> 1465;
1601 -> 1591;
1601 -> 1598;
1601 -> 1600;
1601 -> 1461;
1601 -> 1462;
1601 -> 1471;
1601 -> 1472;
1601 -> 1464;
1602 -> 1428;
1602 -> 1583;
1602 -> 1393;
1603 -> 1386;
1603 -> 1385;
1603 -> 1393;
1604 -> 1476;
1604 -> 1478;
1605 -> 1604;
1605 -> 1478;
1606 -> 1605;
1606 -> 1484;
1607 -> 1606;
1607 -> 1484;
1608 -> 1607;
1608 -> 1488;
1609 -> 1608;
1609 -> 1488;
1610 -> 1492;
1610 -> 1609;
1610 -> 1488;
1611 -> 1494;
1611 -> 1610;
1611 -> 1488;
1612 -> 1499;
1612 -> 1611;
1612 -> 1498;
1613 -> 1612;
1613 -> 1496;
1614 -> 1613;
1614 -> 1502;
1615 -> 1614;
1615 -> 1502;
1616 -> 1615;
1617 -> 1616;
1617 -> 1484;
1618 -> 1617;
1618 -> 1486;
1618 -> 1484;
1619 -> 1486;
1619 -> 1611;
1619 -> 0;
1619 -> 1484;
1620 -> 1619;
1620 -> 1486;
1620 -> 1484;
1621 -> 1482;
1621 -> 1516;
1621 -> 1611;
1621 -> 1618;
1621 -> 1620;
1621 -> 1510;
1621 -> 1511;
1621 -> 1517;
1621 -> 1518;
1621 -> 1515;
1622 -> 1476;
1622 -> 1603;
1622 -> 1393;
1623 -> 1390;
1623 -> 1389;
1623 -> 1393;
1624 -> 1522;
1624 -> 1524;
1625 -> 1624;
1625 -> 1524;
1626 -> 1625;
1626 -> 1530;
1627 -> 1626;
1627 -> 1530;
1628 -> 1627;
1628 -> 1534;
1629 -> 1628;
1629 -> 1534;
1630 -> 1538;
1630 -> 1629;
1630 -> 1534;
1631 -> 1540;
1631 -> 1630;
1631 -> 1534;
1632 -> 1545;
1632 -> 1631;
1632 -> 1544;
1633 -> 1632;
1633 -> 1542;
1634 -> 1633;
1634 -> 1548;
1635 -> 1634;
1635 -> 1548;
1636 -> 1635;
1637 -> 1636;
1637 -> 1530;
1638 -> 1637;
1638 -> 1532;
1638 -> 1530;
1639 -> 1532;
1639 -> 1631;
1639 -> 0;
1639 -> 1530;
1640 -> 1639;
1640 -> 1532;
1640 -> 1530;
1641 -> 1528;
1641 -> 1562;
1641 -> 1631;
1641 -> 1638;
1641 -> 1640;
1641 -> 1556;
1641 -> 1557;
1641 -> 1563;
1641 -> 1564;
1641 -> 1561;
1642 -> 1522;
1642 -> 1623;
1642 -> 1393;
1643 -> 1576;
1644 -> 1643;
1644 -> 1397;
1645 -> 1644;
1645 -> 1399;
1645 -> 1397;
1646 -> 1595;
1647 -> 1646;
1647 -> 1435;
1648 -> 1647;
1648 -> 1437;
1648 -> 1435;
1649 -> 1433;
1649 -> 1465;
1649 -> 1591;
1649 -> 1648;
1649 -> 1600;
1649 -> 1461;
1649 -> 1462;
1649 -> 1601;
1649 -> 1472;
1649 -> 1464;
1650 -> 1615;
1651 -> 1650;
1651 -> 1484;
1652 -> 1651;
1652 -> 1486;
1652 -> 1484;
1653 -> 1482;
1653 -> 1516;
1653 -> 1611;
1653 -> 1652;
1653 -> 1620;
1653 -> 1510;
1653 -> 1511;
1653 -> 1621;
1653 -> 1518;
1653 -> 1515;
1654 -> 1635;
1655 -> 1654;
1655 -> 1530;
1656 -> 1655;
1656 -> 1532;
1656 -> 1530;
1657 -> 1528;
1657 -> 1562;
1657 -> 1631;
1657 -> 1656;
1657 -> 1640;
1657 -> 1556;
1657 -> 1557;
1657 -> 1641;
1657 -> 1564;
1657 -> 1561;
1658 -> 1576;
1659 -> 1658;
1659 -> 1397;
1660 -> 1659;
1660 -> 1399;
1660 -> 1397;
1661 -> 1595;
1662 -> 1661;
1662 -> 1435;
1663 -> 1662;
1663 -> 1437;
1663 -> 1435;
1664 -> 1433;
1664 -> 1465;
1664 -> 1591;
1664 -> 1663;
1664 -> 1600;
1664 -> 1461;
1664 -> 1462;
1664 -> 1649;
1664 -> 1472;
1664 -> 1464;
1665 -> 1615;
1666 -> 1665;
1666 -> 1484;
1667 -> 1666;
1667 -> 1486;
1667 -> 1484;
1668 -> 1482;
1668 -> 1516;
1668 -> 1611;
1668 -> 1667;
1668 -> 1620;
1668 -> 1510;
1668 -> 1511;
1668 -> 1653;
1668 -> 1518;
1668 -> 1515;
1669 -> 1635;
1670 -> 1669;
1670 -> 1530;
1671 -> 1670;
1671 -> 1532;
1671 -> 1530;
1672 -> 1528;
1672 -> 1562;
1672 -> 1631;
1672 -> 1671;
1672 -> 1640;
1672 -> 1556;
1672 -> 1557;
1672 -> 1657;
1672 -> 1564;
1672 -> 1561;
1673 -> 1576;
1674 -> 1673;
1674 -> 1397;
1675 -> 1674;
1675 -> 1399;
1675 -> 1397;
1676 -> 1595;
1677 -> 1676;
1677 -> 1435;
1678 -> 1677;
1678 -> 1437;
1678 -> 1435;
1679 -> 1433;
1679 -> 1465;
1679 -> 1591;
1679 -> 1678;
1679 -> 1600;
1679 -> 1461;
1679 -> 1462;
1679 -> 1664;
1679 -> 1472;
1679 -> 1464;
1680 -> 1615;
1681 -> 1680;
1681 -> 1484;
1682 -> 1681;
1682 -> 1486;
1682 -> 1484;
1683 -> 1482;
1683 -> 1516;
1683 -> 1611;
1683 -> 1682;
1683 -> 1620;
1683 -> 1510;
1683 -> 1511;
1683 -> 1668;
1683 -> 1518;
1683 -> 1515;
1684 -> 1635;
1685 -> 1684;
1685 -> 1530;
1686 -> 1685;
1686 -> 1532;
1686 -> 1530;
1687 -> 1528;
1687 -> 1562;
1687 -> 1631;
1687 -> 1686;
1687 -> 1640;
1687 -> 1556;
1687 -> 1557;
1687 -> 1672;
1687 -> 1564;
1687 -> 1561;
1688 -> 1576;
1689 -> 1688;
1689 -> 1397;
1690 -> 1689;
1690 -> 1399;
1690 -> 1397;
1691 -> 1595;
1692 -> 1691;
1692 -> 1435;
1693 -> 1692;
1693 -> 1437;
1693 -> 1435;
1694 -> 1433;
1694 -> 1465;
1694 -> 1591;
1694 -> 1693;
1694 -> 1600;
1694 -> 1461;
1694 -> 1462;
1694 -> 1679;
1694 -> 1472;
1694 -> 1464;
1695 -> 1615;
1696 -> 1695;
1696 -> 1484;
1697 -> 1696;
1697 -> 1486;
1697 -> 1484;
1698 -> 1482;
1698 -> 1516;
1698 -> 1611;
1698 -> 1697;
1698 -> 1620;
1698 -> 1510;
1698 -> 1511;
1698 -> 1683;
1698 -> 1518;
1698 -> 1515;
1699 -> 1635;
1700 -> 1699;
1700 -> 1530;
1701 -> 1700;
1701 -> 1532;
1701 -> 1530;
1702 -> 1528;
1702 -> 1562;
1702 -> 1631;
1702 -> 1701;
1702 -> 1640;
1702 -> 1556;
1702 -> 1557;
1702 -> 1687;
1702 -> 1564;
1702 -> 1561;
1703 -> 1576;
1704 -> 1703;
1704 -> 1397;
1705 -> 1704;
1705 -> 1399;
1705 -> 1397;
1706 -> 1595;
1707 -> 1706;
1707 -> 1435;
1708 -> 1707;
1708 -> 1437;
1708 -> 1435;
1709 -> 1433;
1709 -> 1465;
1709 -> 1591;
1709 -> 1708;
1709 -> 1600;
1709 -> 1461;
1709 -> 1462;
1709 -> 1694;
1709 -> 1472;
1709 -> 1464;
1710 -> 1615;
1711 -> 1710;
1711 -> 1484;
1712 -> 1711;
1712 -> 1486;
1712 -> 1484;
1713 -> 1482;
1713 -> 1516;
1713 -> 1611;
1713 -> 1712;
1713 -> 1620;
1713 -> 1510;
1713 -> 1511;
1713 -> 1698;
1713 -> 1518;
1713 -> 1515;
1714 -> 1635;
1715 -> 1714;
1715 -> 1530;
1716 -> 1715;
1716 -> 1532;
1716 -> 1530;
1717 -> 1528;
1717 -> 1562;
1717 -> 1631;
1717 -> 1716;
1717 -> 1640;
1717 -> 1556;
1717 -> 1557;
1717 -> 1702;
1717 -> 1564;
1717 -> 1561;
1718 -> 1576;
1719 -> 1718;
1719 -> 1397;
1720 -> 1719;
1720 -> 1399;
1720 -> 1397;
1721 -> 1595;
1722 -> 1721;
1722 -> 1435;
1723 -> 1722;
1723 -> 1437;
1723 -> 1435;
1724 -> 1433;
1724 -> 1465;
1724 -> 1591;
1724 -> 1723;
1724 -> 1600;
1724 -> 1461;
1724 -> 1462;
1724 -> 1709;
1724 -> 1472;
1724 -> 1464;
1725 -> 1615;
1726 -> 1725;
1726 -> 1484;
1727 -> 1726;
1727 -> 1486;
1727 -> 1484;
1728 -> 1482;
1728 -> 1516;
1728 -> 1611;
1728 -> 1727;
1728 -> 1620;
1728 -> 1510;
1728 -> 1511;
1728 -> 1713;
1728 -> 1518;
1728 -> 1515;
1729 -> 1635;
1730 -> 1729;
1730 -> 1530;
1731 -> 1730;
1731 -> 1532;
1731 -> 1530;
1732 -> 1528;
1732 -> 1562;
1732 -> 1631;
1732 -> 1731;
1732 -> 1640;
1732 -> 1556;
1732 -> 1557;
1732 -> 1717;
1732 -> 1564;
1732 -> 1561;
1733 -> 1576;
1734 -> 1733;
1734 -> 1397;
1735 -> 1734;
1735 -> 1399;
1735 -> 1397;
1736 -> 1595;
1737 -> 1736;
1737 -> 1435;
1738 -> 1737;
1738 -> 1437;
1738 -> 1435;
1739 -> 1433;
1739 -> 1465;
1739 -> 1591;
1739 -> 1738;
1739 -> 1600;
1739 -> 1461;
1739 -> 1462;
1739 -> 1724;
1739 -> 1472;
1739 -> 1464;
1740 -> 1615;
1741 -> 1740;
1741 -> 1484;
1742 -> 1741;
1742 -> 1486;
1742 -> 1484;
1743 -> 1482;
1743 -> 1516;
1743 -> 1611;
1743 -> 1742;
1743 -> 1620;
1743 -> 1510;
1743 -> 1511;
1743 -> 1728;
1743 -> 1518;
1743 -> 1515;
1744 -> 1635;
1745 -> 1744;
1745 -> 1530;
1746 -> 1745;
1746 -> 1532;
1746 -> 1530;
1747 -> 1528;
1747 -> 1562;
1747 -> 1631;
1747 -> 1746;
1747 -> 1640;
1747 -> 1556;
1747 -> 1557;
1747 -> 1732;
1747 -> 1564;
1747 -> 1561;
1748 -> 1576;
1749 -> 1748;
1749 -> 1397;
1750 -> 1749;
1750 -> 1399;
1750 -> 1397;
1751 -> 1595;
1752 -> 1751;
1752 -> 1435;
1753 -> 1752;
1753 -> 1437;
1753 -> 1435;
1754 -> 1433;
1754 -> 1465;
1754 -> 1591;
1754 -> 1753;
1754 -> 1600;
1754 -> 1461;
1754 -> 1462;
1754 -> 1739;
1754 -> 1472;
1754 -> 1464;
1755 -> 1615;
1756 -> 1755;
1756 -> 1484;
1757 -> 1756;
1757 -> 1486;
1757 -> 1484;
1758 -> 1482;
1758 -> 1516;
1758 -> 1611;
1758 -> 1757;
1758 -> 1620;
1758 -> 1510;
1758 -> 1511;
1758 -> 1743;
1758 -> 1518;
1758 -> 1515;
1759 -> 1635;
1760 -> 1759;
1760 -> 1530;
1761 -> 1760;
1761 -> 1532;
1761 -> 1530;
1762 -> 1528;
1762 -> 1562;
1762 -> 1631;
1762 -> 1761;
1762 -> 1640;
1762 -> 1556;
1762 -> 1557;
1762 -> 1747;
1762 -> 1564;
1762 -> 1561;
1763 -> 1576;
1764 -> 1763;
1764 -> 1397;
1765 -> 1764;
1765 -> 1399;
1765 -> 1397;
1766 -> 1595;
1767 -> 1766;
1767 -> 1435;
1768 -> 1767;
1768 -> 1437;
1768 -> 1435;
1769 -> 1433;
1769 -> 1465;
1769 -> 1591;
1769 -> 1768;
1769 -> 1600;
1769 -> 1461;
1769 -> 1462;
1769 -> 1754;
1769 -> 1472;
1769 -> 1464;
1770 -> 1615;
1771 -> 1770;
1771 -> 1484;
1772 -> 1771;
1772 -> 1486;
1772 -> 1484;
1773 -> 1482;
1773 -> 1516;
1773 -> 1611;
1773 -> 1772;
1773 -> 1620;
1773 -> 1510;
1773 -> 1511;
1773 -> 1758;
1773 -> 1518;
1773 -> 1515;
1774 -> 1635;
1775 -> 1774;
1775 -> 1530;
1776 -> 1775;
1776 -> 1532;
1776 -> 1530;
1777 -> 1528;
1777 -> 1562;
1777 -> 1631;
1777 -> 1776;
1777 -> 1640;
1777 -> 1556;
1777 -> 1557;
1777 -> 1762;
1777 -> 1564;
1777 -> 1561;
1778 -> 1576;
1779 -> 1778;
1779 -> 1397;
1780 -> 1779;
1780 -> 1399;
1780 -> 1397;
1781 -> 1595;
1782 -> 1781;
1782 -> 1435;
1783 -> 1782;
1783 -> 1437;
1783 -> 1435;
1784 -> 1433;
1784 -> 1465;
1784 -> 1591;
1784 -> 1783;
1784 -> 1600;
1784 -> 1461;
1784 -> 1462;
1784 -> 1769;
1784 -> 1472;
1784 -> 1464;
1785 -> 1615;
1786 -> 1785;
1786 -> 1484;
1787 -> 1786;
1787 -> 1486;
1787 -> 1484;
1788 -> 1482;
1788 -> 1516;
1788 -> 1611;
1788 -> 1787;
1788 -> 1620;
1788 -> 1510;
1788 -> 1511;
1788 -> 1773;
1788 -> 1518;
1788 -> 1515;
1789 -> 1635;
1790 -> 1789;
1790 -> 1530;
1791 -> 1790;
1791 -> 1532;
1791 -> 1530;
1792 -> 1528;
1792 -> 1562;
1792 -> 1631;
1792 -> 1791;
1792 -> 1640;
1792 -> 1556;
1792 -> 1557;
1792 -> 1777;
1792 -> 1564;
1792 -> 1561;
1793 -> 1576;
1794 -> 1793;
1794 -> 1397;
1795 -> 1794;
1795 -> 1399;
1795 -> 1397;
1796 -> 1595;
1797 -> 1796;
1797 -> 1435;
1798 -> 1797;
1798 -> 1437;
1798 -> 1435;
1799 -> 1433;
1799 -> 1465;
1799 -> 1591;
1799 -> 1798;
1799 -> 1600;
1799 -> 1461;
1799 -> 1462;
1799 -> 1784;
1799 -> 1472;
1799 -> 1464;
1800 -> 1615;
1801 -> 1800;
1801 -> 1484;
1802 -> 1801;
1802 -> 1486;
1802 -> 1484;
1803 -> 1482;
1803 -> 1516;
1803 -> 1611;
1803 -> 1802;
1803 -> 1620;
1803 -> 1510;
1803 -> 1511;
1803 -> 1788;
1803 -> 1518;
1803 -> 1515;
1804 -> 1635;
1805 -> 1804;
1805 -> 1530;
1806 -> 1805;
1806 -> 1532;
1806 -> 1530;
1807 -> 1528;
1807 -> 1562;
1807 -> 1631;
1807 -> 1806;
1807 -> 1640;
1807 -> 1556;
1807 -> 1557;
1807 -> 1792;
1807 -> 1564;
1807 -> 1561;
1808 -> 1576;
1809 -> 1808;
1809 -> 1397;
1810 -> 1809;
1810 -> 1399;
1810 -> 1397;
1811 -> 1595;
1812 -> 1811;
1812 -> 1435;
1813 -> 1812;
1813 -> 1437;
1813 -> 1435;
1814 -> 1433;
1814 -> 1465;
1814 -> 1591;
1814 -> 1813;
1814 -> 1600;
1814 -> 1461;
1814 -> 1462;
1814 -> 1799;
1814 -> 1472;
1814 -> 1464;
1815 -> 1615;
1816 -> 1815;
1816 -> 1484;
1817 -> 1816;
1817 -> 1486;
1817 -> 1484;
1818 -> 1482;
1818 -> 1516;
1818 -> 1611;
1818 -> 1817;
1818 -> 1620;
1818 -> 1510;
1818 -> 1511;
1818 -> 1803;
1818 -> 1518;
1818 -> 1515;
1819 -> 1635;
1820 -> 1819;
1820 -> 1530;
1821 -> 1820;
1821 -> 1532;
1821 -> 1530;
1822 -> 1528;
1822 -> 1562;
1822 -> 1631;
1822 -> 1821;
1822 -> 1640;
1822 -> 1556;
1822 -> 1557;
1822 -> 1807;
1822 -> 1564;
1822 -> 1561;
1823 -> 1576;
1824 -> 1823;
1824 -> 1397;
1825 -> 1824;
1825 -> 1399;
1825 -> 1397;
1826 -> 1595;
1827 -> 1826;
1827 -> 1435;
1828 -> 1827;
1828 -> 1437;
1828 -> 1435;
1829 -> 1433;
1829 -> 1465;
1829 -> 1591;
1829 -> 1828;
1829 -> 1600;
1829 -> 1461;
1829 -> 1462;
1829 -> 1814;
1829 -> 1472;
1829 -> 1464;
1830 -> 1615;
1831 -> 1830;
1831 -> 1484;
1832 -> 1831;
1832 -> 1486;
1832 -> 1484;
1833 -> 1482;
1833 -> 1516;
1833 -> 1611;
1833 -> 1832;
1833 -> 1620;
1833 -> 1510;
1833 -> 1511;
1833 -> 1818;
1833 -> 1518;
1833 -> 1515;
1834 -> 1635;
1835 -> 1834;
1835 -> 1530;
1836 -> 1835;
1836 -> 1532;
1836 -> 1530;
1837 -> 1528;
1837 -> 1562;
1837 -> 1631;
1837 -> 1836;
1837 -> 1640;
1837 -> 1556;
1837 -> 1557;
1837 -> 1822;
1837 -> 1564;
1837 -> 1561;
1838 -> 1576;
1839 -> 1838;
1839 -> 1397;
1840 -> 1839;
1840 -> 1399;
1840 -> 1397;
1841 -> 1595;
1842 -> 1841;
1842 -> 1435;
1843 -> 1842;
1843 -> 1437;
1843 -> 1435;
1844 -> 1433;
1844 -> 1465;
1844 -> 1591;
1844 -> 1843;
1844 -> 1600;
1844 -> 1461;
1844 -> 1462;
1844 -> 1829;
1844 -> 1472;
1844 -> 1464;
1845 -> 1615;
1846 -> 1845;
1846 -> 1484;
1847 -> 1846;
1847 -> 1486;
1847 -> 1484;
1848 -> 1482;
1848 -> 1516;
1848 -> 1611;
1848 -> 1847;
1848 -> 1620;
1848 -> 1510;
1848 -> 1511;
1848 -> 1833;
1848 -> 1518;
1848 -> 1515;
1849 -> 1635;
1850 -> 1849;
1850 -> 1530;
1851 -> 1850;
1851 -> 1532;
1851 -> 1530;
1852 -> 1528;
1852 -> 1562;
1852 -> 1631;
1852 -> 1851;
1852 -> 1640;
1852 -> 1556;
1852 -> 1557;
1852 -> 1837;
1852 -> 1564;
1852 -> 1561;
1853 -> 1576;
1854 -> 1853;
1854 -> 1397;
1855 -> 1854;
1855 -> 1399;
1855 -> 1397;
1856 -> 1595;
1857 -> 1856;
1857 -> 1435;
1858 -> 1857;
1858 -> 1437;
1858 -> 1435;
1859 -> 1433;
1859 -> 1465;
1859 -> 1591;
1859 -> 1858;
1859 -> 1600;
1859 -> 1461;
1859 -> 1462;
1859 -> 1844;
1859 -> 1472;
1859 -> 1464;
1860 -> 1615;
1861 -> 1860;
1861 -> 1484;
1862 -> 1861;
1862 -> 1486;
1862 -> 1484;
1863 -> 1482;
1863 -> 1516;
1863 -> 1611;
1863 -> 1862;
1863 -> 1620;
1863 -> 1510;
1863 -> 1511;
1863 -> 1848;
1863 -> 1518;
1863 -> 1515;
1864 -> 1635;
1865 -> 1864;
1865 -> 1530;
1866 -> 1865;
1866 -> 1532;
1866 -> 1530;
1867 -> 1528;
1867 -> 1562;
1867 -> 1631;
1867 -> 1866;
1867 -> 1640;
1867 -> 1556;
1867 -> 1557;
1867 -> 1852;
1867 -> 1564;
1867 -> 1561;
1868 -> 1576;
1869 -> 1868;
1869 -> 1397;
1870 -> 1869;
1870 -> 1399;
1870 -> 1397;
1871 -> 1595;
1872 -> 1871;
1872 -> 1435;
1873 -> 1872;
1873 -> 1437;
1873 -> 1435;
1874 -> 1433;
1874 -> 1465;
1874 -> 1591;
1874 -> 1873;
1874 -> 1600;
1874 -> 1461;
1874 -> 1462;
1874 -> 1859;
1874 -> 1472;
1874 -> 1464;
1875 -> 1615;
1876 -> 1875;
1876 -> 1484;
1877 -> 1876;
1877 -> 1486;
1877 -> 1484;
1878 -> 1482;
1878 -> 1516;
1878 -> 1611;
1878 -> 1877;
1878 -> 1620;
1878 -> 1510;
1878 -> 1511;
1878 -> 1863;
1878 -> 1518;
1878 -> 1515;
1879 -> 1635;
1880 -> 1879;
1880 -> 1530;
1881 -> 1880;
1881 -> 1532;
1881 -> 1530;
1882 -> 1528;
1882 -> 1562;
1882 -> 1631;
1882 -> 1881;
1882 -> 1640;
1882 -> 1556;
1882 -> 1557;
1882 -> 1867;
1882 -> 1564;
1882 -> 1561;
1883 -> 1576;
1884 -> 1883;
1884 -> 1397;
1885 -> 1884;
1885 -> 1399;
1885 -> 1397;
1886 -> 1595;
1887 -> 1886;
1887 -> 1435;
1888 -> 1887;
1888 -> 1437;
1888 -> 1435;
1889 -> 1433;
1889 -> 1465;
1889 -> 1591;
1889 -> 1888;
1889 -> 1600;
1889 -> 1461;
1889 -> 1462;
1889 -> 1874;
1889 -> 1472;
1889 -> 1464;
1890 -> 1615;
1891 -> 1890;
1891 -> 1484;
1892 -> 1891;
1892 -> 1486;
1892 -> 1484;
1893 -> 1482;
1893 -> 1516;
1893 -> 1611;
1893 -> 1892;
1893 -> 1620;
1893 -> 1510;
1893 -> 1511;
1893 -> 1878;
1893 -> 1518;
1893 -> 1515;
1894 -> 1635;
1895 -> 1894;
1895 -> 1530;
1896 -> 1895;
1896 -> 1532;
1896 -> 1530;
1897 -> 1528;
1897 -> 1562;
1897 -> 1631;
1897 -> 1896;
1897 -> 1640;
1897 -> 1556;
1897 -> 1557;
1897 -> 1882;
1897 -> 1564;
1897 -> 1561;
1898 -> 1576;
1899 -> 1898;
1899 -> 1397;
1900 -> 1899;
1900 -> 1399;
1900 -> 1397;
1901 -> 1595;
1902 -> 1901;
1902 -> 1435;
1903 -> 1902;
1903 -> 1437;
1903 -> 1435;
1904 -> 1433;
1904 -> 1465;
1904 -> 1591;
1904 -> 1903;
1904 -> 1600;
1904 -> 1461;
1904 -> 1462;
1904 -> 1889;
1904 -> 1472;
1904 -> 1464;
1905 -> 1615;
1906 -> 1905;
1906 -> 1484;
1907 -> 1906;
1907 -> 1486;
1907 -> 1484;
1908 -> 1482;
1908 -> 1516;
1908 -> 1611;
1908 -> 1907;
1908 -> 1620;
1908 -> 1510;
1908 -> 1511;
1908 -> 1893;
1908 -> 1518;
1908 -> 1515;
1909 -> 1635;
1910 -> 1909;
1910 -> 1530;
1911 -> 1910;
1911 -> 1532;
1911 -> 1530;
1912 -> 1528;
1912 -> 1562;
1912 -> 1631;
1912 -> 1911;
1912 -> 1640;
1912 -> 1556;
1912 -> 1557;
1912 -> 1897;
1912 -> 1564;
1912 -> 1561;
1913 -> 1576;
1914 -> 1913;
1914 -> 1397;
1915 -> 1914;
1915 -> 1399;
1915 -> 1397;
1916 -> 1595;
1917 -> 1916;
1917 -> 1435;
1918 -> 1917;
1918 -> 1437;
1918 -> 1435;
1919 -> 1433;
1919 -> 1465;
1919 -> 1591;
1919 -> 1918;
1919 -> 1600;
1919 -> 1461;
1919 -> 1462;
1919 -> 1904;
1919 -> 1472;
1919 -> 1464;
1920 -> 1615;
1921 -> 1920;
1921 -> 1484;
1922 -> 1921;
1922 -> 1486;
1922 -> 1484;
1923 -> 1482;
1923 -> 1516;
1923 -> 1611;
1923 -> 1922;
1923 -> 1620;
1923 -> 1510;
1923 -> 1511;
1923 -> 1908;
1923 -> 1518;
1923 -> 1515;
1924 -> 1635;
1925 -> 1924;
1925 -> 1530;
1926 -> 1925;
1926 -> 1532;
1926 -> 1530;
1927 -> 1528;
1927 -> 1562;
1927 -> 1631;
1927 -> 1926;
1927 -> 1640;
1927 -> 1556;
1927 -> 1557;
1927 -> 1912;
1927 -> 1564;
1927 -> 1561;
1928 -> 1576;
1929 -> 1928;
1929 -> 1397;
1930 -> 1929;
1930 -> 1399;
1930 -> 1397;
1931 -> 1595;
1932 -> 1931;
1932 -> 1435;
1933 -> 1932;
1933 -> 1437;
1933 -> 1435;
1934 -> 1433;
1934 -> 1465;
1934 -> 1591;
1934 -> 1933;
1934 -> 1600;
1934 -> 1461;
1934 -> 1462;
1934 -> 1919;
1934 -> 1472;
1934 -> 1464;
1935 -> 1615;
1936 -> 1935;
1936 -> 1484;
1937 -> 1936;
1937 -> 1486;
1937 -> 1484;
1938 -> 1482;
1938 -> 1516;
1938 -> 1611;
1938 -> 1937;
1938 -> 1620;
1938 -> 1510;
1938 -> 1511;
1938 -> 1923;
1938 -> 1518;
1938 -> 1515;
1939 -> 1635;
1940 -> 1939;
1940 -> 1530;
1941 -> 1940;
1941 -> 1532;
1941 -> 1530;
1942 -> 1528;
1942 -> 1562;
1942 -> 1631;
1942 -> 1941;
1942 -> 1640;
1942 -> 1556;
1942 -> 1557;
1942 -> 1927;
1942 -> 1564;
1942 -> 1561;
1943 -> 1576;
1944 -> 1943;
1944 -> 1397;
1945 -> 1944;
1945 -> 1399;
1945 -> 1397;
1946 -> 1595;
1947 -> 1946;
1947 -> 1435;
1948 -> 1947;
1948 -> 1437;
1948 -> 1435;
1949 -> 1433;
1949 -> 1465;
1949 -> 1591;
1949 -> 1948;
1949 -> 1600;
1949 -> 1461;
1949 -> 1462;
1949 -> 1934;
1949 -> 1472;
1949 -> 1464;
1950 -> 1615;
1951 -> 1950;
1951 -> 1484;
1952 -> 1951;
1952 -> 1486;
1952 -> 1484;
1953 -> 1482;
1953 -> 1516;
1953 -> 1611;
1953 -> 1952;
1953 -> 1620;
1953 -> 1510;
1953 -> 1511;
1953 -> 1938;
1953 -> 1518;
1953 -> 1515;
1954 -> 1635;
1955 -> 1954;
1955 -> 1530;
1956 -> 1955;
1956 -> 1532;
1956 -> 1530;
1957 -> 1528;
1957 -> 1562;
1957 -> 1631;
1957 -> 1956;
1957 -> 1640;
1957 -> 1556;
1957 -> 1557;
1957 -> 1942;
1957 -> 1564;
1957 -> 1561;
1958 -> 1576;
1959 -> 1958;
1959 -> 1397;
1960 -> 1959;
1960 -> 1399;
1960 -> 1397;
1961 -> 1595;
1962 -> 1961;
1962 -> 1435;
1963 -> 1962;
1963 -> 1437;
1963 -> 1435;
1964 -> 1433;
1964 -> 1465;
1964 -> 1591;
1964 -> 1963;
1964 -> 1600;
1964 -> 1461;
1964 -> 1462;
1964 -> 1949;
1964 -> 1472;
1964 -> 1464;
1965 -> 1615;
1966 -> 1965;
1966 -> 1484;
1967 -> 1966;
1967 -> 1486;
1967 -> 1484;
1968 -> 1482;
1968 -> 1516;
1968 -> 1611;
1968 -> 1967;
1968 -> 1620;
1968 -> 1510;
1968 -> 1511;
1968 -> 1953;
1968 -> 1518;
1968 -> 1515;
1969 -> 1635;
1970 -> 1969;
1970 -> 1530;
1971 -> 1970;
1971 -> 1532;
1971 -> 1530;
1972 -> 1528;
1972 -> 1562;
1972 -> 1631;
1972 -> 1971;
1972 -> 1640;
1972 -> 1556;
1972 -> 1557;
1972 -> 1957;
1972 -> 1564;
1972 -> 1561;
1973 -> 1576;
1974 -> 1973;
1974 -> 1397;
1975 -> 1974;
1975 -> 1399;
1975 -> 1397;
1976 -> 1595;
1977 -> 1976;
1977 -> 1435;
1978 -> 1977;
1978 -> 1437;
1978 -> 1435;
1979 -> 1433;
1979 -> 1465;
1979 -> 1591;
1979 -> 1978;
1979 -> 1600;
1979 -> 1461;
1979 -> 1462;
1979 -> 1964;
1979 -> 1472;
1979 -> 1464;
1980 -> 1615;
1981 -> 1980;
1981 -> 1484;
1982 -> 1981;
1982 -> 1486;
1982 -> 1484;
1983 -> 1482;
1983 -> 1516;
1983 -> 1611;
1983 -> 1982;
1983 -> 1620;
1983 -> 1510;
1983 -> 1511;
1983 -> 1968;
1983 -> 1518;
1983 -> 1515;
1984 -> 1635;
1985 -> 1984;
1985 -> 1530;
1986 -> 1985;
1986 -> 1532;
1986 -> 1530;
1987 -> 1528;
1987 -> 1562;
1987 -> 1631;
1987 -> 1986;
1987 -> 1640;
1987 -> 1556;
1987 -> 1557;
1987 -> 1972;
1987 -> 1564;
1987 -> 1561;
1988 -> 1576;
1989 -> 1988;
1989 -> 1397;
1990 -> 1989;
1990 -> 1399;
1990 -> 1397;
1991 -> 1595;
1992 -> 1991;
1992 -> 1435;
1993 -> 1992;
1993 -> 1437;
1993 -> 1435;
1994 -> 1433;
1994 -> 1465;
1994 -> 1591;
1994 -> 1993;
1994 -> 1600;
1994 -> 1461;
1994 -> 1462;
1994 -> 1979;
1994 -> 1472;
1994 -> 1464;
1995 -> 1615;
1996 -> 1995;
1996 -> 1484;
1997 -> 1996;
1997 -> 1486;
1997 -> 1484;
1998 -> 1482;
1998 -> 1516;
1998 -> 1611;
1998 -> 1997;
1998 -> 1620;
1998 -> 1510;
1998 -> 1511;
1998 -> 1983;
1998 -> 1518;
1998 -> 1515;
1999 -> 1635;
2000 -> 1999;
2000 -> 1530;
2001 -> 2000;
2001 -> 1532;
2001 -> 1530;
2002 -> 1528;
2002 -> 1562;
2002 -> 1631;
2002 -> 2001;
2002 -> 1640;
2002 -> 1556;
2002 -> 1557;
2002 -> 1987;
2002 -> 1564;
2002 -> 1561;
2003 -> 1576;
2004 -> 2003;
2004 -> 1397;
2005 -> 2004;
2005 -> 1399;
2005 -> 1397;
2006 -> 1595;
2007 -> 2006;
2007 -> 1435;
2008 -> 2007;
2008 -> 1437;
2008 -> 1435;
2009 -> 1433;
2009 -> 1465;
2009 -> 1591;
2009 -> 2008;
2009 -> 1600;
2009 -> 1461;
2009 -> 1462;
2009 -> 1994;
2009 -> 1472;
2009 -> 1464;
2010 -> 1615;
2011 -> 2010;
2011 -> 1484;
2012 -> 2011;
2012 -> 1486;
2012 -> 1484;
2013 -> 1482;
2013 -> 1516;
2013 -> 1611;
2013 -> 2012;
2013 -> 1620;
2013 -> 1510;
2013 -> 1511;
2013 -> 1998;
2013 -> 1518;
2013 -> 1515;
2014 -> 1635;
2015 -> 2014;
2015 -> 1530;
2016 -> 2015;
2016 -> 1532;
2016 -> 1530;
2017 -> 1528;
2017 -> 1562;
2017 -> 1631;
2017 -> 2016;
2017 -> 1640;
2017 -> 1556;
2017 -> 1557;
2017 -> 2002;
2017 -> 1564;
2017 -> 1561;
2018 -> 1576;
2019 -> 2018;
2019 -> 1397;
2020 -> 2019;
2020 -> 1399;
2020 -> 1397;
2021 -> 1595;
2022 -> 2021;
2022 -> 1435;
2023 -> 2022;
2023 -> 1437;
2023 -> 1435;
2024 -> 1433;
2024 -> 1465;
2024 -> 1591;
2024 -> 2023;
2024 -> 1600;
2024 -> 1461;
2024 -> 1462;
2024 -> 2009;
2024 -> 1472;
2024 -> 1464;
2025 -> 1615;
2026 -> 2025;
2026 -> 1484;
2027 -> 2026;
2027 -> 1486;
2027 -> 1484;
2028 -> 1482;
2028 -> 1516;
2028 -> 1611;
2028 -> 2027;
2028 -> 1620;
2028 -> 1510;
2028 -> 1511;
2028 -> 2013;
2028 -> 1518;
2028 -> 1515;
2029 -> 1635;
2030 -> 2029;
2030 -> 1530;
2031 -> 2030;
2031 -> 1532;
2031 -> 1530;
2032 -> 1528;
2032 -> 1562;
2032 -> 1631;
2032 -> 2031;
2032 -> 1640;
2032 -> 1556;
2032 -> 1557;
2032 -> 2017;
2032 -> 1564;
2032 -> 1561;
2033 -> 1576;
2034 -> 2033;
2034 -> 1397;
2035 -> 2034;
2035 -> 1399;
2035 -> 1397;
2036 -> 1595;
2037 -> 2036;
2037 -> 1435;
2038 -> 2037;
2038 -> 1437;
2038 -> 1435;
2039 -> 1433;
2039 -> 1465;
2039 -> 1591;
2039 -> 2038;
2039 -> 1600;
2039 -> 1461;
2039 -> 1462;
2039 -> 2024;
2039 -> 1472;
2039 -> 1464;
2040 -> 1615;
2041 -> 2040;
2041 -> 1484;
2042 -> 2041;
2042 -> 1486;
2042 -> 1484;
2043 -> 1482;
2043 -> 1516;
2043 -> 1611;
2043 -> 2042;
2043 -> 1620;
2043 -> 1510;
2043 -> 1511;
2043 -> 2028;
2043 -> 1518;
2043 -> 1515;
2044 -> 1635;
2045 -> 2044;
2045 -> 1530;
2046 -> 2045;
2046 -> 1532;
2046 -> 1530;
2047 -> 1528;
2047 -> 1562;
2047 -> 1631;
2047 -> 2046;
2047 -> 1640;
2047 -> 1556;
2047 -> 1557;
2047 -> 2032;
2047 -> 1564;
2047 -> 1561;
2048 -> 1576;
2049 -> 2048;
2049 -> 1397;
2050 -> 2049;
2050 -> 1399;
2050 -> 1397;
2051 -> 1595;
2052 -> 2051;
2052 -> 1435;
2053 -> 2052;
2053 -> 1437;
2053 -> 1435;
2054 -> 1433;
2054 -> 1465;
2054 -> 1591;
2054 -> 2053;
2054 -> 1600;
2054 -> 1461;
2054 -> 1462;
2054 -> 2039;
2054 -> 1472;
2054 -> 1464;
2055 -> 1615;
2056 -> 2055;
2056 -> 1484;
2057 -> 2056;
2057 -> 1486;
2057 -> 1484;
2058 -> 1482;
2058 -> 1516;
2058 -> 1611;
2058 -> 2057;
2058 -> 1620;
2058 -> 1510;
2058 -> 1511;
2058 -> 2043;
2058 -> 1518;
2058 -> 1515;
2059 -> 1635;
2060 -> 2059;
2060 -> 1530;
2061 -> 2060;
2061 -> 1532;
2061 -> 1530;
2062 -> 1528;
2062 -> 1562;
2062 -> 1631;
2062 -> 2061;
2062 -> 1640;
2062 -> 1556;
2062 -> 1557;
2062 -> 2047;
2062 -> 1564;
2062 -> 1561;
2063 -> 0;
2063 -> 1576;
2064 -> 2063;
2064 -> 1397;
2065 -> 2064;
2065 -> 1399;
2065 -> 1397;
2066 -> 0;
2066 -> 1595;
2067 -> 2066;
2067 -> 1435;
2068 -> 2067;
2068 -> 1437;
2068 -> 1435;
2069 -> 1433;
2069 -> 1465;
2069 -> 1591;
2069 -> 2068;
2069 -> 1600;
2069 -> 1461;
2069 -> 1462;
2069 -> 2054;
2069 -> 1472;
2069 -> 1464;
2070 -> 0;
2070 -> 1615;
2071 -> 2070;
2071 -> 1484;
2072 -> 2071;
2072 -> 1486;
2072 -> 1484;
2073 -> 1482;
2073 -> 1516;
2073 -> 1611;
2073 -> 2072;
2073 -> 1620;
2073 -> 1510;
2073 -> 1511;
2073 -> 2058;
2073 -> 1518;
2073 -> 1515;
2074 -> 0;
2074 -> 1635;
2075 -> 2074;
2075 -> 1530;
2076 -> 2075;
2076 -> 1532;
2076 -> 1530;
2077 -> 1528;
2077 -> 1562;
2077 -> 1631;
2077 -> 2076;
2077 -> 1640;
2077 -> 1556;
2077 -> 1557;
2077 -> 2062;
2077 -> 1564;
2077 -> 1561;
2078 -> 1576;
2079 -> 2078;
2079 -> 1397;
2080 -> 2079;
2080 -> 1399;
2080 -> 1397;
2081 -> 1595;
2082 -> 2081;
2082 -> 1435;
2083 -> 2082;
2083 -> 1437;
2083 -> 1435;
2084 -> 1433;
2084 -> 1465;
2084 -> 1591;
2084 -> 2083;
2084 -> 1600;
2084 -> 1461;
2084 -> 1462;
2084 -> 2069;
2084 -> 1472;
2084 -> 1464;
2085 -> 1615;
2086 -> 2085;
2086 -> 1484;
2087 -> 2086;
2087 -> 1486;
2087 -> 1484;
2088 -> 1482;
2088 -> 1516;
2088 -> 1611;
2088 -> 2087;
2088 -> 1620;
2088 -> 1510;
2088 -> 1511;
2088 -> 2073;
2088 -> 1518;
2088 -> 1515;
2089 -> 1635;
2090 -> 2089;
2090 -> 1530;
2091 -> 2090;
2091 -> 1532;
2091 -> 1530;
2092 -> 1528;
2092 -> 1562;
2092 -> 1631;
2092 -> 2091;
2092 -> 1640;
2092 -> 1556;
2092 -> 1557;
2092 -> 2077;
2092 -> 1564;
2092 -> 1561;
2093 -> 1576;
2094 -> 2093;
2094 -> 1397;
2095 -> 2094;
2095 -> 1399;
2095 -> 1397;
2096 -> 1595;
2097 -> 2096;
2097 -> 1435;
2098 -> 2097;
2098 -> 1437;
2098 -> 1435;
2099 -> 1433;
2099 -> 1465;
2099 -> 1591;
2099 -> 2098;
2099 -> 1600;
2099 -> 1461;
2099 -> 1462;
2099 -> 2084;
2099 -> 1472;
2099 -> 1464;
2100 -> 1615;
2101 -> 2100;
2101 -> 1484;
2102 -> 2101;
2102 -> 1486;
2102 -> 1484;
2103 -> 1482;
2103 -> 1516;
2103 -> 1611;
2103 -> 2102;
2103 -> 1620;
2103 -> 1510;
2103 -> 1511;
2103 -> 2088;
2103 -> 1518;
2103 -> 1515;
2104 -> 1635;
2105 -> 2104;
2105 -> 1530;
2106 -> 2105;
2106 -> 1532;
2106 -> 1530;
2107 -> 1528;
2107 -> 1562;
2107 -> 1631;
2107 -> 2106;
2107 -> 1640;
2107 -> 1556;
2107 -> 1557;
2107 -> 2092;
2107 -> 1564;
2107 -> 1561;
2108 -> 1576;
2109 -> 2108;
2109 -> 1397;
2110 -> 2109;
2110 -> 1399;
2110 -> 1397;
2111 -> 1595;
2112 -> 2111;
2112 -> 1435;
2113 -> 2112;
2113 -> 1437;
2113 -> 1435;
2114 -> 1433;
2114 -> 1465;
2114 -> 1591;
2114 -> 2113;
2114 -> 1600;
2114 -> 1461;
2114 -> 1462;
2114 -> 2099;
2114 -> 1472;
2114 -> 1464;
2115 -> 1615;
2116 -> 2115;
2116 -> 1484;
2117 -> 2116;
2117 -> 1486;
2117 -> 1484;
2118 -> 1482;
2118 -> 1516;
2118 -> 1611;
2118 -> 2117;
2118 -> 1620;
2118 -> 1510;
2118 -> 1511;
2118 -> 2103;
2118 -> 1518;
2118 -> 1515;
2119 -> 1635;
2120 -> 2119;
2120 -> 1530;
2121 -> 2120;
2121 -> 1532;
2121 -> 1530;
2122 -> 1528;
2122 -> 1562;
2122 -> 1631;
2122 -> 2121;
2122 -> 1640;
2122 -> 1556;
2122 -> 1557;
2122 -> 2107;
2122 -> 1564;
2122 -> 1561;
2123 -> 1576;
2124 -> 2123;
2124 -> 1397;
2125 -> 2124;
2125 -> 1399;
2125 -> 1397;
2126 -> 1595;
2127 -> 2126;
2127 -> 1435;
2128 -> 2127;
2128 -> 1437;
2128 -> 1435;
2129 -> 1433;
2129 -> 1465;
2129 -> 1591;
2129 -> 2128;
2129 -> 1600;
2129 -> 1461;
2129 -> 1462;
2129 -> 2114;
2129 -> 1472;
2129 -> 1464;
2130 -> 1615;
2131 -> 2130;
2131 -> 1484;
2132 -> 2131;
2132 -> 1486;
2132 -> 1484;
2133 -> 1482;
2133 -> 1516;
2133 -> 1611;
2133 -> 2132;
2133 -> 1620;
2133 -> 1510;
2133 -> 1511;
2133 -> 2118;
2133 -> 1518;
2133 -> 1515;
2134 -> 1635;
2135 -> 2134;
2135 -> 1530;
2136 -> 2135;
2136 -> 1532;
2136 -> 1530;
2137 -> 1528;
2137 -> 1562;
2137 -> 1631;
2137 -> 2136;
2137 -> 1640;
2137 -> 1556;
2137 -> 1557;
2137 -> 2122;
2137 -> 1564;
2137 -> 1561;
2138 -> 1576;
2139 -> 2138;
2139 -> 1397;
2140 -> 2139;
2140 -> 1399;
2140 -> 1397;
2141 -> 1595;
2142 -> 2141;
2142 -> 1435;
2143 -> 2142;
2143 -> 1437;
2143 -> 1435;
2144 -> 1433;
2144 -> 1465;
2144 -> 1591;
2144 -> 2143;
2144 -> 1600;
2144 -> 1461;
2144 -> 1462;
2144 -> 2129;
2144 -> 1472;
2144 -> 1464;
2145 -> 1615;
2146 -> 2145;
2146 -> 1484;
2147 -> 2146;
2147 -> 1486;
2147 -> 1484;
2148 -> 1482;
2148 -> 1516;
2148 -> 1611;
2148 -> 2147;
2148 -> 1620;
2148 -> 1510;
2148 -> 1511;
2148 -> 2133;
2148 -> 1518;
2148 -> 1515;
2149 -> 1635;
2150 -> 2149;
2150 -> 1530;
2151 -> 2150;
2151 -> 1532;
2151 -> 1530;
2152 -> 1528;
2152 -> 1562;
2152 -> 1631;
2152 -> 2151;
2152 -> 1640;
2152 -> 1556;
2152 -> 1557;
2152 -> 2137;
2152 -> 1564;
2152 -> 1561;
2153 -> 1576;
2154 -> 2153;
2154 -> 1397;
2155 -> 2154;
2155 -> 1399;
2155 -> 1397;
2156 -> 1595;
2157 -> 2156;
2157 -> 1435;
2158 -> 2157;
2158 -> 1437;
2158 -> 1435;
2159 -> 1433;
2159 -> 1465;
2159 -> 1591;
2159 -> 2158;
2159 -> 1600;
2159 -> 1461;
2159 -> 1462;
2159 -> 2144;
2159 -> 1472;
2159 -> 1464;
2160 -> 1615;
2161 -> 2160;
2161 -> 1484;
2162 -> 2161;
2162 -> 1486;
2162 -> 1484;
2163 -> 1482;
2163 -> 1516;
2163 -> 1611;
2163 -> 2162;
2163 -> 1620;
2163 -> 1510;
2163 -> 1511;
2163 -> 2148;
2163 -> 1518;
2163 -> 1515;
2164 -> 1635;
2165 -> 2164;
2165 -> 1530;
2166 -> 2165;
2166 -> 1532;
2166 -> 1530;
2167 -> 1528;
2167 -> 1562;
2167 -> 1631;
2167 -> 2166;
2167 -> 1640;
2167 -> 1556;
2167 -> 1557;
2167 -> 2152;
2167 -> 1564;
2167 -> 1561;
2168 -> 1576;
2169 -> 2168;
2169 -> 1397;
2170 -> 2169;
2170 -> 1399;
2170 -> 1397;
2171 -> 1595;
2172 -> 2171;
2172 -> 1435;
2173 -> 2172;
2173 -> 1437;
2173 -> 1435;
2174 -> 1433;
2174 -> 1465;
2174 -> 1591;
2174 -> 2173;
2174 -> 1600;
2174 -> 1461;
2174 -> 1462;
2174 -> 2159;
2174 -> 1472;
2174 -> 1464;
2175 -> 1615;
2176 -> 2175;
2176 -> 1484;
2177 -> 2176;
2177 -> 1486;
2177 -> 1484;
2178 -> 1482;
2178 -> 1516;
2178 -> 1611;
2178 -> 2177;
2178 -> 1620;
2178 -> 1510;
2178 -> 1511;
2178 -> 2163;
2178 -> 1518;
2178 -> 1515;
2179 -> 1635;
2180 -> 2179;
2180 -> 1530;
2181 -> 2180;
2181 -> 1532;
2181 -> 1530;
2182 -> 1528;
2182 -> 1562;
2182 -> 1631;
2182 -> 2181;
2182 -> 1640;
2182 -> 1556;
2182 -> 1557;
2182 -> 2167;
2182 -> 1564;
2182 -> 1561;
2183 -> 1576;
2184 -> 2183;
2184 -> 1397;
2185 -> 2184;
2185 -> 1399;
2185 -> 1397;
2186 -> 1595;
2187 -> 2186;
2187 -> 1435;
2188 -> 2187;
2188 -> 1437;
2188 -> 1435;
2189 -> 1433;
2189 -> 1465;
2189 -> 1591;
2189 -> 2188;
2189 -> 1600;
2189 -> 1461;
2189 -> 1462;
2189 -> 2174;
2189 -> 1472;
2189 -> 1464;
2190 -> 1615;
2191 -> 2190;
2191 -> 1484;
2192 -> 2191;
2192 -> 1486;
2192 -> 1484;
2193 -> 1482;
2193 -> 1516;
2193 -> 1611;
2193 -> 2192;
2193 -> 1620;
2193 -> 1510;
2193 -> 1511;
2193 -> 2178;
2193 -> 1518;
2193 -> 1515;
2194 -> 1635;
2195 -> 2194;
2195 -> 1530;
2196 -> 2195;
2196 -> 1532;
2196 -> 1530;
2197 -> 1528;
2197 -> 1562;
2197 -> 1631;
2197 -> 2196;
2197 -> 1640;
2197 -> 1556;
2197 -> 1557;
2197 -> 2182;
2197 -> 1564;
2197 -> 1561;
2198 -> 1576;
2199 -> 2198;
2199 -> 1397;
2200 -> 2199;
2200 -> 1399;
2200 -> 1397;
2201 -> 1595;
2202 -> 2201;
2202 -> 1435;
2203 -> 2202;
2203 -> 1437;
2203 -> 1435;
2204 -> 1433;
2204 -> 1465;
2204 -> 1591;
2204 -> 2203;
2204 -> 1600;
2204 -> 1461;
2204 -> 1462;
2204 -> 2189;
2204 -> 1472;
2204 -> 1464;
2205 -> 1615;
2206 -> 2205;
2206 -> 1484;
2207 -> 2206;
2207 -> 1486;
2207 -> 1484;
2208 -> 1482;
2208 -> 1516;
2208 -> 1611;
2208 -> 2207;
2208 -> 1620;
2208 -> 1510;
2208 -> 1511;
2208 -> 2193;
2208 -> 1518;
2208 -> 1515;
2209 -> 1635;
2210 -> 2209;
2210 -> 1530;
2211 -> 2210;
2211 -> 1532;
2211 -> 1530;
2212 -> 1528;
2212 -> 1562;
2212 -> 1631;
2212 -> 2211;
2212 -> 1640;
2212 -> 1556;
2212 -> 1557;
2212 -> 2197;
2212 -> 1564;
2212 -> 1561;
2213 -> 1576;
2214 -> 2213;
2214 -> 1397;
2215 -> 2214;
2215 -> 1399;
2215 -> 1397;
2216 -> 1595;
2217 -> 2216;
2217 -> 1435;
2218 -> 2217;
2218 -> 1437;
2218 -> 1435;
2219 -> 1433;
2219 -> 1465;
2219 -> 1591;
2219 -> 2218;
2219 -> 1600;
2219 -> 1461;
2219 -> 1462;
2219 -> 2204;
2219 -> 1472;
2219 -> 1464;
2220 -> 1615;
2221 -> 2220;
2221 -> 1484;
2222 -> 2221;
2222 -> 1486;
2222 -> 1484;
2223 -> 1482;
2223 -> 1516;
2223 -> 1611;
2223 -> 2222;
2223 -> 1620;
2223 -> 1510;
2223 -> 1511;
2223 -> 2208;
2223 -> 1518;
2223 -> 1515;
2224 -> 1635;
2225 -> 2224;
2225 -> 1530;
2226 -> 2225;
2226 -> 1532;
2226 -> 1530;
2227 -> 1528;
2227 -> 1562;
2227 -> 1631;
2227 -> 2226;
2227 -> 1640;
2227 -> 1556;
2227 -> 1557;
2227 -> 2212;
2227 -> 1564;
2227 -> 1561;
2228 -> 1576;
2229 -> 2228;
2229 -> 1397;
2230 -> 2229;
2230 -> 1399;
2230 -> 1397;
2231 -> 1595;
2232 -> 2231;
2232 -> 1435;
2233 -> 2232;
2233 -> 1437;
2233 -> 1435;
2234 -> 1433;
2234 -> 1465;
2234 -> 1591;
2234 -> 2233;
2234 -> 1600;
2234 -> 1461;
2234 -> 1462;
2234 -> 2219;
2234 -> 1472;
2234 -> 1464;
2235 -> 1615;
2236 -> 2235;
2236 -> 1484;
2237 -> 2236;
2237 -> 1486;
2237 -> 1484;
2238 -> 1482;
2238 -> 1516;
2238 -> 1611;
2238 -> 2237;
2238 -> 1620;
2238 -> 1510;
2238 -> 1511;
2238 -> 2223;
2238 -> 1518;
2238 -> 1515;
2239 -> 1635;
2240 -> 2239;
2240 -> 1530;
2241 -> 2240;
2241 -> 1532;
2241 -> 1530;
2242 -> 1528;
2242 -> 1562;
2242 -> 1631;
2242 -> 2241;
2242 -> 1640;
2242 -> 1556;
2242 -> 1557;
2242 -> 2227;
2242 -> 1564;
2242 -> 1561;
2243 -> 1576;
2244 -> 2243;
2244 -> 1397;
2245 -> 2244;
2245 -> 1399;
2245 -> 1397;
2246 -> 1595;
2247 -> 2246;
2247 -> 1435;
2248 -> 2247;
2248 -> 1437;
2248 -> 1435;
2249 -> 1433;
2249 -> 1465;
2249 -> 1591;
2249 -> 2248;
2249 -> 1600;
2249 -> 1461;
2249 -> 1462;
2249 -> 2234;
2249 -> 1472;
2249 -> 1464;
2250 -> 1615;
2251 -> 2250;
2251 -> 1484;
2252 -> 2251;
2252 -> 1486;
2252 -> 1484;
2253 -> 1482;
2253 -> 1516;
2253 -> 1611;
2253 -> 2252;
2253 -> 1620;
2253 -> 1510;
2253 -> 1511;
2253 -> 2238;
2253 -> 1518;
2253 -> 1515;
2254 -> 1635;
2255 -> 2254;
2255 -> 1530;
2256 -> 2255;
2256 -> 1532;
2256 -> 1530;
2257 -> 1528;
2257 -> 1562;
2257 -> 1631;
2257 -> 2256;
2257 -> 1640;
2257 -> 1556;
2257 -> 1557;
2257 -> 2242;
2257 -> 1564;
2257 -> 1561;
2258 -> 1576;
2259 -> 2258;
2259 -> 1397;
2260 -> 2259;
2260 -> 1399;
2260 -> 1397;
2261 -> 1595;
2262 -> 2261;
2262 -> 1435;
2263 -> 2262;
2263 -> 1437;
2263 -> 1435;
2264 -> 1433;
2264 -> 1465;
2264 -> 1591;
2264 -> 2263;
2264 -> 1600;
2264 -> 1461;
2264 -> 1462;
2264 -> 2249;
2264 -> 1472;
2264 -> 1464;
2265 -> 1615;
2266 -> 2265;
2266 -> 1484;
2267 -> 2266;
2267 -> 1486;
2267 -> 1484;
2268 -> 1482;
2268 -> 1516;
2268 -> 1611;
2268 -> 2267;
2268 -> 1620;
2268 -> 1510;
2268 -> 1511;
2268 -> 2253;
2268 -> 1518;
2268 -> 1515;
2269 -> 1635;
2270 -> 2269;
2270 -> 1530;
2271 -> 2270;
2271 -> 1532;
2271 -> 1530;
2272 -> 1528;
2272 -> 1562;
2272 -> 1631;
2272 -> 2271;
2272 -> 1640;
2272 -> 1556;
2272 -> 1557;
2272 -> 2257;
2272 -> 1564;
2272 -> 1561;
2273 -> 1576;
2274 -> 2273;
2274 -> 1397;
2275 -> 2274;
2275 -> 1399;
2275 -> 1397;
2276 -> 1595;
2277 -> 2276;
2277 -> 1435;
2278 -> 2277;
2278 -> 1437;
2278 -> 1435;
2279 -> 1433;
2279 -> 1465;
2279 -> 1591;
2279 -> 2278;
2279 -> 1600;
2279 -> 1461;
2279 -> 1462;
2279 -> 2264;
2279 -> 1472;
2279 -> 1464;
2280 -> 1615;
2281 -> 2280;
2281 -> 1484;
2282 -> 2281;
2282 -> 1486;
2282 -> 1484;
2283 -> 1482;
2283 -> 1516;
2283 -> 1611;
2283 -> 2282;
2283 -> 1620;
2283 -> 1510;
2283 -> 1511;
2283 -> 2268;
2283 -> 1518;
2283 -> 1515;
2284 -> 1635;
2285 -> 2284;
2285 -> 1530;
2286 -> 2285;
2286 -> 1532;
2286 -> 1530;
2287 -> 1528;
2287 -> 1562;
2287 -> 1631;
2287 -> 2286;
2287 -> 1640;
2287 -> 1556;
2287 -> 1557;
2287 -> 2272;
2287 -> 1564;
2287 -> 1561;
2288 -> 1576;
2289 -> 2288;
2289 -> 1397;
2290 -> 2289;
2290 -> 1399;
2290 -> 1397;
2291 -> 1595;
2292 -> 2291;
2292 -> 1435;
2293 -> 2292;
2293 -> 1437;
2293 -> 1435;
2294 -> 1433;
2294 -> 1465;
2294 -> 1591;
2294 -> 2293;
2294 -> 1600;
2294 -> 1461;
2294 -> 1462;
2294 -> 2279;
2294 -> 1472;
2294 -> 1464;
2295 -> 1615;
2296 -> 2295;
2296 -> 1484;
2297 -> 2296;
2297 -> 1486;
2297 -> 1484;
2298 -> 1482;
2298 -> 1516;
2298 -> 1611;
2298 -> 2297;
2298 -> 1620;
2298 -> 1510;
2298 -> 1511;
2298 -> 2283;
2298 -> 1518;
2298 -> 1515;
2299 -> 1635;
2300 -> 2299;
2300 -> 1530;
2301 -> 2300;
2301 -> 1532;
2301 -> 1530;
2302 -> 1528;
2302 -> 1562;
2302 -> 1631;
2302 -> 2301;
2302 -> 1640;
2302 -> 1556;
2302 -> 1557;
2302 -> 2287;
2302 -> 1564;
2302 -> 1561;
2303 -> 1576;
2304 -> 2303;
2304 -> 1397;
2305 -> 2304;
2305 -> 1399;
2305 -> 1397;
2306 -> 1595;
2307 -> 2306;
2307 -> 1435;
2308 -> 2307;
2308 -> 1437;
2308 -> 1435;
2309 -> 1433;
2309 -> 1465;
2309 -> 1591;
2309 -> 2308;
2309 -> 1600;
2309 -> 1461;
2309 -> 1462;
2309 -> 2294;
2309 -> 1472;
2309 -> 1464;
2310 -> 1615;
2311 -> 2310;
2311 -> 1484;
2312 -> 2311;
2312 -> 1486;
2312 -> 1484;
2313 -> 1482;
2313 -> 1516;
2313 -> 1611;
2313 -> 2312;
2313 -> 1620;
2313 -> 1510;
2313 -> 1511;
2313 -> 2298;
2313 -> 1518;
2313 -> 1515;
2314 -> 1635;
2315 -> 2314;
2315 -> 1530;
2316 -> 2315;
2316 -> 1532;
2316 -> 1530;
2317 -> 1528;
2317 -> 1562;
2317 -> 1631;
2317 -> 2316;
2317 -> 1640;
2317 -> 1556;
2317 -> 1557;
2317 -> 2302;
2317 -> 1564;
2317 -> 1561;
2318 -> 1576;
2319 -> 2318;
2319 -> 1397;
2320 -> 2319;
2320 -> 1399;
2320 -> 1397;
2321 -> 1595;
2322 -> 2321;
2322 -> 1435;
2323 -> 2322;
2323 -> 1437;
2323 -> 1435;
2324 -> 1433;
2324 -> 1465;
2324 -> 1591;
2324 -> 2323;
2324 -> 1600;
2324 -> 1461;
2324 -> 1462;
2324 -> 2309;
2324 -> 1472;
2324 -> 1464;
2325 -> 1615;
2326 -> 2325;
2326 -> 1484;
2327 -> 2326;
2327 -> 1486;
2327 -> 1484;
2328 -> 1482;
2328 -> 1516;
2328 -> 1611;
2328 -> 2327;
2328 -> 1620;
2328 -> 1510;
2328 -> 1511;
2328 -> 2313;
2328 -> 1518;
2328 -> 1515;
2329 -> 1635;
2330 -> 2329;
2330 -> 1530;
2331 -> 2330;
2331 -> 1532;
2331 -> 1530;
2332 -> 1528;
2332 -> 1562;
2332 -> 1631;
2332 -> 2331;
2332 -> 1640;
2332 -> 1556;
2332 -> 1557;
2332 -> 2317;
2332 -> 1564;
2332 -> 1561;
2333 -> 1576;
2334 -> 2333;
2334 -> 1397;
2335 -> 2334;
2335 -> 1399;
2335 -> 1397;
2336 -> 1595;
2337 -> 2336;
2337 -> 1435;
2338 -> 2337;
2338 -> 1437;
2338 -> 1435;
2339 -> 1433;
2339 -> 1465;
2339 -> 1591;
2339 -> 2338;
2339 -> 1600;
2339 -> 1461;
2339 -> 1462;
2339 -> 2324;
2339 -> 1472;
2339 -> 1464;
2340 -> 1615;
2341 -> 2340;
2341 -> 1484;
2342 -> 2341;
2342 -> 1486;
2342 -> 1484;
2343 -> 1482;
2343 -> 1516;
2343 -> 1611;
2343 -> 2342;
2343 -> 1620;
2343 -> 1510;
2343 -> 1511;
2343 -> 2328;
2343 -> 1518;
2343 -> 1515;
2344 -> 1635;
2345 -> 2344;
2345 -> 1530;
2346 -> 2345;
2346 -> 1532;
2346 -> 1530;
2347 -> 1528;
2347 -> 1562;
2347 -> 1631;
2347 -> 2346;
2347 -> 1640;
2347 -> 1556;
2347 -> 1557;
2347 -> 2332;
2347 -> 1564;
2347 -> 1561;
2348 -> 1576;
2349 -> 2348;
2349 -> 1397;
2350 -> 2349;
2350 -> 1399;
2350 -> 1397;
2351 -> 1595;
2352 -> 2351;
2352 -> 1435;
2353 -> 2352;
2353 -> 1437;
2353 -> 1435;
2354 -> 1433;
2354 -> 1465;
2354 -> 1591;
2354 -> 2353;
2354 -> 1600;
2354 -> 1461;
2354 -> 1462;
2354 -> 2339;
2354 -> 1472;
2354 -> 1464;
2355 -> 1615;
2356 -> 2355;
2356 -> 1484;
2357 -> 2356;
2357 -> 1486;
2357 -> 1484;
2358 -> 1482;
2358 -> 1516;
2358 -> 1611;
2358 -> 2357;
2358 -> 1620;
2358 -> 1510;
2358 -> 1511;
2358 -> 2343;
2358 -> 1518;
2358 -> 1515;
2359 -> 1635;
2360 -> 2359;
2360 -> 1530;
2361 -> 2360;
2361 -> 1532;
2361 -> 1530;
2362 -> 1528;
2362 -> 1562;
2362 -> 1631;
2362 -> 2361;
2362 -> 1640;
2362 -> 1556;
2362 -> 1557;
2362 -> 2347;
2362 -> 1564;
2362 -> 1561;
2363 -> 1576;
2364 -> 2363;
2364 -> 1397;
2365 -> 2364;
2365 -> 1399;
2365 -> 1397;
2366 -> 1595;
2367 -> 2366;
2367 -> 1435;
2368 -> 2367;
2368 -> 1437;
2368 -> 1435;
2369 -> 1433;
2369 -> 1465;
2369 -> 1591;
2369 -> 2368;
2369 -> 1600;
2369 -> 1461;
2369 -> 1462;
2369 -> 2354;
2369 -> 1472;
2369 -> 1464;
2370 -> 1615;
2371 -> 2370;
2371 -> 1484;
2372 -> 2371;
2372 -> 1486;
2372 -> 1484;
2373 -> 1482;
2373 -> 1516;
2373 -> 1611;
2373 -> 2372;
2373 -> 1620;
2373 -> 1510;
2373 -> 1511;
2373 -> 2358;
2373 -> 1518;
2373 -> 1515;
2374 -> 1635;
2375 -> 2374;
2375 -> 1530;
2376 -> 2375;
2376 -> 1532;
2376 -> 1530;
2377 -> 1528;
2377 -> 1562;
2377 -> 1631;
2377 -> 2376;
2377 -> 1640;
2377 -> 1556;
2377 -> 1557;
2377 -> 2362;
2377 -> 1564;
2377 -> 1561;
2378 -> 1576;
2379 -> 2378;
2379 -> 1397;
2380 -> 2379;
2380 -> 1399;
2380 -> 1397;
2381 -> 1595;
2382 -> 2381;
2382 -> 1435;
2383 -> 2382;
2383 -> 1437;
2383 -> 1435;
2384 -> 1433;
2384 -> 1465;
2384 -> 1591;
2384 -> 2383;
2384 -> 1600;
2384 -> 1461;
2384 -> 1462;
2384 -> 2369;
2384 -> 1472;
2384 -> 1464;
2385 -> 1615;
2386 -> 2385;
2386 -> 1484;
2387 -> 2386;
2387 -> 1486;
2387 -> 1484;
2388 -> 1482;
2388 -> 1516;
2388 -> 1611;
2388 -> 2387;
2388 -> 1620;
2388 -> 1510;
2388 -> 1511;
2388 -> 2373;
2388 -> 1518;
2388 -> 1515;
2389 -> 1635;
2390 -> 2389;
2390 -> 1530;
2391 -> 2390;
2391 -> 1532;
2391 -> 1530;
2392 -> 1528;
2392 -> 1562;
2392 -> 1631;
2392 -> 2391;
2392 -> 1640;
2392 -> 1556;
2392 -> 1557;
2392 -> 2377;
2392 -> 1564;
2392 -> 1561;
2393 -> 1576;
2394 -> 2393;
2394 -> 1397;
2395 -> 2394;
2395 -> 1399;
2395 -> 1397;
2396 -> 1595;
2397 -> 2396;
2397 -> 1435;
2398 -> 2397;
2398 -> 1437;
2398 -> 1435;
2399 -> 1433;
2399 -> 1465;
2399 -> 1591;
2399 -> 2398;
2399 -> 1600;
2399 -> 1461;
2399 -> 1462;
2399 -> 2384;
2399 -> 1472;
2399 -> 1464;
2400 -> 1615;
2401 -> 2400;
2401 -> 1484;
2402 -> 2401;
2402 -> 1486;
2402 -> 1484;
2403 -> 1482;
2403 -> 1516;
2403 -> 1611;
2403 -> 2402;
2403 -> 1620;
2403 -> 1510;
2403 -> 1511;
2403 -> 2388;
2403 -> 1518;
2403 -> 1515;
2404 -> 1635;
2405 -> 2404;
2405 -> 1530;
2406 -> 2405;
2406 -> 1532;
2406 -> 1530;
2407 -> 1528;
2407 -> 1562;
2407 -> 1631;
2407 -> 2406;
2407 -> 1640;
2407 -> 1556;
2407 -> 1557;
2407 -> 2392;
2407 -> 1564;
2407 -> 1561;
2408 -> 1576;
2409 -> 2408;
2409 -> 1397;
2410 -> 2409;
2410 -> 1399;
2410 -> 1397;
2411 -> 1595;
2412 -> 2411;
2412 -> 1435;
2413 -> 2412;
2413 -> 1437;
2413 -> 1435;
2414 -> 1433;
2414 -> 1465;
2414 -> 1591;
2414 -> 2413;
2414 -> 1600;
2414 -> 1461;
2414 -> 1462;
2414 -> 2399;
2414 -> 1472;
2414 -> 1464;
2415 -> 1615;
2416 -> 2415;
2416 -> 1484;
2417 -> 2416;
2417 -> 1486;
2417 -> 1484;
2418 -> 1482;
2418 -> 1516;
2418 -> 1611;
2418 -> 2417;
2418 -> 1620;
2418 -> 1510;
2418 -> 1511;
2418 -> 2403;
2418 -> 1518;
2418 -> 1515;
2419 -> 1635;
2420 -> 2419;
2420 -> 1530;
2421 -> 2420;
2421 -> 1532;
2421 -> 1530;
2422 -> 1528;
2422 -> 1562;
2422 -> 1631;
2422 -> 2421;
2422 -> 1640;
2422 -> 1556;
2422 -> 1557;
2422 -> 2407;
2422 -> 1564;
2422 -> 1561;
2423 -> 1576;
2424 -> 2423;
2424 -> 1397;
2425 -> 2424;
2425 -> 1399;
2425 -> 1397;
2426 -> 1595;
2427 -> 2426;
2427 -> 1435;
2428 -> 2427;
2428 -> 1437;
2428 -> 1435;
2429 -> 1433;
2429 -> 1465;
2429 -> 1591;
2429 -> 2428;
2429 -> 1600;
2429 -> 1461;
2429 -> 1462;
2429 -> 2414;
2429 -> 1472;
2429 -> 1464;
2430 -> 1615;
2431 -> 2430;
2431 -> 1484;
2432 -> 2431;
2432 -> 1486;
2432 -> 1484;
2433 -> 1482;
2433 -> 1516;
2433 -> 1611;
2433 -> 2432;
2433 -> 1620;
2433 -> 1510;
2433 -> 1511;
2433 -> 2418;
2433 -> 1518;
2433 -> 1515;
2434 -> 1635;
2435 -> 2434;
2435 -> 1530;
2436 -> 2435;
2436 -> 1532;
2436 -> 1530;
2437 -> 1528;
2437 -> 1562;
2437 -> 1631;
2437 -> 2436;
2437 -> 1640;
2437 -> 1556;
2437 -> 1557;
2437 -> 2422;
2437 -> 1564;
2437 -> 1561;
2438 -> 1576;
2439 -> 2438;
2439 -> 1397;
2440 -> 2439;
2440 -> 1399;
2440 -> 1397;
2441 -> 1595;
2442 -> 2441;
2442 -> 1435;
2443 -> 2442;
2443 -> 1437;
2443 -> 1435;
2444 -> 1433;
2444 -> 1465;
2444 -> 1591;
2444 -> 2443;
2444 -> 1600;
2444 -> 1461;
2444 -> 1462;
2444 -> 2429;
2444 -> 1472;
2444 -> 1464;
2445 -> 1615;
2446 -> 2445;
2446 -> 1484;
2447 -> 2446;
2447 -> 1486;
2447 -> 1484;
2448 -> 1482;
2448 -> 1516;
2448 -> 1611;
2448 -> 2447;
2448 -> 1620;
2448 -> 1510;
2448 -> 1511;
2448 -> 2433;
2448 -> 1518;
2448 -> 1515;
2449 -> 1635;
2450 -> 2449;
2450 -> 1530;
2451 -> 2450;
2451 -> 1532;
2451 -> 1530;
2452 -> 1528;
2452 -> 1562;
2452 -> 1631;
2452 -> 2451;
2452 -> 1640;
2452 -> 1556;
2452 -> 1557;
2452 -> 2437;
2452 -> 1564;
2452 -> 1561;
2453 -> 1576;
2454 -> 2453;
2454 -> 1397;
2455 -> 2454;
2455 -> 1399;
2455 -> 1397;
2456 -> 1595;
2457 -> 2456;
2457 -> 1435;
2458 -> 2457;
2458 -> 1437;
2458 -> 1435;
2459 -> 1433;
2459 -> 1465;
2459 -> 1591;
2459 -> 2458;
2459 -> 1600;
2459 -> 1461;
2459 -> 1462;
2459 -> 2444;
2459 -> 1472;
2459 -> 1464;
2460 -> 1615;
2461 -> 2460;
2461 -> 1484;
2462 -> 2461;
2462 -> 1486;
2462 -> 1484;
2463 -> 1482;
2463 -> 1516;
2463 -> 1611;
2463 -> 2462;
2463 -> 1620;
2463 -> 1510;
2463 -> 1511;
2463 -> 2448;
2463 -> 1518;
2463 -> 1515;
2464 -> 1635;
2465 -> 2464;
2465 -> 1530;
2466 -> 2465;
2466 -> 1532;
2466 -> 1530;
2467 -> 1528;
2467 -> 1562;
2467 -> 1631;
2467 -> 2466;
2467 -> 1640;
2467 -> 1556;
2467 -> 1557;
2467 -> 2452;
2467 -> 1564;
2467 -> 1561;
2468 -> 1576;
2469 -> 2468;
2469 -> 1397;
2470 -> 2469;
2470 -> 1399;
2470 -> 1397;
2471 -> 1595;
2472 -> 2471;
2472 -> 1435;
2473 -> 2472;
2473 -> 1437;
2473 -> 1435;
2474 -> 1433;
2474 -> 1465;
2474 -> 1591;
2474 -> 2473;
2474 -> 1600;
2474 -> 1461;
2474 -> 1462;
2474 -> 2459;
2474 -> 1472;
2474 -> 1464;
2475 -> 1615;
2476 -> 2475;
2476 -> 1484;
2477 -> 2476;
2477 -> 1486;
2477 -> 1484;
2478 -> 1482;
2478 -> 1516;
2478 -> 1611;
2478 -> 2477;
2478 -> 1620;
2478 -> 1510;
2478 -> 1511;
2478 -> 2463;
2478 -> 1518;
2478 -> 1515;
2479 -> 1635;
2480 -> 2479;
2480 -> 1530;
2481 -> 2480;
2481 -> 1532;
2481 -> 1530;
2482 -> 1528;
2482 -> 1562;
2482 -> 1631;
2482 -> 2481;
2482 -> 1640;
2482 -> 1556;
2482 -> 1557;
2482 -> 2467;
2482 -> 1564;
2482 -> 1561;
2483 -> 1576;
2484 -> 2483;
2484 -> 1397;
2485 -> 2484;
2485 -> 1399;
2485 -> 1397;
2486 -> 1595;
2487 -> 2486;
2487 -> 1435;
2488 -> 2487;
2488 -> 1437;
2488 -> 1435;
2489 -> 1433;
2489 -> 1465;
2489 -> 1591;
2489 -> 2488;
2489 -> 1600;
2489 -> 1461;
2489 -> 1462;
2489 -> 2474;
2489 -> 1472;
2489 -> 1464;
2490 -> 1615;
2491 -> 2490;
2491 -> 1484;
2492 -> 2491;
2492 -> 1486;
2492 -> 1484;
2493 -> 1482;
2493 -> 1516;
2493 -> 1611;
2493 -> 2492;
2493 -> 1620;
2493 -> 1510;
2493 -> 1511;
2493 -> 2478;
2493 -> 1518;
2493 -> 1515;
2494 -> 1635;
2495 -> 2494;
2495 -> 1530;
2496 -> 2495;
2496 -> 1532;
2496 -> 1530;
2497 -> 1528;
2497 -> 1562;
2497 -> 1631;
2497 -> 2496;
2497 -> 1640;
2497 -> 1556;
2497 -> 1557;
2497 -> 2482;
2497 -> 1564;
2497 -> 1561;
2498 -> 1576;
2499 -> 2498;
2499 -> 1397;
2500 -> 2499;
2500 -> 1399;
2500 -> 1397;
2501 -> 1595;
2502 -> 2501;
2502 -> 1435;
2503 -> 2502;
2503 -> 1437;
2503 -> 1435;
2504 -> 1433;
2504 -> 1465;
2504 -> 1591;
2504 -> 2503;
2504 -> 1600;
2504 -> 1461;
2504 -> 1462;
2504 -> 2489;
2504 -> 1472;
2504 -> 1464;
2505 -> 1615;
2506 -> 2505;
2506 -> 1484;
2507 -> 2506;
2507 -> 1486;
2507 -> 1484;
2508 -> 1482;
2508 -> 1516;
2508 -> 1611;
2508 -> 2507;
2508 -> 1620;
2508 -> 1510;
2508 -> 1511;
2508 -> 2493;
2508 -> 1518;
2508 -> 1515;
2509 -> 1635;
2510 -> 2509;
2510 -> 1530;
2511 -> 2510;
2511 -> 1532;
2511 -> 1530;
2512 -> 1528;
2512 -> 1562;
2512 -> 1631;
2512 -> 2511;
2512 -> 1640;
2512 -> 1556;
2512 -> 1557;
2512 -> 2497;
2512 -> 1564;
2512 -> 1561;
2513 -> 1576;
2514 -> 2513;
2514 -> 1397;
2515 -> 2514;
2515 -> 1399;
2515 -> 1397;
2516 -> 1595;
2517 -> 2516;
2517 -> 1435;
2518 -> 2517;
2518 -> 1437;
2518 -> 1435;
2519 -> 1433;
2519 -> 1465;
2519 -> 1591;
2519 -> 2518;
2519 -> 1600;
2519 -> 1461;
2519 -> 1462;
2519 -> 2504;
2519 -> 1472;
2519 -> 1464;
2520 -> 1615;
2521 -> 2520;
2521 -> 1484;
2522 -> 2521;
2522 -> 1486;
2522 -> 1484;
2523 -> 1482;
2523 -> 1516;
2523 -> 1611;
2523 -> 2522;
2523 -> 1620;
2523 -> 1510;
2523 -> 1511;
2523 -> 2508;
2523 -> 1518;
2523 -> 1515;
2524 -> 1635;
2525 -> 2524;
2525 -> 1530;
2526 -> 2525;
2526 -> 1532;
2526 -> 1530;
2527 -> 1528;
2527 -> 1562;
2527 -> 1631;
2527 -> 2526;
2527 -> 1640;
2527 -> 1556;
2527 -> 1557;
2527 -> 2512;
2527 -> 1564;
2527 -> 1561;
2528 -> 1576;
2529 -> 2528;
2529 -> 1397;
2530 -> 2529;
2530 -> 1399;
2530 -> 1397;
2531 -> 1595;
2532 -> 2531;
2532 -> 1435;
2533 -> 2532;
2533 -> 1437;
2533 -> 1435;
2534 -> 1433;
2534 -> 1465;
2534 -> 1591;
2534 -> 2533;
2534 -> 1600;
2534 -> 1461;
2534 -> 1462;
2534 -> 2519;
2534 -> 1472;
2534 -> 1464;
2535 -> 1615;
2536 -> 2535;
2536 -> 1484;
2537 -> 2536;
2537 -> 1486;
2537 -> 1484;
2538 -> 1482;
2538 -> 1516;
2538 -> 1611;
2538 -> 2537;
2538 -> 1620;
2538 -> 1510;
2538 -> 1511;
2538 -> 2523;
2538 -> 1518;
2538 -> 1515;
2539 -> 1635;
2540 -> 2539;
2540 -> 1530;
2541 -> 2540;
2541 -> 1532;
2541 -> 1530;
2542 -> 1528;
2542 -> 1562;
2542 -> 1631;
2542 -> 2541;
2542 -> 1640;
2542 -> 1556;
2542 -> 1557;
2542 -> 2527;
2542 -> 1564;
2542 -> 1561;
2543 -> 1576;
2544 -> 2543;
2544 -> 1397;
2545 -> 2544;
2545 -> 1399;
2545 -> 1397;
2546 -> 1595;
2547 -> 2546;
2547 -> 1435;
2548 -> 2547;
2548 -> 1437;
2548 -> 1435;
2549 -> 1433;
2549 -> 1465;
2549 -> 1591;
2549 -> 2548;
2549 -> 1600;
2549 -> 1461;
2549 -> 1462;
2549 -> 2534;
2549 -> 1472;
2549 -> 1464;
2550 -> 1615;
2551 -> 2550;
2551 -> 1484;
2552 -> 2551;
2552 -> 1486;
2552 -> 1484;
2553 -> 1482;
2553 -> 1516;
2553 -> 1611;
2553 -> 2552;
2553 -> 1620;
2553 -> 1510;
2553 -> 1511;
2553 -> 2538;
2553 -> 1518;
2553 -> 1515;
2554 -> 1635;
2555 -> 2554;
2555 -> 1530;
2556 -> 2555;
2556 -> 1532;
2556 -> 1530;
2557 -> 1528;
2557 -> 1562;
2557 -> 1631;
2557 -> 2556;
2557 -> 1640;
2557 -> 1556;
2557 -> 1557;
2557 -> 2542;
2557 -> 1564;
2557 -> 1561;
2558 -> 1576;
2559 -> 2558;
2559 -> 1397;
2560 -> 2559;
2560 -> 1399;
2560 -> 1397;
2561 -> 1595;
2562 -> 2561;
2562 -> 1435;
2563 -> 2562;
2563 -> 1437;
2563 -> 1435;
2564 -> 1433;
2564 -> 1465;
2564 -> 1591;
2564 -> 2563;
2564 -> 1600;
2564 -> 1461;
2564 -> 1462;
2564 -> 2549;
2564 -> 1472;
2564 -> 1464;
2565 -> 1615;
2566 -> 2565;
2566 -> 1484;
2567 -> 2566;
2567 -> 1486;
2567 -> 1484;
2568 -> 1482;
2568 -> 1516;
2568 -> 1611;
2568 -> 2567;
2568 -> 1620;
2568 -> 1510;
2568 -> 1511;
2568 -> 2553;
2568 -> 1518;
2568 -> 1515;
2569 -> 1635;
2570 -> 2569;
2570 -> 1530;
2571 -> 2570;
2571 -> 1532;
2571 -> 1530;
2572 -> 1528;
2572 -> 1562;
2572 -> 1631;
2572 -> 2571;
2572 -> 1640;
2572 -> 1556;
2572 -> 1557;
2572 -> 2557;
2572 -> 1564;
2572 -> 1561;
2573 -> 1576;
2574 -> 2573;
2574 -> 1397;
2575 -> 2574;
2575 -> 1399;
2575 -> 1397;
2576 -> 1595;
2577 -> 2576;
2577 -> 1435;
2578 -> 2577;
2578 -> 1437;
2578 -> 1435;
2579 -> 1433;
2579 -> 1465;
2579 -> 1591;
2579 -> 2578;
2579 -> 1600;
2579 -> 1461;
2579 -> 1462;
2579 -> 2564;
2579 -> 1472;
2579 -> 1464;
2580 -> 1615;
2581 -> 2580;
2581 -> 1484;
2582 -> 2581;
2582 -> 1486;
2582 -> 1484;
2583 -> 1482;
2583 -> 1516;
2583 -> 1611;
2583 -> 2582;
2583 -> 1620;
2583 -> 1510;
2583 -> 1511;
2583 -> 2568;
2583 -> 1518;
2583 -> 1515;
2584 -> 1635;
2585 -> 2584;
2585 -> 1530;
2586 -> 2585;
2586 -> 1532;
2586 -> 1530;
2587 -> 1528;
2587 -> 1562;
2587 -> 1631;
2587 -> 2586;
2587 -> 1640;
2587 -> 1556;
2587 -> 1557;
2587 -> 2572;
2587 -> 1564;
2587 -> 1561;
2588 -> 1576;
2589 -> 2588;
2589 -> 1397;
2590 -> 2589;
2590 -> 1399;
2590 -> 1397;
2591 -> 1595;
2592 -> 2591;
2592 -> 1435;
2593 -> 2592;
2593 -> 1437;
2593 -> 1435;
2594 -> 1433;
2594 -> 1465;
2594 -> 1591;
2594 -> 2593;
2594 -> 1600;
2594 -> 1461;
2594 -> 1462;
2594 -> 2579;
2594 -> 1472;
2594 -> 1464;
2595 -> 1615;
2596 -> 2595;
2596 -> 1484;
2597 -> 2596;
2597 -> 1486;
2597 -> 1484;
2598 -> 1482;
2598 -> 1516;
2598 -> 1611;
2598 -> 2597;
2598 -> 1620;
2598 -> 1510;
2598 -> 1511;
2598 -> 2583;
2598 -> 1518;
2598 -> 1515;
2599 -> 1635;
2600 -> 2599;
2600 -> 1530;
2601 -> 2600;
2601 -> 1532;
2601 -> 1530;
2602 -> 1528;
2602 -> 1562;
2602 -> 1631;
2602 -> 2601;
2602 -> 1640;
2602 -> 1556;
2602 -> 1557;
2602 -> 2587;
2602 -> 1564;
2602 -> 1561;
2603 -> 1576;
2604 -> 2603;
2604 -> 1397;
2605 -> 2604;
2605 -> 1399;
2605 -> 1397;
2606 -> 1595;
2607 -> 2606;
2607 -> 1435;
2608 -> 2607;
2608 -> 1437;
2608 -> 1435;
2609 -> 1433;
2609 -> 1465;
2609 -> 1591;
2609 -> 2608;
2609 -> 1600;
2609 -> 1461;
2609 -> 1462;
2609 -> 2594;
2609 -> 1472;
2609 -> 1464;
2610 -> 1615;
2611 -> 2610;
2611 -> 1484;
2612 -> 2611;
2612 -> 1486;
2612 -> 1484;
2613 -> 1482;
2613 -> 1516;
2613 -> 1611;
2613 -> 2612;
2613 -> 1620;
2613 -> 1510;
2613 -> 1511;
2613 -> 2598;
2613 -> 1518;
2613 -> 1515;
2614 -> 1635;
2615 -> 2614;
2615 -> 1530;
2616 -> 2615;
2616 -> 1532;
2616 -> 1530;
2617 -> 1528;
2617 -> 1562;
2617 -> 1631;
2617 -> 2616;
2617 -> 1640;
2617 -> 1556;
2617 -> 1557;
2617 -> 2602;
2617 -> 1564;
2617 -> 1561;
2618 -> 1576;
2619 -> 2618;
2619 -> 1397;
2620 -> 2619;
2620 -> 1399;
2620 -> 1397;
2621 -> 1595;
2622 -> 2621;
2622 -> 1435;
2623 -> 2622;
2623 -> 1437;
2623 -> 1435;
2624 -> 1433;
2624 -> 1465;
2624 -> 1591;
2624 -> 2623;
2624 -> 1600;
2624 -> 1461;
2624 -> 1462;
2624 -> 2609;
2624 -> 1472;
2624 -> 1464;
2625 -> 1615;
2626 -> 2625;
2626 -> 1484;
2627 -> 2626;
2627 -> 1486;
2627 -> 1484;
2628 -> 1482;
2628 -> 1516;
2628 -> 1611;
2628 -> 2627;
2628 -> 1620;
2628 -> 1510;
2628 -> 1511;
2628 -> 2613;
2628 -> 1518;
2628 -> 1515;
2629 -> 1635;
2630 -> 2629;
2630 -> 1530;
2631 -> 2630;
2631 -> 1532;
2631 -> 1530;
2632 -> 1528;
2632 -> 1562;
2632 -> 1631;
2632 -> 2631;
2632 -> 1640;
2632 -> 1556;
2632 -> 1557;
2632 -> 2617;
2632 -> 1564;
2632 -> 1561;
2633 -> 1576;
2634 -> 2633;
2634 -> 1397;
2635 -> 2634;
2635 -> 1399;
2635 -> 1397;
2636 -> 1595;
2637 -> 2636;
2637 -> 1435;
2638 -> 2637;
2638 -> 1437;
2638 -> 1435;
2639 -> 1433;
2639 -> 1465;
2639 -> 1591;
2639 -> 2638;
2639 -> 1600;
2639 -> 1461;
2639 -> 1462;
2639 -> 2624;
2639 -> 1472;
2639 -> 1464;
2640 -> 1615;
2641 -> 2640;
2641 -> 1484;
2642 -> 2641;
2642 -> 1486;
2642 -> 1484;
2643 -> 1482;
2643 -> 1516;
2643 -> 1611;
2643 -> 2642;
2643 -> 1620;
2643 -> 1510;
2643 -> 1511;
2643 -> 2628;
2643 -> 1518;
2643 -> 1515;
2644 -> 1635;
2645 -> 2644;
2645 -> 1530;
2646 -> 2645;
2646 -> 1532;
2646 -> 1530;
2647 -> 1528;
2647 -> 1562;
2647 -> 1631;
2647 -> 2646;
2647 -> 1640;
2647 -> 1556;
2647 -> 1557;
2647 -> 2632;
2647 -> 1564;
2647 -> 1561;
2648 -> 1576;
2649 -> 2648;
2649 -> 1397;
2650 -> 2649;
2650 -> 1399;
2650 -> 1397;
2651 -> 1595;
2652 -> 2651;
2652 -> 1435;
2653 -> 2652;
2653 -> 1437;
2653 -> 1435;
2654 -> 1433;
2654 -> 1465;
2654 -> 1591;
2654 -> 2653;
2654 -> 1600;
2654 -> 1461;
2654 -> 1462;
2654 -> 2639;
2654 -> 1472;
2654 -> 1464;
2655 -> 1615;
2656 -> 2655;
2656 -> 1484;
2657 -> 2656;
2657 -> 1486;
2657 -> 1484;
2658 -> 1482;
2658 -> 1516;
2658 -> 1611;
2658 -> 2657;
2658 -> 1620;
2658 -> 1510;
2658 -> 1511;
2658 -> 2643;
2658 -> 1518;
2658 -> 1515;
2659 -> 1635;
2660 -> 2659;
2660 -> 1530;
2661 -> 2660;
2661 -> 1532;
2661 -> 1530;
2662 -> 1528;
2662 -> 1562;
2662 -> 1631;
2662 -> 2661;
2662 -> 1640;
2662 -> 1556;
2662 -> 1557;
2662 -> 2647;
2662 -> 1564;
2662 -> 1561;
2663 -> 1576;
2664 -> 2663;
2664 -> 1397;
2665 -> 2664;
2665 -> 1399;
2665 -> 1397;
2666 -> 1595;
2667 -> 2666;
2667 -> 1435;
2668 -> 2667;
2668 -> 1437;
2668 -> 1435;
2669 -> 1433;
2669 -> 1465;
2669 -> 1591;
2669 -> 2668;
2669 -> 1600;
2669 -> 1461;
2669 -> 1462;
2669 -> 2654;
2669 -> 1472;
2669 -> 1464;
2670 -> 1615;
2671 -> 2670;
2671 -> 1484;
2672 -> 2671;
2672 -> 1486;
2672 -> 1484;
2673 -> 1482;
2673 -> 1516;
2673 -> 1611;
2673 -> 2672;
2673 -> 1620;
2673 -> 1510;
2673 -> 1511;
2673 -> 2658;
2673 -> 1518;
2673 -> 1515;
2674 -> 1635;
2675 -> 2674;
2675 -> 1530;
2676 -> 2675;
2676 -> 1532;
2676 -> 1530;
2677 -> 1528;
2677 -> 1562;
2677 -> 1631;
2677 -> 2676;
2677 -> 1640;
2677 -> 1556;
2677 -> 1557;
2677 -> 2662;
2677 -> 1564;
2677 -> 1561;
2678 -> 1576;
2679 -> 2678;
2679 -> 1397;
2680 -> 2679;
2680 -> 1399;
2680 -> 1397;
2681 -> 1595;
2682 -> 2681;
2682 -> 1435;
2683 -> 2682;
2683 -> 1437;
2683 -> 1435;
2684 -> 1433;
2684 -> 1465;
2684 -> 1591;
2684 -> 2683;
2684 -> 1600;
2684 -> 1461;
2684 -> 1462;
2684 -> 2669;
2684 -> 1472;
2684 -> 1464;
2685 -> 1615;
2686 -> 2685;
2686 -> 1484;
2687 -> 2686;
2687 -> 1486;
2687 -> 1484;
2688 -> 1482;
2688 -> 1516;
2688 -> 1611;
2688 -> 2687;
2688 -> 1620;
2688 -> 1510;
2688 -> 1511;
2688 -> 2673;
2688 -> 1518;
2688 -> 1515;
2689 -> 1635;
2690 -> 2689;
2690 -> 1530;
2691 -> 2690;
2691 -> 1532;
2691 -> 1530;
2692 -> 1528;
2692 -> 1562;
2692 -> 1631;
2692 -> 2691;
2692 -> 1640;
2692 -> 1556;
2692 -> 1557;
2692 -> 2677;
2692 -> 1564;
2692 -> 1561;
2693 -> 1576;
2694 -> 2693;
2694 -> 1397;
2695 -> 2694;
2695 -> 1399;
2695 -> 1397;
2696 -> 1595;
2697 -> 2696;
2697 -> 1435;
2698 -> 2697;
2698 -> 1437;
2698 -> 1435;
2699 -> 1433;
2699 -> 1465;
2699 -> 1591;
2699 -> 2698;
2699 -> 1600;
2699 -> 1461;
2699 -> 1462;
2699 -> 2684;
2699 -> 1472;
2699 -> 1464;
2700 -> 1615;
2701 -> 2700;
2701 -> 1484;
2702 -> 2701;
2702 -> 1486;
2702 -> 1484;
2703 -> 1482;
2703 -> 1516;
2703 -> 1611;
2703 -> 2702;
2703 -> 1620;
2703 -> 1510;
2703 -> 1511;
2703 -> 2688;
2703 -> 1518;
2703 -> 1515;
2704 -> 1635;
2705 -> 2704;
2705 -> 1530;
2706 -> 2705;
2706 -> 1532;
2706 -> 1530;
2707 -> 1528;
2707 -> 1562;
2707 -> 1631;
2707 -> 2706;
2707 -> 1640;
2707 -> 1556;
2707 -> 1557;
2707 -> 2692;
2707 -> 1564;
2707 -> 1561;
2708 -> 1576;
2709 -> 2708;
2709 -> 1397;
2710 -> 2709;
2710 -> 1399;
2710 -> 1397;
2711 -> 1595;
2712 -> 2711;
2712 -> 1435;
2713 -> 2712;
2713 -> 1437;
2713 -> 1435;
2714 -> 1433;
2714 -> 1465;
2714 -> 1591;
2714 -> 2713;
2714 -> 1600;
2714 -> 1461;
2714 -> 1462;
2714 -> 2699;
2714 -> 1472;
2714 -> 1464;
2715 -> 1615;
2716 -> 2715;
2716 -> 1484;
2717 -> 2716;
2717 -> 1486;
2717 -> 1484;
2718 -> 1482;
2718 -> 1516;
2718 -> 1611;
2718 -> 2717;
2718 -> 1620;
2718 -> 1510;
2718 -> 1511;
2718 -> 2703;
2718 -> 1518;
2718 -> 1515;
2719 -> 1635;
2720 -> 2719;
2720 -> 1530;
2721 -> 2720;
2721 -> 1532;
2721 -> 1530;
2722 -> 1528;
2722 -> 1562;
2722 -> 1631;
2722 -> 2721;
2722 -> 1640;
2722 -> 1556;
2722 -> 1557;
2722 -> 2707;
2722 -> 1564;
2722 -> 1561;
2723 -> 1576;
2724 -> 2723;
2724 -> 1397;
2725 -> 2724;
2725 -> 1399;
2725 -> 1397;
2726 -> 1595;
2727 -> 2726;
2727 -> 1435;
2728 -> 2727;
2728 -> 1437;
2728 -> 1435;
2729 -> 1433;
2729 -> 1465;
2729 -> 1591;
2729 -> 2728;
2729 -> 1600;
2729 -> 1461;
2729 -> 1462;
2729 -> 2714;
2729 -> 1472;
2729 -> 1464;
2730 -> 1615;
2731 -> 2730;
2731 -> 1484;
2732 -> 2731;
2732 -> 1486;
2732 -> 1484;
2733 -> 1482;
2733 -> 1516;
2733 -> 1611;
2733 -> 2732;
2733 -> 1620;
2733 -> 1510;
2733 -> 1511;
2733 -> 2718;
2733 -> 1518;
2733 -> 1515;
2734 -> 1635;
2735 -> 2734;
2735 -> 1530;
2736 -> 2735;
2736 -> 1532;
2736 -> 1530;
2737 -> 1528;
2737 -> 1562;
2737 -> 1631;
2737 -> 2736;
2737 -> 1640;
2737 -> 1556;
2737 -> 1557;
2737 -> 2722;
2737 -> 1564;
2737 -> 1561;
2738 -> 1576;
2739 -> 2738;
2739 -> 1397;
2740 -> 2739;
2740 -> 1399;
2740 -> 1397;
2741 -> 1595;
2742 -> 2741;
2742 -> 1435;
2743 -> 2742;
2743 -> 1437;
2743 -> 1435;
2744 -> 1433;
2744 -> 1465;
2744 -> 1591;
2744 -> 2743;
2744 -> 1600;
2744 -> 1461;
2744 -> 1462;
2744 -> 2729;
2744 -> 1472;
2744 -> 1464;
2745 -> 1615;
2746 -> 2745;
2746 -> 1484;
2747 -> 2746;
2747 -> 1486;
2747 -> 1484;
2748 -> 1482;
2748 -> 1516;
2748 -> 1611;
2748 -> 2747;
2748 -> 1620;
2748 -> 1510;
2748 -> 1511;
2748 -> 2733;
2748 -> 1518;
2748 -> 1515;
2749 -> 1635;
2750 -> 2749;
2750 -> 1530;
2751 -> 2750;
2751 -> 1532;
2751 -> 1530;
2752 -> 1528;
2752 -> 1562;
2752 -> 1631;
2752 -> 2751;
2752 -> 1640;
2752 -> 1556;
2752 -> 1557;
2752 -> 2737;
2752 -> 1564;
2752 -> 1561;
2753 -> 1576;
2754 -> 2753;
2754 -> 1397;
2755 -> 2754;
2755 -> 1399;
2755 -> 1397;
2756 -> 1595;
2757 -> 2756;
2757 -> 1435;
2758 -> 2757;
2758 -> 1437;
2758 -> 1435;
2759 -> 1433;
2759 -> 1465;
2759 -> 1591;
2759 -> 2758;
2759 -> 1600;
2759 -> 1461;
2759 -> 1462;
2759 -> 2744;
2759 -> 1472;
2759 -> 1464;
2760 -> 1615;
2761 -> 2760;
2761 -> 1484;
2762 -> 2761;
2762 -> 1486;
2762 -> 1484;
2763 -> 1482;
2763 -> 1516;
2763 -> 1611;
2763 -> 2762;
2763 -> 1620;
2763 -> 1510;
2763 -> 1511;
2763 -> 2748;
2763 -> 1518;
2763 -> 1515;
2764 -> 1635;
2765 -> 2764;
2765 -> 1530;
2766 -> 2765;
2766 -> 1532;
2766 -> 1530;
2767 -> 1528;
2767 -> 1562;
2767 -> 1631;
2767 -> 2766;
2767 -> 1640;
2767 -> 1556;
2767 -> 1557;
2767 -> 2752;
2767 -> 1564;
2767 -> 1561;
2768 -> 1576;
2769 -> 2768;
2769 -> 1397;
2770 -> 2769;
2770 -> 1399;
2770 -> 1397;
2771 -> 1595;
2772 -> 2771;
2772 -> 1435;
2773 -> 2772;
2773 -> 1437;
2773 -> 1435;
2774 -> 1433;
2774 -> 1465;
2774 -> 1591;
2774 -> 2773;
2774 -> 1600;
2774 -> 1461;
2774 -> 1462;
2774 -> 2759;
2774 -> 1472;
2774 -> 1464;
2775 -> 1615;
2776 -> 2775;
2776 -> 1484;
2777 -> 2776;
2777 -> 1486;
2777 -> 1484;
2778 -> 1482;
2778 -> 1516;
2778 -> 1611;
2778 -> 2777;
2778 -> 1620;
2778 -> 1510;
2778 -> 1511;
2778 -> 2763;
2778 -> 1518;
2778 -> 1515;
2779 -> 1635;
2780 -> 2779;
2780 -> 1530;
2781 -> 2780;
2781 -> 1532;
2781 -> 1530;
2782 -> 1528;
2782 -> 1562;
2782 -> 1631;
2782 -> 2781;
2782 -> 1640;
2782 -> 1556;
2782 -> 1557;
2782 -> 2767;
2782 -> 1564;
2782 -> 1561;
2783 -> 1576;
2784 -> 2783;
2784 -> 1397;
2785 -> 2784;
2785 -> 1399;
2785 -> 1397;
2786 -> 1595;
2787 -> 2786;
2787 -> 1435;
2788 -> 2787;
2788 -> 1437;
2788 -> 1435;
2789 -> 1433;
2789 -> 1465;
2789 -> 1591;
2789 -> 2788;
2789 -> 1600;
2789 -> 1461;
2789 -> 1462;
2789 -> 2774;
2789 -> 1472;
2789 -> 1464;
2790 -> 1615;
2791 -> 2790;
2791 -> 1484;
2792 -> 2791;
2792 -> 1486;
2792 -> 1484;
2793 -> 1482;
2793 -> 1516;
2793 -> 1611;
2793 -> 2792;
2793 -> 1620;
2793 -> 1510;
2793 -> 1511;
2793 -> 2778;
2793 -> 1518;
2793 -> 1515;
2794 -> 1635;
2795 -> 2794;
2795 -> 1530;
2796 -> 2795;
2796 -> 1532;
2796 -> 1530;
2797 -> 1528;
2797 -> 1562;
2797 -> 1631;
2797 -> 2796;
2797 -> 1640;
2797 -> 1556;
2797 -> 1557;
2797 -> 2782;
2797 -> 1564;
2797 -> 1561;
2798 -> 1576;
2799 -> 2798;
2799 -> 1397;
2800 -> 2799;
2800 -> 1399;
2800 -> 1397;
2801 -> 1595;
2802 -> 2801;
2802 -> 1435;
2803 -> 2802;
2803 -> 1437;
2803 -> 1435;
2804 -> 1433;
2804 -> 1465;
2804 -> 1591;
2804 -> 2803;
2804 -> 1600;
2804 -> 1461;
2804 -> 1462;
2804 -> 2789;
2804 -> 1472;
2804 -> 1464;
2805 -> 1615;
2806 -> 2805;
2806 -> 1484;
2807 -> 2806;
2807 -> 1486;
2807 -> 1484;
2808 -> 1482;
2808 -> 1516;
2808 -> 1611;
2808 -> 2807;
2808 -> 1620;
2808 -> 1510;
2808 -> 1511;
2808 -> 2793;
2808 -> 1518;
2808 -> 1515;
2809 -> 1635;
2810 -> 2809;
2810 -> 1530;
2811 -> 2810;
2811 -> 1532;
2811 -> 1530;
2812 -> 1528;
2812 -> 1562;
2812 -> 1631;
2812 -> 2811;
2812 -> 1640;
2812 -> 1556;
2812 -> 1557;
2812 -> 2797;
2812 -> 1564;
2812 -> 1561;
2813 -> 1576;
2814 -> 2813;
2814 -> 1397;
2815 -> 2814;
2815 -> 1399;
2815 -> 1397;
2816 -> 1595;
2817 -> 2816;
2817 -> 1435;
2818 -> 2817;
2818 -> 1437;
2818 -> 1435;
2819 -> 1433;
2819 -> 1465;
2819 -> 1591;
2819 -> 2818;
2819 -> 1600;
2819 -> 1461;
2819 -> 1462;
2819 -> 2804;
2819 -> 1472;
2819 -> 1464;
2820 -> 1615;
2821 -> 2820;
2821 -> 1484;
2822 -> 2821;
2822 -> 1486;
2822 -> 1484;
2823 -> 1482;
2823 -> 1516;
2823 -> 1611;
2823 -> 2822;
2823 -> 1620;
2823 -> 1510;
2823 -> 1511;
2823 -> 2808;
2823 -> 1518;
2823 -> 1515;
2824 -> 1635;
2825 -> 2824;
2825 -> 1530;
2826 -> 2825;
2826 -> 1532;
2826 -> 1530;
2827 -> 1528;
2827 -> 1562;
2827 -> 1631;
2827 -> 2826;
2827 -> 1640;
2827 -> 1556;
2827 -> 1557;
2827 -> 2812;
2827 -> 1564;
2827 -> 1561;
2828 -> 1576;
2829 -> 2828;
2829 -> 1397;
2830 -> 2829;
2830 -> 1399;
2830 -> 1397;
2831 -> 1595;
2832 -> 2831;
2832 -> 1435;
2833 -> 2832;
2833 -> 1437;
2833 -> 1435;
2834 -> 1433;
2834 -> 1465;
2834 -> 1591;
2834 -> 2833;
2834 -> 1600;
2834 -> 1461;
2834 -> 1462;
2834 -> 2819;
2834 -> 1472;
2834 -> 1464;
2835 -> 1615;
2836 -> 2835;
2836 -> 1484;
2837 -> 2836;
2837 -> 1486;
2837 -> 1484;
2838 -> 1482;
2838 -> 1516;
2838 -> 1611;
2838 -> 2837;
2838 -> 1620;
2838 -> 1510;
2838 -> 1511;
2838 -> 2823;
2838 -> 1518;
2838 -> 1515;
2839 -> 1635;
2840 -> 2839;
2840 -> 1530;
2841 -> 2840;
2841 -> 1532;
2841 -> 1530;
2842 -> 1528;
2842 -> 1562;
2842 -> 1631;
2842 -> 2841;
2842 -> 1640;
2842 -> 1556;
2842 -> 1557;
2842 -> 2827;
2842 -> 1564;
2842 -> 1561;
2843 -> 1576;
2844 -> 2843;
2844 -> 1397;
2845 -> 2844;
2845 -> 1399;
2845 -> 1397;
2846 -> 1595;
2847 -> 2846;
2847 -> 1435;
2848 -> 2847;
2848 -> 1437;
2848 -> 1435;
2849 -> 1433;
2849 -> 1465;
2849 -> 1591;
2849 -> 2848;
2849 -> 1600;
2849 -> 1461;
2849 -> 1462;
2849 -> 2834;
2849 -> 1472;
2849 -> 1464;
2850 -> 1615;
2851 -> 2850;
2851 -> 1484;
2852 -> 2851;
2852 -> 1486;
2852 -> 1484;
2853 -> 1482;
2853 -> 1516;
2853 -> 1611;
2853 -> 2852;
2853 -> 1620;
2853 -> 1510;
2853 -> 1511;
2853 -> 2838;
2853 -> 1518;
2853 -> 1515;
2854 -> 1635;
2855 -> 2854;
2855 -> 1530;
2856 -> 2855;
2856 -> 1532;
2856 -> 1530;
2857 -> 1528;
2857 -> 1562;
2857 -> 1631;
2857 -> 2856;
2857 -> 1640;
2857 -> 1556;
2857 -> 1557;
2857 -> 2842;
2857 -> 1564;
2857 -> 1561;
2858 -> 1576;
2859 -> 2858;
2859 -> 1397;
2860 -> 2859;
2860 -> 1399;
2860 -> 1397;
2861 -> 1595;
2862 -> 2861;
2862 -> 1435;
2863 -> 2862;
2863 -> 1437;
2863 -> 1435;
2864 -> 1433;
2864 -> 1465;
2864 -> 1591;
2864 -> 2863;
2864 -> 1600;
2864 -> 1461;
2864 -> 1462;
2864 -> 2849;
2864 -> 1472;
2864 -> 1464;
2865 -> 1615;
2866 -> 2865;
2866 -> 1484;
2867 -> 2866;
2867 -> 1486;
2867 -> 1484;
2868 -> 1482;
2868 -> 1516;
2868 -> 1611;
2868 -> 2867;
2868 -> 1620;
2868 -> 1510;
2868 -> 1511;
2868 -> 2853;
2868 -> 1518;
2868 -> 1515;
2869 -> 1635;
2870 -> 2869;
2870 -> 1530;
2871 -> 2870;
2871 -> 1532;
2871 -> 1530;
2872 -> 1528;
2872 -> 1562;
2872 -> 1631;
2872 -> 2871;
2872 -> 1640;
2872 -> 1556;
2872 -> 1557;
2872 -> 2857;
2872 -> 1564;
2872 -> 1561;
2873 -> 1576;
2874 -> 2873;
2874 -> 1397;
2875 -> 2874;
2875 -> 1399;
2875 -> 1397;
2876 -> 1595;
2877 -> 2876;
2877 -> 1435;
2878 -> 2877;
2878 -> 1437;
2878 -> 1435;
2879 -> 1433;
2879 -> 1465;
2879 -> 1591;
2879 -> 2878;
2879 -> 1600;
2879 -> 1461;
2879 -> 1462;
2879 -> 2864;
2879 -> 1472;
2879 -> 1464;
2880 -> 1615;
2881 -> 2880;
2881 -> 1484;
2882 -> 2881;
2882 -> 1486;
2882 -> 1484;
2883 -> 1482;
2883 -> 1516;
2883 -> 1611;
2883 -> 2882;
2883 -> 1620;
2883 -> 1510;
2883 -> 1511;
2883 -> 2868;
2883 -> 1518;
2883 -> 1515;
2884 -> 1635;
2885 -> 2884;
2885 -> 1530;
2886 -> 2885;
2886 -> 1532;
2886 -> 1530;
2887 -> 1528;
2887 -> 1562;
2887 -> 1631;
2887 -> 2886;
2887 -> 1640;
2887 -> 1556;
2887 -> 1557;
2887 -> 2872;
2887 -> 1564;
2887 -> 1561;
2888 -> 1576;
2889 -> 2888;
2889 -> 1397;
2890 -> 2889;
2890 -> 1399;
2890 -> 1397;
2891 -> 1595;
2892 -> 2891;
2892 -> 1435;
2893 -> 2892;
2893 -> 1437;
2893 -> 1435;
2894 -> 1433;
2894 -> 1465;
2894 -> 1591;
2894 -> 2893;
2894 -> 1600;
2894 -> 1461;
2894 -> 1462;
2894 -> 2879;
2894 -> 1472;
2894 -> 1464;
2895 -> 1615;
2896 -> 2895;
2896 -> 1484;
2897 -> 2896;
2897 -> 1486;
2897 -> 1484;
2898 -> 1482;
2898 -> 1516;
2898 -> 1611;
2898 -> 2897;
2898 -> 1620;
2898 -> 1510;
2898 -> 1511;
2898 -> 2883;
2898 -> 1518;
2898 -> 1515;
2899 -> 1635;
2900 -> 2899;
2900 -> 1530;
2901 -> 2900;
2901 -> 1532;
2901 -> 1530;
2902 -> 1528;
2902 -> 1562;
2902 -> 1631;
2902 -> 2901;
2902 -> 1640;
2902 -> 1556;
2902 -> 1557;
2902 -> 2887;
2902 -> 1564;
2902 -> 1561;
2903 -> 1576;
2904 -> 2903;
2904 -> 1397;
2905 -> 2904;
2905 -> 1399;
2905 -> 1397;
2906 -> 1595;
2907 -> 2906;
2907 -> 1435;
2908 -> 2907;
2908 -> 1437;
2908 -> 1435;
2909 -> 1433;
2909 -> 1465;
2909 -> 1591;
2909 -> 2908;
2909 -> 1600;
2909 -> 1461;
2909 -> 1462;
2909 -> 2894;
2909 -> 1472;
2909 -> 1464;
2910 -> 1615;
2911 -> 2910;
2911 -> 1484;
2912 -> 2911;
2912 -> 1486;
2912 -> 1484;
2913 -> 1482;
2913 -> 1516;
2913 -> 1611;
2913 -> 2912;
2913 -> 1620;
2913 -> 1510;
2913 -> 1511;
2913 -> 2898;
2913 -> 1518;
2913 -> 1515;
2914 -> 1635;
2915 -> 2914;
2915 -> 1530;
2916 -> 2915;
2916 -> 1532;
2916 -> 1530;
2917 -> 1528;
2917 -> 1562;
2917 -> 1631;
2917 -> 2916;
2917 -> 1640;
2917 -> 1556;
2917 -> 1557;
2917 -> 2902;
2917 -> 1564;
2917 -> 1561;
2918 -> 1576;
2919 -> 2918;
2919 -> 1397;
2920 -> 2919;
2920 -> 1399;
2920 -> 1397;
2921 -> 1595;
2922 -> 2921;
2922 -> 1435;
2923 -> 2922;
2923 -> 1437;
2923 -> 1435;
2924 -> 1433;
2924 -> 1465;
2924 -> 1591;
2924 -> 2923;
2924 -> 1600;
2924 -> 1461;
2924 -> 1462;
2924 -> 2909;
2924 -> 1472;
2924 -> 1464;
2925 -> 1615;
2926 -> 2925;
2926 -> 1484;
2927 -> 2926;
2927 -> 1486;
2927 -> 1484;
2928 -> 1482;
2928 -> 1516;
2928 -> 1611;
2928 -> 2927;
2928 -> 1620;
2928 -> 1510;
2928 -> 1511;
2928 -> 2913;
2928 -> 1518;
2928 -> 1515;
2929 -> 1635;
2930 -> 2929;
2930 -> 1530;
2931 -> 2930;
2931 -> 1532;
2931 -> 1530;
2932 -> 1528;
2932 -> 1562;
2932 -> 1631;
2932 -> 2931;
2932 -> 1640;
2932 -> 1556;
2932 -> 1557;
2932 -> 2917;
2932 -> 1564;
2932 -> 1561;
2933 -> 1576;
2934 -> 2933;
2934 -> 1397;
2935 -> 2934;
2935 -> 1399;
2935 -> 1397;
2936 -> 1595;
2937 -> 2936;
2937 -> 1435;
2938 -> 2937;
2938 -> 1437;
2938 -> 1435;
2939 -> 1433;
2939 -> 1465;
2939 -> 1591;
2939 -> 2938;
2939 -> 1600;
2939 -> 1461;
2939 -> 1462;
2939 -> 2924;
2939 -> 1472;
2939 -> 1464;
2940 -> 1615;
2941 -> 2940;
2941 -> 1484;
2942 -> 2941;
2942 -> 1486;
2942 -> 1484;
2943 -> 1482;
2943 -> 1516;
2943 -> 1611;
2943 -> 2942;
2943 -> 1620;
2943 -> 1510;
2943 -> 1511;
2943 -> 2928;
2943 -> 1518;
2943 -> 1515;
2944 -> 1635;
2945 -> 2944;
2945 -> 1530;
2946 -> 2945;
2946 -> 1532;
2946 -> 1530;
2947 -> 1528;
2947 -> 1562;
2947 -> 1631;
2947 -> 2946;
2947 -> 1640;
2947 -> 1556;
2947 -> 1557;
2947 -> 2932;
2947 -> 1564;
2947 -> 1561;
2948 -> 1576;
2949 -> 2948;
2949 -> 1397;
2950 -> 2949;
2950 -> 1399;
2950 -> 1397;
2951 -> 1595;
2952 -> 2951;
2952 -> 1435;
2953 -> 2952;
2953 -> 1437;
2953 -> 1435;
2954 -> 1433;
2954 -> 1465;
2954 -> 1591;
2954 -> 2953;
2954 -> 1600;
2954 -> 1461;
2954 -> 1462;
2954 -> 2939;
2954 -> 1472;
2954 -> 1464;
2955 -> 1615;
2956 -> 2955;
2956 -> 1484;
2957 -> 2956;
2957 -> 1486;
2957 -> 1484;
2958 -> 1482;
2958 -> 1516;
2958 -> 1611;
2958 -> 2957;
2958 -> 1620;
2958 -> 1510;
2958 -> 1511;
2958 -> 2943;
2958 -> 1518;
2958 -> 1515;
2959 -> 1635;
2960 -> 2959;
2960 -> 1530;
2961 -> 2960;
2961 -> 1532;
2961 -> 1530;
2962 -> 1528;
2962 -> 1562;
2962 -> 1631;
2962 -> 2961;
2962 -> 1640;
2962 -> 1556;
2962 -> 1557;
2962 -> 2947;
2962 -> 1564;
2962 -> 1561;
2963 -> 1576;
2964 -> 2963;
2964 -> 1397;
2965 -> 2964;
2965 -> 1399;
2965 -> 1397;
2966 -> 1595;
2967 -> 2966;
2967 -> 1435;
2968 -> 2967;
2968 -> 1437;
2968 -> 1435;
2969 -> 1433;
2969 -> 1465;
2969 -> 1591;
2969 -> 2968;
2969 -> 1600;
2969 -> 1461;
2969 -> 1462;
2969 -> 2954;
2969 -> 1472;
2969 -> 1464;
2970 -> 1615;
2971 -> 2970;
2971 -> 1484;
2972 -> 2971;
2972 -> 1486;
2972 -> 1484;
2973 -> 1482;
2973 -> 1516;
2973 -> 1611;
2973 -> 2972;
2973 -> 1620;
2973 -> 1510;
2973 -> 1511;
2973 -> 2958;
2973 -> 1518;
2973 -> 1515;
2974 -> 1635;
2975 -> 2974;
2975 -> 1530;
2976 -> 2975;
2976 -> 1532;
2976 -> 1530;
2977 -> 1528;
2977 -> 1562;
2977 -> 1631;
2977 -> 2976;
2977 -> 1640;
2977 -> 1556;
2977 -> 1557;
2977 -> 2962;
2977 -> 1564;
2977 -> 1561;
2978 -> 1576;
2979 -> 2978;
2979 -> 1397;
2980 -> 2979;
2980 -> 1399;
2980 -> 1397;
2981 -> 1595;
2982 -> 2981;
2982 -> 1435;
2983 -> 2982;
2983 -> 1437;
2983 -> 1435;
2984 -> 1433;
2984 -> 1465;
2984 -> 1591;
2984 -> 2983;
2984 -> 1600;
2984 -> 1461;
2984 -> 1462;
2984 -> 2969;
2984 -> 1472;
2984 -> 1464;
2985 -> 1615;
2986 -> 2985;
2986 -> 1484;
2987 -> 2986;
2987 -> 1486;
2987 -> 1484;
2988 -> 1482;
2988 -> 1516;
2988 -> 1611;
2988 -> 2987;
2988 -> 1620;
2988 -> 1510;
2988 -> 1511;
2988 -> 2973;
2988 -> 1518;
2988 -> 1515;
2989 -> 1635;
2990 -> 2989;
2990 -> 1530;
2991 -> 2990;
2991 -> 1532;
2991 -> 1530;
2992 -> 1528;
2992 -> 1562;
2992 -> 1631;
2992 -> 2991;
2992 -> 1640;
2992 -> 1556;
2992 -> 1557;
2992 -> 2977;
2992 -> 1564;
2992 -> 1561;
2993 -> 1576;
2994 -> 2993;
2994 -> 1397;
2995 -> 2994;
2995 -> 1399;
2995 -> 1397;
2996 -> 1595;
2997 -> 2996;
2997 -> 1435;
2998 -> 2997;
2998 -> 1437;
2998 -> 1435;
2999 -> 1433;
2999 -> 1465;
2999 -> 1591;
2999 -> 2998;
2999 -> 1600;
2999 -> 1461;
2999 -> 1462;
2999 -> 2984;
2999 -> 1472;
2999 -> 1464;
3000 -> 1615;
3001 -> 3000;
3001 -> 1484;
3002 -> 3001;
3002 -> 1486;
3002 -> 1484;
3003 -> 1482;
3003 -> 1516;
3003 -> 1611;
3003 -> 3002;
3003 -> 1620;
3003 -> 1510;
3003 -> 1511;
3003 -> 2988;
3003 -> 1518;
3003 -> 1515;
3004 -> 1635;
3005 -> 3004;
3005 -> 1530;
3006 -> 3005;
3006 -> 1532;
3006 -> 1530;
3007 -> 1528;
3007 -> 1562;
3007 -> 1631;
3007 -> 3006;
3007 -> 1640;
3007 -> 1556;
3007 -> 1557;
3007 -> 2992;
3007 -> 1564;
3007 -> 1561;
3008 -> 1576;
3009 -> 3008;
3009 -> 1397;
3010 -> 3009;
3010 -> 1399;
3010 -> 1397;
3011 -> 1595;
3012 -> 3011;
3012 -> 1435;
3013 -> 3012;
3013 -> 1437;
3013 -> 1435;
3014 -> 1433;
3014 -> 1465;
3014 -> 1591;
3014 -> 3013;
3014 -> 1600;
3014 -> 1461;
3014 -> 1462;
3014 -> 2999;
3014 -> 1472;
3014 -> 1464;
3015 -> 1615;
3016 -> 3015;
3016 -> 1484;
3017 -> 3016;
3017 -> 1486;
3017 -> 1484;
3018 -> 1482;
3018 -> 1516;
3018 -> 1611;
3018 -> 3017;
3018 -> 1620;
3018 -> 1510;
3018 -> 1511;
3018 -> 3003;
3018 -> 1518;
3018 -> 1515;
3019 -> 1635;
3020 -> 3019;
3020 -> 1530;
3021 -> 3020;
3021 -> 1532;
3021 -> 1530;
3022 -> 1528;
3022 -> 1562;
3022 -> 1631;
3022 -> 3021;
3022 -> 1640;
3022 -> 1556;
3022 -> 1557;
3022 -> 3007;
3022 -> 1564;
3022 -> 1561;
3023 -> 1576;
3024 -> 3023;
3024 -> 1397;
3025 -> 3024;
3025 -> 1399;
3025 -> 1397;
3026 -> 1595;
3027 -> 3026;
3027 -> 1435;
3028 -> 3027;
3028 -> 1437;
3028 -> 1435;
3029 -> 1433;
3029 -> 1465;
3029 -> 1591;
3029 -> 3028;
3029 -> 1600;
3029 -> 1461;
3029 -> 1462;
3029 -> 3014;
3029 -> 1472;
3029 -> 1464;
3030 -> 1615;
3031 -> 3030;
3031 -> 1484;
3032 -> 3031;
3032 -> 1486;
3032 -> 1484;
3033 -> 1482;
3033 -> 1516;
3033 -> 1611;
3033 -> 3032;
3033 -> 1620;
3033 -> 1510;
3033 -> 1511;
3033 -> 3018;
3033 -> 1518;
3033 -> 1515;
3034 -> 1635;
3035 -> 3034;
3035 -> 1530;
3036 -> 3035;
3036 -> 1532;
3036 -> 1530;
3037 -> 1528;
3037 -> 1562;
3037 -> 1631;
3037 -> 3036;
3037 -> 1640;
3037 -> 1556;
3037 -> 1557;
3037 -> 3022;
3037 -> 1564;
3037 -> 1561;
3038 -> 1576;
3039 -> 3038;
3039 -> 1397;
3040 -> 3039;
3040 -> 1399;
3040 -> 1397;
3041 -> 1595;
3042 -> 3041;
3042 -> 1435;
3043 -> 3042;
3043 -> 1437;
3043 -> 1435;
3044 -> 1433;
3044 -> 1465;
3044 -> 1591;
3044 -> 3043;
3044 -> 1600;
3044 -> 1461;
3044 -> 1462;
3044 -> 3029;
3044 -> 1472;
3044 -> 1464;
3045 -> 1615;
3046 -> 3045;
3046 -> 1484;
3047 -> 3046;
3047 -> 1486;
3047 -> 1484;
3048 -> 1482;
3048 -> 1516;
3048 -> 1611;
3048 -> 3047;
3048 -> 1620;
3048 -> 1510;
3048 -> 1511;
3048 -> 3033;
3048 -> 1518;
3048 -> 1515;
3049 -> 1635;
3050 -> 3049;
3050 -> 1530;
3051 -> 3050;
3051 -> 1532;
3051 -> 1530;
3052 -> 1528;
3052 -> 1562;
3052 -> 1631;
3052 -> 3051;
3052 -> 1640;
3052 -> 1556;
3052 -> 1557;
3052 -> 3037;
3052 -> 1564;
3052 -> 1561;
3053 -> 1576;
3054 -> 3053;
3054 -> 1397;
3055 -> 3054;
3055 -> 1399;
3055 -> 1397;
3056 -> 1595;
3057 -> 3056;
3057 -> 1435;
3058 -> 3057;
3058 -> 1437;
3058 -> 1435;
3059 -> 1433;
3059 -> 1465;
3059 -> 1591;
3059 -> 3058;
3059 -> 1600;
3059 -> 1461;
3059 -> 1462;
3059 -> 3044;
3059 -> 1472;
3059 -> 1464;
3060 -> 1615;
3061 -> 3060;
3061 -> 1484;
3062 -> 3061;
3062 -> 1486;
3062 -> 1484;
3063 -> 1482;
3063 -> 1516;
3063 -> 1611;
3063 -> 3062;
3063 -> 1620;
3063 -> 1510;
3063 -> 1511;
3063 -> 3048;
3063 -> 1518;
3063 -> 1515;
3064 -> 1635;
3065 -> 3064;
3065 -> 1530;
3066 -> 3065;
3066 -> 1532;
3066 -> 1530;
3067 -> 1528;
3067 -> 1562;
3067 -> 1631;
3067 -> 3066;
3067 -> 1640;
3067 -> 1556;
3067 -> 1557;
3067 -> 3052;
3067 -> 1564;
3067 -> 1561;
3068 -> 1576;
3069 -> 3068;
3069 -> 1397;
3070 -> 3069;
3070 -> 1399;
3070 -> 1397;
3071 -> 1595;
3072 -> 3071;
3072 -> 1435;
3073 -> 3072;
3073 -> 1437;
3073 -> 1435;
3074 -> 1433;
3074 -> 1465;
3074 -> 1591;
3074 -> 3073;
3074 -> 1600;
3074 -> 1461;
3074 -> 1462;
3074 -> 3059;
3074 -> 1472;
3074 -> 1464;
3075 -> 1615;
3076 -> 3075;
3076 -> 1484;
3077 -> 3076;
3077 -> 1486;
3077 -> 1484;
3078 -> 1482;
3078 -> 1516;
3078 -> 1611;
3078 -> 3077;
3078 -> 1620;
3078 -> 1510;
3078 -> 1511;
3078 -> 3063;
3078 -> 1518;
3078 -> 1515;
3079 -> 1635;
3080 -> 3079;
3080 -> 1530;
3081 -> 3080;
3081 -> 1532;
3081 -> 1530;
3082 -> 1528;
3082 -> 1562;
3082 -> 1631;
3082 -> 3081;
3082 -> 1640;
3082 -> 1556;
3082 -> 1557;
3082 -> 3067;
3082 -> 1564;
3082 -> 1561;
3083 -> 1576;
3084 -> 3083;
3084 -> 1397;
3085 -> 3084;
3085 -> 1399;
3085 -> 1397;
3086 -> 1595;
3087 -> 3086;
3087 -> 1435;
3088 -> 3087;
3088 -> 1437;
3088 -> 1435;
3089 -> 1433;
3089 -> 1465;
3089 -> 1591;
3089 -> 3088;
3089 -> 1600;
3089 -> 1461;
3089 -> 1462;
3089 -> 3074;
3089 -> 1472;
3089 -> 1464;
3090 -> 1615;
3091 -> 3090;
3091 -> 1484;
3092 -> 3091;
3092 -> 1486;
3092 -> 1484;
3093 -> 1482;
3093 -> 1516;
3093 -> 1611;
3093 -> 3092;
3093 -> 1620;
3093 -> 1510;
3093 -> 1511;
3093 -> 3078;
3093 -> 1518;
3093 -> 1515;
3094 -> 1635;
3095 -> 3094;
3095 -> 1530;
3096 -> 3095;
3096 -> 1532;
3096 -> 1530;
3097 -> 1528;
3097 -> 1562;
3097 -> 1631;
3097 -> 3096;
3097 -> 1640;
3097 -> 1556;
3097 -> 1557;
3097 -> 3082;
3097 -> 1564;
3097 -> 1561;
3098 -> 1576;
3099 -> 3098;
3099 -> 1397;
3100 -> 3099;
3100 -> 1399;
3100 -> 1397;
3101 -> 1595;
3102 -> 3101;
3102 -> 1435;
3103 -> 3102;
3103 -> 1437;
3103 -> 1435;
3104 -> 1433;
3104 -> 1465;
3104 -> 1591;
3104 -> 3103;
3104 -> 1600;
3104 -> 1461;
3104 -> 1462;
3104 -> 3089;
3104 -> 1472;
3104 -> 1464;
3105 -> 1615;
3106 -> 3105;
3106 -> 1484;
3107 -> 3106;
3107 -> 1486;
3107 -> 1484;
3108 -> 1482;
3108 -> 1516;
3108 -> 1611;
3108 -> 3107;
3108 -> 1620;
3108 -> 1510;
3108 -> 1511;
3108 -> 3093;
3108 -> 1518;
3108 -> 1515;
3109 -> 1635;
3110 -> 3109;
3110 -> 1530;
3111 -> 3110;
3111 -> 1532;
3111 -> 1530;
3112 -> 1528;
3112 -> 1562;
3112 -> 1631;
3112 -> 3111;
3112 -> 1640;
3112 -> 1556;
3112 -> 1557;
3112 -> 3097;
3112 -> 1564;
3112 -> 1561;
3113 -> 1576;
3114 -> 3113;
3114 -> 1397;
3115 -> 3114;
3115 -> 1399;
3115 -> 1397;
3116 -> 1595;
3117 -> 3116;
3117 -> 1435;
3118 -> 3117;
3118 -> 1437;
3118 -> 1435;
3119 -> 1433;
3119 -> 1465;
3119 -> 1591;
3119 -> 3118;
3119 -> 1600;
3119 -> 1461;
3119 -> 1462;
3119 -> 3104;
3119 -> 1472;
3119 -> 1464;
3120 -> 1615;
3121 -> 3120;
3121 -> 1484;
3122 -> 3121;
3122 -> 1486;
3122 -> 1484;
3123 -> 1482;
3123 -> 1516;
3123 -> 1611;
3123 -> 3122;
3123 -> 1620;
3123 -> 1510;
3123 -> 1511;
3123 -> 3108;
3123 -> 1518;
3123 -> 1515;
3124 -> 1635;
3125 -> 3124;
3125 -> 1530;
3126 -> 3125;
3126 -> 1532;
3126 -> 1530;
3127 -> 1528;
3127 -> 1562;
3127 -> 1631;
3127 -> 3126;
3127 -> 1640;
3127 -> 1556;
3127 -> 1557;
3127 -> 3112;
3127 -> 1564;
3127 -> 1561;
3128 -> 1576;
3129 -> 3128;
3129 -> 1397;
3130 -> 3129;
3130 -> 1399;
3130 -> 1397;
3131 -> 1595;
3132 -> 3131;
3132 -> 1435;
3133 -> 3132;
3133 -> 1437;
3133 -> 1435;
3134 -> 1433;
3134 -> 1465;
3134 -> 1591;
3134 -> 3133;
3134 -> 1600;
3134 -> 1461;
3134 -> 1462;
3134 -> 3119;
3134 -> 1472;
3134 -> 1464;
3135 -> 1615;
3136 -> 3135;
3136 -> 1484;
3137 -> 3136;
3137 -> 1486;
3137 -> 1484;
3138 -> 1482;
3138 -> 1516;
3138 -> 1611;
3138 -> 3137;
3138 -> 1620;
3138 -> 1510;
3138 -> 1511;
3138 -> 3123;
3138 -> 1518;
3138 -> 1515;
3139 -> 1635;
3140 -> 3139;
3140 -> 1530;
3141 -> 3140;
3141 -> 1532;
3141 -> 1530;
3142 -> 1528;
3142 -> 1562;
3142 -> 1631;
3142 -> 3141;
3142 -> 1640;
3142 -> 1556;
3142 -> 1557;
3142 -> 3127;
3142 -> 1564;
3142 -> 1561;
3143 -> 1576;
3144 -> 3143;
3144 -> 1397;
3145 -> 3144;
3145 -> 1399;
3145 -> 1397;
3146 -> 1595;
3147 -> 3146;
3147 -> 1435;
3148 -> 3147;
3148 -> 1437;
3148 -> 1435;
3149 -> 1433;
3149 -> 1465;
3149 -> 1591;
3149 -> 3148;
3149 -> 1600;
3149 -> 1461;
3149 -> 1462;
3149 -> 3134;
3149 -> 1472;
3149 -> 1464;
3150 -> 1615;
3151 -> 3150;
3151 -> 1484;
3152 -> 3151;
3152 -> 1486;
3152 -> 1484;
3153 -> 1482;
3153 -> 1516;
3153 -> 1611;
3153 -> 3152;
3153 -> 1620;
3153 -> 1510;
3153 -> 1511;
3153 -> 3138;
3153 -> 1518;
3153 -> 1515;
3154 -> 1635;
3155 -> 3154;
3155 -> 1530;
3156 -> 3155;
3156 -> 1532;
3156 -> 1530;
3157 -> 1528;
3157 -> 1562;
3157 -> 1631;
3157 -> 3156;
3157 -> 1640;
3157 -> 1556;
3157 -> 1557;
3157 -> 3142;
3157 -> 1564;
3157 -> 1561;
3158 -> 1576;
3159 -> 3158;
3159 -> 1397;
3160 -> 3159;
3160 -> 1399;
3160 -> 1397;
3161 -> 1595;
3162 -> 3161;
3162 -> 1435;
3163 -> 3162;
3163 -> 1437;
3163 -> 1435;
3164 -> 1433;
3164 -> 1465;
3164 -> 1591;
3164 -> 3163;
3164 -> 1600;
3164 -> 1461;
3164 -> 1462;
3164 -> 3149;
3164 -> 1472;
3164 -> 1464;
3165 -> 1615;
3166 -> 3165;
3166 -> 1484;
3167 -> 3166;
3167 -> 1486;
3167 -> 1484;
3168 -> 1482;
3168 -> 1516;
3168 -> 1611;
3168 -> 3167;
3168 -> 1620;
3168 -> 1510;
3168 -> 1511;
3168 -> 3153;
3168 -> 1518;
3168 -> 1515;
3169 -> 1635;
3170 -> 3169;
3170 -> 1530;
3171 -> 3170;
3171 -> 1532;
3171 -> 1530;
3172 -> 1528;
3172 -> 1562;
3172 -> 1631;
3172 -> 3171;
3172 -> 1640;
3172 -> 1556;
3172 -> 1557;
3172 -> 3157;
3172 -> 1564;
3172 -> 1561;
3173 -> 1576;
3174 -> 3173;
3174 -> 1397;
3175 -> 3174;
3175 -> 1399;
3175 -> 1397;
3176 -> 1595;
3177 -> 3176;
3177 -> 1435;
3178 -> 3177;
3178 -> 1437;
3178 -> 1435;
3179 -> 1433;
3179 -> 1465;
3179 -> 1591;
3179 -> 3178;
3179 -> 1600;
3179 -> 1461;
3179 -> 1462;
3179 -> 3164;
3179 -> 1472;
3179 -> 1464;
3180 -> 1615;
3181 -> 3180;
3181 -> 1484;
3182 -> 3181;
3182 -> 1486;
3182 -> 1484;
3183 -> 1482;
3183 -> 1516;
3183 -> 1611;
3183 -> 3182;
3183 -> 1620;
3183 -> 1510;
3183 -> 1511;
3183 -> 3168;
3183 -> 1518;
3183 -> 1515;
3184 -> 1635;
3185 -> 3184;
3185 -> 1530;
3186 -> 3185;
3186 -> 1532;
3186 -> 1530;
3187 -> 1528;
3187 -> 1562;
3187 -> 1631;
3187 -> 3186;
3187 -> 1640;
3187 -> 1556;
3187 -> 1557;
3187 -> 3172;
3187 -> 1564;
3187 -> 1561;
3188 -> 1576;
3189 -> 3188;
3189 -> 1397;
3190 -> 3189;
3190 -> 1399;
3190 -> 1397;
3191 -> 1595;
3192 -> 3191;
3192 -> 1435;
3193 -> 3192;
3193 -> 1437;
3193 -> 1435;
3194 -> 1433;
3194 -> 1465;
3194 -> 1591;
3194 -> 3193;
3194 -> 1600;
3194 -> 1461;
3194 -> 1462;
3194 -> 3179;
3194 -> 1472;
3194 -> 1464;
3195 -> 1615;
3196 -> 3195;
3196 -> 1484;
3197 -> 3196;
3197 -> 1486;
3197 -> 1484;
3198 -> 1482;
3198 -> 1516;
3198 -> 1611;
3198 -> 3197;
3198 -> 1620;
3198 -> 1510;
3198 -> 1511;
3198 -> 3183;
3198 -> 1518;
3198 -> 1515;
3199 -> 1635;
3200 -> 3199;
3200 -> 1530;
3201 -> 3200;
3201 -> 1532;
3201 -> 1530;
3202 -> 1528;
3202 -> 1562;
3202 -> 1631;
3202 -> 3201;
3202 -> 1640;
3202 -> 1556;
3202 -> 1557;
3202 -> 3187;
3202 -> 1564;
3202 -> 1561;
3203 -> 1576;
3204 -> 3203;
3204 -> 1397;
3205 -> 3204;
3205 -> 1399;
3205 -> 1397;
3206 -> 1595;
3207 -> 3206;
3207 -> 1435;
3208 -> 3207;
3208 -> 1437;
3208 -> 1435;
3209 -> 1433;
3209 -> 1465;
3209 -> 1591;
3209 -> 3208;
3209 -> 1600;
3209 -> 1461;
3209 -> 1462;
3209 -> 3194;
3209 -> 1472;
3209 -> 1464;
3210 -> 1615;
3211 -> 3210;
3211 -> 1484;
3212 -> 3211;
3212 -> 1486;
3212 -> 1484;
3213 -> 1482;
3213 -> 1516;
3213 -> 1611;
3213 -> 3212;
3213 -> 1620;
3213 -> 1510;
3213 -> 1511;
3213 -> 3198;
3213 -> 1518;
3213 -> 1515;
3214 -> 1635;
3215 -> 3214;
3215 -> 1530;
3216 -> 3215;
3216 -> 1532;
3216 -> 1530;
3217 -> 1528;
3217 -> 1562;
3217 -> 1631;
3217 -> 3216;
3217 -> 1640;
3217 -> 1556;
3217 -> 1557;
3217 -> 3202;
3217 -> 1564;
3217 -> 1561;
3218 -> 1576;
3219 -> 3218;
3219 -> 1397;
3220 -> 3219;
3220 -> 1399;
3220 -> 1397;
3221 -> 1595;
3222 -> 3221;
3222 -> 1435;
3223 -> 3222;
3223 -> 1437;
3223 -> 1435;
3224 -> 1433;
3224 -> 1465;
3224 -> 1591;
3224 -> 3223;
3224 -> 1600;
3224 -> 1461;
3224 -> 1462;
3224 -> 3209;
3224 -> 1472;
3224 -> 1464;
3225 -> 1615;
3226 -> 3225;
3226 -> 1484;
3227 -> 3226;
3227 -> 1486;
3227 -> 1484;
3228 -> 1482;
3228 -> 1516;
3228 -> 1611;
3228 -> 3227;
3228 -> 1620;
3228 -> 1510;
3228 -> 1511;
3228 -> 3213;
3228 -> 1518;
3228 -> 1515;
3229 -> 1635;
3230 -> 3229;
3230 -> 1530;
3231 -> 3230;
3231 -> 1532;
3231 -> 1530;
3232 -> 1528;
3232 -> 1562;
3232 -> 1631;
3232 -> 3231;
3232 -> 1640;
3232 -> 1556;
3232 -> 1557;
3232 -> 3217;
3232 -> 1564;
3232 -> 1561;
3233 -> 1576;
3234 -> 3233;
3234 -> 1397;
3235 -> 3234;
3235 -> 1399;
3235 -> 1397;
3236 -> 1595;
3237 -> 3236;
3237 -> 1435;
3238 -> 3237;
3238 -> 1437;
3238 -> 1435;
3239 -> 1433;
3239 -> 1465;
3239 -> 1591;
3239 -> 3238;
3239 -> 1600;
3239 -> 1461;
3239 -> 1462;
3239 -> 3224;
3239 -> 1472;
3239 -> 1464;
3240 -> 1615;
3241 -> 3240;
3241 -> 1484;
3242 -> 3241;
3242 -> 1486;
3242 -> 1484;
3243 -> 1482;
3243 -> 1516;
3243 -> 1611;
3243 -> 3242;
3243 -> 1620;
3243 -> 1510;
3243 -> 1511;
3243 -> 3228;
3243 -> 1518;
3243 -> 1515;
3244 -> 1635;
3245 -> 3244;
3245 -> 1530;
3246 -> 3245;
3246 -> 1532;
3246 -> 1530;
3247 -> 1528;
3247 -> 1562;
3247 -> 1631;
3247 -> 3246;
3247 -> 1640;
3247 -> 1556;
3247 -> 1557;
3247 -> 3232;
3247 -> 1564;
3247 -> 1561;
3248 -> 1576;
3249 -> 3248;
3249 -> 1397;
3250 -> 3249;
3250 -> 1399;
3250 -> 1397;
3251 -> 1595;
3252 -> 3251;
3252 -> 1435;
3253 -> 3252;
3253 -> 1437;
3253 -> 1435;
3254 -> 1433;
3254 -> 1465;
3254 -> 1591;
3254 -> 3253;
3254 -> 1600;
3254 -> 1461;
3254 -> 1462;
3254 -> 3239;
3254 -> 1472;
3254 -> 1464;
3255 -> 1615;
3256 -> 3255;
3256 -> 1484;
3257 -> 3256;
3257 -> 1486;
3257 -> 1484;
3258 -> 1482;
3258 -> 1516;
3258 -> 1611;
3258 -> 3257;
3258 -> 1620;
3258 -> 1510;
3258 -> 1511;
3258 -> 3243;
3258 -> 1518;
3258 -> 1515;
3259 -> 1635;
3260 -> 3259;
3260 -> 1530;
3261 -> 3260;
3261 -> 1532;
3261 -> 1530;
3262 -> 1528;
3262 -> 1562;
3262 -> 1631;
3262 -> 3261;
3262 -> 1640;
3262 -> 1556;
3262 -> 1557;
3262 -> 3247;
3262 -> 1564;
3262 -> 1561;
3263 -> 1576;
3264 -> 3263;
3264 -> 1397;
3265 -> 3264;
3265 -> 1399;
3265 -> 1397;
3266 -> 1595;
3267 -> 3266;
3267 -> 1435;
3268 -> 3267;
3268 -> 1437;
3268 -> 1435;
3269 -> 1433;
3269 -> 1465;
3269 -> 1591;
3269 -> 3268;
3269 -> 1600;
3269 -> 1461;
3269 -> 1462;
3269 -> 3254;
3269 -> 1472;
3269 -> 1464;
3270 -> 1615;
3271 -> 3270;
3271 -> 1484;
3272 -> 3271;
3272 -> 1486;
3272 -> 1484;
3273 -> 1482;
3273 -> 1516;
3273 -> 1611;
3273 -> 3272;
3273 -> 1620;
3273 -> 1510;
3273 -> 1511;
3273 -> 3258;
3273 -> 1518;
3273 -> 1515;
3274 -> 1635;
3275 -> 3274;
3275 -> 1530;
3276 -> 3275;
3276 -> 1532;
3276 -> 1530;
3277 -> 1528;
3277 -> 1562;
3277 -> 1631;
3277 -> 3276;
3277 -> 1640;
3277 -> 1556;
3277 -> 1557;
3277 -> 3262;
3277 -> 1564;
3277 -> 1561;
3278 -> 1576;
3279 -> 3278;
3279 -> 1397;
3280 -> 3279;
3280 -> 1399;
3280 -> 1397;
3281 -> 1595;
3282 -> 3281;
3282 -> 1435;
3283 -> 3282;
3283 -> 1437;
3283 -> 1435;
3284 -> 1433;
3284 -> 1465;
3284 -> 1591;
3284 -> 3283;
3284 -> 1600;
3284 -> 1461;
3284 -> 1462;
3284 -> 3269;
3284 -> 1472;
3284 -> 1464;
3285 -> 1615;
3286 -> 3285;
3286 -> 1484;
3287 -> 3286;
3287 -> 1486;
3287 -> 1484;
3288 -> 1482;
3288 -> 1516;
3288 -> 1611;
3288 -> 3287;
3288 -> 1620;
3288 -> 1510;
3288 -> 1511;
3288 -> 3273;
3288 -> 1518;
3288 -> 1515;
3289 -> 1635;
3290 -> 3289;
3290 -> 1530;
3291 -> 3290;
3291 -> 1532;
3291 -> 1530;
3292 -> 1528;
3292 -> 1562;
3292 -> 1631;
3292 -> 3291;
3292 -> 1640;
3292 -> 1556;
3292 -> 1557;
3292 -> 3277;
3292 -> 1564;
3292 -> 1561;
3293 -> 1576;
3294 -> 3293;
3294 -> 1397;
3295 -> 3294;
3295 -> 1399;
3295 -> 1397;
3296 -> 1595;
3297 -> 3296;
3297 -> 1435;
3298 -> 3297;
3298 -> 1437;
3298 -> 1435;
3299 -> 1433;
3299 -> 1465;
3299 -> 1591;
3299 -> 3298;
3299 -> 1600;
3299 -> 1461;
3299 -> 1462;
3299 -> 3284;
3299 -> 1472;
3299 -> 1464;
3300 -> 1615;
3301 -> 3300;
3301 -> 1484;
3302 -> 3301;
3302 -> 1486;
3302 -> 1484;
3303 -> 1482;
3303 -> 1516;
3303 -> 1611;
3303 -> 3302;
3303 -> 1620;
3303 -> 1510;
3303 -> 1511;
3303 -> 3288;
3303 -> 1518;
3303 -> 1515;
3304 -> 1635;
3305 -> 3304;
3305 -> 1530;
3306 -> 3305;
3306 -> 1532;
3306 -> 1530;
3307 -> 1528;
3307 -> 1562;
3307 -> 1631;
3307 -> 3306;
3307 -> 1640;
3307 -> 1556;
3307 -> 1557;
3307 -> 3292;
3307 -> 1564;
3307 -> 1561;
3308 -> 1576;
3309 -> 3308;
3309 -> 1397;
3310 -> 3309;
3310 -> 1399;
3310 -> 1397;
3311 -> 1595;
3312 -> 3311;
3312 -> 1435;
3313 -> 3312;
3313 -> 1437;
3313 -> 1435;
3314 -> 1433;
3314 -> 1465;
3314 -> 1591;
3314 -> 3313;
3314 -> 1600;
3314 -> 1461;
3314 -> 1462;
3314 -> 3299;
3314 -> 1472;
3314 -> 1464;
3315 -> 1615;
3316 -> 3315;
3316 -> 1484;
3317 -> 3316;
3317 -> 1486;
3317 -> 1484;
3318 -> 1482;
3318 -> 1516;
3318 -> 1611;
3318 -> 3317;
3318 -> 1620;
3318 -> 1510;
3318 -> 1511;
3318 -> 3303;
3318 -> 1518;
3318 -> 1515;
3319 -> 1635;
3320 -> 3319;
3320 -> 1530;
3321 -> 3320;
3321 -> 1532;
3321 -> 1530;
3322 -> 1528;
3322 -> 1562;
3322 -> 1631;
3322 -> 3321;
3322 -> 1640;
3322 -> 1556;
3322 -> 1557;
3322 -> 3307;
3322 -> 1564;
3322 -> 1561;
3323 -> 1576;
3324 -> 3323;
3324 -> 1397;
3325 -> 3324;
3325 -> 1399;
3325 -> 1397;
3326 -> 1595;
3327 -> 3326;
3327 -> 1435;
3328 -> 3327;
3328 -> 1437;
3328 -> 1435;
3329 -> 1433;
3329 -> 1465;
3329 -> 1591;
3329 -> 3328;
3329 -> 1600;
3329 -> 1461;
3329 -> 1462;
3329 -> 3314;
3329 -> 1472;
3329 -> 1464;
3330 -> 1615;
3331 -> 3330;
3331 -> 1484;
3332 -> 3331;
3332 -> 1486;
3332 -> 1484;
3333 -> 1482;
3333 -> 1516;
3333 -> 1611;
3333 -> 3332;
3333 -> 1620;
3333 -> 1510;
3333 -> 1511;
3333 -> 3318;
3333 -> 1518;
3333 -> 1515;
3334 -> 1635;
3335 -> 3334;
3335 -> 1530;
3336 -> 3335;
3336 -> 1532;
3336 -> 1530;
3337 -> 1528;
3337 -> 1562;
3337 -> 1631;
3337 -> 3336;
3337 -> 1640;
3337 -> 1556;
3337 -> 1557;
3337 -> 3322;
3337 -> 1564;
3337 -> 1561;
3338 -> 1576;
3339 -> 3338;
3339 -> 1397;
3340 -> 3339;
3340 -> 1399;
3340 -> 1397;
3341 -> 1595;
3342 -> 3341;
3342 -> 1435;
3343 -> 3342;
3343 -> 1437;
3343 -> 1435;
3344 -> 1433;
3344 -> 1465;
3344 -> 1591;
3344 -> 3343;
3344 -> 1600;
3344 -> 1461;
3344 -> 1462;
3344 -> 3329;
3344 -> 1472;
3344 -> 1464;
3345 -> 1615;
3346 -> 3345;
3346 -> 1484;
3347 -> 3346;
3347 -> 1486;
3347 -> 1484;
3348 -> 1482;
3348 -> 1516;
3348 -> 1611;
3348 -> 3347;
3348 -> 1620;
3348 -> 1510;
3348 -> 1511;
3348 -> 3333;
3348 -> 1518;
3348 -> 1515;
3349 -> 1635;
3350 -> 3349;
3350 -> 1530;
3351 -> 3350;
3351 -> 1532;
3351 -> 1530;
3352 -> 1528;
3352 -> 1562;
3352 -> 1631;
3352 -> 3351;
3352 -> 1640;
3352 -> 1556;
3352 -> 1557;
3352 -> 3337;
3352 -> 1564;
3352 -> 1561;
3353 -> 1576;
3354 -> 3353;
3354 -> 1397;
3355 -> 3354;
3355 -> 1399;
3355 -> 1397;
3356 -> 1595;
3357 -> 3356;
3357 -> 1435;
3358 -> 3357;
3358 -> 1437;
3358 -> 1435;
3359 -> 1433;
3359 -> 1465;
3359 -> 1591;
3359 -> 3358;
3359 -> 1600;
3359 -> 1461;
3359 -> 1462;
3359 -> 3344;
3359 -> 1472;
3359 -> 1464;
3360 -> 1615;
3361 -> 3360;
3361 -> 1484;
3362 -> 3361;
3362 -> 1486;
3362 -> 1484;
3363 -> 1482;
3363 -> 1516;
3363 -> 1611;
3363 -> 3362;
3363 -> 1620;
3363 -> 1510;
3363 -> 1511;
3363 -> 3348;
3363 -> 1518;
3363 -> 1515;
3364 -> 1635;
3365 -> 3364;
3365 -> 1530;
3366 -> 3365;
3366 -> 1532;
3366 -> 1530;
3367 -> 1528;
3367 -> 1562;
3367 -> 1631;
3367 -> 3366;
3367 -> 1640;
3367 -> 1556;
3367 -> 1557;
3367 -> 3352;
3367 -> 1564;
3367 -> 1561;
3368 -> 1576;
3369 -> 3368;
3369 -> 1397;
3370 -> 3369;
3370 -> 1399;
3370 -> 1397;
3371 -> 1595;
3372 -> 3371;
3372 -> 1435;
3373 -> 3372;
3373 -> 1437;
3373 -> 1435;
3374 -> 1433;
3374 -> 1465;
3374 -> 1591;
3374 -> 3373;
3374 -> 1600;
3374 -> 1461;
3374 -> 1462;
3374 -> 3359;
3374 -> 1472;
3374 -> 1464;
3375 -> 1615;
3376 -> 3375;
3376 -> 1484;
3377 -> 3376;
3377 -> 1486;
3377 -> 1484;
3378 -> 1482;
3378 -> 1516;
3378 -> 1611;
3378 -> 3377;
3378 -> 1620;
3378 -> 1510;
3378 -> 1511;
3378 -> 3363;
3378 -> 1518;
3378 -> 1515;
3379 -> 1635;
3380 -> 3379;
3380 -> 1530;
3381 -> 3380;
3381 -> 1532;
3381 -> 1530;
3382 -> 1528;
3382 -> 1562;
3382 -> 1631;
3382 -> 3381;
3382 -> 1640;
3382 -> 1556;
3382 -> 1557;
3382 -> 3367;
3382 -> 1564;
3382 -> 1561;
3383 -> 1576;
3384 -> 3383;
3384 -> 1397;
3385 -> 3384;
3385 -> 1399;
3385 -> 1397;
3386 -> 1595;
3387 -> 3386;
3387 -> 1435;
3388 -> 3387;
3388 -> 1437;
3388 -> 1435;
3389 -> 1433;
3389 -> 1465;
3389 -> 1591;
3389 -> 3388;
3389 -> 1600;
3389 -> 1461;
3389 -> 1462;
3389 -> 3374;
3389 -> 1472;
3389 -> 1464;
3390 -> 1615;
3391 -> 3390;
3391 -> 1484;
3392 -> 3391;
3392 -> 1486;
3392 -> 1484;
3393 -> 1482;
3393 -> 1516;
3393 -> 1611;
3393 -> 3392;
3393 -> 1620;
3393 -> 1510;
3393 -> 1511;
3393 -> 3378;
3393 -> 1518;
3393 -> 1515;
3394 -> 1635;
3395 -> 3394;
3395 -> 1530;
3396 -> 3395;
3396 -> 1532;
3396 -> 1530;
3397 -> 1528;
3397 -> 1562;
3397 -> 1631;
3397 -> 3396;
3397 -> 1640;
3397 -> 1556;
3397 -> 1557;
3397 -> 3382;
3397 -> 1564;
3397 -> 1561;
3398 -> 1576;
3399 -> 3398;
3399 -> 1397;
3400 -> 3399;
3400 -> 1399;
3400 -> 1397;
3401 -> 1595;
3402 -> 3401;
3402 -> 1435;
3403 -> 3402;
3403 -> 1437;
3403 -> 1435;
3404 -> 1433;
3404 -> 1465;
3404 -> 1591;
3404 -> 3403;
3404 -> 1600;
3404 -> 1461;
3404 -> 1462;
3404 -> 3389;
3404 -> 1472;
3404 -> 1464;
3405 -> 1615;
3406 -> 3405;
3406 -> 1484;
3407 -> 3406;
3407 -> 1486;
3407 -> 1484;
3408 -> 1482;
3408 -> 1516;
3408 -> 1611;
3408 -> 3407;
3408 -> 1620;
3408 -> 1510;
3408 -> 1511;
3408 -> 3393;
3408 -> 1518;
3408 -> 1515;
3409 -> 1635;
3410 -> 3409;
3410 -> 1530;
3411 -> 3410;
3411 -> 1532;
3411 -> 1530;
3412 -> 1528;
3412 -> 1562;
3412 -> 1631;
3412 -> 3411;
3412 -> 1640;
3412 -> 1556;
3412 -> 1557;
3412 -> 3397;
3412 -> 1564;
3412 -> 1561;
3413 -> 1576;
3414 -> 3413;
3414 -> 1397;
3415 -> 3414;
3415 -> 1399;
3415 -> 1397;
3416 -> 1595;
3417 -> 3416;
3417 -> 1435;
3418 -> 3417;
3418 -> 1437;
3418 -> 1435;
3419 -> 1433;
3419 -> 1465;
3419 -> 1591;
3419 -> 3418;
3419 -> 1600;
3419 -> 1461;
3419 -> 1462;
3419 -> 3404;
3419 -> 1472;
3419 -> 1464;
3420 -> 1615;
3421 -> 3420;
3421 -> 1484;
3422 -> 3421;
3422 -> 1486;
3422 -> 1484;
3423 -> 1482;
3423 -> 1516;
3423 -> 1611;
3423 -> 3422;
3423 -> 1620;
3423 -> 1510;
3423 -> 1511;
3423 -> 3408;
3423 -> 1518;
3423 -> 1515;
3424 -> 1635;
3425 -> 3424;
3425 -> 1530;
3426 -> 3425;
3426 -> 1532;
3426 -> 1530;
3427 -> 1528;
3427 -> 1562;
3427 -> 1631;
3427 -> 3426;
3427 -> 1640;
3427 -> 1556;
3427 -> 1557;
3427 -> 3412;
3427 -> 1564;
3427 -> 1561;
3428 -> 1576;
3429 -> 3428;
3429 -> 1397;
3430 -> 3429;
3430 -> 1399;
3430 -> 1397;
3431 -> 1595;
3432 -> 3431;
3432 -> 1435;
3433 -> 3432;
3433 -> 1437;
3433 -> 1435;
3434 -> 1433;
3434 -> 1465;
3434 -> 1591;
3434 -> 3433;
3434 -> 1600;
3434 -> 1461;
3434 -> 1462;
3434 -> 3419;
3434 -> 1472;
3434 -> 1464;
3435 -> 1615;
3436 -> 3435;
3436 -> 1484;
3437 -> 3436;
3437 -> 1486;
3437 -> 1484;
3438 -> 1482;
3438 -> 1516;
3438 -> 1611;
3438 -> 3437;
3438 -> 1620;
3438 -> 1510;
3438 -> 1511;
3438 -> 3423;
3438 -> 1518;
3438 -> 1515;
3439 -> 1635;
3440 -> 3439;
3440 -> 1530;
3441 -> 3440;
3441 -> 1532;
3441 -> 1530;
3442 -> 1528;
3442 -> 1562;
3442 -> 1631;
3442 -> 3441;
3442 -> 1640;
3442 -> 1556;
3442 -> 1557;
3442 -> 3427;
3442 -> 1564;
3442 -> 1561;
3443 -> 1576;
3444 -> 3443;
3444 -> 1397;
3445 -> 3444;
3445 -> 1399;
3445 -> 1397;
3446 -> 1595;
3447 -> 3446;
3447 -> 1435;
3448 -> 3447;
3448 -> 1437;
3448 -> 1435;
3449 -> 1433;
3449 -> 1465;
3449 -> 1591;
3449 -> 3448;
3449 -> 1600;
3449 -> 1461;
3449 -> 1462;
3449 -> 3434;
3449 -> 1472;
3449 -> 1464;
3450 -> 1615;
3451 -> 3450;
3451 -> 1484;
3452 -> 3451;
3452 -> 1486;
3452 -> 1484;
3453 -> 1482;
3453 -> 1516;
3453 -> 1611;
3453 -> 3452;
3453 -> 1620;
3453 -> 1510;
3453 -> 1511;
3453 -> 3438;
3453 -> 1518;
3453 -> 1515;
3454 -> 1635;
3455 -> 3454;
3455 -> 1530;
3456 -> 3455;
3456 -> 1532;
3456 -> 1530;
3457 -> 1528;
3457 -> 1562;
3457 -> 1631;
3457 -> 3456;
3457 -> 1640;
3457 -> 1556;
3457 -> 1557;
3457 -> 3442;
3457 -> 1564;
3457 -> 1561;
3458 -> 1576;
3459 -> 3458;
3459 -> 1397;
3460 -> 3459;
3460 -> 1399;
3460 -> 1397;
3461 -> 1595;
3462 -> 3461;
3462 -> 1435;
3463 -> 3462;
3463 -> 1437;
3463 -> 1435;
3464 -> 1433;
3464 -> 1465;
3464 -> 1591;
3464 -> 3463;
3464 -> 1600;
3464 -> 1461;
3464 -> 1462;
3464 -> 3449;
3464 -> 1472;
3464 -> 1464;
3465 -> 1615;
3466 -> 3465;
3466 -> 1484;
3467 -> 3466;
3467 -> 1486;
3467 -> 1484;
3468 -> 1482;
3468 -> 1516;
3468 -> 1611;
3468 -> 3467;
3468 -> 1620;
3468 -> 1510;
3468 -> 1511;
3468 -> 3453;
3468 -> 1518;
3468 -> 1515;
3469 -> 1635;
3470 -> 3469;
3470 -> 1530;
3471 -> 3470;
3471 -> 1532;
3471 -> 1530;
3472 -> 1528;
3472 -> 1562;
3472 -> 1631;
3472 -> 3471;
3472 -> 1640;
3472 -> 1556;
3472 -> 1557;
3472 -> 3457;
3472 -> 1564;
3472 -> 1561;
3473 -> 1576;
3474 -> 3473;
3474 -> 1397;
3475 -> 3474;
3475 -> 1399;
3475 -> 1397;
3476 -> 1595;
3477 -> 3476;
3477 -> 1435;
3478 -> 3477;
3478 -> 1437;
3478 -> 1435;
3479 -> 1433;
3479 -> 1465;
3479 -> 1591;
3479 -> 3478;
3479 -> 1600;
3479 -> 1461;
3479 -> 1462;
3479 -> 3464;
3479 -> 1472;
3479 -> 1464;
3480 -> 1615;
3481 -> 3480;
3481 -> 1484;
3482 -> 3481;
3482 -> 1486;
3482 -> 1484;
3483 -> 1482;
3483 -> 1516;
3483 -> 1611;
3483 -> 3482;
3483 -> 1620;
3483 -> 1510;
3483 -> 1511;
3483 -> 3468;
3483 -> 1518;
3483 -> 1515;
3484 -> 1635;
3485 -> 3484;
3485 -> 1530;
3486 -> 3485;
3486 -> 1532;
3486 -> 1530;
3487 -> 1528;
3487 -> 1562;
3487 -> 1631;
3487 -> 3486;
3487 -> 1640;
3487 -> 1556;
3487 -> 1557;
3487 -> 3472;
3487 -> 1564;
3487 -> 1561;
3488 -> 1576;
3489 -> 3488;
3489 -> 1397;
3490 -> 3489;
3490 -> 1399;
3490 -> 1397;
3491 -> 1595;
3492 -> 3491;
3492 -> 1435;
3493 -> 3492;
3493 -> 1437;
3493 -> 1435;
3494 -> 1433;
3494 -> 1465;
3494 -> 1591;
3494 -> 3493;
3494 -> 1600;
3494 -> 1461;
3494 -> 1462;
3494 -> 3479;
3494 -> 1472;
3494 -> 1464;
3495 -> 1615;
3496 -> 3495;
3496 -> 1484;
3497 -> 3496;
3497 -> 1486;
3497 -> 1484;
3498 -> 1482;
3498 -> 1516;
3498 -> 1611;
3498 -> 3497;
3498 -> 1620;
3498 -> 1510;
3498 -> 1511;
3498 -> 3483;
3498 -> 1518;
3498 -> 1515;
3499 -> 1635;
3500 -> 3499;
3500 -> 1530;
3501 -> 3500;
3501 -> 1532;
3501 -> 1530;
3502 -> 1528;
3502 -> 1562;
3502 -> 1631;
3502 -> 3501;
3502 -> 1640;
3502 -> 1556;
3502 -> 1557;
3502 -> 3487;
3502 -> 1564;
3502 -> 1561;
3503 -> 1576;
3504 -> 3503;
3504 -> 1397;
3505 -> 3504;
3505 -> 1399;
3505 -> 1397;
3506 -> 1595;
3507 -> 3506;
3507 -> 1435;
3508 -> 3507;
3508 -> 1437;
3508 -> 1435;
3509 -> 1433;
3509 -> 1465;
3509 -> 1591;
3509 -> 3508;
3509 -> 1600;
3509 -> 1461;
3509 -> 1462;
3509 -> 3494;
3509 -> 1472;
3509 -> 1464;
3510 -> 1615;
3511 -> 3510;
3511 -> 1484;
3512 -> 3511;
3512 -> 1486;
3512 -> 1484;
3513 -> 1482;
3513 -> 1516;
3513 -> 1611;
3513 -> 3512;
3513 -> 1620;
3513 -> 1510;
3513 -> 1511;
3513 -> 3498;
3513 -> 1518;
3513 -> 1515;
3514 -> 1635;
3515 -> 3514;
3515 -> 1530;
3516 -> 3515;
3516 -> 1532;
3516 -> 1530;
3517 -> 1528;
3517 -> 1562;
3517 -> 1631;
3517 -> 3516;
3517 -> 1640;
3517 -> 1556;
3517 -> 1557;
3517 -> 3502;
3517 -> 1564;
3517 -> 1561;
3518 -> 1576;
3519 -> 3518;
3519 -> 1397;
3520 -> 3519;
3520 -> 1399;
3520 -> 1397;
3521 -> 1595;
3522 -> 3521;
3522 -> 1435;
3523 -> 3522;
3523 -> 1437;
3523 -> 1435;
3524 -> 1433;
3524 -> 1465;
3524 -> 1591;
3524 -> 3523;
3524 -> 1600;
3524 -> 1461;
3524 -> 1462;
3524 -> 3509;
3524 -> 1472;
3524 -> 1464;
3525 -> 1615;
3526 -> 3525;
3526 -> 1484;
3527 -> 3526;
3527 -> 1486;
3527 -> 1484;
3528 -> 1482;
3528 -> 1516;
3528 -> 1611;
3528 -> 3527;
3528 -> 1620;
3528 -> 1510;
3528 -> 1511;
3528 -> 3513;
3528 -> 1518;
3528 -> 1515;
3529 -> 1635;
3530 -> 3529;
3530 -> 1530;
3531 -> 3530;
3531 -> 1532;
3531 -> 1530;
3532 -> 1528;
3532 -> 1562;
3532 -> 1631;
3532 -> 3531;
3532 -> 1640;
3532 -> 1556;
3532 -> 1557;
3532 -> 3517;
3532 -> 1564;
3532 -> 1561;
3533 -> 1576;
3534 -> 3533;
3534 -> 1397;
3535 -> 3534;
3535 -> 1399;
3535 -> 1397;
3536 -> 1595;
3537 -> 3536;
3537 -> 1435;
3538 -> 3537;
3538 -> 1437;
3538 -> 1435;
3539 -> 1433;
3539 -> 1465;
3539 -> 1591;
3539 -> 3538;
3539 -> 1600;
3539 -> 1461;
3539 -> 1462;
3539 -> 3524;
3539 -> 1472;
3539 -> 1464;
3540 -> 1615;
3541 -> 3540;
3541 -> 1484;
3542 -> 3541;
3542 -> 1486;
3542 -> 1484;
3543 -> 1482;
3543 -> 1516;
3543 -> 1611;
3543 -> 3542;
3543 -> 1620;
3543 -> 1510;
3543 -> 1511;
3543 -> 3528;
3543 -> 1518;
3543 -> 1515;
3544 -> 1635;
3545 -> 3544;
3545 -> 1530;
3546 -> 3545;
3546 -> 1532;
3546 -> 1530;
3547 -> 1528;
3547 -> 1562;
3547 -> 1631;
3547 -> 3546;
3547 -> 1640;
3547 -> 1556;
3547 -> 1557;
3547 -> 3532;
3547 -> 1564;
3547 -> 1561;
3548 -> 1576;
3549 -> 3548;
3549 -> 1397;
3550 -> 3549;
3550 -> 1399;
3550 -> 1397;
3551 -> 1595;
3552 -> 3551;
3552 -> 1435;
3553 -> 3552;
3553 -> 1437;
3553 -> 1435;
3554 -> 1433;
3554 -> 1465;
3554 -> 1591;
3554 -> 3553;
3554 -> 1600;
3554 -> 1461;
3554 -> 1462;
3554 -> 3539;
3554 -> 1472;
3554 -> 1464;
3555 -> 1615;
3556 -> 3555;
3556 -> 1484;
3557 -> 3556;
3557 -> 1486;
3557 -> 1484;
3558 -> 1482;
3558 -> 1516;
3558 -> 1611;
3558 -> 3557;
3558 -> 1620;
3558 -> 1510;
3558 -> 1511;
3558 -> 3543;
3558 -> 1518;
3558 -> 1515;
3559 -> 1635;
3560 -> 3559;
3560 -> 1530;
3561 -> 3560;
3561 -> 1532;
3561 -> 1530;
3562 -> 1528;
3562 -> 1562;
3562 -> 1631;
3562 -> 3561;
3562 -> 1640;
3562 -> 1556;
3562 -> 1557;
3562 -> 3547;
3562 -> 1564;
3562 -> 1561;
3563 -> 1576;
3564 -> 3563;
3564 -> 1397;
3565 -> 3564;
3565 -> 1399;
3565 -> 1397;
3566 -> 1595;
3567 -> 3566;
3567 -> 1435;
3568 -> 3567;
3568 -> 1437;
3568 -> 1435;
3569 -> 1433;
3569 -> 1465;
3569 -> 1591;
3569 -> 3568;
3569 -> 1600;
3569 -> 1461;
3569 -> 1462;
3569 -> 3554;
3569 -> 1472;
3569 -> 1464;
3570 -> 1615;
3571 -> 3570;
3571 -> 1484;
3572 -> 3571;
3572 -> 1486;
3572 -> 1484;
3573 -> 1482;
3573 -> 1516;
3573 -> 1611;
3573 -> 3572;
3573 -> 1620;
3573 -> 1510;
3573 -> 1511;
3573 -> 3558;
3573 -> 1518;
3573 -> 1515;
3574 -> 1635;
3575 -> 3574;
3575 -> 1530;
3576 -> 3575;
3576 -> 1532;
3576 -> 1530;
3577 -> 1528;
3577 -> 1562;
3577 -> 1631;
3577 -> 3576;
3577 -> 1640;
3577 -> 1556;
3577 -> 1557;
3577 -> 3562;
3577 -> 1564;
3577 -> 1561;
3578 -> 1576;
3579 -> 3578;
3579 -> 1397;
3580 -> 3579;
3580 -> 1399;
3580 -> 1397;
3581 -> 1595;
3582 -> 3581;
3582 -> 1435;
3583 -> 3582;
3583 -> 1437;
3583 -> 1435;
3584 -> 1433;
3584 -> 1465;
3584 -> 1591;
3584 -> 3583;
3584 -> 1600;
3584 -> 1461;
3584 -> 1462;
3584 -> 3569;
3584 -> 1472;
3584 -> 1464;
3585 -> 1615;
3586 -> 3585;
3586 -> 1484;
3587 -> 3586;
3587 -> 1486;
3587 -> 1484;
3588 -> 1482;
3588 -> 1516;
3588 -> 1611;
3588 -> 3587;
3588 -> 1620;
3588 -> 1510;
3588 -> 1511;
3588 -> 3573;
3588 -> 1518;
3588 -> 1515;
3589 -> 1635;
3590 -> 3589;
3590 -> 1530;
3591 -> 3590;
3591 -> 1532;
3591 -> 1530;
3592 -> 1528;
3592 -> 1562;
3592 -> 1631;
3592 -> 3591;
3592 -> 1640;
3592 -> 1556;
3592 -> 1557;
3592 -> 3577;
3592 -> 1564;
3592 -> 1561;
3593 -> 1576;
3594 -> 3593;
3594 -> 1397;
3595 -> 3594;
3595 -> 1399;
3595 -> 1397;
3596 -> 1595;
3597 -> 3596;
3597 -> 1435;
3598 -> 3597;
3598 -> 1437;
3598 -> 1435;
3599 -> 1433;
3599 -> 1465;
3599 -> 1591;
3599 -> 3598;
3599 -> 1600;
3599 -> 1461;
3599 -> 1462;
3599 -> 3584;
3599 -> 1472;
3599 -> 1464;
3600 -> 1615;
3601 -> 3600;
3601 -> 1484;
3602 -> 3601;
3602 -> 1486;
3602 -> 1484;
3603 -> 1482;
3603 -> 1516;
3603 -> 1611;
3603 -> 3602;
3603 -> 1620;
3603 -> 1510;
3603 -> 1511;
3603 -> 3588;
3603 -> 1518;
3603 -> 1515;
3604 -> 1635;
3605 -> 3604;
3605 -> 1530;
3606 -> 3605;
3606 -> 1532;
3606 -> 1530;
3607 -> 1528;
3607 -> 1562;
3607 -> 1631;
3607 -> 3606;
3607 -> 1640;
3607 -> 1556;
3607 -> 1557;
3607 -> 3592;
3607 -> 1564;
3607 -> 1561;
3608 -> 1576;
3609 -> 3608;
3609 -> 1397;
3610 -> 3609;
3610 -> 1399;
3610 -> 1397;
3611 -> 1595;
3612 -> 3611;
3612 -> 1435;
3613 -> 3612;
3613 -> 1437;
3613 -> 1435;
3614 -> 1433;
3614 -> 1465;
3614 -> 1591;
3614 -> 3613;
3614 -> 1600;
3614 -> 1461;
3614 -> 1462;
3614 -> 3599;
3614 -> 1472;
3614 -> 1464;
3615 -> 1615;
3616 -> 3615;
3616 -> 1484;
3617 -> 3616;
3617 -> 1486;
3617 -> 1484;
3618 -> 1482;
3618 -> 1516;
3618 -> 1611;
3618 -> 3617;
3618 -> 1620;
3618 -> 1510;
3618 -> 1511;
3618 -> 3603;
3618 -> 1518;
3618 -> 1515;
3619 -> 1635;
3620 -> 3619;
3620 -> 1530;
3621 -> 3620;
3621 -> 1532;
3621 -> 1530;
3622 -> 1528;
3622 -> 1562;
3622 -> 1631;
3622 -> 3621;
3622 -> 1640;
3622 -> 1556;
3622 -> 1557;
3622 -> 3607;
3622 -> 1564;
3622 -> 1561;
3623 -> 1576;
3624 -> 3623;
3624 -> 1397;
3625 -> 3624;
3625 -> 1399;
3625 -> 1397;
3626 -> 1595;
3627 -> 3626;
3627 -> 1435;
3628 -> 3627;
3628 -> 1437;
3628 -> 1435;
3629 -> 1433;
3629 -> 1465;
3629 -> 1591;
3629 -> 3628;
3629 -> 1600;
3629 -> 1461;
3629 -> 1462;
3629 -> 3614;
3629 -> 1472;
3629 -> 1464;
3630 -> 1615;
3631 -> 3630;
3631 -> 1484;
3632 -> 3631;
3632 -> 1486;
3632 -> 1484;
3633 -> 1482;
3633 -> 1516;
3633 -> 1611;
3633 -> 3632;
3633 -> 1620;
3633 -> 1510;
3633 -> 1511;
3633 -> 3618;
3633 -> 1518;
3633 -> 1515;
3634 -> 1635;
3635 -> 3634;
3635 -> 1530;
3636 -> 3635;
3636 -> 1532;
3636 -> 1530;
3637 -> 1528;
3637 -> 1562;
3637 -> 1631;
3637 -> 3636;
3637 -> 1640;
3637 -> 1556;
3637 -> 1557;
3637 -> 3622;
3637 -> 1564;
3637 -> 1561;
3638 -> 1576;
3639 -> 3638;
3639 -> 1397;
3640 -> 3639;
3640 -> 1399;
3640 -> 1397;
3641 -> 1595;
3642 -> 3641;
3642 -> 1435;
3643 -> 3642;
3643 -> 1437;
3643 -> 1435;
3644 -> 1433;
3644 -> 1465;
3644 -> 1591;
3644 -> 3643;
3644 -> 1600;
3644 -> 1461;
3644 -> 1462;
3644 -> 3629;
3644 -> 1472;
3644 -> 1464;
3645 -> 1615;
3646 -> 3645;
3646 -> 1484;
3647 -> 3646;
3647 -> 1486;
3647 -> 1484;
3648 -> 1482;
3648 -> 1516;
3648 -> 1611;
3648 -> 3647;
3648 -> 1620;
3648 -> 1510;
3648 -> 1511;
3648 -> 3633;
3648 -> 1518;
3648 -> 1515;
3649 -> 1635;
3650 -> 3649;
3650 -> 1530;
3651 -> 3650;
3651 -> 1532;
3651 -> 1530;
3652 -> 1528;
3652 -> 1562;
3652 -> 1631;
3652 -> 3651;
3652 -> 1640;
3652 -> 1556;
3652 -> 1557;
3652 -> 3637;
3652 -> 1564;
3652 -> 1561;
3653 -> 1576;
3654 -> 3653;
3654 -> 1397;
3655 -> 3654;
3655 -> 1399;
3655 -> 1397;
3656 -> 1595;
3657 -> 3656;
3657 -> 1435;
3658 -> 3657;
3658 -> 1437;
3658 -> 1435;
3659 -> 1433;
3659 -> 1465;
3659 -> 1591;
3659 -> 3658;
3659 -> 1600;
3659 -> 1461;
3659 -> 1462;
3659 -> 3644;
3659 -> 1472;
3659 -> 1464;
3660 -> 1615;
3661 -> 3660;
3661 -> 1484;
3662 -> 3661;
3662 -> 1486;
3662 -> 1484;
3663 -> 1482;
3663 -> 1516;
3663 -> 1611;
3663 -> 3662;
3663 -> 1620;
3663 -> 1510;
3663 -> 1511;
3663 -> 3648;
3663 -> 1518;
3663 -> 1515;
3664 -> 1635;
3665 -> 3664;
3665 -> 1530;
3666 -> 3665;
3666 -> 1532;
3666 -> 1530;
3667 -> 1528;
3667 -> 1562;
3667 -> 1631;
3667 -> 3666;
3667 -> 1640;
3667 -> 1556;
3667 -> 1557;
3667 -> 3652;
3667 -> 1564;
3667 -> 1561;
3668 -> 1576;
3669 -> 3668;
3669 -> 1397;
3670 -> 3669;
3670 -> 1399;
3670 -> 1397;
3671 -> 1595;
3672 -> 3671;
3672 -> 1435;
3673 -> 3672;
3673 -> 1437;
3673 -> 1435;
3674 -> 1433;
3674 -> 1465;
3674 -> 1591;
3674 -> 3673;
3674 -> 1600;
3674 -> 1461;
3674 -> 1462;
3674 -> 3659;
3674 -> 1472;
3674 -> 1464;
3675 -> 1615;
3676 -> 3675;
3676 -> 1484;
3677 -> 3676;
3677 -> 1486;
3677 -> 1484;
3678 -> 1482;
3678 -> 1516;
3678 -> 1611;
3678 -> 3677;
3678 -> 1620;
3678 -> 1510;
3678 -> 1511;
3678 -> 3663;
3678 -> 1518;
3678 -> 1515;
3679 -> 1635;
3680 -> 3679;
3680 -> 1530;
3681 -> 3680;
3681 -> 1532;
3681 -> 1530;
3682 -> 1528;
3682 -> 1562;
3682 -> 1631;
3682 -> 3681;
3682 -> 1640;
3682 -> 1556;
3682 -> 1557;
3682 -> 3667;
3682 -> 1564;
3682 -> 1561;
3683 -> 1576;
3684 -> 3683;
3684 -> 1397;
3685 -> 3684;
3685 -> 1399;
3685 -> 1397;
3686 -> 1595;
3687 -> 3686;
3687 -> 1435;
3688 -> 3687;
3688 -> 1437;
3688 -> 1435;
3689 -> 1433;
3689 -> 1465;
3689 -> 1591;
3689 -> 3688;
3689 -> 1600;
3689 -> 1461;
3689 -> 1462;
3689 -> 3674;
3689 -> 1472;
3689 -> 1464;
3690 -> 1615;
3691 -> 3690;
3691 -> 1484;
3692 -> 3691;
3692 -> 1486;
3692 -> 1484;
3693 -> 1482;
3693 -> 1516;
3693 -> 1611;
3693 -> 3692;
3693 -> 1620;
3693 -> 1510;
3693 -> 1511;
3693 -> 3678;
3693 -> 1518;
3693 -> 1515;
3694 -> 1635;
3695 -> 3694;
3695 -> 1530;
3696 -> 3695;
3696 -> 1532;
3696 -> 1530;
3697 -> 1528;
3697 -> 1562;
3697 -> 1631;
3697 -> 3696;
3697 -> 1640;
3697 -> 1556;
3697 -> 1557;
3697 -> 3682;
3697 -> 1564;
3697 -> 1561;
3698 -> 1576;
3699 -> 3698;
3699 -> 1397;
3700 -> 3699;
3700 -> 1399;
3700 -> 1397;
3701 -> 1595;
3702 -> 3701;
3702 -> 1435;
3703 -> 3702;
3703 -> 1437;
3703 -> 1435;
3704 -> 1433;
3704 -> 1465;
3704 -> 1591;
3704 -> 3703;
3704 -> 1600;
3704 -> 1461;
3704 -> 1462;
3704 -> 3689;
3704 -> 1472;
3704 -> 1464;
3705 -> 1615;
3706 -> 3705;
3706 -> 1484;
3707 -> 3706;
3707 -> 1486;
3707 -> 1484;
3708 -> 1482;
3708 -> 1516;
3708 -> 1611;
3708 -> 3707;
3708 -> 1620;
3708 -> 1510;
3708 -> 1511;
3708 -> 3693;
3708 -> 1518;
3708 -> 1515;
3709 -> 1635;
3710 -> 3709;
3710 -> 1530;
3711 -> 3710;
3711 -> 1532;
3711 -> 1530;
3712 -> 1528;
3712 -> 1562;
3712 -> 1631;
3712 -> 3711;
3712 -> 1640;
3712 -> 1556;
3712 -> 1557;
3712 -> 3697;
3712 -> 1564;
3712 -> 1561;
3713 -> 1576;
3714 -> 3713;
3714 -> 1397;
3715 -> 3714;
3715 -> 1399;
3715 -> 1397;
3716 -> 1595;
3717 -> 3716;
3717 -> 1435;
3718 -> 3717;
3718 -> 1437;
3718 -> 1435;
3719 -> 1433;
3719 -> 1465;
3719 -> 1591;
3719 -> 3718;
3719 -> 1600;
3719 -> 1461;
3719 -> 1462;
3719 -> 3704;
3719 -> 1472;
3719 -> 1464;
3720 -> 1615;
3721 -> 3720;
3721 -> 1484;
3722 -> 3721;
3722 -> 1486;
3722 -> 1484;
3723 -> 1482;
3723 -> 1516;
3723 -> 1611;
3723 -> 3722;
3723 -> 1620;
3723 -> 1510;
3723 -> 1511;
3723 -> 3708;
3723 -> 1518;
3723 -> 1515;
3724 -> 1635;
3725 -> 3724;
3725 -> 1530;
3726 -> 3725;
3726 -> 1532;
3726 -> 1530;
3727 -> 1528;
3727 -> 1562;
3727 -> 1631;
3727 -> 3726;
3727 -> 1640;
3727 -> 1556;
3727 -> 1557;
3727 -> 3712;
3727 -> 1564;
3727 -> 1561;
3728 -> 1576;
3729 -> 3728;
3729 -> 1397;
3730 -> 3729;
3730 -> 1399;
3730 -> 1397;
3731 -> 1595;
3732 -> 3731;
3732 -> 1435;
3733 -> 3732;
3733 -> 1437;
3733 -> 1435;
3734 -> 1433;
3734 -> 1465;
3734 -> 1591;
3734 -> 3733;
3734 -> 1600;
3734 -> 1461;
3734 -> 1462;
3734 -> 3719;
3734 -> 1472;
3734 -> 1464;
3735 -> 1615;
3736 -> 3735;
3736 -> 1484;
3737 -> 3736;
3737 -> 1486;
3737 -> 1484;
3738 -> 1482;
3738 -> 1516;
3738 -> 1611;
3738 -> 3737;
3738 -> 1620;
3738 -> 1510;
3738 -> 1511;
3738 -> 3723;
3738 -> 1518;
3738 -> 1515;
3739 -> 1635;
3740 -> 3739;
3740 -> 1530;
3741 -> 3740;
3741 -> 1532;
3741 -> 1530;
3742 -> 1528;
3742 -> 1562;
3742 -> 1631;
3742 -> 3741;
3742 -> 1640;
3742 -> 1556;
3742 -> 1557;
3742 -> 3727;
3742 -> 1564;
3742 -> 1561;
3743 -> 1576;
3744 -> 3743;
3744 -> 1397;
3745 -> 3744;
3745 -> 1399;
3745 -> 1397;
3746 -> 1595;
3747 -> 3746;
3747 -> 1435;
3748 -> 3747;
3748 -> 1437;
3748 -> 1435;
3749 -> 1433;
3749 -> 1465;
3749 -> 1591;
3749 -> 3748;
3749 -> 1600;
3749 -> 1461;
3749 -> 1462;
3749 -> 3734;
3749 -> 1472;
3749 -> 1464;
3750 -> 1615;
3751 -> 3750;
3751 -> 1484;
3752 -> 3751;
3752 -> 1486;
3752 -> 1484;
3753 -> 1482;
3753 -> 1516;
3753 -> 1611;
3753 -> 3752;
3753 -> 1620;
3753 -> 1510;
3753 -> 1511;
3753 -> 3738;
3753 -> 1518;
3753 -> 1515;
3754 -> 1635;
3755 -> 3754;
3755 -> 1530;
3756 -> 3755;
3756 -> 1532;
3756 -> 1530;
3757 -> 1528;
3757 -> 1562;
3757 -> 1631;
3757 -> 3756;
3757 -> 1640;
3757 -> 1556;
3757 -> 1557;
3757 -> 3742;
3757 -> 1564;
3757 -> 1561;
3758 -> 1576;
3759 -> 3758;
3759 -> 1397;
3760 -> 3759;
3760 -> 1399;
3760 -> 1397;
3761 -> 1595;
3762 -> 3761;
3762 -> 1435;
3763 -> 3762;
3763 -> 1437;
3763 -> 1435;
3764 -> 1433;
3764 -> 1465;
3764 -> 1591;
3764 -> 3763;
3764 -> 1600;
3764 -> 1461;
3764 -> 1462;
3764 -> 3749;
3764 -> 1472;
3764 -> 1464;
3765 -> 1615;
3766 -> 3765;
3766 -> 1484;
3767 -> 3766;
3767 -> 1486;
3767 -> 1484;
3768 -> 1482;
3768 -> 1516;
3768 -> 1611;
3768 -> 3767;
3768 -> 1620;
3768 -> 1510;
3768 -> 1511;
3768 -> 3753;
3768 -> 1518;
3768 -> 1515;
3769 -> 1635;
3770 -> 3769;
3770 -> 1530;
3771 -> 3770;
3771 -> 1532;
3771 -> 1530;
3772 -> 1528;
3772 -> 1562;
3772 -> 1631;
3772 -> 3771;
3772 -> 1640;
3772 -> 1556;
3772 -> 1557;
3772 -> 3757;
3772 -> 1564;
3772 -> 1561;
3773 -> 1576;
3774 -> 3773;
3774 -> 1397;
3775 -> 3774;
3775 -> 1399;
3775 -> 1397;
3776 -> 1595;
3777 -> 3776;
3777 -> 1435;
3778 -> 3777;
3778 -> 1437;
3778 -> 1435;
3779 -> 1433;
3779 -> 1465;
3779 -> 1591;
3779 -> 3778;
3779 -> 1600;
3779 -> 1461;
3779 -> 1462;
3779 -> 3764;
3779 -> 1472;
3779 -> 1464;
3780 -> 1615;
3781 -> 3780;
3781 -> 1484;
3782 -> 3781;
3782 -> 1486;
3782 -> 1484;
3783 -> 1482;
3783 -> 1516;
3783 -> 1611;
3783 -> 3782;
3783 -> 1620;
3783 -> 1510;
3783 -> 1511;
3783 -> 3768;
3783 -> 1518;
3783 -> 1515;
3784 -> 1635;
3785 -> 3784;
3785 -> 1530;
3786 -> 3785;
3786 -> 1532;
3786 -> 1530;
3787 -> 1528;
3787 -> 1562;
3787 -> 1631;
3787 -> 3786;
3787 -> 1640;
3787 -> 1556;
3787 -> 1557;
3787 -> 3772;
3787 -> 1564;
3787 -> 1561;
3788 -> 1576;
3789 -> 3788;
3789 -> 1397;
3790 -> 3789;
3790 -> 1399;
3790 -> 1397;
3791 -> 1595;
3792 -> 3791;
3792 -> 1435;
3793 -> 3792;
3793 -> 1437;
3793 -> 1435;
3794 -> 1433;
3794 -> 1465;
3794 -> 1591;
3794 -> 3793;
3794 -> 1600;
3794 -> 1461;
3794 -> 1462;
3794 -> 3779;
3794 -> 1472;
3794 -> 1464;
3795 -> 1615;
3796 -> 3795;
3796 -> 1484;
3797 -> 3796;
3797 -> 1486;
3797 -> 1484;
3798 -> 1482;
3798 -> 1516;
3798 -> 1611;
3798 -> 3797;
3798 -> 1620;
3798 -> 1510;
3798 -> 1511;
3798 -> 3783;
3798 -> 1518;
3798 -> 1515;
3799 -> 1635;
3800 -> 3799;
3800 -> 1530;
3801 -> 3800;
3801 -> 1532;
3801 -> 1530;
3802 -> 1528;
3802 -> 1562;
3802 -> 1631;
3802 -> 3801;
3802 -> 1640;
3802 -> 1556;
3802 -> 1557;
3802 -> 3787;
3802 -> 1564;
3802 -> 1561;
3803 -> 1576;
3804 -> 3803;
3804 -> 1397;
3805 -> 3804;
3805 -> 1399;
3805 -> 1397;
3806 -> 1595;
3807 -> 3806;
3807 -> 1435;
3808 -> 3807;
3808 -> 1437;
3808 -> 1435;
3809 -> 1433;
3809 -> 1465;
3809 -> 1591;
3809 -> 3808;
3809 -> 1600;
3809 -> 1461;
3809 -> 1462;
3809 -> 3794;
3809 -> 1472;
3809 -> 1464;
3810 -> 1615;
3811 -> 3810;
3811 -> 1484;
3812 -> 3811;
3812 -> 1486;
3812 -> 1484;
3813 -> 1482;
3813 -> 1516;
3813 -> 1611;
3813 -> 3812;
3813 -> 1620;
3813 -> 1510;
3813 -> 1511;
3813 -> 3798;
3813 -> 1518;
3813 -> 1515;
3814 -> 1635;
3815 -> 3814;
3815 -> 1530;
3816 -> 3815;
3816 -> 1532;
3816 -> 1530;
3817 -> 1528;
3817 -> 1562;
3817 -> 1631;
3817 -> 3816;
3817 -> 1640;
3817 -> 1556;
3817 -> 1557;
3817 -> 3802;
3817 -> 1564;
3817 -> 1561;
3818 -> 1576;
3819 -> 3818;
3819 -> 1397;
3820 -> 3819;
3820 -> 1399;
3820 -> 1397;
3821 -> 1595;
3822 -> 3821;
3822 -> 1435;
3823 -> 3822;
3823 -> 1437;
3823 -> 1435;
3824 -> 1433;
3824 -> 1465;
3824 -> 1591;
3824 -> 3823;
3824 -> 1600;
3824 -> 1461;
3824 -> 1462;
3824 -> 3809;
3824 -> 1472;
3824 -> 1464;
3825 -> 1615;
3826 -> 3825;
3826 -> 1484;
3827 -> 3826;
3827 -> 1486;
3827 -> 1484;
3828 -> 1482;
3828 -> 1516;
3828 -> 1611;
3828 -> 3827;
3828 -> 1620;
3828 -> 1510;
3828 -> 1511;
3828 -> 3813;
3828 -> 1518;
3828 -> 1515;
3829 -> 1635;
3830 -> 3829;
3830 -> 1530;
3831 -> 3830;
3831 -> 1532;
3831 -> 1530;
3832 -> 1528;
3832 -> 1562;
3832 -> 1631;
3832 -> 3831;
3832 -> 1640;
3832 -> 1556;
3832 -> 1557;
3832 -> 3817;
3832 -> 1564;
3832 -> 1561;
3833 -> 1576;
3834 -> 3833;
3834 -> 1397;
3835 -> 3834;
3835 -> 1399;
3835 -> 1397;
3836 -> 1595;
3837 -> 3836;
3837 -> 1435;
3838 -> 3837;
3838 -> 1437;
3838 -> 1435;
3839 -> 1433;
3839 -> 1465;
3839 -> 1591;
3839 -> 3838;
3839 -> 1600;
3839 -> 1461;
3839 -> 1462;
3839 -> 3824;
3839 -> 1472;
3839 -> 1464;
3840 -> 1615;
3841 -> 3840;
3841 -> 1484;
3842 -> 3841;
3842 -> 1486;
3842 -> 1484;
3843 -> 1482;
3843 -> 1516;
3843 -> 1611;
3843 -> 3842;
3843 -> 1620;
3843 -> 1510;
3843 -> 1511;
3843 -> 3828;
3843 -> 1518;
3843 -> 1515;
3844 -> 1635;
3845 -> 3844;
3845 -> 1530;
3846 -> 3845;
3846 -> 1532;
3846 -> 1530;
3847 -> 1528;
3847 -> 1562;
3847 -> 1631;
3847 -> 3846;
3847 -> 1640;
3847 -> 1556;
3847 -> 1557;
3847 -> 3832;
3847 -> 1564;
3847 -> 1561;
3848 -> 1576;
3849 -> 3848;
3849 -> 1397;
3850 -> 3849;
3850 -> 1399;
3850 -> 1397;
3851 -> 1595;
3852 -> 3851;
3852 -> 1435;
3853 -> 3852;
3853 -> 1437;
3853 -> 1435;
3854 -> 1433;
3854 -> 1465;
3854 -> 1591;
3854 -> 3853;
3854 -> 1600;
3854 -> 1461;
3854 -> 1462;
3854 -> 3839;
3854 -> 1472;
3854 -> 1464;
3855 -> 1615;
3856 -> 3855;
3856 -> 1484;
3857 -> 3856;
3857 -> 1486;
3857 -> 1484;
3858 -> 1482;
3858 -> 1516;
3858 -> 1611;
3858 -> 3857;
3858 -> 1620;
3858 -> 1510;
3858 -> 1511;
3858 -> 3843;
3858 -> 1518;
3858 -> 1515;
3859 -> 1635;
3860 -> 3859;
3860 -> 1530;
3861 -> 3860;
3861 -> 1532;
3861 -> 1530;
3862 -> 1528;
3862 -> 1562;
3862 -> 1631;
3862 -> 3861;
3862 -> 1640;
3862 -> 1556;
3862 -> 1557;
3862 -> 3847;
3862 -> 1564;
3862 -> 1561;
3863 -> 1576;
3864 -> 3863;
3864 -> 1397;
3865 -> 3864;
3865 -> 1399;
3865 -> 1397;
3866 -> 1595;
3867 -> 3866;
3867 -> 1435;
3868 -> 3867;
3868 -> 1437;
3868 -> 1435;
3869 -> 1433;
3869 -> 1465;
3869 -> 1591;
3869 -> 3868;
3869 -> 1600;
3869 -> 1461;
3869 -> 1462;
3869 -> 3854;
3869 -> 1472;
3869 -> 1464;
3870 -> 1615;
3871 -> 3870;
3871 -> 1484;
3872 -> 3871;
3872 -> 1486;
3872 -> 1484;
3873 -> 1482;
3873 -> 1516;
3873 -> 1611;
3873 -> 3872;
3873 -> 1620;
3873 -> 1510;
3873 -> 1511;
3873 -> 3858;
3873 -> 1518;
3873 -> 1515;
3874 -> 1635;
3875 -> 3874;
3875 -> 1530;
3876 -> 3875;
3876 -> 1532;
3876 -> 1530;
3877 -> 1528;
3877 -> 1562;
3877 -> 1631;
3877 -> 3876;
3877 -> 1640;
3877 -> 1556;
3877 -> 1557;
3877 -> 3862;
3877 -> 1564;
3877 -> 1561;
3878 -> 1576;
3879 -> 3878;
3879 -> 1397;
3880 -> 3879;
3880 -> 1399;
3880 -> 1397;
3881 -> 1595;
3882 -> 3881;
3882 -> 1435;
3883 -> 3882;
3883 -> 1437;
3883 -> 1435;
3884 -> 1433;
3884 -> 1465;
3884 -> 1591;
3884 -> 3883;
3884 -> 1600;
3884 -> 1461;
3884 -> 1462;
3884 -> 3869;
3884 -> 1472;
3884 -> 1464;
3885 -> 1615;
3886 -> 3885;
3886 -> 1484;
3887 -> 3886;
3887 -> 1486;
3887 -> 1484;
3888 -> 1482;
3888 -> 1516;
3888 -> 1611;
3888 -> 3887;
3888 -> 1620;
3888 -> 1510;
3888 -> 1511;
3888 -> 3873;
3888 -> 1518;
3888 -> 1515;
3889 -> 1635;
3890 -> 3889;
3890 -> 1530;
3891 -> 3890;
3891 -> 1532;
3891 -> 1530;
3892 -> 1528;
3892 -> 1562;
3892 -> 1631;
3892 -> 3891;
3892 -> 1640;
3892 -> 1556;
3892 -> 1557;
3892 -> 3877;
3892 -> 1564;
3892 -> 1561;
3893 -> 1576;
3894 -> 3893;
3894 -> 1397;
3895 -> 3894;
3895 -> 1399;
3895 -> 1397;
3896 -> 1595;
3897 -> 3896;
3897 -> 1435;
3898 -> 3897;
3898 -> 1437;
3898 -> 1435;
3899 -> 1433;
3899 -> 1465;
3899 -> 1591;
3899 -> 3898;
3899 -> 1600;
3899 -> 1461;
3899 -> 1462;
3899 -> 3884;
3899 -> 1472;
3899 -> 1464;
3900 -> 1615;
3901 -> 3900;
3901 -> 1484;
3902 -> 3901;
3902 -> 1486;
3902 -> 1484;
3903 -> 1482;
3903 -> 1516;
3903 -> 1611;
3903 -> 3902;
3903 -> 1620;
3903 -> 1510;
3903 -> 1511;
3903 -> 3888;
3903 -> 1518;
3903 -> 1515;
3904 -> 1635;
3905 -> 3904;
3905 -> 1530;
3906 -> 3905;
3906 -> 1532;
3906 -> 1530;
3907 -> 1528;
3907 -> 1562;
3907 -> 1631;
3907 -> 3906;
3907 -> 1640;
3907 -> 1556;
3907 -> 1557;
3907 -> 3892;
3907 -> 1564;
3907 -> 1561;
3908 -> 1576;
3909 -> 3908;
3909 -> 1397;
3910 -> 3909;
3910 -> 1399;
3910 -> 1397;
3911 -> 1595;
3912 -> 3911;
3912 -> 1435;
3913 -> 3912;
3913 -> 1437;
3913 -> 1435;
3914 -> 1433;
3914 -> 1465;
3914 -> 1591;
3914 -> 3913;
3914 -> 1600;
3914 -> 1461;
3914 -> 1462;
3914 -> 3899;
3914 -> 1472;
3914 -> 1464;
3915 -> 1615;
3916 -> 3915;
3916 -> 1484;
3917 -> 3916;
3917 -> 1486;
3917 -> 1484;
3918 -> 1482;
3918 -> 1516;
3918 -> 1611;
3918 -> 3917;
3918 -> 1620;
3918 -> 1510;
3918 -> 1511;
3918 -> 3903;
3918 -> 1518;
3918 -> 1515;
3919 -> 1635;
3920 -> 3919;
3920 -> 1530;
3921 -> 3920;
3921 -> 1532;
3921 -> 1530;
3922 -> 1528;
3922 -> 1562;
3922 -> 1631;
3922 -> 3921;
3922 -> 1640;
3922 -> 1556;
3922 -> 1557;
3922 -> 3907;
3922 -> 1564;
3922 -> 1561;
3923 -> 1576;
3924 -> 3923;
3924 -> 1397;
3925 -> 3924;
3925 -> 1399;
3925 -> 1397;
3926 -> 1595;
3927 -> 3926;
3927 -> 1435;
3928 -> 3927;
3928 -> 1437;
3928 -> 1435;
3929 -> 1433;
3929 -> 1465;
3929 -> 1591;
3929 -> 3928;
3929 -> 1600;
3929 -> 1461;
3929 -> 1462;
3929 -> 3914;
3929 -> 1472;
3929 -> 1464;
3930 -> 1615;
3931 -> 3930;
3931 -> 1484;
3932 -> 3931;
3932 -> 1486;
3932 -> 1484;
3933 -> 1482;
3933 -> 1516;
3933 -> 1611;
3933 -> 3932;
3933 -> 1620;
3933 -> 1510;
3933 -> 1511;
3933 -> 3918;
3933 -> 1518;
3933 -> 1515;
3934 -> 1635;
3935 -> 3934;
3935 -> 1530;
3936 -> 3935;
3936 -> 1532;
3936 -> 1530;
3937 -> 1528;
3937 -> 1562;
3937 -> 1631;
3937 -> 3936;
3937 -> 1640;
3937 -> 1556;
3937 -> 1557;
3937 -> 3922;
3937 -> 1564;
3937 -> 1561;
3938 -> 1576;
3939 -> 3938;
3939 -> 1397;
3940 -> 3939;
3940 -> 1399;
3940 -> 1397;
3941 -> 1595;
3942 -> 3941;
3942 -> 1435;
3943 -> 3942;
3943 -> 1437;
3943 -> 1435;
3944 -> 1433;
3944 -> 1465;
3944 -> 1591;
3944 -> 3943;
3944 -> 1600;
3944 -> 1461;
3944 -> 1462;
3944 -> 3929;
3944 -> 1472;
3944 -> 1464;
3945 -> 1615;
3946 -> 3945;
3946 -> 1484;
3947 -> 3946;
3947 -> 1486;
3947 -> 1484;
3948 -> 1482;
3948 -> 1516;
3948 -> 1611;
3948 -> 3947;
3948 -> 1620;
3948 -> 1510;
3948 -> 1511;
3948 -> 3933;
3948 -> 1518;
3948 -> 1515;
3949 -> 1635;
3950 -> 3949;
3950 -> 1530;
3951 -> 3950;
3951 -> 1532;
3951 -> 1530;
3952 -> 1528;
3952 -> 1562;
3952 -> 1631;
3952 -> 3951;
3952 -> 1640;
3952 -> 1556;
3952 -> 1557;
3952 -> 3937;
3952 -> 1564;
3952 -> 1561;
3953 -> 1576;
3954 -> 3953;
3954 -> 1397;
3955 -> 3954;
3955 -> 1399;
3955 -> 1397;
3956 -> 1595;
3957 -> 3956;
3957 -> 1435;
3958 -> 3957;
3958 -> 1437;
3958 -> 1435;
3959 -> 1433;
3959 -> 1465;
3959 -> 1591;
3959 -> 3958;
3959 -> 1600;
3959 -> 1461;
3959 -> 1462;
3959 -> 3944;
3959 -> 1472;
3959 -> 1464;
3960 -> 1615;
3961 -> 3960;
3961 -> 1484;
3962 -> 3961;
3962 -> 1486;
3962 -> 1484;
3963 -> 1482;
3963 -> 1516;
3963 -> 1611;
3963 -> 3962;
3963 -> 1620;
3963 -> 1510;
3963 -> 1511;
3963 -> 3948;
3963 -> 1518;
3963 -> 1515;
3964 -> 1635;
3965 -> 3964;
3965 -> 1530;
3966 -> 3965;
3966 -> 1532;
3966 -> 1530;
3967 -> 1528;
3967 -> 1562;
3967 -> 1631;
3967 -> 3966;
3967 -> 1640;
3967 -> 1556;
3967 -> 1557;
3967 -> 3952;
3967 -> 1564;
3967 -> 1561;
3968 -> 1576;
3969 -> 3968;
3969 -> 1397;
3970 -> 3969;
3970 -> 1399;
3970 -> 1397;
3971 -> 1595;
3972 -> 3971;
3972 -> 1435;
3973 -> 3972;
3973 -> 1437;
3973 -> 1435;
3974 -> 1433;
3974 -> 1465;
3974 -> 1591;
3974 -> 3973;
3974 -> 1600;
3974 -> 1461;
3974 -> 1462;
3974 -> 3959;
3974 -> 1472;
3974 -> 1464;
3975 -> 1615;
3976 -> 3975;
3976 -> 1484;
3977 -> 3976;
3977 -> 1486;
3977 -> 1484;
3978 -> 1482;
3978 -> 1516;
3978 -> 1611;
3978 -> 3977;
3978 -> 1620;
3978 -> 1510;
3978 -> 1511;
3978 -> 3963;
3978 -> 1518;
3978 -> 1515;
3979 -> 1635;
3980 -> 3979;
3980 -> 1530;
3981 -> 3980;
3981 -> 1532;
3981 -> 1530;
3982 -> 1528;
3982 -> 1562;
3982 -> 1631;
3982 -> 3981;
3982 -> 1640;
3982 -> 1556;
3982 -> 1557;
3982 -> 3967;
3982 -> 1564;
3982 -> 1561;
3983 -> 1576;
3984 -> 3983;
3984 -> 1397;
3985 -> 3984;
3985 -> 1399;
3985 -> 1397;
3986 -> 1595;
3987 -> 3986;
3987 -> 1435;
3988 -> 3987;
3988 -> 1437;
3988 -> 1435;
3989 -> 1433;
3989 -> 1465;
3989 -> 1591;
3989 -> 3988;
3989 -> 1600;
3989 -> 1461;
3989 -> 1462;
3989 -> 3974;
3989 -> 1472;
3989 -> 1464;
3990 -> 1615;
3991 -> 3990;
3991 -> 1484;
3992 -> 3991;
3992 -> 1486;
3992 -> 1484;
3993 -> 1482;
3993 -> 1516;
3993 -> 1611;
3993 -> 3992;
3993 -> 1620;
3993 -> 1510;
3993 -> 1511;
3993 -> 3978;
3993 -> 1518;
3993 -> 1515;
3994 -> 1635;
3995 -> 3994;
3995 -> 1530;
3996 -> 3995;
3996 -> 1532;
3996 -> 1530;
3997 -> 1528;
3997 -> 1562;
3997 -> 1631;
3997 -> 3996;
3997 -> 1640;
3997 -> 1556;
3997 -> 1557;
3997 -> 3982;
3997 -> 1564;
3997 -> 1561;
3998 -> 1576;
3999 -> 3998;
3999 -> 1397;
4000 -> 3999;
4000 -> 1399;
4000 -> 1397;
4001 -> 1595;
4002 -> 4001;
4002 -> 1435;
4003 -> 4002;
4003 -> 1437;
4003 -> 1435;
4004 -> 1433;
4004 -> 1465;
4004 -> 1591;
4004 -> 4003;
4004 -> 1600;
4004 -> 1461;
4004 -> 1462;
4004 -> 3989;
4004 -> 1472;
4004 -> 1464;
4005 -> 1615;
4006 -> 4005;
4006 -> 1484;
4007 -> 4006;
4007 -> 1486;
4007 -> 1484;
4008 -> 1482;
4008 -> 1516;
4008 -> 1611;
4008 -> 4007;
4008 -> 1620;
4008 -> 1510;
4008 -> 1511;
4008 -> 3993;
4008 -> 1518;
4008 -> 1515;
4009 -> 1635;
4010 -> 4009;
4010 -> 1530;
4011 -> 4010;
4011 -> 1532;
4011 -> 1530;
4012 -> 1528;
4012 -> 1562;
4012 -> 1631;
4012 -> 4011;
4012 -> 1640;
4012 -> 1556;
4012 -> 1557;
4012 -> 3997;
4012 -> 1564;
4012 -> 1561;
4013 -> 1576;
4014 -> 4013;
4014 -> 1397;
4015 -> 4014;
4015 -> 1399;
4015 -> 1397;
4016 -> 1595;
4017 -> 4016;
4017 -> 1435;
4018 -> 4017;
4018 -> 1437;
4018 -> 1435;
4019 -> 1433;
4019 -> 1465;
4019 -> 1591;
4019 -> 4018;
4019 -> 1600;
4019 -> 1461;
4019 -> 1462;
4019 -> 4004;
4019 -> 1472;
4019 -> 1464;
4020 -> 1615;
4021 -> 4020;
4021 -> 1484;
4022 -> 4021;
4022 -> 1486;
4022 -> 1484;
4023 -> 1482;
4023 -> 1516;
4023 -> 1611;
4023 -> 4022;
4023 -> 1620;
4023 -> 1510;
4023 -> 1511;
4023 -> 4008;
4023 -> 1518;
4023 -> 1515;
4024 -> 1635;
4025 -> 4024;
4025 -> 1530;
4026 -> 4025;
4026 -> 1532;
4026 -> 1530;
4027 -> 1528;
4027 -> 1562;
4027 -> 1631;
4027 -> 4026;
4027 -> 1640;
4027 -> 1556;
4027 -> 1557;
4027 -> 4012;
4027 -> 1564;
4027 -> 1561;
4028 -> 1576;
4029 -> 4028;
4029 -> 1397;
4030 -> 4029;
4030 -> 1399;
4030 -> 1397;
4031 -> 1595;
4032 -> 4031;
4032 -> 1435;
4033 -> 4032;
4033 -> 1437;
4033 -> 1435;
4034 -> 1433;
4034 -> 1465;
4034 -> 1591;
4034 -> 4033;
4034 -> 1600;
4034 -> 1461;
4034 -> 1462;
4034 -> 4019;
4034 -> 1472;
4034 -> 1464;
4035 -> 1615;
4036 -> 4035;
4036 -> 1484;
4037 -> 4036;
4037 -> 1486;
4037 -> 1484;
4038 -> 1482;
4038 -> 1516;
4038 -> 1611;
4038 -> 4037;
4038 -> 1620;
4038 -> 1510;
4038 -> 1511;
4038 -> 4023;
4038 -> 1518;
4038 -> 1515;
4039 -> 1635;
4040 -> 4039;
4040 -> 1530;
4041 -> 4040;
4041 -> 1532;
4041 -> 1530;
4042 -> 1528;
4042 -> 1562;
4042 -> 1631;
4042 -> 4041;
4042 -> 1640;
4042 -> 1556;
4042 -> 1557;
4042 -> 4027;
4042 -> 1564;
4042 -> 1561;
4043 -> 1576;
4044 -> 4043;
4044 -> 1397;
4045 -> 4044;
4045 -> 1399;
4045 -> 1397;
4046 -> 1595;
4047 -> 4046;
4047 -> 1435;
4048 -> 4047;
4048 -> 1437;
4048 -> 1435;
4049 -> 1433;
4049 -> 1465;
4049 -> 1591;
4049 -> 4048;
4049 -> 1600;
4049 -> 1461;
4049 -> 1462;
4049 -> 4034;
4049 -> 1472;
4049 -> 1464;
4050 -> 1615;
4051 -> 4050;
4051 -> 1484;
4052 -> 4051;
4052 -> 1486;
4052 -> 1484;
4053 -> 1482;
4053 -> 1516;
4053 -> 1611;
4053 -> 4052;
4053 -> 1620;
4053 -> 1510;
4053 -> 1511;
4053 -> 4038;
4053 -> 1518;
4053 -> 1515;
4054 -> 1635;
4055 -> 4054;
4055 -> 1530;
4056 -> 4055;
4056 -> 1532;
4056 -> 1530;
4057 -> 1528;
4057 -> 1562;
4057 -> 1631;
4057 -> 4056;
4057 -> 1640;
4057 -> 1556;
4057 -> 1557;
4057 -> 4042;
4057 -> 1564;
4057 -> 1561;
4058 -> 1576;
4059 -> 4058;
4059 -> 1397;
4060 -> 4059;
4060 -> 1399;
4060 -> 1397;
4061 -> 1595;
4062 -> 4061;
4062 -> 1435;
4063 -> 4062;
4063 -> 1437;
4063 -> 1435;
4064 -> 1433;
4064 -> 1465;
4064 -> 1591;
4064 -> 4063;
4064 -> 1600;
4064 -> 1461;
4064 -> 1462;
4064 -> 4049;
4064 -> 1472;
4064 -> 1464;
4065 -> 1615;
4066 -> 4065;
4066 -> 1484;
4067 -> 4066;
4067 -> 1486;
4067 -> 1484;
4068 -> 1482;
4068 -> 1516;
4068 -> 1611;
4068 -> 4067;
4068 -> 1620;
4068 -> 1510;
4068 -> 1511;
4068 -> 4053;
4068 -> 1518;
4068 -> 1515;
4069 -> 1635;
4070 -> 4069;
4070 -> 1530;
4071 -> 4070;
4071 -> 1532;
4071 -> 1530;
4072 -> 1528;
4072 -> 1562;
4072 -> 1631;
4072 -> 4071;
4072 -> 1640;
4072 -> 1556;
4072 -> 1557;
4072 -> 4057;
4072 -> 1564;
4072 -> 1561;
4073 -> 1576;
4074 -> 4073;
4074 -> 1397;
4075 -> 4074;
4075 -> 1399;
4075 -> 1397;
4076 -> 1595;
4077 -> 4076;
4077 -> 1435;
4078 -> 4077;
4078 -> 1437;
4078 -> 1435;
4079 -> 1433;
4079 -> 1465;
4079 -> 1591;
4079 -> 4078;
4079 -> 1600;
4079 -> 1461;
4079 -> 1462;
4079 -> 4064;
4079 -> 1472;
4079 -> 1464;
4080 -> 1615;
4081 -> 4080;
4081 -> 1484;
4082 -> 4081;
4082 -> 1486;
4082 -> 1484;
4083 -> 1482;
4083 -> 1516;
4083 -> 1611;
4083 -> 4082;
4083 -> 1620;
4083 -> 1510;
4083 -> 1511;
4083 -> 4068;
4083 -> 1518;
4083 -> 1515;
4084 -> 1635;
4085 -> 4084;
4085 -> 1530;
4086 -> 4085;
4086 -> 1532;
4086 -> 1530;
4087 -> 1528;
4087 -> 1562;
4087 -> 1631;
4087 -> 4086;
4087 -> 1640;
4087 -> 1556;
4087 -> 1557;
4087 -> 4072;
4087 -> 1564;
4087 -> 1561;
4088 -> 1576;
4089 -> 4088;
4089 -> 1397;
4090 -> 4089;
4090 -> 1399;
4090 -> 1397;
4091 -> 1595;
4092 -> 4091;
4092 -> 1435;
4093 -> 4092;
4093 -> 1437;
4093 -> 1435;
4094 -> 1433;
4094 -> 1465;
4094 -> 1591;
4094 -> 4093;
4094 -> 1600;
4094 -> 1461;
4094 -> 1462;
4094 -> 4079;
4094 -> 1472;
4094 -> 1464;
4095 -> 1615;
4096 -> 4095;
4096 -> 1484;
4097 -> 4096;
4097 -> 1486;
4097 -> 1484;
4098 -> 1482;
4098 -> 1516;
4098 -> 1611;
4098 -> 4097;
4098 -> 1620;
4098 -> 1510;
4098 -> 1511;
4098 -> 4083;
4098 -> 1518;
4098 -> 1515;
4099 -> 1635;
4100 -> 4099;
4100 -> 1530;
4101 -> 4100;
4101 -> 1532;
4101 -> 1530;
4102 -> 1528;
4102 -> 1562;
4102 -> 1631;
4102 -> 4101;
4102 -> 1640;
4102 -> 1556;
4102 -> 1557;
4102 -> 4087;
4102 -> 1564;
4102 -> 1561;
4103 -> 1576;
4104 -> 4103;
4104 -> 1397;
4105 -> 4104;
4105 -> 1399;
4105 -> 1397;
4106 -> 1595;
4107 -> 4106;
4107 -> 1435;
4108 -> 4107;
4108 -> 1437;
4108 -> 1435;
4109 -> 1433;
4109 -> 1465;
4109 -> 1591;
4109 -> 4108;
4109 -> 1600;
4109 -> 1461;
4109 -> 1462;
4109 -> 4094;
4109 -> 1472;
4109 -> 1464;
4110 -> 1615;
4111 -> 4110;
4111 -> 1484;
4112 -> 4111;
4112 -> 1486;
4112 -> 1484;
4113 -> 1482;
4113 -> 1516;
4113 -> 1611;
4113 -> 4112;
4113 -> 1620;
4113 -> 1510;
4113 -> 1511;
4113 -> 4098;
4113 -> 1518;
4113 -> 1515;
4114 -> 1635;
4115 -> 4114;
4115 -> 1530;
4116 -> 4115;
4116 -> 1532;
4116 -> 1530;
4117 -> 1528;
4117 -> 1562;
4117 -> 1631;
4117 -> 4116;
4117 -> 1640;
4117 -> 1556;
4117 -> 1557;
4117 -> 4102;
4117 -> 1564;
4117 -> 1561;
4118 -> 1576;
4119 -> 4118;
4119 -> 1397;
4120 -> 4119;
4120 -> 1399;
4120 -> 1397;
4121 -> 1595;
4122 -> 4121;
4122 -> 1435;
4123 -> 4122;
4123 -> 1437;
4123 -> 1435;
4124 -> 1433;
4124 -> 1465;
4124 -> 1591;
4124 -> 4123;
4124 -> 1600;
4124 -> 1461;
4124 -> 1462;
4124 -> 4109;
4124 -> 1472;
4124 -> 1464;
4125 -> 1615;
4126 -> 4125;
4126 -> 1484;
4127 -> 4126;
4127 -> 1486;
4127 -> 1484;
4128 -> 1482;
4128 -> 1516;
4128 -> 1611;
4128 -> 4127;
4128 -> 1620;
4128 -> 1510;
4128 -> 1511;
4128 -> 4113;
4128 -> 1518;
4128 -> 1515;
4129 -> 1635;
4130 -> 4129;
4130 -> 1530;
4131 -> 4130;
4131 -> 1532;
4131 -> 1530;
4132 -> 1528;
4132 -> 1562;
4132 -> 1631;
4132 -> 4131;
4132 -> 1640;
4132 -> 1556;
4132 -> 1557;
4132 -> 4117;
4132 -> 1564;
4132 -> 1561;
4133 -> 1576;
4134 -> 4133;
4134 -> 1397;
4135 -> 4134;
4135 -> 1399;
4135 -> 1397;
4136 -> 1595;
4137 -> 4136;
4137 -> 1435;
4138 -> 4137;
4138 -> 1437;
4138 -> 1435;
4139 -> 1433;
4139 -> 1465;
4139 -> 1591;
4139 -> 4138;
4139 -> 1600;
4139 -> 1461;
4139 -> 1462;
4139 -> 4124;
4139 -> 1472;
4139 -> 1464;
4140 -> 1615;
4141 -> 4140;
4141 -> 1484;
4142 -> 4141;
4142 -> 1486;
4142 -> 1484;
4143 -> 1482;
4143 -> 1516;
4143 -> 1611;
4143 -> 4142;
4143 -> 1620;
4143 -> 1510;
4143 -> 1511;
4143 -> 4128;
4143 -> 1518;
4143 -> 1515;
4144 -> 1635;
4145 -> 4144;
4145 -> 1530;
4146 -> 4145;
4146 -> 1532;
4146 -> 1530;
4147 -> 1528;
4147 -> 1562;
4147 -> 1631;
4147 -> 4146;
4147 -> 1640;
4147 -> 1556;
4147 -> 1557;
4147 -> 4132;
4147 -> 1564;
4147 -> 1561;
4148 -> 1576;
4149 -> 4148;
4149 -> 1397;
4150 -> 4149;
4150 -> 1399;
4150 -> 1397;
4151 -> 1595;
4152 -> 4151;
4152 -> 1435;
4153 -> 4152;
4153 -> 1437;
4153 -> 1435;
4154 -> 1433;
4154 -> 1465;
4154 -> 1591;
4154 -> 4153;
4154 -> 1600;
4154 -> 1461;
4154 -> 1462;
4154 -> 4139;
4154 -> 1472;
4154 -> 1464;
4155 -> 1615;
4156 -> 4155;
4156 -> 1484;
4157 -> 4156;
4157 -> 1486;
4157 -> 1484;
4158 -> 1482;
4158 -> 1516;
4158 -> 1611;
4158 -> 4157;
4158 -> 1620;
4158 -> 1510;
4158 -> 1511;
4158 -> 4143;
4158 -> 1518;
4158 -> 1515;
4159 -> 1635;
4160 -> 4159;
4160 -> 1530;
4161 -> 4160;
4161 -> 1532;
4161 -> 1530;
4162 -> 1528;
4162 -> 1562;
4162 -> 1631;
4162 -> 4161;
4162 -> 1640;
4162 -> 1556;
4162 -> 1557;
4162 -> 4147;
4162 -> 1564;
4162 -> 1561;
4163 -> 1576;
4164 -> 4163;
4164 -> 1397;
4165 -> 4164;
4165 -> 1399;
4165 -> 1397;
4166 -> 1595;
4167 -> 4166;
4167 -> 1435;
4168 -> 4167;
4168 -> 1437;
4168 -> 1435;
4169 -> 1433;
4169 -> 1465;
4169 -> 1591;
4169 -> 4168;
4169 -> 1600;
4169 -> 1461;
4169 -> 1462;
4169 -> 4154;
4169 -> 1472;
4169 -> 1464;
4170 -> 1615;
4171 -> 4170;
4171 -> 1484;
4172 -> 4171;
4172 -> 1486;
4172 -> 1484;
4173 -> 1482;
4173 -> 1516;
4173 -> 1611;
4173 -> 4172;
4173 -> 1620;
4173 -> 1510;
4173 -> 1511;
4173 -> 4158;
4173 -> 1518;
4173 -> 1515;
4174 -> 1635;
4175 -> 4174;
4175 -> 1530;
4176 -> 4175;
4176 -> 1532;
4176 -> 1530;
4177 -> 1528;
4177 -> 1562;
4177 -> 1631;
4177 -> 4176;
4177 -> 1640;
4177 -> 1556;
4177 -> 1557;
4177 -> 4162;
4177 -> 1564;
4177 -> 1561;
4178 -> 1576;
4179 -> 4178;
4179 -> 1397;
4180 -> 4179;
4180 -> 1399;
4180 -> 1397;
4181 -> 1595;
4182 -> 4181;
4182 -> 1435;
4183 -> 4182;
4183 -> 1437;
4183 -> 1435;
4184 -> 1433;
4184 -> 1465;
4184 -> 1591;
4184 -> 4183;
4184 -> 1600;
4184 -> 1461;
4184 -> 1462;
4184 -> 4169;
4184 -> 1472;
4184 -> 1464;
4185 -> 1615;
4186 -> 4185;
4186 -> 1484;
4187 -> 4186;
4187 -> 1486;
4187 -> 1484;
4188 -> 1482;
4188 -> 1516;
4188 -> 1611;
4188 -> 4187;
4188 -> 1620;
4188 -> 1510;
4188 -> 1511;
4188 -> 4173;
4188 -> 1518;
4188 -> 1515;
4189 -> 1635;
4190 -> 4189;
4190 -> 1530;
4191 -> 4190;
4191 -> 1532;
4191 -> 1530;
4192 -> 1528;
4192 -> 1562;
4192 -> 1631;
4192 -> 4191;
4192 -> 1640;
4192 -> 1556;
4192 -> 1557;
4192 -> 4177;
4192 -> 1564;
4192 -> 1561;
4193 -> 1576;
4194 -> 4193;
4194 -> 1397;
4195 -> 4194;
4195 -> 1399;
4195 -> 1397;
4196 -> 1595;
4197 -> 4196;
4197 -> 1435;
4198 -> 4197;
4198 -> 1437;
4198 -> 1435;
4199 -> 1433;
4199 -> 1465;
4199 -> 1591;
4199 -> 4198;
4199 -> 1600;
4199 -> 1461;
4199 -> 1462;
4199 -> 4184;
4199 -> 1472;
4199 -> 1464;
4200 -> 1615;
4201 -> 4200;
4201 -> 1484;
4202 -> 4201;
4202 -> 1486;
4202 -> 1484;
4203 -> 1482;
4203 -> 1516;
4203 -> 1611;
4203 -> 4202;
4203 -> 1620;
4203 -> 1510;
4203 -> 1511;
4203 -> 4188;
4203 -> 1518;
4203 -> 1515;
4204 -> 1635;
4205 -> 4204;
4205 -> 1530;
4206 -> 4205;
4206 -> 1532;
4206 -> 1530;
4207 -> 1528;
4207 -> 1562;
4207 -> 1631;
4207 -> 4206;
4207 -> 1640;
4207 -> 1556;
4207 -> 1557;
4207 -> 4192;
4207 -> 1564;
4207 -> 1561;
4208 -> 1576;
4209 -> 4208;
4209 -> 1397;
4210 -> 4209;
4210 -> 1399;
4210 -> 1397;
4211 -> 1595;
4212 -> 4211;
4212 -> 1435;
4213 -> 4212;
4213 -> 1437;
4213 -> 1435;
4214 -> 1433;
4214 -> 1465;
4214 -> 1591;
4214 -> 4213;
4214 -> 1600;
4214 -> 1461;
4214 -> 1462;
4214 -> 4199;
4214 -> 1472;
4214 -> 1464;
4215 -> 1615;
4216 -> 4215;
4216 -> 1484;
4217 -> 4216;
4217 -> 1486;
4217 -> 1484;
4218 -> 1482;
4218 -> 1516;
4218 -> 1611;
4218 -> 4217;
4218 -> 1620;
4218 -> 1510;
4218 -> 1511;
4218 -> 4203;
4218 -> 1518;
4218 -> 1515;
4219 -> 1635;
4220 -> 4219;
4220 -> 1530;
4221 -> 4220;
4221 -> 1532;
4221 -> 1530;
4222 -> 1528;
4222 -> 1562;
4222 -> 1631;
4222 -> 4221;
4222 -> 1640;
4222 -> 1556;
4222 -> 1557;
4222 -> 4207;
4222 -> 1564;
4222 -> 1561;
4223 -> 1576;
4224 -> 4223;
4224 -> 1397;
4225 -> 4224;
4225 -> 1399;
4225 -> 1397;
4226 -> 1595;
4227 -> 4226;
4227 -> 1435;
4228 -> 4227;
4228 -> 1437;
4228 -> 1435;
4229 -> 1433;
4229 -> 1465;
4229 -> 1591;
4229 -> 4228;
4229 -> 1600;
4229 -> 1461;
4229 -> 1462;
4229 -> 4214;
4229 -> 1472;
4229 -> 1464;
4230 -> 1615;
4231 -> 4230;
4231 -> 1484;
4232 -> 4231;
4232 -> 1486;
4232 -> 1484;
4233 -> 1482;
4233 -> 1516;
4233 -> 1611;
4233 -> 4232;
4233 -> 1620;
4233 -> 1510;
4233 -> 1511;
4233 -> 4218;
4233 -> 1518;
4233 -> 1515;
4234 -> 1635;
4235 -> 4234;
4235 -> 1530;
4236 -> 4235;
4236 -> 1532;
4236 -> 1530;
4237 -> 1528;
4237 -> 1562;
4237 -> 1631;
4237 -> 4236;
4237 -> 1640;
4237 -> 1556;
4237 -> 1557;
4237 -> 4222;
4237 -> 1564;
4237 -> 1561;
4238 -> 1576;
4239 -> 4238;
4239 -> 1397;
4240 -> 4239;
4240 -> 1399;
4240 -> 1397;
4241 -> 1595;
4242 -> 4241;
4242 -> 1435;
4243 -> 4242;
4243 -> 1437;
4243 -> 1435;
4244 -> 1433;
4244 -> 1465;
4244 -> 1591;
4244 -> 4243;
4244 -> 1600;
4244 -> 1461;
4244 -> 1462;
4244 -> 4229;
4244 -> 1472;
4244 -> 1464;
4245 -> 1615;
4246 -> 4245;
4246 -> 1484;
4247 -> 4246;
4247 -> 1486;
4247 -> 1484;
4248 -> 1482;
4248 -> 1516;
4248 -> 1611;
4248 -> 4247;
4248 -> 1620;
4248 -> 1510;
4248 -> 1511;
4248 -> 4233;
4248 -> 1518;
4248 -> 1515;
4249 -> 1635;
4250 -> 4249;
4250 -> 1530;
4251 -> 4250;
4251 -> 1532;
4251 -> 1530;
4252 -> 1528;
4252 -> 1562;
4252 -> 1631;
4252 -> 4251;
4252 -> 1640;
4252 -> 1556;
4252 -> 1557;
4252 -> 4237;
4252 -> 1564;
4252 -> 1561;
4253 -> 1576;
4254 -> 4253;
4254 -> 1397;
4255 -> 4254;
4255 -> 1399;
4255 -> 1397;
4256 -> 1595;
4257 -> 4256;
4257 -> 1435;
4258 -> 4257;
4258 -> 1437;
4258 -> 1435;
4259 -> 1433;
4259 -> 1465;
4259 -> 1591;
4259 -> 4258;
4259 -> 1600;
4259 -> 1461;
4259 -> 1462;
4259 -> 4244;
4259 -> 1472;
4259 -> 1464;
4260 -> 1615;
4261 -> 4260;
4261 -> 1484;
4262 -> 4261;
4262 -> 1486;
4262 -> 1484;
4263 -> 1482;
4263 -> 1516;
4263 -> 1611;
4263 -> 4262;
4263 -> 1620;
4263 -> 1510;
4263 -> 1511;
4263 -> 4248;
4263 -> 1518;
4263 -> 1515;
4264 -> 1635;
4265 -> 4264;
4265 -> 1530;
4266 -> 4265;
4266 -> 1532;
4266 -> 1530;
4267 -> 1528;
4267 -> 1562;
4267 -> 1631;
4267 -> 4266;
4267 -> 1640;
4267 -> 1556;
4267 -> 1557;
4267 -> 4252;
4267 -> 1564;
4267 -> 1561;
4268 -> 1576;
4269 -> 4268;
4269 -> 1397;
4270 -> 4269;
4270 -> 1399;
4270 -> 1397;
4271 -> 1595;
4272 -> 4271;
4272 -> 1435;
4273 -> 4272;
4273 -> 1437;
4273 -> 1435;
4274 -> 1433;
4274 -> 1465;
4274 -> 1591;
4274 -> 4273;
4274 -> 1600;
4274 -> 1461;
4274 -> 1462;
4274 -> 4259;
4274 -> 1472;
4274 -> 1464;
4275 -> 1615;
4276 -> 4275;
4276 -> 1484;
4277 -> 4276;
4277 -> 1486;
4277 -> 1484;
4278 -> 1482;
4278 -> 1516;
4278 -> 1611;
4278 -> 4277;
4278 -> 1620;
4278 -> 1510;
4278 -> 1511;
4278 -> 4263;
4278 -> 1518;
4278 -> 1515;
4279 -> 1635;
4280 -> 4279;
4280 -> 1530;
4281 -> 4280;
4281 -> 1532;
4281 -> 1530;
4282 -> 1528;
4282 -> 1562;
4282 -> 1631;
4282 -> 4281;
4282 -> 1640;
4282 -> 1556;
4282 -> 1557;
4282 -> 4267;
4282 -> 1564;
4282 -> 1561;
4283 -> 1576;
4284 -> 4283;
4284 -> 1397;
4285 -> 4284;
4285 -> 1399;
4285 -> 1397;
4286 -> 1595;
4287 -> 4286;
4287 -> 1435;
4288 -> 4287;
4288 -> 1437;
4288 -> 1435;
4289 -> 1433;
4289 -> 1465;
4289 -> 1591;
4289 -> 4288;
4289 -> 1600;
4289 -> 1461;
4289 -> 1462;
4289 -> 4274;
4289 -> 1472;
4289 -> 1464;
4290 -> 1615;
4291 -> 4290;
4291 -> 1484;
4292 -> 4291;
4292 -> 1486;
4292 -> 1484;
4293 -> 1482;
4293 -> 1516;
4293 -> 1611;
4293 -> 4292;
4293 -> 1620;
4293 -> 1510;
4293 -> 1511;
4293 -> 4278;
4293 -> 1518;
4293 -> 1515;
4294 -> 1635;
4295 -> 4294;
4295 -> 1530;
4296 -> 4295;
4296 -> 1532;
4296 -> 1530;
4297 -> 1528;
4297 -> 1562;
4297 -> 1631;
4297 -> 4296;
4297 -> 1640;
4297 -> 1556;
4297 -> 1557;
4297 -> 4282;
4297 -> 1564;
4297 -> 1561;
4298 -> 1576;
4299 -> 4298;
4299 -> 1397;
4300 -> 4299;
4300 -> 1399;
4300 -> 1397;
4301 -> 1595;
4302 -> 4301;
4302 -> 1435;
4303 -> 4302;
4303 -> 1437;
4303 -> 1435;
4304 -> 1433;
4304 -> 1465;
4304 -> 1591;
4304 -> 4303;
4304 -> 1600;
4304 -> 1461;
4304 -> 1462;
4304 -> 4289;
4304 -> 1472;
4304 -> 1464;
4305 -> 1615;
4306 -> 4305;
4306 -> 1484;
4307 -> 4306;
4307 -> 1486;
4307 -> 1484;
4308 -> 1482;
4308 -> 1516;
4308 -> 1611;
4308 -> 4307;
4308 -> 1620;
4308 -> 1510;
4308 -> 1511;
4308 -> 4293;
4308 -> 1518;
4308 -> 1515;
4309 -> 1635;
4310 -> 4309;
4310 -> 1530;
4311 -> 4310;
4311 -> 1532;
4311 -> 1530;
4312 -> 1528;
4312 -> 1562;
4312 -> 1631;
4312 -> 4311;
4312 -> 1640;
4312 -> 1556;
4312 -> 1557;
4312 -> 4297;
4312 -> 1564;
4312 -> 1561;
4313 -> 1576;
4314 -> 4313;
4314 -> 1397;
4315 -> 4314;
4315 -> 1399;
4315 -> 1397;
4316 -> 1595;
4317 -> 4316;
4317 -> 1435;
4318 -> 4317;
4318 -> 1437;
4318 -> 1435;
4319 -> 1433;
4319 -> 1465;
4319 -> 1591;
4319 -> 4318;
4319 -> 1600;
4319 -> 1461;
4319 -> 1462;
4319 -> 4304;
4319 -> 1472;
4319 -> 1464;
4320 -> 1615;
4321 -> 4320;
4321 -> 1484;
4322 -> 4321;
4322 -> 1486;
4322 -> 1484;
4323 -> 1482;
4323 -> 1516;
4323 -> 1611;
4323 -> 4322;
4323 -> 1620;
4323 -> 1510;
4323 -> 1511;
4323 -> 4308;
4323 -> 1518;
4323 -> 1515;
4324 -> 1635;
4325 -> 4324;
4325 -> 1530;
4326 -> 4325;
4326 -> 1532;
4326 -> 1530;
4327 -> 1528;
4327 -> 1562;
4327 -> 1631;
4327 -> 4326;
4327 -> 1640;
4327 -> 1556;
4327 -> 1557;
4327 -> 4312;
4327 -> 1564;
4327 -> 1561;
4328 -> 1576;
4329 -> 4328;
4329 -> 1397;
4330 -> 4329;
4330 -> 1399;
4330 -> 1397;
4331 -> 1595;
4332 -> 4331;
4332 -> 1435;
4333 -> 4332;
4333 -> 1437;
4333 -> 1435;
4334 -> 1433;
4334 -> 1465;
4334 -> 1591;
4334 -> 4333;
4334 -> 1600;
4334 -> 1461;
4334 -> 1462;
4334 -> 4319;
4334 -> 1472;
4334 -> 1464;
4335 -> 1615;
4336 -> 4335;
4336 -> 1484;
4337 -> 4336;
4337 -> 1486;
4337 -> 1484;
4338 -> 1482;
4338 -> 1516;
4338 -> 1611;
4338 -> 4337;
4338 -> 1620;
4338 -> 1510;
4338 -> 1511;
4338 -> 4323;
4338 -> 1518;
4338 -> 1515;
4339 -> 1635;
4340 -> 4339;
4340 -> 1530;
4341 -> 4340;
4341 -> 1532;
4341 -> 1530;
4342 -> 1528;
4342 -> 1562;
4342 -> 1631;
4342 -> 4341;
4342 -> 1640;
4342 -> 1556;
4342 -> 1557;
4342 -> 4327;
4342 -> 1564;
4342 -> 1561;
4343 -> 1576;
4344 -> 4343;
4344 -> 1397;
4345 -> 4344;
4345 -> 1399;
4345 -> 1397;
4346 -> 1595;
4347 -> 4346;
4347 -> 1435;
4348 -> 4347;
4348 -> 1437;
4348 -> 1435;
4349 -> 1433;
4349 -> 1465;
4349 -> 1591;
4349 -> 4348;
4349 -> 1600;
4349 -> 1461;
4349 -> 1462;
4349 -> 4334;
4349 -> 1472;
4349 -> 1464;
4350 -> 1615;
4351 -> 4350;
4351 -> 1484;
4352 -> 4351;
4352 -> 1486;
4352 -> 1484;
4353 -> 1482;
4353 -> 1516;
4353 -> 1611;
4353 -> 4352;
4353 -> 1620;
4353 -> 1510;
4353 -> 1511;
4353 -> 4338;
4353 -> 1518;
4353 -> 1515;
4354 -> 1635;
4355 -> 4354;
4355 -> 1530;
4356 -> 4355;
4356 -> 1532;
4356 -> 1530;
4357 -> 1528;
4357 -> 1562;
4357 -> 1631;
4357 -> 4356;
4357 -> 1640;
4357 -> 1556;
4357 -> 1557;
4357 -> 4342;
4357 -> 1564;
4357 -> 1561;
4358 -> 1576;
4359 -> 4358;
4359 -> 1397;
4360 -> 4359;
4360 -> 1399;
4360 -> 1397;
4361 -> 1595;
4362 -> 4361;
4362 -> 1435;
4363 -> 4362;
4363 -> 1437;
4363 -> 1435;
4364 -> 1433;
4364 -> 1465;
4364 -> 1591;
4364 -> 4363;
4364 -> 1600;
4364 -> 1461;
4364 -> 1462;
4364 -> 4349;
4364 -> 1472;
4364 -> 1464;
4365 -> 1615;
4366 -> 4365;
4366 -> 1484;
4367 -> 4366;
4367 -> 1486;
4367 -> 1484;
4368 -> 1482;
4368 -> 1516;
4368 -> 1611;
4368 -> 4367;
4368 -> 1620;
4368 -> 1510;
4368 -> 1511;
4368 -> 4353;
4368 -> 1518;
4368 -> 1515;
4369 -> 1635;
4370 -> 4369;
4370 -> 1530;
4371 -> 4370;
4371 -> 1532;
4371 -> 1530;
4372 -> 1528;
4372 -> 1562;
4372 -> 1631;
4372 -> 4371;
4372 -> 1640;
4372 -> 1556;
4372 -> 1557;
4372 -> 4357;
4372 -> 1564;
4372 -> 1561;
4373 -> 1576;
4374 -> 4373;
4374 -> 1397;
4375 -> 4374;
4375 -> 1399;
4375 -> 1397;
4376 -> 1595;
4377 -> 4376;
4377 -> 1435;
4378 -> 4377;
4378 -> 1437;
4378 -> 1435;
4379 -> 1433;
4379 -> 1465;
4379 -> 1591;
4379 -> 4378;
4379 -> 1600;
4379 -> 1461;
4379 -> 1462;
4379 -> 4364;
4379 -> 1472;
4379 -> 1464;
4380 -> 1615;
4381 -> 4380;
4381 -> 1484;
4382 -> 4381;
4382 -> 1486;
4382 -> 1484;
4383 -> 1482;
4383 -> 1516;
4383 -> 1611;
4383 -> 4382;
4383 -> 1620;
4383 -> 1510;
4383 -> 1511;
4383 -> 4368;
4383 -> 1518;
4383 -> 1515;
4384 -> 1635;
4385 -> 4384;
4385 -> 1530;
4386 -> 4385;
4386 -> 1532;
4386 -> 1530;
4387 -> 1528;
4387 -> 1562;
4387 -> 1631;
4387 -> 4386;
4387 -> 1640;
4387 -> 1556;
4387 -> 1557;
4387 -> 4372;
4387 -> 1564;
4387 -> 1561;
4388 -> 1576;
4389 -> 4388;
4389 -> 1397;
4390 -> 4389;
4390 -> 1399;
4390 -> 1397;
4391 -> 1595;
4392 -> 4391;
4392 -> 1435;
4393 -> 4392;
4393 -> 1437;
4393 -> 1435;
4394 -> 1433;
4394 -> 1465;
4394 -> 1591;
4394 -> 4393;
4394 -> 1600;
4394 -> 1461;
4394 -> 1462;
4394 -> 4379;
4394 -> 1472;
4394 -> 1464;
4395 -> 1615;
4396 -> 4395;
4396 -> 1484;
4397 -> 4396;
4397 -> 1486;
4397 -> 1484;
4398 -> 1482;
4398 -> 1516;
4398 -> 1611;
4398 -> 4397;
4398 -> 1620;
4398 -> 1510;
4398 -> 1511;
4398 -> 4383;
4398 -> 1518;
4398 -> 1515;
4399 -> 1635;
4400 -> 4399;
4400 -> 1530;
4401 -> 4400;
4401 -> 1532;
4401 -> 1530;
4402 -> 1528;
4402 -> 1562;
4402 -> 1631;
4402 -> 4401;
4402 -> 1640;
4402 -> 1556;
4402 -> 1557;
4402 -> 4387;
4402 -> 1564;
4402 -> 1561;
4403 -> 1576;
4404 -> 4403;
4404 -> 1397;
4405 -> 4404;
4405 -> 1399;
4405 -> 1397;
4406 -> 1595;
4407 -> 4406;
4407 -> 1435;
4408 -> 4407;
4408 -> 1437;
4408 -> 1435;
4409 -> 1433;
4409 -> 1465;
4409 -> 1591;
4409 -> 4408;
4409 -> 1600;
4409 -> 1461;
4409 -> 1462;
4409 -> 4394;
4409 -> 1472;
4409 -> 1464;
4410 -> 1615;
4411 -> 4410;
4411 -> 1484;
4412 -> 4411;
4412 -> 1486;
4412 -> 1484;
4413 -> 1482;
4413 -> 1516;
4413 -> 1611;
4413 -> 4412;
4413 -> 1620;
4413 -> 1510;
4413 -> 1511;
4413 -> 4398;
4413 -> 1518;
4413 -> 1515;
4414 -> 1635;
4415 -> 4414;
4415 -> 1530;
4416 -> 4415;
4416 -> 1532;
4416 -> 1530;
4417 -> 1528;
4417 -> 1562;
4417 -> 1631;
4417 -> 4416;
4417 -> 1640;
4417 -> 1556;
4417 -> 1557;
4417 -> 4402;
4417 -> 1564;
4417 -> 1561;
4418 -> 1576;
4419 -> 4418;
4419 -> 1397;
4420 -> 4419;
4420 -> 1399;
4420 -> 1397;
4421 -> 1595;
4422 -> 4421;
4422 -> 1435;
4423 -> 4422;
4423 -> 1437;
4423 -> 1435;
4424 -> 1433;
4424 -> 1465;
4424 -> 1591;
4424 -> 4423;
4424 -> 1600;
4424 -> 1461;
4424 -> 1462;
4424 -> 4409;
4424 -> 1472;
4424 -> 1464;
4425 -> 1615;
4426 -> 4425;
4426 -> 1484;
4427 -> 4426;
4427 -> 1486;
4427 -> 1484;
4428 -> 1482;
4428 -> 1516;
4428 -> 1611;
4428 -> 4427;
4428 -> 1620;
4428 -> 1510;
4428 -> 1511;
4428 -> 4413;
4428 -> 1518;
4428 -> 1515;
4429 -> 1635;
4430 -> 4429;
4430 -> 1530;
4431 -> 4430;
4431 -> 1532;
4431 -> 1530;
4432 -> 1528;
4432 -> 1562;
4432 -> 1631;
4432 -> 4431;
4432 -> 1640;
4432 -> 1556;
4432 -> 1557;
4432 -> 4417;
4432 -> 1564;
4432 -> 1561;
4433 -> 1576;
4434 -> 4433;
4434 -> 1397;
4435 -> 4434;
4435 -> 1399;
4435 -> 1397;
4436 -> 1595;
4437 -> 4436;
4437 -> 1435;
4438 -> 4437;
4438 -> 1437;
4438 -> 1435;
4439 -> 1433;
4439 -> 1465;
4439 -> 1591;
4439 -> 4438;
4439 -> 1600;
4439 -> 1461;
4439 -> 1462;
4439 -> 4424;
4439 -> 1472;
4439 -> 1464;
4440 -> 1615;
4441 -> 4440;
4441 -> 1484;
4442 -> 4441;
4442 -> 1486;
4442 -> 1484;
4443 -> 1482;
4443 -> 1516;
4443 -> 1611;
4443 -> 4442;
4443 -> 1620;
4443 -> 1510;
4443 -> 1511;
4443 -> 4428;
4443 -> 1518;
4443 -> 1515;
4444 -> 1635;
4445 -> 4444;
4445 -> 1530;
4446 -> 4445;
4446 -> 1532;
4446 -> 1530;
4447 -> 1528;
4447 -> 1562;
4447 -> 1631;
4447 -> 4446;
4447 -> 1640;
4447 -> 1556;
4447 -> 1557;
4447 -> 4432;
4447 -> 1564;
4447 -> 1561;
4448 -> 1576;
4449 -> 4448;
4449 -> 1397;
4450 -> 4449;
4450 -> 1399;
4450 -> 1397;
4451 -> 1595;
4452 -> 4451;
4452 -> 1435;
4453 -> 4452;
4453 -> 1437;
4453 -> 1435;
4454 -> 1433;
4454 -> 1465;
4454 -> 1591;
4454 -> 4453;
4454 -> 1600;
4454 -> 1461;
4454 -> 1462;
4454 -> 4439;
4454 -> 1472;
4454 -> 1464;
4455 -> 1615;
4456 -> 4455;
4456 -> 1484;
4457 -> 4456;
4457 -> 1486;
4457 -> 1484;
4458 -> 1482;
4458 -> 1516;
4458 -> 1611;
4458 -> 4457;
4458 -> 1620;
4458 -> 1510;
4458 -> 1511;
4458 -> 4443;
4458 -> 1518;
4458 -> 1515;
4459 -> 1635;
4460 -> 4459;
4460 -> 1530;
4461 -> 4460;
4461 -> 1532;
4461 -> 1530;
4462 -> 1528;
4462 -> 1562;
4462 -> 1631;
4462 -> 4461;
4462 -> 1640;
4462 -> 1556;
4462 -> 1557;
4462 -> 4447;
4462 -> 1564;
4462 -> 1561;
4463 -> 1576;
4464 -> 4463;
4464 -> 1397;
4465 -> 4464;
4465 -> 1399;
4465 -> 1397;
4466 -> 1595;
4467 -> 4466;
4467 -> 1435;
4468 -> 4467;
4468 -> 1437;
4468 -> 1435;
4469 -> 1433;
4469 -> 1465;
4469 -> 1591;
4469 -> 4468;
4469 -> 1600;
4469 -> 1461;
4469 -> 1462;
4469 -> 4454;
4469 -> 1472;
4469 -> 1464;
4470 -> 1615;
4471 -> 4470;
4471 -> 1484;
4472 -> 4471;
4472 -> 1486;
4472 -> 1484;
4473 -> 1482;
4473 -> 1516;
4473 -> 1611;
4473 -> 4472;
4473 -> 1620;
4473 -> 1510;
4473 -> 1511;
4473 -> 4458;
4473 -> 1518;
4473 -> 1515;
4474 -> 1635;
4475 -> 4474;
4475 -> 1530;
4476 -> 4475;
4476 -> 1532;
4476 -> 1530;
4477 -> 1528;
4477 -> 1562;
4477 -> 1631;
4477 -> 4476;
4477 -> 1640;
4477 -> 1556;
4477 -> 1557;
4477 -> 4462;
4477 -> 1564;
4477 -> 1561;
4478 -> 1576;
4479 -> 4478;
4479 -> 1397;
4480 -> 4479;
4480 -> 1399;
4480 -> 1397;
4481 -> 1595;
4482 -> 4481;
4482 -> 1435;
4483 -> 4482;
4483 -> 1437;
4483 -> 1435;
4484 -> 1433;
4484 -> 1465;
4484 -> 1591;
4484 -> 4483;
4484 -> 1600;
4484 -> 1461;
4484 -> 1462;
4484 -> 4469;
4484 -> 1472;
4484 -> 1464;
4485 -> 1615;
4486 -> 4485;
4486 -> 1484;
4487 -> 4486;
4487 -> 1486;
4487 -> 1484;
4488 -> 1482;
4488 -> 1516;
4488 -> 1611;
4488 -> 4487;
4488 -> 1620;
4488 -> 1510;
4488 -> 1511;
4488 -> 4473;
4488 -> 1518;
4488 -> 1515;
4489 -> 1635;
4490 -> 4489;
4490 -> 1530;
4491 -> 4490;
4491 -> 1532;
4491 -> 1530;
4492 -> 1528;
4492 -> 1562;
4492 -> 1631;
4492 -> 4491;
4492 -> 1640;
4492 -> 1556;
4492 -> 1557;
4492 -> 4477;
4492 -> 1564;
4492 -> 1561;
4493 -> 1576;
4494 -> 4493;
4494 -> 1397;
4495 -> 4494;
4495 -> 1399;
4495 -> 1397;
4496 -> 1595;
4497 -> 4496;
4497 -> 1435;
4498 -> 4497;
4498 -> 1437;
4498 -> 1435;
4499 -> 1433;
4499 -> 1465;
4499 -> 1591;
4499 -> 4498;
4499 -> 1600;
4499 -> 1461;
4499 -> 1462;
4499 -> 4484;
4499 -> 1472;
4499 -> 1464;
4500 -> 1615;
4501 -> 4500;
4501 -> 1484;
4502 -> 4501;
4502 -> 1486;
4502 -> 1484;
4503 -> 1482;
4503 -> 1516;
4503 -> 1611;
4503 -> 4502;
4503 -> 1620;
4503 -> 1510;
4503 -> 1511;
4503 -> 4488;
4503 -> 1518;
4503 -> 1515;
4504 -> 1635;
4505 -> 4504;
4505 -> 1530;
4506 -> 4505;
4506 -> 1532;
4506 -> 1530;
4507 -> 1528;
4507 -> 1562;
4507 -> 1631;
4507 -> 4506;
4507 -> 1640;
4507 -> 1556;
4507 -> 1557;
4507 -> 4492;
4507 -> 1564;
4507 -> 1561;
4508 -> 1576;
4509 -> 4508;
4509 -> 1397;
4510 -> 4509;
4510 -> 1399;
4510 -> 1397;
4511 -> 1595;
4512 -> 4511;
4512 -> 1435;
4513 -> 4512;
4513 -> 1437;
4513 -> 1435;
4514 -> 1433;
4514 -> 1465;
4514 -> 1591;
4514 -> 4513;
4514 -> 1600;
4514 -> 1461;
4514 -> 1462;
4514 -> 4499;
4514 -> 1472;
4514 -> 1464;
4515 -> 1615;
4516 -> 4515;
4516 -> 1484;
4517 -> 4516;
4517 -> 1486;
4517 -> 1484;
4518 -> 1482;
4518 -> 1516;
4518 -> 1611;
4518 -> 4517;
4518 -> 1620;
4518 -> 1510;
4518 -> 1511;
4518 -> 4503;
4518 -> 1518;
4518 -> 1515;
4519 -> 1635;
4520 -> 4519;
4520 -> 1530;
4521 -> 4520;
4521 -> 1532;
4521 -> 1530;
4522 -> 1528;
4522 -> 1562;
4522 -> 1631;
4522 -> 4521;
4522 -> 1640;
4522 -> 1556;
4522 -> 1557;
4522 -> 4507;
4522 -> 1564;
4522 -> 1561;
4523 -> 1576;
4524 -> 4523;
4524 -> 1397;
4525 -> 4524;
4525 -> 1399;
4525 -> 1397;
4526 -> 1595;
4527 -> 4526;
4527 -> 1435;
4528 -> 4527;
4528 -> 1437;
4528 -> 1435;
4529 -> 1433;
4529 -> 1465;
4529 -> 1591;
4529 -> 4528;
4529 -> 1600;
4529 -> 1461;
4529 -> 1462;
4529 -> 4514;
4529 -> 1472;
4529 -> 1464;
4530 -> 1615;
4531 -> 4530;
4531 -> 1484;
4532 -> 4531;
4532 -> 1486;
4532 -> 1484;
4533 -> 1482;
4533 -> 1516;
4533 -> 1611;
4533 -> 4532;
4533 -> 1620;
4533 -> 1510;
4533 -> 1511;
4533 -> 4518;
4533 -> 1518;
4533 -> 1515;
4534 -> 1635;
4535 -> 4534;
4535 -> 1530;
4536 -> 4535;
4536 -> 1532;
4536 -> 1530;
4537 -> 1528;
4537 -> 1562;
4537 -> 1631;
4537 -> 4536;
4537 -> 1640;
4537 -> 1556;
4537 -> 1557;
4537 -> 4522;
4537 -> 1564;
4537 -> 1561;
4538 -> 1576;
4539 -> 4538;
4539 -> 1397;
4540 -> 4539;
4540 -> 1399;
4540 -> 1397;
4541 -> 1595;
4542 -> 4541;
4542 -> 1435;
4543 -> 4542;
4543 -> 1437;
4543 -> 1435;
4544 -> 1433;
4544 -> 1465;
4544 -> 1591;
4544 -> 4543;
4544 -> 1600;
4544 -> 1461;
4544 -> 1462;
4544 -> 4529;
4544 -> 1472;
4544 -> 1464;
4545 -> 1615;
4546 -> 4545;
4546 -> 1484;
4547 -> 4546;
4547 -> 1486;
4547 -> 1484;
4548 -> 1482;
4548 -> 1516;
4548 -> 1611;
4548 -> 4547;
4548 -> 1620;
4548 -> 1510;
4548 -> 1511;
4548 -> 4533;
4548 -> 1518;
4548 -> 1515;
4549 -> 1635;
4550 -> 4549;
4550 -> 1530;
4551 -> 4550;
4551 -> 1532;
4551 -> 1530;
4552 -> 1528;
4552 -> 1562;
4552 -> 1631;
4552 -> 4551;
4552 -> 1640;
4552 -> 1556;
4552 -> 1557;
4552 -> 4537;
4552 -> 1564;
4552 -> 1561;
4553 -> 1576;
4554 -> 4553;
4554 -> 1397;
4555 -> 4554;
4555 -> 1399;
4555 -> 1397;
4556 -> 1595;
4557 -> 4556;
4557 -> 1435;
4558 -> 4557;
4558 -> 1437;
4558 -> 1435;
4559 -> 1433;
4559 -> 1465;
4559 -> 1591;
4559 -> 4558;
4559 -> 1600;
4559 -> 1461;
4559 -> 1462;
4559 -> 4544;
4559 -> 1472;
4559 -> 1464;
4560 -> 1615;
4561 -> 4560;
4561 -> 1484;
4562 -> 4561;
4562 -> 1486;
4562 -> 1484;
4563 -> 1482;
4563 -> 1516;
4563 -> 1611;
4563 -> 4562;
4563 -> 1620;
4563 -> 1510;
4563 -> 1511;
4563 -> 4548;
4563 -> 1518;
4563 -> 1515;
4564 -> 1635;
4565 -> 4564;
4565 -> 1530;
4566 -> 4565;
4566 -> 1532;
4566 -> 1530;
4567 -> 1528;
4567 -> 1562;
4567 -> 1631;
4567 -> 4566;
4567 -> 1640;
4567 -> 1556;
4567 -> 1557;
4567 -> 4552;
4567 -> 1564;
4567 -> 1561;
4568 -> 1576;
4569 -> 4568;
4569 -> 1397;
4570 -> 4569;
4570 -> 1399;
4570 -> 1397;
4571 -> 1595;
4572 -> 4571;
4572 -> 1435;
4573 -> 4572;
4573 -> 1437;
4573 -> 1435;
4574 -> 1433;
4574 -> 1465;
4574 -> 1591;
4574 -> 4573;
4574 -> 1600;
4574 -> 1461;
4574 -> 1462;
4574 -> 4559;
4574 -> 1472;
4574 -> 1464;
4575 -> 1615;
4576 -> 4575;
4576 -> 1484;
4577 -> 4576;
4577 -> 1486;
4577 -> 1484;
4578 -> 1482;
4578 -> 1516;
4578 -> 1611;
4578 -> 4577;
4578 -> 1620;
4578 -> 1510;
4578 -> 1511;
4578 -> 4563;
4578 -> 1518;
4578 -> 1515;
4579 -> 1635;
4580 -> 4579;
4580 -> 1530;
4581 -> 4580;
4581 -> 1532;
4581 -> 1530;
4582 -> 1528;
4582 -> 1562;
4582 -> 1631;
4582 -> 4581;
4582 -> 1640;
4582 -> 1556;
4582 -> 1557;
4582 -> 4567;
4582 -> 1564;
4582 -> 1561;
4583 -> 1576;
4584 -> 4583;
4584 -> 1397;
4585 -> 4584;
4585 -> 1399;
4585 -> 1397;
4586 -> 1595;
4587 -> 4586;
4587 -> 1435;
4588 -> 4587;
4588 -> 1437;
4588 -> 1435;
4589 -> 1433;
4589 -> 1465;
4589 -> 1591;
4589 -> 4588;
4589 -> 1600;
4589 -> 1461;
4589 -> 1462;
4589 -> 4574;
4589 -> 1472;
4589 -> 1464;
4590 -> 1615;
4591 -> 4590;
4591 -> 1484;
4592 -> 4591;
4592 -> 1486;
4592 -> 1484;
4593 -> 1482;
4593 -> 1516;
4593 -> 1611;
4593 -> 4592;
4593 -> 1620;
4593 -> 1510;
4593 -> 1511;
4593 -> 4578;
4593 -> 1518;
4593 -> 1515;
4594 -> 1635;
4595 -> 4594;
4595 -> 1530;
4596 -> 4595;
4596 -> 1532;
4596 -> 1530;
4597 -> 1528;
4597 -> 1562;
4597 -> 1631;
4597 -> 4596;
4597 -> 1640;
4597 -> 1556;
4597 -> 1557;
4597 -> 4582;
4597 -> 1564;
4597 -> 1561;
4598 -> 1576;
4599 -> 4598;
4599 -> 1397;
4600 -> 4599;
4600 -> 1399;
4600 -> 1397;
4601 -> 1595;
4602 -> 4601;
4602 -> 1435;
4603 -> 4602;
4603 -> 1437;
4603 -> 1435;
4604 -> 1433;
4604 -> 1465;
4604 -> 1591;
4604 -> 4603;
4604 -> 1600;
4604 -> 1461;
4604 -> 1462;
4604 -> 4589;
4604 -> 1472;
4604 -> 1464;
4605 -> 1615;
4606 -> 4605;
4606 -> 1484;
4607 -> 4606;
4607 -> 1486;
4607 -> 1484;
4608 -> 1482;
4608 -> 1516;
4608 -> 1611;
4608 -> 4607;
4608 -> 1620;
4608 -> 1510;
4608 -> 1511;
4608 -> 4593;
4608 -> 1518;
4608 -> 1515;
4609 -> 1635;
4610 -> 4609;
4610 -> 1530;
4611 -> 4610;
4611 -> 1532;
4611 -> 1530;
4612 -> 1528;
4612 -> 1562;
4612 -> 1631;
4612 -> 4611;
4612 -> 1640;
4612 -> 1556;
4612 -> 1557;
4612 -> 4597;
4612 -> 1564;
4612 -> 1561;
4613 -> 1576;
4614 -> 4613;
4614 -> 1397;
4615 -> 4614;
4615 -> 1399;
4615 -> 1397;
4616 -> 1595;
4617 -> 4616;
4617 -> 1435;
4618 -> 4617;
4618 -> 1437;
4618 -> 1435;
4619 -> 1433;
4619 -> 1465;
4619 -> 1591;
4619 -> 4618;
4619 -> 1600;
4619 -> 1461;
4619 -> 1462;
4619 -> 4604;
4619 -> 1472;
4619 -> 1464;
4620 -> 1615;
4621 -> 4620;
4621 -> 1484;
4622 -> 4621;
4622 -> 1486;
4622 -> 1484;
4623 -> 1482;
4623 -> 1516;
4623 -> 1611;
4623 -> 4622;
4623 -> 1620;
4623 -> 1510;
4623 -> 1511;
4623 -> 4608;
4623 -> 1518;
4623 -> 1515;
4624 -> 1635;
4625 -> 4624;
4625 -> 1530;
4626 -> 4625;
4626 -> 1532;
4626 -> 1530;
4627 -> 1528;
4627 -> 1562;
4627 -> 1631;
4627 -> 4626;
4627 -> 1640;
4627 -> 1556;
4627 -> 1557;
4627 -> 4612;
4627 -> 1564;
4627 -> 1561;
4628 -> 1576;
4629 -> 4628;
4629 -> 1397;
4630 -> 4629;
4630 -> 1399;
4630 -> 1397;
4631 -> 1595;
4632 -> 4631;
4632 -> 1435;
4633 -> 4632;
4633 -> 1437;
4633 -> 1435;
4634 -> 1433;
4634 -> 1465;
4634 -> 1591;
4634 -> 4633;
4634 -> 1600;
4634 -> 1461;
4634 -> 1462;
4634 -> 4619;
4634 -> 1472;
4634 -> 1464;
4635 -> 1615;
4636 -> 4635;
4636 -> 1484;
4637 -> 4636;
4637 -> 1486;
4637 -> 1484;
4638 -> 1482;
4638 -> 1516;
4638 -> 1611;
4638 -> 4637;
4638 -> 1620;
4638 -> 1510;
4638 -> 1511;
4638 -> 4623;
4638 -> 1518;
4638 -> 1515;
4639 -> 1635;
4640 -> 4639;
4640 -> 1530;
4641 -> 4640;
4641 -> 1532;
4641 -> 1530;
4642 -> 1528;
4642 -> 1562;
4642 -> 1631;
4642 -> 4641;
4642 -> 1640;
4642 -> 1556;
4642 -> 1557;
4642 -> 4627;
4642 -> 1564;
4642 -> 1561;
4643 -> 1576;
4644 -> 4643;
4644 -> 1397;
4645 -> 4644;
4645 -> 1399;
4645 -> 1397;
4646 -> 1595;
4647 -> 4646;
4647 -> 1435;
4648 -> 4647;
4648 -> 1437;
4648 -> 1435;
4649 -> 1433;
4649 -> 1465;
4649 -> 1591;
4649 -> 4648;
4649 -> 1600;
4649 -> 1461;
4649 -> 1462;
4649 -> 4634;
4649 -> 1472;
4649 -> 1464;
4650 -> 1615;
4651 -> 4650;
4651 -> 1484;
4652 -> 4651;
4652 -> 1486;
4652 -> 1484;
4653 -> 1482;
4653 -> 1516;
4653 -> 1611;
4653 -> 4652;
4653 -> 1620;
4653 -> 1510;
4653 -> 1511;
4653 -> 4638;
4653 -> 1518;
4653 -> 1515;
4654 -> 1635;
4655 -> 4654;
4655 -> 1530;
4656 -> 4655;
4656 -> 1532;
4656 -> 1530;
4657 -> 1528;
4657 -> 1562;
4657 -> 1631;
4657 -> 4656;
4657 -> 1640;
4657 -> 1556;
4657 -> 1557;
4657 -> 4642;
4657 -> 1564;
4657 -> 1561;
4658 -> 1576;
4659 -> 4658;
4659 -> 1397;
4660 -> 4659;
4660 -> 1399;
4660 -> 1397;
4661 -> 1595;
4662 -> 4661;
4662 -> 1435;
4663 -> 4662;
4663 -> 1437;
4663 -> 1435;
4664 -> 1433;
4664 -> 1465;
4664 -> 1591;
4664 -> 4663;
4664 -> 1600;
4664 -> 1461;
4664 -> 1462;
4664 -> 4649;
4664 -> 1472;
4664 -> 1464;
4665 -> 1615;
4666 -> 4665;
4666 -> 1484;
4667 -> 4666;
4667 -> 1486;
4667 -> 1484;
4668 -> 1482;
4668 -> 1516;
4668 -> 1611;
4668 -> 4667;
4668 -> 1620;
4668 -> 1510;
4668 -> 1511;
4668 -> 4653;
4668 -> 1518;
4668 -> 1515;
4669 -> 1635;
4670 -> 4669;
4670 -> 1530;
4671 -> 4670;
4671 -> 1532;
4671 -> 1530;
4672 -> 1528;
4672 -> 1562;
4672 -> 1631;
4672 -> 4671;
4672 -> 1640;
4672 -> 1556;
4672 -> 1557;
4672 -> 4657;
4672 -> 1564;
4672 -> 1561;
4673 -> 1576;
4674 -> 4673;
4674 -> 1397;
4675 -> 4674;
4675 -> 1399;
4675 -> 1397;
4676 -> 1595;
4677 -> 4676;
4677 -> 1435;
4678 -> 4677;
4678 -> 1437;
4678 -> 1435;
4679 -> 1433;
4679 -> 1465;
4679 -> 1591;
4679 -> 4678;
4679 -> 1600;
4679 -> 1461;
4679 -> 1462;
4679 -> 4664;
4679 -> 1472;
4679 -> 1464;
4680 -> 1615;
4681 -> 4680;
4681 -> 1484;
4682 -> 4681;
4682 -> 1486;
4682 -> 1484;
4683 -> 1482;
4683 -> 1516;
4683 -> 1611;
4683 -> 4682;
4683 -> 1620;
4683 -> 1510;
4683 -> 1511;
4683 -> 4668;
4683 -> 1518;
4683 -> 1515;
4684 -> 1635;
4685 -> 4684;
4685 -> 1530;
4686 -> 4685;
4686 -> 1532;
4686 -> 1530;
4687 -> 1528;
4687 -> 1562;
4687 -> 1631;
4687 -> 4686;
4687 -> 1640;
4687 -> 1556;
4687 -> 1557;
4687 -> 4672;
4687 -> 1564;
4687 -> 1561;
4688 -> 1576;
4689 -> 4688;
4689 -> 1397;
4690 -> 4689;
4690 -> 1399;
4690 -> 1397;
4691 -> 1595;
4692 -> 4691;
4692 -> 1435;
4693 -> 4692;
4693 -> 1437;
4693 -> 1435;
4694 -> 1433;
4694 -> 1465;
4694 -> 1591;
4694 -> 4693;
4694 -> 1600;
4694 -> 1461;
4694 -> 1462;
4694 -> 4679;
4694 -> 1472;
4694 -> 1464;
4695 -> 1615;
4696 -> 4695;
4696 -> 1484;
4697 -> 4696;
4697 -> 1486;
4697 -> 1484;
4698 -> 1482;
4698 -> 1516;
4698 -> 1611;
4698 -> 4697;
4698 -> 1620;
4698 -> 1510;
4698 -> 1511;
4698 -> 4683;
4698 -> 1518;
4698 -> 1515;
4699 -> 1635;
4700 -> 4699;
4700 -> 1530;
4701 -> 4700;
4701 -> 1532;
4701 -> 1530;
4702 -> 1528;
4702 -> 1562;
4702 -> 1631;
4702 -> 4701;
4702 -> 1640;
4702 -> 1556;
4702 -> 1557;
4702 -> 4687;
4702 -> 1564;
4702 -> 1561;
4703 -> 1576;
4704 -> 4703;
4704 -> 1397;
4705 -> 4704;
4705 -> 1399;
4705 -> 1397;
4706 -> 1595;
4707 -> 4706;
4707 -> 1435;
4708 -> 4707;
4708 -> 1437;
4708 -> 1435;
4709 -> 1433;
4709 -> 1465;
4709 -> 1591;
4709 -> 4708;
4709 -> 1600;
4709 -> 1461;
4709 -> 1462;
4709 -> 4694;
4709 -> 1472;
4709 -> 1464;
4710 -> 1615;
4711 -> 4710;
4711 -> 1484;
4712 -> 4711;
4712 -> 1486;
4712 -> 1484;
4713 -> 1482;
4713 -> 1516;
4713 -> 1611;
4713 -> 4712;
4713 -> 1620;
4713 -> 1510;
4713 -> 1511;
4713 -> 4698;
4713 -> 1518;
4713 -> 1515;
4714 -> 1635;
4715 -> 4714;
4715 -> 1530;
4716 -> 4715;
4716 -> 1532;
4716 -> 1530;
4717 -> 1528;
4717 -> 1562;
4717 -> 1631;
4717 -> 4716;
4717 -> 1640;
4717 -> 1556;
4717 -> 1557;
4717 -> 4702;
4717 -> 1564;
4717 -> 1561;
4718 -> 1576;
4719 -> 4718;
4719 -> 1397;
4720 -> 4719;
4720 -> 1399;
4720 -> 1397;
4721 -> 1595;
4722 -> 4721;
4722 -> 1435;
4723 -> 4722;
4723 -> 1437;
4723 -> 1435;
4724 -> 1433;
4724 -> 1465;
4724 -> 1591;
4724 -> 4723;
4724 -> 1600;
4724 -> 1461;
4724 -> 1462;
4724 -> 4709;
4724 -> 1472;
4724 -> 1464;
4725 -> 1615;
4726 -> 4725;
4726 -> 1484;
4727 -> 4726;
4727 -> 1486;
4727 -> 1484;
4728 -> 1482;
4728 -> 1516;
4728 -> 1611;
4728 -> 4727;
4728 -> 1620;
4728 -> 1510;
4728 -> 1511;
4728 -> 4713;
4728 -> 1518;
4728 -> 1515;
4729 -> 1635;
4730 -> 4729;
4730 -> 1530;
4731 -> 4730;
4731 -> 1532;
4731 -> 1530;
4732 -> 1528;
4732 -> 1562;
4732 -> 1631;
4732 -> 4731;
4732 -> 1640;
4732 -> 1556;
4732 -> 1557;
4732 -> 4717;
4732 -> 1564;
4732 -> 1561;
4733 -> 1576;
4734 -> 4733;
4734 -> 1397;
4735 -> 4734;
4735 -> 1399;
4735 -> 1397;
4736 -> 1595;
4737 -> 4736;
4737 -> 1435;
4738 -> 4737;
4738 -> 1437;
4738 -> 1435;
4739 -> 1433;
4739 -> 1465;
4739 -> 1591;
4739 -> 4738;
4739 -> 1600;
4739 -> 1461;
4739 -> 1462;
4739 -> 4724;
4739 -> 1472;
4739 -> 1464;
4740 -> 1615;
4741 -> 4740;
4741 -> 1484;
4742 -> 4741;
4742 -> 1486;
4742 -> 1484;
4743 -> 1482;
4743 -> 1516;
4743 -> 1611;
4743 -> 4742;
4743 -> 1620;
4743 -> 1510;
4743 -> 1511;
4743 -> 4728;
4743 -> 1518;
4743 -> 1515;
4744 -> 1635;
4745 -> 4744;
4745 -> 1530;
4746 -> 4745;
4746 -> 1532;
4746 -> 1530;
4747 -> 1528;
4747 -> 1562;
4747 -> 1631;
4747 -> 4746;
4747 -> 1640;
4747 -> 1556;
4747 -> 1557;
4747 -> 4732;
4747 -> 1564;
4747 -> 1561;
4748 -> 1576;
4749 -> 4748;
4749 -> 1397;
4750 -> 4749;
4750 -> 1399;
4750 -> 1397;
4751 -> 1595;
4752 -> 4751;
4752 -> 1435;
4753 -> 4752;
4753 -> 1437;
4753 -> 1435;
4754 -> 1433;
4754 -> 1465;
4754 -> 1591;
4754 -> 4753;
4754 -> 1600;
4754 -> 1461;
4754 -> 1462;
4754 -> 4739;
4754 -> 1472;
4754 -> 1464;
4755 -> 1615;
4756 -> 4755;
4756 -> 1484;
4757 -> 4756;
4757 -> 1486;
4757 -> 1484;
4758 -> 1482;
4758 -> 1516;
4758 -> 1611;
4758 -> 4757;
4758 -> 1620;
4758 -> 1510;
4758 -> 1511;
4758 -> 4743;
4758 -> 1518;
4758 -> 1515;
4759 -> 1635;
4760 -> 4759;
4760 -> 1530;
4761 -> 4760;
4761 -> 1532;
4761 -> 1530;
4762 -> 1528;
4762 -> 1562;
4762 -> 1631;
4762 -> 4761;
4762 -> 1640;
4762 -> 1556;
4762 -> 1557;
4762 -> 4747;
4762 -> 1564;
4762 -> 1561;
4763 -> 1576;
4764 -> 4763;
4764 -> 1397;
4765 -> 4764;
4765 -> 1399;
4765 -> 1397;
4766 -> 1595;
4767 -> 4766;
4767 -> 1435;
4768 -> 4767;
4768 -> 1437;
4768 -> 1435;
4769 -> 1433;
4769 -> 1465;
4769 -> 1591;
4769 -> 4768;
4769 -> 1600;
4769 -> 1461;
4769 -> 1462;
4769 -> 4754;
4769 -> 1472;
4769 -> 1464;
4770 -> 1615;
4771 -> 4770;
4771 -> 1484;
4772 -> 4771;
4772 -> 1486;
4772 -> 1484;
4773 -> 1482;
4773 -> 1516;
4773 -> 1611;
4773 -> 4772;
4773 -> 1620;
4773 -> 1510;
4773 -> 1511;
4773 -> 4758;
4773 -> 1518;
4773 -> 1515;
4774 -> 1635;
4775 -> 4774;
4775 -> 1530;
4776 -> 4775;
4776 -> 1532;
4776 -> 1530;
4777 -> 1528;
4777 -> 1562;
4777 -> 1631;
4777 -> 4776;
4777 -> 1640;
4777 -> 1556;
4777 -> 1557;
4777 -> 4762;
4777 -> 1564;
4777 -> 1561;
4778 -> 1576;
4779 -> 4778;
4779 -> 1397;
4780 -> 4779;
4780 -> 1399;
4780 -> 1397;
4781 -> 1595;
4782 -> 4781;
4782 -> 1435;
4783 -> 4782;
4783 -> 1437;
4783 -> 1435;
4784 -> 1433;
4784 -> 1465;
4784 -> 1591;
4784 -> 4783;
4784 -> 1600;
4784 -> 1461;
4784 -> 1462;
4784 -> 4769;
4784 -> 1472;
4784 -> 1464;
4785 -> 1615;
4786 -> 4785;
4786 -> 1484;
4787 -> 4786;
4787 -> 1486;
4787 -> 1484;
4788 -> 1482;
4788 -> 1516;
4788 -> 1611;
4788 -> 4787;
4788 -> 1620;
4788 -> 1510;
4788 -> 1511;
4788 -> 4773;
4788 -> 1518;
4788 -> 1515;
4789 -> 1635;
4790 -> 4789;
4790 -> 1530;
4791 -> 4790;
4791 -> 1532;
4791 -> 1530;
4792 -> 1528;
4792 -> 1562;
4792 -> 1631;
4792 -> 4791;
4792 -> 1640;
4792 -> 1556;
4792 -> 1557;
4792 -> 4777;
4792 -> 1564;
4792 -> 1561;
4793 -> 1371;
4793 -> 1369;
4794 -> 1370;
4794 -> 1369;
4795 -> 1372;
4795 -> 1369;
4796 -> 1369;
4797 -> 4793;
4797 -> 4796;
4798 -> 4794;
4798 -> 4796;
4799 -> 4795;
4799 -> 4796;
4800 -> 4797;
4800 -> 1374;
4800 -> 4796;
4801 -> 4796;
4802 -> 4798;
4802 -> 4801;
4802 -> 4796;
4803 -> 4802;
4804 -> 4799;
4804 -> 4803;
4804 -> 4802;
4805 -> 4799;
4805 -> 408;
4805 -> 4804;
4806 -> 1386;
4806 -> 1385;
4806 -> 4797;
4806 -> 4805;
4807 -> 1350;
4808 -> 1354;
4808 -> 4807;
4808 -> 1350;
4809 -> 4806;
4809 -> 1350;
4810 -> 4809;
4810 -> 1118;
4811 -> 1118;
4812 -> 4810;
4812 -> 4811;
4813 -> 1107;
4813 -> 4811;
4814 -> 4811;
4815 -> 4812;
4815 -> 4814;
4815 -> 4811;
4816 -> 4813;
4816 -> 1078;
4816 -> 1114;
4816 -> 1113;
4816 -> 4811;
4817 -> 4813;
4817 -> 1114;
4817 -> 1113;
4817 -> 1078;
4817 -> 4811;
4818 -> 4812;
4818 -> 4817;
4818 -> 4811;
4819 -> 4813;
4819 -> 1078;
4819 -> 4811;
4820 -> 1118;
4821 -> 1118;
4822 -> 4809;
4822 -> 4821;
4823 -> 4822;
4823 -> 4821;
4824 -> 4823;
4824 -> 1118;
4825 -> 1358;
4826 -> 1358;
4827 -> 4826;
4827 -> 1358;
4828 -> 1358;
4829 -> 1358;
4830 -> 1358;
4831 -> 1358;
4832 -> 1358;
4833 -> 1358;
4834 -> 4828;
4834 -> 1358;
4835 -> 4829;
4835 -> 1358;
4836 -> 4830;
4836 -> 1358;
4837 -> 4831;
4837 -> 1358;
4838 -> 4833;
4838 -> 4827;
4838 -> 4834;
4838 -> 4835;
4838 -> 4836;
4838 -> 4837;
4838 -> 1358;
4839 -> 1358;
4840 -> 4838;
4840 -> 4839;
4840 -> 1358;
4841 -> 4832;
4841 -> 4838;
4841 -> 4840;
4842 -> 4840;
4843 -> 4841;
4843 -> 4842;
4844 -> 4842;
4845 -> 4843;
4845 -> 4841;
4845 -> 4844;
4846 -> 4845;
4846 -> 4842;
4847 -> 4842;
4848 -> 4843;
4848 -> 4841;
4848 -> 4847;
4849 -> 4848;
4849 -> 4842;
4850 -> 4842;
4851 -> 4849;
4851 -> 4850;
4852 -> 4843;
4852 -> 4841;
4852 -> 4850;
4853 -> 4842;
4854 -> 4842;
4855 -> 4843;
4855 -> 4854;
4856 -> 4855;
4856 -> 4841;
4856 -> 4851;
4856 -> 4854;
4857 -> 4854;
4858 -> 4855;
4858 -> 4856;
4858 -> 4857;
4859 -> 4858;
4859 -> 4854;
4860 -> 4854;
4861 -> 4860;
4861 -> 4854;
4862 -> 4854;
4863 -> 4854;
4864 -> 4856;
4864 -> 4854;
4865 -> 4856;
4866 -> 4856;
4866 -> 4854;
4867 -> 4866;
4868 -> 4854;
4869 -> 4856;
4869 -> 4854;
4870 -> 4854;
4871 -> 4869;
4871 -> 4870;
4872 -> 4870;
4873 -> 4870;
4874 -> 4871;
4874 -> 4873;
4874 -> 4870;
4875 -> 4874;
4876 -> 4872;
4876 -> 4870;
4877 -> 4876;
4877 -> 4854;
4878 -> 4854;
4879 -> 4877;
4879 -> 4878;
4880 -> 4855;
4880 -> 4878;
4881 -> 4878;
4882 -> 4880;
4882 -> 4856;
4882 -> 4881;
4882 -> 4878;
4883 -> 4882;
4884 -> 4883;
4884 -> 4854;
4885 -> 4854;
4886 -> 4856;
4886 -> 4854;
4887 -> 4884;
4887 -> 4854;
4888 -> 4855;
4888 -> 4854;
4889 -> 4886;
4889 -> 4856;
4889 -> 0;
4889 -> 4854;
4890 -> 4854;
4891 -> 4886;
4891 -> 4856;
4891 -> 4854;
4892 -> 4886;
4892 -> 4856;
4892 -> 4891;
4893 -> 4886;
4893 -> 4856;
4893 -> 4892;
4894 -> 4892;
4895 -> 4893;
4895 -> 4894;
4896 -> 4895;
4896 -> 0;
4896 -> 4894;
4897 -> 4856;
4897 -> 4892;
4898 -> 4886;
4898 -> 4856;
4898 -> 4892;
4899 -> 4892;
4900 -> 4897;
4900 -> 4899;
4901 -> 4898;
4901 -> 4899;
4902 -> 4897;
4902 -> 4899;
4903 -> 4901;
4903 -> 4899;
4904 -> 4900;
4904 -> 4899;
4905 -> 4902;
4905 -> 4899;
4906 -> 4899;
4907 -> 4903;
4907 -> 4906;
4908 -> 4904;
4908 -> 4906;
4909 -> 4905;
4909 -> 4906;
4910 -> 4907;
4910 -> 1374;
4910 -> 4906;
4911 -> 4906;
4912 -> 4908;
4912 -> 4911;
4912 -> 4906;
4913 -> 4912;
4914 -> 4909;
4914 -> 4913;
4914 -> 4912;
4915 -> 1378;
4915 -> 1377;
4915 -> 4907;
4915 -> 4914;
4916 -> 4854;
4917 -> 4887;
4917 -> 4916;
4917 -> 4854;
4918 -> 4915;
4918 -> 4854;
4919 -> 4918;
4919 -> 4842;
4920 -> 4846;
4920 -> 4919;
4920 -> 4842;
4921 -> 4919;
4921 -> 4842;
4922 -> 4828;
4922 -> 4840;
4923 -> 4829;
4923 -> 4840;
4924 -> 4830;
4924 -> 4840;
4925 -> 4831;
4925 -> 4840;
4926 -> 4921;
4926 -> 4840;
4927 -> 4921;
4927 -> 1358;
4928 -> 1358;
4928 -> 4927;
4928 -> 4926;
4929 -> 4928;
4929 -> 1118;
4930 -> 4929;
4930 -> 4811;
4931 -> 4930;
4931 -> 4814;
4931 -> 4811;
4932 -> 4813;
4932 -> 4819;
4932 -> 1114;
4932 -> 1113;
4932 -> 4811;
4933 -> 4813;
4933 -> 1114;
4933 -> 1113;
4933 -> 4819;
4933 -> 4811;
4934 -> 4930;
4934 -> 4933;
4934 -> 4811;
4935 -> 4928;
4935 -> 4821;
4936 -> 4935;
4936 -> 4928;
4936 -> 4821;
4937 -> 4936;
4937 -> 1118;
4938 -> 4928;
4939 -> 4928;
4940 -> 4939;
4940 -> 4928;
4941 -> 4928;
4942 -> 4941;
4942 -> 4928;
4943 -> 4941;
4943 -> 4928;
4944 -> 4943;
4944 -> 4928;
4945 -> 4928;
4946 -> 4928;
4947 -> 4928;
4948 -> 4928;
4949 -> 4948;
4950 -> 4928;
4951 -> 4941;
4952 -> 4941;
4953 -> 4941;
4953 -> 1018;
4954 -> 0;
4954 -> 4941;
4955 -> 4941;
4956 -> 4955;
4956 -> 4941;
4957 -> 0;
4957 -> 4956;
4958 -> 4941;
4958 -> 4957;
4958 -> 4954;
4959 -> 4958;
4959 -> 0;
4959 -> 4941;
4960 -> 0;
4960 -> 4941;
4960 -> 4959;
4961 -> 0;
4961 -> 4941;
4961 -> 4959;
4962 -> 4941;
4962 -> 4958;
4962 -> 4960;
4962 -> 0;
4963 -> 4941;
4963 -> 4958;
4963 -> 4960;
4963 -> 4961;
4963 -> 4928;
4964 -> 4941;
4964 -> 4928;
4965 -> 4928;
4966 -> 4964;
4966 -> 4965;
4967 -> 4965;
4968 -> 4965;
4969 -> 4966;
4969 -> 4968;
4969 -> 4965;
4970 -> 4969;
4971 -> 4970;
4971 -> 4966;
4971 -> 4963;
4971 -> 4969;
4972 -> 4967;
4972 -> 4965;
4973 -> 4972;
4973 -> 4928;
4974 -> 4928;
4975 -> 4973;
4975 -> 4974;
4976 -> 4928;
4976 -> 4974;
4977 -> 4974;
4978 -> 4976;
4978 -> 4963;
4978 -> 4977;
4978 -> 4974;
4979 -> 4978;
4980 -> 4979;
4980 -> 4928;
4981 -> 4928;
4982 -> 4928;
4983 -> 4982;
4983 -> 4928;
4984 -> 4963;
4984 -> 4928;
4985 -> 4963;
4986 -> 4963;
4986 -> 4928;
4987 -> 4986;
4988 -> 4980;
4988 -> 4928;
4989 -> 4928;
4990 -> 4963;
4990 -> 0;
4990 -> 4928;
4991 -> 4928;
4992 -> 4963;
4992 -> 4991;
4992 -> 4928;
4993 -> 4928;
4994 -> 4963;
4995 -> 4963;
4996 -> 4994;
4996 -> 4995;
4997 -> 4994;
4997 -> 4995;
4998 -> 4994;
4998 -> 4995;
4999 -> 4994;
4999 -> 4995;
5000 -> 4994;
5000 -> 4995;
5001 -> 4996;
5001 -> 4995;
5002 -> 4997;
5002 -> 4995;
5003 -> 4998;
5003 -> 4995;
5004 -> 4999;
5004 -> 4995;
5005 -> 5000;
5005 -> 4995;
5006 -> 4995;
5007 -> 5001;
5007 -> 5006;
5008 -> 5002;
5008 -> 5006;
5009 -> 5003;
5009 -> 5006;
5010 -> 5004;
5010 -> 5006;
5011 -> 5005;
5011 -> 5006;
5012 -> 5007;
5012 -> 0;
5012 -> 5006;
5013 -> 5010;
5013 -> 5009;
5013 -> 5006;
5014 -> 5012;
5014 -> 5013;
5014 -> 5006;
5015 -> 5008;
5015 -> 5014;
5016 -> 5009;
5016 -> 5014;
5017 -> 5011;
5017 -> 5014;
5018 -> 5014;
5019 -> 5015;
5019 -> 5018;
5020 -> 5016;
5020 -> 5018;
5021 -> 5017;
5021 -> 5018;
5022 -> 5018;
5023 -> 5019;
5023 -> 5022;
5023 -> 5018;
5024 -> 5023;
5025 -> 5021;
5025 -> 5024;
5025 -> 5023;
5026 -> 5020;
5026 -> 5025;
5027 -> 5025;
5028 -> 5026;
5028 -> 5027;
5030 -> 5028;
5030 -> 5027;
5031 -> 5027;
5032 -> 5027;
5033 -> 5030;
5033 -> 5032;
5034 -> 5031;
5034 -> 5032;
5035 -> 0;
5035 -> 5032;
5036 -> 5033;
5036 -> 5032;
5037 -> 5032;
5038 -> 5035;
5038 -> 5037;
5039 -> 5036;
5039 -> 5037;
5040 -> 5034;
5040 -> 5037;
5041 -> 5038;
5041 -> 5037;
5042 -> 5039;
5042 -> 5037;
5043 -> 5037;
5044 -> 5041;
5044 -> 5043;
5045 -> 5042;
5045 -> 5043;
5046 -> 5040;
5046 -> 5043;
5047 -> 5044;
5047 -> 5043;
5048 -> 5045;
5048 -> 5043;
5049 -> 5043;
5050 -> 5049;
5050 -> 5047;
5050 -> 5048;
5050 -> 5043;
5051 -> 5049;
5051 -> 5043;
5052 -> 5051;
5052 -> 5050;
5052 -> 5043;
5053 -> 5040;
5053 -> 5052;
5053 -> 0;
5053 -> 5037;
5054 -> 5053;
5054 -> 5040;
5054 -> 5037;
5055 -> 5034;
5055 -> 5032;
5056 -> 5033;
5056 -> 5034;
5056 -> 5032;
5057 -> 5031;
5057 -> 5025;
5058 -> 4928;
5059 -> 4988;
5059 -> 5058;
5059 -> 4928;
5060 -> 4940;
5060 -> 5057;
5060 -> 5052;
5060 -> 4928;
5061 -> 4928;
5061 -> 5057;
5061 -> 4963;
5061 -> 5052;
5061 -> 5054;
5061 -> 5055;
5061 -> 5056;
5062 -> 5061;
5062 -> 1118;
5063 -> 5062;
5063 -> 4811;
5064 -> 5063;
5064 -> 4814;
5064 -> 4811;
5065 -> 5063;
5065 -> 4933;
5065 -> 4811;
5066 -> 5061;
5066 -> 4821;
5067 -> 5066;
5067 -> 5061;
5067 -> 4821;
5068 -> 5067;
5068 -> 1118;
5069 -> 5061;
5070 -> 5061;
5071 -> 5070;
5071 -> 5061;
5072 -> 5061;
5073 -> 5061;
5074 -> 5073;
5074 -> 5061;
5075 -> 5061;
5076 -> 5061;
5077 -> 5061;
5078 -> 5061;
5079 -> 5078;
5080 -> 5061;
5081 -> 5061;
5082 -> 5061;
5083 -> 5081;
5083 -> 5082;
5084 -> 5082;
5085 -> 5082;
5086 -> 5083;
5086 -> 5085;
5086 -> 5082;
5087 -> 5086;
5088 -> 5084;
5088 -> 5082;
5089 -> 5088;
5089 -> 5061;
5090 -> 5061;
5091 -> 5089;
5091 -> 5090;
5092 -> 5061;
5092 -> 5090;
5093 -> 5090;
5094 -> 5092;
5094 -> 5061;
5094 -> 5093;
5094 -> 5090;
5095 -> 5094;
5096 -> 5095;
5096 -> 5061;
5097 -> 5061;
5098 -> 5061;
5099 -> 5097;
5099 -> 5098;
5100 -> 5098;
5101 -> 5099;
5101 -> 5070;
5101 -> 5100;
5101 -> 5098;
5102 -> 5101;
5102 -> 5061;
5103 -> 5061;
5104 -> 5070;
5104 -> 5103;
5104 -> 5061;
5105 -> 5070;
5105 -> 5061;
5106 -> 5070;
5107 -> 5070;
5107 -> 5061;
5108 -> 5107;
5109 -> 5096;
5109 -> 5061;
5110 -> 5061;
5111 -> 5061;
5111 -> 0;
5112 -> 5061;
5113 -> 5061;
5114 -> 5061;
5115 -> 5113;
5115 -> 5114;
5116 -> 5115;
5116 -> 0;
5116 -> 5114;
5117 -> 5070;
5117 -> 1374;
5117 -> 5061;
5118 -> 5070;
5118 -> 408;
5119 -> 1386;
5119 -> 1385;
5119 -> 5070;
5119 -> 5118;
5120 -> 5061;
5121 -> 5109;
5121 -> 5120;
5121 -> 5061;
5122 -> 5071;
5122 -> 5119;
5122 -> 5061;
5123 -> 5119;
5123 -> 1118;
5124 -> 5123;
5124 -> 4811;
5125 -> 5124;
5125 -> 4814;
5125 -> 4811;
5126 -> 5124;
5126 -> 4933;
5126 -> 4811;
5127 -> 5119;
5127 -> 4821;
5128 -> 5127;
5128 -> 5119;
5128 -> 4821;
5129 -> 5128;
5129 -> 1118;
5130 -> 5119;
5131 -> 5119;
5132 -> 5119;
5133 -> 5119;
5134 -> 5133;
5134 -> 5119;
5135 -> 5119;
5136 -> 5119;
5137 -> 5119;
5138 -> 5119;
5139 -> 5138;
5140 -> 5119;
5141 -> 5119;
5142 -> 5119;
5143 -> 5141;
5143 -> 5142;
5144 -> 5142;
5145 -> 5142;
5146 -> 5143;
5146 -> 5145;
5146 -> 5142;
5147 -> 5146;
5148 -> 5144;
5148 -> 5142;
5149 -> 5148;
5149 -> 5119;
5150 -> 5119;
5151 -> 5149;
5151 -> 5150;
5152 -> 5119;
5152 -> 5150;
5153 -> 5150;
5154 -> 5152;
5154 -> 5119;
5154 -> 5153;
5154 -> 5150;
5155 -> 5154;
5156 -> 5155;
5156 -> 5119;
5157 -> 5119;
5158 -> 5119;
5159 -> 5157;
5159 -> 5158;
5160 -> 5158;
5161 -> 5159;
5161 -> 5119;
5161 -> 5160;
5161 -> 5158;
5162 -> 5161;
5162 -> 5119;
5163 -> 5119;
5164 -> 5156;
5164 -> 5119;
5165 -> 5119;
5166 -> 5119;
5166 -> 0;
5167 -> 5119;
5168 -> 5119;
5169 -> 5119;
5170 -> 5168;
5170 -> 5169;
5171 -> 5170;
5171 -> 0;
5171 -> 5169;
5172 -> 5119;
5172 -> 1374;
5173 -> 5119;
5174 -> 5164;
5174 -> 5173;
5174 -> 5119;
5175 -> 5131;
5175 -> 5119;
5176 -> 5119;
5177 -> 5119;
5177 -> 1018;
5178 -> 0;
5178 -> 5119;
5179 -> 5119;
5179 -> 5178;
5180 -> 5178;
5181 -> 5179;
5181 -> 5180;
5182 -> 5181;
5182 -> 5180;
5183 -> 5182;
5184 -> 5119;
5184 -> 5178;
5184 -> 0;
5185 -> 5147;
5185 -> 5143;
5185 -> 5178;
5185 -> 5146;
5186 -> 5152;
5186 -> 5178;
5186 -> 5153;
5186 -> 5150;
5187 -> 5186;
5188 -> 5187;
5188 -> 5119;
5189 -> 5178;
5189 -> 5119;
5190 -> 5178;
5191 -> 5119;
5191 -> 5178;
5192 -> 5178;
5193 -> 5191;
5193 -> 5192;
5194 -> 5192;
5195 -> 5193;
5195 -> 5178;
5195 -> 5194;
5195 -> 5192;
5196 -> 5195;
5196 -> 5178;
5197 -> 5178;
5198 -> 5178;
5199 -> 5178;
5199 -> 5119;
5200 -> 5199;
5201 -> 5188;
5201 -> 5119;
5202 -> 5178;
5202 -> 0;
5202 -> 5119;
5203 -> 5178;
5204 -> 5178;
5205 -> 5203;
5205 -> 5204;
5206 -> 5205;
5206 -> 0;
5206 -> 5204;
5207 -> 5178;
5207 -> 1374;
5208 -> 5201;
5208 -> 5173;
5208 -> 5119;
5209 -> 5131;
5209 -> 5178;
5209 -> 5119;
5210 -> 5178;
5210 -> 1118;
5211 -> 5210;
5211 -> 4811;
5212 -> 5211;
5212 -> 4814;
5212 -> 4811;
5213 -> 5211;
5213 -> 4933;
5213 -> 4811;
5214 -> 5178;
5214 -> 4821;
5215 -> 5214;
5215 -> 5178;
5215 -> 4821;
5216 -> 5215;
5216 -> 1118;
5217 -> 5178;
5218 -> 5178;
5219 -> 5178;
5220 -> 5178;
5221 -> 5220;
5221 -> 5178;
5222 -> 5178;
5223 -> 5178;
5224 -> 5223;
5225 -> 5178;
5226 -> 5178;
5227 -> 5178;
5227 -> 1018;
5228 -> 5178;
5228 -> 0;
5229 -> 5178;
5230 -> 5178;
5231 -> 5229;
5231 -> 5230;
5232 -> 5230;
5233 -> 5230;
5234 -> 5231;
5234 -> 5233;
5234 -> 5230;
5235 -> 5234;
5236 -> 5232;
5236 -> 5230;
5237 -> 5236;
5237 -> 5178;
5238 -> 5178;
5239 -> 5237;
5239 -> 5238;
5240 -> 5178;
5240 -> 5238;
5241 -> 5238;
5242 -> 5240;
5242 -> 5178;
5242 -> 5241;
5242 -> 5238;
5243 -> 5242;
5244 -> 5243;
5244 -> 5178;
5245 -> 5244;
5245 -> 5178;
5246 -> 5178;
5247 -> 5178;
5247 -> 0;
5248 -> 5178;
5249 -> 5178;
5250 -> 5178;
5251 -> 5245;
5251 -> 5250;
5251 -> 5178;
5252 -> 5218;
5252 -> 5178;
5253 -> 5178;
5254 -> 5253;
5254 -> 5192;
5255 -> 5254;
5255 -> 5178;
5255 -> 5194;
5255 -> 5192;
5256 -> 5255;
5256 -> 5178;
5257 -> 5214;
5257 -> 4821;
5258 -> 5257;
5258 -> 1118;
5259 -> 5178;
5260 -> 5259;
5260 -> 5178;
5261 -> 5260;
5262 -> 5261;
5262 -> 5178;
5263 -> 956;
5263 -> 5262;
5264 -> 5263;
5265 -> 5263;
5265 -> 5264;
5266 -> 5264;
5267 -> 5265;
5267 -> 5266;
5268 -> 5266;
5269 -> 5267;
5269 -> 5268;
5269 -> 5266;
5270 -> 5267;
5270 -> 5266;
5271 -> 5263;
5271 -> 5269;
5272 -> 5269;
5273 -> 5271;
5273 -> 5272;
5274 -> 5272;
5275 -> 5273;
5275 -> 5274;
5275 -> 5272;
5276 -> 5263;
5276 -> 5178;
5277 -> 5276;
5278 -> 5259;
5278 -> 5178;
5279 -> 5259;
5279 -> 5178;
5280 -> 5279;
5280 -> 5178;
5281 -> 5259;
5282 -> 5259;
5283 -> 5282;
5284 -> 5283;
5284 -> 5259;
5285 -> 956;
5285 -> 5284;
5286 -> 5259;
5287 -> 5286;
5287 -> 5285;
5287 -> 5259;
5288 -> 5259;
5289 -> 5286;
5289 -> 5288;
5290 -> 5289;
5290 -> 5285;
5290 -> 5288;
5291 -> 5290;
5291 -> 5259;
5292 -> 0;
5294 -> 5292;
5294 -> 5293;
5295 -> 5293;
5296 -> 5294;
5296 -> 5295;
5296 -> 5293;
5297 -> 5293;
5300 -> 5298;
5300 -> 5299;
5301 -> 5299;
5302 -> 5300;
5302 -> 5301;
5302 -> 5299;
5303 -> 5299;
5304 -> 5259;
5305 -> 5304;
5305 -> 5291;
5305 -> 5259;
5306 -> 5259;
5307 -> 5305;
5307 -> 5306;
5308 -> 5307;
5308 -> 5306;
5309 -> 5306;
5310 -> 5308;
5310 -> 5309;
5310 -> 5306;
5311 -> 5308;
5311 -> 5306;
5312 -> 5259;
5313 -> 5311;
5313 -> 5312;
5313 -> 5259;
5314 -> 5259;
5315 -> 5314;
5315 -> 5313;
5315 -> 5259;
5316 -> 5259;
5317 -> 5315;
5317 -> 5316;
5318 -> 5316;
5319 -> 5317;
5319 -> 5318;
5319 -> 5316;
5320 -> 5259;
5321 -> 5317;
5321 -> 5320;
5321 -> 5259;
5322 -> 5259;
5322 -> 5178;
5323 -> 5322;
5323 -> 5230;
5324 -> 5323;
5324 -> 5233;
5324 -> 5230;
5325 -> 5324;
5326 -> 5325;
5326 -> 5323;
5326 -> 5321;
5326 -> 5324;
5327 -> 5240;
5327 -> 5321;
5327 -> 5241;
5327 -> 5238;
5328 -> 5327;
5329 -> 5328;
5329 -> 5178;
5330 -> 5321;
5331 -> 5321;
5331 -> 5330;
5332 -> 5330;
5333 -> 5331;
5333 -> 5332;
5334 -> 5332;
5335 -> 5333;
5335 -> 5334;
5335 -> 5332;
5336 -> 5333;
5336 -> 5332;
5337 -> 5321;
5337 -> 5335;
5338 -> 5335;
5339 -> 5337;
5339 -> 5338;
5340 -> 5338;
5341 -> 5339;
5341 -> 5340;
5341 -> 5338;
5342 -> 5321;
5342 -> 5178;
5343 -> 5342;
5344 -> 5329;
5344 -> 5178;
5345 -> 5321;
5345 -> 0;
5345 -> 5178;
5346 -> 5321;
5347 -> 5321;
5348 -> 5346;
5348 -> 5347;
5349 -> 5346;
5349 -> 5347;
5350 -> 5346;
5350 -> 5347;
5351 -> 5349;
5351 -> 1374;
5351 -> 5347;
5352 -> 5344;
5352 -> 5250;
5352 -> 5178;
5353 -> 5349;
5353 -> 1118;
5354 -> 5353;
5354 -> 4811;
5355 -> 5354;
5355 -> 4814;
5355 -> 4811;
5356 -> 5354;
5356 -> 4933;
5356 -> 4811;
5357 -> 5349;
5357 -> 4821;
5358 -> 5357;
5358 -> 4821;
5359 -> 5358;
5359 -> 1118;
5360 -> 1105;
5361 -> 1042;
5362 -> 5361;
5362 -> 1048;
5362 -> 1042;
5363 -> 1048;
5363 -> 1042;
5364 -> 1048;
5364 -> 1042;
5365 -> 1048;
5365 -> 1042;
5366 -> 1048;
5366 -> 1042;
5367 -> 1048;
5367 -> 1042;
5368 -> 1048;
5368 -> 1042;
5369 -> 1042;
5370 -> 5369;
5370 -> 1048;
5370 -> 1042;
5371 -> 1048;
5371 -> 5370;
5371 -> 1042;
5372 -> 1042;
5373 -> 5372;
5373 -> 1048;
5373 -> 1042;
5374 -> 1041;
5374 -> 890;
5375 -> 890;
5376 -> 5374;
5376 -> 5375;
5377 -> 5376;
5377 -> 5375;
5378 -> 0;
5378 -> 5375;
5379 -> 5375;
5380 -> 5377;
5380 -> 5379;
5381 -> 5378;
5381 -> 5379;
5382 -> 5376;
5382 -> 5379;
5383 -> 5379;
5384 -> 5382;
5384 -> 5365;
5384 -> 5383;
5384 -> 5379;
5385 -> 5380;
5385 -> 5377;
5385 -> 1082;
5385 -> 1090;
5385 -> 1084;
5385 -> 1083;
5385 -> 1073;
5385 -> 1114;
5385 -> 1075;
5385 -> 1076;
5385 -> 1077;
5385 -> 4819;
5385 -> 1079;
5385 -> 1080;
5385 -> 1081;
5385 -> 1085;
5385 -> 1087;
5385 -> 1097;
5385 -> 5362;
5385 -> 5370;
5385 -> 5373;
5385 -> 5365;
5385 -> 5366;
5385 -> 5367;
5385 -> 5368;
5385 -> 5321;
5385 -> 1041;
5385 -> 1086;
5385 -> 1096;
5385 -> 1113;
5385 -> 5361;
5385 -> 5371;
5385 -> 5379;
5386 -> 5379;
5387 -> 5385;
5387 -> 5386;
5388 -> 5386;
5389 -> 5387;
5389 -> 5388;
5390 -> 5389;
5390 -> 5385;
5390 -> 5388;
5391 -> 5389;
5391 -> 5390;
5391 -> 5388;
5392 -> 5389;
5392 -> 5390;
5392 -> 0;
5392 -> 5388;
5393 -> 5392;
5393 -> 5389;
5393 -> 5388;
5394 -> 5388;
5395 -> 5389;
5395 -> 5394;
5396 -> 5394;
5397 -> 5395;
5397 -> 5396;
5398 -> 5396;
5399 -> 5397;
5399 -> 5398;
5400 -> 5399;
5400 -> 5390;
5400 -> 5398;
5401 -> 5398;
5402 -> 5399;
5402 -> 5390;
5402 -> 5401;
5402 -> 5398;
5403 -> 5399;
5403 -> 5390;
5403 -> 5393;
5403 -> 5402;
5404 -> 5403;
5404 -> 5396;
5405 -> 5404;
5405 -> 5397;
5405 -> 5396;
5406 -> 5405;
5406 -> 5394;
5407 -> 5394;
5408 -> 5406;
5408 -> 5407;
5409 -> 5408;
5409 -> 5390;
5409 -> 5407;
5410 -> 5409;
5410 -> 5388;
5411 -> 5391;
5411 -> 5389;
5411 -> 5388;
5412 -> 5390;
5412 -> 5393;
5412 -> 5411;
5412 -> 5405;
5412 -> 5388;
5413 -> 5390;
5413 -> 5388;
5414 -> 5389;
5414 -> 5412;
5414 -> 5413;
5414 -> 5388;
5415 -> 5386;
5416 -> 5415;
5416 -> 5386;
5417 -> 5386;
5418 -> 5412;
5418 -> 5417;
5419 -> 5416;
5419 -> 5417;
5420 -> 5387;
5420 -> 5417;
5421 -> 5418;
5421 -> 5417;
5422 -> 5419;
5422 -> 5417;
5423 -> 5417;
5424 -> 5421;
5424 -> 5423;
5425 -> 5422;
5425 -> 5423;
5426 -> 5420;
5426 -> 5423;
5427 -> 5423;
5428 -> 5426;
5428 -> 5427;
5429 -> 5427;
5430 -> 5428;
5430 -> 5429;
5431 -> 5430;
5431 -> 5414;
5431 -> 5429;
5432 -> 5431;
5432 -> 5427;
5433 -> 5432;
5434 -> 5433;
5434 -> 5423;
5435 -> 5434;
5435 -> 5417;
5436 -> 5417;
5437 -> 5420;
5437 -> 5436;
5438 -> 5436;
5439 -> 5437;
5439 -> 5438;
5440 -> 5438;
5441 -> 5439;
5441 -> 5440;
5442 -> 5441;
5442 -> 5414;
5442 -> 5440;
5443 -> 5442;
5443 -> 5438;
5444 -> 5438;
5445 -> 5439;
5445 -> 5414;
5445 -> 5444;
5445 -> 5438;
5446 -> 5443;
5446 -> 5439;
5446 -> 5445;
5447 -> 5439;
5447 -> 5414;
5447 -> 5438;
5448 -> 5439;
5448 -> 5414;
5448 -> 5447;
5448 -> 5438;
5449 -> 5439;
5449 -> 5414;
5449 -> 5438;
5450 -> 5443;
5450 -> 5438;
5451 -> 5448;
5451 -> 5449;
5451 -> 5450;
5451 -> 5414;
5451 -> 5446;
5451 -> 5447;
5451 -> 5438;
5452 -> 5451;
5452 -> 5436;
5453 -> 5437;
5453 -> 5451;
5453 -> 5436;
5454 -> 5436;
5455 -> 5436;
5456 -> 5452;
5456 -> 5455;
5457 -> 5453;
5457 -> 5455;
5458 -> 5453;
5458 -> 5455;
5459 -> 5453;
5459 -> 5455;
5460 -> 5453;
5460 -> 5455;
5461 -> 5454;
5461 -> 5455;
5462 -> 5456;
5462 -> 5461;
5462 -> 5455;
5463 -> 5457;
5463 -> 5461;
5463 -> 5455;
5464 -> 5458;
5464 -> 5461;
5464 -> 5455;
5465 -> 5459;
5465 -> 5461;
5465 -> 5455;
5466 -> 5460;
5466 -> 5461;
5466 -> 5455;
5467 -> 5454;
5467 -> 5417;
5468 -> 5420;
5468 -> 5451;
5468 -> 5417;
5469 -> 5420;
5469 -> 5451;
5469 -> 5468;
5469 -> 5417;
5470 -> 5417;
5471 -> 5417;
5472 -> 5420;
5472 -> 5471;
5473 -> 5472;
5473 -> 5451;
5473 -> 5471;
5474 -> 5473;
5474 -> 5417;
5475 -> 5417;
5476 -> 5474;
5476 -> 5475;
5477 -> 5476;
5477 -> 5451;
5477 -> 5475;
5478 -> 5418;
5478 -> 5477;
5479 -> 5477;
5480 -> 5478;
5480 -> 5479;
5481 -> 5420;
5481 -> 5479;
5482 -> 5479;
5483 -> 5481;
5483 -> 5482;
5484 -> 5483;
5484 -> 5479;
5485 -> 5479;
5486 -> 5484;
5486 -> 5485;
5487 -> 0;
5487 -> 5479;
5488 -> 5479;
5489 -> 5487;
5489 -> 5488;
5490 -> 5481;
5490 -> 5488;
5491 -> 5489;
5491 -> 5488;
5492 -> 5488;
5493 -> 5491;
5493 -> 5492;
5494 -> 5493;
5494 -> 0;
5494 -> 5492;
5495 -> 5494;
5496 -> 5488;
5497 -> 5490;
5497 -> 5496;
5498 -> 5497;
5498 -> 5488;
5499 -> 5488;
5500 -> 5498;
5500 -> 5499;
5501 -> 5500;
5501 -> 5488;
5502 -> 5501;
5502 -> 5489;
5502 -> 5488;
5503 -> 5502;
5504 -> 5490;
5504 -> 5503;
5505 -> 5503;
5506 -> 5504;
5506 -> 5451;
5506 -> 5505;
5507 -> 5506;
5507 -> 5451;
5507 -> 5505;
5508 -> 5507;
5508 -> 5503;
5509 -> 5508;
5509 -> 5504;
5509 -> 5503;
5510 -> 5503;
5511 -> 5510;
5511 -> 5504;
5511 -> 5503;
5512 -> 5503;
5513 -> 5504;
5513 -> 5451;
5513 -> 5512;
5513 -> 5503;
5514 -> 5504;
5514 -> 5451;
5514 -> 5503;
5515 -> 5502;
5516 -> 5498;
5516 -> 5502;
5517 -> 5479;
5518 -> 5481;
5518 -> 5517;
5519 -> 0;
5519 -> 5517;
5520 -> 5517;
5521 -> 5519;
5521 -> 5520;
5522 -> 5518;
5522 -> 5520;
5523 -> 5522;
5523 -> 5451;
5523 -> 5468;
5523 -> 5520;
5524 -> 5522;
5524 -> 5451;
5524 -> 5468;
5524 -> 5523;
5524 -> 5520;
5525 -> 5521;
5525 -> 5520;
5526 -> 5520;
5527 -> 5525;
5527 -> 5526;
5528 -> 5522;
5528 -> 5526;
5529 -> 5526;
5530 -> 5526;
5531 -> 5526;
5532 -> 5528;
5532 -> 5531;
5533 -> 5532;
5533 -> 5451;
5533 -> 5514;
5533 -> 5531;
5534 -> 5532;
5534 -> 5451;
5534 -> 5468;
5534 -> 5523;
5534 -> 5509;
5534 -> 5511;
5534 -> 5514;
5535 -> 5534;
5535 -> 5526;
5536 -> 5526;
5537 -> 5535;
5537 -> 5536;
5538 -> 5537;
5538 -> 5526;
5539 -> 5526;
5540 -> 5538;
5540 -> 5539;
5541 -> 5540;
5541 -> 5539;
5542 -> 5541;
5543 -> 5537;
5543 -> 5526;
5544 -> 5526;
5545 -> 5543;
5545 -> 5544;
5546 -> 5545;
5546 -> 5544;
5547 -> 5544;
5548 -> 5546;
5548 -> 5547;
5549 -> 5548;
5549 -> 5547;
5550 -> 5547;
5551 -> 5549;
5551 -> 5550;
5552 -> 5551;
5552 -> 5550;
5553 -> 0;
5553 -> 5552;
5554 -> 5537;
5554 -> 0;
5554 -> 5553;
5555 -> 5554;
5556 -> 5528;
5556 -> 5555;
5557 -> 5555;
5558 -> 5556;
5558 -> 5557;
5559 -> 5558;
5559 -> 5555;
5560 -> 5555;
5561 -> 5559;
5561 -> 5560;
5562 -> 5560;
5563 -> 5561;
5563 -> 5562;
5564 -> 5563;
5564 -> 5560;
5565 -> 5555;
5566 -> 5565;
5566 -> 5554;
5567 -> 5566;
5568 -> 5566;
5569 -> 5567;
5569 -> 5568;
5570 -> 5567;
5570 -> 5568;
5571 -> 5528;
5571 -> 5568;
5572 -> 5568;
5573 -> 5571;
5573 -> 5572;
5574 -> 5573;
5574 -> 5568;
5575 -> 5568;
5576 -> 5574;
5576 -> 5575;
5577 -> 5575;
5578 -> 5576;
5578 -> 5577;
5579 -> 5578;
5579 -> 5575;
5580 -> 5568;
5581 -> 5580;
5581 -> 5566;
5582 -> 5581;
5583 -> 5582;
5583 -> 5581;
5584 -> 5581;
5585 -> 5583;
5585 -> 5584;
5586 -> 5584;
5587 -> 5585;
5587 -> 5586;
5588 -> 5587;
5588 -> 5584;
5589 -> 5537;
5589 -> 0;
5589 -> 5588;
5590 -> 5527;
5590 -> 5589;
5591 -> 5589;
5592 -> 5590;
5592 -> 5591;
5593 -> 5528;
5593 -> 5591;
5594 -> 5592;
5594 -> 0;
5594 -> 5591;
5595 -> 5591;
5596 -> 5593;
5596 -> 5595;
5597 -> 5596;
5597 -> 5591;
5598 -> 5591;
5599 -> 5597;
5599 -> 5598;
5600 -> 5598;
5601 -> 5599;
5601 -> 5600;
5602 -> 5601;
5602 -> 5598;
5603 -> 5591;
5604 -> 5593;
5604 -> 5603;
5605 -> 5604;
5605 -> 5591;
5606 -> 5591;
5607 -> 5605;
5607 -> 5606;
5608 -> 5591;
5609 -> 5607;
5609 -> 5608;
5610 -> 5609;
5610 -> 5608;
5611 -> 5608;
5612 -> 5610;
5612 -> 5611;
5613 -> 5612;
5613 -> 5611;
5614 -> 5613;
5615 -> 5602;
5615 -> 5614;
5615 -> 5591;
5616 -> 5594;
5616 -> 5615;
5616 -> 5591;
5617 -> 5616;
5618 -> 5527;
5618 -> 5617;
5619 -> 5617;
5620 -> 5618;
5620 -> 5619;
5621 -> 5528;
5621 -> 5619;
5622 -> 5620;
5622 -> 5619;
5623 -> 5619;
5624 -> 5622;
5624 -> 5623;
5625 -> 5621;
5625 -> 5623;
5626 -> 5623;
5627 -> 5625;
5627 -> 5626;
5628 -> 5627;
5628 -> 5623;
5629 -> 5623;
5630 -> 5628;
5630 -> 5629;
5631 -> 5630;
5631 -> 5623;
5632 -> 5624;
5632 -> 5631;
5633 -> 5631;
5634 -> 5632;
5634 -> 5633;
5635 -> 5625;
5635 -> 5633;
5636 -> 5633;
5637 -> 5635;
5637 -> 5636;
5638 -> 5637;
5638 -> 5633;
5639 -> 5633;
5640 -> 5638;
5640 -> 5639;
5641 -> 5633;
5642 -> 5635;
5642 -> 5641;
5643 -> 5642;
5643 -> 5641;
5644 -> 5641;
5645 -> 5641;
5646 -> 5643;
5646 -> 5645;
5647 -> 5643;
5647 -> 5645;
5648 -> 5643;
5648 -> 5645;
5649 -> 5643;
5649 -> 5645;
5650 -> 5643;
5650 -> 5645;
5651 -> 5644;
5651 -> 5645;
5652 -> 5646;
5652 -> 5651;
5652 -> 5645;
5653 -> 5647;
5653 -> 5651;
5653 -> 5645;
5654 -> 5648;
5654 -> 5651;
5654 -> 5645;
5655 -> 5649;
5655 -> 5651;
5655 -> 5645;
5656 -> 5650;
5656 -> 5651;
5656 -> 5645;
5657 -> 5644;
5657 -> 5633;
5658 -> 5634;
5658 -> 5633;
5659 -> 5633;
5660 -> 5658;
5660 -> 5659;
5661 -> 5635;
5661 -> 5659;
5662 -> 5660;
5662 -> 0;
5662 -> 5659;
5663 -> 5659;
5664 -> 5659;
5665 -> 5663;
5665 -> 5664;
5666 -> 5661;
5666 -> 5664;
5667 -> 5664;
5668 -> 5665;
5668 -> 5667;
5668 -> 5664;
5669 -> 5666;
5669 -> 5642;
5669 -> 5665;
5669 -> 5664;
5670 -> 5664;
5671 -> 5666;
5671 -> 5642;
5671 -> 5670;
5671 -> 5664;
5672 -> 5666;
5672 -> 5642;
5672 -> 5665;
5672 -> 5671;
5673 -> 5659;
5674 -> 5672;
5674 -> 5673;
5675 -> 5659;
5676 -> 5661;
5676 -> 5675;
5677 -> 5676;
5677 -> 5642;
5677 -> 5675;
5678 -> 5677;
5678 -> 5659;
5679 -> 5674;
5679 -> 5678;
5679 -> 5659;
5680 -> 5659;
5681 -> 5663;
5681 -> 5680;
5682 -> 5661;
5682 -> 5680;
5683 -> 5680;
5684 -> 5681;
5684 -> 5683;
5684 -> 5680;
5685 -> 5682;
5685 -> 5642;
5685 -> 5681;
5685 -> 5680;
5686 -> 5680;
5687 -> 5682;
5687 -> 5642;
5687 -> 5686;
5687 -> 5680;
5688 -> 5682;
5688 -> 5642;
5688 -> 5681;
5688 -> 5687;
5689 -> 5659;
5690 -> 5688;
5690 -> 5689;
5691 -> 5679;
5691 -> 5690;
5691 -> 5659;
5692 -> 5659;
5693 -> 5659;
5694 -> 5692;
5694 -> 5693;
5695 -> 5661;
5695 -> 5693;
5696 -> 5693;
5697 -> 5694;
5697 -> 5696;
5697 -> 5693;
5698 -> 5695;
5698 -> 5642;
5698 -> 5694;
5698 -> 5693;
5699 -> 5693;
5700 -> 5695;
5700 -> 5642;
5700 -> 5699;
5700 -> 5693;
5701 -> 5695;
5701 -> 5642;
5701 -> 5694;
5701 -> 5700;
5702 -> 5659;
5703 -> 5701;
5703 -> 5702;
5704 -> 5661;
5704 -> 5702;
5705 -> 5702;
5706 -> 5703;
5706 -> 5705;
5707 -> 5706;
5707 -> 5702;
5708 -> 5702;
5709 -> 5704;
5709 -> 5708;
5710 -> 5709;
5710 -> 5642;
5710 -> 5708;
5711 -> 5710;
5711 -> 5702;
5712 -> 5707;
5712 -> 5711;
5712 -> 5702;
5713 -> 5659;
5714 -> 5692;
5714 -> 5713;
5715 -> 5661;
5715 -> 5713;
5716 -> 5713;
5717 -> 5714;
5717 -> 5716;
5717 -> 5713;
5718 -> 5715;
5718 -> 5642;
5718 -> 5714;
5718 -> 5713;
5719 -> 5713;
5720 -> 5715;
5720 -> 5642;
5720 -> 5719;
5720 -> 5713;
5721 -> 5715;
5721 -> 5642;
5721 -> 5714;
5721 -> 5720;
5722 -> 5659;
5723 -> 5721;
5723 -> 5722;
5724 -> 5712;
5724 -> 5723;
5724 -> 5659;
5725 -> 5659;
5726 -> 5692;
5726 -> 5725;
5727 -> 5661;
5727 -> 5725;
5728 -> 5725;
5729 -> 5726;
5729 -> 5728;
5729 -> 5725;
5730 -> 5727;
5730 -> 5642;
5730 -> 5726;
5730 -> 5725;
5731 -> 5725;
5732 -> 5727;
5732 -> 5642;
5732 -> 5731;
5732 -> 5725;
5733 -> 5727;
5733 -> 5642;
5733 -> 5726;
5733 -> 5732;
5734 -> 5659;
5735 -> 5733;
5735 -> 5734;
5736 -> 5724;
5736 -> 5735;
5736 -> 5659;
5737 -> 5659;
5738 -> 5659;
5739 -> 5737;
5739 -> 5738;
5740 -> 5661;
5740 -> 5738;
5741 -> 5738;
5742 -> 5739;
5742 -> 5741;
5742 -> 5738;
5743 -> 5740;
5743 -> 5642;
5743 -> 5739;
5743 -> 5738;
5744 -> 5738;
5745 -> 5740;
5745 -> 5642;
5745 -> 5744;
5745 -> 5738;
5746 -> 5740;
5746 -> 5642;
5746 -> 5739;
5746 -> 5745;
5747 -> 5659;
5748 -> 5746;
5748 -> 5747;
5749 -> 5659;
5750 -> 5659;
5751 -> 5749;
5751 -> 5750;
5752 -> 5661;
5752 -> 5750;
5753 -> 5750;
5754 -> 5751;
5754 -> 5753;
5754 -> 5750;
5755 -> 5752;
5755 -> 5642;
5755 -> 5751;
5755 -> 5750;
5756 -> 5750;
5757 -> 5752;
5757 -> 5642;
5757 -> 5756;
5757 -> 5750;
5758 -> 5752;
5758 -> 5642;
5758 -> 5751;
5758 -> 5757;
5759 -> 5659;
5760 -> 5758;
5760 -> 5759;
5761 -> 5659;
5762 -> 5761;
5762 -> 5633;
5763 -> 5633;
5764 -> 5633;
5765 -> 5763;
5765 -> 5764;
5766 -> 5635;
5766 -> 5764;
5767 -> 5764;
5768 -> 5766;
5768 -> 5767;
5769 -> 5768;
5769 -> 5642;
5769 -> 5767;
5770 -> 5769;
5770 -> 5764;
5771 -> 5764;
5772 -> 5770;
5772 -> 5771;
5773 -> 5764;
5774 -> 5766;
5774 -> 5773;
5775 -> 5773;
5776 -> 5774;
5776 -> 5775;
5777 -> 5776;
5777 -> 5642;
5777 -> 5775;
5778 -> 5777;
5778 -> 5773;
5779 -> 5773;
5780 -> 5774;
5780 -> 5779;
5781 -> 5780;
5781 -> 5642;
5781 -> 5779;
5782 -> 5779;
5783 -> 5782;
5783 -> 5780;
5783 -> 5779;
5784 -> 5779;
5785 -> 5780;
5785 -> 5642;
5785 -> 5784;
5785 -> 5779;
5786 -> 5780;
5786 -> 5642;
5786 -> 5779;
5787 -> 5773;
5788 -> 5778;
5788 -> 5773;
5789 -> 5788;
5789 -> 5764;
5790 -> 5765;
5790 -> 5764;
5791 -> 5764;
5792 -> 5790;
5792 -> 5791;
5793 -> 5766;
5793 -> 5791;
5794 -> 5791;
5795 -> 5792;
5795 -> 5791;
5796 -> 5791;
5797 -> 5794;
5797 -> 5796;
5798 -> 5795;
5798 -> 5796;
5799 -> 5793;
5799 -> 5796;
5800 -> 5798;
5800 -> 5796;
5801 -> 0;
5801 -> 5800;
5802 -> 5797;
5802 -> 5796;
5803 -> 5801;
5803 -> 5802;
5803 -> 5799;
5803 -> 5642;
5803 -> 5783;
5803 -> 5780;
5803 -> 5786;
5803 -> 5796;
5804 -> 5796;
5805 -> 5803;
5805 -> 5804;
5806 -> 5803;
5806 -> 5804;
5807 -> 5803;
5807 -> 5804;
5808 -> 5804;
5809 -> 5806;
5809 -> 5808;
5809 -> 5804;
5810 -> 5807;
5810 -> 5803;
5810 -> 5806;
5810 -> 5804;
5811 -> 5804;
5812 -> 5807;
5812 -> 5803;
5812 -> 5811;
5812 -> 5804;
5813 -> 5807;
5813 -> 5803;
5813 -> 5806;
5813 -> 5812;
5814 -> 5803;
5814 -> 5804;
5815 -> 5803;
5815 -> 5804;
5816 -> 5804;
5817 -> 5815;
5817 -> 5816;
5818 -> 5817;
5818 -> 5813;
5818 -> 5816;
5819 -> 5818;
5819 -> 5804;
5820 -> 5804;
5821 -> 5819;
5821 -> 5820;
5822 -> 5804;
5823 -> 5815;
5823 -> 5822;
5824 -> 5822;
5825 -> 5823;
5825 -> 5824;
5826 -> 5825;
5826 -> 5813;
5826 -> 5824;
5827 -> 5826;
5827 -> 5822;
5828 -> 5822;
5829 -> 5827;
5829 -> 5828;
5830 -> 5829;
5831 -> 5823;
5831 -> 5830;
5832 -> 5830;
5833 -> 5831;
5833 -> 5832;
5834 -> 5833;
5834 -> 5830;
5835 -> 5830;
5836 -> 5834;
5836 -> 5835;
5837 -> 5830;
5838 -> 5837;
5838 -> 5829;
5839 -> 5829;
5840 -> 5823;
5840 -> 5839;
5841 -> 5839;
5842 -> 5840;
5842 -> 5841;
5843 -> 5842;
5843 -> 5813;
5843 -> 5841;
5844 -> 5843;
5844 -> 5839;
5845 -> 5844;
5845 -> 5829;
5846 -> 5838;
5846 -> 5845;
5846 -> 5829;
5847 -> 5829;
5848 -> 5823;
5848 -> 5847;
5849 -> 5847;
5850 -> 5848;
5850 -> 5849;
5851 -> 5850;
5851 -> 5847;
5852 -> 5847;
5853 -> 5851;
5853 -> 5852;
5854 -> 5853;
5854 -> 5829;
5855 -> 5846;
5855 -> 5854;
5855 -> 5829;
5856 -> 5855;
5857 -> 5856;
5857 -> 5804;
5858 -> 5821;
5858 -> 5857;
5858 -> 5804;
5859 -> 5804;
5860 -> 5815;
5860 -> 5859;
5861 -> 5859;
5862 -> 5860;
5862 -> 5861;
5863 -> 5862;
5863 -> 5813;
5863 -> 5861;
5864 -> 5863;
5864 -> 5859;
5865 -> 5859;
5866 -> 5860;
5866 -> 5813;
5866 -> 5865;
5867 -> 5865;
5868 -> 5865;
5869 -> 5860;
5869 -> 5813;
5869 -> 5868;
5869 -> 5865;
5870 -> 5860;
5870 -> 5813;
5870 -> 5865;
5871 -> 5859;
5872 -> 5864;
5872 -> 5859;
5873 -> 5872;
5873 -> 5804;
5874 -> 5804;
5875 -> 5815;
5875 -> 5874;
5876 -> 5875;
5876 -> 5813;
5876 -> 5870;
5876 -> 5874;
5877 -> 5875;
5877 -> 5813;
5877 -> 5874;
5878 -> 5875;
5878 -> 5813;
5878 -> 5860;
5878 -> 5870;
5878 -> 5877;
5879 -> 5878;
5879 -> 5804;
5880 -> 5804;
5881 -> 5879;
5881 -> 5880;
5882 -> 0;
5882 -> 5881;
5883 -> 5873;
5883 -> 5882;
5883 -> 5813;
5883 -> 5860;
5883 -> 5878;
5883 -> 5870;
5883 -> 5796;
5884 -> 5873;
5884 -> 5804;
5885 -> 5804;
5886 -> 5884;
5886 -> 5885;
5887 -> 5886;
5887 -> 5883;
5887 -> 5885;
5888 -> 5887;
5888 -> 5804;
5889 -> 5804;
5890 -> 5888;
5890 -> 5889;
5891 -> 5804;
5892 -> 5884;
5892 -> 5891;
5893 -> 5892;
5893 -> 5883;
5893 -> 5891;
5894 -> 5893;
5894 -> 5804;
5895 -> 5804;
5896 -> 5894;
5896 -> 5895;
5897 -> 5890;
5897 -> 5896;
5897 -> 5804;
5898 -> 5873;
5898 -> 5804;
5899 -> 5873;
5899 -> 5804;
5900 -> 5873;
5900 -> 5804;
5901 -> 5804;
5902 -> 5900;
5902 -> 5901;
5903 -> 5902;
5903 -> 5897;
5903 -> 5901;
5904 -> 5903;
5904 -> 5804;
5905 -> 5904;
5905 -> 5898;
5905 -> 5804;
5906 -> 5904;
5906 -> 5905;
5907 -> 5905;
5908 -> 5906;
5908 -> 5907;
5908 -> 5796;
5909 -> 5799;
5909 -> 5801;
5909 -> 5802;
5909 -> 5803;
5909 -> 5813;
5909 -> 5882;
5909 -> 5897;
5909 -> 5907;
5909 -> 5906;
5909 -> 5796;
5910 -> 5909;
5910 -> 0;
5910 -> 5764;
5911 -> 5764;
5912 -> 5766;
5912 -> 5911;
5913 -> 5912;
5913 -> 5909;
5913 -> 5911;
5914 -> 5913;
5914 -> 5764;
5915 -> 5764;
5916 -> 5914;
5916 -> 5915;
5917 -> 5764;
5918 -> 5766;
5918 -> 5917;
5919 -> 5917;
5920 -> 5918;
5920 -> 5919;
5921 -> 5920;
5921 -> 5909;
5921 -> 5919;
5922 -> 5917;
5923 -> 5918;
5923 -> 5922;
5924 -> 5923;
5924 -> 5909;
5924 -> 5922;
5925 -> 5922;
5926 -> 5923;
5926 -> 5909;
5926 -> 5925;
5926 -> 5922;
5927 -> 5923;
5927 -> 5909;
5927 -> 5922;
5928 -> 5917;
5929 -> 5921;
5929 -> 5764;
5930 -> 5909;
5930 -> 5764;
5931 -> 5930;
5932 -> 5931;
5932 -> 5909;
5932 -> 5927;
5933 -> 5931;
5933 -> 5909;
5933 -> 5924;
5933 -> 5923;
5933 -> 5927;
5934 -> 5933;
5934 -> 5930;
5935 -> 5930;
5936 -> 5934;
5936 -> 5935;
5937 -> 5930;
5938 -> 5936;
5938 -> 5937;
5939 -> 5938;
5939 -> 5937;
5940 -> 5939;
5941 -> 5657;
5941 -> 5633;
5942 -> 5633;
5943 -> 5941;
5943 -> 5942;
5944 -> 5635;
5944 -> 5942;
5945 -> 5943;
5945 -> 5653;
5945 -> 5944;
5945 -> 5942;
5946 -> 5943;
5946 -> 5654;
5946 -> 5944;
5946 -> 5942;
5947 -> 5943;
5947 -> 5655;
5947 -> 5944;
5947 -> 5909;
5947 -> 5942;
5948 -> 5943;
5948 -> 5656;
5948 -> 5944;
5948 -> 5909;
5948 -> 5942;
5949 -> 5943;
5949 -> 5652;
5949 -> 5942;
5950 -> 5942;
5951 -> 5949;
5951 -> 5950;
5952 -> 5944;
5952 -> 5950;
5953 -> 5951;
5953 -> 5642;
5953 -> 5952;
5953 -> 5909;
5953 -> 5950;
5954 -> 5950;
5955 -> 5953;
5955 -> 5954;
5955 -> 5950;
5956 -> 5953;
5956 -> 5952;
5956 -> 5909;
5956 -> 5950;
5957 -> 5951;
5957 -> 5642;
5957 -> 5952;
5957 -> 5950;
5958 -> 5950;
5959 -> 5953;
5959 -> 5958;
5959 -> 5950;
5960 -> 5953;
5960 -> 5952;
5960 -> 5909;
5960 -> 5950;
5961 -> 5953;
5961 -> 5952;
5961 -> 5950;
5962 -> 5950;
5963 -> 5962;
5963 -> 5952;
5963 -> 5950;
5964 -> 5950;
5965 -> 5964;
5965 -> 5952;
5965 -> 5950;
5966 -> 5951;
5966 -> 5642;
5966 -> 5952;
5966 -> 5950;
5967 -> 5950;
5968 -> 5952;
5968 -> 5909;
5968 -> 5967;
5968 -> 5950;
5969 -> 5942;
5970 -> 5633;
5971 -> 5634;
5971 -> 5633;
5972 -> 5633;
5973 -> 5971;
5973 -> 5972;
5974 -> 5635;
5974 -> 5972;
5975 -> 5973;
5975 -> 0;
5975 -> 5972;
5976 -> 5972;
5977 -> 5974;
5977 -> 5976;
5978 -> 5977;
5978 -> 5909;
5978 -> 5927;
5978 -> 5961;
5978 -> 5976;
5979 -> 5977;
5979 -> 5909;
5979 -> 5976;
5980 -> 5977;
5980 -> 5909;
5980 -> 5976;
5981 -> 5977;
5981 -> 5909;
5981 -> 5957;
5981 -> 5976;
5982 -> 5977;
5982 -> 5909;
5982 -> 5924;
5982 -> 5966;
5982 -> 5976;
5983 -> 5980;
5983 -> 5981;
5983 -> 5978;
5983 -> 5982;
5983 -> 5909;
5983 -> 5924;
5983 -> 5966;
5983 -> 5923;
5983 -> 5933;
5983 -> 5963;
5983 -> 5927;
5983 -> 5961;
5983 -> 5945;
5983 -> 5946;
5983 -> 5947;
5983 -> 5948;
5983 -> 5957;
5983 -> 5965;
5983 -> 5964;
5983 -> 5976;
5984 -> 5976;
5985 -> 5976;
5986 -> 5984;
5986 -> 5985;
5987 -> 5984;
5987 -> 5972;
5988 -> 5972;
5989 -> 5972;
5990 -> 5989;
5991 -> 5974;
5991 -> 5990;
5992 -> 5990;
5993 -> 5991;
5993 -> 5992;
5994 -> 5993;
5994 -> 5983;
5994 -> 5992;
5995 -> 5993;
5995 -> 5983;
5995 -> 5992;
5996 -> 5990;
5997 -> 5991;
5997 -> 5996;
5998 -> 5997;
5998 -> 5983;
5998 -> 5995;
5998 -> 5996;
5999 -> 5996;
6000 -> 5999;
6000 -> 5997;
6000 -> 5996;
6001 -> 5996;
6002 -> 5997;
6002 -> 5983;
6002 -> 6001;
6002 -> 5996;
6003 -> 5997;
6003 -> 5983;
6003 -> 5996;
6004 -> 5990;
6005 -> 5995;
6005 -> 5989;
6006 -> 5989;
6007 -> 5974;
6007 -> 6006;
6008 -> 6007;
6008 -> 5983;
6008 -> 6003;
6008 -> 6006;
6009 -> 6007;
6009 -> 5983;
6009 -> 6006;
6010 -> 6007;
6010 -> 5983;
6010 -> 5995;
6010 -> 5997;
6010 -> 6000;
6010 -> 6003;
6010 -> 6009;
6011 -> 6010;
6011 -> 5989;
6012 -> 5989;
6013 -> 6011;
6013 -> 6012;
6014 -> 5989;
6015 -> 5974;
6015 -> 6014;
6016 -> 6015;
6016 -> 5983;
6016 -> 5995;
6016 -> 5997;
6016 -> 6010;
6016 -> 6014;
6017 -> 6016;
6017 -> 5989;
6018 -> 5989;
6019 -> 6017;
6019 -> 6018;
6020 -> 5989;
6021 -> 5989;
6022 -> 6020;
6022 -> 6021;
6023 -> 5974;
6023 -> 6021;
6024 -> 6021;
6025 -> 6022;
6025 -> 6021;
6026 -> 6021;
6027 -> 6024;
6027 -> 6026;
6028 -> 6025;
6028 -> 6026;
6029 -> 6023;
6029 -> 6026;
6030 -> 6028;
6030 -> 6026;
6031 -> 5801;
6031 -> 6030;
6032 -> 6027;
6032 -> 6026;
6033 -> 6031;
6033 -> 6032;
6033 -> 6029;
6033 -> 5983;
6033 -> 5995;
6033 -> 5997;
6033 -> 6010;
6033 -> 6000;
6033 -> 6003;
6033 -> 6026;
6034 -> 6026;
6035 -> 6034;
6036 -> 6033;
6036 -> 6035;
6036 -> 6034;
6037 -> 6033;
6037 -> 6034;
6038 -> 6034;
6039 -> 6033;
6039 -> 6034;
6040 -> 6034;
6041 -> 6033;
6041 -> 6040;
6042 -> 6041;
6042 -> 6034;
6043 -> 6034;
6044 -> 6042;
6044 -> 6043;
6045 -> 6034;
6046 -> 6033;
6046 -> 6045;
6047 -> 6045;
6048 -> 6046;
6048 -> 6047;
6049 -> 6048;
6049 -> 6045;
6050 -> 6045;
6051 -> 6049;
6051 -> 6050;
6052 -> 6051;
6053 -> 6046;
6053 -> 6052;
6054 -> 6052;
6055 -> 6053;
6055 -> 6054;
6056 -> 6055;
6056 -> 6052;
6057 -> 6052;
6058 -> 6056;
6058 -> 6057;
6059 -> 6052;
6060 -> 6059;
6060 -> 6051;
6061 -> 6051;
6062 -> 6046;
6062 -> 6061;
6063 -> 6061;
6064 -> 6062;
6064 -> 6063;
6065 -> 6064;
6065 -> 6033;
6065 -> 6063;
6066 -> 6065;
6066 -> 6061;
6067 -> 6066;
6067 -> 6051;
6068 -> 6060;
6068 -> 6067;
6068 -> 6051;
6069 -> 6051;
6070 -> 6046;
6070 -> 6069;
6071 -> 6069;
6072 -> 6070;
6072 -> 6071;
6073 -> 6072;
6073 -> 6069;
6074 -> 6069;
6075 -> 6073;
6075 -> 6074;
6076 -> 6075;
6076 -> 6051;
6077 -> 6068;
6077 -> 6076;
6077 -> 6051;
6078 -> 6077;
6079 -> 6078;
6079 -> 6034;
6080 -> 6044;
6080 -> 6079;
6080 -> 6034;
6081 -> 6034;
6082 -> 6081;
6083 -> 6081;
6084 -> 6033;
6084 -> 6083;
6085 -> 6083;
6086 -> 6083;
6087 -> 6033;
6087 -> 6086;
6087 -> 6083;
6088 -> 6081;
6089 -> 6034;
6090 -> 6033;
6090 -> 6089;
6091 -> 6034;
6092 -> 6034;
6093 -> 6034;
6094 -> 6034;
6095 -> 6034;
6096 -> 6033;
6096 -> 6034;
6097 -> 6034;
6098 -> 5989;
6099 -> 5974;
6099 -> 6098;
6100 -> 6098;
6101 -> 6099;
6101 -> 6100;
6102 -> 6101;
6102 -> 6033;
6102 -> 6100;
6103 -> 6102;
6103 -> 6098;
6104 -> 6098;
6105 -> 6103;
6105 -> 6104;
6106 -> 6098;
6107 -> 6106;
6107 -> 5989;
6108 -> 5989;
6109 -> 5974;
6109 -> 6108;
6110 -> 6109;
6110 -> 6033;
6110 -> 6108;
6111 -> 6110;
6111 -> 5989;
6112 -> 5989;
6113 -> 6111;
6113 -> 6112;
6114 -> 6113;
6115 -> 6113;
6116 -> 6114;
6116 -> 6115;
6117 -> 6115;
6118 -> 6116;
6118 -> 6117;
6118 -> 6115;
6119 -> 6115;
6119 -> 6033;
6119 -> 6116;
6120 -> 6113;
6121 -> 6116;
6121 -> 6120;
6122 -> 5987;
6122 -> 6113;
6123 -> 6113;
6124 -> 6122;
6124 -> 6123;
6125 -> 6123;
6126 -> 6124;
6126 -> 6125;
6126 -> 6123;
6127 -> 6124;
6127 -> 6123;
6127 -> 6033;
6128 -> 6123;
6129 -> 6124;
6129 -> 6128;
6129 -> 6123;
6130 -> 6124;
6130 -> 6123;
6130 -> 6033;
6131 -> 6123;
6132 -> 6113;
6133 -> 6124;
6133 -> 6113;
6134 -> 6113;
6135 -> 6133;
6135 -> 6134;
6136 -> 5974;
6136 -> 6134;
6137 -> 6135;
6137 -> 6124;
6137 -> 6134;
6138 -> 6134;
6139 -> 6137;
6139 -> 6138;
6140 -> 6136;
6140 -> 6138;
6141 -> 6140;
6141 -> 6033;
6141 -> 6139;
6141 -> 5983;
6141 -> 6138;
6142 -> 6140;
6142 -> 6033;
6142 -> 6138;
6143 -> 6138;
6144 -> 6140;
6144 -> 6033;
6144 -> 6142;
6144 -> 6143;
6144 -> 6138;
6145 -> 6134;
6146 -> 6113;
6147 -> 6121;
6147 -> 5633;
6148 -> 5943;
6148 -> 5633;
6149 -> 5633;
6150 -> 6148;
6150 -> 6149;
6151 -> 5635;
6151 -> 6149;
6152 -> 6150;
6152 -> 5653;
6152 -> 6151;
6152 -> 6149;
6153 -> 6150;
6153 -> 5654;
6153 -> 6151;
6153 -> 6149;
6154 -> 6150;
6154 -> 5655;
6154 -> 6151;
6154 -> 6033;
6154 -> 6149;
6155 -> 6150;
6155 -> 5656;
6155 -> 6151;
6155 -> 6033;
6155 -> 6149;
6156 -> 6150;
6156 -> 5951;
6156 -> 6149;
6157 -> 6149;
6158 -> 6151;
6158 -> 6157;
6159 -> 6156;
6159 -> 5642;
6159 -> 6158;
6159 -> 6033;
6159 -> 6157;
6160 -> 6157;
6161 -> 6159;
6161 -> 6160;
6161 -> 6157;
6162 -> 6159;
6162 -> 6158;
6162 -> 6033;
6162 -> 6157;
6163 -> 6156;
6163 -> 5642;
6163 -> 6158;
6163 -> 6157;
6164 -> 6157;
6165 -> 6159;
6165 -> 6164;
6165 -> 6157;
6166 -> 6159;
6166 -> 6158;
6166 -> 6033;
6166 -> 6157;
6167 -> 6157;
6168 -> 6167;
6168 -> 6158;
6168 -> 6157;
6169 -> 6157;
6170 -> 6169;
6170 -> 6158;
6170 -> 6157;
6171 -> 6156;
6171 -> 5642;
6171 -> 6158;
6171 -> 6157;
6172 -> 6157;
6173 -> 6158;
6173 -> 6033;
6173 -> 6172;
6173 -> 6157;
6174 -> 6149;
6175 -> 5633;
6176 -> 0;
6176 -> 5633;
6177 -> 5633;
6178 -> 6176;
6178 -> 6177;
6179 -> 5635;
6179 -> 6177;
6180 -> 6178;
6180 -> 6177;
6181 -> 6177;
6182 -> 6180;
6182 -> 6181;
6183 -> 6182;
6183 -> 0;
6183 -> 6181;
6184 -> 6183;
6185 -> 6179;
6185 -> 6033;
6185 -> 6124;
6185 -> 6159;
6185 -> 6177;
6186 -> 6179;
6186 -> 6033;
6186 -> 6177;
6187 -> 6179;
6187 -> 6033;
6187 -> 6124;
6187 -> 6152;
6187 -> 6153;
6187 -> 6154;
6187 -> 6155;
6187 -> 6163;
6187 -> 6159;
6187 -> 6123;
6187 -> 6168;
6187 -> 6170;
6187 -> 6171;
6187 -> 6142;
6187 -> 6186;
6188 -> 6187;
6188 -> 6178;
6188 -> 6177;
6189 -> 6188;
6189 -> 6033;
6189 -> 6123;
6189 -> 6168;
6189 -> 6187;
6190 -> 6188;
6191 -> 6188;
6192 -> 6187;
6192 -> 6188;
6193 -> 0;
6193 -> 5633;
6194 -> 5633;
6195 -> 5633;
6196 -> 6193;
6196 -> 6195;
6197 -> 6194;
6197 -> 6195;
6198 -> 6194;
6198 -> 6195;
6199 -> 5635;
6199 -> 6195;
6200 -> 6196;
6200 -> 6195;
6201 -> 6198;
6201 -> 6195;
6202 -> 6195;
6203 -> 6200;
6203 -> 6202;
6204 -> 6201;
6204 -> 6202;
6205 -> 6199;
6205 -> 6202;
6206 -> 6202;
6207 -> 6205;
6207 -> 6206;
6208 -> 6207;
6208 -> 6033;
6208 -> 6124;
6208 -> 6152;
6208 -> 6153;
6208 -> 6154;
6208 -> 6155;
6208 -> 6163;
6208 -> 6159;
6208 -> 6188;
6208 -> 6123;
6208 -> 6168;
6208 -> 6187;
6208 -> 6170;
6208 -> 6171;
6208 -> 6142;
6208 -> 6206;
6209 -> 6208;
6209 -> 6202;
6210 -> 6202;
6211 -> 6205;
6211 -> 6210;
6212 -> 6211;
6212 -> 6033;
6212 -> 6124;
6212 -> 6159;
6212 -> 6188;
6212 -> 6210;
6213 -> 6211;
6213 -> 6033;
6213 -> 6142;
6213 -> 6210;
6214 -> 6211;
6214 -> 6033;
6214 -> 6142;
6214 -> 6210;
6215 -> 6211;
6215 -> 6033;
6215 -> 6124;
6215 -> 6163;
6215 -> 6210;
6216 -> 6211;
6216 -> 6033;
6216 -> 6124;
6216 -> 6171;
6216 -> 6188;
6216 -> 6210;
6217 -> 6210;
6218 -> 6210;
6219 -> 6217;
6219 -> 6218;
6220 -> 6217;
6220 -> 6202;
6221 -> 6202;
6222 -> 6205;
6222 -> 6221;
6223 -> 6221;
6224 -> 6222;
6224 -> 6223;
6225 -> 6224;
6225 -> 6212;
6225 -> 6223;
6226 -> 6224;
6226 -> 6212;
6226 -> 6223;
6227 -> 6226;
6227 -> 6221;
6228 -> 6221;
6229 -> 6227;
6229 -> 6228;
6230 -> 6229;
6231 -> 6230;
6231 -> 6202;
6232 -> 6202;
6233 -> 6203;
6233 -> 6202;
6234 -> 6232;
6234 -> 6202;
6235 -> 6233;
6235 -> 6234;
6235 -> 6205;
6235 -> 6212;
6235 -> 6226;
6235 -> 6202;
6236 -> 6202;
6237 -> 6236;
6238 -> 6235;
6238 -> 6237;
6238 -> 6236;
6239 -> 6235;
6239 -> 6236;
6240 -> 6236;
6241 -> 6235;
6241 -> 6236;
6242 -> 6236;
6243 -> 6235;
6243 -> 6242;
6244 -> 6243;
6244 -> 6236;
6245 -> 6236;
6246 -> 6244;
6246 -> 6245;
6247 -> 6236;
6248 -> 6235;
6248 -> 6247;
6249 -> 6247;
6250 -> 6248;
6250 -> 6249;
6251 -> 6250;
6251 -> 6247;
6252 -> 6247;
6253 -> 6251;
6253 -> 6252;
6254 -> 6253;
6255 -> 6248;
6255 -> 6254;
6256 -> 6254;
6257 -> 6255;
6257 -> 6256;
6258 -> 6257;
6258 -> 6254;
6259 -> 6254;
6260 -> 6258;
6260 -> 6259;
6261 -> 6254;
6262 -> 6261;
6262 -> 6253;
6263 -> 6253;
6264 -> 6248;
6264 -> 6263;
6265 -> 6263;
6266 -> 6264;
6266 -> 6265;
6267 -> 6266;
6267 -> 6235;
6267 -> 6265;
6268 -> 6267;
6268 -> 6263;
6269 -> 6268;
6269 -> 6253;
6270 -> 6262;
6270 -> 6269;
6270 -> 6253;
6271 -> 6253;
6272 -> 6248;
6272 -> 6271;
6273 -> 6271;
6274 -> 6272;
6274 -> 6273;
6275 -> 6274;
6275 -> 6271;
6276 -> 6271;
6277 -> 6275;
6277 -> 6276;
6278 -> 6277;
6278 -> 6253;
6279 -> 6270;
6279 -> 6278;
6279 -> 6253;
6280 -> 6279;
6281 -> 6280;
6281 -> 6236;
6282 -> 6246;
6282 -> 6281;
6282 -> 6236;
6283 -> 6236;
6284 -> 6283;
6285 -> 6283;
6286 -> 6235;
6286 -> 6285;
6287 -> 6285;
6288 -> 6285;
6289 -> 6235;
6289 -> 6288;
6289 -> 6285;
6290 -> 6283;
6291 -> 6236;
6292 -> 6235;
6292 -> 6291;
6293 -> 6236;
6294 -> 6236;
6295 -> 6236;
6296 -> 6236;
6297 -> 6236;
6298 -> 6235;
6298 -> 6236;
6299 -> 6236;
6300 -> 6202;
6301 -> 6235;
6301 -> 6300;
6302 -> 6301;
6302 -> 6202;
6303 -> 6202;
6304 -> 6302;
6304 -> 6303;
6305 -> 6231;
6305 -> 6304;
6305 -> 6202;
6306 -> 6204;
6306 -> 6305;
6306 -> 6202;
6307 -> 6202;
6308 -> 6306;
6308 -> 6307;
6309 -> 6205;
6309 -> 6307;
6310 -> 6307;
6311 -> 6309;
6311 -> 6310;
6312 -> 6311;
6312 -> 6235;
6312 -> 6310;
6313 -> 6312;
6313 -> 6307;
6314 -> 6307;
6315 -> 6313;
6315 -> 6314;
6316 -> 6315;
6317 -> 6316;
6317 -> 6202;
6318 -> 6317;
6319 -> 6220;
6319 -> 6317;
6320 -> 6317;
6321 -> 6319;
6321 -> 6320;
6322 -> 6320;
6323 -> 6321;
6323 -> 6322;
6323 -> 6320;
6324 -> 6321;
6324 -> 6320;
6324 -> 6235;
6325 -> 6320;
6326 -> 6321;
6326 -> 6325;
6326 -> 6320;
6327 -> 6321;
6327 -> 6320;
6327 -> 6235;
6328 -> 6320;
6329 -> 6317;
6330 -> 6321;
6330 -> 6317;
6331 -> 6317;
6332 -> 6330;
6332 -> 6331;
6333 -> 6332;
6333 -> 6321;
6333 -> 6331;
6334 -> 6333;
6334 -> 6331;
6335 -> 6331;
6335 -> 6235;
6335 -> 6334;
6335 -> 6212;
6336 -> 6331;
6337 -> 6331;
6338 -> 6317;
6339 -> 6318;
6340 -> 6339;
6340 -> 6235;
6341 -> 6339;
6342 -> 6339;
6343 -> 6339;
6343 -> 6235;
6343 -> 6321;
6344 -> 6339;
6344 -> 6235;
6344 -> 6321;
6344 -> 6320;
6344 -> 6331;
6345 -> 6344;
6345 -> 6339;
6346 -> 6339;
6347 -> 6345;
6347 -> 6346;
6348 -> 6347;
6348 -> 6346;
6349 -> 6348;
6350 -> 6339;
6350 -> 6344;
6351 -> 6344;
6352 -> 6350;
6352 -> 6351;
6353 -> 6352;
6353 -> 6344;
6354 -> 6344;
6355 -> 6353;
6355 -> 6354;
6356 -> 6344;
6357 -> 6344;
6358 -> 6339;
6358 -> 6344;
6359 -> 6344;
6360 -> 6358;
6360 -> 6359;
6361 -> 6360;
6361 -> 6344;
6362 -> 6344;
6363 -> 6361;
6363 -> 6362;
6364 -> 6339;
6364 -> 6354;
6365 -> 6364;
6365 -> 6354;
6366 -> 6365;
6366 -> 6354;
6367 -> 6366;
6367 -> 6354;
6368 -> 6354;
6369 -> 6354;
6369 -> 6368;
6370 -> 6368;
6371 -> 6369;
6371 -> 6370;
6372 -> 6371;
6372 -> 6368;
6373 -> 6368;
6374 -> 6372;
6374 -> 6373;
6375 -> 6374;
6376 -> 6369;
6376 -> 6375;
6377 -> 6375;
6378 -> 6376;
6378 -> 6377;
6379 -> 6378;
6379 -> 6375;
6380 -> 6375;
6381 -> 6379;
6381 -> 6380;
6382 -> 6375;
6383 -> 6382;
6383 -> 6374;
6384 -> 6374;
6385 -> 6369;
6385 -> 6384;
6386 -> 6384;
6387 -> 6385;
6387 -> 6386;
6388 -> 6387;
6388 -> 6235;
6388 -> 6321;
6388 -> 6320;
6388 -> 6344;
6388 -> 6331;
6388 -> 6339;
6388 -> 6386;
6389 -> 6388;
6389 -> 6384;
6390 -> 6389;
6390 -> 6374;
6391 -> 6383;
6391 -> 6390;
6391 -> 6374;
6392 -> 6374;
6393 -> 6369;
6393 -> 6392;
6394 -> 6392;
6395 -> 6393;
6395 -> 6394;
6396 -> 6395;
6396 -> 6392;
6397 -> 6392;
6398 -> 6396;
6398 -> 6397;
6399 -> 6398;
6399 -> 6374;
6400 -> 6391;
6400 -> 6399;
6400 -> 6374;
6401 -> 6400;
6402 -> 6401;
6402 -> 6354;
6403 -> 6402;
6404 -> 6354;
6404 -> 6403;
6405 -> 6403;
6406 -> 6405;
6406 -> 6403;
6407 -> 6403;
6408 -> 6406;
6408 -> 6407;
6409 -> 6404;
6409 -> 6407;
6410 -> 6407;
6411 -> 6408;
6411 -> 6410;
6411 -> 6407;
6412 -> 6409;
6412 -> 6235;
6412 -> 6321;
6412 -> 6408;
6412 -> 6407;
6413 -> 6409;
6413 -> 6235;
6413 -> 6321;
6413 -> 6408;
6414 -> 6403;
6415 -> 6413;
6415 -> 6414;
6416 -> 6403;
6417 -> 6406;
6417 -> 6416;
6418 -> 6404;
6418 -> 6416;
6419 -> 6416;
6420 -> 6417;
6420 -> 6419;
6420 -> 6416;
6421 -> 6418;
6421 -> 6235;
6421 -> 6321;
6421 -> 6417;
6421 -> 6416;
6422 -> 6418;
6422 -> 6235;
6422 -> 6321;
6422 -> 6417;
6423 -> 6403;
6424 -> 6422;
6424 -> 6423;
6425 -> 6415;
6425 -> 6424;
6425 -> 6403;
6426 -> 6405;
6426 -> 6403;
6427 -> 6403;
6428 -> 6426;
6428 -> 6427;
6429 -> 6404;
6429 -> 6427;
6430 -> 6427;
6431 -> 6428;
6431 -> 6430;
6431 -> 6427;
6432 -> 6429;
6432 -> 6235;
6432 -> 6321;
6432 -> 6428;
6432 -> 6427;
6433 -> 6429;
6433 -> 6235;
6433 -> 6321;
6433 -> 6428;
6434 -> 6403;
6435 -> 6433;
6435 -> 6434;
6436 -> 6435;
6436 -> 6402;
6437 -> 6367;
6437 -> 6436;
6438 -> 6436;
6439 -> 6437;
6439 -> 6438;
6440 -> 6354;
6440 -> 6438;
6441 -> 6438;
6442 -> 6440;
6442 -> 6441;
6443 -> 6442;
6443 -> 6438;
6444 -> 6438;
6445 -> 6443;
6445 -> 6444;
6446 -> 6438;
6447 -> 6440;
6447 -> 6446;
6448 -> 6447;
6448 -> 6438;
6449 -> 6438;
6450 -> 6448;
6450 -> 6449;
6451 -> 6440;
6451 -> 6449;
6452 -> 6449;
6453 -> 6450;
6453 -> 6452;
6454 -> 6453;
6454 -> 6449;
6455 -> 6449;
6456 -> 6451;
6456 -> 6455;
6457 -> 6456;
6457 -> 6449;
6458 -> 6454;
6458 -> 6457;
6458 -> 6449;
6459 -> 6445;
6459 -> 6458;
6459 -> 6438;
6460 -> 6439;
6460 -> 0;
6460 -> 6438;
6461 -> 6438;
6462 -> 6438;
6463 -> 6438;
6464 -> 6440;
6464 -> 6463;
6465 -> 6464;
6465 -> 6438;
6466 -> 6438;
6467 -> 6465;
6467 -> 6466;
6468 -> 6467;
6469 -> 6468;
6469 -> 6467;
6470 -> 6467;
6471 -> 6469;
6471 -> 6470;
6472 -> 6471;
6473 -> 6471;
6474 -> 6472;
6474 -> 6438;
6475 -> 6438;
6476 -> 6474;
6476 -> 6475;
6477 -> 6440;
6477 -> 6475;
6478 -> 6475;
6479 -> 6476;
6479 -> 6478;
6479 -> 6475;
6480 -> 6477;
6480 -> 6235;
6480 -> 6321;
6480 -> 6476;
6480 -> 6475;
6481 -> 6438;
6482 -> 6476;
6482 -> 6481;
6483 -> 6472;
6483 -> 6438;
6484 -> 6438;
6485 -> 6483;
6485 -> 6484;
6486 -> 6440;
6486 -> 6484;
6487 -> 6484;
6488 -> 6485;
6488 -> 6487;
6488 -> 6484;
6489 -> 6486;
6489 -> 6235;
6489 -> 6321;
6489 -> 6485;
6489 -> 6484;
6490 -> 6438;
6491 -> 6485;
6491 -> 6490;
6492 -> 6438;
6493 -> 6472;
6493 -> 6492;
6493 -> 6438;
6494 -> 6438;
6495 -> 6493;
6495 -> 6494;
6496 -> 6440;
6496 -> 6494;
6497 -> 6494;
6498 -> 6495;
6498 -> 6497;
6498 -> 6494;
6499 -> 6496;
6499 -> 6235;
6499 -> 6321;
6499 -> 6495;
6499 -> 6494;
6500 -> 6438;
6501 -> 6495;
6501 -> 6500;
6502 -> 6491;
6502 -> 6501;
6502 -> 6438;
6503 -> 6472;
6503 -> 6438;
6504 -> 6438;
6505 -> 6503;
6505 -> 6504;
6506 -> 6440;
6506 -> 6504;
6507 -> 6504;
6508 -> 6505;
6508 -> 6507;
6508 -> 6504;
6509 -> 6506;
6509 -> 6235;
6509 -> 6321;
6509 -> 6505;
6509 -> 6504;
6510 -> 6438;
6511 -> 6505;
6511 -> 6510;
6512 -> 6472;
6512 -> 6438;
6513 -> 6438;
6514 -> 6512;
6514 -> 6513;
6515 -> 6440;
6515 -> 6513;
6516 -> 6513;
6517 -> 6514;
6517 -> 6516;
6517 -> 6513;
6518 -> 6515;
6518 -> 6235;
6518 -> 6321;
6518 -> 6514;
6518 -> 6513;
6519 -> 6438;
6520 -> 6514;
6520 -> 6519;
6521 -> 6520;
6522 -> 6521;
6522 -> 6436;
6523 -> 6367;
6523 -> 6522;
6524 -> 6522;
6525 -> 6523;
6525 -> 6524;
6526 -> 0;
6526 -> 6525;
6527 -> 6525;
6528 -> 6526;
6528 -> 6527;
6529 -> 6354;
6529 -> 6527;
6530 -> 6528;
6530 -> 6527;
6531 -> 6527;
6532 -> 6530;
6532 -> 6531;
6533 -> 6529;
6533 -> 6531;
6534 -> 6531;
6535 -> 6531;
6536 -> 6534;
6536 -> 6535;
6537 -> 6533;
6537 -> 6535;
6538 -> 6535;
6539 -> 6537;
6539 -> 6538;
6540 -> 6538;
6541 -> 6539;
6541 -> 6540;
6542 -> 6541;
6542 -> 6538;
6543 -> 6542;
6544 -> 6543;
6544 -> 6535;
6545 -> 6536;
6545 -> 6535;
6546 -> 6535;
6547 -> 6545;
6547 -> 6546;
6548 -> 6537;
6548 -> 6546;
6549 -> 6546;
6550 -> 6548;
6550 -> 6549;
6551 -> 6550;
6551 -> 6546;
6552 -> 6546;
6553 -> 6551;
6553 -> 6552;
6554 -> 6553;
6554 -> 0;
6554 -> 6546;
6555 -> 6554;
6556 -> 6548;
6556 -> 6555;
6557 -> 6555;
6558 -> 6556;
6558 -> 6557;
6559 -> 6558;
6559 -> 6555;
6560 -> 6555;
6561 -> 6559;
6561 -> 6560;
6562 -> 6555;
6562 -> 6554;
6563 -> 6554;
6564 -> 6563;
6564 -> 6554;
6565 -> 6562;
6565 -> 6564;
6565 -> 6554;
6566 -> 6554;
6567 -> 6566;
6567 -> 6235;
6567 -> 6320;
6567 -> 6344;
6568 -> 6566;
6569 -> 6566;
6570 -> 6566;
6570 -> 6554;
6571 -> 6554;
6572 -> 6548;
6572 -> 6571;
6573 -> 6572;
6573 -> 6235;
6573 -> 6321;
6573 -> 6566;
6573 -> 6320;
6573 -> 6344;
6573 -> 6331;
6573 -> 6339;
6573 -> 6571;
6574 -> 6573;
6574 -> 6554;
6575 -> 6570;
6575 -> 6554;
6576 -> 6575;
6576 -> 6535;
6577 -> 6576;
6577 -> 6535;
6578 -> 6535;
6579 -> 6577;
6579 -> 6578;
6580 -> 6577;
6580 -> 6578;
6581 -> 6579;
6581 -> 6578;
6582 -> 6578;
6583 -> 6582;
6583 -> 6581;
6583 -> 6578;
6584 -> 6582;
6584 -> 6578;
6585 -> 6584;
6585 -> 6583;
6585 -> 6578;
6586 -> 6585;
6586 -> 6531;
6587 -> 6586;
6587 -> 6585;
6587 -> 6531;
6588 -> 6586;
6588 -> 6531;
6589 -> 6531;
6590 -> 6533;
6590 -> 6589;
6591 -> 6590;
6591 -> 6585;
6591 -> 6589;
6592 -> 6590;
6592 -> 6585;
6592 -> 6589;
6593 -> 6592;
6593 -> 6531;
6594 -> 6531;
6595 -> 6593;
6595 -> 6594;
6596 -> 6588;
6596 -> 6531;
6597 -> 6596;
6597 -> 6527;
6598 -> 6527;
6599 -> 6529;
6599 -> 6598;
6600 -> 6599;
6600 -> 6585;
6600 -> 6592;
6600 -> 6598;
6601 -> 6600;
6601 -> 6527;
6602 -> 6527;
6603 -> 6601;
6603 -> 6602;
6604 -> 6597;
6604 -> 6527;
6605 -> 6604;
6605 -> 6525;
6606 -> 6605;
6606 -> 6354;
6606 -> 6585;
6606 -> 6592;
6607 -> 6354;
6608 -> 6606;
6608 -> 6339;
6609 -> 6339;
6610 -> 6339;
6611 -> 6608;
6611 -> 6610;
6612 -> 6609;
6612 -> 6610;
6613 -> 6339;
6613 -> 6610;
6614 -> 6610;
6615 -> 6614;
6616 -> 6613;
6616 -> 6615;
6617 -> 6616;
6617 -> 6606;
6617 -> 6615;
6618 -> 6617;
6618 -> 6614;
6619 -> 6614;
6620 -> 6618;
6620 -> 6619;
6621 -> 6614;
6622 -> 6614;
6623 -> 6620;
6623 -> 6614;
6624 -> 6614;
6625 -> 6623;
6625 -> 6624;
6626 -> 6625;
6626 -> 6624;
6627 -> 6624;
6628 -> 6626;
6628 -> 6627;
6629 -> 6628;
6629 -> 6627;
6630 -> 6627;
6631 -> 6629;
6631 -> 6630;
6632 -> 6631;
6632 -> 6630;
6633 -> 0;
6633 -> 6632;
6634 -> 6620;
6634 -> 6633;
6635 -> 6633;
6636 -> 6634;
6636 -> 6635;
6637 -> 6636;
6637 -> 6635;
6638 -> 6635;
6639 -> 6637;
6639 -> 6638;
6640 -> 6639;
6640 -> 6638;
6641 -> 6640;
6642 -> 6620;
6642 -> 0;
6642 -> 6641;
6643 -> 6620;
6643 -> 0;
6643 -> 6642;
6644 -> 6620;
6644 -> 0;
6644 -> 6643;
6645 -> 6610;
6646 -> 6613;
6646 -> 6645;
6647 -> 6646;
6647 -> 6606;
6647 -> 6645;
6648 -> 6647;
6648 -> 6610;
6649 -> 6610;
6650 -> 6648;
6650 -> 6649;
6651 -> 6611;
6651 -> 6610;
6652 -> 6339;
6653 -> 6339;
6654 -> 6651;
6654 -> 6653;
6655 -> 6654;
6655 -> 6339;
6656 -> 6339;
6657 -> 6655;
6657 -> 6656;
6658 -> 6657;
6658 -> 6656;
6659 -> 0;
6659 -> 6658;
6660 -> 6339;
6660 -> 6606;
6661 -> 6651;
6661 -> 6339;
6662 -> 5633;
6663 -> 5635;
6663 -> 6662;
6664 -> 6663;
6664 -> 6606;
6664 -> 6662;
6665 -> 6664;
6665 -> 5633;
6666 -> 5633;
6667 -> 6665;
6667 -> 6666;
6668 -> 5633;
6669 -> 6661;
6669 -> 6668;
6670 -> 6669;
6670 -> 5633;
6671 -> 5633;
6672 -> 5635;
6672 -> 6671;
6673 -> 6672;
6673 -> 6606;
6673 -> 6671;
6674 -> 6673;
6674 -> 5633;
6675 -> 5633;
6676 -> 6674;
6676 -> 6675;
6677 -> 6670;
6677 -> 6676;
6677 -> 5633;
6678 -> 0;
6678 -> 5633;
6679 -> 5633;
6680 -> 6678;
6680 -> 6679;
6681 -> 5635;
6681 -> 6679;
6682 -> 6680;
6682 -> 6679;
6683 -> 6679;
6684 -> 6682;
6684 -> 6683;
6685 -> 6684;
6685 -> 0;
6685 -> 6683;
6686 -> 6685;
6687 -> 6681;
6687 -> 6606;
6687 -> 6679;
6688 -> 6687;
6688 -> 6680;
6688 -> 6679;
6689 -> 6688;
6690 -> 6688;
6691 -> 6687;
6691 -> 6688;
6692 -> 6192;
6692 -> 5633;
6693 -> 6661;
6693 -> 5633;
6694 -> 6691;
6694 -> 5633;
6695 -> 6692;
6695 -> 6693;
6695 -> 6694;
6695 -> 5635;
6695 -> 6606;
6695 -> 6660;
6695 -> 6688;
6695 -> 5633;
6696 -> 5633;
6697 -> 6695;
6697 -> 6696;
6698 -> 6695;
6698 -> 6696;
6699 -> 6695;
6699 -> 6696;
6700 -> 6695;
6700 -> 6696;
6701 -> 6695;
6701 -> 6696;
6702 -> 6695;
6702 -> 6696;
6703 -> 6697;
6703 -> 6696;
6704 -> 6698;
6704 -> 6696;
6705 -> 6699;
6705 -> 6696;
6706 -> 6700;
6706 -> 6696;
6707 -> 6701;
6707 -> 6696;
6708 -> 6696;
6709 -> 6707;
6709 -> 6708;
6710 -> 6708;
6711 -> 6709;
6711 -> 6695;
6711 -> 6708;
6712 -> 6709;
6712 -> 6695;
6712 -> 6708;
6713 -> 6710;
6713 -> 6708;
6714 -> 6713;
6714 -> 6696;
6715 -> 6702;
6715 -> 6696;
6716 -> 6703;
6716 -> 6704;
6716 -> 6705;
6716 -> 6706;
6716 -> 6714;
6716 -> 6715;
6716 -> 6695;
6716 -> 6696;
6717 -> 6696;
6718 -> 6717;
6718 -> 6696;
6719 -> 6716;
6719 -> 6696;
6720 -> 6716;
6720 -> 6696;
6721 -> 6719;
6721 -> 6696;
6722 -> 6719;
6722 -> 6696;
6723 -> 6150;
6723 -> 5633;
6724 -> 5633;
6725 -> 6723;
6725 -> 6724;
6726 -> 5635;
6726 -> 6724;
6727 -> 6725;
6727 -> 6156;
6727 -> 6724;
6728 -> 6724;
6729 -> 6727;
6729 -> 6728;
6730 -> 6726;
6730 -> 6728;
6731 -> 6730;
6731 -> 6716;
6731 -> 6729;
6731 -> 5642;
6731 -> 6728;
6732 -> 6730;
6732 -> 6716;
6732 -> 6728;
6733 -> 6728;
6734 -> 6730;
6734 -> 6716;
6734 -> 6732;
6734 -> 6733;
6734 -> 6728;
6735 -> 6724;
6736 -> 5633;
6737 -> 6716;
6737 -> 5631;
6738 -> 6737;
6738 -> 5621;
6738 -> 6716;
6738 -> 6732;
6738 -> 5619;
6739 -> 5619;
6740 -> 6738;
6740 -> 6739;
6741 -> 5527;
6741 -> 5526;
6742 -> 5526;
6743 -> 6741;
6743 -> 6742;
6744 -> 5528;
6744 -> 6742;
6745 -> 6742;
6746 -> 6745;
6747 -> 6744;
6747 -> 6746;
6748 -> 6747;
6748 -> 6738;
6748 -> 6746;
6749 -> 6748;
6749 -> 6745;
6750 -> 6745;
6751 -> 6749;
6751 -> 6750;
6752 -> 6750;
6753 -> 6745;
6754 -> 6745;
6755 -> 6751;
6755 -> 6745;
6756 -> 6745;
6757 -> 6755;
6757 -> 6756;
6758 -> 6757;
6758 -> 6756;
6759 -> 6756;
6760 -> 6758;
6760 -> 6759;
6761 -> 6760;
6761 -> 6759;
6762 -> 6759;
6763 -> 6761;
6763 -> 6762;
6764 -> 6763;
6764 -> 6762;
6765 -> 0;
6765 -> 6764;
6766 -> 6751;
6766 -> 6765;
6767 -> 6765;
6768 -> 6766;
6768 -> 6767;
6769 -> 6768;
6769 -> 6767;
6770 -> 6767;
6771 -> 6769;
6771 -> 6770;
6772 -> 6771;
6772 -> 6770;
6773 -> 6772;
6774 -> 6751;
6774 -> 0;
6774 -> 6773;
6775 -> 6751;
6775 -> 0;
6775 -> 6774;
6776 -> 6751;
6776 -> 0;
6776 -> 6775;
6777 -> 6742;
6778 -> 6744;
6778 -> 6777;
6779 -> 6778;
6779 -> 6738;
6779 -> 6777;
6780 -> 6779;
6780 -> 6742;
6781 -> 6742;
6782 -> 6780;
6782 -> 6781;
6783 -> 5520;
6784 -> 5520;
6785 -> 6738;
6785 -> 6784;
6786 -> 6785;
6786 -> 5520;
6787 -> 5520;
6788 -> 6786;
6788 -> 6787;
6789 -> 6788;
6789 -> 6787;
6790 -> 0;
6790 -> 6789;
6791 -> 6738;
6791 -> 5479;
6792 -> 5479;
6793 -> 5479;
6794 -> 5479;
6795 -> 6791;
6795 -> 6794;
6796 -> 6795;
6796 -> 5479;
6797 -> 6791;
6797 -> 6796;
6798 -> 6797;
6798 -> 6738;
6798 -> 6796;
6799 -> 6797;
6799 -> 6738;
6799 -> 6796;
6800 -> 6797;
6800 -> 6738;
6800 -> 6796;
6801 -> 6797;
6801 -> 6738;
6801 -> 6796;
6802 -> 6796;
6803 -> 0;
6803 -> 5479;
6804 -> 5479;
6805 -> 6803;
6805 -> 6804;
6806 -> 5481;
6806 -> 6804;
6807 -> 6805;
6807 -> 6804;
6808 -> 6804;
6809 -> 6807;
6809 -> 6808;
6810 -> 6809;
6810 -> 0;
6810 -> 6808;
6811 -> 6810;
6812 -> 6804;
6813 -> 6806;
6813 -> 6812;
6814 -> 6813;
6814 -> 6801;
6814 -> 6812;
6815 -> 6804;
6816 -> 6814;
6816 -> 6805;
6816 -> 6804;
6817 -> 6816;
6818 -> 6816;
6819 -> 5481;
6819 -> 6801;
6819 -> 6816;
6819 -> 5479;
6820 -> 5479;
6821 -> 5481;
6821 -> 6820;
6822 -> 6820;
6823 -> 6821;
6823 -> 6822;
6824 -> 6823;
6824 -> 6819;
6824 -> 6822;
6825 -> 6823;
6825 -> 6819;
6825 -> 6822;
6826 -> 6825;
6826 -> 6820;
6827 -> 6820;
6828 -> 6826;
6828 -> 6827;
6829 -> 6828;
6829 -> 5479;
6830 -> 6829;
6831 -> 5481;
6831 -> 6830;
6832 -> 6830;
6833 -> 6831;
6833 -> 6832;
6834 -> 6833;
6834 -> 6830;
6835 -> 6831;
6835 -> 6819;
6835 -> 6825;
6835 -> 6830;
6836 -> 6831;
6836 -> 6835;
6836 -> 6830;
6837 -> 6830;
6838 -> 6830;
6839 -> 6830;
6840 -> 6830;
6841 -> 6831;
6841 -> 6840;
6842 -> 6841;
6842 -> 6836;
6842 -> 6840;
6843 -> 6842;
6843 -> 6830;
6844 -> 6830;
6845 -> 6843;
6845 -> 6844;
6846 -> 6845;
6847 -> 6845;
6848 -> 6847;
6849 -> 6847;
6850 -> 6847;
6850 -> 6845;
6851 -> 6845;
6852 -> 6851;
6852 -> 6836;
6852 -> 6847;
6853 -> 6851;
6853 -> 6836;
6853 -> 6847;
6854 -> 6853;
6854 -> 6845;
6855 -> 6845;
6856 -> 6854;
6856 -> 6855;
6857 -> 6856;
6858 -> 6831;
6858 -> 6857;
6859 -> 6857;
6860 -> 6858;
6860 -> 6859;
6861 -> 0;
6861 -> 6859;
6862 -> 6859;
6863 -> 6859;
6864 -> 6861;
6864 -> 6863;
6865 -> 6862;
6865 -> 6863;
6866 -> 6862;
6866 -> 6863;
6867 -> 6860;
6867 -> 6863;
6868 -> 6864;
6868 -> 6863;
6869 -> 6865;
6869 -> 6863;
6870 -> 6866;
6870 -> 6863;
6871 -> 6863;
6872 -> 6868;
6872 -> 6871;
6873 -> 6869;
6873 -> 6871;
6874 -> 6870;
6874 -> 6871;
6875 -> 6867;
6875 -> 6871;
6876 -> 6872;
6876 -> 6871;
6877 -> 6873;
6877 -> 6871;
6878 -> 6874;
6878 -> 6871;
6879 -> 6871;
6880 -> 6876;
6880 -> 6879;
6881 -> 6877;
6881 -> 6879;
6882 -> 6878;
6882 -> 6879;
6883 -> 6875;
6883 -> 6879;
6884 -> 6880;
6884 -> 6879;
6885 -> 6881;
6885 -> 6879;
6886 -> 6882;
6886 -> 6879;
6887 -> 6879;
6888 -> 6884;
6888 -> 6887;
6889 -> 6885;
6889 -> 6887;
6890 -> 6886;
6890 -> 6887;
6891 -> 6883;
6891 -> 6887;
6892 -> 6887;
6893 -> 6891;
6893 -> 6892;
6894 -> 6893;
6894 -> 6887;
6895 -> 6887;
6896 -> 6894;
6896 -> 6895;
6897 -> 6888;
6897 -> 6896;
6898 -> 6889;
6898 -> 6896;
6899 -> 6890;
6899 -> 6896;
6900 -> 6896;
6901 -> 6897;
6901 -> 6900;
6902 -> 6898;
6902 -> 6900;
6903 -> 6899;
6903 -> 6900;
6904 -> 6891;
6904 -> 6900;
6905 -> 6900;
6906 -> 6904;
6906 -> 6905;
6907 -> 6906;
6907 -> 6900;
6908 -> 6900;
6909 -> 6907;
6909 -> 6908;
6910 -> 6909;
6910 -> 6900;
6911 -> 6900;
6912 -> 6904;
6912 -> 6911;
6913 -> 6912;
6913 -> 6900;
6914 -> 6900;
6915 -> 6913;
6915 -> 6914;
6916 -> 6900;
6917 -> 6904;
6917 -> 6916;
6918 -> 6917;
6918 -> 6900;
6919 -> 6900;
6920 -> 6918;
6920 -> 6919;
6921 -> 6900;
6922 -> 6904;
6922 -> 6921;
6923 -> 6921;
6923 -> 6900;
6924 -> 6900;
6925 -> 6900;
6926 -> 6904;
6926 -> 6925;
6927 -> 6925;
6928 -> 6926;
6928 -> 6927;
6929 -> 6928;
6929 -> 6922;
6929 -> 6927;
6930 -> 6929;
6930 -> 6925;
6931 -> 6925;
6932 -> 6930;
6932 -> 6931;
6933 -> 6932;
6933 -> 6925;
6934 -> 6925;
6935 -> 6933;
6935 -> 6934;
6936 -> 6932;
6936 -> 0;
6936 -> 6925;
6937 -> 6925;
6938 -> 6926;
6938 -> 6937;
6939 -> 6938;
6939 -> 6922;
6939 -> 6937;
6940 -> 6939;
6940 -> 6925;
6941 -> 6925;
6942 -> 6940;
6942 -> 6941;
6943 -> 6936;
6943 -> 6942;
6943 -> 6925;
6944 -> 6925;
6945 -> 6926;
6945 -> 6944;
6946 -> 6945;
6946 -> 6922;
6946 -> 6944;
6947 -> 6946;
6947 -> 6925;
6948 -> 6925;
6949 -> 6947;
6949 -> 6948;
6950 -> 6943;
6950 -> 6949;
6950 -> 6925;
6951 -> 6950;
6952 -> 6951;
6952 -> 6900;
6953 -> 6902;
6953 -> 6952;
6954 -> 0;
6954 -> 6953;
6955 -> 6952;
6956 -> 6954;
6956 -> 6955;
6957 -> 6904;
6957 -> 6955;
6958 -> 6955;
6959 -> 6957;
6959 -> 6958;
6960 -> 6959;
6960 -> 6955;
6961 -> 6955;
6962 -> 6960;
6962 -> 6961;
6963 -> 6956;
6963 -> 6955;
6964 -> 6963;
6964 -> 6957;
6964 -> 6922;
6964 -> 6955;
6965 -> 6955;
6966 -> 6964;
6966 -> 6965;
6967 -> 6964;
6967 -> 6965;
6968 -> 6964;
6968 -> 6965;
6969 -> 6965;
6970 -> 6968;
6970 -> 6969;
6971 -> 6970;
6971 -> 6965;
6972 -> 6965;
6973 -> 6971;
6973 -> 6972;
6974 -> 6965;
6975 -> 6973;
6975 -> 6974;
6976 -> 6965;
6977 -> 6968;
6977 -> 6976;
6978 -> 6977;
6979 -> 6977;
6980 -> 6978;
6980 -> 6979;
6981 -> 6980;
6981 -> 6977;
6982 -> 6977;
6983 -> 6981;
6983 -> 6982;
6984 -> 6982;
6984 -> 6965;
6985 -> 6967;
6985 -> 6984;
6986 -> 6984;
6987 -> 6985;
6987 -> 6986;
6988 -> 6968;
6988 -> 6986;
6989 -> 6987;
6989 -> 6986;
6990 -> 6986;
6991 -> 6989;
6991 -> 6990;
6992 -> 6988;
6992 -> 6990;
6993 -> 6991;
6993 -> 6990;
6994 -> 6990;
6995 -> 6990;
6996 -> 6992;
6996 -> 6995;
6997 -> 6995;
6998 -> 6996;
6998 -> 6997;
6999 -> 6998;
6999 -> 6995;
7000 -> 6999;
7001 -> 7000;
7001 -> 6990;
7002 -> 6994;
7002 -> 6990;
7003 -> 6992;
7004 -> 6992;
7004 -> 7003;
7005 -> 7003;
7006 -> 7004;
7006 -> 7005;
7007 -> 7006;
7007 -> 7003;
7008 -> 7003;
7008 -> 6992;
7009 -> 6992;
7010 -> 7009;
7010 -> 6992;
7011 -> 7008;
7011 -> 7010;
7011 -> 6992;
7012 -> 6992;
7012 -> 6964;
7013 -> 6992;
7014 -> 6992;
7015 -> 6992;
7016 -> 6992;
7016 -> 7015;
7017 -> 7016;
7017 -> 6964;
7017 -> 6992;
7017 -> 7015;
7018 -> 7017;
7018 -> 6992;
7019 -> 6992;
7019 -> 6990;
7020 -> 6992;
7020 -> 6990;
7021 -> 6992;
7021 -> 6990;
7022 -> 6990;
7023 -> 7021;
7023 -> 7022;
7024 -> 6990;
7025 -> 6992;
7025 -> 7024;
7026 -> 7025;
7026 -> 6990;
7027 -> 6990;
7028 -> 7026;
7028 -> 7027;
7029 -> 6992;
7029 -> 6986;
7030 -> 6986;
7031 -> 6988;
7031 -> 7030;
7032 -> 7031;
7032 -> 6992;
7032 -> 7030;
7033 -> 7032;
7033 -> 6986;
7034 -> 6986;
7035 -> 6988;
7035 -> 7034;
7036 -> 7035;
7036 -> 6992;
7036 -> 7034;
7037 -> 7036;
7037 -> 6986;
7038 -> 6986;
7039 -> 7037;
7039 -> 7038;
7040 -> 7033;
7040 -> 7039;
7040 -> 6986;
7041 -> 7029;
7041 -> 6986;
7042 -> 7041;
7042 -> 6984;
7043 -> 6964;
7043 -> 6965;
7044 -> 6901;
7044 -> 6952;
7045 -> 6952;
7046 -> 7044;
7046 -> 7045;
7047 -> 6904;
7047 -> 7045;
7048 -> 7045;
7049 -> 7047;
7049 -> 7048;
7050 -> 7049;
7050 -> 7042;
7050 -> 7048;
7051 -> 7050;
7051 -> 7045;
7052 -> 7045;
7053 -> 7051;
7053 -> 7052;
7054 -> 7053;
7055 -> 7053;
7056 -> 7054;
7056 -> 7055;
7057 -> 7056;
7057 -> 7055;
7058 -> 7055;
7059 -> 7057;
7059 -> 7058;
7060 -> 7059;
7060 -> 7058;
7061 -> 0;
7061 -> 7060;
7062 -> 7061;
7062 -> 6952;
7063 -> 7042;
7063 -> 6900;
7064 -> 6901;
7064 -> 6900;
7065 -> 6903;
7065 -> 6900;
7066 -> 6900;
7067 -> 7063;
7067 -> 7066;
7068 -> 7064;
7068 -> 7066;
7069 -> 7065;
7069 -> 7066;
7070 -> 6904;
7070 -> 7066;
7071 -> 7066;
7072 -> 7067;
7072 -> 7071;
7073 -> 7072;
7073 -> 7066;
7074 -> 7067;
7074 -> 7073;
7075 -> 7074;
7075 -> 7042;
7075 -> 7073;
7076 -> 7073;
7077 -> 7075;
7077 -> 7076;
7078 -> 7077;
7078 -> 7073;
7079 -> 7066;
7080 -> 7070;
7080 -> 7079;
7081 -> 7080;
7081 -> 7042;
7081 -> 7079;
7082 -> 7081;
7082 -> 7066;
7083 -> 7066;
7084 -> 7082;
7084 -> 7083;
7085 -> 7066;
7086 -> 7066;
7087 -> 7085;
7087 -> 7086;
7088 -> 7070;
7088 -> 7086;
7089 -> 7086;
7090 -> 7086;
7091 -> 7088;
7091 -> 7090;
7092 -> 7091;
7092 -> 7042;
7092 -> 7090;
7093 -> 7092;
7093 -> 7086;
7094 -> 7086;
7095 -> 7093;
7095 -> 7094;
7096 -> 7086;
7097 -> 7096;
7097 -> 7066;
7098 -> 7066;
7099 -> 7067;
7099 -> 7098;
7099 -> 7066;
7100 -> 7069;
7100 -> 7099;
7101 -> 7099;
7102 -> 7099;
7103 -> 7100;
7103 -> 7102;
7104 -> 7101;
7104 -> 7102;
7105 -> 7070;
7105 -> 7102;
7106 -> 7102;
7107 -> 7102;
7108 -> 7105;
7108 -> 7107;
7109 -> 7107;
7110 -> 7109;
7110 -> 7102;
7111 -> 7102;
7112 -> 7111;
7112 -> 7099;
7113 -> 7067;
7113 -> 7112;
7114 -> 7112;
7115 -> 7112;
7116 -> 7113;
7116 -> 7115;
7117 -> 7114;
7117 -> 7115;
7118 -> 7114;
7118 -> 7115;
7119 -> 7070;
7119 -> 7115;
7120 -> 7115;
7121 -> 7116;
7121 -> 7115;
7122 -> 7116;
7122 -> 7042;
7122 -> 7115;
7123 -> 7119;
7123 -> 7042;
7123 -> 7115;
7124 -> 7121;
7124 -> 7122;
7125 -> 7122;
7126 -> 7124;
7126 -> 7125;
7127 -> 7068;
7127 -> 7125;
7128 -> 7125;
7129 -> 7126;
7129 -> 7128;
7130 -> 7127;
7130 -> 7128;
7131 -> 7070;
7131 -> 7128;
7132 -> 7128;
7133 -> 7132;
7134 -> 7131;
7134 -> 7133;
7135 -> 7134;
7135 -> 7132;
7136 -> 7132;
7137 -> 7135;
7137 -> 7136;
7138 -> 7132;
7139 -> 7132;
7140 -> 7137;
7140 -> 7132;
7141 -> 7132;
7142 -> 7140;
7142 -> 7141;
7143 -> 7142;
7143 -> 7141;
7144 -> 7141;
7145 -> 7143;
7145 -> 7144;
7146 -> 7145;
7146 -> 7144;
7147 -> 7144;
7148 -> 7146;
7148 -> 7147;
7149 -> 7148;
7149 -> 7147;
7150 -> 0;
7150 -> 7149;
7151 -> 7137;
7151 -> 7150;
7152 -> 7150;
7153 -> 7151;
7153 -> 7152;
7154 -> 7153;
7154 -> 7152;
7155 -> 7152;
7156 -> 7154;
7156 -> 7155;
7157 -> 7156;
7157 -> 7155;
7158 -> 7157;
7159 -> 7137;
7159 -> 0;
7159 -> 7158;
7160 -> 7137;
7160 -> 0;
7160 -> 7159;
7161 -> 7137;
7161 -> 0;
7161 -> 7160;
7162 -> 7128;
7163 -> 7131;
7163 -> 7162;
7164 -> 7163;
7164 -> 7128;
7165 -> 7128;
7166 -> 7164;
7166 -> 7165;
7167 -> 7129;
7167 -> 7125;
7168 -> 7167;
7168 -> 7070;
7168 -> 7042;
7168 -> 7125;
7169 -> 7125;
7170 -> 7168;
7170 -> 7169;
7171 -> 7168;
7171 -> 7169;
7172 -> 7168;
7172 -> 7169;
7173 -> 7168;
7173 -> 7169;
7174 -> 7170;
7174 -> 7169;
7175 -> 7171;
7175 -> 7169;
7176 -> 7172;
7176 -> 7169;
7177 -> 7169;
7178 -> 7176;
7178 -> 7177;
7179 -> 7178;
7179 -> 7168;
7179 -> 7177;
7180 -> 7178;
7180 -> 7168;
7180 -> 7177;
7181 -> 7177;
7181 -> 7169;
7182 -> 7173;
7182 -> 7169;
7183 -> 7174;
7183 -> 7175;
7183 -> 7181;
7183 -> 7182;
7183 -> 7168;
7183 -> 7169;
7184 -> 7183;
7184 -> 7169;
7185 -> 7183;
7185 -> 7169;
7186 -> 7184;
7186 -> 7169;
7187 -> 7184;
7187 -> 7169;
7188 -> 6900;
7189 -> 7183;
7189 -> 7188;
7189 -> 6900;
7190 -> 7183;
7190 -> 7189;
7191 -> 6923;
7191 -> 7189;
7192 -> 7189;
7193 -> 7191;
7193 -> 7192;
7194 -> 7193;
7194 -> 6922;
7194 -> 7192;
7195 -> 7194;
7195 -> 7192;
7196 -> 7192;
7196 -> 7183;
7196 -> 7195;
7196 -> 6922;
7197 -> 7192;
7198 -> 7192;
7199 -> 7189;
7200 -> 6879;
7201 -> 6883;
7201 -> 7200;
7202 -> 7201;
7202 -> 7183;
7202 -> 7200;
7203 -> 7202;
7203 -> 6879;
7204 -> 6879;
7205 -> 7203;
7205 -> 7204;
7206 -> 7190;
7206 -> 6879;
7207 -> 6871;
7208 -> 6875;
7208 -> 7207;
7209 -> 7208;
7209 -> 7183;
7209 -> 7207;
7210 -> 7209;
7210 -> 6871;
7211 -> 6871;
7212 -> 7210;
7212 -> 7211;
7213 -> 7206;
7213 -> 6871;
7214 -> 7213;
7214 -> 6859;
7215 -> 7213;
7215 -> 6859;
7216 -> 7215;
7216 -> 6857;
7217 -> 6857;
7218 -> 7216;
7218 -> 7217;
7219 -> 6858;
7219 -> 7217;
7220 -> 7217;
7221 -> 7218;
7221 -> 7220;
7222 -> 7221;
7222 -> 7217;
7223 -> 7218;
7223 -> 7222;
7224 -> 7223;
7224 -> 6856;
7225 -> 6856;
7226 -> 7225;
7226 -> 7183;
7227 -> 7226;
7227 -> 6856;
7228 -> 6856;
7229 -> 7227;
7229 -> 7228;
7230 -> 6856;
7231 -> 7224;
7231 -> 7230;
7232 -> 7231;
7232 -> 6856;
7233 -> 7224;
7233 -> 6856;
7234 -> 0;
7234 -> 7233;
7235 -> 7233;
7236 -> 7234;
7236 -> 7235;
7237 -> 7236;
7237 -> 7235;
7238 -> 7235;
7239 -> 7237;
7239 -> 7238;
7240 -> 7239;
7240 -> 0;
7240 -> 7238;
7241 -> 7240;
7242 -> 7236;
7243 -> 7236;
7244 -> 6850;
7244 -> 7233;
7245 -> 7224;
7245 -> 7233;
7246 -> 7236;
7246 -> 7233;
7247 -> 7244;
7247 -> 7245;
7247 -> 7246;
7247 -> 6831;
7247 -> 7183;
7247 -> 7192;
7247 -> 7236;
7247 -> 7233;
7248 -> 7233;
7249 -> 7247;
7249 -> 7248;
7250 -> 7249;
7250 -> 7248;
7251 -> 7250;
7251 -> 7247;
7251 -> 7248;
7252 -> 7250;
7252 -> 7247;
7252 -> 7248;
7253 -> 7249;
7253 -> 7248;
7254 -> 7249;
7254 -> 7248;
7255 -> 7253;
7255 -> 7248;
7256 -> 7253;
7256 -> 7248;
7257 -> 7249;
7257 -> 6830;
7258 -> 6830;
7259 -> 6831;
7259 -> 7258;
7260 -> 7259;
7260 -> 7257;
7260 -> 7258;
7261 -> 7259;
7261 -> 7257;
7261 -> 7258;
7262 -> 7261;
7262 -> 6830;
7263 -> 7262;
7264 -> 7262;
7265 -> 7262;
7266 -> 7262;
7267 -> 7262;
7268 -> 7262;
7269 -> 7262;
7269 -> 7257;
7270 -> 7262;
7271 -> 7262;
7272 -> 7270;
7272 -> 7262;
7273 -> 7271;
7273 -> 7262;
7274 -> 7272;
7274 -> 7262;
7275 -> 7273;
7275 -> 7262;
7276 -> 7274;
7276 -> 7262;
7277 -> 7275;
7277 -> 7262;
7278 -> 7276;
7278 -> 7262;
7279 -> 7277;
7279 -> 7262;
7280 -> 7262;
7281 -> 7280;
7281 -> 7262;
7282 -> 7262;
7283 -> 7281;
7283 -> 7282;
7284 -> 7283;
7284 -> 7262;
7285 -> 7262;
7286 -> 7285;
7286 -> 7262;
7287 -> 7262;
7288 -> 7286;
7288 -> 7287;
7289 -> 7262;
7290 -> 7289;
7290 -> 7262;
7291 -> 7262;
7292 -> 7290;
7292 -> 7291;
7293 -> 7262;
7294 -> 7262;
7295 -> 7280;
7295 -> 7262;
7296 -> 7262;
7297 -> 7295;
7297 -> 7296;
7298 -> 7280;
7298 -> 7287;
7299 -> 7276;
7299 -> 7298;
7300 -> 7298;
7301 -> 7300;
7301 -> 7298;
7302 -> 7298;
7303 -> 7301;
7303 -> 7302;
7304 -> 7299;
7304 -> 7298;
7305 -> 7299;
7305 -> 7298;
7306 -> 7298;
7307 -> 7299;
7307 -> 7306;
7308 -> 7307;
7308 -> 7298;
7309 -> 7298;
7310 -> 7308;
7310 -> 7309;
7311 -> 7298;
7312 -> 7310;
7312 -> 7311;
7313 -> 7299;
7314 -> 7299;
7315 -> 7313;
7315 -> 7314;
7316 -> 7315;
7316 -> 7299;
7317 -> 7305;
7317 -> 7299;
7318 -> 7317;
7318 -> 7299;
7319 -> 7318;
7319 -> 7299;
7320 -> 7299;
7321 -> 7299;
7322 -> 7299;
7322 -> 7321;
7323 -> 7321;
7324 -> 7322;
7324 -> 7323;
7325 -> 7324;
7325 -> 7321;
7326 -> 7325;
7327 -> 7326;
7327 -> 7299;
7328 -> 7320;
7328 -> 7299;
7329 -> 7299;
7330 -> 7299;
7330 -> 7329;
7331 -> 7329;
7332 -> 7330;
7332 -> 7331;
7333 -> 7332;
7333 -> 7329;
7334 -> 7329;
7334 -> 7299;
7335 -> 7299;
7336 -> 7335;
7336 -> 7299;
7337 -> 7334;
7337 -> 7336;
7337 -> 7299;
7338 -> 7299;
7339 -> 7299;
7340 -> 7299;
7341 -> 7299;
7342 -> 7299;
7342 -> 7341;
7343 -> 7342;
7343 -> 7299;
7343 -> 7341;
7344 -> 7343;
7344 -> 7299;
7345 -> 7320;
7345 -> 7299;
7346 -> 7299;
7346 -> 7320;
7347 -> 7320;
7347 -> 7299;
7348 -> 7299;
7349 -> 7347;
7349 -> 7348;
7350 -> 7299;
7351 -> 7350;
7351 -> 7320;
7352 -> 7351;
7352 -> 7299;
7353 -> 7299;
7354 -> 7352;
7354 -> 7353;
7355 -> 7299;
7356 -> 7355;
7356 -> 7320;
7357 -> 7356;
7357 -> 7299;
7358 -> 7299;
7359 -> 7358;
7359 -> 7320;
7360 -> 7359;
7360 -> 7299;
7361 -> 7299;
7362 -> 7360;
7362 -> 7361;
7363 -> 7357;
7363 -> 7362;
7363 -> 7299;
7364 -> 7299;
7364 -> 7298;
7365 -> 7278;
7365 -> 7298;
7366 -> 7298;
7367 -> 7365;
7367 -> 7366;
7368 -> 7262;
7368 -> 7366;
7369 -> 7366;
7370 -> 7368;
7370 -> 7369;
7371 -> 7370;
7371 -> 7320;
7371 -> 7369;
7372 -> 7371;
7372 -> 7366;
7373 -> 7366;
7374 -> 7372;
7374 -> 7373;
7375 -> 7374;
7376 -> 7374;
7377 -> 7375;
7377 -> 7376;
7378 -> 7377;
7378 -> 7376;
7379 -> 7376;
7380 -> 7378;
7380 -> 7379;
7381 -> 7380;
7381 -> 7379;
7382 -> 0;
7382 -> 7381;
7383 -> 7382;
7383 -> 7298;
7384 -> 7278;
7384 -> 7262;
7385 -> 7279;
7385 -> 7262;
7386 -> 7262;
7387 -> 7320;
7387 -> 7386;
7388 -> 7387;
7388 -> 7262;
7389 -> 7320;
7389 -> 7388;
7390 -> 7389;
7390 -> 7320;
7390 -> 7388;
7391 -> 7388;
7392 -> 7390;
7392 -> 7391;
7393 -> 7392;
7393 -> 7388;
7394 -> 7262;
7395 -> 7394;
7395 -> 7320;
7396 -> 7395;
7396 -> 7262;
7397 -> 7262;
7398 -> 7396;
7398 -> 7397;
7399 -> 7262;
7400 -> 7262;
7401 -> 7399;
7401 -> 7400;
7402 -> 7262;
7402 -> 7400;
7403 -> 7400;
7404 -> 7400;
7405 -> 7402;
7405 -> 7404;
7406 -> 7405;
7406 -> 7320;
7406 -> 7404;
7407 -> 7406;
7407 -> 7400;
7408 -> 7400;
7409 -> 7407;
7409 -> 7408;
7410 -> 7400;
7411 -> 7410;
7411 -> 7262;
7412 -> 7385;
7412 -> 7320;
7413 -> 7412;
7413 -> 7320;
7414 -> 7320;
7415 -> 7262;
7415 -> 7320;
7416 -> 7320;
7417 -> 7320;
7418 -> 7415;
7418 -> 7417;
7419 -> 7417;
7420 -> 7419;
7420 -> 7320;
7421 -> 7320;
7422 -> 7320;
7423 -> 7262;
7423 -> 7320;
7424 -> 7320;
7425 -> 7384;
7425 -> 7320;
7426 -> 7425;
7426 -> 7320;
7427 -> 7262;
7427 -> 7320;
7428 -> 7320;
7429 -> 7428;
7430 -> 7427;
7430 -> 7429;
7431 -> 7430;
7431 -> 7428;
7432 -> 7428;
7433 -> 7431;
7433 -> 7432;
7434 -> 7428;
7435 -> 7428;
7436 -> 7433;
7436 -> 7428;
7437 -> 7428;
7438 -> 7436;
7438 -> 7437;
7439 -> 7438;
7439 -> 7437;
7440 -> 7437;
7441 -> 7439;
7441 -> 7440;
7442 -> 7441;
7442 -> 7440;
7443 -> 7440;
7444 -> 7442;
7444 -> 7443;
7445 -> 7444;
7445 -> 7443;
7446 -> 0;
7446 -> 7445;
7447 -> 7433;
7447 -> 7446;
7448 -> 7446;
7449 -> 7447;
7449 -> 7448;
7450 -> 7449;
7450 -> 7448;
7451 -> 7448;
7452 -> 7450;
7452 -> 7451;
7453 -> 7452;
7453 -> 7451;
7454 -> 7453;
7455 -> 7433;
7455 -> 0;
7455 -> 7454;
7456 -> 7433;
7456 -> 0;
7456 -> 7455;
7457 -> 7433;
7457 -> 0;
7457 -> 7456;
7458 -> 7320;
7459 -> 7427;
7459 -> 7458;
7460 -> 7459;
7460 -> 7320;
7461 -> 7320;
7462 -> 7460;
7462 -> 7461;
7463 -> 7320;
7464 -> 7463;
7464 -> 7320;
7465 -> 7464;
7465 -> 7320;
7466 -> 7464;
7466 -> 7320;
7467 -> 7463;
7468 -> 7463;
7469 -> 7467;
7469 -> 7463;
7470 -> 7467;
7470 -> 7463;
7471 -> 7293;
7471 -> 7463;
7472 -> 7471;
7472 -> 7463;
7473 -> 7472;
7473 -> 7262;
7473 -> 7463;
7474 -> 7473;
7474 -> 7463;
7475 -> 7463;
7475 -> 7474;
7475 -> 7262;
7476 -> 7463;
7477 -> 7463;
7478 -> 7463;
7479 -> 7262;
7480 -> 7479;
7480 -> 7463;
7481 -> 7480;
7481 -> 7262;
7482 -> 7262;
7483 -> 7481;
7483 -> 7482;
7484 -> 7262;
7485 -> 7484;
7485 -> 7463;
7486 -> 7485;
7486 -> 7262;
7487 -> 7262;
7488 -> 7486;
7488 -> 7487;
7489 -> 7463;
7489 -> 7262;
7490 -> 7262;
7491 -> 7262;
7492 -> 7491;
7492 -> 7463;
7493 -> 7492;
7493 -> 7262;
7494 -> 7262;
7495 -> 7493;
7495 -> 7494;
7496 -> 7262;
7497 -> 7463;
7497 -> 7496;
7498 -> 7497;
7498 -> 7262;
7499 -> 7463;
7500 -> 7463;
7501 -> 7499;
7501 -> 7500;
7502 -> 7501;
7502 -> 0;
7502 -> 7500;
7503 -> 7502;
7504 -> 7463;
7505 -> 7463;
7506 -> 7463;
7507 -> 7463;
7508 -> 7507;
7508 -> 7463;
7509 -> 7507;
7509 -> 7463;
7510 -> 7259;
7510 -> 7463;
7510 -> 7258;
7511 -> 7258;
7512 -> 7259;
7512 -> 7511;
7513 -> 7512;
7513 -> 7463;
7513 -> 7511;
7514 -> 7258;
7515 -> 7513;
7515 -> 7514;
7516 -> 6830;
7517 -> 6835;
7517 -> 7463;
7517 -> 7516;
7517 -> 6830;
7518 -> 7517;
7518 -> 6830;
7519 -> 6836;
7519 -> 6830;
7520 -> 6830;
7521 -> 6830;
7522 -> 7518;
7522 -> 7521;
7523 -> 7519;
7523 -> 7521;
7524 -> 7520;
7524 -> 7521;
7525 -> 6831;
7525 -> 7521;
7526 -> 7525;
7526 -> 7517;
7526 -> 7521;
7527 -> 7525;
7527 -> 7517;
7527 -> 0;
7527 -> 7521;
7528 -> 7527;
7528 -> 7525;
7528 -> 7521;
7529 -> 7524;
7529 -> 7521;
7530 -> 7525;
7530 -> 7517;
7530 -> 7528;
7530 -> 0;
7530 -> 7529;
7531 -> 7530;
7531 -> 7525;
7531 -> 7529;
7532 -> 7521;
7533 -> 7521;
7534 -> 7525;
7534 -> 7533;
7535 -> 7534;
7535 -> 7517;
7535 -> 7533;
7536 -> 7535;
7536 -> 7521;
7537 -> 7521;
7538 -> 7536;
7538 -> 7537;
7539 -> 7521;
7540 -> 7525;
7540 -> 7539;
7541 -> 7540;
7541 -> 7517;
7541 -> 7539;
7542 -> 7541;
7542 -> 7521;
7543 -> 7521;
7544 -> 7542;
7544 -> 7543;
7545 -> 7538;
7545 -> 7544;
7545 -> 7521;
7546 -> 7521;
7547 -> 7525;
7547 -> 7546;
7548 -> 7547;
7548 -> 7517;
7548 -> 7546;
7549 -> 7546;
7550 -> 7547;
7550 -> 7549;
7551 -> 7550;
7551 -> 7517;
7551 -> 7549;
7552 -> 7546;
7553 -> 7551;
7553 -> 7552;
7554 -> 7553;
7554 -> 7521;
7555 -> 7524;
7555 -> 7554;
7555 -> 7521;
7556 -> 7545;
7556 -> 7555;
7556 -> 7521;
7557 -> 7532;
7557 -> 7521;
7558 -> 7521;
7559 -> 7521;
7560 -> 7557;
7560 -> 7559;
7561 -> 7558;
7561 -> 7559;
7562 -> 7525;
7562 -> 7559;
7563 -> 7562;
7563 -> 7517;
7563 -> 7559;
7564 -> 7563;
7564 -> 7560;
7564 -> 7559;
7565 -> 7556;
7565 -> 7564;
7565 -> 7521;
7566 -> 7565;
7567 -> 7565;
7568 -> 7566;
7568 -> 7567;
7569 -> 7525;
7569 -> 7567;
7570 -> 7567;
7571 -> 7569;
7571 -> 7570;
7572 -> 7571;
7572 -> 7567;
7573 -> 7567;
7574 -> 7572;
7574 -> 7573;
7575 -> 7574;
7575 -> 7567;
7576 -> 7575;
7577 -> 7576;
7577 -> 7565;
7578 -> 7577;
7579 -> 7578;
7579 -> 7517;
7579 -> 7528;
7579 -> 7531;
7580 -> 7579;
7580 -> 7578;
7581 -> 7578;
7582 -> 7580;
7582 -> 7581;
7583 -> 7582;
7583 -> 7578;
7584 -> 7578;
7585 -> 7584;
7585 -> 7578;
7586 -> 7579;
7586 -> 7578;
7587 -> 7585;
7587 -> 7578;
7588 -> 7586;
7588 -> 7578;
7589 -> 7587;
7589 -> 7578;
7590 -> 7578;
7591 -> 7588;
7591 -> 7590;
7592 -> 7589;
7592 -> 7590;
7593 -> 7578;
7593 -> 7590;
7594 -> 7590;
7595 -> 7593;
7595 -> 7594;
7596 -> 7594;
7597 -> 7595;
7597 -> 7596;
7598 -> 7597;
7598 -> 7579;
7598 -> 7596;
7599 -> 7598;
7599 -> 7594;
7600 -> 7599;
7601 -> 7600;
7601 -> 7590;
7602 -> 7601;
7602 -> 7578;
7603 -> 7578;
7604 -> 7578;
7604 -> 7579;
7605 -> 7578;
7606 -> 7586;
7606 -> 7579;
7607 -> 7579;
7608 -> 7607;
7609 -> 7607;
7610 -> 7607;
7610 -> 7579;
7611 -> 7606;
7611 -> 7610;
7611 -> 7578;
7611 -> 7579;
7611 -> 7607;
7612 -> 7579;
7613 -> 7611;
7613 -> 7612;
7614 -> 7611;
7614 -> 7612;
7615 -> 7611;
7615 -> 7612;
7616 -> 7611;
7616 -> 7612;
7617 -> 7611;
7617 -> 7612;
7618 -> 7613;
7618 -> 7612;
7619 -> 7614;
7619 -> 7612;
7620 -> 7615;
7620 -> 7612;
7621 -> 7616;
7621 -> 7612;
7622 -> 7612;
7623 -> 7621;
7623 -> 7622;
7624 -> 7623;
7624 -> 7611;
7624 -> 7622;
7625 -> 7623;
7625 -> 7611;
7625 -> 7622;
7626 -> 7622;
7626 -> 7612;
7627 -> 7617;
7627 -> 7612;
7628 -> 7618;
7628 -> 7619;
7628 -> 7620;
7628 -> 7626;
7628 -> 7627;
7628 -> 7611;
7628 -> 7612;
7629 -> 7628;
7629 -> 7612;
7630 -> 7628;
7630 -> 7612;
7631 -> 7629;
7631 -> 7612;
7632 -> 7629;
7632 -> 7612;
7633 -> 7578;
7633 -> 7628;
7633 -> 7579;
7634 -> 7603;
7634 -> 7579;
7635 -> 7579;
7636 -> 7634;
7636 -> 7635;
7637 -> 7636;
7637 -> 7579;
7637 -> 7635;
7638 -> 7637;
7638 -> 7635;
7639 -> 7635;
7639 -> 7628;
7639 -> 7638;
7639 -> 7579;
7640 -> 7635;
7640 -> 7628;
7641 -> 7635;
7642 -> 7635;
7642 -> 7628;
7642 -> 7640;
7642 -> 7641;
7643 -> 7635;
7644 -> 7579;
7645 -> 7628;
7645 -> 7577;
7646 -> 7577;
7647 -> 7645;
7647 -> 7646;
7647 -> 7577;
7648 -> 7645;
7648 -> 7647;
7649 -> 7523;
7649 -> 7648;
7649 -> 6836;
7649 -> 7628;
7649 -> 7633;
7649 -> 7640;
7649 -> 7647;
7650 -> 7565;
7650 -> 7649;
7651 -> 7526;
7651 -> 7525;
7651 -> 7649;
7652 -> 6830;
7653 -> 6835;
7653 -> 7649;
7653 -> 7652;
7653 -> 6830;
7654 -> 7522;
7654 -> 7653;
7654 -> 6830;
7655 -> 7654;
7655 -> 6830;
7656 -> 6836;
7656 -> 6830;
7657 -> 7655;
7657 -> 7656;
7657 -> 6831;
7657 -> 7649;
7657 -> 6836;
7657 -> 7651;
7657 -> 6830;
7658 -> 6830;
7659 -> 7657;
7659 -> 7658;
7660 -> 7658;
7661 -> 7659;
7661 -> 7660;
7662 -> 7661;
7662 -> 7657;
7662 -> 7660;
7663 -> 7661;
7663 -> 7657;
7663 -> 7660;
7664 -> 7660;
7664 -> 7658;
7665 -> 7659;
7665 -> 7658;
7666 -> 7659;
7666 -> 7658;
7667 -> 7665;
7667 -> 7658;
7668 -> 7665;
7668 -> 7658;
7669 -> 6836;
7669 -> 6830;
7670 -> 6831;
7670 -> 7659;
7670 -> 7669;
7670 -> 6836;
7670 -> 6830;
7671 -> 7654;
7671 -> 6830;
7672 -> 6831;
7672 -> 7670;
7672 -> 7671;
7672 -> 6830;
7673 -> 7659;
7673 -> 6829;
7674 -> 7673;
7674 -> 6829;
7675 -> 6819;
7675 -> 7674;
7675 -> 7672;
7675 -> 6829;
7676 -> 6820;
7677 -> 6821;
7677 -> 7676;
7678 -> 6820;
7679 -> 0;
7679 -> 5479;
7680 -> 5479;
7681 -> 7679;
7681 -> 7680;
7682 -> 5481;
7682 -> 7680;
7683 -> 7681;
7683 -> 7680;
7684 -> 7680;
7685 -> 7683;
7685 -> 7684;
7686 -> 7685;
7686 -> 0;
7686 -> 7684;
7687 -> 7686;
7688 -> 7680;
7689 -> 7682;
7689 -> 7688;
7690 -> 7689;
7690 -> 7675;
7690 -> 7688;
7691 -> 7680;
7692 -> 7690;
7692 -> 7681;
7692 -> 7680;
7693 -> 7692;
7693 -> 7675;
7694 -> 7692;
7695 -> 7692;
7696 -> 5480;
7696 -> 5479;
7697 -> 5516;
7697 -> 5479;
7698 -> 6798;
7698 -> 5479;
7699 -> 6799;
7699 -> 5479;
7700 -> 6800;
7700 -> 5479;
7701 -> 6816;
7701 -> 5479;
7702 -> 6819;
7702 -> 5479;
7703 -> 7692;
7703 -> 5479;
7704 -> 7696;
7704 -> 7697;
7704 -> 7698;
7704 -> 7699;
7704 -> 7700;
7704 -> 7701;
7704 -> 7702;
7704 -> 7703;
7704 -> 5481;
7704 -> 7675;
7704 -> 5412;
7704 -> 7692;
7704 -> 5479;
7705 -> 5479;
7706 -> 7705;
7707 -> 7706;
7707 -> 7705;
7708 -> 7704;
7708 -> 7705;
7709 -> 7704;
7709 -> 7705;
7710 -> 7708;
7710 -> 7704;
7710 -> 7705;
7711 -> 7708;
7711 -> 7704;
7711 -> 7705;
7712 -> 6819;
7712 -> 5479;
7713 -> 5481;
7713 -> 7704;
7713 -> 7712;
7713 -> 5479;
7714 -> 5467;
7714 -> 5477;
7715 -> 5477;
7716 -> 7714;
7716 -> 7715;
7717 -> 5420;
7717 -> 7715;
7718 -> 7716;
7718 -> 5462;
7718 -> 7715;
7719 -> 7715;
7720 -> 7718;
7720 -> 7719;
7721 -> 7717;
7721 -> 7719;
7722 -> 7721;
7722 -> 7713;
7722 -> 7720;
7722 -> 5451;
7722 -> 7719;
7723 -> 7719;
7724 -> 7721;
7724 -> 7713;
7724 -> 7723;
7724 -> 7719;
7725 -> 7724;
7726 -> 7725;
7726 -> 7721;
7726 -> 7724;
7727 -> 7715;
7728 -> 5477;
7729 -> 7726;
7729 -> 890;
7730 -> 894;
7730 -> 890;
7731 -> 7729;
7731 -> 7730;
7732 -> 7730;
7733 -> 7731;
7733 -> 7732;
7734 -> 5374;
7734 -> 7732;
7735 -> 7732;
7736 -> 7734;
7736 -> 7735;
7737 -> 7735;
7738 -> 7736;
7738 -> 7737;
7739 -> 7738;
7739 -> 7726;
7739 -> 7737;
7740 -> 7737;
7741 -> 7738;
7741 -> 7726;
7741 -> 7740;
7741 -> 7737;
7742 -> 7741;
7742 -> 7732;
7743 -> 7732;
7744 -> 7742;
7744 -> 7743;
7745 -> 7733;
7745 -> 7744;
7746 -> 7745;
7746 -> 890;
7747 -> 7745;
7747 -> 7726;
7747 -> 7741;
7747 -> 890;
7748 -> 890;
7749 -> 7747;
7749 -> 7748;
7750 -> 7747;
7750 -> 7748;
7751 -> 7747;
7751 -> 7748;
7752 -> 7746;
7752 -> 7748;
7753 -> 7749;
7753 -> 7748;
7754 -> 7750;
7754 -> 7748;
7755 -> 7751;
7755 -> 7748;
7756 -> 7748;
7757 -> 7756;
7757 -> 7753;
7757 -> 7754;
7757 -> 7755;
7757 -> 7747;
7757 -> 7748;
7758 -> 7757;
7758 -> 1;
7759 -> 0;
7759 -> 1;
7760 -> 1;
7761 -> 7757;
7761 -> 7760;
7762 -> 7761;
7762 -> 7757;
7762 -> 7760;
7763 -> 7762;
7763 -> 1;
7764 -> 206;
7764 -> 1;
7765 -> 7757;
7765 -> 1;
7766 -> 1;
7767 -> 7765;
7767 -> 7766;
7768 -> 7766;
7769 -> 7765;
7769 -> 7768;
7769 -> 1;
7770 -> 7765;
7770 -> 7766;
7771 -> 7765;
7771 -> 7766;
7772 -> 7765;
7772 -> 7766;
7773 -> 7765;
7773 -> 7766;
7774 -> 7771;
7774 -> 7766;
7775 -> 7766;
7776 -> 7773;
7776 -> 7775;
7777 -> 7775;
7778 -> 7776;
7778 -> 7777;
7779 -> 7778;
7779 -> 7769;
7779 -> 7777;
7780 -> 7779;
7780 -> 7775;
7781 -> 7775;
7782 -> 7780;
7782 -> 7781;
7783 -> 7782;
7783 -> 7781;
7784 -> 7783;
7785 -> 7784;
7785 -> 7766;
7786 -> 7770;
7786 -> 7785;
7786 -> 7769;
7786 -> 7766;
7787 -> 7772;
7787 -> 7766;
7788 -> 7787;
7789 -> 7773;
7789 -> 7788;
7790 -> 7789;
7790 -> 7786;
7790 -> 7788;
7791 -> 7790;
7791 -> 7787;
7792 -> 7787;
7793 -> 7791;
7793 -> 7792;
7793 -> 7787;
7794 -> 7770;
7794 -> 7793;
7795 -> 7793;
7796 -> 7794;
7796 -> 7795;
7797 -> 7795;
7798 -> 7794;
7798 -> 7795;
7799 -> 7794;
7799 -> 7795;
7800 -> 7799;
7800 -> 7797;
7800 -> 7795;
7801 -> 7798;
7801 -> 7800;
7801 -> 7797;
7801 -> 7795;
7802 -> 7774;
7803 -> 7773;
7803 -> 7802;
7804 -> 7802;
7805 -> 7804;
7805 -> 7774;
7806 -> 7774;
7807 -> 7805;
7807 -> 7806;
7807 -> 7774;
7808 -> 7801;
7809 -> 7773;
7809 -> 7788;
7810 -> 7788;
7810 -> 7787;
7811 -> 7810;
7811 -> 7792;
7811 -> 7787;
7812 -> 7773;
7812 -> 7775;
7813 -> 7812;
7813 -> 7808;
7813 -> 7775;
7814 -> 7773;
7814 -> 7802;
7815 -> 7814;
7815 -> 7813;
7815 -> 7802;
7816 -> 7815;
7816 -> 7774;
7817 -> 7816;
7817 -> 7806;
7817 -> 7774;
7818 -> 7813;
7819 -> 7818;
7820 -> 7814;
7820 -> 7818;
7820 -> 7802;
7821 -> 7820;
7821 -> 7774;
7822 -> 7821;
7822 -> 7806;
7822 -> 7774;
7823 -> 7818;
7824 -> 7823;
7825 -> 7814;
7825 -> 7823;
7825 -> 7802;
7826 -> 7825;
7826 -> 7774;
7827 -> 7826;
7827 -> 7806;
7827 -> 7774;
7828 -> 7823;
7829 -> 7828;
7830 -> 7814;
7830 -> 7828;
7830 -> 7802;
7831 -> 7830;
7831 -> 7774;
7832 -> 7831;
7832 -> 7806;
7832 -> 7774;
7833 -> 7828;
7834 -> 7833;
7835 -> 7814;
7835 -> 7833;
7835 -> 7802;
7836 -> 7835;
7836 -> 7774;
7837 -> 7836;
7837 -> 7806;
7837 -> 7774;
7838 -> 7833;
7839 -> 7838;
7840 -> 7838;
7841 -> 1;
7842 -> 7757;
7842 -> 1;
7843 -> 1;
7844 -> 7842;
7844 -> 7843;
7845 -> 7844;
7845 -> 7840;
7845 -> 7843;
7846 -> 7843;
7847 -> 7843;
7848 -> 7845;
7848 -> 7847;
7849 -> 7846;
7849 -> 7847;
7850 -> 7847;
7851 -> 7848;
7851 -> 7847;
7852 -> 7851;
7852 -> 7847;
7853 -> 7850;
7853 -> 7847;
7854 -> 7853;
7854 -> 7843;
7855 -> 7854;
7855 -> 1;
7856 -> 7757;
7856 -> 1;
7857 -> 1;
7858 -> 7856;
7858 -> 7851;
7858 -> 1;
7859 -> 1;
7860 -> 7858;
7860 -> 7859;
7861 -> 7859;
7862 -> 7861;
7862 -> 1;
7863 -> 7858;
7863 -> 7862;
7863 -> 1;
7864 -> 0;
7864 -> 1;
7865 -> 7856;
7865 -> 7863;
7865 -> 1;
7866 -> 1;
7867 -> 7865;
7867 -> 7866;
7868 -> 7866;
7869 -> 7868;
7869 -> 1;
7870 -> 7865;
7870 -> 7869;
7870 -> 1;
7871 -> 1;
7872 -> 7856;
7872 -> 7870;
7872 -> 1;
7873 -> 1;
7874 -> 7872;
7874 -> 7873;
7875 -> 7873;
7876 -> 7875;
7876 -> 1;
7877 -> 7872;
7877 -> 7876;
7877 -> 1;
7878 -> 7856;
7878 -> 7877;
7878 -> 1;
7879 -> 1;
7880 -> 7878;
7880 -> 7879;
7881 -> 7878;
7881 -> 7879;
7882 -> 7878;
7882 -> 7879;
7883 -> 7878;
7883 -> 7879;
7884 -> 7879;
7885 -> 1;
7886 -> 1;
7887 -> 7856;
7887 -> 7880;
7887 -> 7886;
7888 -> 7886;
7889 -> 7887;
7889 -> 7880;
7889 -> 7888;
7890 -> 7889;
7890 -> 7886;
7891 -> 7890;
7891 -> 1;
7892 -> 1;
7893 -> 7856;
7893 -> 7880;
7893 -> 1;
7894 -> 1;
7895 -> 7893;
7895 -> 7894;
7896 -> 7894;
7897 -> 7896;
7897 -> 1;
7898 -> 7893;
7898 -> 7897;
7898 -> 1;
7899 -> 1;
7900 -> 7856;
7900 -> 7898;
7900 -> 1;
7901 -> 1;
7902 -> 7900;
7902 -> 7901;
7903 -> 7901;
7904 -> 7903;
7904 -> 1;
7905 -> 7900;
7905 -> 7904;
7905 -> 1;
7906 -> 1;
7907 -> 7856;
7907 -> 7905;
7907 -> 1;
7908 -> 1;
7909 -> 7907;
7909 -> 7908;
7910 -> 7907;
7910 -> 7908;
7911 -> 7907;
7911 -> 7908;
7912 -> 7907;
7912 -> 7908;
7913 -> 7908;
7914 -> 1;
7915 -> 7856;
7915 -> 7909;
7915 -> 7914;
7915 -> 1;
7916 -> 1;
7917 -> 7856;
7917 -> 7915;
7917 -> 7916;
7917 -> 1;
7918 -> 1;
7919 -> 7917;
7919 -> 7918;
7920 -> 7917;
7920 -> 7918;
7921 -> 7917;
7921 -> 7918;
7922 -> 7917;
7922 -> 7918;
7923 -> 7918;
7924 -> 7917;
7924 -> 7918;
7925 -> 7918;
7926 -> 7925;
7926 -> 1;
7927 -> 0;
7927 -> 1;
7928 -> 1;
7929 -> 7856;
7929 -> 7919;
7929 -> 7928;
7929 -> 1;
7930 -> 1;
7931 -> 7929;
7931 -> 7930;
7932 -> 7930;
7933 -> 7932;
7933 -> 1;
7934 -> 7929;
7934 -> 7933;
7934 -> 1;
7935 -> 1;
7936 -> 7856;
7936 -> 7934;
7936 -> 7935;
7936 -> 1;
7937 -> 7936;
7937 -> 1;
7938 -> 7936;
7938 -> 1;
7939 -> 1;
7940 -> 7938;
7940 -> 7939;
7941 -> 7938;
7941 -> 7939;
7942 -> 7938;
7942 -> 7939;
7943 -> 7938;
7943 -> 7939;
7944 -> 7939;
7945 -> 1;
7946 -> 1;
7947 -> 7936;
7947 -> 7940;
7947 -> 7946;
7948 -> 7946;
7949 -> 7947;
7949 -> 7940;
7949 -> 7948;
7950 -> 7949;
7950 -> 7946;
7951 -> 7950;
7951 -> 1;
7952 -> 1;
7953 -> 7856;
7953 -> 7940;
7953 -> 7952;
7953 -> 1;
7954 -> 1;
7955 -> 7953;
7955 -> 7954;
7956 -> 7953;
7956 -> 7954;
7957 -> 7953;
7957 -> 7954;
7958 -> 7953;
7958 -> 7954;
7959 -> 7954;
7960 -> 7953;
7960 -> 7954;
7961 -> 7954;
7962 -> 7961;
7962 -> 1;
7963 -> 0;
7963 -> 1;
7964 -> 1;
7965 -> 7856;
7965 -> 7955;
7965 -> 7964;
7965 -> 1;
7966 -> 1;
7967 -> 7965;
7967 -> 7966;
7968 -> 7966;
7969 -> 7968;
7969 -> 1;
7970 -> 7965;
7970 -> 7969;
7970 -> 1;
7971 -> 1;
7972 -> 7856;
7972 -> 7970;
7972 -> 7971;
7972 -> 1;
7973 -> 7972;
7973 -> 1;
7974 -> 7972;
7974 -> 1;
7975 -> 1;
7976 -> 7974;
7976 -> 7975;
7977 -> 7974;
7977 -> 7975;
7978 -> 7974;
7978 -> 7975;
7979 -> 7974;
7979 -> 7975;
7980 -> 7975;
7981 -> 1;
7982 -> 1;
7983 -> 7972;
7983 -> 7976;
7983 -> 7982;
7984 -> 7982;
7985 -> 7983;
7985 -> 7976;
7985 -> 7984;
7986 -> 7985;
7986 -> 7982;
7987 -> 7986;
7987 -> 1;
7988 -> 1;
7989 -> 7856;
7989 -> 7976;
7989 -> 7988;
7989 -> 1;
7990 -> 1;
7991 -> 7989;
7991 -> 7990;
7992 -> 7990;
7993 -> 7992;
7993 -> 1;
7994 -> 7989;
7994 -> 7993;
7994 -> 1;
7995 -> 1;
7996 -> 7856;
7996 -> 7994;
7996 -> 7995;
7996 -> 1;
7997 -> 1;
7998 -> 7996;
7998 -> 7997;
7999 -> 7996;
7999 -> 7997;
8000 -> 7996;
8000 -> 7997;
8001 -> 7996;
8001 -> 7997;
8002 -> 7997;
8003 -> 1;
8004 -> 7856;
8004 -> 7998;
8004 -> 8003;
8004 -> 1;
8005 -> 8004;
8005 -> 8003;
8006 -> 8003;
8007 -> 8004;
8007 -> 8003;
8008 -> 8007;
8008 -> 8003;
8009 -> 8003;
8010 -> 8009;
8011 -> 8009;
8012 -> 1;
8013 -> 7856;
8013 -> 8004;
8013 -> 1;
8014 -> 1;
8015 -> 8013;
8015 -> 8014;
8016 -> 8014;
8017 -> 8016;
8017 -> 1;
8018 -> 8013;
8018 -> 8017;
8018 -> 1;
}