digraph G {
0 [label="EXTERNAL"];
1 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 152104"];
2 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 152105"];
3 [label="RuntimeHelpers.RunModuleConstructor(typeof(TestBase).Module.ModuleHandle); 152106"];
4 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 152107"];
5 [label="NullableAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 152108"];
6 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 152109"];
7 [label="NullableContextAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 152110"];
8 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 152111"];
9 [label="NullablePublicOnlyAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 152112"];
10 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 152113"];
11 [label="AllowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 152114"];
12 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 152115"];
13 [label="DisallowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 152116"];
14 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 152117"];
15 [label="MaybeNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 152118"];
16 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 152119"];
17 [label="MaybeNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 152120"];
18 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 152121"];
19 [label="NotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 152122"];
20 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 152123"];
21 [label="NotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 152124"];
22 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 152125"];
23 [label="MemberNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 152126"];
24 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 152127"];
25 [label="MemberNotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 152128"];
26 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 152129"];
27 [label="DoesNotReturnIfAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 152130"];
28 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 152131"];
29 [label="DoesNotReturnAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 152132"];
30 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 152133"];
31 [label="NotNullIfNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 152134"];
32 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 152135"];
33 [label="IsExternalInitTypeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 152136"];
34 [label="@'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 152137"];
35 [label="IAsyncDisposableDefinition = @'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 152138"];
36 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 152139"];
37 [label="AsyncStreamsTypes = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 152140"];
38 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 152141"];
39 [label="EnumeratorCancellationAttributeType = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 152142"];
40 [label="@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 152143"];
41 [label="NativeIntegerAttributeDefinition =\n@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 152144"];
42 [label="() => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic } 152145"];
43 [label="LazyThreadSafetyMode.PublicationOnly 152146"];
44 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 152147"];
45 [label="s_lazyDefaultVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 152148"];
46 [label="() => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic } 152149"];
47 [label="LazyThreadSafetyMode.PublicationOnly 152150"];
48 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 152151"];
49 [label="s_lazyLatestVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 152152"];
50 [label="RuntimeUtilities.IsCoreClrRuntime 152153"];
51 [label="'netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' 152154"];
52 [label="new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51') 152155"];
53 [label="RuntimeCorLibName = RuntimeUtilities.IsCoreClrRuntime\n            ? new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51')\n            : new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 152156"];
54 [label="() =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            } 152157"];
55 [label="LazyThreadSafetyMode.PublicationOnly 152158"];
56 [label="new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 152159"];
57 [label="s_winRtRefs = new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 152160"];
58 [label="() => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref } 152161"];
59 [label="LazyThreadSafetyMode.PublicationOnly 152162"];
60 [label="new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 152163"];
61 [label="s_portableRefsMinimal = new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 152164"];
62 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll') 152165"];
63 [label="LazyThreadSafetyMode.PublicationOnly 152166"];
64 [label="new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 152167"];
65 [label="s_systemCoreRef =\n            new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 152168"];
66 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll') 152169"];
67 [label="LazyThreadSafetyMode.PublicationOnly 152170"];
68 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152171"];
69 [label="s_systemCoreRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152172"];
70 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll') 152173"];
71 [label="LazyThreadSafetyMode.PublicationOnly 152174"];
72 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152175"];
73 [label="s_systemCoreRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152176"];
74 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll') 152177"];
75 [label="LazyThreadSafetyMode.PublicationOnly 152178"];
76 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152179"];
77 [label="s_systemWindowsFormsRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152180"];
78 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll') 152181"];
79 [label="LazyThreadSafetyMode.PublicationOnly 152182"];
80 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152183"];
81 [label="s_systemDrawingRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152184"];
82 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll') 152185"];
83 [label="LazyThreadSafetyMode.PublicationOnly 152186"];
84 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152187"];
85 [label="s_systemDataRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152188"];
86 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll') 152189"];
87 [label="LazyThreadSafetyMode.PublicationOnly 152190"];
88 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152191"];
89 [label="s_mscorlibRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152192"];
90 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll') 152193"];
91 [label="LazyThreadSafetyMode.PublicationOnly 152194"];
92 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152195"];
93 [label="s_mscorlibRefPortable = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152196"];
94 [label="() =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            } 152197"];
95 [label="LazyThreadSafetyMode.PublicationOnly 152198"];
96 [label="new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 152199"];
97 [label="s_aacorlibRef = new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 152200"];
98 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri') 152201"];
99 [label="LazyThreadSafetyMode.PublicationOnly 152202"];
100 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 152203"];
101 [label="s_mscorlibRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 152204"];
102 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll') 152205"];
103 [label="LazyThreadSafetyMode.PublicationOnly 152206"];
104 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152207"];
105 [label="s_mscorlibRef_silverlight = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152208"];
106 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll') 152209"];
107 [label="LazyThreadSafetyMode.PublicationOnly 152210"];
108 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152211"];
109 [label="s_desktopCSharpRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152212"];
110 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll') 152213"];
111 [label="LazyThreadSafetyMode.PublicationOnly 152214"];
112 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152215"];
113 [label="s_std20Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152216"];
114 [label="() => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll') 152217"];
115 [label="LazyThreadSafetyMode.PublicationOnly 152218"];
116 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152219"];
117 [label="s_46NetStandardFacade = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152220"];
118 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)') 152221"];
119 [label="LazyThreadSafetyMode.PublicationOnly 152222"];
120 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 152223"];
121 [label="s_systemDynamicRuntimeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 152224"];
122 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll') 152225"];
123 [label="LazyThreadSafetyMode.PublicationOnly 152226"];
124 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152227"];
125 [label="s_systemRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152228"];
126 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll') 152229"];
127 [label="LazyThreadSafetyMode.PublicationOnly 152230"];
128 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152231"];
129 [label="s_systemRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152232"];
130 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll') 152233"];
131 [label="LazyThreadSafetyMode.PublicationOnly 152234"];
132 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152235"];
133 [label="s_systemRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152236"];
134 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll') 152237"];
135 [label="LazyThreadSafetyMode.PublicationOnly 152238"];
136 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152239"];
137 [label="s_systemRef_v20 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152240"];
138 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll') 152241"];
139 [label="LazyThreadSafetyMode.PublicationOnly 152242"];
140 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152243"];
141 [label="s_systemXmlRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152244"];
142 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll') 152245"];
143 [label="LazyThreadSafetyMode.PublicationOnly 152246"];
144 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152247"];
145 [label="s_systemXmlLinqRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152248"];
146 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll') 152249"];
147 [label="LazyThreadSafetyMode.PublicationOnly 152250"];
148 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152251"];
149 [label="s_mscorlibFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152252"];
150 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll') 152253"];
151 [label="LazyThreadSafetyMode.PublicationOnly 152254"];
152 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152255"];
153 [label="s_systemRuntimeFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152256"];
154 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll') 152257"];
155 [label="LazyThreadSafetyMode.PublicationOnly 152258"];
156 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152259"];
157 [label="s_systemThreadingFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152260"];
158 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll') 152261"];
159 [label="LazyThreadSafetyMode.PublicationOnly 152262"];
160 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152263"];
161 [label="s_systemThreadingTasksFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152264"];
162 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll') 152265"];
163 [label="LazyThreadSafetyMode.PublicationOnly 152266"];
164 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152267"];
165 [label="s_mscorlibPP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152268"];
166 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll') 152269"];
167 [label="LazyThreadSafetyMode.PublicationOnly 152270"];
168 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152271"];
169 [label="s_systemRuntimePP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152272"];
170 [label="() => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll') 152273"];
171 [label="LazyThreadSafetyMode.PublicationOnly 152274"];
172 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152275"];
173 [label="s_FSharpTestLibraryRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 152276"];
174 [label="@'R:\\Invalid.dll' 152277"];
175 [label="fullPath: @'R:\\Invalid.dll' 152278"];
176 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 152279"];
177 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 152280"];
178 [label="InvalidRef = new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 152281"];
179 [label="MscorlibRef_v4_0_30316_17626 152282"];
180 [label="Net451.mscorlib 152283"];
181 [label="ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 152284"];
182 [label="s_scriptRefs = ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 152285"];
183 [label="'/*<bind>*/' 152286"];
184 [label="StartString = '/*<bind>*/' 152287"];
185 [label="'/*</bind>*/' 152288"];
186 [label="EndString = '/*</bind>*/' 152289"];
187 [label="@'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 152290"];
188 [label="SpanSource = @'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 152291"];
189 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 152292"];
190 [label="s_IAsyncEnumerable = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 152293"];
191 [label="param StatementParsingTests(ITestOutputHelper output) 152294"];
192 [label="param StatementParsingTests(this) 152295"];
193 [label="output 152296"];
194 [label="param ParsingTests(ITestOutputHelper output) 152297"];
195 [label="param ParsingTests(this) 152298"];
196 [label="param CSharpTestBase(this) 152299"];
197 [label="param CommonTestBase(this) 152300"];
198 [label="param TestBase(this) 152301"];
199 [label="_temp 152302"];
200 [label="_node 152303"];
201 [label="_treeEnumerator 152304"];
202 [label="_output 152305"];
203 [label="this._output 152306"];
204 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 152307"];
205 [label="param TestSwitchWithMultipleStatementsOnOneCase(this) 152308"];
206 [label="var text = 'switch (a) { case b: s1(); s2(); }'; 152309"];
207 [label="var statement = this.ParseStatement(text); 152310"];
208 [label="var statement = this.ParseStatement(text); 152311"];
209 [label="this.ParseStatement(text) 152312"];
210 [label="param ParseStatement(string text) 152313"];
211 [label="param ParseStatement(int offset = 0) 152314"];
212 [label="param ParseStatement(ParseOptions options = null) 152315"];
213 [label="param ParseStatement(this) 152316"];
214 [label="'\\r\\n' 152317"];
215 [label="CrLf = '\\r\\n' 152318"];
216 [label="CrLf 152319"];
217 [label="EndOfLine(CrLf) 152320"];
218 [label="param EndOfLine(string text) 152321"];
219 [label="param EndOfLine(bool elastic = false) 152322"];
220 [label="SyntaxTrivia trivia = null; 152323"];
221 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 152324"];
222 [label="elastic 152325"];
223 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 152326"];
224 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152327"];
225 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152328"];
226 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTrivia), r => new SyntaxTrivia(r)); 152329"];
227 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152330"];
228 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152331"];
229 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 152332"];
230 [label="param Create(SyntaxKind kind) 152333"];
231 [label="param Create(string text) 152334"];
232 [label="return new SyntaxTrivia(kind, text); 152335"];
233 [label="return new SyntaxTrivia(kind, text); 152336"];
234 [label="return new SyntaxTrivia(kind, text); 152337"];
235 [label="new SyntaxTrivia(kind, text) 152338"];
236 [label="param SyntaxTrivia(SyntaxKind kind) 152339"];
237 [label="param SyntaxTrivia(string text) 152340"];
238 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152341"];
239 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152342"];
240 [label="param SyntaxTrivia(this) 152343"];
241 [label="kind 152344"];
242 [label="diagnostics 152345"];
243 [label="annotations 152346"];
244 [label="new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 152347"];
245 [label="s_structuresTable\n            = new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 152348"];
246 [label="text 152349"];
247 [label="param SyntaxTrivia(this) 152350"];
248 [label="param CSharpSyntaxNode(SyntaxKind kind) 152351"];
249 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152352"];
250 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152353"];
251 [label="param CSharpSyntaxNode(int fullWidth) 152354"];
252 [label="param CSharpSyntaxNode(this) 152355"];
253 [label="kind 152356"];
254 [label="diagnostics 152357"];
255 [label="annotations 152358"];
256 [label="fullWidth 152359"];
257 [label="param CSharpSyntaxNode(this) 152360"];
258 [label="param CSharpSyntaxNode(this) 152361"];
259 [label="GreenStats.NoteGreen(this); 152362"];
260 [label="GreenStats.NoteGreen(this); 152363"];
261 [label="Text 152364"];
262 [label="this.Text 152365"];
263 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152366"];
264 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152367"];
265 [label="if (!elastic)\n            {\n                return trivia;\n            } 152368"];
266 [label="return trivia; 152369"];
267 [label="CarriageReturnLineFeed = EndOfLine(CrLf) 152370"];
268 [label="'\\n' 152371"];
269 [label="EndOfLine('\\n') 152372"];
270 [label="param EndOfLine(string text) 152373"];
271 [label="param EndOfLine(bool elastic = false) 152374"];
272 [label="SyntaxTrivia trivia = null; 152375"];
273 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 152376"];
274 [label="elastic 152377"];
275 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 152378"];
276 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152379"];
277 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152380"];
278 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152381"];
279 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152382"];
280 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 152383"];
281 [label="param Create(SyntaxKind kind) 152384"];
282 [label="param Create(string text) 152385"];
283 [label="return new SyntaxTrivia(kind, text); 152386"];
284 [label="return new SyntaxTrivia(kind, text); 152387"];
285 [label="return new SyntaxTrivia(kind, text); 152388"];
286 [label="new SyntaxTrivia(kind, text) 152389"];
287 [label="param SyntaxTrivia(SyntaxKind kind) 152390"];
288 [label="param SyntaxTrivia(string text) 152391"];
289 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152392"];
290 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152393"];
291 [label="param SyntaxTrivia(this) 152394"];
292 [label="kind 152395"];
293 [label="diagnostics 152396"];
294 [label="annotations 152397"];
295 [label="text 152398"];
296 [label="param SyntaxTrivia(this) 152399"];
297 [label="param CSharpSyntaxNode(SyntaxKind kind) 152400"];
298 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152401"];
299 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152402"];
300 [label="param CSharpSyntaxNode(int fullWidth) 152403"];
301 [label="param CSharpSyntaxNode(this) 152404"];
302 [label="kind 152405"];
303 [label="diagnostics 152406"];
304 [label="annotations 152407"];
305 [label="fullWidth 152408"];
306 [label="param CSharpSyntaxNode(this) 152409"];
307 [label="param CSharpSyntaxNode(this) 152410"];
308 [label="GreenStats.NoteGreen(this); 152411"];
309 [label="GreenStats.NoteGreen(this); 152412"];
310 [label="Text 152413"];
311 [label="this.Text 152414"];
312 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152415"];
313 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152416"];
314 [label="if (!elastic)\n            {\n                return trivia;\n            } 152417"];
315 [label="return trivia; 152418"];
316 [label="LineFeed = EndOfLine('\\n') 152419"];
317 [label="'\\r' 152420"];
318 [label="EndOfLine('\\r') 152421"];
319 [label="param EndOfLine(string text) 152422"];
320 [label="param EndOfLine(bool elastic = false) 152423"];
321 [label="SyntaxTrivia trivia = null; 152424"];
322 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 152425"];
323 [label="elastic 152426"];
324 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 152427"];
325 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152428"];
326 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152429"];
327 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152430"];
328 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152431"];
329 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 152432"];
330 [label="param Create(SyntaxKind kind) 152433"];
331 [label="param Create(string text) 152434"];
332 [label="return new SyntaxTrivia(kind, text); 152435"];
333 [label="return new SyntaxTrivia(kind, text); 152436"];
334 [label="return new SyntaxTrivia(kind, text); 152437"];
335 [label="new SyntaxTrivia(kind, text) 152438"];
336 [label="param SyntaxTrivia(SyntaxKind kind) 152439"];
337 [label="param SyntaxTrivia(string text) 152440"];
338 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152441"];
339 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152442"];
340 [label="param SyntaxTrivia(this) 152443"];
341 [label="kind 152444"];
342 [label="diagnostics 152445"];
343 [label="annotations 152446"];
344 [label="text 152447"];
345 [label="param SyntaxTrivia(this) 152448"];
346 [label="param CSharpSyntaxNode(SyntaxKind kind) 152449"];
347 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152450"];
348 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152451"];
349 [label="param CSharpSyntaxNode(int fullWidth) 152452"];
350 [label="param CSharpSyntaxNode(this) 152453"];
351 [label="kind 152454"];
352 [label="diagnostics 152455"];
353 [label="annotations 152456"];
354 [label="fullWidth 152457"];
355 [label="param CSharpSyntaxNode(this) 152458"];
356 [label="param CSharpSyntaxNode(this) 152459"];
357 [label="GreenStats.NoteGreen(this); 152460"];
358 [label="GreenStats.NoteGreen(this); 152461"];
359 [label="Text 152462"];
360 [label="this.Text 152463"];
361 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152464"];
362 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152465"];
363 [label="if (!elastic)\n            {\n                return trivia;\n            } 152466"];
364 [label="return trivia; 152467"];
365 [label="CarriageReturn = EndOfLine('\\r') 152468"];
366 [label="' ' 152469"];
367 [label="Whitespace(' ') 152470"];
368 [label="param Whitespace(string text) 152471"];
369 [label="param Whitespace(bool elastic = false) 152472"];
370 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152473"];
371 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152474"];
372 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 152475"];
373 [label="param Create(SyntaxKind kind) 152476"];
374 [label="param Create(string text) 152477"];
375 [label="return new SyntaxTrivia(kind, text); 152478"];
376 [label="return new SyntaxTrivia(kind, text); 152479"];
377 [label="return new SyntaxTrivia(kind, text); 152480"];
378 [label="new SyntaxTrivia(kind, text) 152481"];
379 [label="param SyntaxTrivia(SyntaxKind kind) 152482"];
380 [label="param SyntaxTrivia(string text) 152483"];
381 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152484"];
382 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152485"];
383 [label="param SyntaxTrivia(this) 152486"];
384 [label="kind 152487"];
385 [label="diagnostics 152488"];
386 [label="annotations 152489"];
387 [label="text 152490"];
388 [label="param SyntaxTrivia(this) 152491"];
389 [label="param CSharpSyntaxNode(SyntaxKind kind) 152492"];
390 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152493"];
391 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152494"];
392 [label="param CSharpSyntaxNode(int fullWidth) 152495"];
393 [label="param CSharpSyntaxNode(this) 152496"];
394 [label="kind 152497"];
395 [label="diagnostics 152498"];
396 [label="annotations 152499"];
397 [label="fullWidth 152500"];
398 [label="param CSharpSyntaxNode(this) 152501"];
399 [label="param CSharpSyntaxNode(this) 152502"];
400 [label="GreenStats.NoteGreen(this); 152503"];
401 [label="GreenStats.NoteGreen(this); 152504"];
402 [label="Text 152505"];
403 [label="this.Text 152506"];
404 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152507"];
405 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152508"];
406 [label="if (!elastic)\n            {\n                return trivia;\n            } 152509"];
407 [label="return trivia; 152510"];
408 [label="Space = Whitespace(' ') 152511"];
409 [label="'\\t' 152512"];
410 [label="Whitespace('\\t') 152513"];
411 [label="param Whitespace(string text) 152514"];
412 [label="param Whitespace(bool elastic = false) 152515"];
413 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152516"];
414 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152517"];
415 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 152518"];
416 [label="param Create(SyntaxKind kind) 152519"];
417 [label="param Create(string text) 152520"];
418 [label="return new SyntaxTrivia(kind, text); 152521"];
419 [label="return new SyntaxTrivia(kind, text); 152522"];
420 [label="return new SyntaxTrivia(kind, text); 152523"];
421 [label="new SyntaxTrivia(kind, text) 152524"];
422 [label="param SyntaxTrivia(SyntaxKind kind) 152525"];
423 [label="param SyntaxTrivia(string text) 152526"];
424 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152527"];
425 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152528"];
426 [label="param SyntaxTrivia(this) 152529"];
427 [label="kind 152530"];
428 [label="diagnostics 152531"];
429 [label="annotations 152532"];
430 [label="text 152533"];
431 [label="param SyntaxTrivia(this) 152534"];
432 [label="param CSharpSyntaxNode(SyntaxKind kind) 152535"];
433 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152536"];
434 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152537"];
435 [label="param CSharpSyntaxNode(int fullWidth) 152538"];
436 [label="param CSharpSyntaxNode(this) 152539"];
437 [label="kind 152540"];
438 [label="diagnostics 152541"];
439 [label="annotations 152542"];
440 [label="fullWidth 152543"];
441 [label="param CSharpSyntaxNode(this) 152544"];
442 [label="param CSharpSyntaxNode(this) 152545"];
443 [label="GreenStats.NoteGreen(this); 152546"];
444 [label="GreenStats.NoteGreen(this); 152547"];
445 [label="Text 152548"];
446 [label="this.Text 152549"];
447 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152550"];
448 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152551"];
449 [label="if (!elastic)\n            {\n                return trivia;\n            } 152552"];
450 [label="return trivia; 152553"];
451 [label="Tab = Whitespace('\\t') 152554"];
452 [label="CrLf 152555"];
453 [label="true 152556"];
454 [label="elastic: true 152557"];
455 [label="EndOfLine(CrLf, elastic: true) 152558"];
456 [label="param EndOfLine(string text) 152559"];
457 [label="param EndOfLine(bool elastic = false) 152560"];
458 [label="SyntaxTrivia trivia = null; 152561"];
459 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 152562"];
460 [label="elastic 152563"];
461 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 152564"];
462 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152565"];
463 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152566"];
464 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152567"];
465 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152568"];
466 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 152569"];
467 [label="param Create(SyntaxKind kind) 152570"];
468 [label="param Create(string text) 152571"];
469 [label="return new SyntaxTrivia(kind, text); 152572"];
470 [label="return new SyntaxTrivia(kind, text); 152573"];
471 [label="return new SyntaxTrivia(kind, text); 152574"];
472 [label="new SyntaxTrivia(kind, text) 152575"];
473 [label="param SyntaxTrivia(SyntaxKind kind) 152576"];
474 [label="param SyntaxTrivia(string text) 152577"];
475 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152578"];
476 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152579"];
477 [label="param SyntaxTrivia(this) 152580"];
478 [label="kind 152581"];
479 [label="diagnostics 152582"];
480 [label="annotations 152583"];
481 [label="text 152584"];
482 [label="param SyntaxTrivia(this) 152585"];
483 [label="param CSharpSyntaxNode(SyntaxKind kind) 152586"];
484 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152587"];
485 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152588"];
486 [label="param CSharpSyntaxNode(int fullWidth) 152589"];
487 [label="param CSharpSyntaxNode(this) 152590"];
488 [label="kind 152591"];
489 [label="diagnostics 152592"];
490 [label="annotations 152593"];
491 [label="fullWidth 152594"];
492 [label="param CSharpSyntaxNode(this) 152595"];
493 [label="param CSharpSyntaxNode(this) 152596"];
494 [label="GreenStats.NoteGreen(this); 152597"];
495 [label="GreenStats.NoteGreen(this); 152598"];
496 [label="Text 152599"];
497 [label="this.Text 152600"];
498 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152601"];
499 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152602"];
500 [label="if (!elastic)\n            {\n                return trivia;\n            } 152603"];
501 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152604"];
502 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152605"];
503 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 152606"];
504 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152607"];
505 [label="param SetAnnotations(SyntaxAnnotation[]? annotations) 152608"];
506 [label="param SetAnnotations(this) 152609"];
507 [label="this.Kind 152610"];
508 [label="get { return (SyntaxKind)this.RawKind; } 152611"];
509 [label="return (SyntaxKind)this.RawKind; 152612"];
510 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152613"];
511 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152614"];
512 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152615"];
513 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152616"];
514 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 152617"];
515 [label="param SyntaxTrivia(SyntaxKind kind) 152618"];
516 [label="param SyntaxTrivia(string text) 152619"];
517 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152620"];
518 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152621"];
519 [label="param SyntaxTrivia(this) 152622"];
520 [label="param SyntaxTrivia(this) 152623"];
521 [label="param CSharpSyntaxNode(this) 152624"];
522 [label="param CSharpSyntaxNode(this) 152625"];
523 [label="param CSharpSyntaxNode(this) 152626"];
524 [label="GreenStats.NoteGreen(this); 152627"];
525 [label="Text 152628"];
526 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152629"];
527 [label="ElasticCarriageReturnLineFeed = EndOfLine(CrLf, elastic: true) 152630"];
528 [label="'\\n' 152631"];
529 [label="true 152632"];
530 [label="elastic: true 152633"];
531 [label="EndOfLine('\\n', elastic: true) 152634"];
532 [label="param EndOfLine(string text) 152635"];
533 [label="param EndOfLine(bool elastic = false) 152636"];
534 [label="SyntaxTrivia trivia = null; 152637"];
535 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 152638"];
536 [label="elastic 152639"];
537 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 152640"];
538 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152641"];
539 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152642"];
540 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152643"];
541 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152644"];
542 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 152645"];
543 [label="param Create(SyntaxKind kind) 152646"];
544 [label="param Create(string text) 152647"];
545 [label="return new SyntaxTrivia(kind, text); 152648"];
546 [label="return new SyntaxTrivia(kind, text); 152649"];
547 [label="return new SyntaxTrivia(kind, text); 152650"];
548 [label="new SyntaxTrivia(kind, text) 152651"];
549 [label="param SyntaxTrivia(SyntaxKind kind) 152652"];
550 [label="param SyntaxTrivia(string text) 152653"];
551 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152654"];
552 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152655"];
553 [label="param SyntaxTrivia(this) 152656"];
554 [label="kind 152657"];
555 [label="diagnostics 152658"];
556 [label="annotations 152659"];
557 [label="text 152660"];
558 [label="param SyntaxTrivia(this) 152661"];
559 [label="param CSharpSyntaxNode(SyntaxKind kind) 152662"];
560 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152663"];
561 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152664"];
562 [label="param CSharpSyntaxNode(int fullWidth) 152665"];
563 [label="param CSharpSyntaxNode(this) 152666"];
564 [label="kind 152667"];
565 [label="diagnostics 152668"];
566 [label="annotations 152669"];
567 [label="fullWidth 152670"];
568 [label="param CSharpSyntaxNode(this) 152671"];
569 [label="param CSharpSyntaxNode(this) 152672"];
570 [label="GreenStats.NoteGreen(this); 152673"];
571 [label="GreenStats.NoteGreen(this); 152674"];
572 [label="Text 152675"];
573 [label="this.Text 152676"];
574 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152677"];
575 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152678"];
576 [label="if (!elastic)\n            {\n                return trivia;\n            } 152679"];
577 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152680"];
578 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152681"];
579 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 152682"];
580 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152683"];
581 [label="this.Kind 152684"];
582 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152685"];
583 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 152686"];
584 [label="param SyntaxTrivia(this) 152687"];
585 [label="param SyntaxTrivia(this) 152688"];
586 [label="param CSharpSyntaxNode(this) 152689"];
587 [label="param CSharpSyntaxNode(this) 152690"];
588 [label="GreenStats.NoteGreen(this); 152691"];
589 [label="Text 152692"];
590 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152693"];
591 [label="ElasticLineFeed = EndOfLine('\\n', elastic: true) 152694"];
592 [label="'\\r' 152695"];
593 [label="true 152696"];
594 [label="elastic: true 152697"];
595 [label="EndOfLine('\\r', elastic: true) 152698"];
596 [label="param EndOfLine(string text) 152699"];
597 [label="param EndOfLine(bool elastic = false) 152700"];
598 [label="SyntaxTrivia trivia = null; 152701"];
599 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 152702"];
600 [label="elastic 152703"];
601 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 152704"];
602 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152705"];
603 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152706"];
604 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152707"];
605 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152708"];
606 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 152709"];
607 [label="param Create(SyntaxKind kind) 152710"];
608 [label="param Create(string text) 152711"];
609 [label="return new SyntaxTrivia(kind, text); 152712"];
610 [label="return new SyntaxTrivia(kind, text); 152713"];
611 [label="return new SyntaxTrivia(kind, text); 152714"];
612 [label="new SyntaxTrivia(kind, text) 152715"];
613 [label="param SyntaxTrivia(SyntaxKind kind) 152716"];
614 [label="param SyntaxTrivia(string text) 152717"];
615 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152718"];
616 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152719"];
617 [label="param SyntaxTrivia(this) 152720"];
618 [label="kind 152721"];
619 [label="diagnostics 152722"];
620 [label="annotations 152723"];
621 [label="text 152724"];
622 [label="param SyntaxTrivia(this) 152725"];
623 [label="param CSharpSyntaxNode(SyntaxKind kind) 152726"];
624 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152727"];
625 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152728"];
626 [label="param CSharpSyntaxNode(int fullWidth) 152729"];
627 [label="param CSharpSyntaxNode(this) 152730"];
628 [label="kind 152731"];
629 [label="diagnostics 152732"];
630 [label="annotations 152733"];
631 [label="fullWidth 152734"];
632 [label="param CSharpSyntaxNode(this) 152735"];
633 [label="param CSharpSyntaxNode(this) 152736"];
634 [label="GreenStats.NoteGreen(this); 152737"];
635 [label="GreenStats.NoteGreen(this); 152738"];
636 [label="Text 152739"];
637 [label="this.Text 152740"];
638 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152741"];
639 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152742"];
640 [label="if (!elastic)\n            {\n                return trivia;\n            } 152743"];
641 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152744"];
642 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152745"];
643 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 152746"];
644 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152747"];
645 [label="this.Kind 152748"];
646 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152749"];
647 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 152750"];
648 [label="param SyntaxTrivia(this) 152751"];
649 [label="param SyntaxTrivia(this) 152752"];
650 [label="param CSharpSyntaxNode(this) 152753"];
651 [label="param CSharpSyntaxNode(this) 152754"];
652 [label="GreenStats.NoteGreen(this); 152755"];
653 [label="Text 152756"];
654 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152757"];
655 [label="ElasticCarriageReturn = EndOfLine('\\r', elastic: true) 152758"];
656 [label="' ' 152759"];
657 [label="true 152760"];
658 [label="elastic: true 152761"];
659 [label="Whitespace(' ', elastic: true) 152762"];
660 [label="param Whitespace(string text) 152763"];
661 [label="param Whitespace(bool elastic = false) 152764"];
662 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152765"];
663 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152766"];
664 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 152767"];
665 [label="param Create(SyntaxKind kind) 152768"];
666 [label="param Create(string text) 152769"];
667 [label="return new SyntaxTrivia(kind, text); 152770"];
668 [label="return new SyntaxTrivia(kind, text); 152771"];
669 [label="return new SyntaxTrivia(kind, text); 152772"];
670 [label="new SyntaxTrivia(kind, text) 152773"];
671 [label="param SyntaxTrivia(SyntaxKind kind) 152774"];
672 [label="param SyntaxTrivia(string text) 152775"];
673 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152776"];
674 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152777"];
675 [label="param SyntaxTrivia(this) 152778"];
676 [label="kind 152779"];
677 [label="diagnostics 152780"];
678 [label="annotations 152781"];
679 [label="text 152782"];
680 [label="param SyntaxTrivia(this) 152783"];
681 [label="param CSharpSyntaxNode(SyntaxKind kind) 152784"];
682 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152785"];
683 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152786"];
684 [label="param CSharpSyntaxNode(int fullWidth) 152787"];
685 [label="param CSharpSyntaxNode(this) 152788"];
686 [label="kind 152789"];
687 [label="diagnostics 152790"];
688 [label="annotations 152791"];
689 [label="fullWidth 152792"];
690 [label="param CSharpSyntaxNode(this) 152793"];
691 [label="param CSharpSyntaxNode(this) 152794"];
692 [label="GreenStats.NoteGreen(this); 152795"];
693 [label="GreenStats.NoteGreen(this); 152796"];
694 [label="Text 152797"];
695 [label="this.Text 152798"];
696 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152799"];
697 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152800"];
698 [label="if (!elastic)\n            {\n                return trivia;\n            } 152801"];
699 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152802"];
700 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152803"];
701 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 152804"];
702 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152805"];
703 [label="this.Kind 152806"];
704 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152807"];
705 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 152808"];
706 [label="param SyntaxTrivia(this) 152809"];
707 [label="param SyntaxTrivia(this) 152810"];
708 [label="param CSharpSyntaxNode(this) 152811"];
709 [label="param CSharpSyntaxNode(this) 152812"];
710 [label="GreenStats.NoteGreen(this); 152813"];
711 [label="Text 152814"];
712 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152815"];
713 [label="ElasticSpace = Whitespace(' ', elastic: true) 152816"];
714 [label="'\\t' 152817"];
715 [label="true 152818"];
716 [label="elastic: true 152819"];
717 [label="Whitespace('\\t', elastic: true) 152820"];
718 [label="param Whitespace(string text) 152821"];
719 [label="param Whitespace(bool elastic = false) 152822"];
720 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152823"];
721 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152824"];
722 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 152825"];
723 [label="param Create(SyntaxKind kind) 152826"];
724 [label="param Create(string text) 152827"];
725 [label="return new SyntaxTrivia(kind, text); 152828"];
726 [label="return new SyntaxTrivia(kind, text); 152829"];
727 [label="return new SyntaxTrivia(kind, text); 152830"];
728 [label="new SyntaxTrivia(kind, text) 152831"];
729 [label="param SyntaxTrivia(SyntaxKind kind) 152832"];
730 [label="param SyntaxTrivia(string text) 152833"];
731 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152834"];
732 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152835"];
733 [label="param SyntaxTrivia(this) 152836"];
734 [label="kind 152837"];
735 [label="diagnostics 152838"];
736 [label="annotations 152839"];
737 [label="text 152840"];
738 [label="param SyntaxTrivia(this) 152841"];
739 [label="param CSharpSyntaxNode(SyntaxKind kind) 152842"];
740 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152843"];
741 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152844"];
742 [label="param CSharpSyntaxNode(int fullWidth) 152845"];
743 [label="param CSharpSyntaxNode(this) 152846"];
744 [label="kind 152847"];
745 [label="diagnostics 152848"];
746 [label="annotations 152849"];
747 [label="fullWidth 152850"];
748 [label="param CSharpSyntaxNode(this) 152851"];
749 [label="param CSharpSyntaxNode(this) 152852"];
750 [label="GreenStats.NoteGreen(this); 152853"];
751 [label="GreenStats.NoteGreen(this); 152854"];
752 [label="Text 152855"];
753 [label="this.Text 152856"];
754 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152857"];
755 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152858"];
756 [label="if (!elastic)\n            {\n                return trivia;\n            } 152859"];
757 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152860"];
758 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152861"];
759 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 152862"];
760 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152863"];
761 [label="this.Kind 152864"];
762 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152865"];
763 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 152866"];
764 [label="param SyntaxTrivia(this) 152867"];
765 [label="param SyntaxTrivia(this) 152868"];
766 [label="param CSharpSyntaxNode(this) 152869"];
767 [label="param CSharpSyntaxNode(this) 152870"];
768 [label="GreenStats.NoteGreen(this); 152871"];
769 [label="Text 152872"];
770 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152873"];
771 [label="ElasticTab = Whitespace('\\t', elastic: true) 152874"];
772 [label="string.Empty 152875"];
773 [label="true 152876"];
774 [label="elastic: true 152877"];
775 [label="Whitespace(string.Empty, elastic: true) 152878"];
776 [label="param Whitespace(string text) 152879"];
777 [label="param Whitespace(bool elastic = false) 152880"];
778 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152881"];
779 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152882"];
780 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 152883"];
781 [label="param Create(SyntaxKind kind) 152884"];
782 [label="param Create(string text) 152885"];
783 [label="return new SyntaxTrivia(kind, text); 152886"];
784 [label="return new SyntaxTrivia(kind, text); 152887"];
785 [label="return new SyntaxTrivia(kind, text); 152888"];
786 [label="new SyntaxTrivia(kind, text) 152889"];
787 [label="param SyntaxTrivia(SyntaxKind kind) 152890"];
788 [label="param SyntaxTrivia(string text) 152891"];
789 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152892"];
790 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152893"];
791 [label="param SyntaxTrivia(this) 152894"];
792 [label="kind 152895"];
793 [label="diagnostics 152896"];
794 [label="annotations 152897"];
795 [label="text 152898"];
796 [label="param SyntaxTrivia(this) 152899"];
797 [label="param CSharpSyntaxNode(SyntaxKind kind) 152900"];
798 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152901"];
799 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152902"];
800 [label="param CSharpSyntaxNode(int fullWidth) 152903"];
801 [label="param CSharpSyntaxNode(this) 152904"];
802 [label="kind 152905"];
803 [label="diagnostics 152906"];
804 [label="annotations 152907"];
805 [label="fullWidth 152908"];
806 [label="param CSharpSyntaxNode(this) 152909"];
807 [label="param CSharpSyntaxNode(this) 152910"];
808 [label="GreenStats.NoteGreen(this); 152911"];
809 [label="GreenStats.NoteGreen(this); 152912"];
810 [label="Text 152913"];
811 [label="this.Text 152914"];
812 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152915"];
813 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152916"];
814 [label="if (!elastic)\n            {\n                return trivia;\n            } 152917"];
815 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152918"];
816 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152919"];
817 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 152920"];
818 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152921"];
819 [label="this.Kind 152922"];
820 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152923"];
821 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 152924"];
822 [label="param SyntaxTrivia(this) 152925"];
823 [label="param SyntaxTrivia(this) 152926"];
824 [label="param CSharpSyntaxNode(this) 152927"];
825 [label="param CSharpSyntaxNode(this) 152928"];
826 [label="GreenStats.NoteGreen(this); 152929"];
827 [label="Text 152930"];
828 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152931"];
829 [label="ElasticZeroSpace = Whitespace(string.Empty, elastic: true) 152932"];
830 [label="s_xmlCarriageReturnLineFeed 152933"];
831 [label="public static SyntaxTrivia CarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturnLineFeed; 152934"];
832 [label="param operator(SyntaxTrivia trivia) 152935"];
833 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152936"];
834 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152937"];
835 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152938"];
836 [label="public static SyntaxTrivia LineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.LineFeed; 152939"];
837 [label="param operator(SyntaxTrivia trivia) 152940"];
838 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152941"];
839 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152942"];
840 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152943"];
841 [label="public static SyntaxTrivia CarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturn; 152944"];
842 [label="param operator(SyntaxTrivia trivia) 152945"];
843 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152946"];
844 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152947"];
845 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152948"];
846 [label="public static SyntaxTrivia Space { get; } = Syntax.InternalSyntax.SyntaxFactory.Space; 152949"];
847 [label="param operator(SyntaxTrivia trivia) 152950"];
848 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152951"];
849 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152952"];
850 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152953"];
851 [label="public static SyntaxTrivia Tab { get; } = Syntax.InternalSyntax.SyntaxFactory.Tab; 152954"];
852 [label="param operator(SyntaxTrivia trivia) 152955"];
853 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152956"];
854 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152957"];
855 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152958"];
856 [label="public static SyntaxTrivia ElasticCarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturnLineFeed; 152959"];
857 [label="param operator(SyntaxTrivia trivia) 152960"];
858 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152961"];
859 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152962"];
860 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152963"];
861 [label="public static SyntaxTrivia ElasticLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticLineFeed; 152964"];
862 [label="param operator(SyntaxTrivia trivia) 152965"];
863 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152966"];
864 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152967"];
865 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152968"];
866 [label="public static SyntaxTrivia ElasticCarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturn; 152969"];
867 [label="param operator(SyntaxTrivia trivia) 152970"];
868 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152971"];
869 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152972"];
870 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152973"];
871 [label="public static SyntaxTrivia ElasticSpace { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticSpace; 152974"];
872 [label="param operator(SyntaxTrivia trivia) 152975"];
873 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152976"];
874 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152977"];
875 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152978"];
876 [label="public static SyntaxTrivia ElasticTab { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticTab; 152979"];
877 [label="param operator(SyntaxTrivia trivia) 152980"];
878 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152981"];
879 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152982"];
880 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152983"];
881 [label="public static SyntaxTrivia ElasticMarker { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticZeroSpace; 152984"];
882 [label="param operator(SyntaxTrivia trivia) 152985"];
883 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152986"];
884 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152987"];
885 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152988"];
886 [label="return SyntaxFactory.ParseStatement(text, offset, options); 152989"];
887 [label="return SyntaxFactory.ParseStatement(text, offset, options); 152990"];
888 [label="return SyntaxFactory.ParseStatement(text, offset, options); 152991"];
889 [label="return SyntaxFactory.ParseStatement(text, offset, options); 152992"];
890 [label="SyntaxFactory.ParseStatement(text, offset, options) 152993"];
891 [label="param ParseStatement(string text) 152994"];
892 [label="param ParseStatement(int offset = 0) 152995"];
893 [label="param ParseStatement(ParseOptions? options = null) 152996"];
894 [label="param ParseStatement(bool consumeFullText = true) 152997"];
895 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 152998"];
896 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 152999"];
897 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 153000"];
898 [label="MakeLexer(text, offset, (CSharpParseOptions?)options) 153001"];
899 [label="param MakeLexer(string text) 153002"];
900 [label="param MakeLexer(int offset) 153003"];
901 [label="param MakeLexer(CSharpParseOptions? options = null) 153004"];
902 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 153005"];
903 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 153006"];
904 [label="MakeSourceText(text, offset) 153007"];
905 [label="param MakeSourceText(string text) 153008"];
906 [label="param MakeSourceText(int offset) 153009"];
907 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 153010"];
908 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 153011"];
909 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 153012"];
910 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 153013"];
911 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 153014"];
912 [label="8 153015"];
913 [label="TriviaListInitialCapacity = 8 153016"];
914 [label="TokensLexed 153017"];
915 [label="'<<<<<<<' 153018"];
916 [label="s_conflictMarkerLength = '<<<<<<<'.Length 153019"];
917 [label="42 153020"];
918 [label="MaxCachedTokenSize = 42 153021"];
919 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 153022"];
920 [label="{\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            } 153023"];
921 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 153024"];
922 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 153025"];
923 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 153026"];
924 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 153027"];
925 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 153028"];
926 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 153029"];
927 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 153030"];
928 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 153031"];
929 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 153032"];
930 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 153033"];
931 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 153034"];
932 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 153035"];
933 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 153036"];
934 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 153037"];
935 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 153038"];
936 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 153039"];
937 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 153040"];
938 [label="s_stateTransitions = new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 153041"];
939 [label="new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 153042"];
940 [label="s_charProperties = new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 153043"];
941 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 153044"];
942 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 153045"];
943 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 153046"];
944 [label="new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default) 153047"];
945 [label="param Lexer(SourceText text) 153048"];
946 [label="param Lexer(CSharpParseOptions options) 153049"];
947 [label="param Lexer(bool allowPreprocessorDirectives = true) 153050"];
948 [label="param Lexer(bool interpolationFollowedByColon = false) 153051"];
949 [label="param Lexer(this) 153052"];
950 [label="text 153053"];
951 [label="param Lexer(this) 153054"];
952 [label="param AbstractLexer(SourceText text) 153055"];
953 [label="param AbstractLexer(this) 153056"];
954 [label="TextWindow 153057"];
955 [label="_errors 153058"];
956 [label="InvalidCharacter = char.MaxValue 153059"];
957 [label="2048 153060"];
958 [label="DefaultWindowLength = 2048 153061"];
959 [label="() => new char[DefaultWindowLength] 153062"];
960 [label="new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 153063"];
961 [label="s_windowPool = new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 153064"];
962 [label="this.TextWindow = new SlidingTextWindow(text); 153065"];
963 [label="this.TextWindow = new SlidingTextWindow(text); 153066"];
964 [label="new SlidingTextWindow(text) 153067"];
965 [label="param SlidingTextWindow(SourceText text) 153068"];
966 [label="param SlidingTextWindow(this) 153069"];
967 [label="_text 153070"];
968 [label="_basis 153071"];
969 [label="_offset 153072"];
970 [label="_textEnd 153073"];
971 [label="_characterWindow 153074"];
972 [label="_characterWindowCount 153075"];
973 [label="_lexemeStart 153076"];
974 [label="_strings 153077"];
975 [label="_text 153078"];
976 [label="_basis = 0; 153079"];
977 [label="_basis 153080"];
978 [label="_offset = 0; 153081"];
979 [label="_offset 153082"];
980 [label="_textEnd 153083"];
981 [label="_strings = StringTable.GetInstance(); 153084"];
982 [label="_strings 153085"];
983 [label="_characterWindow = s_windowPool.Allocate(); 153086"];
984 [label="_characterWindow 153087"];
985 [label="_lexemeStart = 0; 153088"];
986 [label="_lexemeStart 153089"];
987 [label="this.TextWindow 153090"];
988 [label="_options 153091"];
989 [label="_mode 153092"];
990 [label="_builder 153093"];
991 [label="_identBuffer 153094"];
992 [label="_identLen 153095"];
993 [label="_cache 153096"];
994 [label="_allowPreprocessorDirectives 153097"];
995 [label="_interpolationFollowedByColon 153098"];
996 [label="_xmlParser 153099"];
997 [label="_badTokenCount 153100"];
998 [label="10 153101"];
999 [label="new SyntaxListBuilder(10) 153102"];
1000 [label="_leadingTriviaCache = new SyntaxListBuilder(10) 153103"];
1001 [label="10 153104"];
1002 [label="new SyntaxListBuilder(10) 153105"];
1003 [label="_trailingTriviaCache = new SyntaxListBuilder(10) 153106"];
1004 [label="_createWhitespaceTriviaFunction 153107"];
1005 [label="_createQuickTokenFunction 153108"];
1006 [label="Debug.Assert(options != null); 153109"];
1007 [label="Debug.Assert(options != null); 153110"];
1008 [label="_options 153111"];
1009 [label="_builder = new StringBuilder(); 153112"];
1010 [label="_builder 153113"];
1011 [label="_identBuffer = new char[32]; 153114"];
1012 [label="_identBuffer 153115"];
1013 [label="512 153116"];
1014 [label="(key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            } 153117"];
1015 [label="CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 153118"];
1016 [label="s_keywordKindPool =\n            CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 153119"];
1017 [label="10 153120"];
1018 [label="MaxKeywordLength = 10 153121"];
1019 [label="_cache = new LexerCache(); 153122"];
1020 [label="new LexerCache() 153123"];
1021 [label="param LexerCache(this) 153124"];
1022 [label="_triviaMap 153125"];
1023 [label="_tokenMap 153126"];
1024 [label="_keywordKindMap 153127"];
1025 [label="_triviaMap = TextKeyedCache<SyntaxTrivia>.GetInstance(); 153128"];
1026 [label="_triviaMap 153129"];
1027 [label="_tokenMap = TextKeyedCache<SyntaxToken>.GetInstance(); 153130"];
1028 [label="_tokenMap 153131"];
1029 [label="_keywordKindMap = s_keywordKindPool.Allocate(); 153132"];
1030 [label="_keywordKindMap 153133"];
1031 [label="_cache 153134"];
1032 [label="_createQuickTokenFunction 153135"];
1033 [label="_allowPreprocessorDirectives 153136"];
1034 [label="_interpolationFollowedByColon 153137"];
1035 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 153138"];
1036 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 153139"];
1037 [label="MakeParser(lexer) 153140"];
1038 [label="param MakeParser(InternalSyntax.Lexer lexer) 153141"];
1039 [label="LastTerminatorState = (int)TerminatorState.IsEndOfRecordSignature 153142"];
1040 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 153143"];
1041 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 153144"];
1042 [label="new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null) 153145"];
1043 [label="param LanguageParser(Lexer lexer) 153146"];
1044 [label="param LanguageParser(CSharp.CSharpSyntaxNode oldTree) 153147"];
1045 [label="param LanguageParser(IEnumerable<TextChangeRange> changes) 153148"];
1046 [label="param LanguageParser(LexerMode lexerMode = LexerMode.Syntax) 153149"];
1047 [label="param LanguageParser(CancellationToken cancellationToken = default(CancellationToken)) 153150"];
1048 [label="param LanguageParser(this) 153151"];
1049 [label="() => new BlendedNode[32] 153152"];
1050 [label="2 153153"];
1051 [label="new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 153154"];
1052 [label="s_blendedNodesPool = new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 153155"];
1053 [label="lexer 153156"];
1054 [label="lexerMode 153157"];
1055 [label="oldTree 153158"];
1056 [label="changes 153159"];
1057 [label="false 153160"];
1058 [label="true 153161"];
1059 [label="cancellationToken 153162"];
1060 [label="param LanguageParser(this) 153163"];
1061 [label="param SyntaxParser(Lexer lexer) 153164"];
1062 [label="param SyntaxParser(LexerMode mode) 153165"];
1063 [label="param SyntaxParser(CSharp.CSharpSyntaxNode oldTree) 153166"];
1064 [label="param SyntaxParser(IEnumerable<TextChangeRange> changes) 153167"];
1065 [label="param SyntaxParser(bool allowModeReset) 153168"];
1066 [label="param SyntaxParser(bool preLexIfNotIncremental = false) 153169"];
1067 [label="param SyntaxParser(CancellationToken cancellationToken = default(CancellationToken)) 153170"];
1068 [label="param SyntaxParser(this) 153171"];
1069 [label="lexer 153172"];
1070 [label="_isIncremental 153173"];
1071 [label="_allowModeReset 153174"];
1072 [label="_mode 153175"];
1073 [label="_currentToken 153176"];
1074 [label="_lexedTokens 153177"];
1075 [label="_prevTokenTrailingTrivia 153178"];
1076 [label="_firstToken 153179"];
1077 [label="_tokenOffset 153180"];
1078 [label="_tokenCount 153181"];
1079 [label="_resetCount 153182"];
1080 [label="_resetStart 153183"];
1081 [label="_blendedTokens 153184"];
1082 [label="this.lexer 153185"];
1083 [label="_mode 153186"];
1084 [label="_allowModeReset 153187"];
1085 [label="this.cancellationToken 153188"];
1086 [label="_currentNode = default(BlendedNode); 153189"];
1087 [label="_currentNode 153190"];
1088 [label="_isIncremental = oldTree != null; 153191"];
1089 [label="_isIncremental = oldTree != null; 153192"];
1090 [label="_isIncremental 153193"];
1091 [label="this.IsIncremental 153194"];
1092 [label="get\n            {\n                return _isIncremental;\n            } 153195"];
1093 [label="return _isIncremental; 153196"];
1094 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 153197"];
1095 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 153198"];
1096 [label="_firstBlender = default(Blender); 153199"];
1097 [label="_firstBlender 153200"];
1098 [label="_lexedTokens = new ArrayElement<SyntaxToken>[32]; 153201"];
1099 [label="_lexedTokens 153202"];
1100 [label="this.IsIncremental 153203"];
1101 [label="get\n            {\n                return _isIncremental;\n            } 153204"];
1102 [label="return _isIncremental; 153205"];
1103 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 153206"];
1104 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 153207"];
1105 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 153208"];
1106 [label="this.PreLex() 153209"];
1107 [label="param PreLex(this) 153210"];
1108 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 153211"];
1109 [label="this.lexer.TextWindow.Text 153212"];
1110 [label="=> _text 153213"];
1111 [label="_text 153214"];
1112 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 153215"];
1113 [label="_lexedTokens = new ArrayElement<SyntaxToken>[size]; 153216"];
1114 [label="_lexedTokens 153217"];
1115 [label="var lexer = this.lexer; 153218"];
1116 [label="var mode = _mode; 153219"];
1117 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 153220"];
1118 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 153221"];
1119 [label="var token = lexer.Lex(mode); 153222"];
1120 [label="lexer.Lex(mode) 153223"];
1121 [label="param Lex(LexerMode mode) 153224"];
1122 [label="param Lex(this) 153225"];
1123 [label="TokensLexed++; 153226"];
1124 [label="_mode 153227"];
1125 [label="switch (_mode)\n            {\n                case LexerMode.Syntax:\n                case LexerMode.DebuggerSyntax:\n                    return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken();\n                case LexerMode.Directive:\n                    return this.LexDirectiveToken();\n            } 153228"];
1126 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 153229"];
1127 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 153230"];
1128 [label="param Start(this) 153231"];
1129 [label="TextWindow.Start() 153232"];
1130 [label="param Start(this) 153233"];
1131 [label="_lexemeStart 153234"];
1132 [label="TextWindow.Start(); 153235"];
1133 [label="_errors = null; 153236"];
1134 [label="_errors 153237"];
1135 [label="get\n            {\n                return _offset;\n            } 153238"];
1136 [label="return _offset; 153239"];
1137 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 153240"];
1138 [label="get\n            {\n                return _characterWindowCount;\n            } 153241"];
1139 [label="return _characterWindowCount; 153242"];
1140 [label="get\n            {\n                return _characterWindow;\n            } 153243"];
1141 [label="return _characterWindow; 153244"];
1142 [label="param AdvanceChar(int n) 153245"];
1143 [label="param AdvanceChar(this) 153246"];
1144 [label="_offset += n; 153247"];
1145 [label="_offset 153248"];
1146 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 153249"];
1147 [label="return _basis + _lexemeStart; 153250"];
1148 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 153251"];
1149 [label="param Reset(int position) 153252"];
1150 [label="param Reset(this) 153253"];
1151 [label="int relative = position - _basis; 153254"];
1152 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 153255"];
1153 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 153256"];
1154 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 153257"];
1155 [label="_offset 153258"];
1156 [label="this.LexSyntaxToken() 153259"];
1157 [label="param LexSyntaxToken(this) 153260"];
1158 [label="_leadingTriviaCache.Clear(); 153261"];
1159 [label="TextWindow.Position 153262"];
1160 [label="get\n            {\n                return _basis + _offset;\n            } 153263"];
1161 [label="return _basis + _offset; 153264"];
1162 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 153265"];
1163 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 153266"];
1164 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 153267"];
1165 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache) 153268"];
1166 [label="param LexSyntaxTrivia(bool afterFirstToken) 153269"];
1167 [label="param LexSyntaxTrivia(bool isTrailing) 153270"];
1168 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 153271"];
1169 [label="param LexSyntaxTrivia(this) 153272"];
1170 [label="bool onlyWhitespaceOnLine = !isTrailing; 153273"];
1171 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 153274"];
1172 [label="this.Start() 153275"];
1173 [label="param Start(this) 153276"];
1174 [label="TextWindow.Start() 153277"];
1175 [label="param Start(this) 153278"];
1176 [label="TextWindow.Start(); 153279"];
1177 [label="_errors = null; 153280"];
1178 [label="_errors 153281"];
1179 [label="this.Start(); 153282"];
1180 [label="TextWindow.PeekChar() 153283"];
1181 [label="param PeekChar(this) 153284"];
1182 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 153285"];
1183 [label="MoreChars() 153286"];
1184 [label="param MoreChars(this) 153287"];
1185 [label="if (_offset >= _characterWindowCount)\n            {\n                if (this.Position >= _textEnd)\n                {\n                    return false;\n                }\n\n                // if lexeme scanning is sufficiently into the char buffer, \n                // then refocus the window onto the lexeme\n                if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                }\n\n                if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                }\n\n                int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount);\n                _text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead);\n                _characterWindowCount += amountToRead;\n                return amountToRead > 0;\n            } 153288"];
1186 [label="this.Position 153289"];
1187 [label="get\n            {\n                return _basis + _offset;\n            } 153290"];
1188 [label="return _basis + _offset; 153291"];
1189 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 153292"];
1190 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 153293"];
1191 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 153294"];
1192 [label="if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                } 153295"];
1193 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 153296"];
1194 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 153297"];
1195 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 153298"];
1196 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 153299"];
1197 [label="_characterWindowCount += amountToRead; 153300"];
1198 [label="_characterWindowCount 153301"];
1199 [label="return amountToRead > 0; 153302"];
1200 [label="return amountToRead > 0; 153303"];
1201 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 153304"];
1202 [label="return _characterWindow[_offset]; 153305"];
1203 [label="char ch = TextWindow.PeekChar(); 153306"];
1204 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 153307"];
1205 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 153308"];
1206 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 153309"];
1207 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 153310"];
1208 [label="return; 153311"];
1209 [label="var leading = _leadingTriviaCache; 153312"];
1210 [label="var tokenInfo = default(TokenInfo); 153313"];
1211 [label="this.Start() 153314"];
1212 [label="param Start(this) 153315"];
1213 [label="TextWindow.Start() 153316"];
1214 [label="param Start(this) 153317"];
1215 [label="TextWindow.Start(); 153318"];
1216 [label="_errors = null; 153319"];
1217 [label="_errors 153320"];
1218 [label="this.Start(); 153321"];
1219 [label="this.ScanSyntaxToken(ref tokenInfo); 153322"];
1220 [label="this.ScanSyntaxToken(ref tokenInfo); 153323"];
1221 [label="this.ScanSyntaxToken(ref tokenInfo); 153324"];
1222 [label="get\n            {\n                return _basis + _offset;\n            } 153325"];
1223 [label="return _basis + _offset; 153326"];
1224 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 153327"];
1225 [label="return _characterWindow[_offset]; 153328"];
1226 [label="param ScanIdentifierOrKeyword(ref TokenInfo info) 153329"];
1227 [label="param ScanIdentifierOrKeyword(this) 153330"];
1228 [label="info.ContextualKind 153331"];
1229 [label="if (this.ScanIdentifier(ref info))\n            {\n                // check to see if it is an actual keyword\n                if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                }\n\n                return true;\n            }\n            else\n            {\n                info.Kind = SyntaxKind.None;\n                return false;\n            } 153332"];
1230 [label="this.ScanIdentifier(ref info) 153333"];
1231 [label="param ScanIdentifier(ref TokenInfo info) 153334"];
1232 [label="param ScanIdentifier(this) 153335"];
1233 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 153336"];
1234 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 153337"];
1235 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 153338"];
1236 [label="param Intern(char[] array) 153339"];
1237 [label="param Intern(int start) 153340"];
1238 [label="param Intern(int length) 153341"];
1239 [label="param Intern(this) 153342"];
1240 [label="return _strings.Add(array, start, length); 153343"];
1241 [label="return _strings.Add(array, start, length); 153344"];
1242 [label="return _strings.Add(array, start, length); 153345"];
1243 [label="return _strings.Add(array, start, length); 153346"];
1244 [label="if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                } 153347"];
1245 [label="if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    } 153348"];
1246 [label="this.ModeIs(LexerMode.Directive) 153349"];
1247 [label="param ModeIs(LexerMode mode) 153350"];
1248 [label="param ModeIs(this) 153351"];
1249 [label="return ModeOf(_mode) == mode; 153352"];
1250 [label="ModeOf(_mode) 153353"];
1251 [label="param ModeOf(LexerMode mode) 153354"];
1252 [label="return mode & LexerMode.MaskLexMode; 153355"];
1253 [label="return ModeOf(_mode) == mode; 153356"];
1254 [label="if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 153357"];
1255 [label="_cache.TryGetKeywordKind(info.Text, out info.Kind) 153358"];
1256 [label="param TryGetKeywordKind(string key) 153359"];
1257 [label="param TryGetKeywordKind(out SyntaxKind kind) 153360"];
1258 [label="param TryGetKeywordKind(this) 153361"];
1259 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 153362"];
1260 [label="new SyntaxKindEqualityComparer() 153363"];
1261 [label="param SyntaxKindEqualityComparer(this) 153364"];
1262 [label="public static IEqualityComparer<SyntaxKind> EqualityComparer { get; } = new SyntaxKindEqualityComparer(); 153365"];
1263 [label="kind = _keywordKindMap.GetOrMakeValue(key); 153366"];
1264 [label="kind = _keywordKindMap.GetOrMakeValue(key); 153367"];
1265 [label="kind = _keywordKindMap.GetOrMakeValue(key); 153368"];
1266 [label="param GetKeywordKind(string text) 153369"];
1267 [label="switch (text)\n            {\n                case 'bool':\n                    return SyntaxKind.BoolKeyword;\n                case 'byte':\n                    return SyntaxKind.ByteKeyword;\n                case 'sbyte':\n                    return SyntaxKind.SByteKeyword;\n                case 'short':\n                    return SyntaxKind.ShortKeyword;\n                case 'ushort':\n                    return SyntaxKind.UShortKeyword;\n                case 'int':\n                    return SyntaxKind.IntKeyword;\n                case 'uint':\n                    return SyntaxKind.UIntKeyword;\n                case 'long':\n                    return SyntaxKind.LongKeyword;\n                case 'ulong':\n                    return SyntaxKind.ULongKeyword;\n                case 'double':\n                    return SyntaxKind.DoubleKeyword;\n                case 'float':\n                    return SyntaxKind.FloatKeyword;\n                case 'decimal':\n                    return SyntaxKind.DecimalKeyword;\n                case 'string':\n                    return SyntaxKind.StringKeyword;\n                case 'char':\n                    return SyntaxKind.CharKeyword;\n                case 'void':\n                    return SyntaxKind.VoidKeyword;\n                case 'object':\n                    return SyntaxKind.ObjectKeyword;\n                case 'typeof':\n                    return SyntaxKind.TypeOfKeyword;\n                case 'sizeof':\n                    return SyntaxKind.SizeOfKeyword;\n                case 'null':\n                    return SyntaxKind.NullKeyword;\n                case 'true':\n                    return SyntaxKind.TrueKeyword;\n                case 'false':\n                    return SyntaxKind.FalseKeyword;\n                case 'if':\n                    return SyntaxKind.IfKeyword;\n                case 'else':\n                    return SyntaxKind.ElseKeyword;\n                case 'while':\n                    return SyntaxKind.WhileKeyword;\n                case 'for':\n                    return SyntaxKind.ForKeyword;\n                case 'foreach':\n                    return SyntaxKind.ForEachKeyword;\n                case 'do':\n                    return SyntaxKind.DoKeyword;\n                case 'switch':\n                    return SyntaxKind.SwitchKeyword;\n                case 'case':\n                    return SyntaxKind.CaseKeyword;\n                case 'default':\n                    return SyntaxKind.DefaultKeyword;\n                case 'lock':\n                    return SyntaxKind.LockKeyword;\n                case 'try':\n                    return SyntaxKind.TryKeyword;\n                case 'throw':\n                    return SyntaxKind.ThrowKeyword;\n                case 'catch':\n                    return SyntaxKind.CatchKeyword;\n                case 'finally':\n                    return SyntaxKind.FinallyKeyword;\n                case 'goto':\n                    return SyntaxKind.GotoKeyword;\n                case 'break':\n                    return SyntaxKind.BreakKeyword;\n                case 'continue':\n                    return SyntaxKind.ContinueKeyword;\n                case 'return':\n                    return SyntaxKind.ReturnKeyword;\n                case 'public':\n                    return SyntaxKind.PublicKeyword;\n                case 'private':\n                    return SyntaxKind.PrivateKeyword;\n                case 'internal':\n                    return SyntaxKind.InternalKeyword;\n                case 'protected':\n                    return SyntaxKind.ProtectedKeyword;\n                case 'static':\n                    return SyntaxKind.StaticKeyword;\n                case 'readonly':\n                    return SyntaxKind.ReadOnlyKeyword;\n                case 'sealed':\n                    return SyntaxKind.SealedKeyword;\n                case 'const':\n                    return SyntaxKind.ConstKeyword;\n                case 'fixed':\n                    return SyntaxKind.FixedKeyword;\n                case 'stackalloc':\n                    return SyntaxKind.StackAllocKeyword;\n                case 'volatile':\n                    return SyntaxKind.VolatileKeyword;\n                case 'new':\n                    return SyntaxKind.NewKeyword;\n                case 'override':\n                    return SyntaxKind.OverrideKeyword;\n                case 'abstract':\n                    return SyntaxKind.AbstractKeyword;\n                case 'virtual':\n                    return SyntaxKind.VirtualKeyword;\n                case 'event':\n                    return SyntaxKind.EventKeyword;\n                case 'extern':\n                    return SyntaxKind.ExternKeyword;\n                case 'ref':\n                    return SyntaxKind.RefKeyword;\n                case 'out':\n                    return SyntaxKind.OutKeyword;\n                case 'in':\n                    return SyntaxKind.InKeyword;\n                case 'is':\n                    return SyntaxKind.IsKeyword;\n                case 'as':\n                    return SyntaxKind.AsKeyword;\n                case 'params':\n                    return SyntaxKind.ParamsKeyword;\n                case '__arglist':\n                    return SyntaxKind.ArgListKeyword;\n                case '__makeref':\n                    return SyntaxKind.MakeRefKeyword;\n                case '__reftype':\n                    return SyntaxKind.RefTypeKeyword;\n                case '__refvalue':\n                    return SyntaxKind.RefValueKeyword;\n                case 'this':\n                    return SyntaxKind.ThisKeyword;\n                case 'base':\n                    return SyntaxKind.BaseKeyword;\n                case 'namespace':\n                    return SyntaxKind.NamespaceKeyword;\n                case 'using':\n                    return SyntaxKind.UsingKeyword;\n                case 'class':\n                    return SyntaxKind.ClassKeyword;\n                case 'struct':\n                    return SyntaxKind.StructKeyword;\n                case 'interface':\n                    return SyntaxKind.InterfaceKeyword;\n                case 'enum':\n                    return SyntaxKind.EnumKeyword;\n                case 'delegate':\n                    return SyntaxKind.DelegateKeyword;\n                case 'checked':\n                    return SyntaxKind.CheckedKeyword;\n                case 'unchecked':\n                    return SyntaxKind.UncheckedKeyword;\n                case 'unsafe':\n                    return SyntaxKind.UnsafeKeyword;\n                case 'operator':\n                    return SyntaxKind.OperatorKeyword;\n                case 'implicit':\n                    return SyntaxKind.ImplicitKeyword;\n                case 'explicit':\n                    return SyntaxKind.ExplicitKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 153370"];
1268 [label="return SyntaxKind.SwitchKeyword; 153371"];
1269 [label="return kind != SyntaxKind.None; 153372"];
1270 [label="if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 153373"];
1271 [label="SyntaxFacts.IsContextualKeyword(info.Kind) 153374"];
1272 [label="param IsContextualKeyword(SyntaxKind kind) 153375"];
1273 [label="switch (kind)\n            {\n                case SyntaxKind.YieldKeyword:\n                case SyntaxKind.PartialKeyword:\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.LetKeyword:\n                case SyntaxKind.ByKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                case SyntaxKind.AddKeyword:\n                case SyntaxKind.RemoveKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.AliasKeyword:\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.AssemblyKeyword:\n                case SyntaxKind.ModuleKeyword:\n                case SyntaxKind.TypeKeyword:\n                case SyntaxKind.GlobalKeyword:\n                case SyntaxKind.FieldKeyword:\n                case SyntaxKind.MethodKeyword:\n                case SyntaxKind.ParamKeyword:\n                case SyntaxKind.PropertyKeyword:\n                case SyntaxKind.TypeVarKeyword:\n                case SyntaxKind.NameOfKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.AwaitKeyword:\n                case SyntaxKind.WhenKeyword:\n                case SyntaxKind.UnderscoreToken:\n                case SyntaxKind.VarKeyword:\n                case SyntaxKind.OrKeyword:\n                case SyntaxKind.AndKeyword:\n                case SyntaxKind.NotKeyword:\n                case SyntaxKind.DataKeyword:\n                case SyntaxKind.WithKeyword:\n                case SyntaxKind.InitKeyword:\n                case SyntaxKind.RecordKeyword:\n                case SyntaxKind.ManagedKeyword:\n                case SyntaxKind.UnmanagedKeyword:\n                    return true;\n                default:\n                    return false;\n            } 153376"];
1274 [label="return false; 153377"];
1275 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 153378"];
1276 [label="return true; 153379"];
1277 [label="this.ScanSyntaxToken(ref tokenInfo); 153380"];
1278 [label="var errors = this.GetErrors(GetFullWidth(leading)); 153381"];
1279 [label="GetFullWidth(leading) 153382"];
1280 [label="param GetFullWidth(SyntaxListBuilder builder) 153383"];
1281 [label="int width = 0; 153384"];
1282 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 153385"];
1283 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 153386"];
1284 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 153387"];
1285 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 153388"];
1286 [label="return width; 153389"];
1287 [label="var errors = this.GetErrors(GetFullWidth(leading)); 153390"];
1288 [label="this.GetErrors(GetFullWidth(leading)) 153391"];
1289 [label="param GetErrors(int leadingTriviaWidth) 153392"];
1290 [label="param GetErrors(this) 153393"];
1291 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 153394"];
1292 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 153395"];
1293 [label="return null; 153396"];
1294 [label="var errors = this.GetErrors(GetFullWidth(leading)); 153397"];
1295 [label="_trailingTriviaCache.Clear(); 153398"];
1296 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 153399"];
1297 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 153400"];
1298 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache) 153401"];
1299 [label="param LexSyntaxTrivia(bool afterFirstToken) 153402"];
1300 [label="param LexSyntaxTrivia(bool isTrailing) 153403"];
1301 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 153404"];
1302 [label="param LexSyntaxTrivia(this) 153405"];
1303 [label="bool onlyWhitespaceOnLine = !isTrailing; 153406"];
1304 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 153407"];
1305 [label="this.Start() 153408"];
1306 [label="param Start(this) 153409"];
1307 [label="TextWindow.Start() 153410"];
1308 [label="param Start(this) 153411"];
1309 [label="TextWindow.Start(); 153412"];
1310 [label="_errors = null; 153413"];
1311 [label="_errors 153414"];
1312 [label="this.Start(); 153415"];
1313 [label="TextWindow.PeekChar() 153416"];
1314 [label="param PeekChar(this) 153417"];
1315 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 153418"];
1316 [label="char ch = TextWindow.PeekChar(); 153419"];
1317 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 153420"];
1318 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 153421"];
1319 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 153422"];
1320 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 153423"];
1321 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 153424"];
1322 [label="param AdvanceChar(this) 153425"];
1323 [label="_offset 153426"];
1324 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 153427"];
1325 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 153428"];
1326 [label="return _offset - _lexemeStart; 153429"];
1327 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 153430"];
1328 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList) 153431"];
1329 [label="param AddTrivia(CSharpSyntaxNode trivia) 153432"];
1330 [label="param AddTrivia(ref SyntaxListBuilder list) 153433"];
1331 [label="param AddTrivia(this) 153434"];
1332 [label="this.HasErrors 153435"];
1333 [label="get { return _errors != null; } 153436"];
1334 [label="return _errors != null; 153437"];
1335 [label="return _errors != null; 153438"];
1336 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 153439"];
1337 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 153440"];
1338 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 153441"];
1339 [label="list.Add(trivia); 153442"];
1340 [label="list.Add(trivia); 153443"];
1341 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 153444"];
1342 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 153445"];
1343 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 153446"];
1344 [label="return; 153447"];
1345 [label="var trailing = _trailingTriviaCache; 153448"];
1346 [label="return Create(ref tokenInfo, leading, trailing, errors); 153449"];
1347 [label="return Create(ref tokenInfo, leading, trailing, errors); 153450"];
1348 [label="return Create(ref tokenInfo, leading, trailing, errors); 153451"];
1349 [label="return Create(ref tokenInfo, leading, trailing, errors); 153452"];
1350 [label="Create(ref tokenInfo, leading, trailing, errors) 153453"];
1351 [label="param Create(ref TokenInfo info) 153454"];
1352 [label="param Create(SyntaxListBuilder leading) 153455"];
1353 [label="param Create(SyntaxListBuilder trailing) 153456"];
1354 [label="param Create(SyntaxDiagnosticInfo[] errors) 153457"];
1355 [label="param Create(this) 153458"];
1356 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 153459"];
1357 [label="var leadingNode = leading?.ToListNode(); 153460"];
1358 [label="var trailingNode = trailing?.ToListNode(); 153461"];
1359 [label="SyntaxToken token; 153462"];
1360 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 153463"];
1361 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 153464"];
1362 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 153465"];
1363 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 153466"];
1364 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 153467"];
1365 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 153468"];
1366 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 153469"];
1367 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 153470"];
1368 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 153471"];
1369 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 153472"];
1370 [label="param Token(GreenNode leading) 153473"];
1371 [label="param Token(SyntaxKind kind) 153474"];
1372 [label="param Token(GreenNode trailing) 153475"];
1373 [label="FirstTokenWithWellKnownText = SyntaxKind.TildeToken 153476"];
1374 [label="LastTokenWithWellKnownText = SyntaxKind.EndOfFileToken 153477"];
1375 [label="1 153478"];
1376 [label="(int)LastTokenWithWellKnownText + 1 153479"];
1377 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 153480"];
1378 [label="s_tokensWithNoTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 153481"];
1379 [label="1 153482"];
1380 [label="(int)LastTokenWithWellKnownText + 1 153483"];
1381 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 153484"];
1382 [label="s_tokensWithElasticTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 153485"];
1383 [label="1 153486"];
1384 [label="(int)LastTokenWithWellKnownText + 1 153487"];
1385 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 153488"];
1386 [label="s_tokensWithSingleTrailingSpace = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 153489"];
1387 [label="1 153490"];
1388 [label="(int)LastTokenWithWellKnownText + 1 153491"];
1389 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 153492"];
1390 [label="s_tokensWithSingleTrailingCRLF = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 153493"];
1391 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxToken), r => new SyntaxToken(r)); 153494"];
1392 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 153495"];
1393 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 153496"];
1394 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 153497"];
1395 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 153498"];
1396 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 153499"];
1397 [label="new SyntaxToken(kind) 153500"];
1398 [label="param SyntaxToken(SyntaxKind kind) 153501"];
1399 [label="param SyntaxToken(this) 153502"];
1400 [label="kind 153503"];
1401 [label="param SyntaxToken(this) 153504"];
1402 [label="param CSharpSyntaxNode(SyntaxKind kind) 153505"];
1403 [label="param CSharpSyntaxNode(this) 153506"];
1404 [label="kind 153507"];
1405 [label="param CSharpSyntaxNode(this) 153508"];
1406 [label="param CSharpSyntaxNode(this) 153509"];
1407 [label="GreenStats.NoteGreen(this); 153510"];
1408 [label="GreenStats.NoteGreen(this); 153511"];
1409 [label="this.Text 153512"];
1410 [label="get { return SyntaxFacts.GetText(this.Kind); } 153513"];
1411 [label="this.Kind 153514"];
1412 [label="get { return (SyntaxKind)this.RawKind; } 153515"];
1413 [label="return (SyntaxKind)this.RawKind; 153516"];
1414 [label="return SyntaxFacts.GetText(this.Kind); 153517"];
1415 [label="SyntaxFacts.GetText(this.Kind) 153518"];
1416 [label="param GetText(SyntaxKind kind) 153519"];
1417 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 153520"];
1418 [label="return '~'; 153521"];
1419 [label="FullWidth = this.Text.Length; 153522"];
1420 [label="FullWidth 153523"];
1421 [label="this.flags |= NodeFlags.IsNotMissing; 153524"];
1422 [label="this.flags 153525"];
1423 [label="s_tokensWithNoTrivia[(int)kind].Value 153526"];
1424 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithTrivia), r => new SyntaxTokenWithTrivia(r)); 153527"];
1425 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 153528"];
1426 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 153529"];
1427 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 153530"];
1428 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 153531"];
1429 [label="new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace) 153532"];
1430 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 153533"];
1431 [label="param SyntaxTokenWithTrivia(GreenNode leading) 153534"];
1432 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 153535"];
1433 [label="param SyntaxTokenWithTrivia(this) 153536"];
1434 [label="kind 153537"];
1435 [label="param SyntaxTokenWithTrivia(this) 153538"];
1436 [label="param SyntaxToken(SyntaxKind kind) 153539"];
1437 [label="param SyntaxToken(this) 153540"];
1438 [label="kind 153541"];
1439 [label="param SyntaxToken(this) 153542"];
1440 [label="param CSharpSyntaxNode(SyntaxKind kind) 153543"];
1441 [label="param CSharpSyntaxNode(this) 153544"];
1442 [label="kind 153545"];
1443 [label="param CSharpSyntaxNode(this) 153546"];
1444 [label="param CSharpSyntaxNode(this) 153547"];
1445 [label="GreenStats.NoteGreen(this); 153548"];
1446 [label="GreenStats.NoteGreen(this); 153549"];
1447 [label="this.Text 153550"];
1448 [label="get { return SyntaxFacts.GetText(this.Kind); } 153551"];
1449 [label="this.Kind 153552"];
1450 [label="get { return (SyntaxKind)this.RawKind; } 153553"];
1451 [label="return (SyntaxKind)this.RawKind; 153554"];
1452 [label="return SyntaxFacts.GetText(this.Kind); 153555"];
1453 [label="SyntaxFacts.GetText(this.Kind) 153556"];
1454 [label="param GetText(SyntaxKind kind) 153557"];
1455 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 153558"];
1456 [label="return '~'; 153559"];
1457 [label="FullWidth = this.Text.Length; 153560"];
1458 [label="FullWidth 153561"];
1459 [label="this.flags |= NodeFlags.IsNotMissing; 153562"];
1460 [label="this.flags 153563"];
1461 [label="LeadingField 153564"];
1462 [label="TrailingField 153565"];
1463 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 153566"];
1464 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 153567"];
1465 [label="this.AdjustFlagsAndWidth(leading); 153568"];
1466 [label="this.AdjustFlagsAndWidth(leading); 153569"];
1467 [label="this.LeadingField 153570"];
1468 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 153571"];
1469 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 153572"];
1470 [label="this.AdjustFlagsAndWidth(trailing); 153573"];
1471 [label="this.AdjustFlagsAndWidth(trailing); 153574"];
1472 [label="this.TrailingField 153575"];
1473 [label="s_tokensWithElasticTrivia[(int)kind].Value 153576"];
1474 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 153577"];
1475 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 153578"];
1476 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 153579"];
1477 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 153580"];
1478 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space) 153581"];
1479 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 153582"];
1480 [label="param SyntaxTokenWithTrivia(GreenNode leading) 153583"];
1481 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 153584"];
1482 [label="param SyntaxTokenWithTrivia(this) 153585"];
1483 [label="kind 153586"];
1484 [label="param SyntaxTokenWithTrivia(this) 153587"];
1485 [label="param SyntaxToken(SyntaxKind kind) 153588"];
1486 [label="param SyntaxToken(this) 153589"];
1487 [label="kind 153590"];
1488 [label="param SyntaxToken(this) 153591"];
1489 [label="param CSharpSyntaxNode(SyntaxKind kind) 153592"];
1490 [label="param CSharpSyntaxNode(this) 153593"];
1491 [label="kind 153594"];
1492 [label="param CSharpSyntaxNode(this) 153595"];
1493 [label="param CSharpSyntaxNode(this) 153596"];
1494 [label="GreenStats.NoteGreen(this); 153597"];
1495 [label="GreenStats.NoteGreen(this); 153598"];
1496 [label="this.Text 153599"];
1497 [label="get { return SyntaxFacts.GetText(this.Kind); } 153600"];
1498 [label="this.Kind 153601"];
1499 [label="get { return (SyntaxKind)this.RawKind; } 153602"];
1500 [label="return (SyntaxKind)this.RawKind; 153603"];
1501 [label="return SyntaxFacts.GetText(this.Kind); 153604"];
1502 [label="SyntaxFacts.GetText(this.Kind) 153605"];
1503 [label="param GetText(SyntaxKind kind) 153606"];
1504 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 153607"];
1505 [label="return '~'; 153608"];
1506 [label="FullWidth = this.Text.Length; 153609"];
1507 [label="FullWidth 153610"];
1508 [label="this.flags |= NodeFlags.IsNotMissing; 153611"];
1509 [label="this.flags 153612"];
1510 [label="LeadingField 153613"];
1511 [label="TrailingField 153614"];
1512 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 153615"];
1513 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 153616"];
1514 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 153617"];
1515 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 153618"];
1516 [label="this.AdjustFlagsAndWidth(trailing); 153619"];
1517 [label="this.AdjustFlagsAndWidth(trailing); 153620"];
1518 [label="this.TrailingField 153621"];
1519 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 153622"];
1520 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 153623"];
1521 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 153624"];
1522 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 153625"];
1523 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 153626"];
1524 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed) 153627"];
1525 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 153628"];
1526 [label="param SyntaxTokenWithTrivia(GreenNode leading) 153629"];
1527 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 153630"];
1528 [label="param SyntaxTokenWithTrivia(this) 153631"];
1529 [label="kind 153632"];
1530 [label="param SyntaxTokenWithTrivia(this) 153633"];
1531 [label="param SyntaxToken(SyntaxKind kind) 153634"];
1532 [label="param SyntaxToken(this) 153635"];
1533 [label="kind 153636"];
1534 [label="param SyntaxToken(this) 153637"];
1535 [label="param CSharpSyntaxNode(SyntaxKind kind) 153638"];
1536 [label="param CSharpSyntaxNode(this) 153639"];
1537 [label="kind 153640"];
1538 [label="param CSharpSyntaxNode(this) 153641"];
1539 [label="param CSharpSyntaxNode(this) 153642"];
1540 [label="GreenStats.NoteGreen(this); 153643"];
1541 [label="GreenStats.NoteGreen(this); 153644"];
1542 [label="this.Text 153645"];
1543 [label="get { return SyntaxFacts.GetText(this.Kind); } 153646"];
1544 [label="this.Kind 153647"];
1545 [label="get { return (SyntaxKind)this.RawKind; } 153648"];
1546 [label="return (SyntaxKind)this.RawKind; 153649"];
1547 [label="return SyntaxFacts.GetText(this.Kind); 153650"];
1548 [label="SyntaxFacts.GetText(this.Kind) 153651"];
1549 [label="param GetText(SyntaxKind kind) 153652"];
1550 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 153653"];
1551 [label="return '~'; 153654"];
1552 [label="FullWidth = this.Text.Length; 153655"];
1553 [label="FullWidth 153656"];
1554 [label="this.flags |= NodeFlags.IsNotMissing; 153657"];
1555 [label="this.flags 153658"];
1556 [label="LeadingField 153659"];
1557 [label="TrailingField 153660"];
1558 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 153661"];
1559 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 153662"];
1560 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 153663"];
1561 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 153664"];
1562 [label="this.AdjustFlagsAndWidth(trailing); 153665"];
1563 [label="this.AdjustFlagsAndWidth(trailing); 153666"];
1564 [label="this.TrailingField 153667"];
1565 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 153668"];
1566 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 153669"];
1567 [label="param SyntaxToken(SyntaxKind kind) 153670"];
1568 [label="kind 153671"];
1569 [label="param CSharpSyntaxNode(SyntaxKind kind) 153672"];
1570 [label="kind 153673"];
1571 [label="param CSharpSyntaxNode(this) 153674"];
1572 [label="GreenStats.NoteGreen(this); 153675"];
1573 [label="return (SyntaxKind)this.RawKind; 153676"];
1574 [label="return SyntaxFacts.GetText(this.Kind); 153677"];
1575 [label="param GetText(SyntaxKind kind) 153678"];
1576 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 153679"];
1577 [label="return '!'; 153680"];
1578 [label="FullWidth = this.Text.Length; 153681"];
1579 [label="FullWidth 153682"];
1580 [label="this.flags |= NodeFlags.IsNotMissing; 153683"];
1581 [label="this.flags 153684"];
1582 [label="s_tokensWithNoTrivia[(int)kind].Value 153685"];
1583 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 153686"];
1584 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 153687"];
1585 [label="kind 153688"];
1586 [label="param SyntaxToken(SyntaxKind kind) 153689"];
1587 [label="kind 153690"];
1588 [label="param CSharpSyntaxNode(SyntaxKind kind) 153691"];
1589 [label="kind 153692"];
1590 [label="param CSharpSyntaxNode(this) 153693"];
1591 [label="GreenStats.NoteGreen(this); 153694"];
1592 [label="return (SyntaxKind)this.RawKind; 153695"];
1593 [label="return SyntaxFacts.GetText(this.Kind); 153696"];
1594 [label="param GetText(SyntaxKind kind) 153697"];
1595 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 153698"];
1596 [label="return '!'; 153699"];
1597 [label="FullWidth = this.Text.Length; 153700"];
1598 [label="FullWidth 153701"];
1599 [label="this.flags |= NodeFlags.IsNotMissing; 153702"];
1600 [label="this.flags 153703"];
1601 [label="this.AdjustFlagsAndWidth(leading); 153704"];
1602 [label="s_tokensWithElasticTrivia[(int)kind].Value 153705"];
1603 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 153706"];
1604 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 153707"];
1605 [label="kind 153708"];
1606 [label="param SyntaxToken(SyntaxKind kind) 153709"];
1607 [label="kind 153710"];
1608 [label="param CSharpSyntaxNode(SyntaxKind kind) 153711"];
1609 [label="kind 153712"];
1610 [label="param CSharpSyntaxNode(this) 153713"];
1611 [label="GreenStats.NoteGreen(this); 153714"];
1612 [label="return (SyntaxKind)this.RawKind; 153715"];
1613 [label="return SyntaxFacts.GetText(this.Kind); 153716"];
1614 [label="param GetText(SyntaxKind kind) 153717"];
1615 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 153718"];
1616 [label="return '!'; 153719"];
1617 [label="FullWidth = this.Text.Length; 153720"];
1618 [label="FullWidth 153721"];
1619 [label="this.flags |= NodeFlags.IsNotMissing; 153722"];
1620 [label="this.flags 153723"];
1621 [label="this.AdjustFlagsAndWidth(trailing); 153724"];
1622 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 153725"];
1623 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 153726"];
1624 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 153727"];
1625 [label="kind 153728"];
1626 [label="param SyntaxToken(SyntaxKind kind) 153729"];
1627 [label="kind 153730"];
1628 [label="param CSharpSyntaxNode(SyntaxKind kind) 153731"];
1629 [label="kind 153732"];
1630 [label="param CSharpSyntaxNode(this) 153733"];
1631 [label="GreenStats.NoteGreen(this); 153734"];
1632 [label="return (SyntaxKind)this.RawKind; 153735"];
1633 [label="return SyntaxFacts.GetText(this.Kind); 153736"];
1634 [label="param GetText(SyntaxKind kind) 153737"];
1635 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 153738"];
1636 [label="return '!'; 153739"];
1637 [label="FullWidth = this.Text.Length; 153740"];
1638 [label="FullWidth 153741"];
1639 [label="this.flags |= NodeFlags.IsNotMissing; 153742"];
1640 [label="this.flags 153743"];
1641 [label="this.AdjustFlagsAndWidth(trailing); 153744"];
1642 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 153745"];
1643 [label="return '$'; 153746"];
1644 [label="FullWidth = this.Text.Length; 153747"];
1645 [label="FullWidth 153748"];
1646 [label="return '$'; 153749"];
1647 [label="FullWidth = this.Text.Length; 153750"];
1648 [label="FullWidth 153751"];
1649 [label="this.AdjustFlagsAndWidth(leading); 153752"];
1650 [label="return '$'; 153753"];
1651 [label="FullWidth = this.Text.Length; 153754"];
1652 [label="FullWidth 153755"];
1653 [label="this.AdjustFlagsAndWidth(trailing); 153756"];
1654 [label="return '$'; 153757"];
1655 [label="FullWidth = this.Text.Length; 153758"];
1656 [label="FullWidth 153759"];
1657 [label="this.AdjustFlagsAndWidth(trailing); 153760"];
1658 [label="return '%'; 153761"];
1659 [label="FullWidth = this.Text.Length; 153762"];
1660 [label="FullWidth 153763"];
1661 [label="return '%'; 153764"];
1662 [label="FullWidth = this.Text.Length; 153765"];
1663 [label="FullWidth 153766"];
1664 [label="this.AdjustFlagsAndWidth(leading); 153767"];
1665 [label="return '%'; 153768"];
1666 [label="FullWidth = this.Text.Length; 153769"];
1667 [label="FullWidth 153770"];
1668 [label="this.AdjustFlagsAndWidth(trailing); 153771"];
1669 [label="return '%'; 153772"];
1670 [label="FullWidth = this.Text.Length; 153773"];
1671 [label="FullWidth 153774"];
1672 [label="this.AdjustFlagsAndWidth(trailing); 153775"];
1673 [label="return '^'; 153776"];
1674 [label="FullWidth = this.Text.Length; 153777"];
1675 [label="FullWidth 153778"];
1676 [label="return '^'; 153779"];
1677 [label="FullWidth = this.Text.Length; 153780"];
1678 [label="FullWidth 153781"];
1679 [label="this.AdjustFlagsAndWidth(leading); 153782"];
1680 [label="return '^'; 153783"];
1681 [label="FullWidth = this.Text.Length; 153784"];
1682 [label="FullWidth 153785"];
1683 [label="this.AdjustFlagsAndWidth(trailing); 153786"];
1684 [label="return '^'; 153787"];
1685 [label="FullWidth = this.Text.Length; 153788"];
1686 [label="FullWidth 153789"];
1687 [label="this.AdjustFlagsAndWidth(trailing); 153790"];
1688 [label="return '&'; 153791"];
1689 [label="FullWidth = this.Text.Length; 153792"];
1690 [label="FullWidth 153793"];
1691 [label="return '&'; 153794"];
1692 [label="FullWidth = this.Text.Length; 153795"];
1693 [label="FullWidth 153796"];
1694 [label="this.AdjustFlagsAndWidth(leading); 153797"];
1695 [label="return '&'; 153798"];
1696 [label="FullWidth = this.Text.Length; 153799"];
1697 [label="FullWidth 153800"];
1698 [label="this.AdjustFlagsAndWidth(trailing); 153801"];
1699 [label="return '&'; 153802"];
1700 [label="FullWidth = this.Text.Length; 153803"];
1701 [label="FullWidth 153804"];
1702 [label="this.AdjustFlagsAndWidth(trailing); 153805"];
1703 [label="return '*'; 153806"];
1704 [label="FullWidth = this.Text.Length; 153807"];
1705 [label="FullWidth 153808"];
1706 [label="return '*'; 153809"];
1707 [label="FullWidth = this.Text.Length; 153810"];
1708 [label="FullWidth 153811"];
1709 [label="this.AdjustFlagsAndWidth(leading); 153812"];
1710 [label="return '*'; 153813"];
1711 [label="FullWidth = this.Text.Length; 153814"];
1712 [label="FullWidth 153815"];
1713 [label="this.AdjustFlagsAndWidth(trailing); 153816"];
1714 [label="return '*'; 153817"];
1715 [label="FullWidth = this.Text.Length; 153818"];
1716 [label="FullWidth 153819"];
1717 [label="this.AdjustFlagsAndWidth(trailing); 153820"];
1718 [label="return '('; 153821"];
1719 [label="FullWidth = this.Text.Length; 153822"];
1720 [label="FullWidth 153823"];
1721 [label="return '('; 153824"];
1722 [label="FullWidth = this.Text.Length; 153825"];
1723 [label="FullWidth 153826"];
1724 [label="this.AdjustFlagsAndWidth(leading); 153827"];
1725 [label="return '('; 153828"];
1726 [label="FullWidth = this.Text.Length; 153829"];
1727 [label="FullWidth 153830"];
1728 [label="this.AdjustFlagsAndWidth(trailing); 153831"];
1729 [label="return '('; 153832"];
1730 [label="FullWidth = this.Text.Length; 153833"];
1731 [label="FullWidth 153834"];
1732 [label="this.AdjustFlagsAndWidth(trailing); 153835"];
1733 [label="return ')'; 153836"];
1734 [label="FullWidth = this.Text.Length; 153837"];
1735 [label="FullWidth 153838"];
1736 [label="return ')'; 153839"];
1737 [label="FullWidth = this.Text.Length; 153840"];
1738 [label="FullWidth 153841"];
1739 [label="this.AdjustFlagsAndWidth(leading); 153842"];
1740 [label="return ')'; 153843"];
1741 [label="FullWidth = this.Text.Length; 153844"];
1742 [label="FullWidth 153845"];
1743 [label="this.AdjustFlagsAndWidth(trailing); 153846"];
1744 [label="return ')'; 153847"];
1745 [label="FullWidth = this.Text.Length; 153848"];
1746 [label="FullWidth 153849"];
1747 [label="this.AdjustFlagsAndWidth(trailing); 153850"];
1748 [label="return '-'; 153851"];
1749 [label="FullWidth = this.Text.Length; 153852"];
1750 [label="FullWidth 153853"];
1751 [label="return '-'; 153854"];
1752 [label="FullWidth = this.Text.Length; 153855"];
1753 [label="FullWidth 153856"];
1754 [label="this.AdjustFlagsAndWidth(leading); 153857"];
1755 [label="return '-'; 153858"];
1756 [label="FullWidth = this.Text.Length; 153859"];
1757 [label="FullWidth 153860"];
1758 [label="this.AdjustFlagsAndWidth(trailing); 153861"];
1759 [label="return '-'; 153862"];
1760 [label="FullWidth = this.Text.Length; 153863"];
1761 [label="FullWidth 153864"];
1762 [label="this.AdjustFlagsAndWidth(trailing); 153865"];
1763 [label="return '+'; 153866"];
1764 [label="FullWidth = this.Text.Length; 153867"];
1765 [label="FullWidth 153868"];
1766 [label="return '+'; 153869"];
1767 [label="FullWidth = this.Text.Length; 153870"];
1768 [label="FullWidth 153871"];
1769 [label="this.AdjustFlagsAndWidth(leading); 153872"];
1770 [label="return '+'; 153873"];
1771 [label="FullWidth = this.Text.Length; 153874"];
1772 [label="FullWidth 153875"];
1773 [label="this.AdjustFlagsAndWidth(trailing); 153876"];
1774 [label="return '+'; 153877"];
1775 [label="FullWidth = this.Text.Length; 153878"];
1776 [label="FullWidth 153879"];
1777 [label="this.AdjustFlagsAndWidth(trailing); 153880"];
1778 [label="return '='; 153881"];
1779 [label="FullWidth = this.Text.Length; 153882"];
1780 [label="FullWidth 153883"];
1781 [label="return '='; 153884"];
1782 [label="FullWidth = this.Text.Length; 153885"];
1783 [label="FullWidth 153886"];
1784 [label="this.AdjustFlagsAndWidth(leading); 153887"];
1785 [label="return '='; 153888"];
1786 [label="FullWidth = this.Text.Length; 153889"];
1787 [label="FullWidth 153890"];
1788 [label="this.AdjustFlagsAndWidth(trailing); 153891"];
1789 [label="return '='; 153892"];
1790 [label="FullWidth = this.Text.Length; 153893"];
1791 [label="FullWidth 153894"];
1792 [label="this.AdjustFlagsAndWidth(trailing); 153895"];
1793 [label="return '{'; 153896"];
1794 [label="FullWidth = this.Text.Length; 153897"];
1795 [label="FullWidth 153898"];
1796 [label="return '{'; 153899"];
1797 [label="FullWidth = this.Text.Length; 153900"];
1798 [label="FullWidth 153901"];
1799 [label="this.AdjustFlagsAndWidth(leading); 153902"];
1800 [label="return '{'; 153903"];
1801 [label="FullWidth = this.Text.Length; 153904"];
1802 [label="FullWidth 153905"];
1803 [label="this.AdjustFlagsAndWidth(trailing); 153906"];
1804 [label="return '{'; 153907"];
1805 [label="FullWidth = this.Text.Length; 153908"];
1806 [label="FullWidth 153909"];
1807 [label="this.AdjustFlagsAndWidth(trailing); 153910"];
1808 [label="return '}'; 153911"];
1809 [label="FullWidth = this.Text.Length; 153912"];
1810 [label="FullWidth 153913"];
1811 [label="return '}'; 153914"];
1812 [label="FullWidth = this.Text.Length; 153915"];
1813 [label="FullWidth 153916"];
1814 [label="this.AdjustFlagsAndWidth(leading); 153917"];
1815 [label="return '}'; 153918"];
1816 [label="FullWidth = this.Text.Length; 153919"];
1817 [label="FullWidth 153920"];
1818 [label="this.AdjustFlagsAndWidth(trailing); 153921"];
1819 [label="return '}'; 153922"];
1820 [label="FullWidth = this.Text.Length; 153923"];
1821 [label="FullWidth 153924"];
1822 [label="this.AdjustFlagsAndWidth(trailing); 153925"];
1823 [label="return '['; 153926"];
1824 [label="FullWidth = this.Text.Length; 153927"];
1825 [label="FullWidth 153928"];
1826 [label="return '['; 153929"];
1827 [label="FullWidth = this.Text.Length; 153930"];
1828 [label="FullWidth 153931"];
1829 [label="this.AdjustFlagsAndWidth(leading); 153932"];
1830 [label="return '['; 153933"];
1831 [label="FullWidth = this.Text.Length; 153934"];
1832 [label="FullWidth 153935"];
1833 [label="this.AdjustFlagsAndWidth(trailing); 153936"];
1834 [label="return '['; 153937"];
1835 [label="FullWidth = this.Text.Length; 153938"];
1836 [label="FullWidth 153939"];
1837 [label="this.AdjustFlagsAndWidth(trailing); 153940"];
1838 [label="return ']'; 153941"];
1839 [label="FullWidth = this.Text.Length; 153942"];
1840 [label="FullWidth 153943"];
1841 [label="return ']'; 153944"];
1842 [label="FullWidth = this.Text.Length; 153945"];
1843 [label="FullWidth 153946"];
1844 [label="this.AdjustFlagsAndWidth(leading); 153947"];
1845 [label="return ']'; 153948"];
1846 [label="FullWidth = this.Text.Length; 153949"];
1847 [label="FullWidth 153950"];
1848 [label="this.AdjustFlagsAndWidth(trailing); 153951"];
1849 [label="return ']'; 153952"];
1850 [label="FullWidth = this.Text.Length; 153953"];
1851 [label="FullWidth 153954"];
1852 [label="this.AdjustFlagsAndWidth(trailing); 153955"];
1853 [label="return '|'; 153956"];
1854 [label="FullWidth = this.Text.Length; 153957"];
1855 [label="FullWidth 153958"];
1856 [label="return '|'; 153959"];
1857 [label="FullWidth = this.Text.Length; 153960"];
1858 [label="FullWidth 153961"];
1859 [label="this.AdjustFlagsAndWidth(leading); 153962"];
1860 [label="return '|'; 153963"];
1861 [label="FullWidth = this.Text.Length; 153964"];
1862 [label="FullWidth 153965"];
1863 [label="this.AdjustFlagsAndWidth(trailing); 153966"];
1864 [label="return '|'; 153967"];
1865 [label="FullWidth = this.Text.Length; 153968"];
1866 [label="FullWidth 153969"];
1867 [label="this.AdjustFlagsAndWidth(trailing); 153970"];
1868 [label="return '\\\\'; 153971"];
1869 [label="FullWidth = this.Text.Length; 153972"];
1870 [label="FullWidth 153973"];
1871 [label="return '\\\\'; 153974"];
1872 [label="FullWidth = this.Text.Length; 153975"];
1873 [label="FullWidth 153976"];
1874 [label="this.AdjustFlagsAndWidth(leading); 153977"];
1875 [label="return '\\\\'; 153978"];
1876 [label="FullWidth = this.Text.Length; 153979"];
1877 [label="FullWidth 153980"];
1878 [label="this.AdjustFlagsAndWidth(trailing); 153981"];
1879 [label="return '\\\\'; 153982"];
1880 [label="FullWidth = this.Text.Length; 153983"];
1881 [label="FullWidth 153984"];
1882 [label="this.AdjustFlagsAndWidth(trailing); 153985"];
1883 [label="return ':'; 153986"];
1884 [label="FullWidth = this.Text.Length; 153987"];
1885 [label="FullWidth 153988"];
1886 [label="return ':'; 153989"];
1887 [label="FullWidth = this.Text.Length; 153990"];
1888 [label="FullWidth 153991"];
1889 [label="this.AdjustFlagsAndWidth(leading); 153992"];
1890 [label="return ':'; 153993"];
1891 [label="FullWidth = this.Text.Length; 153994"];
1892 [label="FullWidth 153995"];
1893 [label="this.AdjustFlagsAndWidth(trailing); 153996"];
1894 [label="return ':'; 153997"];
1895 [label="FullWidth = this.Text.Length; 153998"];
1896 [label="FullWidth 153999"];
1897 [label="this.AdjustFlagsAndWidth(trailing); 154000"];
1898 [label="return ';'; 154001"];
1899 [label="FullWidth = this.Text.Length; 154002"];
1900 [label="FullWidth 154003"];
1901 [label="return ';'; 154004"];
1902 [label="FullWidth = this.Text.Length; 154005"];
1903 [label="FullWidth 154006"];
1904 [label="this.AdjustFlagsAndWidth(leading); 154007"];
1905 [label="return ';'; 154008"];
1906 [label="FullWidth = this.Text.Length; 154009"];
1907 [label="FullWidth 154010"];
1908 [label="this.AdjustFlagsAndWidth(trailing); 154011"];
1909 [label="return ';'; 154012"];
1910 [label="FullWidth = this.Text.Length; 154013"];
1911 [label="FullWidth 154014"];
1912 [label="this.AdjustFlagsAndWidth(trailing); 154015"];
1913 [label="return '\\''; 154016"];
1914 [label="FullWidth = this.Text.Length; 154017"];
1915 [label="FullWidth 154018"];
1916 [label="return '\\''; 154019"];
1917 [label="FullWidth = this.Text.Length; 154020"];
1918 [label="FullWidth 154021"];
1919 [label="this.AdjustFlagsAndWidth(leading); 154022"];
1920 [label="return '\\''; 154023"];
1921 [label="FullWidth = this.Text.Length; 154024"];
1922 [label="FullWidth 154025"];
1923 [label="this.AdjustFlagsAndWidth(trailing); 154026"];
1924 [label="return '\\''; 154027"];
1925 [label="FullWidth = this.Text.Length; 154028"];
1926 [label="FullWidth 154029"];
1927 [label="this.AdjustFlagsAndWidth(trailing); 154030"];
1928 [label="return '''; 154031"];
1929 [label="FullWidth = this.Text.Length; 154032"];
1930 [label="FullWidth 154033"];
1931 [label="return '''; 154034"];
1932 [label="FullWidth = this.Text.Length; 154035"];
1933 [label="FullWidth 154036"];
1934 [label="this.AdjustFlagsAndWidth(leading); 154037"];
1935 [label="return '''; 154038"];
1936 [label="FullWidth = this.Text.Length; 154039"];
1937 [label="FullWidth 154040"];
1938 [label="this.AdjustFlagsAndWidth(trailing); 154041"];
1939 [label="return '''; 154042"];
1940 [label="FullWidth = this.Text.Length; 154043"];
1941 [label="FullWidth 154044"];
1942 [label="this.AdjustFlagsAndWidth(trailing); 154045"];
1943 [label="return '<'; 154046"];
1944 [label="FullWidth = this.Text.Length; 154047"];
1945 [label="FullWidth 154048"];
1946 [label="return '<'; 154049"];
1947 [label="FullWidth = this.Text.Length; 154050"];
1948 [label="FullWidth 154051"];
1949 [label="this.AdjustFlagsAndWidth(leading); 154052"];
1950 [label="return '<'; 154053"];
1951 [label="FullWidth = this.Text.Length; 154054"];
1952 [label="FullWidth 154055"];
1953 [label="this.AdjustFlagsAndWidth(trailing); 154056"];
1954 [label="return '<'; 154057"];
1955 [label="FullWidth = this.Text.Length; 154058"];
1956 [label="FullWidth 154059"];
1957 [label="this.AdjustFlagsAndWidth(trailing); 154060"];
1958 [label="return ','; 154061"];
1959 [label="FullWidth = this.Text.Length; 154062"];
1960 [label="FullWidth 154063"];
1961 [label="return ','; 154064"];
1962 [label="FullWidth = this.Text.Length; 154065"];
1963 [label="FullWidth 154066"];
1964 [label="this.AdjustFlagsAndWidth(leading); 154067"];
1965 [label="return ','; 154068"];
1966 [label="FullWidth = this.Text.Length; 154069"];
1967 [label="FullWidth 154070"];
1968 [label="this.AdjustFlagsAndWidth(trailing); 154071"];
1969 [label="return ','; 154072"];
1970 [label="FullWidth = this.Text.Length; 154073"];
1971 [label="FullWidth 154074"];
1972 [label="this.AdjustFlagsAndWidth(trailing); 154075"];
1973 [label="return '>'; 154076"];
1974 [label="FullWidth = this.Text.Length; 154077"];
1975 [label="FullWidth 154078"];
1976 [label="return '>'; 154079"];
1977 [label="FullWidth = this.Text.Length; 154080"];
1978 [label="FullWidth 154081"];
1979 [label="this.AdjustFlagsAndWidth(leading); 154082"];
1980 [label="return '>'; 154083"];
1981 [label="FullWidth = this.Text.Length; 154084"];
1982 [label="FullWidth 154085"];
1983 [label="this.AdjustFlagsAndWidth(trailing); 154086"];
1984 [label="return '>'; 154087"];
1985 [label="FullWidth = this.Text.Length; 154088"];
1986 [label="FullWidth 154089"];
1987 [label="this.AdjustFlagsAndWidth(trailing); 154090"];
1988 [label="return '.'; 154091"];
1989 [label="FullWidth = this.Text.Length; 154092"];
1990 [label="FullWidth 154093"];
1991 [label="return '.'; 154094"];
1992 [label="FullWidth = this.Text.Length; 154095"];
1993 [label="FullWidth 154096"];
1994 [label="this.AdjustFlagsAndWidth(leading); 154097"];
1995 [label="return '.'; 154098"];
1996 [label="FullWidth = this.Text.Length; 154099"];
1997 [label="FullWidth 154100"];
1998 [label="this.AdjustFlagsAndWidth(trailing); 154101"];
1999 [label="return '.'; 154102"];
2000 [label="FullWidth = this.Text.Length; 154103"];
2001 [label="FullWidth 154104"];
2002 [label="this.AdjustFlagsAndWidth(trailing); 154105"];
2003 [label="return '?'; 154106"];
2004 [label="FullWidth = this.Text.Length; 154107"];
2005 [label="FullWidth 154108"];
2006 [label="return '?'; 154109"];
2007 [label="FullWidth = this.Text.Length; 154110"];
2008 [label="FullWidth 154111"];
2009 [label="this.AdjustFlagsAndWidth(leading); 154112"];
2010 [label="return '?'; 154113"];
2011 [label="FullWidth = this.Text.Length; 154114"];
2012 [label="FullWidth 154115"];
2013 [label="this.AdjustFlagsAndWidth(trailing); 154116"];
2014 [label="return '?'; 154117"];
2015 [label="FullWidth = this.Text.Length; 154118"];
2016 [label="FullWidth 154119"];
2017 [label="this.AdjustFlagsAndWidth(trailing); 154120"];
2018 [label="return '#'; 154121"];
2019 [label="FullWidth = this.Text.Length; 154122"];
2020 [label="FullWidth 154123"];
2021 [label="return '#'; 154124"];
2022 [label="FullWidth = this.Text.Length; 154125"];
2023 [label="FullWidth 154126"];
2024 [label="this.AdjustFlagsAndWidth(leading); 154127"];
2025 [label="return '#'; 154128"];
2026 [label="FullWidth = this.Text.Length; 154129"];
2027 [label="FullWidth 154130"];
2028 [label="this.AdjustFlagsAndWidth(trailing); 154131"];
2029 [label="return '#'; 154132"];
2030 [label="FullWidth = this.Text.Length; 154133"];
2031 [label="FullWidth 154134"];
2032 [label="this.AdjustFlagsAndWidth(trailing); 154135"];
2033 [label="return '/'; 154136"];
2034 [label="FullWidth = this.Text.Length; 154137"];
2035 [label="FullWidth 154138"];
2036 [label="return '/'; 154139"];
2037 [label="FullWidth = this.Text.Length; 154140"];
2038 [label="FullWidth 154141"];
2039 [label="this.AdjustFlagsAndWidth(leading); 154142"];
2040 [label="return '/'; 154143"];
2041 [label="FullWidth = this.Text.Length; 154144"];
2042 [label="FullWidth 154145"];
2043 [label="this.AdjustFlagsAndWidth(trailing); 154146"];
2044 [label="return '/'; 154147"];
2045 [label="FullWidth = this.Text.Length; 154148"];
2046 [label="FullWidth 154149"];
2047 [label="this.AdjustFlagsAndWidth(trailing); 154150"];
2048 [label="return '..'; 154151"];
2049 [label="FullWidth = this.Text.Length; 154152"];
2050 [label="FullWidth 154153"];
2051 [label="return '..'; 154154"];
2052 [label="FullWidth = this.Text.Length; 154155"];
2053 [label="FullWidth 154156"];
2054 [label="this.AdjustFlagsAndWidth(leading); 154157"];
2055 [label="return '..'; 154158"];
2056 [label="FullWidth = this.Text.Length; 154159"];
2057 [label="FullWidth 154160"];
2058 [label="this.AdjustFlagsAndWidth(trailing); 154161"];
2059 [label="return '..'; 154162"];
2060 [label="FullWidth = this.Text.Length; 154163"];
2061 [label="FullWidth 154164"];
2062 [label="this.AdjustFlagsAndWidth(trailing); 154165"];
2063 [label="return string.Empty; 154166"];
2064 [label="FullWidth = this.Text.Length; 154167"];
2065 [label="FullWidth 154168"];
2066 [label="return string.Empty; 154169"];
2067 [label="FullWidth = this.Text.Length; 154170"];
2068 [label="FullWidth 154171"];
2069 [label="this.AdjustFlagsAndWidth(leading); 154172"];
2070 [label="return string.Empty; 154173"];
2071 [label="FullWidth = this.Text.Length; 154174"];
2072 [label="FullWidth 154175"];
2073 [label="this.AdjustFlagsAndWidth(trailing); 154176"];
2074 [label="return string.Empty; 154177"];
2075 [label="FullWidth = this.Text.Length; 154178"];
2076 [label="FullWidth 154179"];
2077 [label="this.AdjustFlagsAndWidth(trailing); 154180"];
2078 [label="return '/>'; 154181"];
2079 [label="FullWidth = this.Text.Length; 154182"];
2080 [label="FullWidth 154183"];
2081 [label="return '/>'; 154184"];
2082 [label="FullWidth = this.Text.Length; 154185"];
2083 [label="FullWidth 154186"];
2084 [label="this.AdjustFlagsAndWidth(leading); 154187"];
2085 [label="return '/>'; 154188"];
2086 [label="FullWidth = this.Text.Length; 154189"];
2087 [label="FullWidth 154190"];
2088 [label="this.AdjustFlagsAndWidth(trailing); 154191"];
2089 [label="return '/>'; 154192"];
2090 [label="FullWidth = this.Text.Length; 154193"];
2091 [label="FullWidth 154194"];
2092 [label="this.AdjustFlagsAndWidth(trailing); 154195"];
2093 [label="return '</'; 154196"];
2094 [label="FullWidth = this.Text.Length; 154197"];
2095 [label="FullWidth 154198"];
2096 [label="return '</'; 154199"];
2097 [label="FullWidth = this.Text.Length; 154200"];
2098 [label="FullWidth 154201"];
2099 [label="this.AdjustFlagsAndWidth(leading); 154202"];
2100 [label="return '</'; 154203"];
2101 [label="FullWidth = this.Text.Length; 154204"];
2102 [label="FullWidth 154205"];
2103 [label="this.AdjustFlagsAndWidth(trailing); 154206"];
2104 [label="return '</'; 154207"];
2105 [label="FullWidth = this.Text.Length; 154208"];
2106 [label="FullWidth 154209"];
2107 [label="this.AdjustFlagsAndWidth(trailing); 154210"];
2108 [label="return '<!--'; 154211"];
2109 [label="FullWidth = this.Text.Length; 154212"];
2110 [label="FullWidth 154213"];
2111 [label="return '<!--'; 154214"];
2112 [label="FullWidth = this.Text.Length; 154215"];
2113 [label="FullWidth 154216"];
2114 [label="this.AdjustFlagsAndWidth(leading); 154217"];
2115 [label="return '<!--'; 154218"];
2116 [label="FullWidth = this.Text.Length; 154219"];
2117 [label="FullWidth 154220"];
2118 [label="this.AdjustFlagsAndWidth(trailing); 154221"];
2119 [label="return '<!--'; 154222"];
2120 [label="FullWidth = this.Text.Length; 154223"];
2121 [label="FullWidth 154224"];
2122 [label="this.AdjustFlagsAndWidth(trailing); 154225"];
2123 [label="return '-->'; 154226"];
2124 [label="FullWidth = this.Text.Length; 154227"];
2125 [label="FullWidth 154228"];
2126 [label="return '-->'; 154229"];
2127 [label="FullWidth = this.Text.Length; 154230"];
2128 [label="FullWidth 154231"];
2129 [label="this.AdjustFlagsAndWidth(leading); 154232"];
2130 [label="return '-->'; 154233"];
2131 [label="FullWidth = this.Text.Length; 154234"];
2132 [label="FullWidth 154235"];
2133 [label="this.AdjustFlagsAndWidth(trailing); 154236"];
2134 [label="return '-->'; 154237"];
2135 [label="FullWidth = this.Text.Length; 154238"];
2136 [label="FullWidth 154239"];
2137 [label="this.AdjustFlagsAndWidth(trailing); 154240"];
2138 [label="return '<![CDATA['; 154241"];
2139 [label="FullWidth = this.Text.Length; 154242"];
2140 [label="FullWidth 154243"];
2141 [label="return '<![CDATA['; 154244"];
2142 [label="FullWidth = this.Text.Length; 154245"];
2143 [label="FullWidth 154246"];
2144 [label="this.AdjustFlagsAndWidth(leading); 154247"];
2145 [label="return '<![CDATA['; 154248"];
2146 [label="FullWidth = this.Text.Length; 154249"];
2147 [label="FullWidth 154250"];
2148 [label="this.AdjustFlagsAndWidth(trailing); 154251"];
2149 [label="return '<![CDATA['; 154252"];
2150 [label="FullWidth = this.Text.Length; 154253"];
2151 [label="FullWidth 154254"];
2152 [label="this.AdjustFlagsAndWidth(trailing); 154255"];
2153 [label="return ']]>'; 154256"];
2154 [label="FullWidth = this.Text.Length; 154257"];
2155 [label="FullWidth 154258"];
2156 [label="return ']]>'; 154259"];
2157 [label="FullWidth = this.Text.Length; 154260"];
2158 [label="FullWidth 154261"];
2159 [label="this.AdjustFlagsAndWidth(leading); 154262"];
2160 [label="return ']]>'; 154263"];
2161 [label="FullWidth = this.Text.Length; 154264"];
2162 [label="FullWidth 154265"];
2163 [label="this.AdjustFlagsAndWidth(trailing); 154266"];
2164 [label="return ']]>'; 154267"];
2165 [label="FullWidth = this.Text.Length; 154268"];
2166 [label="FullWidth 154269"];
2167 [label="this.AdjustFlagsAndWidth(trailing); 154270"];
2168 [label="return '<?'; 154271"];
2169 [label="FullWidth = this.Text.Length; 154272"];
2170 [label="FullWidth 154273"];
2171 [label="return '<?'; 154274"];
2172 [label="FullWidth = this.Text.Length; 154275"];
2173 [label="FullWidth 154276"];
2174 [label="this.AdjustFlagsAndWidth(leading); 154277"];
2175 [label="return '<?'; 154278"];
2176 [label="FullWidth = this.Text.Length; 154279"];
2177 [label="FullWidth 154280"];
2178 [label="this.AdjustFlagsAndWidth(trailing); 154281"];
2179 [label="return '<?'; 154282"];
2180 [label="FullWidth = this.Text.Length; 154283"];
2181 [label="FullWidth 154284"];
2182 [label="this.AdjustFlagsAndWidth(trailing); 154285"];
2183 [label="return '?>'; 154286"];
2184 [label="FullWidth = this.Text.Length; 154287"];
2185 [label="FullWidth 154288"];
2186 [label="return '?>'; 154289"];
2187 [label="FullWidth = this.Text.Length; 154290"];
2188 [label="FullWidth 154291"];
2189 [label="this.AdjustFlagsAndWidth(leading); 154292"];
2190 [label="return '?>'; 154293"];
2191 [label="FullWidth = this.Text.Length; 154294"];
2192 [label="FullWidth 154295"];
2193 [label="this.AdjustFlagsAndWidth(trailing); 154296"];
2194 [label="return '?>'; 154297"];
2195 [label="FullWidth = this.Text.Length; 154298"];
2196 [label="FullWidth 154299"];
2197 [label="this.AdjustFlagsAndWidth(trailing); 154300"];
2198 [label="return '||'; 154301"];
2199 [label="FullWidth = this.Text.Length; 154302"];
2200 [label="FullWidth 154303"];
2201 [label="return '||'; 154304"];
2202 [label="FullWidth = this.Text.Length; 154305"];
2203 [label="FullWidth 154306"];
2204 [label="this.AdjustFlagsAndWidth(leading); 154307"];
2205 [label="return '||'; 154308"];
2206 [label="FullWidth = this.Text.Length; 154309"];
2207 [label="FullWidth 154310"];
2208 [label="this.AdjustFlagsAndWidth(trailing); 154311"];
2209 [label="return '||'; 154312"];
2210 [label="FullWidth = this.Text.Length; 154313"];
2211 [label="FullWidth 154314"];
2212 [label="this.AdjustFlagsAndWidth(trailing); 154315"];
2213 [label="return '&&'; 154316"];
2214 [label="FullWidth = this.Text.Length; 154317"];
2215 [label="FullWidth 154318"];
2216 [label="return '&&'; 154319"];
2217 [label="FullWidth = this.Text.Length; 154320"];
2218 [label="FullWidth 154321"];
2219 [label="this.AdjustFlagsAndWidth(leading); 154322"];
2220 [label="return '&&'; 154323"];
2221 [label="FullWidth = this.Text.Length; 154324"];
2222 [label="FullWidth 154325"];
2223 [label="this.AdjustFlagsAndWidth(trailing); 154326"];
2224 [label="return '&&'; 154327"];
2225 [label="FullWidth = this.Text.Length; 154328"];
2226 [label="FullWidth 154329"];
2227 [label="this.AdjustFlagsAndWidth(trailing); 154330"];
2228 [label="return '--'; 154331"];
2229 [label="FullWidth = this.Text.Length; 154332"];
2230 [label="FullWidth 154333"];
2231 [label="return '--'; 154334"];
2232 [label="FullWidth = this.Text.Length; 154335"];
2233 [label="FullWidth 154336"];
2234 [label="this.AdjustFlagsAndWidth(leading); 154337"];
2235 [label="return '--'; 154338"];
2236 [label="FullWidth = this.Text.Length; 154339"];
2237 [label="FullWidth 154340"];
2238 [label="this.AdjustFlagsAndWidth(trailing); 154341"];
2239 [label="return '--'; 154342"];
2240 [label="FullWidth = this.Text.Length; 154343"];
2241 [label="FullWidth 154344"];
2242 [label="this.AdjustFlagsAndWidth(trailing); 154345"];
2243 [label="return '++'; 154346"];
2244 [label="FullWidth = this.Text.Length; 154347"];
2245 [label="FullWidth 154348"];
2246 [label="return '++'; 154349"];
2247 [label="FullWidth = this.Text.Length; 154350"];
2248 [label="FullWidth 154351"];
2249 [label="this.AdjustFlagsAndWidth(leading); 154352"];
2250 [label="return '++'; 154353"];
2251 [label="FullWidth = this.Text.Length; 154354"];
2252 [label="FullWidth 154355"];
2253 [label="this.AdjustFlagsAndWidth(trailing); 154356"];
2254 [label="return '++'; 154357"];
2255 [label="FullWidth = this.Text.Length; 154358"];
2256 [label="FullWidth 154359"];
2257 [label="this.AdjustFlagsAndWidth(trailing); 154360"];
2258 [label="return '::'; 154361"];
2259 [label="FullWidth = this.Text.Length; 154362"];
2260 [label="FullWidth 154363"];
2261 [label="return '::'; 154364"];
2262 [label="FullWidth = this.Text.Length; 154365"];
2263 [label="FullWidth 154366"];
2264 [label="this.AdjustFlagsAndWidth(leading); 154367"];
2265 [label="return '::'; 154368"];
2266 [label="FullWidth = this.Text.Length; 154369"];
2267 [label="FullWidth 154370"];
2268 [label="this.AdjustFlagsAndWidth(trailing); 154371"];
2269 [label="return '::'; 154372"];
2270 [label="FullWidth = this.Text.Length; 154373"];
2271 [label="FullWidth 154374"];
2272 [label="this.AdjustFlagsAndWidth(trailing); 154375"];
2273 [label="return '??'; 154376"];
2274 [label="FullWidth = this.Text.Length; 154377"];
2275 [label="FullWidth 154378"];
2276 [label="return '??'; 154379"];
2277 [label="FullWidth = this.Text.Length; 154380"];
2278 [label="FullWidth 154381"];
2279 [label="this.AdjustFlagsAndWidth(leading); 154382"];
2280 [label="return '??'; 154383"];
2281 [label="FullWidth = this.Text.Length; 154384"];
2282 [label="FullWidth 154385"];
2283 [label="this.AdjustFlagsAndWidth(trailing); 154386"];
2284 [label="return '??'; 154387"];
2285 [label="FullWidth = this.Text.Length; 154388"];
2286 [label="FullWidth 154389"];
2287 [label="this.AdjustFlagsAndWidth(trailing); 154390"];
2288 [label="return '->'; 154391"];
2289 [label="FullWidth = this.Text.Length; 154392"];
2290 [label="FullWidth 154393"];
2291 [label="return '->'; 154394"];
2292 [label="FullWidth = this.Text.Length; 154395"];
2293 [label="FullWidth 154396"];
2294 [label="this.AdjustFlagsAndWidth(leading); 154397"];
2295 [label="return '->'; 154398"];
2296 [label="FullWidth = this.Text.Length; 154399"];
2297 [label="FullWidth 154400"];
2298 [label="this.AdjustFlagsAndWidth(trailing); 154401"];
2299 [label="return '->'; 154402"];
2300 [label="FullWidth = this.Text.Length; 154403"];
2301 [label="FullWidth 154404"];
2302 [label="this.AdjustFlagsAndWidth(trailing); 154405"];
2303 [label="return '!='; 154406"];
2304 [label="FullWidth = this.Text.Length; 154407"];
2305 [label="FullWidth 154408"];
2306 [label="return '!='; 154409"];
2307 [label="FullWidth = this.Text.Length; 154410"];
2308 [label="FullWidth 154411"];
2309 [label="this.AdjustFlagsAndWidth(leading); 154412"];
2310 [label="return '!='; 154413"];
2311 [label="FullWidth = this.Text.Length; 154414"];
2312 [label="FullWidth 154415"];
2313 [label="this.AdjustFlagsAndWidth(trailing); 154416"];
2314 [label="return '!='; 154417"];
2315 [label="FullWidth = this.Text.Length; 154418"];
2316 [label="FullWidth 154419"];
2317 [label="this.AdjustFlagsAndWidth(trailing); 154420"];
2318 [label="return '=='; 154421"];
2319 [label="FullWidth = this.Text.Length; 154422"];
2320 [label="FullWidth 154423"];
2321 [label="return '=='; 154424"];
2322 [label="FullWidth = this.Text.Length; 154425"];
2323 [label="FullWidth 154426"];
2324 [label="this.AdjustFlagsAndWidth(leading); 154427"];
2325 [label="return '=='; 154428"];
2326 [label="FullWidth = this.Text.Length; 154429"];
2327 [label="FullWidth 154430"];
2328 [label="this.AdjustFlagsAndWidth(trailing); 154431"];
2329 [label="return '=='; 154432"];
2330 [label="FullWidth = this.Text.Length; 154433"];
2331 [label="FullWidth 154434"];
2332 [label="this.AdjustFlagsAndWidth(trailing); 154435"];
2333 [label="return '=>'; 154436"];
2334 [label="FullWidth = this.Text.Length; 154437"];
2335 [label="FullWidth 154438"];
2336 [label="return '=>'; 154439"];
2337 [label="FullWidth = this.Text.Length; 154440"];
2338 [label="FullWidth 154441"];
2339 [label="this.AdjustFlagsAndWidth(leading); 154442"];
2340 [label="return '=>'; 154443"];
2341 [label="FullWidth = this.Text.Length; 154444"];
2342 [label="FullWidth 154445"];
2343 [label="this.AdjustFlagsAndWidth(trailing); 154446"];
2344 [label="return '=>'; 154447"];
2345 [label="FullWidth = this.Text.Length; 154448"];
2346 [label="FullWidth 154449"];
2347 [label="this.AdjustFlagsAndWidth(trailing); 154450"];
2348 [label="return '<='; 154451"];
2349 [label="FullWidth = this.Text.Length; 154452"];
2350 [label="FullWidth 154453"];
2351 [label="return '<='; 154454"];
2352 [label="FullWidth = this.Text.Length; 154455"];
2353 [label="FullWidth 154456"];
2354 [label="this.AdjustFlagsAndWidth(leading); 154457"];
2355 [label="return '<='; 154458"];
2356 [label="FullWidth = this.Text.Length; 154459"];
2357 [label="FullWidth 154460"];
2358 [label="this.AdjustFlagsAndWidth(trailing); 154461"];
2359 [label="return '<='; 154462"];
2360 [label="FullWidth = this.Text.Length; 154463"];
2361 [label="FullWidth 154464"];
2362 [label="this.AdjustFlagsAndWidth(trailing); 154465"];
2363 [label="return '<<'; 154466"];
2364 [label="FullWidth = this.Text.Length; 154467"];
2365 [label="FullWidth 154468"];
2366 [label="return '<<'; 154469"];
2367 [label="FullWidth = this.Text.Length; 154470"];
2368 [label="FullWidth 154471"];
2369 [label="this.AdjustFlagsAndWidth(leading); 154472"];
2370 [label="return '<<'; 154473"];
2371 [label="FullWidth = this.Text.Length; 154474"];
2372 [label="FullWidth 154475"];
2373 [label="this.AdjustFlagsAndWidth(trailing); 154476"];
2374 [label="return '<<'; 154477"];
2375 [label="FullWidth = this.Text.Length; 154478"];
2376 [label="FullWidth 154479"];
2377 [label="this.AdjustFlagsAndWidth(trailing); 154480"];
2378 [label="return '<<='; 154481"];
2379 [label="FullWidth = this.Text.Length; 154482"];
2380 [label="FullWidth 154483"];
2381 [label="return '<<='; 154484"];
2382 [label="FullWidth = this.Text.Length; 154485"];
2383 [label="FullWidth 154486"];
2384 [label="this.AdjustFlagsAndWidth(leading); 154487"];
2385 [label="return '<<='; 154488"];
2386 [label="FullWidth = this.Text.Length; 154489"];
2387 [label="FullWidth 154490"];
2388 [label="this.AdjustFlagsAndWidth(trailing); 154491"];
2389 [label="return '<<='; 154492"];
2390 [label="FullWidth = this.Text.Length; 154493"];
2391 [label="FullWidth 154494"];
2392 [label="this.AdjustFlagsAndWidth(trailing); 154495"];
2393 [label="return '>='; 154496"];
2394 [label="FullWidth = this.Text.Length; 154497"];
2395 [label="FullWidth 154498"];
2396 [label="return '>='; 154499"];
2397 [label="FullWidth = this.Text.Length; 154500"];
2398 [label="FullWidth 154501"];
2399 [label="this.AdjustFlagsAndWidth(leading); 154502"];
2400 [label="return '>='; 154503"];
2401 [label="FullWidth = this.Text.Length; 154504"];
2402 [label="FullWidth 154505"];
2403 [label="this.AdjustFlagsAndWidth(trailing); 154506"];
2404 [label="return '>='; 154507"];
2405 [label="FullWidth = this.Text.Length; 154508"];
2406 [label="FullWidth 154509"];
2407 [label="this.AdjustFlagsAndWidth(trailing); 154510"];
2408 [label="return '>>'; 154511"];
2409 [label="FullWidth = this.Text.Length; 154512"];
2410 [label="FullWidth 154513"];
2411 [label="return '>>'; 154514"];
2412 [label="FullWidth = this.Text.Length; 154515"];
2413 [label="FullWidth 154516"];
2414 [label="this.AdjustFlagsAndWidth(leading); 154517"];
2415 [label="return '>>'; 154518"];
2416 [label="FullWidth = this.Text.Length; 154519"];
2417 [label="FullWidth 154520"];
2418 [label="this.AdjustFlagsAndWidth(trailing); 154521"];
2419 [label="return '>>'; 154522"];
2420 [label="FullWidth = this.Text.Length; 154523"];
2421 [label="FullWidth 154524"];
2422 [label="this.AdjustFlagsAndWidth(trailing); 154525"];
2423 [label="return '>>='; 154526"];
2424 [label="FullWidth = this.Text.Length; 154527"];
2425 [label="FullWidth 154528"];
2426 [label="return '>>='; 154529"];
2427 [label="FullWidth = this.Text.Length; 154530"];
2428 [label="FullWidth 154531"];
2429 [label="this.AdjustFlagsAndWidth(leading); 154532"];
2430 [label="return '>>='; 154533"];
2431 [label="FullWidth = this.Text.Length; 154534"];
2432 [label="FullWidth 154535"];
2433 [label="this.AdjustFlagsAndWidth(trailing); 154536"];
2434 [label="return '>>='; 154537"];
2435 [label="FullWidth = this.Text.Length; 154538"];
2436 [label="FullWidth 154539"];
2437 [label="this.AdjustFlagsAndWidth(trailing); 154540"];
2438 [label="return '/='; 154541"];
2439 [label="FullWidth = this.Text.Length; 154542"];
2440 [label="FullWidth 154543"];
2441 [label="return '/='; 154544"];
2442 [label="FullWidth = this.Text.Length; 154545"];
2443 [label="FullWidth 154546"];
2444 [label="this.AdjustFlagsAndWidth(leading); 154547"];
2445 [label="return '/='; 154548"];
2446 [label="FullWidth = this.Text.Length; 154549"];
2447 [label="FullWidth 154550"];
2448 [label="this.AdjustFlagsAndWidth(trailing); 154551"];
2449 [label="return '/='; 154552"];
2450 [label="FullWidth = this.Text.Length; 154553"];
2451 [label="FullWidth 154554"];
2452 [label="this.AdjustFlagsAndWidth(trailing); 154555"];
2453 [label="return '*='; 154556"];
2454 [label="FullWidth = this.Text.Length; 154557"];
2455 [label="FullWidth 154558"];
2456 [label="return '*='; 154559"];
2457 [label="FullWidth = this.Text.Length; 154560"];
2458 [label="FullWidth 154561"];
2459 [label="this.AdjustFlagsAndWidth(leading); 154562"];
2460 [label="return '*='; 154563"];
2461 [label="FullWidth = this.Text.Length; 154564"];
2462 [label="FullWidth 154565"];
2463 [label="this.AdjustFlagsAndWidth(trailing); 154566"];
2464 [label="return '*='; 154567"];
2465 [label="FullWidth = this.Text.Length; 154568"];
2466 [label="FullWidth 154569"];
2467 [label="this.AdjustFlagsAndWidth(trailing); 154570"];
2468 [label="return '|='; 154571"];
2469 [label="FullWidth = this.Text.Length; 154572"];
2470 [label="FullWidth 154573"];
2471 [label="return '|='; 154574"];
2472 [label="FullWidth = this.Text.Length; 154575"];
2473 [label="FullWidth 154576"];
2474 [label="this.AdjustFlagsAndWidth(leading); 154577"];
2475 [label="return '|='; 154578"];
2476 [label="FullWidth = this.Text.Length; 154579"];
2477 [label="FullWidth 154580"];
2478 [label="this.AdjustFlagsAndWidth(trailing); 154581"];
2479 [label="return '|='; 154582"];
2480 [label="FullWidth = this.Text.Length; 154583"];
2481 [label="FullWidth 154584"];
2482 [label="this.AdjustFlagsAndWidth(trailing); 154585"];
2483 [label="return '&='; 154586"];
2484 [label="FullWidth = this.Text.Length; 154587"];
2485 [label="FullWidth 154588"];
2486 [label="return '&='; 154589"];
2487 [label="FullWidth = this.Text.Length; 154590"];
2488 [label="FullWidth 154591"];
2489 [label="this.AdjustFlagsAndWidth(leading); 154592"];
2490 [label="return '&='; 154593"];
2491 [label="FullWidth = this.Text.Length; 154594"];
2492 [label="FullWidth 154595"];
2493 [label="this.AdjustFlagsAndWidth(trailing); 154596"];
2494 [label="return '&='; 154597"];
2495 [label="FullWidth = this.Text.Length; 154598"];
2496 [label="FullWidth 154599"];
2497 [label="this.AdjustFlagsAndWidth(trailing); 154600"];
2498 [label="return '+='; 154601"];
2499 [label="FullWidth = this.Text.Length; 154602"];
2500 [label="FullWidth 154603"];
2501 [label="return '+='; 154604"];
2502 [label="FullWidth = this.Text.Length; 154605"];
2503 [label="FullWidth 154606"];
2504 [label="this.AdjustFlagsAndWidth(leading); 154607"];
2505 [label="return '+='; 154608"];
2506 [label="FullWidth = this.Text.Length; 154609"];
2507 [label="FullWidth 154610"];
2508 [label="this.AdjustFlagsAndWidth(trailing); 154611"];
2509 [label="return '+='; 154612"];
2510 [label="FullWidth = this.Text.Length; 154613"];
2511 [label="FullWidth 154614"];
2512 [label="this.AdjustFlagsAndWidth(trailing); 154615"];
2513 [label="return '-='; 154616"];
2514 [label="FullWidth = this.Text.Length; 154617"];
2515 [label="FullWidth 154618"];
2516 [label="return '-='; 154619"];
2517 [label="FullWidth = this.Text.Length; 154620"];
2518 [label="FullWidth 154621"];
2519 [label="this.AdjustFlagsAndWidth(leading); 154622"];
2520 [label="return '-='; 154623"];
2521 [label="FullWidth = this.Text.Length; 154624"];
2522 [label="FullWidth 154625"];
2523 [label="this.AdjustFlagsAndWidth(trailing); 154626"];
2524 [label="return '-='; 154627"];
2525 [label="FullWidth = this.Text.Length; 154628"];
2526 [label="FullWidth 154629"];
2527 [label="this.AdjustFlagsAndWidth(trailing); 154630"];
2528 [label="return '^='; 154631"];
2529 [label="FullWidth = this.Text.Length; 154632"];
2530 [label="FullWidth 154633"];
2531 [label="return '^='; 154634"];
2532 [label="FullWidth = this.Text.Length; 154635"];
2533 [label="FullWidth 154636"];
2534 [label="this.AdjustFlagsAndWidth(leading); 154637"];
2535 [label="return '^='; 154638"];
2536 [label="FullWidth = this.Text.Length; 154639"];
2537 [label="FullWidth 154640"];
2538 [label="this.AdjustFlagsAndWidth(trailing); 154641"];
2539 [label="return '^='; 154642"];
2540 [label="FullWidth = this.Text.Length; 154643"];
2541 [label="FullWidth 154644"];
2542 [label="this.AdjustFlagsAndWidth(trailing); 154645"];
2543 [label="return '%='; 154646"];
2544 [label="FullWidth = this.Text.Length; 154647"];
2545 [label="FullWidth 154648"];
2546 [label="return '%='; 154649"];
2547 [label="FullWidth = this.Text.Length; 154650"];
2548 [label="FullWidth 154651"];
2549 [label="this.AdjustFlagsAndWidth(leading); 154652"];
2550 [label="return '%='; 154653"];
2551 [label="FullWidth = this.Text.Length; 154654"];
2552 [label="FullWidth 154655"];
2553 [label="this.AdjustFlagsAndWidth(trailing); 154656"];
2554 [label="return '%='; 154657"];
2555 [label="FullWidth = this.Text.Length; 154658"];
2556 [label="FullWidth 154659"];
2557 [label="this.AdjustFlagsAndWidth(trailing); 154660"];
2558 [label="return '??='; 154661"];
2559 [label="FullWidth = this.Text.Length; 154662"];
2560 [label="FullWidth 154663"];
2561 [label="return '??='; 154664"];
2562 [label="FullWidth = this.Text.Length; 154665"];
2563 [label="FullWidth 154666"];
2564 [label="this.AdjustFlagsAndWidth(leading); 154667"];
2565 [label="return '??='; 154668"];
2566 [label="FullWidth = this.Text.Length; 154669"];
2567 [label="FullWidth 154670"];
2568 [label="this.AdjustFlagsAndWidth(trailing); 154671"];
2569 [label="return '??='; 154672"];
2570 [label="FullWidth = this.Text.Length; 154673"];
2571 [label="FullWidth 154674"];
2572 [label="this.AdjustFlagsAndWidth(trailing); 154675"];
2573 [label="return 'bool'; 154676"];
2574 [label="FullWidth = this.Text.Length; 154677"];
2575 [label="FullWidth 154678"];
2576 [label="return 'bool'; 154679"];
2577 [label="FullWidth = this.Text.Length; 154680"];
2578 [label="FullWidth 154681"];
2579 [label="this.AdjustFlagsAndWidth(leading); 154682"];
2580 [label="return 'bool'; 154683"];
2581 [label="FullWidth = this.Text.Length; 154684"];
2582 [label="FullWidth 154685"];
2583 [label="this.AdjustFlagsAndWidth(trailing); 154686"];
2584 [label="return 'bool'; 154687"];
2585 [label="FullWidth = this.Text.Length; 154688"];
2586 [label="FullWidth 154689"];
2587 [label="this.AdjustFlagsAndWidth(trailing); 154690"];
2588 [label="return 'byte'; 154691"];
2589 [label="FullWidth = this.Text.Length; 154692"];
2590 [label="FullWidth 154693"];
2591 [label="return 'byte'; 154694"];
2592 [label="FullWidth = this.Text.Length; 154695"];
2593 [label="FullWidth 154696"];
2594 [label="this.AdjustFlagsAndWidth(leading); 154697"];
2595 [label="return 'byte'; 154698"];
2596 [label="FullWidth = this.Text.Length; 154699"];
2597 [label="FullWidth 154700"];
2598 [label="this.AdjustFlagsAndWidth(trailing); 154701"];
2599 [label="return 'byte'; 154702"];
2600 [label="FullWidth = this.Text.Length; 154703"];
2601 [label="FullWidth 154704"];
2602 [label="this.AdjustFlagsAndWidth(trailing); 154705"];
2603 [label="return 'sbyte'; 154706"];
2604 [label="FullWidth = this.Text.Length; 154707"];
2605 [label="FullWidth 154708"];
2606 [label="return 'sbyte'; 154709"];
2607 [label="FullWidth = this.Text.Length; 154710"];
2608 [label="FullWidth 154711"];
2609 [label="this.AdjustFlagsAndWidth(leading); 154712"];
2610 [label="return 'sbyte'; 154713"];
2611 [label="FullWidth = this.Text.Length; 154714"];
2612 [label="FullWidth 154715"];
2613 [label="this.AdjustFlagsAndWidth(trailing); 154716"];
2614 [label="return 'sbyte'; 154717"];
2615 [label="FullWidth = this.Text.Length; 154718"];
2616 [label="FullWidth 154719"];
2617 [label="this.AdjustFlagsAndWidth(trailing); 154720"];
2618 [label="return 'short'; 154721"];
2619 [label="FullWidth = this.Text.Length; 154722"];
2620 [label="FullWidth 154723"];
2621 [label="return 'short'; 154724"];
2622 [label="FullWidth = this.Text.Length; 154725"];
2623 [label="FullWidth 154726"];
2624 [label="this.AdjustFlagsAndWidth(leading); 154727"];
2625 [label="return 'short'; 154728"];
2626 [label="FullWidth = this.Text.Length; 154729"];
2627 [label="FullWidth 154730"];
2628 [label="this.AdjustFlagsAndWidth(trailing); 154731"];
2629 [label="return 'short'; 154732"];
2630 [label="FullWidth = this.Text.Length; 154733"];
2631 [label="FullWidth 154734"];
2632 [label="this.AdjustFlagsAndWidth(trailing); 154735"];
2633 [label="return 'ushort'; 154736"];
2634 [label="FullWidth = this.Text.Length; 154737"];
2635 [label="FullWidth 154738"];
2636 [label="return 'ushort'; 154739"];
2637 [label="FullWidth = this.Text.Length; 154740"];
2638 [label="FullWidth 154741"];
2639 [label="this.AdjustFlagsAndWidth(leading); 154742"];
2640 [label="return 'ushort'; 154743"];
2641 [label="FullWidth = this.Text.Length; 154744"];
2642 [label="FullWidth 154745"];
2643 [label="this.AdjustFlagsAndWidth(trailing); 154746"];
2644 [label="return 'ushort'; 154747"];
2645 [label="FullWidth = this.Text.Length; 154748"];
2646 [label="FullWidth 154749"];
2647 [label="this.AdjustFlagsAndWidth(trailing); 154750"];
2648 [label="return 'int'; 154751"];
2649 [label="FullWidth = this.Text.Length; 154752"];
2650 [label="FullWidth 154753"];
2651 [label="return 'int'; 154754"];
2652 [label="FullWidth = this.Text.Length; 154755"];
2653 [label="FullWidth 154756"];
2654 [label="this.AdjustFlagsAndWidth(leading); 154757"];
2655 [label="return 'int'; 154758"];
2656 [label="FullWidth = this.Text.Length; 154759"];
2657 [label="FullWidth 154760"];
2658 [label="this.AdjustFlagsAndWidth(trailing); 154761"];
2659 [label="return 'int'; 154762"];
2660 [label="FullWidth = this.Text.Length; 154763"];
2661 [label="FullWidth 154764"];
2662 [label="this.AdjustFlagsAndWidth(trailing); 154765"];
2663 [label="return 'uint'; 154766"];
2664 [label="FullWidth = this.Text.Length; 154767"];
2665 [label="FullWidth 154768"];
2666 [label="return 'uint'; 154769"];
2667 [label="FullWidth = this.Text.Length; 154770"];
2668 [label="FullWidth 154771"];
2669 [label="this.AdjustFlagsAndWidth(leading); 154772"];
2670 [label="return 'uint'; 154773"];
2671 [label="FullWidth = this.Text.Length; 154774"];
2672 [label="FullWidth 154775"];
2673 [label="this.AdjustFlagsAndWidth(trailing); 154776"];
2674 [label="return 'uint'; 154777"];
2675 [label="FullWidth = this.Text.Length; 154778"];
2676 [label="FullWidth 154779"];
2677 [label="this.AdjustFlagsAndWidth(trailing); 154780"];
2678 [label="return 'long'; 154781"];
2679 [label="FullWidth = this.Text.Length; 154782"];
2680 [label="FullWidth 154783"];
2681 [label="return 'long'; 154784"];
2682 [label="FullWidth = this.Text.Length; 154785"];
2683 [label="FullWidth 154786"];
2684 [label="this.AdjustFlagsAndWidth(leading); 154787"];
2685 [label="return 'long'; 154788"];
2686 [label="FullWidth = this.Text.Length; 154789"];
2687 [label="FullWidth 154790"];
2688 [label="this.AdjustFlagsAndWidth(trailing); 154791"];
2689 [label="return 'long'; 154792"];
2690 [label="FullWidth = this.Text.Length; 154793"];
2691 [label="FullWidth 154794"];
2692 [label="this.AdjustFlagsAndWidth(trailing); 154795"];
2693 [label="return 'ulong'; 154796"];
2694 [label="FullWidth = this.Text.Length; 154797"];
2695 [label="FullWidth 154798"];
2696 [label="return 'ulong'; 154799"];
2697 [label="FullWidth = this.Text.Length; 154800"];
2698 [label="FullWidth 154801"];
2699 [label="this.AdjustFlagsAndWidth(leading); 154802"];
2700 [label="return 'ulong'; 154803"];
2701 [label="FullWidth = this.Text.Length; 154804"];
2702 [label="FullWidth 154805"];
2703 [label="this.AdjustFlagsAndWidth(trailing); 154806"];
2704 [label="return 'ulong'; 154807"];
2705 [label="FullWidth = this.Text.Length; 154808"];
2706 [label="FullWidth 154809"];
2707 [label="this.AdjustFlagsAndWidth(trailing); 154810"];
2708 [label="return 'double'; 154811"];
2709 [label="FullWidth = this.Text.Length; 154812"];
2710 [label="FullWidth 154813"];
2711 [label="return 'double'; 154814"];
2712 [label="FullWidth = this.Text.Length; 154815"];
2713 [label="FullWidth 154816"];
2714 [label="this.AdjustFlagsAndWidth(leading); 154817"];
2715 [label="return 'double'; 154818"];
2716 [label="FullWidth = this.Text.Length; 154819"];
2717 [label="FullWidth 154820"];
2718 [label="this.AdjustFlagsAndWidth(trailing); 154821"];
2719 [label="return 'double'; 154822"];
2720 [label="FullWidth = this.Text.Length; 154823"];
2721 [label="FullWidth 154824"];
2722 [label="this.AdjustFlagsAndWidth(trailing); 154825"];
2723 [label="return 'float'; 154826"];
2724 [label="FullWidth = this.Text.Length; 154827"];
2725 [label="FullWidth 154828"];
2726 [label="return 'float'; 154829"];
2727 [label="FullWidth = this.Text.Length; 154830"];
2728 [label="FullWidth 154831"];
2729 [label="this.AdjustFlagsAndWidth(leading); 154832"];
2730 [label="return 'float'; 154833"];
2731 [label="FullWidth = this.Text.Length; 154834"];
2732 [label="FullWidth 154835"];
2733 [label="this.AdjustFlagsAndWidth(trailing); 154836"];
2734 [label="return 'float'; 154837"];
2735 [label="FullWidth = this.Text.Length; 154838"];
2736 [label="FullWidth 154839"];
2737 [label="this.AdjustFlagsAndWidth(trailing); 154840"];
2738 [label="return 'decimal'; 154841"];
2739 [label="FullWidth = this.Text.Length; 154842"];
2740 [label="FullWidth 154843"];
2741 [label="return 'decimal'; 154844"];
2742 [label="FullWidth = this.Text.Length; 154845"];
2743 [label="FullWidth 154846"];
2744 [label="this.AdjustFlagsAndWidth(leading); 154847"];
2745 [label="return 'decimal'; 154848"];
2746 [label="FullWidth = this.Text.Length; 154849"];
2747 [label="FullWidth 154850"];
2748 [label="this.AdjustFlagsAndWidth(trailing); 154851"];
2749 [label="return 'decimal'; 154852"];
2750 [label="FullWidth = this.Text.Length; 154853"];
2751 [label="FullWidth 154854"];
2752 [label="this.AdjustFlagsAndWidth(trailing); 154855"];
2753 [label="return 'string'; 154856"];
2754 [label="FullWidth = this.Text.Length; 154857"];
2755 [label="FullWidth 154858"];
2756 [label="return 'string'; 154859"];
2757 [label="FullWidth = this.Text.Length; 154860"];
2758 [label="FullWidth 154861"];
2759 [label="this.AdjustFlagsAndWidth(leading); 154862"];
2760 [label="return 'string'; 154863"];
2761 [label="FullWidth = this.Text.Length; 154864"];
2762 [label="FullWidth 154865"];
2763 [label="this.AdjustFlagsAndWidth(trailing); 154866"];
2764 [label="return 'string'; 154867"];
2765 [label="FullWidth = this.Text.Length; 154868"];
2766 [label="FullWidth 154869"];
2767 [label="this.AdjustFlagsAndWidth(trailing); 154870"];
2768 [label="return 'char'; 154871"];
2769 [label="FullWidth = this.Text.Length; 154872"];
2770 [label="FullWidth 154873"];
2771 [label="return 'char'; 154874"];
2772 [label="FullWidth = this.Text.Length; 154875"];
2773 [label="FullWidth 154876"];
2774 [label="this.AdjustFlagsAndWidth(leading); 154877"];
2775 [label="return 'char'; 154878"];
2776 [label="FullWidth = this.Text.Length; 154879"];
2777 [label="FullWidth 154880"];
2778 [label="this.AdjustFlagsAndWidth(trailing); 154881"];
2779 [label="return 'char'; 154882"];
2780 [label="FullWidth = this.Text.Length; 154883"];
2781 [label="FullWidth 154884"];
2782 [label="this.AdjustFlagsAndWidth(trailing); 154885"];
2783 [label="return 'void'; 154886"];
2784 [label="FullWidth = this.Text.Length; 154887"];
2785 [label="FullWidth 154888"];
2786 [label="return 'void'; 154889"];
2787 [label="FullWidth = this.Text.Length; 154890"];
2788 [label="FullWidth 154891"];
2789 [label="this.AdjustFlagsAndWidth(leading); 154892"];
2790 [label="return 'void'; 154893"];
2791 [label="FullWidth = this.Text.Length; 154894"];
2792 [label="FullWidth 154895"];
2793 [label="this.AdjustFlagsAndWidth(trailing); 154896"];
2794 [label="return 'void'; 154897"];
2795 [label="FullWidth = this.Text.Length; 154898"];
2796 [label="FullWidth 154899"];
2797 [label="this.AdjustFlagsAndWidth(trailing); 154900"];
2798 [label="return 'object'; 154901"];
2799 [label="FullWidth = this.Text.Length; 154902"];
2800 [label="FullWidth 154903"];
2801 [label="return 'object'; 154904"];
2802 [label="FullWidth = this.Text.Length; 154905"];
2803 [label="FullWidth 154906"];
2804 [label="this.AdjustFlagsAndWidth(leading); 154907"];
2805 [label="return 'object'; 154908"];
2806 [label="FullWidth = this.Text.Length; 154909"];
2807 [label="FullWidth 154910"];
2808 [label="this.AdjustFlagsAndWidth(trailing); 154911"];
2809 [label="return 'object'; 154912"];
2810 [label="FullWidth = this.Text.Length; 154913"];
2811 [label="FullWidth 154914"];
2812 [label="this.AdjustFlagsAndWidth(trailing); 154915"];
2813 [label="return 'typeof'; 154916"];
2814 [label="FullWidth = this.Text.Length; 154917"];
2815 [label="FullWidth 154918"];
2816 [label="return 'typeof'; 154919"];
2817 [label="FullWidth = this.Text.Length; 154920"];
2818 [label="FullWidth 154921"];
2819 [label="this.AdjustFlagsAndWidth(leading); 154922"];
2820 [label="return 'typeof'; 154923"];
2821 [label="FullWidth = this.Text.Length; 154924"];
2822 [label="FullWidth 154925"];
2823 [label="this.AdjustFlagsAndWidth(trailing); 154926"];
2824 [label="return 'typeof'; 154927"];
2825 [label="FullWidth = this.Text.Length; 154928"];
2826 [label="FullWidth 154929"];
2827 [label="this.AdjustFlagsAndWidth(trailing); 154930"];
2828 [label="return 'sizeof'; 154931"];
2829 [label="FullWidth = this.Text.Length; 154932"];
2830 [label="FullWidth 154933"];
2831 [label="return 'sizeof'; 154934"];
2832 [label="FullWidth = this.Text.Length; 154935"];
2833 [label="FullWidth 154936"];
2834 [label="this.AdjustFlagsAndWidth(leading); 154937"];
2835 [label="return 'sizeof'; 154938"];
2836 [label="FullWidth = this.Text.Length; 154939"];
2837 [label="FullWidth 154940"];
2838 [label="this.AdjustFlagsAndWidth(trailing); 154941"];
2839 [label="return 'sizeof'; 154942"];
2840 [label="FullWidth = this.Text.Length; 154943"];
2841 [label="FullWidth 154944"];
2842 [label="this.AdjustFlagsAndWidth(trailing); 154945"];
2843 [label="return 'null'; 154946"];
2844 [label="FullWidth = this.Text.Length; 154947"];
2845 [label="FullWidth 154948"];
2846 [label="return 'null'; 154949"];
2847 [label="FullWidth = this.Text.Length; 154950"];
2848 [label="FullWidth 154951"];
2849 [label="this.AdjustFlagsAndWidth(leading); 154952"];
2850 [label="return 'null'; 154953"];
2851 [label="FullWidth = this.Text.Length; 154954"];
2852 [label="FullWidth 154955"];
2853 [label="this.AdjustFlagsAndWidth(trailing); 154956"];
2854 [label="return 'null'; 154957"];
2855 [label="FullWidth = this.Text.Length; 154958"];
2856 [label="FullWidth 154959"];
2857 [label="this.AdjustFlagsAndWidth(trailing); 154960"];
2858 [label="return 'true'; 154961"];
2859 [label="FullWidth = this.Text.Length; 154962"];
2860 [label="FullWidth 154963"];
2861 [label="return 'true'; 154964"];
2862 [label="FullWidth = this.Text.Length; 154965"];
2863 [label="FullWidth 154966"];
2864 [label="this.AdjustFlagsAndWidth(leading); 154967"];
2865 [label="return 'true'; 154968"];
2866 [label="FullWidth = this.Text.Length; 154969"];
2867 [label="FullWidth 154970"];
2868 [label="this.AdjustFlagsAndWidth(trailing); 154971"];
2869 [label="return 'true'; 154972"];
2870 [label="FullWidth = this.Text.Length; 154973"];
2871 [label="FullWidth 154974"];
2872 [label="this.AdjustFlagsAndWidth(trailing); 154975"];
2873 [label="return 'false'; 154976"];
2874 [label="FullWidth = this.Text.Length; 154977"];
2875 [label="FullWidth 154978"];
2876 [label="return 'false'; 154979"];
2877 [label="FullWidth = this.Text.Length; 154980"];
2878 [label="FullWidth 154981"];
2879 [label="this.AdjustFlagsAndWidth(leading); 154982"];
2880 [label="return 'false'; 154983"];
2881 [label="FullWidth = this.Text.Length; 154984"];
2882 [label="FullWidth 154985"];
2883 [label="this.AdjustFlagsAndWidth(trailing); 154986"];
2884 [label="return 'false'; 154987"];
2885 [label="FullWidth = this.Text.Length; 154988"];
2886 [label="FullWidth 154989"];
2887 [label="this.AdjustFlagsAndWidth(trailing); 154990"];
2888 [label="return 'if'; 154991"];
2889 [label="FullWidth = this.Text.Length; 154992"];
2890 [label="FullWidth 154993"];
2891 [label="return 'if'; 154994"];
2892 [label="FullWidth = this.Text.Length; 154995"];
2893 [label="FullWidth 154996"];
2894 [label="this.AdjustFlagsAndWidth(leading); 154997"];
2895 [label="return 'if'; 154998"];
2896 [label="FullWidth = this.Text.Length; 154999"];
2897 [label="FullWidth 155000"];
2898 [label="this.AdjustFlagsAndWidth(trailing); 155001"];
2899 [label="return 'if'; 155002"];
2900 [label="FullWidth = this.Text.Length; 155003"];
2901 [label="FullWidth 155004"];
2902 [label="this.AdjustFlagsAndWidth(trailing); 155005"];
2903 [label="return 'else'; 155006"];
2904 [label="FullWidth = this.Text.Length; 155007"];
2905 [label="FullWidth 155008"];
2906 [label="return 'else'; 155009"];
2907 [label="FullWidth = this.Text.Length; 155010"];
2908 [label="FullWidth 155011"];
2909 [label="this.AdjustFlagsAndWidth(leading); 155012"];
2910 [label="return 'else'; 155013"];
2911 [label="FullWidth = this.Text.Length; 155014"];
2912 [label="FullWidth 155015"];
2913 [label="this.AdjustFlagsAndWidth(trailing); 155016"];
2914 [label="return 'else'; 155017"];
2915 [label="FullWidth = this.Text.Length; 155018"];
2916 [label="FullWidth 155019"];
2917 [label="this.AdjustFlagsAndWidth(trailing); 155020"];
2918 [label="return 'while'; 155021"];
2919 [label="FullWidth = this.Text.Length; 155022"];
2920 [label="FullWidth 155023"];
2921 [label="return 'while'; 155024"];
2922 [label="FullWidth = this.Text.Length; 155025"];
2923 [label="FullWidth 155026"];
2924 [label="this.AdjustFlagsAndWidth(leading); 155027"];
2925 [label="return 'while'; 155028"];
2926 [label="FullWidth = this.Text.Length; 155029"];
2927 [label="FullWidth 155030"];
2928 [label="this.AdjustFlagsAndWidth(trailing); 155031"];
2929 [label="return 'while'; 155032"];
2930 [label="FullWidth = this.Text.Length; 155033"];
2931 [label="FullWidth 155034"];
2932 [label="this.AdjustFlagsAndWidth(trailing); 155035"];
2933 [label="return 'for'; 155036"];
2934 [label="FullWidth = this.Text.Length; 155037"];
2935 [label="FullWidth 155038"];
2936 [label="return 'for'; 155039"];
2937 [label="FullWidth = this.Text.Length; 155040"];
2938 [label="FullWidth 155041"];
2939 [label="this.AdjustFlagsAndWidth(leading); 155042"];
2940 [label="return 'for'; 155043"];
2941 [label="FullWidth = this.Text.Length; 155044"];
2942 [label="FullWidth 155045"];
2943 [label="this.AdjustFlagsAndWidth(trailing); 155046"];
2944 [label="return 'for'; 155047"];
2945 [label="FullWidth = this.Text.Length; 155048"];
2946 [label="FullWidth 155049"];
2947 [label="this.AdjustFlagsAndWidth(trailing); 155050"];
2948 [label="return 'foreach'; 155051"];
2949 [label="FullWidth = this.Text.Length; 155052"];
2950 [label="FullWidth 155053"];
2951 [label="return 'foreach'; 155054"];
2952 [label="FullWidth = this.Text.Length; 155055"];
2953 [label="FullWidth 155056"];
2954 [label="this.AdjustFlagsAndWidth(leading); 155057"];
2955 [label="return 'foreach'; 155058"];
2956 [label="FullWidth = this.Text.Length; 155059"];
2957 [label="FullWidth 155060"];
2958 [label="this.AdjustFlagsAndWidth(trailing); 155061"];
2959 [label="return 'foreach'; 155062"];
2960 [label="FullWidth = this.Text.Length; 155063"];
2961 [label="FullWidth 155064"];
2962 [label="this.AdjustFlagsAndWidth(trailing); 155065"];
2963 [label="return 'do'; 155066"];
2964 [label="FullWidth = this.Text.Length; 155067"];
2965 [label="FullWidth 155068"];
2966 [label="return 'do'; 155069"];
2967 [label="FullWidth = this.Text.Length; 155070"];
2968 [label="FullWidth 155071"];
2969 [label="this.AdjustFlagsAndWidth(leading); 155072"];
2970 [label="return 'do'; 155073"];
2971 [label="FullWidth = this.Text.Length; 155074"];
2972 [label="FullWidth 155075"];
2973 [label="this.AdjustFlagsAndWidth(trailing); 155076"];
2974 [label="return 'do'; 155077"];
2975 [label="FullWidth = this.Text.Length; 155078"];
2976 [label="FullWidth 155079"];
2977 [label="this.AdjustFlagsAndWidth(trailing); 155080"];
2978 [label="return 'switch'; 155081"];
2979 [label="FullWidth = this.Text.Length; 155082"];
2980 [label="FullWidth 155083"];
2981 [label="return 'switch'; 155084"];
2982 [label="FullWidth = this.Text.Length; 155085"];
2983 [label="FullWidth 155086"];
2984 [label="this.AdjustFlagsAndWidth(leading); 155087"];
2985 [label="return 'switch'; 155088"];
2986 [label="FullWidth = this.Text.Length; 155089"];
2987 [label="FullWidth 155090"];
2988 [label="this.AdjustFlagsAndWidth(trailing); 155091"];
2989 [label="return 'switch'; 155092"];
2990 [label="FullWidth = this.Text.Length; 155093"];
2991 [label="FullWidth 155094"];
2992 [label="this.AdjustFlagsAndWidth(trailing); 155095"];
2993 [label="return 'case'; 155096"];
2994 [label="FullWidth = this.Text.Length; 155097"];
2995 [label="FullWidth 155098"];
2996 [label="return 'case'; 155099"];
2997 [label="FullWidth = this.Text.Length; 155100"];
2998 [label="FullWidth 155101"];
2999 [label="this.AdjustFlagsAndWidth(leading); 155102"];
3000 [label="return 'case'; 155103"];
3001 [label="FullWidth = this.Text.Length; 155104"];
3002 [label="FullWidth 155105"];
3003 [label="this.AdjustFlagsAndWidth(trailing); 155106"];
3004 [label="return 'case'; 155107"];
3005 [label="FullWidth = this.Text.Length; 155108"];
3006 [label="FullWidth 155109"];
3007 [label="this.AdjustFlagsAndWidth(trailing); 155110"];
3008 [label="return 'default'; 155111"];
3009 [label="FullWidth = this.Text.Length; 155112"];
3010 [label="FullWidth 155113"];
3011 [label="return 'default'; 155114"];
3012 [label="FullWidth = this.Text.Length; 155115"];
3013 [label="FullWidth 155116"];
3014 [label="this.AdjustFlagsAndWidth(leading); 155117"];
3015 [label="return 'default'; 155118"];
3016 [label="FullWidth = this.Text.Length; 155119"];
3017 [label="FullWidth 155120"];
3018 [label="this.AdjustFlagsAndWidth(trailing); 155121"];
3019 [label="return 'default'; 155122"];
3020 [label="FullWidth = this.Text.Length; 155123"];
3021 [label="FullWidth 155124"];
3022 [label="this.AdjustFlagsAndWidth(trailing); 155125"];
3023 [label="return 'try'; 155126"];
3024 [label="FullWidth = this.Text.Length; 155127"];
3025 [label="FullWidth 155128"];
3026 [label="return 'try'; 155129"];
3027 [label="FullWidth = this.Text.Length; 155130"];
3028 [label="FullWidth 155131"];
3029 [label="this.AdjustFlagsAndWidth(leading); 155132"];
3030 [label="return 'try'; 155133"];
3031 [label="FullWidth = this.Text.Length; 155134"];
3032 [label="FullWidth 155135"];
3033 [label="this.AdjustFlagsAndWidth(trailing); 155136"];
3034 [label="return 'try'; 155137"];
3035 [label="FullWidth = this.Text.Length; 155138"];
3036 [label="FullWidth 155139"];
3037 [label="this.AdjustFlagsAndWidth(trailing); 155140"];
3038 [label="return 'catch'; 155141"];
3039 [label="FullWidth = this.Text.Length; 155142"];
3040 [label="FullWidth 155143"];
3041 [label="return 'catch'; 155144"];
3042 [label="FullWidth = this.Text.Length; 155145"];
3043 [label="FullWidth 155146"];
3044 [label="this.AdjustFlagsAndWidth(leading); 155147"];
3045 [label="return 'catch'; 155148"];
3046 [label="FullWidth = this.Text.Length; 155149"];
3047 [label="FullWidth 155150"];
3048 [label="this.AdjustFlagsAndWidth(trailing); 155151"];
3049 [label="return 'catch'; 155152"];
3050 [label="FullWidth = this.Text.Length; 155153"];
3051 [label="FullWidth 155154"];
3052 [label="this.AdjustFlagsAndWidth(trailing); 155155"];
3053 [label="return 'finally'; 155156"];
3054 [label="FullWidth = this.Text.Length; 155157"];
3055 [label="FullWidth 155158"];
3056 [label="return 'finally'; 155159"];
3057 [label="FullWidth = this.Text.Length; 155160"];
3058 [label="FullWidth 155161"];
3059 [label="this.AdjustFlagsAndWidth(leading); 155162"];
3060 [label="return 'finally'; 155163"];
3061 [label="FullWidth = this.Text.Length; 155164"];
3062 [label="FullWidth 155165"];
3063 [label="this.AdjustFlagsAndWidth(trailing); 155166"];
3064 [label="return 'finally'; 155167"];
3065 [label="FullWidth = this.Text.Length; 155168"];
3066 [label="FullWidth 155169"];
3067 [label="this.AdjustFlagsAndWidth(trailing); 155170"];
3068 [label="return 'lock'; 155171"];
3069 [label="FullWidth = this.Text.Length; 155172"];
3070 [label="FullWidth 155173"];
3071 [label="return 'lock'; 155174"];
3072 [label="FullWidth = this.Text.Length; 155175"];
3073 [label="FullWidth 155176"];
3074 [label="this.AdjustFlagsAndWidth(leading); 155177"];
3075 [label="return 'lock'; 155178"];
3076 [label="FullWidth = this.Text.Length; 155179"];
3077 [label="FullWidth 155180"];
3078 [label="this.AdjustFlagsAndWidth(trailing); 155181"];
3079 [label="return 'lock'; 155182"];
3080 [label="FullWidth = this.Text.Length; 155183"];
3081 [label="FullWidth 155184"];
3082 [label="this.AdjustFlagsAndWidth(trailing); 155185"];
3083 [label="return 'goto'; 155186"];
3084 [label="FullWidth = this.Text.Length; 155187"];
3085 [label="FullWidth 155188"];
3086 [label="return 'goto'; 155189"];
3087 [label="FullWidth = this.Text.Length; 155190"];
3088 [label="FullWidth 155191"];
3089 [label="this.AdjustFlagsAndWidth(leading); 155192"];
3090 [label="return 'goto'; 155193"];
3091 [label="FullWidth = this.Text.Length; 155194"];
3092 [label="FullWidth 155195"];
3093 [label="this.AdjustFlagsAndWidth(trailing); 155196"];
3094 [label="return 'goto'; 155197"];
3095 [label="FullWidth = this.Text.Length; 155198"];
3096 [label="FullWidth 155199"];
3097 [label="this.AdjustFlagsAndWidth(trailing); 155200"];
3098 [label="return 'break'; 155201"];
3099 [label="FullWidth = this.Text.Length; 155202"];
3100 [label="FullWidth 155203"];
3101 [label="return 'break'; 155204"];
3102 [label="FullWidth = this.Text.Length; 155205"];
3103 [label="FullWidth 155206"];
3104 [label="this.AdjustFlagsAndWidth(leading); 155207"];
3105 [label="return 'break'; 155208"];
3106 [label="FullWidth = this.Text.Length; 155209"];
3107 [label="FullWidth 155210"];
3108 [label="this.AdjustFlagsAndWidth(trailing); 155211"];
3109 [label="return 'break'; 155212"];
3110 [label="FullWidth = this.Text.Length; 155213"];
3111 [label="FullWidth 155214"];
3112 [label="this.AdjustFlagsAndWidth(trailing); 155215"];
3113 [label="return 'continue'; 155216"];
3114 [label="FullWidth = this.Text.Length; 155217"];
3115 [label="FullWidth 155218"];
3116 [label="return 'continue'; 155219"];
3117 [label="FullWidth = this.Text.Length; 155220"];
3118 [label="FullWidth 155221"];
3119 [label="this.AdjustFlagsAndWidth(leading); 155222"];
3120 [label="return 'continue'; 155223"];
3121 [label="FullWidth = this.Text.Length; 155224"];
3122 [label="FullWidth 155225"];
3123 [label="this.AdjustFlagsAndWidth(trailing); 155226"];
3124 [label="return 'continue'; 155227"];
3125 [label="FullWidth = this.Text.Length; 155228"];
3126 [label="FullWidth 155229"];
3127 [label="this.AdjustFlagsAndWidth(trailing); 155230"];
3128 [label="return 'return'; 155231"];
3129 [label="FullWidth = this.Text.Length; 155232"];
3130 [label="FullWidth 155233"];
3131 [label="return 'return'; 155234"];
3132 [label="FullWidth = this.Text.Length; 155235"];
3133 [label="FullWidth 155236"];
3134 [label="this.AdjustFlagsAndWidth(leading); 155237"];
3135 [label="return 'return'; 155238"];
3136 [label="FullWidth = this.Text.Length; 155239"];
3137 [label="FullWidth 155240"];
3138 [label="this.AdjustFlagsAndWidth(trailing); 155241"];
3139 [label="return 'return'; 155242"];
3140 [label="FullWidth = this.Text.Length; 155243"];
3141 [label="FullWidth 155244"];
3142 [label="this.AdjustFlagsAndWidth(trailing); 155245"];
3143 [label="return 'throw'; 155246"];
3144 [label="FullWidth = this.Text.Length; 155247"];
3145 [label="FullWidth 155248"];
3146 [label="return 'throw'; 155249"];
3147 [label="FullWidth = this.Text.Length; 155250"];
3148 [label="FullWidth 155251"];
3149 [label="this.AdjustFlagsAndWidth(leading); 155252"];
3150 [label="return 'throw'; 155253"];
3151 [label="FullWidth = this.Text.Length; 155254"];
3152 [label="FullWidth 155255"];
3153 [label="this.AdjustFlagsAndWidth(trailing); 155256"];
3154 [label="return 'throw'; 155257"];
3155 [label="FullWidth = this.Text.Length; 155258"];
3156 [label="FullWidth 155259"];
3157 [label="this.AdjustFlagsAndWidth(trailing); 155260"];
3158 [label="return 'public'; 155261"];
3159 [label="FullWidth = this.Text.Length; 155262"];
3160 [label="FullWidth 155263"];
3161 [label="return 'public'; 155264"];
3162 [label="FullWidth = this.Text.Length; 155265"];
3163 [label="FullWidth 155266"];
3164 [label="this.AdjustFlagsAndWidth(leading); 155267"];
3165 [label="return 'public'; 155268"];
3166 [label="FullWidth = this.Text.Length; 155269"];
3167 [label="FullWidth 155270"];
3168 [label="this.AdjustFlagsAndWidth(trailing); 155271"];
3169 [label="return 'public'; 155272"];
3170 [label="FullWidth = this.Text.Length; 155273"];
3171 [label="FullWidth 155274"];
3172 [label="this.AdjustFlagsAndWidth(trailing); 155275"];
3173 [label="return 'private'; 155276"];
3174 [label="FullWidth = this.Text.Length; 155277"];
3175 [label="FullWidth 155278"];
3176 [label="return 'private'; 155279"];
3177 [label="FullWidth = this.Text.Length; 155280"];
3178 [label="FullWidth 155281"];
3179 [label="this.AdjustFlagsAndWidth(leading); 155282"];
3180 [label="return 'private'; 155283"];
3181 [label="FullWidth = this.Text.Length; 155284"];
3182 [label="FullWidth 155285"];
3183 [label="this.AdjustFlagsAndWidth(trailing); 155286"];
3184 [label="return 'private'; 155287"];
3185 [label="FullWidth = this.Text.Length; 155288"];
3186 [label="FullWidth 155289"];
3187 [label="this.AdjustFlagsAndWidth(trailing); 155290"];
3188 [label="return 'internal'; 155291"];
3189 [label="FullWidth = this.Text.Length; 155292"];
3190 [label="FullWidth 155293"];
3191 [label="return 'internal'; 155294"];
3192 [label="FullWidth = this.Text.Length; 155295"];
3193 [label="FullWidth 155296"];
3194 [label="this.AdjustFlagsAndWidth(leading); 155297"];
3195 [label="return 'internal'; 155298"];
3196 [label="FullWidth = this.Text.Length; 155299"];
3197 [label="FullWidth 155300"];
3198 [label="this.AdjustFlagsAndWidth(trailing); 155301"];
3199 [label="return 'internal'; 155302"];
3200 [label="FullWidth = this.Text.Length; 155303"];
3201 [label="FullWidth 155304"];
3202 [label="this.AdjustFlagsAndWidth(trailing); 155305"];
3203 [label="return 'protected'; 155306"];
3204 [label="FullWidth = this.Text.Length; 155307"];
3205 [label="FullWidth 155308"];
3206 [label="return 'protected'; 155309"];
3207 [label="FullWidth = this.Text.Length; 155310"];
3208 [label="FullWidth 155311"];
3209 [label="this.AdjustFlagsAndWidth(leading); 155312"];
3210 [label="return 'protected'; 155313"];
3211 [label="FullWidth = this.Text.Length; 155314"];
3212 [label="FullWidth 155315"];
3213 [label="this.AdjustFlagsAndWidth(trailing); 155316"];
3214 [label="return 'protected'; 155317"];
3215 [label="FullWidth = this.Text.Length; 155318"];
3216 [label="FullWidth 155319"];
3217 [label="this.AdjustFlagsAndWidth(trailing); 155320"];
3218 [label="return 'static'; 155321"];
3219 [label="FullWidth = this.Text.Length; 155322"];
3220 [label="FullWidth 155323"];
3221 [label="return 'static'; 155324"];
3222 [label="FullWidth = this.Text.Length; 155325"];
3223 [label="FullWidth 155326"];
3224 [label="this.AdjustFlagsAndWidth(leading); 155327"];
3225 [label="return 'static'; 155328"];
3226 [label="FullWidth = this.Text.Length; 155329"];
3227 [label="FullWidth 155330"];
3228 [label="this.AdjustFlagsAndWidth(trailing); 155331"];
3229 [label="return 'static'; 155332"];
3230 [label="FullWidth = this.Text.Length; 155333"];
3231 [label="FullWidth 155334"];
3232 [label="this.AdjustFlagsAndWidth(trailing); 155335"];
3233 [label="return 'readonly'; 155336"];
3234 [label="FullWidth = this.Text.Length; 155337"];
3235 [label="FullWidth 155338"];
3236 [label="return 'readonly'; 155339"];
3237 [label="FullWidth = this.Text.Length; 155340"];
3238 [label="FullWidth 155341"];
3239 [label="this.AdjustFlagsAndWidth(leading); 155342"];
3240 [label="return 'readonly'; 155343"];
3241 [label="FullWidth = this.Text.Length; 155344"];
3242 [label="FullWidth 155345"];
3243 [label="this.AdjustFlagsAndWidth(trailing); 155346"];
3244 [label="return 'readonly'; 155347"];
3245 [label="FullWidth = this.Text.Length; 155348"];
3246 [label="FullWidth 155349"];
3247 [label="this.AdjustFlagsAndWidth(trailing); 155350"];
3248 [label="return 'sealed'; 155351"];
3249 [label="FullWidth = this.Text.Length; 155352"];
3250 [label="FullWidth 155353"];
3251 [label="return 'sealed'; 155354"];
3252 [label="FullWidth = this.Text.Length; 155355"];
3253 [label="FullWidth 155356"];
3254 [label="this.AdjustFlagsAndWidth(leading); 155357"];
3255 [label="return 'sealed'; 155358"];
3256 [label="FullWidth = this.Text.Length; 155359"];
3257 [label="FullWidth 155360"];
3258 [label="this.AdjustFlagsAndWidth(trailing); 155361"];
3259 [label="return 'sealed'; 155362"];
3260 [label="FullWidth = this.Text.Length; 155363"];
3261 [label="FullWidth 155364"];
3262 [label="this.AdjustFlagsAndWidth(trailing); 155365"];
3263 [label="return 'const'; 155366"];
3264 [label="FullWidth = this.Text.Length; 155367"];
3265 [label="FullWidth 155368"];
3266 [label="return 'const'; 155369"];
3267 [label="FullWidth = this.Text.Length; 155370"];
3268 [label="FullWidth 155371"];
3269 [label="this.AdjustFlagsAndWidth(leading); 155372"];
3270 [label="return 'const'; 155373"];
3271 [label="FullWidth = this.Text.Length; 155374"];
3272 [label="FullWidth 155375"];
3273 [label="this.AdjustFlagsAndWidth(trailing); 155376"];
3274 [label="return 'const'; 155377"];
3275 [label="FullWidth = this.Text.Length; 155378"];
3276 [label="FullWidth 155379"];
3277 [label="this.AdjustFlagsAndWidth(trailing); 155380"];
3278 [label="return 'fixed'; 155381"];
3279 [label="FullWidth = this.Text.Length; 155382"];
3280 [label="FullWidth 155383"];
3281 [label="return 'fixed'; 155384"];
3282 [label="FullWidth = this.Text.Length; 155385"];
3283 [label="FullWidth 155386"];
3284 [label="this.AdjustFlagsAndWidth(leading); 155387"];
3285 [label="return 'fixed'; 155388"];
3286 [label="FullWidth = this.Text.Length; 155389"];
3287 [label="FullWidth 155390"];
3288 [label="this.AdjustFlagsAndWidth(trailing); 155391"];
3289 [label="return 'fixed'; 155392"];
3290 [label="FullWidth = this.Text.Length; 155393"];
3291 [label="FullWidth 155394"];
3292 [label="this.AdjustFlagsAndWidth(trailing); 155395"];
3293 [label="return 'stackalloc'; 155396"];
3294 [label="FullWidth = this.Text.Length; 155397"];
3295 [label="FullWidth 155398"];
3296 [label="return 'stackalloc'; 155399"];
3297 [label="FullWidth = this.Text.Length; 155400"];
3298 [label="FullWidth 155401"];
3299 [label="this.AdjustFlagsAndWidth(leading); 155402"];
3300 [label="return 'stackalloc'; 155403"];
3301 [label="FullWidth = this.Text.Length; 155404"];
3302 [label="FullWidth 155405"];
3303 [label="this.AdjustFlagsAndWidth(trailing); 155406"];
3304 [label="return 'stackalloc'; 155407"];
3305 [label="FullWidth = this.Text.Length; 155408"];
3306 [label="FullWidth 155409"];
3307 [label="this.AdjustFlagsAndWidth(trailing); 155410"];
3308 [label="return 'volatile'; 155411"];
3309 [label="FullWidth = this.Text.Length; 155412"];
3310 [label="FullWidth 155413"];
3311 [label="return 'volatile'; 155414"];
3312 [label="FullWidth = this.Text.Length; 155415"];
3313 [label="FullWidth 155416"];
3314 [label="this.AdjustFlagsAndWidth(leading); 155417"];
3315 [label="return 'volatile'; 155418"];
3316 [label="FullWidth = this.Text.Length; 155419"];
3317 [label="FullWidth 155420"];
3318 [label="this.AdjustFlagsAndWidth(trailing); 155421"];
3319 [label="return 'volatile'; 155422"];
3320 [label="FullWidth = this.Text.Length; 155423"];
3321 [label="FullWidth 155424"];
3322 [label="this.AdjustFlagsAndWidth(trailing); 155425"];
3323 [label="return 'new'; 155426"];
3324 [label="FullWidth = this.Text.Length; 155427"];
3325 [label="FullWidth 155428"];
3326 [label="return 'new'; 155429"];
3327 [label="FullWidth = this.Text.Length; 155430"];
3328 [label="FullWidth 155431"];
3329 [label="this.AdjustFlagsAndWidth(leading); 155432"];
3330 [label="return 'new'; 155433"];
3331 [label="FullWidth = this.Text.Length; 155434"];
3332 [label="FullWidth 155435"];
3333 [label="this.AdjustFlagsAndWidth(trailing); 155436"];
3334 [label="return 'new'; 155437"];
3335 [label="FullWidth = this.Text.Length; 155438"];
3336 [label="FullWidth 155439"];
3337 [label="this.AdjustFlagsAndWidth(trailing); 155440"];
3338 [label="return 'override'; 155441"];
3339 [label="FullWidth = this.Text.Length; 155442"];
3340 [label="FullWidth 155443"];
3341 [label="return 'override'; 155444"];
3342 [label="FullWidth = this.Text.Length; 155445"];
3343 [label="FullWidth 155446"];
3344 [label="this.AdjustFlagsAndWidth(leading); 155447"];
3345 [label="return 'override'; 155448"];
3346 [label="FullWidth = this.Text.Length; 155449"];
3347 [label="FullWidth 155450"];
3348 [label="this.AdjustFlagsAndWidth(trailing); 155451"];
3349 [label="return 'override'; 155452"];
3350 [label="FullWidth = this.Text.Length; 155453"];
3351 [label="FullWidth 155454"];
3352 [label="this.AdjustFlagsAndWidth(trailing); 155455"];
3353 [label="return 'abstract'; 155456"];
3354 [label="FullWidth = this.Text.Length; 155457"];
3355 [label="FullWidth 155458"];
3356 [label="return 'abstract'; 155459"];
3357 [label="FullWidth = this.Text.Length; 155460"];
3358 [label="FullWidth 155461"];
3359 [label="this.AdjustFlagsAndWidth(leading); 155462"];
3360 [label="return 'abstract'; 155463"];
3361 [label="FullWidth = this.Text.Length; 155464"];
3362 [label="FullWidth 155465"];
3363 [label="this.AdjustFlagsAndWidth(trailing); 155466"];
3364 [label="return 'abstract'; 155467"];
3365 [label="FullWidth = this.Text.Length; 155468"];
3366 [label="FullWidth 155469"];
3367 [label="this.AdjustFlagsAndWidth(trailing); 155470"];
3368 [label="return 'virtual'; 155471"];
3369 [label="FullWidth = this.Text.Length; 155472"];
3370 [label="FullWidth 155473"];
3371 [label="return 'virtual'; 155474"];
3372 [label="FullWidth = this.Text.Length; 155475"];
3373 [label="FullWidth 155476"];
3374 [label="this.AdjustFlagsAndWidth(leading); 155477"];
3375 [label="return 'virtual'; 155478"];
3376 [label="FullWidth = this.Text.Length; 155479"];
3377 [label="FullWidth 155480"];
3378 [label="this.AdjustFlagsAndWidth(trailing); 155481"];
3379 [label="return 'virtual'; 155482"];
3380 [label="FullWidth = this.Text.Length; 155483"];
3381 [label="FullWidth 155484"];
3382 [label="this.AdjustFlagsAndWidth(trailing); 155485"];
3383 [label="return 'event'; 155486"];
3384 [label="FullWidth = this.Text.Length; 155487"];
3385 [label="FullWidth 155488"];
3386 [label="return 'event'; 155489"];
3387 [label="FullWidth = this.Text.Length; 155490"];
3388 [label="FullWidth 155491"];
3389 [label="this.AdjustFlagsAndWidth(leading); 155492"];
3390 [label="return 'event'; 155493"];
3391 [label="FullWidth = this.Text.Length; 155494"];
3392 [label="FullWidth 155495"];
3393 [label="this.AdjustFlagsAndWidth(trailing); 155496"];
3394 [label="return 'event'; 155497"];
3395 [label="FullWidth = this.Text.Length; 155498"];
3396 [label="FullWidth 155499"];
3397 [label="this.AdjustFlagsAndWidth(trailing); 155500"];
3398 [label="return 'extern'; 155501"];
3399 [label="FullWidth = this.Text.Length; 155502"];
3400 [label="FullWidth 155503"];
3401 [label="return 'extern'; 155504"];
3402 [label="FullWidth = this.Text.Length; 155505"];
3403 [label="FullWidth 155506"];
3404 [label="this.AdjustFlagsAndWidth(leading); 155507"];
3405 [label="return 'extern'; 155508"];
3406 [label="FullWidth = this.Text.Length; 155509"];
3407 [label="FullWidth 155510"];
3408 [label="this.AdjustFlagsAndWidth(trailing); 155511"];
3409 [label="return 'extern'; 155512"];
3410 [label="FullWidth = this.Text.Length; 155513"];
3411 [label="FullWidth 155514"];
3412 [label="this.AdjustFlagsAndWidth(trailing); 155515"];
3413 [label="return 'ref'; 155516"];
3414 [label="FullWidth = this.Text.Length; 155517"];
3415 [label="FullWidth 155518"];
3416 [label="return 'ref'; 155519"];
3417 [label="FullWidth = this.Text.Length; 155520"];
3418 [label="FullWidth 155521"];
3419 [label="this.AdjustFlagsAndWidth(leading); 155522"];
3420 [label="return 'ref'; 155523"];
3421 [label="FullWidth = this.Text.Length; 155524"];
3422 [label="FullWidth 155525"];
3423 [label="this.AdjustFlagsAndWidth(trailing); 155526"];
3424 [label="return 'ref'; 155527"];
3425 [label="FullWidth = this.Text.Length; 155528"];
3426 [label="FullWidth 155529"];
3427 [label="this.AdjustFlagsAndWidth(trailing); 155530"];
3428 [label="return 'out'; 155531"];
3429 [label="FullWidth = this.Text.Length; 155532"];
3430 [label="FullWidth 155533"];
3431 [label="return 'out'; 155534"];
3432 [label="FullWidth = this.Text.Length; 155535"];
3433 [label="FullWidth 155536"];
3434 [label="this.AdjustFlagsAndWidth(leading); 155537"];
3435 [label="return 'out'; 155538"];
3436 [label="FullWidth = this.Text.Length; 155539"];
3437 [label="FullWidth 155540"];
3438 [label="this.AdjustFlagsAndWidth(trailing); 155541"];
3439 [label="return 'out'; 155542"];
3440 [label="FullWidth = this.Text.Length; 155543"];
3441 [label="FullWidth 155544"];
3442 [label="this.AdjustFlagsAndWidth(trailing); 155545"];
3443 [label="return 'in'; 155546"];
3444 [label="FullWidth = this.Text.Length; 155547"];
3445 [label="FullWidth 155548"];
3446 [label="return 'in'; 155549"];
3447 [label="FullWidth = this.Text.Length; 155550"];
3448 [label="FullWidth 155551"];
3449 [label="this.AdjustFlagsAndWidth(leading); 155552"];
3450 [label="return 'in'; 155553"];
3451 [label="FullWidth = this.Text.Length; 155554"];
3452 [label="FullWidth 155555"];
3453 [label="this.AdjustFlagsAndWidth(trailing); 155556"];
3454 [label="return 'in'; 155557"];
3455 [label="FullWidth = this.Text.Length; 155558"];
3456 [label="FullWidth 155559"];
3457 [label="this.AdjustFlagsAndWidth(trailing); 155560"];
3458 [label="return 'is'; 155561"];
3459 [label="FullWidth = this.Text.Length; 155562"];
3460 [label="FullWidth 155563"];
3461 [label="return 'is'; 155564"];
3462 [label="FullWidth = this.Text.Length; 155565"];
3463 [label="FullWidth 155566"];
3464 [label="this.AdjustFlagsAndWidth(leading); 155567"];
3465 [label="return 'is'; 155568"];
3466 [label="FullWidth = this.Text.Length; 155569"];
3467 [label="FullWidth 155570"];
3468 [label="this.AdjustFlagsAndWidth(trailing); 155571"];
3469 [label="return 'is'; 155572"];
3470 [label="FullWidth = this.Text.Length; 155573"];
3471 [label="FullWidth 155574"];
3472 [label="this.AdjustFlagsAndWidth(trailing); 155575"];
3473 [label="return 'as'; 155576"];
3474 [label="FullWidth = this.Text.Length; 155577"];
3475 [label="FullWidth 155578"];
3476 [label="return 'as'; 155579"];
3477 [label="FullWidth = this.Text.Length; 155580"];
3478 [label="FullWidth 155581"];
3479 [label="this.AdjustFlagsAndWidth(leading); 155582"];
3480 [label="return 'as'; 155583"];
3481 [label="FullWidth = this.Text.Length; 155584"];
3482 [label="FullWidth 155585"];
3483 [label="this.AdjustFlagsAndWidth(trailing); 155586"];
3484 [label="return 'as'; 155587"];
3485 [label="FullWidth = this.Text.Length; 155588"];
3486 [label="FullWidth 155589"];
3487 [label="this.AdjustFlagsAndWidth(trailing); 155590"];
3488 [label="return 'params'; 155591"];
3489 [label="FullWidth = this.Text.Length; 155592"];
3490 [label="FullWidth 155593"];
3491 [label="return 'params'; 155594"];
3492 [label="FullWidth = this.Text.Length; 155595"];
3493 [label="FullWidth 155596"];
3494 [label="this.AdjustFlagsAndWidth(leading); 155597"];
3495 [label="return 'params'; 155598"];
3496 [label="FullWidth = this.Text.Length; 155599"];
3497 [label="FullWidth 155600"];
3498 [label="this.AdjustFlagsAndWidth(trailing); 155601"];
3499 [label="return 'params'; 155602"];
3500 [label="FullWidth = this.Text.Length; 155603"];
3501 [label="FullWidth 155604"];
3502 [label="this.AdjustFlagsAndWidth(trailing); 155605"];
3503 [label="return '__arglist'; 155606"];
3504 [label="FullWidth = this.Text.Length; 155607"];
3505 [label="FullWidth 155608"];
3506 [label="return '__arglist'; 155609"];
3507 [label="FullWidth = this.Text.Length; 155610"];
3508 [label="FullWidth 155611"];
3509 [label="this.AdjustFlagsAndWidth(leading); 155612"];
3510 [label="return '__arglist'; 155613"];
3511 [label="FullWidth = this.Text.Length; 155614"];
3512 [label="FullWidth 155615"];
3513 [label="this.AdjustFlagsAndWidth(trailing); 155616"];
3514 [label="return '__arglist'; 155617"];
3515 [label="FullWidth = this.Text.Length; 155618"];
3516 [label="FullWidth 155619"];
3517 [label="this.AdjustFlagsAndWidth(trailing); 155620"];
3518 [label="return '__makeref'; 155621"];
3519 [label="FullWidth = this.Text.Length; 155622"];
3520 [label="FullWidth 155623"];
3521 [label="return '__makeref'; 155624"];
3522 [label="FullWidth = this.Text.Length; 155625"];
3523 [label="FullWidth 155626"];
3524 [label="this.AdjustFlagsAndWidth(leading); 155627"];
3525 [label="return '__makeref'; 155628"];
3526 [label="FullWidth = this.Text.Length; 155629"];
3527 [label="FullWidth 155630"];
3528 [label="this.AdjustFlagsAndWidth(trailing); 155631"];
3529 [label="return '__makeref'; 155632"];
3530 [label="FullWidth = this.Text.Length; 155633"];
3531 [label="FullWidth 155634"];
3532 [label="this.AdjustFlagsAndWidth(trailing); 155635"];
3533 [label="return '__reftype'; 155636"];
3534 [label="FullWidth = this.Text.Length; 155637"];
3535 [label="FullWidth 155638"];
3536 [label="return '__reftype'; 155639"];
3537 [label="FullWidth = this.Text.Length; 155640"];
3538 [label="FullWidth 155641"];
3539 [label="this.AdjustFlagsAndWidth(leading); 155642"];
3540 [label="return '__reftype'; 155643"];
3541 [label="FullWidth = this.Text.Length; 155644"];
3542 [label="FullWidth 155645"];
3543 [label="this.AdjustFlagsAndWidth(trailing); 155646"];
3544 [label="return '__reftype'; 155647"];
3545 [label="FullWidth = this.Text.Length; 155648"];
3546 [label="FullWidth 155649"];
3547 [label="this.AdjustFlagsAndWidth(trailing); 155650"];
3548 [label="return '__refvalue'; 155651"];
3549 [label="FullWidth = this.Text.Length; 155652"];
3550 [label="FullWidth 155653"];
3551 [label="return '__refvalue'; 155654"];
3552 [label="FullWidth = this.Text.Length; 155655"];
3553 [label="FullWidth 155656"];
3554 [label="this.AdjustFlagsAndWidth(leading); 155657"];
3555 [label="return '__refvalue'; 155658"];
3556 [label="FullWidth = this.Text.Length; 155659"];
3557 [label="FullWidth 155660"];
3558 [label="this.AdjustFlagsAndWidth(trailing); 155661"];
3559 [label="return '__refvalue'; 155662"];
3560 [label="FullWidth = this.Text.Length; 155663"];
3561 [label="FullWidth 155664"];
3562 [label="this.AdjustFlagsAndWidth(trailing); 155665"];
3563 [label="return 'this'; 155666"];
3564 [label="FullWidth = this.Text.Length; 155667"];
3565 [label="FullWidth 155668"];
3566 [label="return 'this'; 155669"];
3567 [label="FullWidth = this.Text.Length; 155670"];
3568 [label="FullWidth 155671"];
3569 [label="this.AdjustFlagsAndWidth(leading); 155672"];
3570 [label="return 'this'; 155673"];
3571 [label="FullWidth = this.Text.Length; 155674"];
3572 [label="FullWidth 155675"];
3573 [label="this.AdjustFlagsAndWidth(trailing); 155676"];
3574 [label="return 'this'; 155677"];
3575 [label="FullWidth = this.Text.Length; 155678"];
3576 [label="FullWidth 155679"];
3577 [label="this.AdjustFlagsAndWidth(trailing); 155680"];
3578 [label="return 'base'; 155681"];
3579 [label="FullWidth = this.Text.Length; 155682"];
3580 [label="FullWidth 155683"];
3581 [label="return 'base'; 155684"];
3582 [label="FullWidth = this.Text.Length; 155685"];
3583 [label="FullWidth 155686"];
3584 [label="this.AdjustFlagsAndWidth(leading); 155687"];
3585 [label="return 'base'; 155688"];
3586 [label="FullWidth = this.Text.Length; 155689"];
3587 [label="FullWidth 155690"];
3588 [label="this.AdjustFlagsAndWidth(trailing); 155691"];
3589 [label="return 'base'; 155692"];
3590 [label="FullWidth = this.Text.Length; 155693"];
3591 [label="FullWidth 155694"];
3592 [label="this.AdjustFlagsAndWidth(trailing); 155695"];
3593 [label="return 'namespace'; 155696"];
3594 [label="FullWidth = this.Text.Length; 155697"];
3595 [label="FullWidth 155698"];
3596 [label="return 'namespace'; 155699"];
3597 [label="FullWidth = this.Text.Length; 155700"];
3598 [label="FullWidth 155701"];
3599 [label="this.AdjustFlagsAndWidth(leading); 155702"];
3600 [label="return 'namespace'; 155703"];
3601 [label="FullWidth = this.Text.Length; 155704"];
3602 [label="FullWidth 155705"];
3603 [label="this.AdjustFlagsAndWidth(trailing); 155706"];
3604 [label="return 'namespace'; 155707"];
3605 [label="FullWidth = this.Text.Length; 155708"];
3606 [label="FullWidth 155709"];
3607 [label="this.AdjustFlagsAndWidth(trailing); 155710"];
3608 [label="return 'using'; 155711"];
3609 [label="FullWidth = this.Text.Length; 155712"];
3610 [label="FullWidth 155713"];
3611 [label="return 'using'; 155714"];
3612 [label="FullWidth = this.Text.Length; 155715"];
3613 [label="FullWidth 155716"];
3614 [label="this.AdjustFlagsAndWidth(leading); 155717"];
3615 [label="return 'using'; 155718"];
3616 [label="FullWidth = this.Text.Length; 155719"];
3617 [label="FullWidth 155720"];
3618 [label="this.AdjustFlagsAndWidth(trailing); 155721"];
3619 [label="return 'using'; 155722"];
3620 [label="FullWidth = this.Text.Length; 155723"];
3621 [label="FullWidth 155724"];
3622 [label="this.AdjustFlagsAndWidth(trailing); 155725"];
3623 [label="return 'class'; 155726"];
3624 [label="FullWidth = this.Text.Length; 155727"];
3625 [label="FullWidth 155728"];
3626 [label="return 'class'; 155729"];
3627 [label="FullWidth = this.Text.Length; 155730"];
3628 [label="FullWidth 155731"];
3629 [label="this.AdjustFlagsAndWidth(leading); 155732"];
3630 [label="return 'class'; 155733"];
3631 [label="FullWidth = this.Text.Length; 155734"];
3632 [label="FullWidth 155735"];
3633 [label="this.AdjustFlagsAndWidth(trailing); 155736"];
3634 [label="return 'class'; 155737"];
3635 [label="FullWidth = this.Text.Length; 155738"];
3636 [label="FullWidth 155739"];
3637 [label="this.AdjustFlagsAndWidth(trailing); 155740"];
3638 [label="return 'struct'; 155741"];
3639 [label="FullWidth = this.Text.Length; 155742"];
3640 [label="FullWidth 155743"];
3641 [label="return 'struct'; 155744"];
3642 [label="FullWidth = this.Text.Length; 155745"];
3643 [label="FullWidth 155746"];
3644 [label="this.AdjustFlagsAndWidth(leading); 155747"];
3645 [label="return 'struct'; 155748"];
3646 [label="FullWidth = this.Text.Length; 155749"];
3647 [label="FullWidth 155750"];
3648 [label="this.AdjustFlagsAndWidth(trailing); 155751"];
3649 [label="return 'struct'; 155752"];
3650 [label="FullWidth = this.Text.Length; 155753"];
3651 [label="FullWidth 155754"];
3652 [label="this.AdjustFlagsAndWidth(trailing); 155755"];
3653 [label="return 'interface'; 155756"];
3654 [label="FullWidth = this.Text.Length; 155757"];
3655 [label="FullWidth 155758"];
3656 [label="return 'interface'; 155759"];
3657 [label="FullWidth = this.Text.Length; 155760"];
3658 [label="FullWidth 155761"];
3659 [label="this.AdjustFlagsAndWidth(leading); 155762"];
3660 [label="return 'interface'; 155763"];
3661 [label="FullWidth = this.Text.Length; 155764"];
3662 [label="FullWidth 155765"];
3663 [label="this.AdjustFlagsAndWidth(trailing); 155766"];
3664 [label="return 'interface'; 155767"];
3665 [label="FullWidth = this.Text.Length; 155768"];
3666 [label="FullWidth 155769"];
3667 [label="this.AdjustFlagsAndWidth(trailing); 155770"];
3668 [label="return 'enum'; 155771"];
3669 [label="FullWidth = this.Text.Length; 155772"];
3670 [label="FullWidth 155773"];
3671 [label="return 'enum'; 155774"];
3672 [label="FullWidth = this.Text.Length; 155775"];
3673 [label="FullWidth 155776"];
3674 [label="this.AdjustFlagsAndWidth(leading); 155777"];
3675 [label="return 'enum'; 155778"];
3676 [label="FullWidth = this.Text.Length; 155779"];
3677 [label="FullWidth 155780"];
3678 [label="this.AdjustFlagsAndWidth(trailing); 155781"];
3679 [label="return 'enum'; 155782"];
3680 [label="FullWidth = this.Text.Length; 155783"];
3681 [label="FullWidth 155784"];
3682 [label="this.AdjustFlagsAndWidth(trailing); 155785"];
3683 [label="return 'delegate'; 155786"];
3684 [label="FullWidth = this.Text.Length; 155787"];
3685 [label="FullWidth 155788"];
3686 [label="return 'delegate'; 155789"];
3687 [label="FullWidth = this.Text.Length; 155790"];
3688 [label="FullWidth 155791"];
3689 [label="this.AdjustFlagsAndWidth(leading); 155792"];
3690 [label="return 'delegate'; 155793"];
3691 [label="FullWidth = this.Text.Length; 155794"];
3692 [label="FullWidth 155795"];
3693 [label="this.AdjustFlagsAndWidth(trailing); 155796"];
3694 [label="return 'delegate'; 155797"];
3695 [label="FullWidth = this.Text.Length; 155798"];
3696 [label="FullWidth 155799"];
3697 [label="this.AdjustFlagsAndWidth(trailing); 155800"];
3698 [label="return 'checked'; 155801"];
3699 [label="FullWidth = this.Text.Length; 155802"];
3700 [label="FullWidth 155803"];
3701 [label="return 'checked'; 155804"];
3702 [label="FullWidth = this.Text.Length; 155805"];
3703 [label="FullWidth 155806"];
3704 [label="this.AdjustFlagsAndWidth(leading); 155807"];
3705 [label="return 'checked'; 155808"];
3706 [label="FullWidth = this.Text.Length; 155809"];
3707 [label="FullWidth 155810"];
3708 [label="this.AdjustFlagsAndWidth(trailing); 155811"];
3709 [label="return 'checked'; 155812"];
3710 [label="FullWidth = this.Text.Length; 155813"];
3711 [label="FullWidth 155814"];
3712 [label="this.AdjustFlagsAndWidth(trailing); 155815"];
3713 [label="return 'unchecked'; 155816"];
3714 [label="FullWidth = this.Text.Length; 155817"];
3715 [label="FullWidth 155818"];
3716 [label="return 'unchecked'; 155819"];
3717 [label="FullWidth = this.Text.Length; 155820"];
3718 [label="FullWidth 155821"];
3719 [label="this.AdjustFlagsAndWidth(leading); 155822"];
3720 [label="return 'unchecked'; 155823"];
3721 [label="FullWidth = this.Text.Length; 155824"];
3722 [label="FullWidth 155825"];
3723 [label="this.AdjustFlagsAndWidth(trailing); 155826"];
3724 [label="return 'unchecked'; 155827"];
3725 [label="FullWidth = this.Text.Length; 155828"];
3726 [label="FullWidth 155829"];
3727 [label="this.AdjustFlagsAndWidth(trailing); 155830"];
3728 [label="return 'unsafe'; 155831"];
3729 [label="FullWidth = this.Text.Length; 155832"];
3730 [label="FullWidth 155833"];
3731 [label="return 'unsafe'; 155834"];
3732 [label="FullWidth = this.Text.Length; 155835"];
3733 [label="FullWidth 155836"];
3734 [label="this.AdjustFlagsAndWidth(leading); 155837"];
3735 [label="return 'unsafe'; 155838"];
3736 [label="FullWidth = this.Text.Length; 155839"];
3737 [label="FullWidth 155840"];
3738 [label="this.AdjustFlagsAndWidth(trailing); 155841"];
3739 [label="return 'unsafe'; 155842"];
3740 [label="FullWidth = this.Text.Length; 155843"];
3741 [label="FullWidth 155844"];
3742 [label="this.AdjustFlagsAndWidth(trailing); 155845"];
3743 [label="return 'operator'; 155846"];
3744 [label="FullWidth = this.Text.Length; 155847"];
3745 [label="FullWidth 155848"];
3746 [label="return 'operator'; 155849"];
3747 [label="FullWidth = this.Text.Length; 155850"];
3748 [label="FullWidth 155851"];
3749 [label="this.AdjustFlagsAndWidth(leading); 155852"];
3750 [label="return 'operator'; 155853"];
3751 [label="FullWidth = this.Text.Length; 155854"];
3752 [label="FullWidth 155855"];
3753 [label="this.AdjustFlagsAndWidth(trailing); 155856"];
3754 [label="return 'operator'; 155857"];
3755 [label="FullWidth = this.Text.Length; 155858"];
3756 [label="FullWidth 155859"];
3757 [label="this.AdjustFlagsAndWidth(trailing); 155860"];
3758 [label="return 'explicit'; 155861"];
3759 [label="FullWidth = this.Text.Length; 155862"];
3760 [label="FullWidth 155863"];
3761 [label="return 'explicit'; 155864"];
3762 [label="FullWidth = this.Text.Length; 155865"];
3763 [label="FullWidth 155866"];
3764 [label="this.AdjustFlagsAndWidth(leading); 155867"];
3765 [label="return 'explicit'; 155868"];
3766 [label="FullWidth = this.Text.Length; 155869"];
3767 [label="FullWidth 155870"];
3768 [label="this.AdjustFlagsAndWidth(trailing); 155871"];
3769 [label="return 'explicit'; 155872"];
3770 [label="FullWidth = this.Text.Length; 155873"];
3771 [label="FullWidth 155874"];
3772 [label="this.AdjustFlagsAndWidth(trailing); 155875"];
3773 [label="return 'implicit'; 155876"];
3774 [label="FullWidth = this.Text.Length; 155877"];
3775 [label="FullWidth 155878"];
3776 [label="return 'implicit'; 155879"];
3777 [label="FullWidth = this.Text.Length; 155880"];
3778 [label="FullWidth 155881"];
3779 [label="this.AdjustFlagsAndWidth(leading); 155882"];
3780 [label="return 'implicit'; 155883"];
3781 [label="FullWidth = this.Text.Length; 155884"];
3782 [label="FullWidth 155885"];
3783 [label="this.AdjustFlagsAndWidth(trailing); 155886"];
3784 [label="return 'implicit'; 155887"];
3785 [label="FullWidth = this.Text.Length; 155888"];
3786 [label="FullWidth 155889"];
3787 [label="this.AdjustFlagsAndWidth(trailing); 155890"];
3788 [label="return 'yield'; 155891"];
3789 [label="FullWidth = this.Text.Length; 155892"];
3790 [label="FullWidth 155893"];
3791 [label="return 'yield'; 155894"];
3792 [label="FullWidth = this.Text.Length; 155895"];
3793 [label="FullWidth 155896"];
3794 [label="this.AdjustFlagsAndWidth(leading); 155897"];
3795 [label="return 'yield'; 155898"];
3796 [label="FullWidth = this.Text.Length; 155899"];
3797 [label="FullWidth 155900"];
3798 [label="this.AdjustFlagsAndWidth(trailing); 155901"];
3799 [label="return 'yield'; 155902"];
3800 [label="FullWidth = this.Text.Length; 155903"];
3801 [label="FullWidth 155904"];
3802 [label="this.AdjustFlagsAndWidth(trailing); 155905"];
3803 [label="return 'partial'; 155906"];
3804 [label="FullWidth = this.Text.Length; 155907"];
3805 [label="FullWidth 155908"];
3806 [label="return 'partial'; 155909"];
3807 [label="FullWidth = this.Text.Length; 155910"];
3808 [label="FullWidth 155911"];
3809 [label="this.AdjustFlagsAndWidth(leading); 155912"];
3810 [label="return 'partial'; 155913"];
3811 [label="FullWidth = this.Text.Length; 155914"];
3812 [label="FullWidth 155915"];
3813 [label="this.AdjustFlagsAndWidth(trailing); 155916"];
3814 [label="return 'partial'; 155917"];
3815 [label="FullWidth = this.Text.Length; 155918"];
3816 [label="FullWidth 155919"];
3817 [label="this.AdjustFlagsAndWidth(trailing); 155920"];
3818 [label="return 'alias'; 155921"];
3819 [label="FullWidth = this.Text.Length; 155922"];
3820 [label="FullWidth 155923"];
3821 [label="return 'alias'; 155924"];
3822 [label="FullWidth = this.Text.Length; 155925"];
3823 [label="FullWidth 155926"];
3824 [label="this.AdjustFlagsAndWidth(leading); 155927"];
3825 [label="return 'alias'; 155928"];
3826 [label="FullWidth = this.Text.Length; 155929"];
3827 [label="FullWidth 155930"];
3828 [label="this.AdjustFlagsAndWidth(trailing); 155931"];
3829 [label="return 'alias'; 155932"];
3830 [label="FullWidth = this.Text.Length; 155933"];
3831 [label="FullWidth 155934"];
3832 [label="this.AdjustFlagsAndWidth(trailing); 155935"];
3833 [label="return 'global'; 155936"];
3834 [label="FullWidth = this.Text.Length; 155937"];
3835 [label="FullWidth 155938"];
3836 [label="return 'global'; 155939"];
3837 [label="FullWidth = this.Text.Length; 155940"];
3838 [label="FullWidth 155941"];
3839 [label="this.AdjustFlagsAndWidth(leading); 155942"];
3840 [label="return 'global'; 155943"];
3841 [label="FullWidth = this.Text.Length; 155944"];
3842 [label="FullWidth 155945"];
3843 [label="this.AdjustFlagsAndWidth(trailing); 155946"];
3844 [label="return 'global'; 155947"];
3845 [label="FullWidth = this.Text.Length; 155948"];
3846 [label="FullWidth 155949"];
3847 [label="this.AdjustFlagsAndWidth(trailing); 155950"];
3848 [label="return 'assembly'; 155951"];
3849 [label="FullWidth = this.Text.Length; 155952"];
3850 [label="FullWidth 155953"];
3851 [label="return 'assembly'; 155954"];
3852 [label="FullWidth = this.Text.Length; 155955"];
3853 [label="FullWidth 155956"];
3854 [label="this.AdjustFlagsAndWidth(leading); 155957"];
3855 [label="return 'assembly'; 155958"];
3856 [label="FullWidth = this.Text.Length; 155959"];
3857 [label="FullWidth 155960"];
3858 [label="this.AdjustFlagsAndWidth(trailing); 155961"];
3859 [label="return 'assembly'; 155962"];
3860 [label="FullWidth = this.Text.Length; 155963"];
3861 [label="FullWidth 155964"];
3862 [label="this.AdjustFlagsAndWidth(trailing); 155965"];
3863 [label="return 'module'; 155966"];
3864 [label="FullWidth = this.Text.Length; 155967"];
3865 [label="FullWidth 155968"];
3866 [label="return 'module'; 155969"];
3867 [label="FullWidth = this.Text.Length; 155970"];
3868 [label="FullWidth 155971"];
3869 [label="this.AdjustFlagsAndWidth(leading); 155972"];
3870 [label="return 'module'; 155973"];
3871 [label="FullWidth = this.Text.Length; 155974"];
3872 [label="FullWidth 155975"];
3873 [label="this.AdjustFlagsAndWidth(trailing); 155976"];
3874 [label="return 'module'; 155977"];
3875 [label="FullWidth = this.Text.Length; 155978"];
3876 [label="FullWidth 155979"];
3877 [label="this.AdjustFlagsAndWidth(trailing); 155980"];
3878 [label="return 'type'; 155981"];
3879 [label="FullWidth = this.Text.Length; 155982"];
3880 [label="FullWidth 155983"];
3881 [label="return 'type'; 155984"];
3882 [label="FullWidth = this.Text.Length; 155985"];
3883 [label="FullWidth 155986"];
3884 [label="this.AdjustFlagsAndWidth(leading); 155987"];
3885 [label="return 'type'; 155988"];
3886 [label="FullWidth = this.Text.Length; 155989"];
3887 [label="FullWidth 155990"];
3888 [label="this.AdjustFlagsAndWidth(trailing); 155991"];
3889 [label="return 'type'; 155992"];
3890 [label="FullWidth = this.Text.Length; 155993"];
3891 [label="FullWidth 155994"];
3892 [label="this.AdjustFlagsAndWidth(trailing); 155995"];
3893 [label="return 'field'; 155996"];
3894 [label="FullWidth = this.Text.Length; 155997"];
3895 [label="FullWidth 155998"];
3896 [label="return 'field'; 155999"];
3897 [label="FullWidth = this.Text.Length; 156000"];
3898 [label="FullWidth 156001"];
3899 [label="this.AdjustFlagsAndWidth(leading); 156002"];
3900 [label="return 'field'; 156003"];
3901 [label="FullWidth = this.Text.Length; 156004"];
3902 [label="FullWidth 156005"];
3903 [label="this.AdjustFlagsAndWidth(trailing); 156006"];
3904 [label="return 'field'; 156007"];
3905 [label="FullWidth = this.Text.Length; 156008"];
3906 [label="FullWidth 156009"];
3907 [label="this.AdjustFlagsAndWidth(trailing); 156010"];
3908 [label="return 'method'; 156011"];
3909 [label="FullWidth = this.Text.Length; 156012"];
3910 [label="FullWidth 156013"];
3911 [label="return 'method'; 156014"];
3912 [label="FullWidth = this.Text.Length; 156015"];
3913 [label="FullWidth 156016"];
3914 [label="this.AdjustFlagsAndWidth(leading); 156017"];
3915 [label="return 'method'; 156018"];
3916 [label="FullWidth = this.Text.Length; 156019"];
3917 [label="FullWidth 156020"];
3918 [label="this.AdjustFlagsAndWidth(trailing); 156021"];
3919 [label="return 'method'; 156022"];
3920 [label="FullWidth = this.Text.Length; 156023"];
3921 [label="FullWidth 156024"];
3922 [label="this.AdjustFlagsAndWidth(trailing); 156025"];
3923 [label="return 'param'; 156026"];
3924 [label="FullWidth = this.Text.Length; 156027"];
3925 [label="FullWidth 156028"];
3926 [label="return 'param'; 156029"];
3927 [label="FullWidth = this.Text.Length; 156030"];
3928 [label="FullWidth 156031"];
3929 [label="this.AdjustFlagsAndWidth(leading); 156032"];
3930 [label="return 'param'; 156033"];
3931 [label="FullWidth = this.Text.Length; 156034"];
3932 [label="FullWidth 156035"];
3933 [label="this.AdjustFlagsAndWidth(trailing); 156036"];
3934 [label="return 'param'; 156037"];
3935 [label="FullWidth = this.Text.Length; 156038"];
3936 [label="FullWidth 156039"];
3937 [label="this.AdjustFlagsAndWidth(trailing); 156040"];
3938 [label="return 'property'; 156041"];
3939 [label="FullWidth = this.Text.Length; 156042"];
3940 [label="FullWidth 156043"];
3941 [label="return 'property'; 156044"];
3942 [label="FullWidth = this.Text.Length; 156045"];
3943 [label="FullWidth 156046"];
3944 [label="this.AdjustFlagsAndWidth(leading); 156047"];
3945 [label="return 'property'; 156048"];
3946 [label="FullWidth = this.Text.Length; 156049"];
3947 [label="FullWidth 156050"];
3948 [label="this.AdjustFlagsAndWidth(trailing); 156051"];
3949 [label="return 'property'; 156052"];
3950 [label="FullWidth = this.Text.Length; 156053"];
3951 [label="FullWidth 156054"];
3952 [label="this.AdjustFlagsAndWidth(trailing); 156055"];
3953 [label="return 'typevar'; 156056"];
3954 [label="FullWidth = this.Text.Length; 156057"];
3955 [label="FullWidth 156058"];
3956 [label="return 'typevar'; 156059"];
3957 [label="FullWidth = this.Text.Length; 156060"];
3958 [label="FullWidth 156061"];
3959 [label="this.AdjustFlagsAndWidth(leading); 156062"];
3960 [label="return 'typevar'; 156063"];
3961 [label="FullWidth = this.Text.Length; 156064"];
3962 [label="FullWidth 156065"];
3963 [label="this.AdjustFlagsAndWidth(trailing); 156066"];
3964 [label="return 'typevar'; 156067"];
3965 [label="FullWidth = this.Text.Length; 156068"];
3966 [label="FullWidth 156069"];
3967 [label="this.AdjustFlagsAndWidth(trailing); 156070"];
3968 [label="return 'get'; 156071"];
3969 [label="FullWidth = this.Text.Length; 156072"];
3970 [label="FullWidth 156073"];
3971 [label="return 'get'; 156074"];
3972 [label="FullWidth = this.Text.Length; 156075"];
3973 [label="FullWidth 156076"];
3974 [label="this.AdjustFlagsAndWidth(leading); 156077"];
3975 [label="return 'get'; 156078"];
3976 [label="FullWidth = this.Text.Length; 156079"];
3977 [label="FullWidth 156080"];
3978 [label="this.AdjustFlagsAndWidth(trailing); 156081"];
3979 [label="return 'get'; 156082"];
3980 [label="FullWidth = this.Text.Length; 156083"];
3981 [label="FullWidth 156084"];
3982 [label="this.AdjustFlagsAndWidth(trailing); 156085"];
3983 [label="return 'set'; 156086"];
3984 [label="FullWidth = this.Text.Length; 156087"];
3985 [label="FullWidth 156088"];
3986 [label="return 'set'; 156089"];
3987 [label="FullWidth = this.Text.Length; 156090"];
3988 [label="FullWidth 156091"];
3989 [label="this.AdjustFlagsAndWidth(leading); 156092"];
3990 [label="return 'set'; 156093"];
3991 [label="FullWidth = this.Text.Length; 156094"];
3992 [label="FullWidth 156095"];
3993 [label="this.AdjustFlagsAndWidth(trailing); 156096"];
3994 [label="return 'set'; 156097"];
3995 [label="FullWidth = this.Text.Length; 156098"];
3996 [label="FullWidth 156099"];
3997 [label="this.AdjustFlagsAndWidth(trailing); 156100"];
3998 [label="return 'add'; 156101"];
3999 [label="FullWidth = this.Text.Length; 156102"];
4000 [label="FullWidth 156103"];
4001 [label="return 'add'; 156104"];
4002 [label="FullWidth = this.Text.Length; 156105"];
4003 [label="FullWidth 156106"];
4004 [label="this.AdjustFlagsAndWidth(leading); 156107"];
4005 [label="return 'add'; 156108"];
4006 [label="FullWidth = this.Text.Length; 156109"];
4007 [label="FullWidth 156110"];
4008 [label="this.AdjustFlagsAndWidth(trailing); 156111"];
4009 [label="return 'add'; 156112"];
4010 [label="FullWidth = this.Text.Length; 156113"];
4011 [label="FullWidth 156114"];
4012 [label="this.AdjustFlagsAndWidth(trailing); 156115"];
4013 [label="return 'remove'; 156116"];
4014 [label="FullWidth = this.Text.Length; 156117"];
4015 [label="FullWidth 156118"];
4016 [label="return 'remove'; 156119"];
4017 [label="FullWidth = this.Text.Length; 156120"];
4018 [label="FullWidth 156121"];
4019 [label="this.AdjustFlagsAndWidth(leading); 156122"];
4020 [label="return 'remove'; 156123"];
4021 [label="FullWidth = this.Text.Length; 156124"];
4022 [label="FullWidth 156125"];
4023 [label="this.AdjustFlagsAndWidth(trailing); 156126"];
4024 [label="return 'remove'; 156127"];
4025 [label="FullWidth = this.Text.Length; 156128"];
4026 [label="FullWidth 156129"];
4027 [label="this.AdjustFlagsAndWidth(trailing); 156130"];
4028 [label="return 'where'; 156131"];
4029 [label="FullWidth = this.Text.Length; 156132"];
4030 [label="FullWidth 156133"];
4031 [label="return 'where'; 156134"];
4032 [label="FullWidth = this.Text.Length; 156135"];
4033 [label="FullWidth 156136"];
4034 [label="this.AdjustFlagsAndWidth(leading); 156137"];
4035 [label="return 'where'; 156138"];
4036 [label="FullWidth = this.Text.Length; 156139"];
4037 [label="FullWidth 156140"];
4038 [label="this.AdjustFlagsAndWidth(trailing); 156141"];
4039 [label="return 'where'; 156142"];
4040 [label="FullWidth = this.Text.Length; 156143"];
4041 [label="FullWidth 156144"];
4042 [label="this.AdjustFlagsAndWidth(trailing); 156145"];
4043 [label="return 'from'; 156146"];
4044 [label="FullWidth = this.Text.Length; 156147"];
4045 [label="FullWidth 156148"];
4046 [label="return 'from'; 156149"];
4047 [label="FullWidth = this.Text.Length; 156150"];
4048 [label="FullWidth 156151"];
4049 [label="this.AdjustFlagsAndWidth(leading); 156152"];
4050 [label="return 'from'; 156153"];
4051 [label="FullWidth = this.Text.Length; 156154"];
4052 [label="FullWidth 156155"];
4053 [label="this.AdjustFlagsAndWidth(trailing); 156156"];
4054 [label="return 'from'; 156157"];
4055 [label="FullWidth = this.Text.Length; 156158"];
4056 [label="FullWidth 156159"];
4057 [label="this.AdjustFlagsAndWidth(trailing); 156160"];
4058 [label="return 'group'; 156161"];
4059 [label="FullWidth = this.Text.Length; 156162"];
4060 [label="FullWidth 156163"];
4061 [label="return 'group'; 156164"];
4062 [label="FullWidth = this.Text.Length; 156165"];
4063 [label="FullWidth 156166"];
4064 [label="this.AdjustFlagsAndWidth(leading); 156167"];
4065 [label="return 'group'; 156168"];
4066 [label="FullWidth = this.Text.Length; 156169"];
4067 [label="FullWidth 156170"];
4068 [label="this.AdjustFlagsAndWidth(trailing); 156171"];
4069 [label="return 'group'; 156172"];
4070 [label="FullWidth = this.Text.Length; 156173"];
4071 [label="FullWidth 156174"];
4072 [label="this.AdjustFlagsAndWidth(trailing); 156175"];
4073 [label="return 'join'; 156176"];
4074 [label="FullWidth = this.Text.Length; 156177"];
4075 [label="FullWidth 156178"];
4076 [label="return 'join'; 156179"];
4077 [label="FullWidth = this.Text.Length; 156180"];
4078 [label="FullWidth 156181"];
4079 [label="this.AdjustFlagsAndWidth(leading); 156182"];
4080 [label="return 'join'; 156183"];
4081 [label="FullWidth = this.Text.Length; 156184"];
4082 [label="FullWidth 156185"];
4083 [label="this.AdjustFlagsAndWidth(trailing); 156186"];
4084 [label="return 'join'; 156187"];
4085 [label="FullWidth = this.Text.Length; 156188"];
4086 [label="FullWidth 156189"];
4087 [label="this.AdjustFlagsAndWidth(trailing); 156190"];
4088 [label="return 'into'; 156191"];
4089 [label="FullWidth = this.Text.Length; 156192"];
4090 [label="FullWidth 156193"];
4091 [label="return 'into'; 156194"];
4092 [label="FullWidth = this.Text.Length; 156195"];
4093 [label="FullWidth 156196"];
4094 [label="this.AdjustFlagsAndWidth(leading); 156197"];
4095 [label="return 'into'; 156198"];
4096 [label="FullWidth = this.Text.Length; 156199"];
4097 [label="FullWidth 156200"];
4098 [label="this.AdjustFlagsAndWidth(trailing); 156201"];
4099 [label="return 'into'; 156202"];
4100 [label="FullWidth = this.Text.Length; 156203"];
4101 [label="FullWidth 156204"];
4102 [label="this.AdjustFlagsAndWidth(trailing); 156205"];
4103 [label="return 'let'; 156206"];
4104 [label="FullWidth = this.Text.Length; 156207"];
4105 [label="FullWidth 156208"];
4106 [label="return 'let'; 156209"];
4107 [label="FullWidth = this.Text.Length; 156210"];
4108 [label="FullWidth 156211"];
4109 [label="this.AdjustFlagsAndWidth(leading); 156212"];
4110 [label="return 'let'; 156213"];
4111 [label="FullWidth = this.Text.Length; 156214"];
4112 [label="FullWidth 156215"];
4113 [label="this.AdjustFlagsAndWidth(trailing); 156216"];
4114 [label="return 'let'; 156217"];
4115 [label="FullWidth = this.Text.Length; 156218"];
4116 [label="FullWidth 156219"];
4117 [label="this.AdjustFlagsAndWidth(trailing); 156220"];
4118 [label="return 'by'; 156221"];
4119 [label="FullWidth = this.Text.Length; 156222"];
4120 [label="FullWidth 156223"];
4121 [label="return 'by'; 156224"];
4122 [label="FullWidth = this.Text.Length; 156225"];
4123 [label="FullWidth 156226"];
4124 [label="this.AdjustFlagsAndWidth(leading); 156227"];
4125 [label="return 'by'; 156228"];
4126 [label="FullWidth = this.Text.Length; 156229"];
4127 [label="FullWidth 156230"];
4128 [label="this.AdjustFlagsAndWidth(trailing); 156231"];
4129 [label="return 'by'; 156232"];
4130 [label="FullWidth = this.Text.Length; 156233"];
4131 [label="FullWidth 156234"];
4132 [label="this.AdjustFlagsAndWidth(trailing); 156235"];
4133 [label="return 'select'; 156236"];
4134 [label="FullWidth = this.Text.Length; 156237"];
4135 [label="FullWidth 156238"];
4136 [label="return 'select'; 156239"];
4137 [label="FullWidth = this.Text.Length; 156240"];
4138 [label="FullWidth 156241"];
4139 [label="this.AdjustFlagsAndWidth(leading); 156242"];
4140 [label="return 'select'; 156243"];
4141 [label="FullWidth = this.Text.Length; 156244"];
4142 [label="FullWidth 156245"];
4143 [label="this.AdjustFlagsAndWidth(trailing); 156246"];
4144 [label="return 'select'; 156247"];
4145 [label="FullWidth = this.Text.Length; 156248"];
4146 [label="FullWidth 156249"];
4147 [label="this.AdjustFlagsAndWidth(trailing); 156250"];
4148 [label="return 'orderby'; 156251"];
4149 [label="FullWidth = this.Text.Length; 156252"];
4150 [label="FullWidth 156253"];
4151 [label="return 'orderby'; 156254"];
4152 [label="FullWidth = this.Text.Length; 156255"];
4153 [label="FullWidth 156256"];
4154 [label="this.AdjustFlagsAndWidth(leading); 156257"];
4155 [label="return 'orderby'; 156258"];
4156 [label="FullWidth = this.Text.Length; 156259"];
4157 [label="FullWidth 156260"];
4158 [label="this.AdjustFlagsAndWidth(trailing); 156261"];
4159 [label="return 'orderby'; 156262"];
4160 [label="FullWidth = this.Text.Length; 156263"];
4161 [label="FullWidth 156264"];
4162 [label="this.AdjustFlagsAndWidth(trailing); 156265"];
4163 [label="return 'on'; 156266"];
4164 [label="FullWidth = this.Text.Length; 156267"];
4165 [label="FullWidth 156268"];
4166 [label="return 'on'; 156269"];
4167 [label="FullWidth = this.Text.Length; 156270"];
4168 [label="FullWidth 156271"];
4169 [label="this.AdjustFlagsAndWidth(leading); 156272"];
4170 [label="return 'on'; 156273"];
4171 [label="FullWidth = this.Text.Length; 156274"];
4172 [label="FullWidth 156275"];
4173 [label="this.AdjustFlagsAndWidth(trailing); 156276"];
4174 [label="return 'on'; 156277"];
4175 [label="FullWidth = this.Text.Length; 156278"];
4176 [label="FullWidth 156279"];
4177 [label="this.AdjustFlagsAndWidth(trailing); 156280"];
4178 [label="return 'equals'; 156281"];
4179 [label="FullWidth = this.Text.Length; 156282"];
4180 [label="FullWidth 156283"];
4181 [label="return 'equals'; 156284"];
4182 [label="FullWidth = this.Text.Length; 156285"];
4183 [label="FullWidth 156286"];
4184 [label="this.AdjustFlagsAndWidth(leading); 156287"];
4185 [label="return 'equals'; 156288"];
4186 [label="FullWidth = this.Text.Length; 156289"];
4187 [label="FullWidth 156290"];
4188 [label="this.AdjustFlagsAndWidth(trailing); 156291"];
4189 [label="return 'equals'; 156292"];
4190 [label="FullWidth = this.Text.Length; 156293"];
4191 [label="FullWidth 156294"];
4192 [label="this.AdjustFlagsAndWidth(trailing); 156295"];
4193 [label="return 'ascending'; 156296"];
4194 [label="FullWidth = this.Text.Length; 156297"];
4195 [label="FullWidth 156298"];
4196 [label="return 'ascending'; 156299"];
4197 [label="FullWidth = this.Text.Length; 156300"];
4198 [label="FullWidth 156301"];
4199 [label="this.AdjustFlagsAndWidth(leading); 156302"];
4200 [label="return 'ascending'; 156303"];
4201 [label="FullWidth = this.Text.Length; 156304"];
4202 [label="FullWidth 156305"];
4203 [label="this.AdjustFlagsAndWidth(trailing); 156306"];
4204 [label="return 'ascending'; 156307"];
4205 [label="FullWidth = this.Text.Length; 156308"];
4206 [label="FullWidth 156309"];
4207 [label="this.AdjustFlagsAndWidth(trailing); 156310"];
4208 [label="return 'descending'; 156311"];
4209 [label="FullWidth = this.Text.Length; 156312"];
4210 [label="FullWidth 156313"];
4211 [label="return 'descending'; 156314"];
4212 [label="FullWidth = this.Text.Length; 156315"];
4213 [label="FullWidth 156316"];
4214 [label="this.AdjustFlagsAndWidth(leading); 156317"];
4215 [label="return 'descending'; 156318"];
4216 [label="FullWidth = this.Text.Length; 156319"];
4217 [label="FullWidth 156320"];
4218 [label="this.AdjustFlagsAndWidth(trailing); 156321"];
4219 [label="return 'descending'; 156322"];
4220 [label="FullWidth = this.Text.Length; 156323"];
4221 [label="FullWidth 156324"];
4222 [label="this.AdjustFlagsAndWidth(trailing); 156325"];
4223 [label="return 'nameof'; 156326"];
4224 [label="FullWidth = this.Text.Length; 156327"];
4225 [label="FullWidth 156328"];
4226 [label="return 'nameof'; 156329"];
4227 [label="FullWidth = this.Text.Length; 156330"];
4228 [label="FullWidth 156331"];
4229 [label="this.AdjustFlagsAndWidth(leading); 156332"];
4230 [label="return 'nameof'; 156333"];
4231 [label="FullWidth = this.Text.Length; 156334"];
4232 [label="FullWidth 156335"];
4233 [label="this.AdjustFlagsAndWidth(trailing); 156336"];
4234 [label="return 'nameof'; 156337"];
4235 [label="FullWidth = this.Text.Length; 156338"];
4236 [label="FullWidth 156339"];
4237 [label="this.AdjustFlagsAndWidth(trailing); 156340"];
4238 [label="return 'async'; 156341"];
4239 [label="FullWidth = this.Text.Length; 156342"];
4240 [label="FullWidth 156343"];
4241 [label="return 'async'; 156344"];
4242 [label="FullWidth = this.Text.Length; 156345"];
4243 [label="FullWidth 156346"];
4244 [label="this.AdjustFlagsAndWidth(leading); 156347"];
4245 [label="return 'async'; 156348"];
4246 [label="FullWidth = this.Text.Length; 156349"];
4247 [label="FullWidth 156350"];
4248 [label="this.AdjustFlagsAndWidth(trailing); 156351"];
4249 [label="return 'async'; 156352"];
4250 [label="FullWidth = this.Text.Length; 156353"];
4251 [label="FullWidth 156354"];
4252 [label="this.AdjustFlagsAndWidth(trailing); 156355"];
4253 [label="return 'await'; 156356"];
4254 [label="FullWidth = this.Text.Length; 156357"];
4255 [label="FullWidth 156358"];
4256 [label="return 'await'; 156359"];
4257 [label="FullWidth = this.Text.Length; 156360"];
4258 [label="FullWidth 156361"];
4259 [label="this.AdjustFlagsAndWidth(leading); 156362"];
4260 [label="return 'await'; 156363"];
4261 [label="FullWidth = this.Text.Length; 156364"];
4262 [label="FullWidth 156365"];
4263 [label="this.AdjustFlagsAndWidth(trailing); 156366"];
4264 [label="return 'await'; 156367"];
4265 [label="FullWidth = this.Text.Length; 156368"];
4266 [label="FullWidth 156369"];
4267 [label="this.AdjustFlagsAndWidth(trailing); 156370"];
4268 [label="return 'when'; 156371"];
4269 [label="FullWidth = this.Text.Length; 156372"];
4270 [label="FullWidth 156373"];
4271 [label="return 'when'; 156374"];
4272 [label="FullWidth = this.Text.Length; 156375"];
4273 [label="FullWidth 156376"];
4274 [label="this.AdjustFlagsAndWidth(leading); 156377"];
4275 [label="return 'when'; 156378"];
4276 [label="FullWidth = this.Text.Length; 156379"];
4277 [label="FullWidth 156380"];
4278 [label="this.AdjustFlagsAndWidth(trailing); 156381"];
4279 [label="return 'when'; 156382"];
4280 [label="FullWidth = this.Text.Length; 156383"];
4281 [label="FullWidth 156384"];
4282 [label="this.AdjustFlagsAndWidth(trailing); 156385"];
4283 [label="return 'or'; 156386"];
4284 [label="FullWidth = this.Text.Length; 156387"];
4285 [label="FullWidth 156388"];
4286 [label="return 'or'; 156389"];
4287 [label="FullWidth = this.Text.Length; 156390"];
4288 [label="FullWidth 156391"];
4289 [label="this.AdjustFlagsAndWidth(leading); 156392"];
4290 [label="return 'or'; 156393"];
4291 [label="FullWidth = this.Text.Length; 156394"];
4292 [label="FullWidth 156395"];
4293 [label="this.AdjustFlagsAndWidth(trailing); 156396"];
4294 [label="return 'or'; 156397"];
4295 [label="FullWidth = this.Text.Length; 156398"];
4296 [label="FullWidth 156399"];
4297 [label="this.AdjustFlagsAndWidth(trailing); 156400"];
4298 [label="return 'and'; 156401"];
4299 [label="FullWidth = this.Text.Length; 156402"];
4300 [label="FullWidth 156403"];
4301 [label="return 'and'; 156404"];
4302 [label="FullWidth = this.Text.Length; 156405"];
4303 [label="FullWidth 156406"];
4304 [label="this.AdjustFlagsAndWidth(leading); 156407"];
4305 [label="return 'and'; 156408"];
4306 [label="FullWidth = this.Text.Length; 156409"];
4307 [label="FullWidth 156410"];
4308 [label="this.AdjustFlagsAndWidth(trailing); 156411"];
4309 [label="return 'and'; 156412"];
4310 [label="FullWidth = this.Text.Length; 156413"];
4311 [label="FullWidth 156414"];
4312 [label="this.AdjustFlagsAndWidth(trailing); 156415"];
4313 [label="return 'not'; 156416"];
4314 [label="FullWidth = this.Text.Length; 156417"];
4315 [label="FullWidth 156418"];
4316 [label="return 'not'; 156419"];
4317 [label="FullWidth = this.Text.Length; 156420"];
4318 [label="FullWidth 156421"];
4319 [label="this.AdjustFlagsAndWidth(leading); 156422"];
4320 [label="return 'not'; 156423"];
4321 [label="FullWidth = this.Text.Length; 156424"];
4322 [label="FullWidth 156425"];
4323 [label="this.AdjustFlagsAndWidth(trailing); 156426"];
4324 [label="return 'not'; 156427"];
4325 [label="FullWidth = this.Text.Length; 156428"];
4326 [label="FullWidth 156429"];
4327 [label="this.AdjustFlagsAndWidth(trailing); 156430"];
4328 [label="return 'data'; 156431"];
4329 [label="FullWidth = this.Text.Length; 156432"];
4330 [label="FullWidth 156433"];
4331 [label="return 'data'; 156434"];
4332 [label="FullWidth = this.Text.Length; 156435"];
4333 [label="FullWidth 156436"];
4334 [label="this.AdjustFlagsAndWidth(leading); 156437"];
4335 [label="return 'data'; 156438"];
4336 [label="FullWidth = this.Text.Length; 156439"];
4337 [label="FullWidth 156440"];
4338 [label="this.AdjustFlagsAndWidth(trailing); 156441"];
4339 [label="return 'data'; 156442"];
4340 [label="FullWidth = this.Text.Length; 156443"];
4341 [label="FullWidth 156444"];
4342 [label="this.AdjustFlagsAndWidth(trailing); 156445"];
4343 [label="return 'with'; 156446"];
4344 [label="FullWidth = this.Text.Length; 156447"];
4345 [label="FullWidth 156448"];
4346 [label="return 'with'; 156449"];
4347 [label="FullWidth = this.Text.Length; 156450"];
4348 [label="FullWidth 156451"];
4349 [label="this.AdjustFlagsAndWidth(leading); 156452"];
4350 [label="return 'with'; 156453"];
4351 [label="FullWidth = this.Text.Length; 156454"];
4352 [label="FullWidth 156455"];
4353 [label="this.AdjustFlagsAndWidth(trailing); 156456"];
4354 [label="return 'with'; 156457"];
4355 [label="FullWidth = this.Text.Length; 156458"];
4356 [label="FullWidth 156459"];
4357 [label="this.AdjustFlagsAndWidth(trailing); 156460"];
4358 [label="return 'init'; 156461"];
4359 [label="FullWidth = this.Text.Length; 156462"];
4360 [label="FullWidth 156463"];
4361 [label="return 'init'; 156464"];
4362 [label="FullWidth = this.Text.Length; 156465"];
4363 [label="FullWidth 156466"];
4364 [label="this.AdjustFlagsAndWidth(leading); 156467"];
4365 [label="return 'init'; 156468"];
4366 [label="FullWidth = this.Text.Length; 156469"];
4367 [label="FullWidth 156470"];
4368 [label="this.AdjustFlagsAndWidth(trailing); 156471"];
4369 [label="return 'init'; 156472"];
4370 [label="FullWidth = this.Text.Length; 156473"];
4371 [label="FullWidth 156474"];
4372 [label="this.AdjustFlagsAndWidth(trailing); 156475"];
4373 [label="return 'record'; 156476"];
4374 [label="FullWidth = this.Text.Length; 156477"];
4375 [label="FullWidth 156478"];
4376 [label="return 'record'; 156479"];
4377 [label="FullWidth = this.Text.Length; 156480"];
4378 [label="FullWidth 156481"];
4379 [label="this.AdjustFlagsAndWidth(leading); 156482"];
4380 [label="return 'record'; 156483"];
4381 [label="FullWidth = this.Text.Length; 156484"];
4382 [label="FullWidth 156485"];
4383 [label="this.AdjustFlagsAndWidth(trailing); 156486"];
4384 [label="return 'record'; 156487"];
4385 [label="FullWidth = this.Text.Length; 156488"];
4386 [label="FullWidth 156489"];
4387 [label="this.AdjustFlagsAndWidth(trailing); 156490"];
4388 [label="return 'managed'; 156491"];
4389 [label="FullWidth = this.Text.Length; 156492"];
4390 [label="FullWidth 156493"];
4391 [label="return 'managed'; 156494"];
4392 [label="FullWidth = this.Text.Length; 156495"];
4393 [label="FullWidth 156496"];
4394 [label="this.AdjustFlagsAndWidth(leading); 156497"];
4395 [label="return 'managed'; 156498"];
4396 [label="FullWidth = this.Text.Length; 156499"];
4397 [label="FullWidth 156500"];
4398 [label="this.AdjustFlagsAndWidth(trailing); 156501"];
4399 [label="return 'managed'; 156502"];
4400 [label="FullWidth = this.Text.Length; 156503"];
4401 [label="FullWidth 156504"];
4402 [label="this.AdjustFlagsAndWidth(trailing); 156505"];
4403 [label="return 'unmanaged'; 156506"];
4404 [label="FullWidth = this.Text.Length; 156507"];
4405 [label="FullWidth 156508"];
4406 [label="return 'unmanaged'; 156509"];
4407 [label="FullWidth = this.Text.Length; 156510"];
4408 [label="FullWidth 156511"];
4409 [label="this.AdjustFlagsAndWidth(leading); 156512"];
4410 [label="return 'unmanaged'; 156513"];
4411 [label="FullWidth = this.Text.Length; 156514"];
4412 [label="FullWidth 156515"];
4413 [label="this.AdjustFlagsAndWidth(trailing); 156516"];
4414 [label="return 'unmanaged'; 156517"];
4415 [label="FullWidth = this.Text.Length; 156518"];
4416 [label="FullWidth 156519"];
4417 [label="this.AdjustFlagsAndWidth(trailing); 156520"];
4418 [label="return 'elif'; 156521"];
4419 [label="FullWidth = this.Text.Length; 156522"];
4420 [label="FullWidth 156523"];
4421 [label="return 'elif'; 156524"];
4422 [label="FullWidth = this.Text.Length; 156525"];
4423 [label="FullWidth 156526"];
4424 [label="this.AdjustFlagsAndWidth(leading); 156527"];
4425 [label="return 'elif'; 156528"];
4426 [label="FullWidth = this.Text.Length; 156529"];
4427 [label="FullWidth 156530"];
4428 [label="this.AdjustFlagsAndWidth(trailing); 156531"];
4429 [label="return 'elif'; 156532"];
4430 [label="FullWidth = this.Text.Length; 156533"];
4431 [label="FullWidth 156534"];
4432 [label="this.AdjustFlagsAndWidth(trailing); 156535"];
4433 [label="return 'endif'; 156536"];
4434 [label="FullWidth = this.Text.Length; 156537"];
4435 [label="FullWidth 156538"];
4436 [label="return 'endif'; 156539"];
4437 [label="FullWidth = this.Text.Length; 156540"];
4438 [label="FullWidth 156541"];
4439 [label="this.AdjustFlagsAndWidth(leading); 156542"];
4440 [label="return 'endif'; 156543"];
4441 [label="FullWidth = this.Text.Length; 156544"];
4442 [label="FullWidth 156545"];
4443 [label="this.AdjustFlagsAndWidth(trailing); 156546"];
4444 [label="return 'endif'; 156547"];
4445 [label="FullWidth = this.Text.Length; 156548"];
4446 [label="FullWidth 156549"];
4447 [label="this.AdjustFlagsAndWidth(trailing); 156550"];
4448 [label="return 'region'; 156551"];
4449 [label="FullWidth = this.Text.Length; 156552"];
4450 [label="FullWidth 156553"];
4451 [label="return 'region'; 156554"];
4452 [label="FullWidth = this.Text.Length; 156555"];
4453 [label="FullWidth 156556"];
4454 [label="this.AdjustFlagsAndWidth(leading); 156557"];
4455 [label="return 'region'; 156558"];
4456 [label="FullWidth = this.Text.Length; 156559"];
4457 [label="FullWidth 156560"];
4458 [label="this.AdjustFlagsAndWidth(trailing); 156561"];
4459 [label="return 'region'; 156562"];
4460 [label="FullWidth = this.Text.Length; 156563"];
4461 [label="FullWidth 156564"];
4462 [label="this.AdjustFlagsAndWidth(trailing); 156565"];
4463 [label="return 'endregion'; 156566"];
4464 [label="FullWidth = this.Text.Length; 156567"];
4465 [label="FullWidth 156568"];
4466 [label="return 'endregion'; 156569"];
4467 [label="FullWidth = this.Text.Length; 156570"];
4468 [label="FullWidth 156571"];
4469 [label="this.AdjustFlagsAndWidth(leading); 156572"];
4470 [label="return 'endregion'; 156573"];
4471 [label="FullWidth = this.Text.Length; 156574"];
4472 [label="FullWidth 156575"];
4473 [label="this.AdjustFlagsAndWidth(trailing); 156576"];
4474 [label="return 'endregion'; 156577"];
4475 [label="FullWidth = this.Text.Length; 156578"];
4476 [label="FullWidth 156579"];
4477 [label="this.AdjustFlagsAndWidth(trailing); 156580"];
4478 [label="return 'define'; 156581"];
4479 [label="FullWidth = this.Text.Length; 156582"];
4480 [label="FullWidth 156583"];
4481 [label="return 'define'; 156584"];
4482 [label="FullWidth = this.Text.Length; 156585"];
4483 [label="FullWidth 156586"];
4484 [label="this.AdjustFlagsAndWidth(leading); 156587"];
4485 [label="return 'define'; 156588"];
4486 [label="FullWidth = this.Text.Length; 156589"];
4487 [label="FullWidth 156590"];
4488 [label="this.AdjustFlagsAndWidth(trailing); 156591"];
4489 [label="return 'define'; 156592"];
4490 [label="FullWidth = this.Text.Length; 156593"];
4491 [label="FullWidth 156594"];
4492 [label="this.AdjustFlagsAndWidth(trailing); 156595"];
4493 [label="return 'undef'; 156596"];
4494 [label="FullWidth = this.Text.Length; 156597"];
4495 [label="FullWidth 156598"];
4496 [label="return 'undef'; 156599"];
4497 [label="FullWidth = this.Text.Length; 156600"];
4498 [label="FullWidth 156601"];
4499 [label="this.AdjustFlagsAndWidth(leading); 156602"];
4500 [label="return 'undef'; 156603"];
4501 [label="FullWidth = this.Text.Length; 156604"];
4502 [label="FullWidth 156605"];
4503 [label="this.AdjustFlagsAndWidth(trailing); 156606"];
4504 [label="return 'undef'; 156607"];
4505 [label="FullWidth = this.Text.Length; 156608"];
4506 [label="FullWidth 156609"];
4507 [label="this.AdjustFlagsAndWidth(trailing); 156610"];
4508 [label="return 'warning'; 156611"];
4509 [label="FullWidth = this.Text.Length; 156612"];
4510 [label="FullWidth 156613"];
4511 [label="return 'warning'; 156614"];
4512 [label="FullWidth = this.Text.Length; 156615"];
4513 [label="FullWidth 156616"];
4514 [label="this.AdjustFlagsAndWidth(leading); 156617"];
4515 [label="return 'warning'; 156618"];
4516 [label="FullWidth = this.Text.Length; 156619"];
4517 [label="FullWidth 156620"];
4518 [label="this.AdjustFlagsAndWidth(trailing); 156621"];
4519 [label="return 'warning'; 156622"];
4520 [label="FullWidth = this.Text.Length; 156623"];
4521 [label="FullWidth 156624"];
4522 [label="this.AdjustFlagsAndWidth(trailing); 156625"];
4523 [label="return 'error'; 156626"];
4524 [label="FullWidth = this.Text.Length; 156627"];
4525 [label="FullWidth 156628"];
4526 [label="return 'error'; 156629"];
4527 [label="FullWidth = this.Text.Length; 156630"];
4528 [label="FullWidth 156631"];
4529 [label="this.AdjustFlagsAndWidth(leading); 156632"];
4530 [label="return 'error'; 156633"];
4531 [label="FullWidth = this.Text.Length; 156634"];
4532 [label="FullWidth 156635"];
4533 [label="this.AdjustFlagsAndWidth(trailing); 156636"];
4534 [label="return 'error'; 156637"];
4535 [label="FullWidth = this.Text.Length; 156638"];
4536 [label="FullWidth 156639"];
4537 [label="this.AdjustFlagsAndWidth(trailing); 156640"];
4538 [label="return 'line'; 156641"];
4539 [label="FullWidth = this.Text.Length; 156642"];
4540 [label="FullWidth 156643"];
4541 [label="return 'line'; 156644"];
4542 [label="FullWidth = this.Text.Length; 156645"];
4543 [label="FullWidth 156646"];
4544 [label="this.AdjustFlagsAndWidth(leading); 156647"];
4545 [label="return 'line'; 156648"];
4546 [label="FullWidth = this.Text.Length; 156649"];
4547 [label="FullWidth 156650"];
4548 [label="this.AdjustFlagsAndWidth(trailing); 156651"];
4549 [label="return 'line'; 156652"];
4550 [label="FullWidth = this.Text.Length; 156653"];
4551 [label="FullWidth 156654"];
4552 [label="this.AdjustFlagsAndWidth(trailing); 156655"];
4553 [label="return 'pragma'; 156656"];
4554 [label="FullWidth = this.Text.Length; 156657"];
4555 [label="FullWidth 156658"];
4556 [label="return 'pragma'; 156659"];
4557 [label="FullWidth = this.Text.Length; 156660"];
4558 [label="FullWidth 156661"];
4559 [label="this.AdjustFlagsAndWidth(leading); 156662"];
4560 [label="return 'pragma'; 156663"];
4561 [label="FullWidth = this.Text.Length; 156664"];
4562 [label="FullWidth 156665"];
4563 [label="this.AdjustFlagsAndWidth(trailing); 156666"];
4564 [label="return 'pragma'; 156667"];
4565 [label="FullWidth = this.Text.Length; 156668"];
4566 [label="FullWidth 156669"];
4567 [label="this.AdjustFlagsAndWidth(trailing); 156670"];
4568 [label="return 'hidden'; 156671"];
4569 [label="FullWidth = this.Text.Length; 156672"];
4570 [label="FullWidth 156673"];
4571 [label="return 'hidden'; 156674"];
4572 [label="FullWidth = this.Text.Length; 156675"];
4573 [label="FullWidth 156676"];
4574 [label="this.AdjustFlagsAndWidth(leading); 156677"];
4575 [label="return 'hidden'; 156678"];
4576 [label="FullWidth = this.Text.Length; 156679"];
4577 [label="FullWidth 156680"];
4578 [label="this.AdjustFlagsAndWidth(trailing); 156681"];
4579 [label="return 'hidden'; 156682"];
4580 [label="FullWidth = this.Text.Length; 156683"];
4581 [label="FullWidth 156684"];
4582 [label="this.AdjustFlagsAndWidth(trailing); 156685"];
4583 [label="return 'checksum'; 156686"];
4584 [label="FullWidth = this.Text.Length; 156687"];
4585 [label="FullWidth 156688"];
4586 [label="return 'checksum'; 156689"];
4587 [label="FullWidth = this.Text.Length; 156690"];
4588 [label="FullWidth 156691"];
4589 [label="this.AdjustFlagsAndWidth(leading); 156692"];
4590 [label="return 'checksum'; 156693"];
4591 [label="FullWidth = this.Text.Length; 156694"];
4592 [label="FullWidth 156695"];
4593 [label="this.AdjustFlagsAndWidth(trailing); 156696"];
4594 [label="return 'checksum'; 156697"];
4595 [label="FullWidth = this.Text.Length; 156698"];
4596 [label="FullWidth 156699"];
4597 [label="this.AdjustFlagsAndWidth(trailing); 156700"];
4598 [label="return 'disable'; 156701"];
4599 [label="FullWidth = this.Text.Length; 156702"];
4600 [label="FullWidth 156703"];
4601 [label="return 'disable'; 156704"];
4602 [label="FullWidth = this.Text.Length; 156705"];
4603 [label="FullWidth 156706"];
4604 [label="this.AdjustFlagsAndWidth(leading); 156707"];
4605 [label="return 'disable'; 156708"];
4606 [label="FullWidth = this.Text.Length; 156709"];
4607 [label="FullWidth 156710"];
4608 [label="this.AdjustFlagsAndWidth(trailing); 156711"];
4609 [label="return 'disable'; 156712"];
4610 [label="FullWidth = this.Text.Length; 156713"];
4611 [label="FullWidth 156714"];
4612 [label="this.AdjustFlagsAndWidth(trailing); 156715"];
4613 [label="return 'restore'; 156716"];
4614 [label="FullWidth = this.Text.Length; 156717"];
4615 [label="FullWidth 156718"];
4616 [label="return 'restore'; 156719"];
4617 [label="FullWidth = this.Text.Length; 156720"];
4618 [label="FullWidth 156721"];
4619 [label="this.AdjustFlagsAndWidth(leading); 156722"];
4620 [label="return 'restore'; 156723"];
4621 [label="FullWidth = this.Text.Length; 156724"];
4622 [label="FullWidth 156725"];
4623 [label="this.AdjustFlagsAndWidth(trailing); 156726"];
4624 [label="return 'restore'; 156727"];
4625 [label="FullWidth = this.Text.Length; 156728"];
4626 [label="FullWidth 156729"];
4627 [label="this.AdjustFlagsAndWidth(trailing); 156730"];
4628 [label="return 'r'; 156731"];
4629 [label="FullWidth = this.Text.Length; 156732"];
4630 [label="FullWidth 156733"];
4631 [label="return 'r'; 156734"];
4632 [label="FullWidth = this.Text.Length; 156735"];
4633 [label="FullWidth 156736"];
4634 [label="this.AdjustFlagsAndWidth(leading); 156737"];
4635 [label="return 'r'; 156738"];
4636 [label="FullWidth = this.Text.Length; 156739"];
4637 [label="FullWidth 156740"];
4638 [label="this.AdjustFlagsAndWidth(trailing); 156741"];
4639 [label="return 'r'; 156742"];
4640 [label="FullWidth = this.Text.Length; 156743"];
4641 [label="FullWidth 156744"];
4642 [label="this.AdjustFlagsAndWidth(trailing); 156745"];
4643 [label="return '$\\''; 156746"];
4644 [label="FullWidth = this.Text.Length; 156747"];
4645 [label="FullWidth 156748"];
4646 [label="return '$\\''; 156749"];
4647 [label="FullWidth = this.Text.Length; 156750"];
4648 [label="FullWidth 156751"];
4649 [label="this.AdjustFlagsAndWidth(leading); 156752"];
4650 [label="return '$\\''; 156753"];
4651 [label="FullWidth = this.Text.Length; 156754"];
4652 [label="FullWidth 156755"];
4653 [label="this.AdjustFlagsAndWidth(trailing); 156756"];
4654 [label="return '$\\''; 156757"];
4655 [label="FullWidth = this.Text.Length; 156758"];
4656 [label="FullWidth 156759"];
4657 [label="this.AdjustFlagsAndWidth(trailing); 156760"];
4658 [label="return '\\''; 156761"];
4659 [label="FullWidth = this.Text.Length; 156762"];
4660 [label="FullWidth 156763"];
4661 [label="return '\\''; 156764"];
4662 [label="FullWidth = this.Text.Length; 156765"];
4663 [label="FullWidth 156766"];
4664 [label="this.AdjustFlagsAndWidth(leading); 156767"];
4665 [label="return '\\''; 156768"];
4666 [label="FullWidth = this.Text.Length; 156769"];
4667 [label="FullWidth 156770"];
4668 [label="this.AdjustFlagsAndWidth(trailing); 156771"];
4669 [label="return '\\''; 156772"];
4670 [label="FullWidth = this.Text.Length; 156773"];
4671 [label="FullWidth 156774"];
4672 [label="this.AdjustFlagsAndWidth(trailing); 156775"];
4673 [label="return '$@\\''; 156776"];
4674 [label="FullWidth = this.Text.Length; 156777"];
4675 [label="FullWidth 156778"];
4676 [label="return '$@\\''; 156779"];
4677 [label="FullWidth = this.Text.Length; 156780"];
4678 [label="FullWidth 156781"];
4679 [label="this.AdjustFlagsAndWidth(leading); 156782"];
4680 [label="return '$@\\''; 156783"];
4681 [label="FullWidth = this.Text.Length; 156784"];
4682 [label="FullWidth 156785"];
4683 [label="this.AdjustFlagsAndWidth(trailing); 156786"];
4684 [label="return '$@\\''; 156787"];
4685 [label="FullWidth = this.Text.Length; 156788"];
4686 [label="FullWidth 156789"];
4687 [label="this.AdjustFlagsAndWidth(trailing); 156790"];
4688 [label="return 'load'; 156791"];
4689 [label="FullWidth = this.Text.Length; 156792"];
4690 [label="FullWidth 156793"];
4691 [label="return 'load'; 156794"];
4692 [label="FullWidth = this.Text.Length; 156795"];
4693 [label="FullWidth 156796"];
4694 [label="this.AdjustFlagsAndWidth(leading); 156797"];
4695 [label="return 'load'; 156798"];
4696 [label="FullWidth = this.Text.Length; 156799"];
4697 [label="FullWidth 156800"];
4698 [label="this.AdjustFlagsAndWidth(trailing); 156801"];
4699 [label="return 'load'; 156802"];
4700 [label="FullWidth = this.Text.Length; 156803"];
4701 [label="FullWidth 156804"];
4702 [label="this.AdjustFlagsAndWidth(trailing); 156805"];
4703 [label="return 'nullable'; 156806"];
4704 [label="FullWidth = this.Text.Length; 156807"];
4705 [label="FullWidth 156808"];
4706 [label="return 'nullable'; 156809"];
4707 [label="FullWidth = this.Text.Length; 156810"];
4708 [label="FullWidth 156811"];
4709 [label="this.AdjustFlagsAndWidth(leading); 156812"];
4710 [label="return 'nullable'; 156813"];
4711 [label="FullWidth = this.Text.Length; 156814"];
4712 [label="FullWidth 156815"];
4713 [label="this.AdjustFlagsAndWidth(trailing); 156816"];
4714 [label="return 'nullable'; 156817"];
4715 [label="FullWidth = this.Text.Length; 156818"];
4716 [label="FullWidth 156819"];
4717 [label="this.AdjustFlagsAndWidth(trailing); 156820"];
4718 [label="return 'enable'; 156821"];
4719 [label="FullWidth = this.Text.Length; 156822"];
4720 [label="FullWidth 156823"];
4721 [label="return 'enable'; 156824"];
4722 [label="FullWidth = this.Text.Length; 156825"];
4723 [label="FullWidth 156826"];
4724 [label="this.AdjustFlagsAndWidth(leading); 156827"];
4725 [label="return 'enable'; 156828"];
4726 [label="FullWidth = this.Text.Length; 156829"];
4727 [label="FullWidth 156830"];
4728 [label="this.AdjustFlagsAndWidth(trailing); 156831"];
4729 [label="return 'enable'; 156832"];
4730 [label="FullWidth = this.Text.Length; 156833"];
4731 [label="FullWidth 156834"];
4732 [label="this.AdjustFlagsAndWidth(trailing); 156835"];
4733 [label="return 'warnings'; 156836"];
4734 [label="FullWidth = this.Text.Length; 156837"];
4735 [label="FullWidth 156838"];
4736 [label="return 'warnings'; 156839"];
4737 [label="FullWidth = this.Text.Length; 156840"];
4738 [label="FullWidth 156841"];
4739 [label="this.AdjustFlagsAndWidth(leading); 156842"];
4740 [label="return 'warnings'; 156843"];
4741 [label="FullWidth = this.Text.Length; 156844"];
4742 [label="FullWidth 156845"];
4743 [label="this.AdjustFlagsAndWidth(trailing); 156846"];
4744 [label="return 'warnings'; 156847"];
4745 [label="FullWidth = this.Text.Length; 156848"];
4746 [label="FullWidth 156849"];
4747 [label="this.AdjustFlagsAndWidth(trailing); 156850"];
4748 [label="return 'annotations'; 156851"];
4749 [label="FullWidth = this.Text.Length; 156852"];
4750 [label="FullWidth 156853"];
4751 [label="return 'annotations'; 156854"];
4752 [label="FullWidth = this.Text.Length; 156855"];
4753 [label="FullWidth 156856"];
4754 [label="this.AdjustFlagsAndWidth(leading); 156857"];
4755 [label="return 'annotations'; 156858"];
4756 [label="FullWidth = this.Text.Length; 156859"];
4757 [label="FullWidth 156860"];
4758 [label="this.AdjustFlagsAndWidth(trailing); 156861"];
4759 [label="return 'annotations'; 156862"];
4760 [label="FullWidth = this.Text.Length; 156863"];
4761 [label="FullWidth 156864"];
4762 [label="this.AdjustFlagsAndWidth(trailing); 156865"];
4763 [label="return 'var'; 156866"];
4764 [label="FullWidth = this.Text.Length; 156867"];
4765 [label="FullWidth 156868"];
4766 [label="return 'var'; 156869"];
4767 [label="FullWidth = this.Text.Length; 156870"];
4768 [label="FullWidth 156871"];
4769 [label="this.AdjustFlagsAndWidth(leading); 156872"];
4770 [label="return 'var'; 156873"];
4771 [label="FullWidth = this.Text.Length; 156874"];
4772 [label="FullWidth 156875"];
4773 [label="this.AdjustFlagsAndWidth(trailing); 156876"];
4774 [label="return 'var'; 156877"];
4775 [label="FullWidth = this.Text.Length; 156878"];
4776 [label="FullWidth 156879"];
4777 [label="this.AdjustFlagsAndWidth(trailing); 156880"];
4778 [label="return '_'; 156881"];
4779 [label="FullWidth = this.Text.Length; 156882"];
4780 [label="FullWidth 156883"];
4781 [label="return '_'; 156884"];
4782 [label="FullWidth = this.Text.Length; 156885"];
4783 [label="FullWidth 156886"];
4784 [label="this.AdjustFlagsAndWidth(leading); 156887"];
4785 [label="return '_'; 156888"];
4786 [label="FullWidth = this.Text.Length; 156889"];
4787 [label="FullWidth 156890"];
4788 [label="this.AdjustFlagsAndWidth(trailing); 156891"];
4789 [label="return '_'; 156892"];
4790 [label="FullWidth = this.Text.Length; 156893"];
4791 [label="FullWidth 156894"];
4792 [label="this.AdjustFlagsAndWidth(trailing); 156895"];
4793 [label="return SyntaxToken.Create(kind, leading, trailing); 156896"];
4794 [label="return SyntaxToken.Create(kind, leading, trailing); 156897"];
4795 [label="return SyntaxToken.Create(kind, leading, trailing); 156898"];
4796 [label="SyntaxToken.Create(kind, leading, trailing) 156899"];
4797 [label="param Create(SyntaxKind kind) 156900"];
4798 [label="param Create(GreenNode leading) 156901"];
4799 [label="param Create(GreenNode trailing) 156902"];
4800 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 156903"];
4801 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 156904"];
4802 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 156905"];
4803 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 156906"];
4804 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 156907"];
4805 [label="if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 156908"];
4806 [label="return s_tokensWithSingleTrailingSpace[(int)kind].Value; 156909"];
4807 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 156910"];
4808 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 156911"];
4809 [label="return token; 156912"];
4810 [label="this.AddLexedToken(token); 156913"];
4811 [label="this.AddLexedToken(token) 156914"];
4812 [label="param AddLexedToken(SyntaxToken token) 156915"];
4813 [label="param AddLexedToken(this) 156916"];
4814 [label="Debug.Assert(token != null); 156917"];
4815 [label="Debug.Assert(token != null); 156918"];
4816 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 156919"];
4817 [label="_lexedTokens[_tokenCount].Value = token; 156920"];
4818 [label="_lexedTokens[_tokenCount].Value 156921"];
4819 [label="_tokenCount 156922"];
4820 [label="this.AddLexedToken(token); 156923"];
4821 [label="token.Kind 156924"];
4822 [label="get { return (SyntaxKind)this.RawKind; } 156925"];
4823 [label="return (SyntaxKind)this.RawKind; 156926"];
4824 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 156927"];
4825 [label="TextWindow.Start(); 156928"];
4826 [label="get\n            {\n                return _lexemeStart;\n            } 156929"];
4827 [label="return _lexemeStart; 156930"];
4828 [label="param LookupToken(char[] textBuffer) 156931"];
4829 [label="param LookupToken(int keyStart) 156932"];
4830 [label="param LookupToken(int keyLength) 156933"];
4831 [label="param LookupToken(int hashCode) 156934"];
4832 [label="param LookupToken(Func<SyntaxToken> createTokenFunction) 156935"];
4833 [label="param LookupToken(this) 156936"];
4834 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 156937"];
4835 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 156938"];
4836 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 156939"];
4837 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 156940"];
4838 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 156941"];
4839 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 156942"];
4840 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 156943"];
4841 [label="value = createTokenFunction(); 156944"];
4842 [label="value = createTokenFunction(); 156945"];
4843 [label="param CreateQuickToken(this) 156946"];
4844 [label="TextWindow.Width 156947"];
4845 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 156948"];
4846 [label="var quickWidth = TextWindow.Width; 156949"];
4847 [label="TextWindow.LexemeStartPosition 156950"];
4848 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 156951"];
4849 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 156952"];
4850 [label="TextWindow.Reset(TextWindow.LexemeStartPosition) 156953"];
4851 [label="param Reset(int position) 156954"];
4852 [label="param Reset(this) 156955"];
4853 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 156956"];
4854 [label="this.LexSyntaxToken() 156957"];
4855 [label="param LexSyntaxToken(this) 156958"];
4856 [label="_leadingTriviaCache.Clear(); 156959"];
4857 [label="TextWindow.Position 156960"];
4858 [label="get\n            {\n                return _basis + _offset;\n            } 156961"];
4859 [label="param LexSyntaxTrivia(bool afterFirstToken) 156962"];
4860 [label="param LexSyntaxTrivia(bool isTrailing) 156963"];
4861 [label="bool onlyWhitespaceOnLine = !isTrailing; 156964"];
4862 [label="TextWindow.Start(); 156965"];
4863 [label="this.Start(); 156966"];
4864 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 156967"];
4865 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 156968"];
4866 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 156969"];
4867 [label="return; 156970"];
4868 [label="this.Start(); 156971"];
4869 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156972"];
4870 [label="GetFullWidth(leading) 156973"];
4871 [label="param GetFullWidth(SyntaxListBuilder builder) 156974"];
4872 [label="int width = 0; 156975"];
4873 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 156976"];
4874 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 156977"];
4875 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 156978"];
4876 [label="return width; 156979"];
4877 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156980"];
4878 [label="this.GetErrors(GetFullWidth(leading)) 156981"];
4879 [label="param GetErrors(int leadingTriviaWidth) 156982"];
4880 [label="param GetErrors(this) 156983"];
4881 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 156984"];
4882 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 156985"];
4883 [label="return null; 156986"];
4884 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156987"];
4885 [label="param LexSyntaxTrivia(bool afterFirstToken) 156988"];
4886 [label="param Create(ref TokenInfo info) 156989"];
4887 [label="param Create(SyntaxDiagnosticInfo[] errors) 156990"];
4888 [label="param Create(this) 156991"];
4889 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 156992"];
4890 [label="SyntaxToken token; 156993"];
4891 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 156994"];
4892 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 156995"];
4893 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 156996"];
4894 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 156997"];
4895 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 156998"];
4896 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 156999"];
4897 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 157000"];
4898 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 157001"];
4899 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 157002"];
4900 [label="param Token(GreenNode leading) 157003"];
4901 [label="param Token(SyntaxKind kind) 157004"];
4902 [label="param Token(GreenNode trailing) 157005"];
4903 [label="return SyntaxToken.Create(kind, leading, trailing); 157006"];
4904 [label="return SyntaxToken.Create(kind, leading, trailing); 157007"];
4905 [label="return SyntaxToken.Create(kind, leading, trailing); 157008"];
4906 [label="SyntaxToken.Create(kind, leading, trailing) 157009"];
4907 [label="param Create(SyntaxKind kind) 157010"];
4908 [label="param Create(GreenNode leading) 157011"];
4909 [label="param Create(GreenNode trailing) 157012"];
4910 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 157013"];
4911 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 157014"];
4912 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 157015"];
4913 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 157016"];
4914 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 157017"];
4915 [label="return s_tokensWithNoTrivia[(int)kind].Value; 157018"];
4916 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 157019"];
4917 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 157020"];
4918 [label="return token; 157021"];
4919 [label="var token = this.LexSyntaxToken(); 157022"];
4920 [label="Debug.Assert(quickWidth == token.FullWidth); 157023"];
4921 [label="return token; 157024"];
4922 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 157025"];
4923 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 157026"];
4924 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 157027"];
4925 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 157028"];
4926 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 157029"];
4927 [label="return value; 157030"];
4928 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 157031"];
4929 [label="this.AddLexedToken(token); 157032"];
4930 [label="param AddLexedToken(SyntaxToken token) 157033"];
4931 [label="Debug.Assert(token != null); 157034"];
4932 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 157035"];
4933 [label="_lexedTokens[_tokenCount].Value = token; 157036"];
4934 [label="_lexedTokens[_tokenCount].Value 157037"];
4935 [label="get { return (SyntaxKind)this.RawKind; } 157038"];
4936 [label="return (SyntaxKind)this.RawKind; 157039"];
4937 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 157040"];
4938 [label="TextWindow.Start(); 157041"];
4939 [label="TextWindow.Width 157042"];
4940 [label="var quickWidth = TextWindow.Width; 157043"];
4941 [label="TextWindow.Position 157044"];
4942 [label="param LexSyntaxTrivia(bool afterFirstToken) 157045"];
4943 [label="param LexSyntaxTrivia(bool isTrailing) 157046"];
4944 [label="bool onlyWhitespaceOnLine = !isTrailing; 157047"];
4945 [label="this.Start(); 157048"];
4946 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 157049"];
4947 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 157050"];
4948 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 157051"];
4949 [label="return; 157052"];
4950 [label="this.Start(); 157053"];
4951 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 157054"];
4952 [label="param TryGetKeywordKind(out SyntaxKind kind) 157055"];
4953 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 157056"];
4954 [label="return SyntaxKind.None; 157057"];
4955 [label="param GetContextualKeywordKind(string text) 157058"];
4956 [label="switch (text)\n            {\n                case 'yield':\n                    return SyntaxKind.YieldKeyword;\n                case 'partial':\n                    return SyntaxKind.PartialKeyword;\n                case 'from':\n                    return SyntaxKind.FromKeyword;\n                case 'group':\n                    return SyntaxKind.GroupKeyword;\n                case 'join':\n                    return SyntaxKind.JoinKeyword;\n                case 'into':\n                    return SyntaxKind.IntoKeyword;\n                case 'let':\n                    return SyntaxKind.LetKeyword;\n                case 'by':\n                    return SyntaxKind.ByKeyword;\n                case 'where':\n                    return SyntaxKind.WhereKeyword;\n                case 'select':\n                    return SyntaxKind.SelectKeyword;\n                case 'get':\n                    return SyntaxKind.GetKeyword;\n                case 'set':\n                    return SyntaxKind.SetKeyword;\n                case 'add':\n                    return SyntaxKind.AddKeyword;\n                case 'remove':\n                    return SyntaxKind.RemoveKeyword;\n                case 'orderby':\n                    return SyntaxKind.OrderByKeyword;\n                case 'alias':\n                    return SyntaxKind.AliasKeyword;\n                case 'on':\n                    return SyntaxKind.OnKeyword;\n                case 'equals':\n                    return SyntaxKind.EqualsKeyword;\n                case 'ascending':\n                    return SyntaxKind.AscendingKeyword;\n                case 'descending':\n                    return SyntaxKind.DescendingKeyword;\n                case 'assembly':\n                    return SyntaxKind.AssemblyKeyword;\n                case 'module':\n                    return SyntaxKind.ModuleKeyword;\n                case 'type':\n                    return SyntaxKind.TypeKeyword;\n                case 'field':\n                    return SyntaxKind.FieldKeyword;\n                case 'method':\n                    return SyntaxKind.MethodKeyword;\n                case 'param':\n                    return SyntaxKind.ParamKeyword;\n                case 'property':\n                    return SyntaxKind.PropertyKeyword;\n                case 'typevar':\n                    return SyntaxKind.TypeVarKeyword;\n                case 'global':\n                    return SyntaxKind.GlobalKeyword;\n                case 'async':\n                    return SyntaxKind.AsyncKeyword;\n                case 'await':\n                    return SyntaxKind.AwaitKeyword;\n                case 'when':\n                    return SyntaxKind.WhenKeyword;\n                case 'nameof':\n                    return SyntaxKind.NameOfKeyword;\n                case '_':\n                    return SyntaxKind.UnderscoreToken;\n                case 'var':\n                    return SyntaxKind.VarKeyword;\n                case 'and':\n                    return SyntaxKind.AndKeyword;\n                case 'or':\n                    return SyntaxKind.OrKeyword;\n                case 'not':\n                    return SyntaxKind.NotKeyword;\n                case 'data':\n                    return SyntaxKind.DataKeyword;\n                case 'with':\n                    return SyntaxKind.WithKeyword;\n                case 'init':\n                    return SyntaxKind.InitKeyword;\n                case 'record':\n                    return SyntaxKind.RecordKeyword;\n                case 'managed':\n                    return SyntaxKind.ManagedKeyword;\n                case 'unmanaged':\n                    return SyntaxKind.UnmanagedKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 157059"];
4957 [label="return SyntaxKind.None; 157060"];
4958 [label="kind = _keywordKindMap.GetOrMakeValue(key); 157061"];
4959 [label="return kind != SyntaxKind.None; 157062"];
4960 [label="info.Kind 157063"];
4961 [label="info.ContextualKind 157064"];
4962 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 157065"];
4963 [label="this.ScanSyntaxToken(ref tokenInfo); 157066"];
4964 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157067"];
4965 [label="GetFullWidth(leading) 157068"];
4966 [label="param GetFullWidth(SyntaxListBuilder builder) 157069"];
4967 [label="int width = 0; 157070"];
4968 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 157071"];
4969 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 157072"];
4970 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 157073"];
4971 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 157074"];
4972 [label="return width; 157075"];
4973 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157076"];
4974 [label="this.GetErrors(GetFullWidth(leading)) 157077"];
4975 [label="param GetErrors(int leadingTriviaWidth) 157078"];
4976 [label="param GetErrors(this) 157079"];
4977 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 157080"];
4978 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 157081"];
4979 [label="return null; 157082"];
4980 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157083"];
4981 [label="param LexSyntaxTrivia(bool afterFirstToken) 157084"];
4982 [label="param LexSyntaxTrivia(bool isTrailing) 157085"];
4983 [label="bool onlyWhitespaceOnLine = !isTrailing; 157086"];
4984 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 157087"];
4985 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 157088"];
4986 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 157089"];
4987 [label="return; 157090"];
4988 [label="param Create(SyntaxDiagnosticInfo[] errors) 157091"];
4989 [label="param Create(this) 157092"];
4990 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 157093"];
4991 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 157094"];
4992 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 157095"];
4993 [label="SyntaxToken token; 157096"];
4994 [label="token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode); 157097"];
4995 [label="SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode) 157098"];
4996 [label="param Identifier(SyntaxKind contextualKind) 157099"];
4997 [label="param Identifier(GreenNode leading) 157100"];
4998 [label="param Identifier(string text) 157101"];
4999 [label="param Identifier(string valueText) 157102"];
5000 [label="param Identifier(GreenNode trailing) 157103"];
5001 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 157104"];
5002 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 157105"];
5003 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 157106"];
5004 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 157107"];
5005 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 157108"];
5006 [label="SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing) 157109"];
5007 [label="param Identifier(SyntaxKind contextualKind) 157110"];
5008 [label="param Identifier(GreenNode leading) 157111"];
5009 [label="param Identifier(string text) 157112"];
5010 [label="param Identifier(string valueText) 157113"];
5011 [label="param Identifier(GreenNode trailing) 157114"];
5012 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 157115"];
5013 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 157116"];
5014 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 157117"];
5015 [label="return Identifier(leading, text, trailing); 157118"];
5016 [label="return Identifier(leading, text, trailing); 157119"];
5017 [label="return Identifier(leading, text, trailing); 157120"];
5018 [label="Identifier(leading, text, trailing) 157121"];
5019 [label="param Identifier(GreenNode leading) 157122"];
5020 [label="param Identifier(string text) 157123"];
5021 [label="param Identifier(GreenNode trailing) 157124"];
5022 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 157125"];
5023 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 157126"];
5024 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 157127"];
5025 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 157128"];
5026 [label="return Identifier(text); 157129"];
5027 [label="Identifier(text) 157130"];
5028 [label="param Identifier(string text) 157131"];
5029 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifier), r => new SyntaxIdentifier(r)); 157132"];
5030 [label="return new SyntaxIdentifier(text); 157133"];
5031 [label="return new SyntaxIdentifier(text); 157134"];
5032 [label="new SyntaxIdentifier(text) 157135"];
5033 [label="param SyntaxIdentifier(string text) 157136"];
5034 [label="param SyntaxIdentifier(this) 157137"];
5035 [label="SyntaxKind.IdentifierToken 157138"];
5036 [label="text 157139"];
5037 [label="param SyntaxIdentifier(this) 157140"];
5038 [label="param SyntaxToken(SyntaxKind kind) 157141"];
5039 [label="param SyntaxToken(int fullWidth) 157142"];
5040 [label="param SyntaxToken(this) 157143"];
5041 [label="kind 157144"];
5042 [label="fullWidth 157145"];
5043 [label="param SyntaxToken(this) 157146"];
5044 [label="param CSharpSyntaxNode(SyntaxKind kind) 157147"];
5045 [label="param CSharpSyntaxNode(int fullWidth) 157148"];
5046 [label="param CSharpSyntaxNode(this) 157149"];
5047 [label="kind 157150"];
5048 [label="fullWidth 157151"];
5049 [label="param CSharpSyntaxNode(this) 157152"];
5050 [label="param CSharpSyntaxNode(this) 157153"];
5051 [label="GreenStats.NoteGreen(this); 157154"];
5052 [label="GreenStats.NoteGreen(this); 157155"];
5053 [label="this.flags |= NodeFlags.IsNotMissing; 157156"];
5054 [label="this.flags 157157"];
5055 [label="TextField 157158"];
5056 [label="this.TextField 157159"];
5057 [label="return Identifier(text); 157160"];
5058 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 157161"];
5059 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 157162"];
5060 [label="Debug.Assert(quickWidth == token.FullWidth); 157163"];
5061 [label="value = createTokenFunction(); 157164"];
5062 [label="this.AddLexedToken(token); 157165"];
5063 [label="param AddLexedToken(SyntaxToken token) 157166"];
5064 [label="Debug.Assert(token != null); 157167"];
5065 [label="_lexedTokens[_tokenCount].Value 157168"];
5066 [label="get { return (SyntaxKind)this.RawKind; } 157169"];
5067 [label="return (SyntaxKind)this.RawKind; 157170"];
5068 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 157171"];
5069 [label="TextWindow.Start(); 157172"];
5070 [label="TextWindow.Width 157173"];
5071 [label="var quickWidth = TextWindow.Width; 157174"];
5072 [label="param LexSyntaxTrivia(bool afterFirstToken) 157175"];
5073 [label="param LexSyntaxTrivia(bool isTrailing) 157176"];
5074 [label="bool onlyWhitespaceOnLine = !isTrailing; 157177"];
5075 [label="this.Start(); 157178"];
5076 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 157179"];
5077 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 157180"];
5078 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 157181"];
5079 [label="return; 157182"];
5080 [label="this.Start(); 157183"];
5081 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157184"];
5082 [label="GetFullWidth(leading) 157185"];
5083 [label="param GetFullWidth(SyntaxListBuilder builder) 157186"];
5084 [label="int width = 0; 157187"];
5085 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 157188"];
5086 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 157189"];
5087 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 157190"];
5088 [label="return width; 157191"];
5089 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157192"];
5090 [label="this.GetErrors(GetFullWidth(leading)) 157193"];
5091 [label="param GetErrors(int leadingTriviaWidth) 157194"];
5092 [label="param GetErrors(this) 157195"];
5093 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 157196"];
5094 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 157197"];
5095 [label="return null; 157198"];
5096 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157199"];
5097 [label="param AddTrivia(this) 157200"];
5098 [label="this.HasErrors 157201"];
5099 [label="get { return _errors != null; } 157202"];
5100 [label="return _errors != null; 157203"];
5101 [label="return _errors != null; 157204"];
5102 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 157205"];
5103 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 157206"];
5104 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 157207"];
5105 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 157208"];
5106 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 157209"];
5107 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 157210"];
5108 [label="return; 157211"];
5109 [label="param Create(SyntaxDiagnosticInfo[] errors) 157212"];
5110 [label="param Create(this) 157213"];
5111 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 157214"];
5112 [label="SyntaxToken token; 157215"];
5113 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 157216"];
5114 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 157217"];
5115 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 157218"];
5116 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 157219"];
5117 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 157220"];
5118 [label="if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 157221"];
5119 [label="return s_tokensWithSingleTrailingSpace[(int)kind].Value; 157222"];
5120 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 157223"];
5121 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 157224"];
5122 [label="Debug.Assert(quickWidth == token.FullWidth); 157225"];
5123 [label="this.AddLexedToken(token); 157226"];
5124 [label="param AddLexedToken(SyntaxToken token) 157227"];
5125 [label="Debug.Assert(token != null); 157228"];
5126 [label="_lexedTokens[_tokenCount].Value 157229"];
5127 [label="get { return (SyntaxKind)this.RawKind; } 157230"];
5128 [label="return (SyntaxKind)this.RawKind; 157231"];
5129 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 157232"];
5130 [label="TextWindow.Start(); 157233"];
5131 [label="var quickWidth = TextWindow.Width; 157234"];
5132 [label="param LexSyntaxTrivia(bool afterFirstToken) 157235"];
5133 [label="param LexSyntaxTrivia(bool isTrailing) 157236"];
5134 [label="bool onlyWhitespaceOnLine = !isTrailing; 157237"];
5135 [label="this.Start(); 157238"];
5136 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 157239"];
5137 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 157240"];
5138 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 157241"];
5139 [label="return; 157242"];
5140 [label="this.Start(); 157243"];
5141 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157244"];
5142 [label="GetFullWidth(leading) 157245"];
5143 [label="param GetFullWidth(SyntaxListBuilder builder) 157246"];
5144 [label="int width = 0; 157247"];
5145 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 157248"];
5146 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 157249"];
5147 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 157250"];
5148 [label="return width; 157251"];
5149 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157252"];
5150 [label="this.GetErrors(GetFullWidth(leading)) 157253"];
5151 [label="param GetErrors(int leadingTriviaWidth) 157254"];
5152 [label="param GetErrors(this) 157255"];
5153 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 157256"];
5154 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 157257"];
5155 [label="return null; 157258"];
5156 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157259"];
5157 [label="param AddTrivia(this) 157260"];
5158 [label="this.HasErrors 157261"];
5159 [label="get { return _errors != null; } 157262"];
5160 [label="return _errors != null; 157263"];
5161 [label="return _errors != null; 157264"];
5162 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 157265"];
5163 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 157266"];
5164 [label="param Create(SyntaxDiagnosticInfo[] errors) 157267"];
5165 [label="param Create(this) 157268"];
5166 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 157269"];
5167 [label="SyntaxToken token; 157270"];
5168 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 157271"];
5169 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 157272"];
5170 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 157273"];
5171 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 157274"];
5172 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 157275"];
5173 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 157276"];
5174 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 157277"];
5175 [label="Debug.Assert(quickWidth == token.FullWidth); 157278"];
5176 [label="param TryGetKeywordKind(out SyntaxKind kind) 157279"];
5177 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 157280"];
5178 [label="return SyntaxKind.CaseKeyword; 157281"];
5179 [label="if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 157282"];
5180 [label="SyntaxFacts.IsContextualKeyword(info.Kind) 157283"];
5181 [label="param IsContextualKeyword(SyntaxKind kind) 157284"];
5182 [label="switch (kind)\n            {\n                case SyntaxKind.YieldKeyword:\n                case SyntaxKind.PartialKeyword:\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.LetKeyword:\n                case SyntaxKind.ByKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                case SyntaxKind.AddKeyword:\n                case SyntaxKind.RemoveKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.AliasKeyword:\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.AssemblyKeyword:\n                case SyntaxKind.ModuleKeyword:\n                case SyntaxKind.TypeKeyword:\n                case SyntaxKind.GlobalKeyword:\n                case SyntaxKind.FieldKeyword:\n                case SyntaxKind.MethodKeyword:\n                case SyntaxKind.ParamKeyword:\n                case SyntaxKind.PropertyKeyword:\n                case SyntaxKind.TypeVarKeyword:\n                case SyntaxKind.NameOfKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.AwaitKeyword:\n                case SyntaxKind.WhenKeyword:\n                case SyntaxKind.UnderscoreToken:\n                case SyntaxKind.VarKeyword:\n                case SyntaxKind.OrKeyword:\n                case SyntaxKind.AndKeyword:\n                case SyntaxKind.NotKeyword:\n                case SyntaxKind.DataKeyword:\n                case SyntaxKind.WithKeyword:\n                case SyntaxKind.InitKeyword:\n                case SyntaxKind.RecordKeyword:\n                case SyntaxKind.ManagedKeyword:\n                case SyntaxKind.UnmanagedKeyword:\n                    return true;\n                default:\n                    return false;\n            } 157285"];
5183 [label="return false; 157286"];
5184 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 157287"];
5185 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 157288"];
5186 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 157289"];
5187 [label="return null; 157290"];
5188 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157291"];
5189 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 157292"];
5190 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 157293"];
5191 [label="param AddTrivia(this) 157294"];
5192 [label="this.HasErrors 157295"];
5193 [label="get { return _errors != null; } 157296"];
5194 [label="return _errors != null; 157297"];
5195 [label="return _errors != null; 157298"];
5196 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 157299"];
5197 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 157300"];
5198 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 157301"];
5199 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 157302"];
5200 [label="return; 157303"];
5201 [label="param Create(SyntaxDiagnosticInfo[] errors) 157304"];
5202 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 157305"];
5203 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 157306"];
5204 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 157307"];
5205 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 157308"];
5206 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 157309"];
5207 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 157310"];
5208 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 157311"];
5209 [label="Debug.Assert(quickWidth == token.FullWidth); 157312"];
5210 [label="this.AddLexedToken(token); 157313"];
5211 [label="param AddLexedToken(SyntaxToken token) 157314"];
5212 [label="Debug.Assert(token != null); 157315"];
5213 [label="_lexedTokens[_tokenCount].Value 157316"];
5214 [label="get { return (SyntaxKind)this.RawKind; } 157317"];
5215 [label="return (SyntaxKind)this.RawKind; 157318"];
5216 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 157319"];
5217 [label="TextWindow.Start(); 157320"];
5218 [label="var quickWidth = TextWindow.Width; 157321"];
5219 [label="param LexSyntaxTrivia(bool afterFirstToken) 157322"];
5220 [label="param LexSyntaxTrivia(bool isTrailing) 157323"];
5221 [label="bool onlyWhitespaceOnLine = !isTrailing; 157324"];
5222 [label="this.Start(); 157325"];
5223 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 157326"];
5224 [label="return; 157327"];
5225 [label="this.Start(); 157328"];
5226 [label="param TryGetKeywordKind(out SyntaxKind kind) 157329"];
5227 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 157330"];
5228 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 157331"];
5229 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157332"];
5230 [label="GetFullWidth(leading) 157333"];
5231 [label="param GetFullWidth(SyntaxListBuilder builder) 157334"];
5232 [label="int width = 0; 157335"];
5233 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 157336"];
5234 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 157337"];
5235 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 157338"];
5236 [label="return width; 157339"];
5237 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157340"];
5238 [label="this.GetErrors(GetFullWidth(leading)) 157341"];
5239 [label="param GetErrors(int leadingTriviaWidth) 157342"];
5240 [label="param GetErrors(this) 157343"];
5241 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 157344"];
5242 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 157345"];
5243 [label="return null; 157346"];
5244 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157347"];
5245 [label="param Create(SyntaxDiagnosticInfo[] errors) 157348"];
5246 [label="param Create(this) 157349"];
5247 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 157350"];
5248 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 157351"];
5249 [label="SyntaxToken token; 157352"];
5250 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 157353"];
5251 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 157354"];
5252 [label="Debug.Assert(quickWidth == token.FullWidth); 157355"];
5253 [label="param AddTrivia(this) 157356"];
5254 [label="get { return _errors != null; } 157357"];
5255 [label="return _errors != null; 157358"];
5256 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 157359"];
5257 [label="this.Position 157360"];
5258 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 157361"];
5259 [label="return false; 157362"];
5260 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 157363"];
5261 [label="return InvalidCharacter; 157364"];
5262 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 157365"];
5263 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 157366"];
5264 [label="SyntaxFacts.IsWhitespace(ch) 157367"];
5265 [label="param IsWhitespace(char ch) 157368"];
5266 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 157369"];
5267 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 157370"];
5268 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 157371"];
5269 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 157372"];
5270 [label="SyntaxFacts.IsNewLine(ch) 157373"];
5271 [label="param IsNewLine(char ch) 157374"];
5272 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 157375"];
5273 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 157376"];
5274 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 157377"];
5275 [label="return; 157378"];
5276 [label="return (SyntaxKind)this.RawKind; 157379"];
5277 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 157380"];
5278 [label="param LexSyntaxTrivia(bool afterFirstToken) 157381"];
5279 [label="param LexSyntaxTrivia(bool isTrailing) 157382"];
5280 [label="bool onlyWhitespaceOnLine = !isTrailing; 157383"];
5281 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 157384"];
5282 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 157385"];
5283 [label="return false; 157386"];
5284 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 157387"];
5285 [label="return InvalidCharacter; 157388"];
5286 [label="param IsReallyAtEnd(this) 157389"];
5287 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 157390"];
5288 [label="Position 157391"];
5289 [label="get\n            {\n                return _basis + _offset;\n            } 157392"];
5290 [label="return _basis + _offset; 157393"];
5291 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 157394"];
5292 [label="ConsList<Directive>.Empty 157395"];
5293 [label="new DirectiveStack(ConsList<Directive>.Empty) 157396"];
5294 [label="param DirectiveStack(ConsList<Directive> directives) 157397"];
5295 [label="param DirectiveStack(this) 157398"];
5296 [label="_directives 157399"];
5297 [label="Empty = new DirectiveStack(ConsList<Directive>.Empty) 157400"];
5298 [label="null 157401"];
5299 [label="new DirectiveStack(null) 157402"];
5300 [label="param DirectiveStack(ConsList<Directive> directives) 157403"];
5301 [label="param DirectiveStack(this) 157404"];
5302 [label="_directives 157405"];
5303 [label="Null = new DirectiveStack(null) 157406"];
5304 [label="param HasUnfinishedIf(this) 157407"];
5305 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 157408"];
5306 [label="GetPreviousIfElifElseOrRegion(_directives) 157409"];
5307 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 157410"];
5308 [label="var current = directives; 157411"];
5309 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 157412"];
5310 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 157413"];
5311 [label="return current; 157414"];
5312 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 157415"];
5313 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 157416"];
5314 [label="param HasUnfinishedRegion(this) 157417"];
5315 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 157418"];
5316 [label="GetPreviousIfElifElseOrRegion(_directives) 157419"];
5317 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 157420"];
5318 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 157421"];
5319 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 157422"];
5320 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 157423"];
5321 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 157424"];
5322 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157425"];
5323 [label="param GetFullWidth(SyntaxListBuilder builder) 157426"];
5324 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 157427"];
5325 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 157428"];
5326 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 157429"];
5327 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 157430"];
5328 [label="return null; 157431"];
5329 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157432"];
5330 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 157433"];
5331 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 157434"];
5332 [label="SyntaxFacts.IsWhitespace(ch) 157435"];
5333 [label="param IsWhitespace(char ch) 157436"];
5334 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 157437"];
5335 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 157438"];
5336 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 157439"];
5337 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 157440"];
5338 [label="SyntaxFacts.IsNewLine(ch) 157441"];
5339 [label="param IsNewLine(char ch) 157442"];
5340 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 157443"];
5341 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 157444"];
5342 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 157445"];
5343 [label="return; 157446"];
5344 [label="param Create(SyntaxDiagnosticInfo[] errors) 157447"];
5345 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 157448"];
5346 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 157449"];
5347 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 157450"];
5348 [label="param Token(GreenNode leading) 157451"];
5349 [label="param Token(SyntaxKind kind) 157452"];
5350 [label="param Token(GreenNode trailing) 157453"];
5351 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 157454"];
5352 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 157455"];
5353 [label="this.AddLexedToken(token); 157456"];
5354 [label="param AddLexedToken(SyntaxToken token) 157457"];
5355 [label="Debug.Assert(token != null); 157458"];
5356 [label="_lexedTokens[_tokenCount].Value 157459"];
5357 [label="get { return (SyntaxKind)this.RawKind; } 157460"];
5358 [label="return (SyntaxKind)this.RawKind; 157461"];
5359 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 157462"];
5360 [label="this.PreLex(); 157463"];
5361 [label="new SyntaxListPool() 157464"];
5362 [label="_pool = new SyntaxListPool() 157465"];
5363 [label="_syntaxFactoryContext 157466"];
5364 [label="_syntaxFactory 157467"];
5365 [label="_recursionDepth 157468"];
5366 [label="_termState 157469"];
5367 [label="_isInTry 157470"];
5368 [label="_checkedTopLevelStatementsFeatureAvailability 157471"];
5369 [label="_syntaxFactoryContext = new SyntaxFactoryContext(); 157472"];
5370 [label="_syntaxFactoryContext 157473"];
5371 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 157474"];
5372 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 157475"];
5373 [label="_syntaxFactory 157476"];
5374 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 157477"];
5375 [label="parser.ParseStatement() 157478"];
5376 [label="param ParseStatement(this) 157479"];
5377 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 157480"];
5378 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 157481"];
5379 [label="ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))) 157482"];
5380 [label="param ParseWithStackGuard(Func<TNode> parseFunc) 157483"];
5381 [label="param ParseWithStackGuard(Func<TNode> createEmptyNodeFunc) 157484"];
5382 [label="param ParseWithStackGuard(this) 157485"];
5383 [label="Debug.Assert(_recursionDepth == 0); 157486"];
5384 [label="Debug.Assert(_recursionDepth == 0); 157487"];
5385 [label="return parseFunc(); 157488"];
5386 [label="return parseFunc(); 157489"];
5387 [label="=> ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 157490"];
5388 [label="ParseAttributeDeclarations() 157491"];
5389 [label="param ParseAttributeDeclarations(this) 157492"];
5390 [label="var attributes = _pool.Allocate<AttributeListSyntax>(); 157493"];
5391 [label="var saveTerm = _termState; 157494"];
5392 [label="_termState |= TerminatorState.IsAttributeDeclarationTerminator; 157495"];
5393 [label="_termState 157496"];
5394 [label="this.IsPossibleAttributeDeclaration() 157497"];
5395 [label="param IsPossibleAttributeDeclaration(this) 157498"];
5396 [label="this.CurrentToken 157499"];
5397 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157500"];
5398 [label="this.FetchCurrentToken() 157501"];
5399 [label="param FetchCurrentToken(this) 157502"];
5400 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157503"];
5401 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 157504"];
5402 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 157505"];
5403 [label="return _lexedTokens[_tokenOffset]; 157506"];
5404 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157507"];
5405 [label="_currentToken 157508"];
5406 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 157509"];
5407 [label="this.CurrentToken.Kind 157510"];
5408 [label="get { return (SyntaxKind)this.RawKind; } 157511"];
5409 [label="return (SyntaxKind)this.RawKind; 157512"];
5410 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 157513"];
5411 [label="_termState 157514"];
5412 [label="return attributes.ToList(); 157515"];
5413 [label="_pool.Free(attributes); 157516"];
5414 [label="_pool.Free(attributes); 157517"];
5415 [label="false 157518"];
5416 [label="isGlobal: false 157519"];
5417 [label="ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 157520"];
5418 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 157521"];
5419 [label="param ParseStatementCore(bool isGlobal) 157522"];
5420 [label="param ParseStatementCore(this) 157523"];
5421 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 157524"];
5422 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 157525"];
5423 [label="canReuseStatement(attributes, isGlobal) 157526"];
5424 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 157527"];
5425 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 157528"];
5426 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 157529"];
5427 [label="this.IsIncrementalAndFactoryContextMatches 157530"];
5428 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 157531"];
5429 [label="base.IsIncremental 157532"];
5430 [label="get\n            {\n                return _isIncremental;\n            } 157533"];
5431 [label="return _isIncremental; 157534"];
5432 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 157535"];
5433 [label="return false; 157536"];
5434 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 157537"];
5435 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 157538"];
5436 [label="this.GetResetPoint() 157539"];
5437 [label="param GetResetPoint(this) 157540"];
5438 [label="base.GetResetPoint() 157541"];
5439 [label="param GetResetPoint(this) 157542"];
5440 [label="CurrentTokenPosition 157543"];
5441 [label="=> _firstToken + _tokenOffset 157544"];
5442 [label="_firstToken + _tokenOffset 157545"];
5443 [label="var pos = CurrentTokenPosition; 157546"];
5444 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 157547"];
5445 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 157548"];
5446 [label="_resetStart 157549"];
5447 [label="_resetCount 157550"];
5448 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 157551"];
5449 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 157552"];
5450 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 157553"];
5451 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 157554"];
5452 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 157555"];
5453 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 157556"];
5454 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 157557"];
5455 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 157558"];
5456 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 157559"];
5457 [label="param ResetPoint(TerminatorState terminatorState) 157560"];
5458 [label="param ResetPoint(bool isInTry) 157561"];
5459 [label="param ResetPoint(bool isInAsync) 157562"];
5460 [label="param ResetPoint(int queryDepth) 157563"];
5461 [label="param ResetPoint(this) 157564"];
5462 [label="this.BaseResetPoint 157565"];
5463 [label="this.TerminatorState 157566"];
5464 [label="this.IsInTry 157567"];
5465 [label="this.IsInAsync 157568"];
5466 [label="this.QueryDepth 157569"];
5467 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 157570"];
5468 [label="_recursionDepth 157571"];
5469 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 157572"];
5470 [label="StatementSyntax result; 157573"];
5471 [label="this.CurrentToken 157574"];
5472 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157575"];
5473 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157576"];
5474 [label="switch (this.CurrentToken.Kind)\n                {\n                    case SyntaxKind.FixedKeyword:\n                        return this.ParseFixedStatement(attributes);\n                    case SyntaxKind.BreakKeyword:\n                        return this.ParseBreakStatement(attributes);\n                    case SyntaxKind.ContinueKeyword:\n                        return this.ParseContinueStatement(attributes);\n                    case SyntaxKind.TryKeyword:\n                    case SyntaxKind.CatchKeyword:\n                    case SyntaxKind.FinallyKeyword:\n                        return this.ParseTryStatement(attributes);\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                        return this.ParseCheckedStatement(attributes);\n                    case SyntaxKind.DoKeyword:\n                        return this.ParseDoStatement(attributes);\n                    case SyntaxKind.ForKeyword:\n                        return this.ParseForOrForEachStatement(attributes);\n                    case SyntaxKind.ForEachKeyword:\n                        return this.ParseForEachStatement(attributes, awaitTokenOpt: null);\n                    case SyntaxKind.GotoKeyword:\n                        return this.ParseGotoStatement(attributes);\n                    case SyntaxKind.IfKeyword:\n                        return this.ParseIfStatement(attributes);\n                    case SyntaxKind.ElseKeyword:\n                        // Including 'else' keyword to handle 'else without if' error cases \n                        return this.ParseMisplacedElse(attributes);\n                    case SyntaxKind.LockKeyword:\n                        return this.ParseLockStatement(attributes);\n                    case SyntaxKind.ReturnKeyword:\n                        return this.ParseReturnStatement(attributes);\n                    case SyntaxKind.SwitchKeyword:\n                        return this.ParseSwitchStatement(attributes);\n                    case SyntaxKind.ThrowKeyword:\n                        return this.ParseThrowStatement(attributes);\n                    case SyntaxKind.UnsafeKeyword:\n                        result = TryParseStatementStartingWithUnsafe(attributes);\n                        if (result != null)\n                            return result;\n                        break;\n                    case SyntaxKind.UsingKeyword:\n                        return ParseStatementStartingWithUsing(attributes);\n                    case SyntaxKind.WhileKeyword:\n                        return this.ParseWhileStatement(attributes);\n                    case SyntaxKind.OpenBraceToken:\n                        return this.ParseBlock(attributes);\n                    case SyntaxKind.SemicolonToken:\n                        return _syntaxFactory.EmptyStatement(attributes, this.EatToken());\n                    case SyntaxKind.IdentifierToken:\n                        result = TryParseStatementStartingWithIdentifier(attributes, isGlobal);\n                        if (result != null)\n                            return result;\n                        break;\n                } 157577"];
5475 [label="this.CurrentToken.Kind 157578"];
5476 [label="get { return (SyntaxKind)this.RawKind; } 157579"];
5477 [label="return (SyntaxKind)this.RawKind; 157580"];
5478 [label="return this.ParseSwitchStatement(attributes); 157581"];
5479 [label="this.ParseSwitchStatement(attributes) 157582"];
5480 [label="param ParseSwitchStatement(SyntaxList<AttributeListSyntax> attributes) 157583"];
5481 [label="param ParseSwitchStatement(this) 157584"];
5482 [label="this.CurrentToken 157585"];
5483 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157586"];
5484 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.SwitchKeyword); 157587"];
5485 [label="this.CurrentToken.Kind 157588"];
5486 [label="get { return (SyntaxKind)this.RawKind; } 157589"];
5487 [label="var @switch = this.EatToken(SyntaxKind.SwitchKeyword); 157590"];
5488 [label="this.EatToken(SyntaxKind.SwitchKeyword) 157591"];
5489 [label="param EatToken(SyntaxKind kind) 157592"];
5490 [label="param EatToken(this) 157593"];
5491 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 157594"];
5492 [label="SyntaxFacts.IsAnyToken(kind) 157595"];
5493 [label="param IsAnyToken(SyntaxKind kind) 157596"];
5494 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 157597"];
5495 [label="return true; 157598"];
5496 [label="this.CurrentToken 157599"];
5497 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157600"];
5498 [label="var ct = this.CurrentToken; 157601"];
5499 [label="ct.Kind 157602"];
5500 [label="get { return (SyntaxKind)this.RawKind; } 157603"];
5501 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 157604"];
5502 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 157605"];
5503 [label="MoveToNextToken() 157606"];
5504 [label="param MoveToNextToken(this) 157607"];
5505 [label="_currentToken.GetTrailingTrivia() 157608"];
5506 [label="param GetTrailingTrivia(this) 157609"];
5507 [label="return this.TrailingField; 157610"];
5508 [label="_prevTokenTrailingTrivia = _currentToken.GetTrailingTrivia(); 157611"];
5509 [label="_prevTokenTrailingTrivia 157612"];
5510 [label="_currentToken = null; 157613"];
5511 [label="_currentToken 157614"];
5512 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157615"];
5513 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157616"];
5514 [label="_tokenOffset 157617"];
5515 [label="MoveToNextToken(); 157618"];
5516 [label="return ct; 157619"];
5517 [label="this.ParseExpressionCore() 157620"];
5518 [label="param ParseExpressionCore(this) 157621"];
5519 [label="return this.ParseSubExpression(Precedence.Expression); 157622"];
5520 [label="this.ParseSubExpression(Precedence.Expression) 157623"];
5521 [label="param ParseSubExpression(Precedence precedence) 157624"];
5522 [label="param ParseSubExpression(this) 157625"];
5523 [label="_recursionDepth 157626"];
5524 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 157627"];
5525 [label="var result = ParseSubExpressionCore(precedence); 157628"];
5526 [label="ParseSubExpressionCore(precedence) 157629"];
5527 [label="param ParseSubExpressionCore(Precedence precedence) 157630"];
5528 [label="param ParseSubExpressionCore(this) 157631"];
5529 [label="ExpressionSyntax leftOperand; 157632"];
5530 [label="Precedence newPrecedence = 0; 157633"];
5531 [label="this.CurrentToken 157634"];
5532 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157635"];
5533 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157636"];
5534 [label="return _lexedTokens[_tokenOffset]; 157637"];
5535 [label="var tk = this.CurrentToken.Kind; 157638"];
5536 [label="this.CurrentToken.Kind 157639"];
5537 [label="get { return (SyntaxKind)this.RawKind; } 157640"];
5538 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 157641"];
5539 [label="IsInvalidSubExpression(tk) 157642"];
5540 [label="param IsInvalidSubExpression(SyntaxKind kind) 157643"];
5541 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 157644"];
5542 [label="return false; 157645"];
5543 [label="if (IsExpectedPrefixUnaryOperator(tk))\n            {\n                var opKind = SyntaxFacts.GetPrefixUnaryExpression(tk);\n                newPrecedence = GetPrecedence(opKind);\n                var opToken = this.EatToken();\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.PrefixUnaryExpression(opKind, opToken, operand);\n            }\n            else if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 157646"];
5544 [label="IsExpectedPrefixUnaryOperator(tk) 157647"];
5545 [label="param IsExpectedPrefixUnaryOperator(SyntaxKind kind) 157648"];
5546 [label="return SyntaxFacts.IsPrefixUnaryExpression(kind) && kind != SyntaxKind.RefKeyword && kind != SyntaxKind.OutKeyword; 157649"];
5547 [label="SyntaxFacts.IsPrefixUnaryExpression(kind) 157650"];
5548 [label="param IsPrefixUnaryExpression(SyntaxKind token) 157651"];
5549 [label="return GetPrefixUnaryExpression(token) != SyntaxKind.None; 157652"];
5550 [label="GetPrefixUnaryExpression(token) 157653"];
5551 [label="param GetPrefixUnaryExpression(SyntaxKind token) 157654"];
5552 [label="switch (token)\n            {\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.UnaryPlusExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.UnaryMinusExpression;\n                case SyntaxKind.TildeToken:\n                    return SyntaxKind.BitwiseNotExpression;\n                case SyntaxKind.ExclamationToken:\n                    return SyntaxKind.LogicalNotExpression;\n                case SyntaxKind.PlusPlusToken:\n                    return SyntaxKind.PreIncrementExpression;\n                case SyntaxKind.MinusMinusToken:\n                    return SyntaxKind.PreDecrementExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.AddressOfExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.PointerIndirectionExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.IndexExpression;\n                default:\n                    return SyntaxKind.None;\n            } 157655"];
5553 [label="return SyntaxKind.None; 157656"];
5554 [label="if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 157657"];
5555 [label="IsAwaitExpression() 157658"];
5556 [label="param IsAwaitExpression(this) 157659"];
5557 [label="this.CurrentToken 157660"];
5558 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157661"];
5559 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 157662"];
5560 [label="this.CurrentToken.ContextualKind 157663"];
5561 [label="get\n            {\n                return this.Kind;\n            } 157664"];
5562 [label="this.Kind 157665"];
5563 [label="get { return (SyntaxKind)this.RawKind; } 157666"];
5564 [label="return this.Kind; 157667"];
5565 [label="return false; 157668"];
5566 [label="if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 157669"];
5567 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 157670"];
5568 [label="this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false) 157671"];
5569 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 157672"];
5570 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 157673"];
5571 [label="param IsQueryExpression(this) 157674"];
5572 [label="this.CurrentToken 157675"];
5573 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157676"];
5574 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 157677"];
5575 [label="this.CurrentToken.ContextualKind 157678"];
5576 [label="get\n            {\n                return this.Kind;\n            } 157679"];
5577 [label="this.Kind 157680"];
5578 [label="get { return (SyntaxKind)this.RawKind; } 157681"];
5579 [label="return this.Kind; 157682"];
5580 [label="return false; 157683"];
5581 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 157684"];
5582 [label="this.CurrentToken 157685"];
5583 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 157686"];
5584 [label="this.CurrentToken.ContextualKind 157687"];
5585 [label="get\n            {\n                return this.Kind;\n            } 157688"];
5586 [label="this.Kind 157689"];
5587 [label="get { return (SyntaxKind)this.RawKind; } 157690"];
5588 [label="return this.Kind; 157691"];
5589 [label="if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 157692"];
5590 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 157693"];
5591 [label="this.IsPossibleDeconstructionLeft(precedence) 157694"];
5592 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 157695"];
5593 [label="param IsPossibleDeconstructionLeft(this) 157696"];
5594 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 157697"];
5595 [label="this.CurrentToken 157698"];
5596 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157699"];
5597 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 157700"];
5598 [label="this.CurrentToken.IsIdentifierVar() 157701"];
5599 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 157702"];
5600 [label="node.ContextualKind 157703"];
5601 [label="get\n            {\n                return this.Kind;\n            } 157704"];
5602 [label="return node.ContextualKind == SyntaxKind.VarKeyword; 157705"];
5603 [label="this.CurrentToken 157706"];
5604 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157707"];
5605 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 157708"];
5606 [label="this.CurrentToken.Kind 157709"];
5607 [label="get { return (SyntaxKind)this.RawKind; } 157710"];
5608 [label="IsPredefinedType(this.CurrentToken.Kind) 157711"];
5609 [label="param IsPredefinedType(SyntaxKind keyword) 157712"];
5610 [label="return SyntaxFacts.IsPredefinedType(keyword); 157713"];
5611 [label="SyntaxFacts.IsPredefinedType(keyword) 157714"];
5612 [label="param IsPredefinedType(SyntaxKind kind) 157715"];
5613 [label="switch (kind)\n            {\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.VoidKeyword:\n                    return true;\n                default:\n                    return false;\n            } 157716"];
5614 [label="return false; 157717"];
5615 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 157718"];
5616 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 157719"];
5617 [label="return false; 157720"];
5618 [label="leftOperand = this.ParseTerm(precedence); 157721"];
5619 [label="this.ParseTerm(precedence) 157722"];
5620 [label="param ParseTerm(Precedence precedence) 157723"];
5621 [label="=> this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 157724"];
5622 [label="precedence 157725"];
5623 [label="ParseTermWithoutPostfix(precedence) 157726"];
5624 [label="param ParseTermWithoutPostfix(Precedence precedence) 157727"];
5625 [label="param ParseTermWithoutPostfix(this) 157728"];
5626 [label="this.CurrentToken 157729"];
5627 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157730"];
5628 [label="var tk = this.CurrentToken.Kind; 157731"];
5629 [label="this.CurrentToken.Kind 157732"];
5630 [label="get { return (SyntaxKind)this.RawKind; } 157733"];
5631 [label="switch (tk)\n            {\n                case SyntaxKind.TypeOfKeyword:\n                    return this.ParseTypeOfExpression();\n                case SyntaxKind.DefaultKeyword:\n                    return this.ParseDefaultExpression();\n                case SyntaxKind.SizeOfKeyword:\n                    return this.ParseSizeOfExpression();\n                case SyntaxKind.MakeRefKeyword:\n                    return this.ParseMakeRefExpression();\n                case SyntaxKind.RefTypeKeyword:\n                    return this.ParseRefTypeExpression();\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                    return this.ParseCheckedOrUncheckedExpression();\n                case SyntaxKind.RefValueKeyword:\n                    return this.ParseRefValueExpression();\n                case SyntaxKind.ColonColonToken:\n                    // misplaced ::\n                    // Calling ParseAliasQualifiedName will cause us to create a missing identifier node that then\n                    // properly consumes the :: and the reset of the alias name afterwards.\n                    return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return this.ParseLambdaExpression();\n                case SyntaxKind.StaticKeyword:\n                    if (this.IsPossibleAnonymousMethodExpression())\n                    {\n                        return this.ParseAnonymousMethodExpression();\n                    }\n                    else if (this.IsPossibleLambdaExpression(precedence))\n                    {\n                        return this.ParseLambdaExpression();\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.IdentifierToken:\n                    if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.ThisKeyword:\n                    return _syntaxFactory.ThisExpression(this.EatToken());\n                case SyntaxKind.BaseKeyword:\n                    return ParseBaseExpression();\n\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.FalseKeyword:\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                    return _syntaxFactory.LiteralExpression(SyntaxFacts.GetLiteralExpression(tk), this.EatToken());\n                case SyntaxKind.InterpolatedStringStartToken:\n                    throw new NotImplementedException(); // this should not occur because these tokens are produced and parsed immediately\n                case SyntaxKind.InterpolatedStringToken:\n                    return this.ParseInterpolatedStringToken();\n                case SyntaxKind.OpenParenToken:\n                    return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence);\n                case SyntaxKind.NewKeyword:\n                    return this.ParseNewExpression();\n                case SyntaxKind.StackAllocKeyword:\n                    return this.ParseStackAllocExpression();\n                case SyntaxKind.DelegateKeyword:\n                    return this.ParseAnonymousMethodExpression();\n                case SyntaxKind.RefKeyword:\n                    // ref is not expected to appear in this position.\n                    return this.AddError(ParsePossibleRefExpression(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                default:\n                    // check for intrinsic type followed by '.'\n                    if (IsPredefinedType(tk))\n                    {\n                        var expr = _syntaxFactory.PredefinedType(this.EatToken());\n\n                        if (this.CurrentToken.Kind != SyntaxKind.DotToken || tk == SyntaxKind.VoidKeyword)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n                    else\n                    {\n                        var expr = this.CreateMissingIdentifierName();\n\n                        if (tk == SyntaxKind.EndOfFileToken)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_ExpressionExpected);\n                        }\n                        else\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n            } 157734"];
5632 [label="return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence); 157735"];
5633 [label="this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence) 157736"];
5634 [label="param ParseCastOrParenExpressionOrLambdaOrTuple(Precedence precedence) 157737"];
5635 [label="param ParseCastOrParenExpressionOrLambdaOrTuple(this) 157738"];
5636 [label="this.CurrentToken 157739"];
5637 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157740"];
5638 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.OpenParenToken); 157741"];
5639 [label="this.CurrentToken.Kind 157742"];
5640 [label="get { return (SyntaxKind)this.RawKind; } 157743"];
5641 [label="this.GetResetPoint() 157744"];
5642 [label="param GetResetPoint(this) 157745"];
5643 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 157746"];
5644 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 157747"];
5645 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 157748"];
5646 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 157749"];
5647 [label="param ResetPoint(TerminatorState terminatorState) 157750"];
5648 [label="param ResetPoint(bool isInTry) 157751"];
5649 [label="param ResetPoint(bool isInAsync) 157752"];
5650 [label="param ResetPoint(int queryDepth) 157753"];
5651 [label="param ResetPoint(this) 157754"];
5652 [label="this.BaseResetPoint 157755"];
5653 [label="this.TerminatorState 157756"];
5654 [label="this.IsInTry 157757"];
5655 [label="this.IsInAsync 157758"];
5656 [label="this.QueryDepth 157759"];
5657 [label="var resetPoint = this.GetResetPoint(); 157760"];
5658 [label="if (ScanParenthesizedImplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 157761"];
5659 [label="ScanParenthesizedImplicitlyTypedLambda(precedence) 157762"];
5660 [label="param ScanParenthesizedImplicitlyTypedLambda(Precedence precedence) 157763"];
5661 [label="param ScanParenthesizedImplicitlyTypedLambda(this) 157764"];
5662 [label="if (!(precedence <= Precedence.Lambda))\n            {\n                return false;\n            } 157765"];
5663 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 157766"];
5664 [label="this.PeekToken(1) 157767"];
5665 [label="param PeekToken(int n) 157768"];
5666 [label="param PeekToken(this) 157769"];
5667 [label="Debug.Assert(n >= 0); 157770"];
5668 [label="Debug.Assert(n >= 0); 157771"];
5669 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157772"];
5670 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157773"];
5671 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157774"];
5672 [label="return _lexedTokens[_tokenOffset + n]; 157775"];
5673 [label="this.PeekToken(1).Kind 157776"];
5674 [label="get { return (SyntaxKind)this.RawKind; } 157777"];
5675 [label="this.IsInQuery 157778"];
5676 [label="get { return _syntaxFactoryContext.IsInQuery; } 157779"];
5677 [label="return _syntaxFactoryContext.IsInQuery; 157780"];
5678 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 157781"];
5679 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 157782"];
5680 [label="this.PeekToken(2) 157783"];
5681 [label="param PeekToken(int n) 157784"];
5682 [label="param PeekToken(this) 157785"];
5683 [label="Debug.Assert(n >= 0); 157786"];
5684 [label="Debug.Assert(n >= 0); 157787"];
5685 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157788"];
5686 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157789"];
5687 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157790"];
5688 [label="return _lexedTokens[_tokenOffset + n]; 157791"];
5689 [label="this.PeekToken(2).Kind 157792"];
5690 [label="get { return (SyntaxKind)this.RawKind; } 157793"];
5691 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 157794"];
5692 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 157795"];
5693 [label="this.PeekToken(1) 157796"];
5694 [label="param PeekToken(int n) 157797"];
5695 [label="param PeekToken(this) 157798"];
5696 [label="Debug.Assert(n >= 0); 157799"];
5697 [label="Debug.Assert(n >= 0); 157800"];
5698 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157801"];
5699 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157802"];
5700 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157803"];
5701 [label="return _lexedTokens[_tokenOffset + n]; 157804"];
5702 [label="IsTrueIdentifier(this.PeekToken(1)) 157805"];
5703 [label="param IsTrueIdentifier(SyntaxToken token) 157806"];
5704 [label="param IsTrueIdentifier(this) 157807"];
5705 [label="token.Kind 157808"];
5706 [label="get { return (SyntaxKind)this.RawKind; } 157809"];
5707 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 157810"];
5708 [label="this.IsInQuery 157811"];
5709 [label="get { return _syntaxFactoryContext.IsInQuery; } 157812"];
5710 [label="return _syntaxFactoryContext.IsInQuery; 157813"];
5711 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 157814"];
5712 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 157815"];
5713 [label="this.PeekToken(2) 157816"];
5714 [label="param PeekToken(int n) 157817"];
5715 [label="param PeekToken(this) 157818"];
5716 [label="Debug.Assert(n >= 0); 157819"];
5717 [label="Debug.Assert(n >= 0); 157820"];
5718 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157821"];
5719 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157822"];
5720 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157823"];
5721 [label="return _lexedTokens[_tokenOffset + n]; 157824"];
5722 [label="this.PeekToken(2).Kind 157825"];
5723 [label="get { return (SyntaxKind)this.RawKind; } 157826"];
5724 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 157827"];
5725 [label="this.PeekToken(3) 157828"];
5726 [label="param PeekToken(int n) 157829"];
5727 [label="param PeekToken(this) 157830"];
5728 [label="Debug.Assert(n >= 0); 157831"];
5729 [label="Debug.Assert(n >= 0); 157832"];
5730 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157833"];
5731 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157834"];
5732 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157835"];
5733 [label="return _lexedTokens[_tokenOffset + n]; 157836"];
5734 [label="this.PeekToken(3).Kind 157837"];
5735 [label="get { return (SyntaxKind)this.RawKind; } 157838"];
5736 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 157839"];
5737 [label="if (this.PeekToken(1).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(2).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 157840"];
5738 [label="this.PeekToken(1) 157841"];
5739 [label="param PeekToken(int n) 157842"];
5740 [label="param PeekToken(this) 157843"];
5741 [label="Debug.Assert(n >= 0); 157844"];
5742 [label="Debug.Assert(n >= 0); 157845"];
5743 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157846"];
5744 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157847"];
5745 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157848"];
5746 [label="return _lexedTokens[_tokenOffset + n]; 157849"];
5747 [label="this.PeekToken(1).Kind 157850"];
5748 [label="get { return (SyntaxKind)this.RawKind; } 157851"];
5749 [label="if (this.PeekToken(1).Kind == SyntaxKind.ParamsKeyword)\n            {\n                return true;\n            } 157852"];
5750 [label="this.PeekToken(1) 157853"];
5751 [label="param PeekToken(int n) 157854"];
5752 [label="param PeekToken(this) 157855"];
5753 [label="Debug.Assert(n >= 0); 157856"];
5754 [label="Debug.Assert(n >= 0); 157857"];
5755 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157858"];
5756 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157859"];
5757 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157860"];
5758 [label="return _lexedTokens[_tokenOffset + n]; 157861"];
5759 [label="this.PeekToken(1).Kind 157862"];
5760 [label="get { return (SyntaxKind)this.RawKind; } 157863"];
5761 [label="return false; 157864"];
5762 [label="if (ScanParenthesizedImplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 157865"];
5763 [label="if (this.ScanCast())\n                {\n                    if (!IsCurrentTokenQueryKeywordInQuery())\n                    {\n                        // Looks like a cast, so parse it as one.\n                        this.Reset(ref resetPoint);\n                        var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                        var type = this.ParseType();\n                        var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                        var expr = this.ParseSubExpression(Precedence.Cast);\n                        return _syntaxFactory.CastExpression(openParen, type, closeParen, expr);\n                    }\n                } 157866"];
5764 [label="this.ScanCast() 157867"];
5765 [label="param ScanCast(bool forPattern = false) 157868"];
5766 [label="param ScanCast(this) 157869"];
5767 [label="this.CurrentToken 157870"];
5768 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157871"];
5769 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157872"];
5770 [label="if (this.CurrentToken.Kind != SyntaxKind.OpenParenToken)\n            {\n                return false;\n            } 157873"];
5771 [label="this.CurrentToken.Kind 157874"];
5772 [label="get { return (SyntaxKind)this.RawKind; } 157875"];
5773 [label="this.EatToken() 157876"];
5774 [label="param EatToken(this) 157877"];
5775 [label="this.CurrentToken 157878"];
5776 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157879"];
5777 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157880"];
5778 [label="var ct = this.CurrentToken; 157881"];
5779 [label="MoveToNextToken() 157882"];
5780 [label="param MoveToNextToken(this) 157883"];
5781 [label="param GetTrailingTrivia(this) 157884"];
5782 [label="return null; 157885"];
5783 [label="_prevTokenTrailingTrivia 157886"];
5784 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157887"];
5785 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157888"];
5786 [label="_tokenOffset 157889"];
5787 [label="MoveToNextToken(); 157890"];
5788 [label="return ct; 157891"];
5789 [label="this.EatToken(); 157892"];
5790 [label="var type = this.ScanType(forPattern: forPattern); 157893"];
5791 [label="this.ScanType(forPattern: forPattern) 157894"];
5792 [label="param ScanType(bool forPattern = false) 157895"];
5793 [label="param ScanType(this) 157896"];
5794 [label="return ScanType(out _, forPattern); 157897"];
5795 [label="return ScanType(out _, forPattern); 157898"];
5796 [label="ScanType(out _, forPattern) 157899"];
5797 [label="param ScanType(out SyntaxToken lastTokenOfType) 157900"];
5798 [label="param ScanType(bool forPattern = false) 157901"];
5799 [label="param ScanType(this) 157902"];
5800 [label="forPattern 157903"];
5801 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 157904"];
5802 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 157905"];
5803 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 157906"];
5804 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 157907"];
5805 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157908"];
5806 [label="param PeekToken(int n) 157909"];
5807 [label="param PeekToken(this) 157910"];
5808 [label="Debug.Assert(n >= 0); 157911"];
5809 [label="Debug.Assert(n >= 0); 157912"];
5810 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157913"];
5811 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157914"];
5812 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157915"];
5813 [label="return _lexedTokens[_tokenOffset + n]; 157916"];
5814 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 157917"];
5815 [label="param ScanNamedTypePart(this) 157918"];
5816 [label="this.CurrentToken 157919"];
5817 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157920"];
5818 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157921"];
5819 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 157922"];
5820 [label="this.CurrentToken.Kind 157923"];
5821 [label="get { return (SyntaxKind)this.RawKind; } 157924"];
5822 [label="this.IsTrueIdentifier() 157925"];
5823 [label="param IsTrueIdentifier(this) 157926"];
5824 [label="this.CurrentToken 157927"];
5825 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157928"];
5826 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157929"];
5827 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 157930"];
5828 [label="this.CurrentToken.Kind 157931"];
5829 [label="get { return (SyntaxKind)this.RawKind; } 157932"];
5830 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 157933"];
5831 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 157934"];
5832 [label="this.CurrentToken 157935"];
5833 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157936"];
5834 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 157937"];
5835 [label="this.CurrentToken.ContextualKind 157938"];
5836 [label="get\n            {\n                return this.Kind;\n            } 157939"];
5837 [label="return false; 157940"];
5838 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157941"];
5839 [label="IsCurrentTokenQueryKeywordInQuery() 157942"];
5840 [label="param IsCurrentTokenQueryKeywordInQuery(this) 157943"];
5841 [label="this.IsInQuery 157944"];
5842 [label="get { return _syntaxFactoryContext.IsInQuery; } 157945"];
5843 [label="return _syntaxFactoryContext.IsInQuery; 157946"];
5844 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 157947"];
5845 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157948"];
5846 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157949"];
5847 [label="IsCurrentTokenWhereOfConstraintClause() 157950"];
5848 [label="param IsCurrentTokenWhereOfConstraintClause(this) 157951"];
5849 [label="this.CurrentToken 157952"];
5850 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157953"];
5851 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 157954"];
5852 [label="this.CurrentToken.ContextualKind 157955"];
5853 [label="get\n            {\n                return this.Kind;\n            } 157956"];
5854 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157957"];
5855 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157958"];
5856 [label="return true; 157959"];
5857 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 157960"];
5858 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 157961"];
5859 [label="this.EatToken() 157962"];
5860 [label="param EatToken(this) 157963"];
5861 [label="this.CurrentToken 157964"];
5862 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157965"];
5863 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157966"];
5864 [label="var ct = this.CurrentToken; 157967"];
5865 [label="MoveToNextToken() 157968"];
5866 [label="param GetTrailingTrivia(this) 157969"];
5867 [label="return null; 157970"];
5868 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157971"];
5869 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157972"];
5870 [label="_tokenOffset 157973"];
5871 [label="MoveToNextToken(); 157974"];
5872 [label="return ct; 157975"];
5873 [label="lastTokenOfType = this.EatToken(); 157976"];
5874 [label="this.CurrentToken 157977"];
5875 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157978"];
5876 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157979"];
5877 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 157980"];
5878 [label="return _lexedTokens[_tokenOffset]; 157981"];
5879 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                return this.ScanPossibleTypeArgumentList(ref lastTokenOfType, out _);\n            }\n            else\n            {\n                return ScanTypeFlags.NonGenericTypeOrExpression;\n            } 157982"];
5880 [label="this.CurrentToken.Kind 157983"];
5881 [label="get { return (SyntaxKind)this.RawKind; } 157984"];
5882 [label="return ScanTypeFlags.NonGenericTypeOrExpression; 157985"];
5883 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 157986"];
5884 [label="param IsDotOrColonColon(this) 157987"];
5885 [label="this.CurrentToken 157988"];
5886 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157989"];
5887 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157990"];
5888 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 157991"];
5889 [label="this.CurrentToken.Kind 157992"];
5890 [label="get { return (SyntaxKind)this.RawKind; } 157993"];
5891 [label="this.CurrentToken 157994"];
5892 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157995"];
5893 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157996"];
5894 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 157997"];
5895 [label="this.CurrentToken.Kind 157998"];
5896 [label="get { return (SyntaxKind)this.RawKind; } 157999"];
5897 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 158000"];
5898 [label="param IsMakingProgress(ref int lastTokenPosition) 158001"];
5899 [label="param IsMakingProgress(bool assertIfFalse = true) 158002"];
5900 [label="param IsMakingProgress(this) 158003"];
5901 [label="CurrentTokenPosition 158004"];
5902 [label="=> _firstToken + _tokenOffset 158005"];
5903 [label="_firstToken + _tokenOffset 158006"];
5904 [label="var pos = CurrentTokenPosition; 158007"];
5905 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 158008"];
5906 [label="lastTokenPosition = pos; 158009"];
5907 [label="return true; 158010"];
5908 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 158011"];
5909 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 158012"];
5910 [label="if (type == ScanTypeFlags.NotType)\n            {\n                return false;\n            } 158013"];
5911 [label="this.CurrentToken 158014"];
5912 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158015"];
5913 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158016"];
5914 [label="if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n            {\n                return false;\n            } 158017"];
5915 [label="this.CurrentToken.Kind 158018"];
5916 [label="get { return (SyntaxKind)this.RawKind; } 158019"];
5917 [label="this.EatToken() 158020"];
5918 [label="param EatToken(this) 158021"];
5919 [label="this.CurrentToken 158022"];
5920 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158023"];
5921 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158024"];
5922 [label="MoveToNextToken() 158025"];
5923 [label="param MoveToNextToken(this) 158026"];
5924 [label="param GetTrailingTrivia(this) 158027"];
5925 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158028"];
5926 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158029"];
5927 [label="_tokenOffset 158030"];
5928 [label="MoveToNextToken(); 158031"];
5929 [label="this.EatToken(); 158032"];
5930 [label="switch (type)\n            {\n                // If we have any of the following, we know it must be a cast:\n                // 1) (Goo*)bar;\n                // 2) (Goo?)bar;\n                // 3) '(int)bar' or '(int[])bar'\n                // 4) (G::Goo)bar\n                case ScanTypeFlags.PointerOrMultiplication:\n                case ScanTypeFlags.NullableType:\n                case ScanTypeFlags.MustBeType:\n                case ScanTypeFlags.AliasQualifiedName:\n                    // The thing between parens is unambiguously a type.\n                    // In a pattern, we need more lookahead to confirm it is a cast and not\n                    // a parenthesized type pattern.  In this case the tokens that\n                    // have both unary and binary operator forms may appear in their unary form\n                    // following a cast.\n                    return !forPattern || this.CurrentToken.Kind switch\n                    {\n                        SyntaxKind.PlusToken => true,\n                        SyntaxKind.MinusToken => true,\n                        SyntaxKind.AmpersandToken => true,\n                        SyntaxKind.AsteriskToken => true,\n                        SyntaxKind.DotDotToken => true,\n                        _ => CanFollowCast(this.CurrentToken.Kind)\n                    };\n\n                case ScanTypeFlags.GenericTypeOrMethod:\n                case ScanTypeFlags.GenericTypeOrExpression:\n                case ScanTypeFlags.NonGenericTypeOrExpression:\n                case ScanTypeFlags.TupleType:\n                    // check for ambiguous type or expression followed by disambiguating token.  i.e.\n                    //\n                    // '(A)b' is a cast.  But '(A)+b' is not a cast.  \n                    return CanFollowCast(this.CurrentToken.Kind);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(type);\n            } 158033"];
5931 [label="this.CurrentToken 158034"];
5932 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158035"];
5933 [label="return _lexedTokens[_tokenOffset]; 158036"];
5934 [label="return CanFollowCast(this.CurrentToken.Kind); 158037"];
5935 [label="this.CurrentToken.Kind 158038"];
5936 [label="get { return (SyntaxKind)this.RawKind; } 158039"];
5937 [label="CanFollowCast(this.CurrentToken.Kind) 158040"];
5938 [label="param CanFollowCast(SyntaxKind kind) 158041"];
5939 [label="switch (kind)\n            {\n                case SyntaxKind.AsKeyword:\n                case SyntaxKind.IsKeyword:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.EqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.QuestionToken:\n                case SyntaxKind.ColonToken:\n                case SyntaxKind.BarBarToken:\n                case SyntaxKind.AmpersandAmpersandToken:\n                case SyntaxKind.BarToken:\n                case SyntaxKind.CaretToken:\n                case SyntaxKind.AmpersandToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.LessThanLessThanToken:\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                case SyntaxKind.PlusToken:\n                case SyntaxKind.MinusToken:\n                case SyntaxKind.AsteriskToken:\n                case SyntaxKind.SlashToken:\n                case SyntaxKind.PercentToken:\n                case SyntaxKind.PlusPlusToken:\n                case SyntaxKind.MinusMinusToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.DotToken:\n                case SyntaxKind.MinusGreaterThanToken:\n                case SyntaxKind.QuestionQuestionToken:\n                case SyntaxKind.EndOfFileToken:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.EqualsGreaterThanToken:\n                case SyntaxKind.DotDotToken:\n                    return false;\n                default:\n                    return true;\n            } 158042"];
5940 [label="return false; 158043"];
5941 [label="this.Reset(ref resetPoint); 158044"];
5942 [label="this.Reset(ref resetPoint) 158045"];
5943 [label="param Reset(ref ResetPoint state) 158046"];
5944 [label="param Reset(this) 158047"];
5945 [label="_termState 158048"];
5946 [label="_isInTry 158049"];
5947 [label="_syntaxFactoryContext.IsInAsync 158050"];
5948 [label="_syntaxFactoryContext.QueryDepth 158051"];
5949 [label="base.Reset(ref state.BaseResetPoint); 158052"];
5950 [label="base.Reset(ref state.BaseResetPoint) 158053"];
5951 [label="param Reset(ref ResetPoint point) 158054"];
5952 [label="param Reset(this) 158055"];
5953 [label="var offset = point.Position - _firstToken; 158056"];
5954 [label="Debug.Assert(offset >= 0); 158057"];
5955 [label="Debug.Assert(offset >= 0); 158058"];
5956 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 158059"];
5957 [label="_mode 158060"];
5958 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 158061"];
5959 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 158062"];
5960 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 158063"];
5961 [label="_tokenOffset 158064"];
5962 [label="_currentToken = null; 158065"];
5963 [label="_currentToken 158066"];
5964 [label="_currentNode = default(BlendedNode); 158067"];
5965 [label="_currentNode 158068"];
5966 [label="_prevTokenTrailingTrivia 158069"];
5967 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 158070"];
5968 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 158071"];
5969 [label="base.Reset(ref state.BaseResetPoint); 158072"];
5970 [label="this.Reset(ref resetPoint); 158073"];
5971 [label="if (this.ScanExplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 158074"];
5972 [label="this.ScanExplicitlyTypedLambda(precedence) 158075"];
5973 [label="param ScanExplicitlyTypedLambda(Precedence precedence) 158076"];
5974 [label="param ScanExplicitlyTypedLambda(this) 158077"];
5975 [label="if (!(precedence <= Precedence.Lambda))\n            {\n                return false;\n            } 158078"];
5976 [label="this.GetResetPoint() 158079"];
5977 [label="param GetResetPoint(this) 158080"];
5978 [label="_firstToken + _tokenOffset 158081"];
5979 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 158082"];
5980 [label="_resetCount 158083"];
5981 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 158084"];
5982 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 158085"];
5983 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 158086"];
5984 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 158087"];
5985 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 158088"];
5986 [label="param ResetPoint(this) 158089"];
5987 [label="var resetPoint = this.GetResetPoint(); 158090"];
5988 [label="bool foundParameterModifier = false; 158091"];
5989 [label="while (true)\n                {\n                    // Advance past the open paren or comma.\n                    this.EatToken();\n\n                    // Eat 'out' or 'ref' for cases [3, 6]. Even though not allowed in a lambda,\n                    // we treat `params` similarly for better error recovery.\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.RefKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                            {\n                                this.EatToken();\n                            }\n                            break;\n                        case SyntaxKind.OutKeyword:\n                        case SyntaxKind.InKeyword:\n                        case SyntaxKind.ParamsKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            break;\n                    }\n\n                    if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        return foundParameterModifier;\n                    }\n\n                    // NOTE: advances CurrentToken\n                    if (this.ScanType() == ScanTypeFlags.NotType)\n                    {\n                        return false;\n                    }\n\n                    if (this.IsTrueIdentifier())\n                    {\n                        // eat the identifier\n                        this.EatToken();\n                    }\n\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.EndOfFileToken:\n                            return foundParameterModifier;\n\n                        case SyntaxKind.CommaToken:\n                            if (foundParameterModifier)\n                            {\n                                return true;\n                            }\n\n                            continue;\n\n                        case SyntaxKind.CloseParenToken:\n                            return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken;\n\n                        default:\n                            return false;\n                    }\n                } 158092"];
5990 [label="this.EatToken() 158093"];
5991 [label="param EatToken(this) 158094"];
5992 [label="this.CurrentToken 158095"];
5993 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158096"];
5994 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158097"];
5995 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 158098"];
5996 [label="MoveToNextToken() 158099"];
5997 [label="param MoveToNextToken(this) 158100"];
5998 [label="param GetTrailingTrivia(this) 158101"];
5999 [label="return null; 158102"];
6000 [label="_prevTokenTrailingTrivia 158103"];
6001 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158104"];
6002 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158105"];
6003 [label="_tokenOffset 158106"];
6004 [label="MoveToNextToken(); 158107"];
6005 [label="this.EatToken(); 158108"];
6006 [label="this.CurrentToken 158109"];
6007 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158110"];
6008 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158111"];
6009 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 158112"];
6010 [label="return _lexedTokens[_tokenOffset]; 158113"];
6011 [label="switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.RefKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                            {\n                                this.EatToken();\n                            }\n                            break;\n                        case SyntaxKind.OutKeyword:\n                        case SyntaxKind.InKeyword:\n                        case SyntaxKind.ParamsKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            break;\n                    } 158114"];
6012 [label="this.CurrentToken.Kind 158115"];
6013 [label="get { return (SyntaxKind)this.RawKind; } 158116"];
6014 [label="this.CurrentToken 158117"];
6015 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158118"];
6016 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158119"];
6017 [label="if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        return foundParameterModifier;\n                    } 158120"];
6018 [label="this.CurrentToken.Kind 158121"];
6019 [label="get { return (SyntaxKind)this.RawKind; } 158122"];
6020 [label="if (this.ScanType() == ScanTypeFlags.NotType)\n                    {\n                        return false;\n                    } 158123"];
6021 [label="this.ScanType() 158124"];
6022 [label="param ScanType(bool forPattern = false) 158125"];
6023 [label="param ScanType(this) 158126"];
6024 [label="return ScanType(out _, forPattern); 158127"];
6025 [label="return ScanType(out _, forPattern); 158128"];
6026 [label="ScanType(out _, forPattern) 158129"];
6027 [label="param ScanType(out SyntaxToken lastTokenOfType) 158130"];
6028 [label="param ScanType(bool forPattern = false) 158131"];
6029 [label="param ScanType(this) 158132"];
6030 [label="forPattern 158133"];
6031 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 158134"];
6032 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 158135"];
6033 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 158136"];
6034 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 158137"];
6035 [label="Debug.Assert(n >= 0); 158138"];
6036 [label="Debug.Assert(n >= 0); 158139"];
6037 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158140"];
6038 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 158141"];
6039 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 158142"];
6040 [label="this.CurrentToken 158143"];
6041 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158144"];
6042 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 158145"];
6043 [label="this.CurrentToken.Kind 158146"];
6044 [label="get { return (SyntaxKind)this.RawKind; } 158147"];
6045 [label="this.IsTrueIdentifier() 158148"];
6046 [label="param IsTrueIdentifier(this) 158149"];
6047 [label="this.CurrentToken 158150"];
6048 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158151"];
6049 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 158152"];
6050 [label="this.CurrentToken.Kind 158153"];
6051 [label="get { return (SyntaxKind)this.RawKind; } 158154"];
6052 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 158155"];
6053 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 158156"];
6054 [label="this.CurrentToken 158157"];
6055 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158158"];
6056 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 158159"];
6057 [label="this.CurrentToken.ContextualKind 158160"];
6058 [label="get\n            {\n                return this.Kind;\n            } 158161"];
6059 [label="return false; 158162"];
6060 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158163"];
6061 [label="IsCurrentTokenQueryKeywordInQuery() 158164"];
6062 [label="param IsCurrentTokenQueryKeywordInQuery(this) 158165"];
6063 [label="this.IsInQuery 158166"];
6064 [label="get { return _syntaxFactoryContext.IsInQuery; } 158167"];
6065 [label="return _syntaxFactoryContext.IsInQuery; 158168"];
6066 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 158169"];
6067 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158170"];
6068 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158171"];
6069 [label="IsCurrentTokenWhereOfConstraintClause() 158172"];
6070 [label="param IsCurrentTokenWhereOfConstraintClause(this) 158173"];
6071 [label="this.CurrentToken 158174"];
6072 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158175"];
6073 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 158176"];
6074 [label="this.CurrentToken.ContextualKind 158177"];
6075 [label="get\n            {\n                return this.Kind;\n            } 158178"];
6076 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158179"];
6077 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158180"];
6078 [label="return true; 158181"];
6079 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 158182"];
6080 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 158183"];
6081 [label="this.EatToken() 158184"];
6082 [label="this.CurrentToken 158185"];
6083 [label="MoveToNextToken() 158186"];
6084 [label="param GetTrailingTrivia(this) 158187"];
6085 [label="return null; 158188"];
6086 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158189"];
6087 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158190"];
6088 [label="MoveToNextToken(); 158191"];
6089 [label="this.CurrentToken 158192"];
6090 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158193"];
6091 [label="this.CurrentToken.Kind 158194"];
6092 [label="this.CurrentToken 158195"];
6093 [label="this.CurrentToken.Kind 158196"];
6094 [label="this.CurrentToken 158197"];
6095 [label="this.CurrentToken.Kind 158198"];
6096 [label="param IsMakingProgress(bool assertIfFalse = true) 158199"];
6097 [label="CurrentTokenPosition 158200"];
6098 [label="this.IsTrueIdentifier() 158201"];
6099 [label="param IsTrueIdentifier(this) 158202"];
6100 [label="this.CurrentToken 158203"];
6101 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158204"];
6102 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158205"];
6103 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 158206"];
6104 [label="this.CurrentToken.Kind 158207"];
6105 [label="get { return (SyntaxKind)this.RawKind; } 158208"];
6106 [label="return false; 158209"];
6107 [label="if (this.IsTrueIdentifier())\n                    {\n                        // eat the identifier\n                        this.EatToken();\n                    } 158210"];
6108 [label="this.CurrentToken 158211"];
6109 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158212"];
6110 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158213"];
6111 [label="switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.EndOfFileToken:\n                            return foundParameterModifier;\n\n                        case SyntaxKind.CommaToken:\n                            if (foundParameterModifier)\n                            {\n                                return true;\n                            }\n\n                            continue;\n\n                        case SyntaxKind.CloseParenToken:\n                            return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken;\n\n                        default:\n                            return false;\n                    } 158214"];
6112 [label="this.CurrentToken.Kind 158215"];
6113 [label="get { return (SyntaxKind)this.RawKind; } 158216"];
6114 [label="return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken; 158217"];
6115 [label="this.PeekToken(1) 158218"];
6116 [label="param PeekToken(int n) 158219"];
6117 [label="Debug.Assert(n >= 0); 158220"];
6118 [label="Debug.Assert(n >= 0); 158221"];
6119 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158222"];
6120 [label="this.PeekToken(1).Kind 158223"];
6121 [label="get { return (SyntaxKind)this.RawKind; } 158224"];
6122 [label="this.Reset(ref resetPoint); 158225"];
6123 [label="this.Reset(ref resetPoint) 158226"];
6124 [label="param Reset(ref ResetPoint state) 158227"];
6125 [label="Debug.Assert(offset >= 0); 158228"];
6126 [label="Debug.Assert(offset >= 0); 158229"];
6127 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 158230"];
6128 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 158231"];
6129 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 158232"];
6130 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 158233"];
6131 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 158234"];
6132 [label="this.Reset(ref resetPoint); 158235"];
6133 [label="this.Release(ref resetPoint); 158236"];
6134 [label="this.Release(ref resetPoint) 158237"];
6135 [label="param Release(ref ResetPoint state) 158238"];
6136 [label="param Release(this) 158239"];
6137 [label="base.Release(ref state.BaseResetPoint); 158240"];
6138 [label="base.Release(ref state.BaseResetPoint) 158241"];
6139 [label="param Release(ref ResetPoint point) 158242"];
6140 [label="param Release(this) 158243"];
6141 [label="Debug.Assert(_resetCount == point.ResetCount); 158244"];
6142 [label="_resetCount 158245"];
6143 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 158246"];
6144 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 158247"];
6145 [label="base.Release(ref state.BaseResetPoint); 158248"];
6146 [label="this.Release(ref resetPoint); 158249"];
6147 [label="if (this.ScanExplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 158250"];
6148 [label="this.Reset(ref resetPoint); 158251"];
6149 [label="this.Reset(ref resetPoint) 158252"];
6150 [label="param Reset(ref ResetPoint state) 158253"];
6151 [label="param Reset(this) 158254"];
6152 [label="_termState 158255"];
6153 [label="_isInTry 158256"];
6154 [label="_syntaxFactoryContext.IsInAsync 158257"];
6155 [label="_syntaxFactoryContext.QueryDepth 158258"];
6156 [label="base.Reset(ref state.BaseResetPoint); 158259"];
6157 [label="base.Reset(ref state.BaseResetPoint) 158260"];
6158 [label="param Reset(this) 158261"];
6159 [label="var offset = point.Position - _firstToken; 158262"];
6160 [label="Debug.Assert(offset >= 0); 158263"];
6161 [label="Debug.Assert(offset >= 0); 158264"];
6162 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 158265"];
6163 [label="_mode 158266"];
6164 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 158267"];
6165 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 158268"];
6166 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 158269"];
6167 [label="_currentToken = null; 158270"];
6168 [label="_currentToken 158271"];
6169 [label="_currentNode = default(BlendedNode); 158272"];
6170 [label="_currentNode 158273"];
6171 [label="_prevTokenTrailingTrivia 158274"];
6172 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 158275"];
6173 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 158276"];
6174 [label="base.Reset(ref state.BaseResetPoint); 158277"];
6175 [label="this.Reset(ref resetPoint); 158278"];
6176 [label="var openParen = this.EatToken(SyntaxKind.OpenParenToken); 158279"];
6177 [label="this.EatToken(SyntaxKind.OpenParenToken) 158280"];
6178 [label="param EatToken(SyntaxKind kind) 158281"];
6179 [label="param EatToken(this) 158282"];
6180 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 158283"];
6181 [label="SyntaxFacts.IsAnyToken(kind) 158284"];
6182 [label="param IsAnyToken(SyntaxKind kind) 158285"];
6183 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 158286"];
6184 [label="return true; 158287"];
6185 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158288"];
6186 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 158289"];
6187 [label="return _lexedTokens[_tokenOffset]; 158290"];
6188 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 158291"];
6189 [label="param GetTrailingTrivia(this) 158292"];
6190 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158293"];
6191 [label="MoveToNextToken(); 158294"];
6192 [label="return ct; 158295"];
6193 [label="var expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true); 158296"];
6194 [label="var expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true); 158297"];
6195 [label="this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true) 158298"];
6196 [label="param ParseExpressionOrDeclaration(ParseTypeMode mode) 158299"];
6197 [label="param ParseExpressionOrDeclaration(MessageID feature) 158300"];
6198 [label="param ParseExpressionOrDeclaration(bool permitTupleDesignation) 158301"];
6199 [label="param ParseExpressionOrDeclaration(this) 158302"];
6200 [label="return IsPossibleDeclarationExpression(mode, permitTupleDesignation)\n                ? this.ParseDeclarationExpression(mode, feature)\n                : this.ParseSubExpression(Precedence.Expression); 158303"];
6201 [label="return IsPossibleDeclarationExpression(mode, permitTupleDesignation)\n                ? this.ParseDeclarationExpression(mode, feature)\n                : this.ParseSubExpression(Precedence.Expression); 158304"];
6202 [label="IsPossibleDeclarationExpression(mode, permitTupleDesignation) 158305"];
6203 [label="param IsPossibleDeclarationExpression(ParseTypeMode mode) 158306"];
6204 [label="param IsPossibleDeclarationExpression(bool permitTupleDesignation) 158307"];
6205 [label="param IsPossibleDeclarationExpression(this) 158308"];
6206 [label="this.IsInAsync 158309"];
6207 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 158310"];
6208 [label="return _syntaxFactoryContext.IsInAsync; 158311"];
6209 [label="if (this.IsInAsync && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                // can't be a declaration expression.\n                return false;\n            } 158312"];
6210 [label="this.GetResetPoint() 158313"];
6211 [label="param GetResetPoint(this) 158314"];
6212 [label="_firstToken + _tokenOffset 158315"];
6213 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 158316"];
6214 [label="_resetCount 158317"];
6215 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 158318"];
6216 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 158319"];
6217 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 158320"];
6218 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 158321"];
6219 [label="param ResetPoint(this) 158322"];
6220 [label="var resetPoint = this.GetResetPoint(); 158323"];
6221 [label="IsVarType() 158324"];
6222 [label="param IsVarType(this) 158325"];
6223 [label="this.CurrentToken 158326"];
6224 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158327"];
6225 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158328"];
6226 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 158329"];
6227 [label="if (!this.CurrentToken.IsIdentifierVar())\n            {\n                return false;\n            } 158330"];
6228 [label="this.CurrentToken.IsIdentifierVar() 158331"];
6229 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 158332"];
6230 [label="return false; 158333"];
6231 [label="bool typeIsVar = IsVarType(); 158334"];
6232 [label="SyntaxToken lastTokenOfType; 158335"];
6233 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 158336"];
6234 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 158337"];
6235 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 158338"];
6236 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 158339"];
6237 [label="Debug.Assert(n >= 0); 158340"];
6238 [label="Debug.Assert(n >= 0); 158341"];
6239 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158342"];
6240 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 158343"];
6241 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 158344"];
6242 [label="this.CurrentToken 158345"];
6243 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158346"];
6244 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 158347"];
6245 [label="this.CurrentToken.Kind 158348"];
6246 [label="get { return (SyntaxKind)this.RawKind; } 158349"];
6247 [label="this.IsTrueIdentifier() 158350"];
6248 [label="param IsTrueIdentifier(this) 158351"];
6249 [label="this.CurrentToken 158352"];
6250 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158353"];
6251 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 158354"];
6252 [label="this.CurrentToken.Kind 158355"];
6253 [label="get { return (SyntaxKind)this.RawKind; } 158356"];
6254 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 158357"];
6255 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 158358"];
6256 [label="this.CurrentToken 158359"];
6257 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158360"];
6258 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 158361"];
6259 [label="this.CurrentToken.ContextualKind 158362"];
6260 [label="get\n            {\n                return this.Kind;\n            } 158363"];
6261 [label="return false; 158364"];
6262 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158365"];
6263 [label="IsCurrentTokenQueryKeywordInQuery() 158366"];
6264 [label="param IsCurrentTokenQueryKeywordInQuery(this) 158367"];
6265 [label="this.IsInQuery 158368"];
6266 [label="get { return _syntaxFactoryContext.IsInQuery; } 158369"];
6267 [label="return _syntaxFactoryContext.IsInQuery; 158370"];
6268 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 158371"];
6269 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158372"];
6270 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158373"];
6271 [label="IsCurrentTokenWhereOfConstraintClause() 158374"];
6272 [label="param IsCurrentTokenWhereOfConstraintClause(this) 158375"];
6273 [label="this.CurrentToken 158376"];
6274 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158377"];
6275 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 158378"];
6276 [label="this.CurrentToken.ContextualKind 158379"];
6277 [label="get\n            {\n                return this.Kind;\n            } 158380"];
6278 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158381"];
6279 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158382"];
6280 [label="return true; 158383"];
6281 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 158384"];
6282 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 158385"];
6283 [label="this.EatToken() 158386"];
6284 [label="this.CurrentToken 158387"];
6285 [label="MoveToNextToken() 158388"];
6286 [label="param GetTrailingTrivia(this) 158389"];
6287 [label="return null; 158390"];
6288 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158391"];
6289 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158392"];
6290 [label="MoveToNextToken(); 158393"];
6291 [label="this.CurrentToken 158394"];
6292 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158395"];
6293 [label="this.CurrentToken.Kind 158396"];
6294 [label="this.CurrentToken 158397"];
6295 [label="this.CurrentToken.Kind 158398"];
6296 [label="this.CurrentToken 158399"];
6297 [label="this.CurrentToken.Kind 158400"];
6298 [label="param IsMakingProgress(bool assertIfFalse = true) 158401"];
6299 [label="CurrentTokenPosition 158402"];
6300 [label="lastTokenOfType.Kind 158403"];
6301 [label="get { return (SyntaxKind)this.RawKind; } 158404"];
6302 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 158405"];
6303 [label="IsPredefinedType(lastTokenOfType.Kind) 158406"];
6304 [label="param IsPredefinedType(SyntaxKind keyword) 158407"];
6305 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 158408"];
6306 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 158409"];
6307 [label="ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))) 158410"];
6308 [label="param ScanDesignation(bool permitTuple) 158411"];
6309 [label="param ScanDesignation(this) 158412"];
6310 [label="this.CurrentToken 158413"];
6311 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158414"];
6312 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158415"];
6313 [label="switch (this.CurrentToken.Kind)\n            {\n                default:\n                    return false;\n                case SyntaxKind.IdentifierToken:\n                    bool result = this.IsTrueIdentifier();\n                    this.EatToken();\n                    return result;\n                case SyntaxKind.OpenParenToken:\n                    if (!permitTuple)\n                    {\n                        return false;\n                    }\n\n                    bool sawComma = false;\n                    while (true)\n                    {\n                        this.EatToken(); // consume the `(` or `,`\n                        if (!ScanDesignation(permitTuple: true))\n                        {\n                            return false;\n                        }\n                        switch (this.CurrentToken.Kind)\n                        {\n                            case SyntaxKind.CloseParenToken:\n                                this.EatToken();\n                                return sawComma;\n                            case SyntaxKind.CommaToken:\n                                sawComma = true;\n                                continue;\n                            default:\n                                return false;\n                        }\n                    }\n            } 158416"];
6314 [label="this.CurrentToken.Kind 158417"];
6315 [label="get { return (SyntaxKind)this.RawKind; } 158418"];
6316 [label="return false; 158419"];
6317 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 158420"];
6318 [label="return false; 158421"];
6319 [label="this.Reset(ref resetPoint); 158422"];
6320 [label="this.Reset(ref resetPoint) 158423"];
6321 [label="param Reset(ref ResetPoint state) 158424"];
6322 [label="Debug.Assert(offset >= 0); 158425"];
6323 [label="Debug.Assert(offset >= 0); 158426"];
6324 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 158427"];
6325 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 158428"];
6326 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 158429"];
6327 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 158430"];
6328 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 158431"];
6329 [label="this.Reset(ref resetPoint); 158432"];
6330 [label="this.Release(ref resetPoint); 158433"];
6331 [label="this.Release(ref resetPoint) 158434"];
6332 [label="param Release(ref ResetPoint state) 158435"];
6333 [label="base.Release(ref state.BaseResetPoint); 158436"];
6334 [label="param Release(ref ResetPoint point) 158437"];
6335 [label="Debug.Assert(_resetCount == point.ResetCount); 158438"];
6336 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 158439"];
6337 [label="base.Release(ref state.BaseResetPoint); 158440"];
6338 [label="this.Release(ref resetPoint); 158441"];
6339 [label="this.ParseSubExpression(Precedence.Expression) 158442"];
6340 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 158443"];
6341 [label="ExpressionSyntax leftOperand; 158444"];
6342 [label="Precedence newPrecedence = 0; 158445"];
6343 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158446"];
6344 [label="return _lexedTokens[_tokenOffset]; 158447"];
6345 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 158448"];
6346 [label="IsInvalidSubExpression(tk) 158449"];
6347 [label="param IsInvalidSubExpression(SyntaxKind kind) 158450"];
6348 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 158451"];
6349 [label="return false; 158452"];
6350 [label="param IsAwaitExpression(this) 158453"];
6351 [label="this.CurrentToken 158454"];
6352 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158455"];
6353 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 158456"];
6354 [label="this.CurrentToken.ContextualKind 158457"];
6355 [label="get\n            {\n                return this.Kind;\n            } 158458"];
6356 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 158459"];
6357 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 158460"];
6358 [label="param IsQueryExpression(this) 158461"];
6359 [label="this.CurrentToken 158462"];
6360 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158463"];
6361 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 158464"];
6362 [label="this.CurrentToken.ContextualKind 158465"];
6363 [label="get\n            {\n                return this.Kind;\n            } 158466"];
6364 [label="leftOperand = this.ParseTerm(precedence); 158467"];
6365 [label="param ParseTerm(Precedence precedence) 158468"];
6366 [label="precedence 158469"];
6367 [label="param ParseTermWithoutPostfix(Precedence precedence) 158470"];
6368 [label="this.IsTrueIdentifier() 158471"];
6369 [label="param IsTrueIdentifier(this) 158472"];
6370 [label="this.CurrentToken 158473"];
6371 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158474"];
6372 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 158475"];
6373 [label="this.CurrentToken.Kind 158476"];
6374 [label="get { return (SyntaxKind)this.RawKind; } 158477"];
6375 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 158478"];
6376 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 158479"];
6377 [label="this.CurrentToken 158480"];
6378 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158481"];
6379 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 158482"];
6380 [label="this.CurrentToken.ContextualKind 158483"];
6381 [label="get\n            {\n                return this.Kind;\n            } 158484"];
6382 [label="return false; 158485"];
6383 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158486"];
6384 [label="IsCurrentTokenQueryKeywordInQuery() 158487"];
6385 [label="param IsCurrentTokenQueryKeywordInQuery(this) 158488"];
6386 [label="this.IsInQuery 158489"];
6387 [label="get { return _syntaxFactoryContext.IsInQuery; } 158490"];
6388 [label="return _syntaxFactoryContext.IsInQuery; 158491"];
6389 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 158492"];
6390 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158493"];
6391 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158494"];
6392 [label="IsCurrentTokenWhereOfConstraintClause() 158495"];
6393 [label="param IsCurrentTokenWhereOfConstraintClause(this) 158496"];
6394 [label="this.CurrentToken 158497"];
6395 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158498"];
6396 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 158499"];
6397 [label="this.CurrentToken.ContextualKind 158500"];
6398 [label="get\n            {\n                return this.Kind;\n            } 158501"];
6399 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158502"];
6400 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158503"];
6401 [label="return true; 158504"];
6402 [label="if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    } 158505"];
6403 [label="this.IsPossibleAnonymousMethodExpression() 158506"];
6404 [label="param IsPossibleAnonymousMethodExpression(this) 158507"];
6405 [label="var tokenIndex = 0; 158508"];
6406 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 158509"];
6407 [label="this.PeekToken(tokenIndex) 158510"];
6408 [label="param PeekToken(int n) 158511"];
6409 [label="param PeekToken(this) 158512"];
6410 [label="Debug.Assert(n >= 0); 158513"];
6411 [label="Debug.Assert(n >= 0); 158514"];
6412 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158515"];
6413 [label="return _lexedTokens[_tokenOffset + n]; 158516"];
6414 [label="this.PeekToken(tokenIndex).Kind 158517"];
6415 [label="get { return (SyntaxKind)this.RawKind; } 158518"];
6416 [label="this.PeekToken(tokenIndex) 158519"];
6417 [label="param PeekToken(int n) 158520"];
6418 [label="param PeekToken(this) 158521"];
6419 [label="Debug.Assert(n >= 0); 158522"];
6420 [label="Debug.Assert(n >= 0); 158523"];
6421 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158524"];
6422 [label="return _lexedTokens[_tokenOffset + n]; 158525"];
6423 [label="this.PeekToken(tokenIndex).ContextualKind 158526"];
6424 [label="get\n            {\n                return this.Kind;\n            } 158527"];
6425 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 158528"];
6426 [label="return this.PeekToken(tokenIndex).Kind == SyntaxKind.DelegateKeyword; 158529"];
6427 [label="this.PeekToken(tokenIndex) 158530"];
6428 [label="param PeekToken(int n) 158531"];
6429 [label="param PeekToken(this) 158532"];
6430 [label="Debug.Assert(n >= 0); 158533"];
6431 [label="Debug.Assert(n >= 0); 158534"];
6432 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158535"];
6433 [label="return _lexedTokens[_tokenOffset + n]; 158536"];
6434 [label="this.PeekToken(tokenIndex).Kind 158537"];
6435 [label="get { return (SyntaxKind)this.RawKind; } 158538"];
6436 [label="if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 158539"];
6437 [label="if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 158540"];
6438 [label="this.IsPossibleLambdaExpression(precedence) 158541"];
6439 [label="param IsPossibleLambdaExpression(Precedence precedence) 158542"];
6440 [label="param IsPossibleLambdaExpression(this) 158543"];
6441 [label="this.CurrentToken 158544"];
6442 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158545"];
6443 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 158546"];
6444 [label="this.CurrentToken.Kind 158547"];
6445 [label="get { return (SyntaxKind)this.RawKind; } 158548"];
6446 [label="this.CurrentToken 158549"];
6447 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158550"];
6448 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 158551"];
6449 [label="this.IsTrueIdentifier(this.CurrentToken) 158552"];
6450 [label="param IsTrueIdentifier(SyntaxToken token) 158553"];
6451 [label="param IsTrueIdentifier(this) 158554"];
6452 [label="token.Kind 158555"];
6453 [label="get { return (SyntaxKind)this.RawKind; } 158556"];
6454 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 158557"];
6455 [label="this.IsInQuery 158558"];
6456 [label="get { return _syntaxFactoryContext.IsInQuery; } 158559"];
6457 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 158560"];
6458 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 158561"];
6459 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 158562"];
6460 [label="if (precedence > Precedence.Lambda)\n            {\n                return false;\n            } 158563"];
6461 [label="int peekIndex; 158564"];
6462 [label="bool seenStatic; 158565"];
6463 [label="this.CurrentToken 158566"];
6464 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158567"];
6465 [label="if (this.CurrentToken.Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 1;\n                seenStatic = true;\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 2;\n                seenStatic = true;\n            }\n            else\n            {\n                peekIndex = 0;\n                seenStatic = false;\n            } 158568"];
6466 [label="this.CurrentToken.Kind 158569"];
6467 [label="get { return (SyntaxKind)this.RawKind; } 158570"];
6468 [label="this.CurrentToken 158571"];
6469 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 2;\n                seenStatic = true;\n            }\n            else\n            {\n                peekIndex = 0;\n                seenStatic = false;\n            } 158572"];
6470 [label="this.CurrentToken.ContextualKind 158573"];
6471 [label="get\n            {\n                return this.Kind;\n            } 158574"];
6472 [label="peekIndex = 0; 158575"];
6473 [label="seenStatic = false; 158576"];
6474 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on => then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static =>`\n                // 2. `async static =>`\n\n                // This is an error case, but we have enough code in front of us to be certain\n                // the user was trying to write a static lambda.\n                return true;\n            } 158577"];
6475 [label="this.PeekToken(peekIndex) 158578"];
6476 [label="param PeekToken(int n) 158579"];
6477 [label="param PeekToken(this) 158580"];
6478 [label="Debug.Assert(n >= 0); 158581"];
6479 [label="Debug.Assert(n >= 0); 158582"];
6480 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158583"];
6481 [label="this.PeekToken(peekIndex).Kind 158584"];
6482 [label="get { return (SyntaxKind)this.RawKind; } 158585"];
6483 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 158586"];
6484 [label="this.PeekToken(peekIndex) 158587"];
6485 [label="param PeekToken(int n) 158588"];
6486 [label="param PeekToken(this) 158589"];
6487 [label="Debug.Assert(n >= 0); 158590"];
6488 [label="Debug.Assert(n >= 0); 158591"];
6489 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158592"];
6490 [label="this.PeekToken(peekIndex).Kind 158593"];
6491 [label="get { return (SyntaxKind)this.RawKind; } 158594"];
6492 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 158595"];
6493 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 158596"];
6494 [label="this.PeekToken(peekIndex + 1) 158597"];
6495 [label="param PeekToken(int n) 158598"];
6496 [label="param PeekToken(this) 158599"];
6497 [label="Debug.Assert(n >= 0); 158600"];
6498 [label="Debug.Assert(n >= 0); 158601"];
6499 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158602"];
6500 [label="this.PeekToken(peekIndex + 1).Kind 158603"];
6501 [label="get { return (SyntaxKind)this.RawKind; } 158604"];
6502 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 158605"];
6503 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.OpenParenToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on ( then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static (...\n                // 2. `async static (...\n                return true;\n            } 158606"];
6504 [label="this.PeekToken(peekIndex) 158607"];
6505 [label="param PeekToken(int n) 158608"];
6506 [label="param PeekToken(this) 158609"];
6507 [label="Debug.Assert(n >= 0); 158610"];
6508 [label="Debug.Assert(n >= 0); 158611"];
6509 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158612"];
6510 [label="this.PeekToken(peekIndex).Kind 158613"];
6511 [label="get { return (SyntaxKind)this.RawKind; } 158614"];
6512 [label="if (this.PeekToken(peekIndex).ContextualKind != SyntaxKind.AsyncKeyword)\n            {\n                return false;\n            } 158615"];
6513 [label="this.PeekToken(peekIndex) 158616"];
6514 [label="param PeekToken(int n) 158617"];
6515 [label="param PeekToken(this) 158618"];
6516 [label="Debug.Assert(n >= 0); 158619"];
6517 [label="Debug.Assert(n >= 0); 158620"];
6518 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158621"];
6519 [label="this.PeekToken(peekIndex).ContextualKind 158622"];
6520 [label="get\n            {\n                return this.Kind;\n            } 158623"];
6521 [label="return false; 158624"];
6522 [label="if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 158625"];
6523 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 158626"];
6524 [label="this.IsPossibleDeconstructionLeft(precedence) 158627"];
6525 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 158628"];
6526 [label="return this.ParseAliasQualifiedName(NameOptions.InExpression); 158629"];
6527 [label="this.ParseAliasQualifiedName(NameOptions.InExpression) 158630"];
6528 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 158631"];
6529 [label="param ParseAliasQualifiedName(this) 158632"];
6530 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 158633"];
6531 [label="this.ParseSimpleName(allowedParts) 158634"];
6532 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 158635"];
6533 [label="param ParseSimpleName(this) 158636"];
6534 [label="var id = this.ParseIdentifierName(); 158637"];
6535 [label="this.ParseIdentifierName() 158638"];
6536 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 158639"];
6537 [label="param ParseIdentifierName(this) 158640"];
6538 [label="this.IsIncrementalAndFactoryContextMatches 158641"];
6539 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 158642"];
6540 [label="base.IsIncremental 158643"];
6541 [label="get\n            {\n                return _isIncremental;\n            } 158644"];
6542 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 158645"];
6543 [label="return false; 158646"];
6544 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 158647"];
6545 [label="var tk = ParseIdentifierToken(code); 158648"];
6546 [label="ParseIdentifierToken(code) 158649"];
6547 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 158650"];
6548 [label="param ParseIdentifierToken(this) 158651"];
6549 [label="this.CurrentToken 158652"];
6550 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158653"];
6551 [label="var ctk = this.CurrentToken.Kind; 158654"];
6552 [label="this.CurrentToken.Kind 158655"];
6553 [label="get { return (SyntaxKind)this.RawKind; } 158656"];
6554 [label="if (ctk == SyntaxKind.IdentifierToken)\n            {\n                // Error tolerance for IntelliSense. Consider the following case: [EditorBrowsable( partial class Goo {\n                // } Because we're parsing an attribute argument we'll end up consuming the 'partial' identifier and\n                // we'll eventually end up in a pretty confused state.  Because of that it becomes very difficult to\n                // show the correct parameter help in this case.  So, when we see 'partial' we check if it's being used\n                // as an identifier or as a contextual keyword.  If it's the latter then we bail out.  See\n                // Bug: vswhidbey/542125\n                if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                }\n\n                SyntaxToken identifierToken = this.EatToken();\n\n                if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                }\n\n                return identifierToken;\n            }\n            else\n            {\n                var name = CreateMissingIdentifierToken();\n                name = this.AddError(name, code);\n                return name;\n            } 158657"];
6555 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 158658"];
6556 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 158659"];
6557 [label="this.CurrentToken 158660"];
6558 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158661"];
6559 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 158662"];
6560 [label="this.CurrentToken.ContextualKind 158663"];
6561 [label="get\n            {\n                return this.Kind;\n            } 158664"];
6562 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 158665"];
6563 [label="IsCurrentTokenQueryKeywordInQuery() 158666"];
6564 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 158667"];
6565 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 158668"];
6566 [label="this.EatToken() 158669"];
6567 [label="param GetTrailingTrivia(this) 158670"];
6568 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158671"];
6569 [label="MoveToNextToken(); 158672"];
6570 [label="SyntaxToken identifierToken = this.EatToken(); 158673"];
6571 [label="this.IsInAsync 158674"];
6572 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 158675"];
6573 [label="return _syntaxFactoryContext.IsInAsync; 158676"];
6574 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 158677"];
6575 [label="return identifierToken; 158678"];
6576 [label="var tk = ParseIdentifierToken(code); 158679"];
6577 [label="return SyntaxFactory.IdentifierName(tk); 158680"];
6578 [label="return SyntaxFactory.IdentifierName(tk); 158681"];
6579 [label="param CSharpSyntaxNode(SyntaxKind kind) 158682"];
6580 [label="param CSharpSyntaxNode(this) 158683"];
6581 [label="kind 158684"];
6582 [label="param CSharpSyntaxNode(this) 158685"];
6583 [label="param CSharpSyntaxNode(this) 158686"];
6584 [label="GreenStats.NoteGreen(this); 158687"];
6585 [label="GreenStats.NoteGreen(this); 158688"];
6586 [label="var id = this.ParseIdentifierName(); 158689"];
6587 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 158690"];
6588 [label="SimpleNameSyntax name = id; 158691"];
6589 [label="this.CurrentToken 158692"];
6590 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158693"];
6591 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158694"];
6592 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 158695"];
6593 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 158696"];
6594 [label="this.CurrentToken.Kind 158697"];
6595 [label="get { return (SyntaxKind)this.RawKind; } 158698"];
6596 [label="return name; 158699"];
6597 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 158700"];
6598 [label="this.CurrentToken 158701"];
6599 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158702"];
6600 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158703"];
6601 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 158704"];
6602 [label="this.CurrentToken.Kind 158705"];
6603 [label="get { return (SyntaxKind)this.RawKind; } 158706"];
6604 [label="return name; 158707"];
6605 [label="return this.ParseAliasQualifiedName(NameOptions.InExpression); 158708"];
6606 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 158709"];
6607 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 158710"];
6608 [label="return ParseExpressionContinued(leftOperand, precedence); 158711"];
6609 [label="return ParseExpressionContinued(leftOperand, precedence); 158712"];
6610 [label="ParseExpressionContinued(leftOperand, precedence) 158713"];
6611 [label="param ParseExpressionContinued(ExpressionSyntax leftOperand) 158714"];
6612 [label="param ParseExpressionContinued(Precedence precedence) 158715"];
6613 [label="param ParseExpressionContinued(this) 158716"];
6614 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 158717"];
6615 [label="this.CurrentToken 158718"];
6616 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158719"];
6617 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158720"];
6618 [label="var tk = this.CurrentToken.ContextualKind; 158721"];
6619 [label="this.CurrentToken.ContextualKind 158722"];
6620 [label="get\n            {\n                return this.Kind;\n            } 158723"];
6621 [label="bool isAssignmentOperator = false; 158724"];
6622 [label="SyntaxKind opKind; 158725"];
6623 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158726"];
6624 [label="IsExpectedBinaryOperator(tk) 158727"];
6625 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 158728"];
6626 [label="return SyntaxFacts.IsBinaryExpression(kind); 158729"];
6627 [label="SyntaxFacts.IsBinaryExpression(kind) 158730"];
6628 [label="param IsBinaryExpression(SyntaxKind token) 158731"];
6629 [label="return GetBinaryExpression(token) != SyntaxKind.None; 158732"];
6630 [label="GetBinaryExpression(token) 158733"];
6631 [label="param GetBinaryExpression(SyntaxKind token) 158734"];
6632 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 158735"];
6633 [label="return SyntaxKind.None; 158736"];
6634 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158737"];
6635 [label="IsExpectedAssignmentOperator(tk) 158738"];
6636 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 158739"];
6637 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 158740"];
6638 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 158741"];
6639 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 158742"];
6640 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 158743"];
6641 [label="return false; 158744"];
6642 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158745"];
6643 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158746"];
6644 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158747"];
6645 [label="CurrentToken 158748"];
6646 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158749"];
6647 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158750"];
6648 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 158751"];
6649 [label="CurrentToken.Kind 158752"];
6650 [label="get { return (SyntaxKind)this.RawKind; } 158753"];
6651 [label="return leftOperand; 158754"];
6652 [label="_ = GetPrecedence(result.Kind); 158755"];
6653 [label="result.Kind 158756"];
6654 [label="get { return (SyntaxKind)this.RawKind; } 158757"];
6655 [label="_ = GetPrecedence(result.Kind); 158758"];
6656 [label="GetPrecedence(result.Kind) 158759"];
6657 [label="param GetPrecedence(SyntaxKind op) 158760"];
6658 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 158761"];
6659 [label="return Precedence.Primary; 158762"];
6660 [label="_recursionDepth 158763"];
6661 [label="return result; 158764"];
6662 [label="this.CurrentToken 158765"];
6663 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158766"];
6664 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158767"];
6665 [label="if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        var firstArg = _syntaxFactory.Argument(nameColon: null, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 158768"];
6666 [label="this.CurrentToken.Kind 158769"];
6667 [label="get { return (SyntaxKind)this.RawKind; } 158770"];
6668 [label="expression.Kind 158771"];
6669 [label="get { return (SyntaxKind)this.RawKind; } 158772"];
6670 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 158773"];
6671 [label="this.CurrentToken 158774"];
6672 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158775"];
6673 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158776"];
6674 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 158777"];
6675 [label="this.CurrentToken.Kind 158778"];
6676 [label="get { return (SyntaxKind)this.RawKind; } 158779"];
6677 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 158780"];
6678 [label="var closeParen = this.EatToken(SyntaxKind.CloseParenToken); 158781"];
6679 [label="this.EatToken(SyntaxKind.CloseParenToken) 158782"];
6680 [label="param EatToken(SyntaxKind kind) 158783"];
6681 [label="param EatToken(this) 158784"];
6682 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 158785"];
6683 [label="SyntaxFacts.IsAnyToken(kind) 158786"];
6684 [label="param IsAnyToken(SyntaxKind kind) 158787"];
6685 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 158788"];
6686 [label="return true; 158789"];
6687 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158790"];
6688 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 158791"];
6689 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158792"];
6690 [label="MoveToNextToken(); 158793"];
6691 [label="return ct; 158794"];
6692 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 158795"];
6693 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 158796"];
6694 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 158797"];
6695 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 158798"];
6696 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 158799"];
6697 [label="param TryGetNode(int kind) 158800"];
6698 [label="param TryGetNode(GreenNode child1) 158801"];
6699 [label="param TryGetNode(GreenNode child2) 158802"];
6700 [label="param TryGetNode(GreenNode child3) 158803"];
6701 [label="param TryGetNode(SyntaxFactoryContext context) 158804"];
6702 [label="param TryGetNode(out int hash) 158805"];
6703 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 158806"];
6704 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 158807"];
6705 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 158808"];
6706 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 158809"];
6707 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 158810"];
6708 [label="GetNodeFlags(context) 158811"];
6709 [label="param GetNodeFlags(SyntaxFactoryContext context) 158812"];
6710 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 158813"];
6711 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 158814"];
6712 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 158815"];
6713 [label="return flags; 158816"];
6714 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 158817"];
6715 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 158818"];
6716 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 158819"];
6717 [label="param CSharpSyntaxNode(this) 158820"];
6718 [label="GreenStats.NoteGreen(this); 158821"];
6719 [label="param SetFactoryContext(SyntaxFactoryContext context) 158822"];
6720 [label="param SetFactoryContext(this) 158823"];
6721 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 158824"];
6722 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 158825"];
6723 [label="this.Release(ref resetPoint); 158826"];
6724 [label="this.Release(ref resetPoint) 158827"];
6725 [label="param Release(ref ResetPoint state) 158828"];
6726 [label="param Release(this) 158829"];
6727 [label="base.Release(ref state.BaseResetPoint); 158830"];
6728 [label="base.Release(ref state.BaseResetPoint) 158831"];
6729 [label="param Release(ref ResetPoint point) 158832"];
6730 [label="param Release(this) 158833"];
6731 [label="Debug.Assert(_resetCount == point.ResetCount); 158834"];
6732 [label="_resetCount 158835"];
6733 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 158836"];
6734 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 158837"];
6735 [label="base.Release(ref state.BaseResetPoint); 158838"];
6736 [label="this.Release(ref resetPoint); 158839"];
6737 [label="return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence); 158840"];
6738 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 158841"];
6739 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 158842"];
6740 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158843"];
6741 [label="return ParseExpressionContinued(leftOperand, precedence); 158844"];
6742 [label="ParseExpressionContinued(leftOperand, precedence) 158845"];
6743 [label="param ParseExpressionContinued(Precedence precedence) 158846"];
6744 [label="param ParseExpressionContinued(this) 158847"];
6745 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 158848"];
6746 [label="this.CurrentToken 158849"];
6747 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158850"];
6748 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158851"];
6749 [label="var tk = this.CurrentToken.ContextualKind; 158852"];
6750 [label="this.CurrentToken.ContextualKind 158853"];
6751 [label="get\n            {\n                return this.Kind;\n            } 158854"];
6752 [label="this.Kind 158855"];
6753 [label="bool isAssignmentOperator = false; 158856"];
6754 [label="SyntaxKind opKind; 158857"];
6755 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158858"];
6756 [label="IsExpectedBinaryOperator(tk) 158859"];
6757 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 158860"];
6758 [label="return SyntaxFacts.IsBinaryExpression(kind); 158861"];
6759 [label="SyntaxFacts.IsBinaryExpression(kind) 158862"];
6760 [label="param IsBinaryExpression(SyntaxKind token) 158863"];
6761 [label="return GetBinaryExpression(token) != SyntaxKind.None; 158864"];
6762 [label="GetBinaryExpression(token) 158865"];
6763 [label="param GetBinaryExpression(SyntaxKind token) 158866"];
6764 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 158867"];
6765 [label="return SyntaxKind.None; 158868"];
6766 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158869"];
6767 [label="IsExpectedAssignmentOperator(tk) 158870"];
6768 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 158871"];
6769 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 158872"];
6770 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 158873"];
6771 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 158874"];
6772 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 158875"];
6773 [label="return false; 158876"];
6774 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158877"];
6775 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158878"];
6776 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158879"];
6777 [label="CurrentToken 158880"];
6778 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158881"];
6779 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158882"];
6780 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 158883"];
6781 [label="CurrentToken.Kind 158884"];
6782 [label="get { return (SyntaxKind)this.RawKind; } 158885"];
6783 [label="_ = GetPrecedence(result.Kind); 158886"];
6784 [label="result.Kind 158887"];
6785 [label="get { return (SyntaxKind)this.RawKind; } 158888"];
6786 [label="_ = GetPrecedence(result.Kind); 158889"];
6787 [label="GetPrecedence(result.Kind) 158890"];
6788 [label="param GetPrecedence(SyntaxKind op) 158891"];
6789 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 158892"];
6790 [label="return Precedence.Primary; 158893"];
6791 [label="var expression = this.ParseExpressionCore(); 158894"];
6792 [label="SyntaxToken openParen; 158895"];
6793 [label="SyntaxToken closeParen; 158896"];
6794 [label="expression.Kind 158897"];
6795 [label="get { return (SyntaxKind)this.RawKind; } 158898"];
6796 [label="if (expression.Kind == SyntaxKind.ParenthesizedExpression)\n            {\n                var parenExpression = (ParenthesizedExpressionSyntax)expression;\n                openParen = parenExpression.OpenParenToken;\n                expression = parenExpression.Expression;\n                closeParen = parenExpression.CloseParenToken;\n\n                Debug.Assert(parenExpression.GetDiagnostics().Length == 0);\n            }\n            else if (expression.Kind == SyntaxKind.TupleExpression)\n            {\n                // As a special case, when a tuple literal is the governing expression of\n                // a switch statement we permit the switch statement's own parentheses to be omitted.\n                // LDM 2018-04-04.\n                openParen = closeParen = null;\n            }\n            else\n            {\n                // Some other expression has appeared without parens. Give a syntax error.\n                openParen = SyntaxFactory.MissingToken(SyntaxKind.OpenParenToken);\n                expression = this.AddError(expression, ErrorCode.ERR_SwitchGoverningExpressionRequiresParens);\n                closeParen = SyntaxFactory.MissingToken(SyntaxKind.CloseParenToken);\n            } 158899"];
6797 [label="var parenExpression = (ParenthesizedExpressionSyntax)expression; 158900"];
6798 [label="openParen = parenExpression.OpenParenToken; 158901"];
6799 [label="expression = parenExpression.Expression; 158902"];
6800 [label="closeParen = parenExpression.CloseParenToken; 158903"];
6801 [label="Debug.Assert(parenExpression.GetDiagnostics().Length == 0); 158904"];
6802 [label="Debug.Assert(parenExpression.GetDiagnostics().Length == 0); 158905"];
6803 [label="var openBrace = this.EatToken(SyntaxKind.OpenBraceToken); 158906"];
6804 [label="this.EatToken(SyntaxKind.OpenBraceToken) 158907"];
6805 [label="param EatToken(SyntaxKind kind) 158908"];
6806 [label="param EatToken(this) 158909"];
6807 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 158910"];
6808 [label="SyntaxFacts.IsAnyToken(kind) 158911"];
6809 [label="param IsAnyToken(SyntaxKind kind) 158912"];
6810 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 158913"];
6811 [label="return true; 158914"];
6812 [label="this.CurrentToken 158915"];
6813 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158916"];
6814 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158917"];
6815 [label="ct.Kind 158918"];
6816 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 158919"];
6817 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158920"];
6818 [label="MoveToNextToken(); 158921"];
6819 [label="var sections = _pool.Allocate<SwitchSectionSyntax>(); 158922"];
6820 [label="this.IsPossibleSwitchSection() 158923"];
6821 [label="param IsPossibleSwitchSection(this) 158924"];
6822 [label="this.CurrentToken 158925"];
6823 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158926"];
6824 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158927"];
6825 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 158928"];
6826 [label="return (this.CurrentToken.Kind == SyntaxKind.CaseKeyword) ||\n                   (this.CurrentToken.Kind == SyntaxKind.DefaultKeyword && this.PeekToken(1).Kind != SyntaxKind.OpenParenToken); 158929"];
6827 [label="this.CurrentToken.Kind 158930"];
6828 [label="get { return (SyntaxKind)this.RawKind; } 158931"];
6829 [label="while (this.IsPossibleSwitchSection())\n                {\n                    var swcase = this.ParseSwitchSection();\n                    sections.Add(swcase);\n                } 158932"];
6830 [label="this.ParseSwitchSection() 158933"];
6831 [label="param ParseSwitchSection(this) 158934"];
6832 [label="this.IsPossibleSwitchSection() 158935"];
6833 [label="param IsPossibleSwitchSection(this) 158936"];
6834 [label="Debug.Assert(this.IsPossibleSwitchSection()); 158937"];
6835 [label="var labels = _pool.Allocate<SwitchLabelSyntax>(); 158938"];
6836 [label="var statements = _pool.Allocate<StatementSyntax>(); 158939"];
6837 [label="SyntaxToken specifier; 158940"];
6838 [label="SwitchLabelSyntax label; 158941"];
6839 [label="SyntaxToken colon; 158942"];
6840 [label="this.CurrentToken 158943"];
6841 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158944"];
6842 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158945"];
6843 [label="if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = _syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    } 158946"];
6844 [label="this.CurrentToken.Kind 158947"];
6845 [label="get { return (SyntaxKind)this.RawKind; } 158948"];
6846 [label="ExpressionSyntax expression; 158949"];
6847 [label="this.EatToken() 158950"];
6848 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158951"];
6849 [label="MoveToNextToken(); 158952"];
6850 [label="specifier = this.EatToken(); 158953"];
6851 [label="this.CurrentToken 158954"];
6852 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158955"];
6853 [label="return _lexedTokens[_tokenOffset]; 158956"];
6854 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        } 158957"];
6855 [label="this.CurrentToken.Kind 158958"];
6856 [label="get { return (SyntaxKind)this.RawKind; } 158959"];
6857 [label="ParseExpressionOrPatternForSwitchStatement() 158960"];
6858 [label="param ParseExpressionOrPatternForSwitchStatement(this) 158961"];
6859 [label="ParseExpressionOrPatternForSwitchStatementCore() 158962"];
6860 [label="param ParseExpressionOrPatternForSwitchStatementCore(this) 158963"];
6861 [label="var pattern = ParsePattern(Precedence.Conditional, whenIsKeyword: true); 158964"];
6862 [label="var pattern = ParsePattern(Precedence.Conditional, whenIsKeyword: true); 158965"];
6863 [label="ParsePattern(Precedence.Conditional, whenIsKeyword: true) 158966"];
6864 [label="param ParsePattern(Precedence precedence) 158967"];
6865 [label="param ParsePattern(bool afterIs = false) 158968"];
6866 [label="param ParsePattern(bool whenIsKeyword = false) 158969"];
6867 [label="param ParsePattern(this) 158970"];
6868 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 158971"];
6869 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 158972"];
6870 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 158973"];
6871 [label="ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword) 158974"];
6872 [label="param ParseDisjunctivePattern(Precedence precedence) 158975"];
6873 [label="param ParseDisjunctivePattern(bool afterIs) 158976"];
6874 [label="param ParseDisjunctivePattern(bool whenIsKeyword) 158977"];
6875 [label="param ParseDisjunctivePattern(this) 158978"];
6876 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 158979"];
6877 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 158980"];
6878 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 158981"];
6879 [label="ParseConjunctivePattern(precedence, afterIs, whenIsKeyword) 158982"];
6880 [label="param ParseConjunctivePattern(Precedence precedence) 158983"];
6881 [label="param ParseConjunctivePattern(bool afterIs) 158984"];
6882 [label="param ParseConjunctivePattern(bool whenIsKeyword) 158985"];
6883 [label="param ParseConjunctivePattern(this) 158986"];
6884 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 158987"];
6885 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 158988"];
6886 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 158989"];
6887 [label="ParseNegatedPattern(precedence, afterIs, whenIsKeyword) 158990"];
6888 [label="param ParseNegatedPattern(Precedence precedence) 158991"];
6889 [label="param ParseNegatedPattern(bool afterIs) 158992"];
6890 [label="param ParseNegatedPattern(bool whenIsKeyword) 158993"];
6891 [label="param ParseNegatedPattern(this) 158994"];
6892 [label="this.CurrentToken 158995"];
6893 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158996"];
6894 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.NotKeyword)\n            {\n                var notToken = ConvertToKeyword(this.EatToken());\n                var pattern = ParseNegatedPattern(precedence, afterIs, whenIsKeyword);\n                var result = _syntaxFactory.UnaryPattern(notToken, pattern);\n                return CheckFeatureAvailability(result, MessageID.IDS_FeatureNotPattern);\n            }\n            else\n            {\n                return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword);\n            } 158997"];
6895 [label="this.CurrentToken.ContextualKind 158998"];
6896 [label="get\n            {\n                return this.Kind;\n            } 158999"];
6897 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 159000"];
6898 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 159001"];
6899 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 159002"];
6900 [label="ParsePrimaryPattern(precedence, afterIs, whenIsKeyword) 159003"];
6901 [label="param ParsePrimaryPattern(Precedence precedence) 159004"];
6902 [label="param ParsePrimaryPattern(bool afterIs) 159005"];
6903 [label="param ParsePrimaryPattern(bool whenIsKeyword) 159006"];
6904 [label="param ParsePrimaryPattern(this) 159007"];
6905 [label="this.CurrentToken 159008"];
6906 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159009"];
6907 [label="var tk = this.CurrentToken.Kind; 159010"];
6908 [label="this.CurrentToken.Kind 159011"];
6909 [label="get { return (SyntaxKind)this.RawKind; } 159012"];
6910 [label="switch (tk)\n            {\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return _syntaxFactory.ConstantPattern(this.ParseIdentifierName(ErrorCode.ERR_MissingPattern));\n            } 159013"];
6911 [label="CurrentToken 159014"];
6912 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159015"];
6913 [label="if (CurrentToken.ContextualKind == SyntaxKind.UnderscoreToken)\n            {\n                return _syntaxFactory.DiscardPattern(this.EatContextualToken(SyntaxKind.UnderscoreToken));\n            } 159016"];
6914 [label="CurrentToken.ContextualKind 159017"];
6915 [label="get\n            {\n                return this.Kind;\n            } 159018"];
6916 [label="CurrentToken 159019"];
6917 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159020"];
6918 [label="switch (CurrentToken.Kind)\n            {\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                    // this is a relational pattern.\n                    var relationalToken = this.EatToken();\n                    Debug.Assert(precedence < Precedence.Shift);\n                    var expression = this.ParseSubExpression(Precedence.Relational);\n                    var result = _syntaxFactory.RelationalPattern(relationalToken, expression);\n                    return CheckFeatureAvailability(result, MessageID.IDS_FeatureRelationalPattern);\n            } 159021"];
6919 [label="CurrentToken.Kind 159022"];
6920 [label="get { return (SyntaxKind)this.RawKind; } 159023"];
6921 [label="this.GetResetPoint() 159024"];
6922 [label="param GetResetPoint(this) 159025"];
6923 [label="var resetPoint = this.GetResetPoint(); 159026"];
6924 [label="TypeSyntax type = null; 159027"];
6925 [label="LooksLikeTypeOfPattern() 159028"];
6926 [label="param LooksLikeTypeOfPattern(this) 159029"];
6927 [label="CurrentToken 159030"];
6928 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159031"];
6929 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159032"];
6930 [label="var tk = CurrentToken.Kind; 159033"];
6931 [label="CurrentToken.Kind 159034"];
6932 [label="get { return (SyntaxKind)this.RawKind; } 159035"];
6933 [label="if (SyntaxFacts.IsPredefinedType(tk))\n            {\n                return true;\n            } 159036"];
6934 [label="SyntaxFacts.IsPredefinedType(tk) 159037"];
6935 [label="param IsPredefinedType(SyntaxKind kind) 159038"];
6936 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 159039"];
6937 [label="this.CurrentToken 159040"];
6938 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159041"];
6939 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159042"];
6940 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 159043"];
6941 [label="this.CurrentToken.ContextualKind 159044"];
6942 [label="get\n            {\n                return this.Kind;\n            } 159045"];
6943 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 159046"];
6944 [label="this.CurrentToken 159047"];
6945 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159048"];
6946 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159049"];
6947 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 159050"];
6948 [label="this.CurrentToken.ContextualKind 159051"];
6949 [label="get\n            {\n                return this.Kind;\n            } 159052"];
6950 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 159053"];
6951 [label="return true; 159054"];
6952 [label="if (LooksLikeTypeOfPattern())\n                {\n                    type = this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern);\n                    if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    }\n                } 159055"];
6953 [label="afterIs 159056"];
6954 [label="type = this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern); 159057"];
6955 [label="this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern) 159058"];
6956 [label="param ParseType(ParseTypeMode mode = ParseTypeMode.Normal) 159059"];
6957 [label="param ParseType(this) 159060"];
6958 [label="this.CurrentToken 159061"];
6959 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159062"];
6960 [label="if (this.CurrentToken.Kind == SyntaxKind.RefKeyword)\n            {\n                var refKeyword = this.EatToken();\n                refKeyword = this.CheckFeatureAvailability(refKeyword, MessageID.IDS_FeatureRefLocalsReturns);\n\n                SyntaxToken readonlyKeyword = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                {\n                    readonlyKeyword = this.EatToken();\n                    readonlyKeyword = this.CheckFeatureAvailability(readonlyKeyword, MessageID.IDS_FeatureReadOnlyReferences);\n                }\n\n                var type = ParseTypeCore(ParseTypeMode.AfterRef);\n                return _syntaxFactory.RefType(refKeyword, readonlyKeyword, type);\n            } 159063"];
6961 [label="this.CurrentToken.Kind 159064"];
6962 [label="get { return (SyntaxKind)this.RawKind; } 159065"];
6963 [label="return ParseTypeCore(mode); 159066"];
6964 [label="return ParseTypeCore(mode); 159067"];
6965 [label="return ParseTypeCore(mode); 159068"];
6966 [label="param ParseUnderlyingType(ParseTypeMode mode) 159069"];
6967 [label="param ParseUnderlyingType(NameOptions options = NameOptions.None) 159070"];
6968 [label="param ParseUnderlyingType(this) 159071"];
6969 [label="this.CurrentToken 159072"];
6970 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159073"];
6971 [label="if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, mode == ParseTypeMode.Parameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return _syntaxFactory.PredefinedType(token);\n            } 159074"];
6972 [label="this.CurrentToken.Kind 159075"];
6973 [label="get { return (SyntaxKind)this.RawKind; } 159076"];
6974 [label="IsPredefinedType(this.CurrentToken.Kind) 159077"];
6975 [label="param IsPredefinedType(SyntaxKind keyword) 159078"];
6976 [label="IsTrueIdentifier() 159079"];
6977 [label="param IsTrueIdentifier(this) 159080"];
6978 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 159081"];
6979 [label="this.CurrentToken 159082"];
6980 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159083"];
6981 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 159084"];
6982 [label="this.CurrentToken.ContextualKind 159085"];
6983 [label="get\n            {\n                return this.Kind;\n            } 159086"];
6984 [label="if (IsTrueIdentifier() || this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                return this.ParseQualifiedName(options);\n            } 159087"];
6985 [label="return this.ParseQualifiedName(options); 159088"];
6986 [label="this.ParseQualifiedName(options) 159089"];
6987 [label="param ParseQualifiedName(NameOptions options = NameOptions.None) 159090"];
6988 [label="param ParseQualifiedName(this) 159091"];
6989 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 159092"];
6990 [label="this.ParseAliasQualifiedName(options) 159093"];
6991 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 159094"];
6992 [label="param ParseAliasQualifiedName(this) 159095"];
6993 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 159096"];
6994 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 159097"];
6995 [label="this.IsIncrementalAndFactoryContextMatches 159098"];
6996 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 159099"];
6997 [label="base.IsIncremental 159100"];
6998 [label="get\n            {\n                return _isIncremental;\n            } 159101"];
6999 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 159102"];
7000 [label="return false; 159103"];
7001 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 159104"];
7002 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 159105"];
7003 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 159106"];
7004 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 159107"];
7005 [label="this.CurrentToken 159108"];
7006 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159109"];
7007 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 159110"];
7008 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 159111"];
7009 [label="IsCurrentTokenQueryKeywordInQuery() 159112"];
7010 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 159113"];
7011 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 159114"];
7012 [label="param GetTrailingTrivia(this) 159115"];
7013 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 159116"];
7014 [label="MoveToNextToken(); 159117"];
7015 [label="this.IsInAsync 159118"];
7016 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 159119"];
7017 [label="return _syntaxFactoryContext.IsInAsync; 159120"];
7018 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 159121"];
7019 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 159122"];
7020 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159123"];
7021 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 159124"];
7022 [label="this.CurrentToken.Kind 159125"];
7023 [label="get { return (SyntaxKind)this.RawKind; } 159126"];
7024 [label="this.CurrentToken 159127"];
7025 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159128"];
7026 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 159129"];
7027 [label="this.CurrentToken.Kind 159130"];
7028 [label="get { return (SyntaxKind)this.RawKind; } 159131"];
7029 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 159132"];
7030 [label="this.IsDotOrColonColon() 159133"];
7031 [label="param IsDotOrColonColon(this) 159134"];
7032 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159135"];
7033 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 159136"];
7034 [label="this.CurrentToken 159137"];
7035 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159138"];
7036 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159139"];
7037 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 159140"];
7038 [label="this.CurrentToken.Kind 159141"];
7039 [label="get { return (SyntaxKind)this.RawKind; } 159142"];
7040 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 159143"];
7041 [label="return name; 159144"];
7042 [label="return this.ParseQualifiedName(options); 159145"];
7043 [label="param IsMakingProgress(bool assertIfFalse = true) 159146"];
7044 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 159147"];
7045 [label="CanTokenFollowTypeInPattern(precedence) 159148"];
7046 [label="param CanTokenFollowTypeInPattern(Precedence precedence) 159149"];
7047 [label="param CanTokenFollowTypeInPattern(this) 159150"];
7048 [label="this.CurrentToken 159151"];
7049 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159152"];
7050 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159153"];
7051 [label="switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.CloseBraceToken:   // for efficiency, test some tokens that can follow a type pattern\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                    return true;\n                case SyntaxKind.DotToken:\n                    // int.MaxValue is an expression, not a type.\n                    return false;\n                case var kind:\n                    // If we find what looks like a continuation of an expression, it is not a type.\n                    return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence;\n            } 159154"];
7052 [label="this.CurrentToken.Kind 159155"];
7053 [label="get { return (SyntaxKind)this.RawKind; } 159156"];
7054 [label="return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence; 159157"];
7055 [label="SyntaxFacts.IsBinaryExpressionOperatorToken(kind) 159158"];
7056 [label="param IsBinaryExpressionOperatorToken(SyntaxKind token) 159159"];
7057 [label="return GetBinaryExpression(token) != SyntaxKind.None; 159160"];
7058 [label="GetBinaryExpression(token) 159161"];
7059 [label="param GetBinaryExpression(SyntaxKind token) 159162"];
7060 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 159163"];
7061 [label="return SyntaxKind.None; 159164"];
7062 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 159165"];
7063 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 159166"];
7064 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 159167"];
7065 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 159168"];
7066 [label="ParsePatternContinued(type, precedence, whenIsKeyword) 159169"];
7067 [label="param ParsePatternContinued(TypeSyntax type) 159170"];
7068 [label="param ParsePatternContinued(Precedence precedence) 159171"];
7069 [label="param ParsePatternContinued(bool whenIsKeyword) 159172"];
7070 [label="param ParsePatternContinued(this) 159173"];
7071 [label=".Kind 159174"];
7072 [label="get { return (SyntaxKind)this.RawKind; } 159175"];
7073 [label="if (type?.Kind == SyntaxKind.IdentifierName)\n            {\n                var typeIdentifier = (IdentifierNameSyntax)type;\n                var typeIdentifierToken = typeIdentifier.Identifier;\n                if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                }\n            } 159176"];
7074 [label="var typeIdentifier = (IdentifierNameSyntax)type; 159177"];
7075 [label="var typeIdentifierToken = typeIdentifier.Identifier; 159178"];
7076 [label="typeIdentifierToken.ContextualKind 159179"];
7077 [label="get\n            {\n                return this.Kind;\n            } 159180"];
7078 [label="if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                } 159181"];
7079 [label="this.CurrentToken 159182"];
7080 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159183"];
7081 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159184"];
7082 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken && (type != null || !looksLikeCast()))\n            {\n                // It is possible this is a parenthesized (constant) expression.\n                // We normalize later.\n                ParseSubpatternList(\n                    openToken: out SyntaxToken openParenToken,\n                    subPatterns: out SeparatedSyntaxList<SubpatternSyntax> subPatterns,\n                    closeToken: out SyntaxToken closeParenToken,\n                    openKind: SyntaxKind.OpenParenToken,\n                    closeKind: SyntaxKind.CloseParenToken);\n\n                parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause0);\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n\n                if (type == null &&\n                    propertyPatternClause0 == null &&\n                    designation0 == null &&\n                    subPatterns.Count == 1 &&\n                    subPatterns.SeparatorCount == 0 &&\n                    subPatterns[0].NameColon == null)\n                {\n                    var subpattern = subPatterns[0].Pattern;\n                    switch (subpattern)\n                    {\n                        case ConstantPatternSyntax cp:\n                            // There is an ambiguity between a positional pattern `(` pattern `)`\n                            // and a constant expression pattern that happens to be parenthesized.\n                            // Per 2017-11-20 LDM we treat such syntax as a parenthesized expression always.\n                            ExpressionSyntax expression = _syntaxFactory.ParenthesizedExpression(openParenToken, cp.Expression, closeParenToken);\n                            expression = ParseExpressionContinued(expression, precedence);\n                            return _syntaxFactory.ConstantPattern(expression);\n                        default:\n                            var parenthesizedPattern = _syntaxFactory.ParenthesizedPattern(openParenToken, subPatterns[0].Pattern, closeParenToken);\n                            return CheckFeatureAvailability(parenthesizedPattern, MessageID.IDS_FeatureParenthesizedPattern);\n                    }\n                }\n\n                var positionalPatternClause = _syntaxFactory.PositionalPatternClause(openParenToken, subPatterns, closeParenToken);\n                var result = _syntaxFactory.RecursivePattern(type, positionalPatternClause, propertyPatternClause0, designation0);\n                return result;\n            } 159185"];
7083 [label="this.CurrentToken.Kind 159186"];
7084 [label="get { return (SyntaxKind)this.RawKind; } 159187"];
7085 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 159188"];
7086 [label="parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause) 159189"];
7087 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 159190"];
7088 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 159191"];
7089 [label="propertyPatternClauseResult = null; 159192"];
7090 [label="this.CurrentToken 159193"];
7091 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159194"];
7092 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159195"];
7093 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                } 159196"];
7094 [label="this.CurrentToken.Kind 159197"];
7095 [label="get { return (SyntaxKind)this.RawKind; } 159198"];
7096 [label="return false; 159199"];
7097 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 159200"];
7098 [label="if (type != null)\n            {\n                if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                }\n            } 159201"];
7099 [label="if (type != null)\n            {\n                if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                }\n            } 159202"];
7100 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 159203"];
7101 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 159204"];
7102 [label="parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation) 159205"];
7103 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 159206"];
7104 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 159207"];
7105 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 159208"];
7106 [label="designationResult = null; 159209"];
7107 [label="this.IsTrueIdentifier() 159210"];
7108 [label="param IsTrueIdentifier(this) 159211"];
7109 [label="return false; 159212"];
7110 [label="if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                } 159213"];
7111 [label="return false; 159214"];
7112 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 159215"];
7113 [label="if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    } 159216"];
7114 [label="if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    } 159217"];
7115 [label="ConvertTypeToExpression(type, out var expression) 159218"];
7116 [label="param ConvertTypeToExpression(TypeSyntax type) 159219"];
7117 [label="param ConvertTypeToExpression(out ExpressionSyntax expr) 159220"];
7118 [label="param ConvertTypeToExpression(bool permitTypeArguments = false) 159221"];
7119 [label="param ConvertTypeToExpression(this) 159222"];
7120 [label="expr = null; 159223"];
7121 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 159224"];
7122 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 159225"];
7123 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 159226"];
7124 [label="expr = s; 159227"];
7125 [label="return true; 159228"];
7126 [label="expression = ParseExpressionContinued(expression, precedence); 159229"];
7127 [label="expression = ParseExpressionContinued(expression, precedence); 159230"];
7128 [label="ParseExpressionContinued(expression, precedence) 159231"];
7129 [label="param ParseExpressionContinued(ExpressionSyntax leftOperand) 159232"];
7130 [label="param ParseExpressionContinued(Precedence precedence) 159233"];
7131 [label="param ParseExpressionContinued(this) 159234"];
7132 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 159235"];
7133 [label="this.CurrentToken 159236"];
7134 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159237"];
7135 [label="var tk = this.CurrentToken.ContextualKind; 159238"];
7136 [label="this.CurrentToken.ContextualKind 159239"];
7137 [label="get\n            {\n                return this.Kind;\n            } 159240"];
7138 [label="bool isAssignmentOperator = false; 159241"];
7139 [label="SyntaxKind opKind; 159242"];
7140 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 159243"];
7141 [label="IsExpectedBinaryOperator(tk) 159244"];
7142 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 159245"];
7143 [label="return SyntaxFacts.IsBinaryExpression(kind); 159246"];
7144 [label="SyntaxFacts.IsBinaryExpression(kind) 159247"];
7145 [label="param IsBinaryExpression(SyntaxKind token) 159248"];
7146 [label="return GetBinaryExpression(token) != SyntaxKind.None; 159249"];
7147 [label="GetBinaryExpression(token) 159250"];
7148 [label="param GetBinaryExpression(SyntaxKind token) 159251"];
7149 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 159252"];
7150 [label="return SyntaxKind.None; 159253"];
7151 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 159254"];
7152 [label="IsExpectedAssignmentOperator(tk) 159255"];
7153 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 159256"];
7154 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 159257"];
7155 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 159258"];
7156 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 159259"];
7157 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 159260"];
7158 [label="return false; 159261"];
7159 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 159262"];
7160 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 159263"];
7161 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 159264"];
7162 [label="CurrentToken 159265"];
7163 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159266"];
7164 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 159267"];
7165 [label="CurrentToken.Kind 159268"];
7166 [label="get { return (SyntaxKind)this.RawKind; } 159269"];
7167 [label="return _syntaxFactory.ConstantPattern(expression); 159270"];
7168 [label="return _syntaxFactory.ConstantPattern(expression); 159271"];
7169 [label="return _syntaxFactory.ConstantPattern(expression); 159272"];
7170 [label="param TryGetNode(int kind) 159273"];
7171 [label="param TryGetNode(GreenNode child1) 159274"];
7172 [label="param TryGetNode(SyntaxFactoryContext context) 159275"];
7173 [label="param TryGetNode(out int hash) 159276"];
7174 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 159277"];
7175 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 159278"];
7176 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 159279"];
7177 [label="GetNodeFlags(context) 159280"];
7178 [label="param GetNodeFlags(SyntaxFactoryContext context) 159281"];
7179 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 159282"];
7180 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 159283"];
7181 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 159284"];
7182 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 159285"];
7183 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 159286"];
7184 [label="param SetFactoryContext(SyntaxFactoryContext context) 159287"];
7185 [label="param SetFactoryContext(this) 159288"];
7186 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 159289"];
7187 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 159290"];
7188 [label="if (p != null)\n                    return p; 159291"];
7189 [label="if (p != null)\n                    return p; 159292"];
7190 [label="return p; 159293"];
7191 [label="this.Release(ref resetPoint); 159294"];
7192 [label="this.Release(ref resetPoint) 159295"];
7193 [label="param Release(ref ResetPoint state) 159296"];
7194 [label="base.Release(ref state.BaseResetPoint); 159297"];
7195 [label="param Release(ref ResetPoint point) 159298"];
7196 [label="Debug.Assert(_resetCount == point.ResetCount); 159299"];
7197 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 159300"];
7198 [label="base.Release(ref state.BaseResetPoint); 159301"];
7199 [label="this.Release(ref resetPoint); 159302"];
7200 [label="this.CurrentToken 159303"];
7201 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159304"];
7202 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159305"];
7203 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.AndKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseNegatedPattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.AndPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureAndPattern);\n            } 159306"];
7204 [label="this.CurrentToken.ContextualKind 159307"];
7205 [label="get\n            {\n                return this.Kind;\n            } 159308"];
7206 [label="return result; 159309"];
7207 [label="this.CurrentToken 159310"];
7208 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159311"];
7209 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159312"];
7210 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.OrKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.OrPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureOrPattern);\n            } 159313"];
7211 [label="this.CurrentToken.ContextualKind 159314"];
7212 [label="get\n            {\n                return this.Kind;\n            } 159315"];
7213 [label="return result; 159316"];
7214 [label="pattern switch\n            {\n                ConstantPatternSyntax cp => cp.Expression,\n                TypePatternSyntax tp when ConvertTypeToExpression(tp.Type, out ExpressionSyntax expr) => expr,\n                DiscardPatternSyntax dp => _syntaxFactory.IdentifierName(ConvertToIdentifier(dp.UnderscoreToken)),\n                var p => p,\n            } 159317"];
7215 [label="return pattern switch\n            {\n                ConstantPatternSyntax cp => cp.Expression,\n                TypePatternSyntax tp when ConvertTypeToExpression(tp.Type, out ExpressionSyntax expr) => expr,\n                DiscardPatternSyntax dp => _syntaxFactory.IdentifierName(ConvertToIdentifier(dp.UnderscoreToken)),\n                var p => p,\n            }; 159318"];
7216 [label="return CheckRecursivePatternFeature(ParseExpressionOrPatternForSwitchStatementCore()); 159319"];
7217 [label="CheckRecursivePatternFeature(ParseExpressionOrPatternForSwitchStatementCore()) 159320"];
7218 [label="param CheckRecursivePatternFeature(CSharpSyntaxNode node) 159321"];
7219 [label="param CheckRecursivePatternFeature(this) 159322"];
7220 [label="node.Kind 159323"];
7221 [label="get { return (SyntaxKind)this.RawKind; } 159324"];
7222 [label="switch (node.Kind)\n            {\n                case SyntaxKind.RecursivePattern:\n                case SyntaxKind.DiscardPattern:\n                case SyntaxKind.VarPattern when ((VarPatternSyntax)node).Designation.Kind == SyntaxKind.ParenthesizedVariableDesignation:\n                    return this.CheckFeatureAvailability(node, MessageID.IDS_FeatureRecursivePatterns);\n                default:\n                    return node;\n            } 159325"];
7223 [label="return node; 159326"];
7224 [label="var node = ParseExpressionOrPatternForSwitchStatement(); 159327"];
7225 [label="this.CurrentToken 159328"];
7226 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159329"];
7227 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex); 159330"];
7228 [label="this.CurrentToken.ContextualKind 159331"];
7229 [label="get\n            {\n                return this.Kind;\n            } 159332"];
7230 [label="node.Kind 159333"];
7231 [label="get { return (SyntaxKind)this.RawKind; } 159334"];
7232 [label="if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement); 159335"];
7233 [label="if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            } 159336"];
7234 [label="colon = this.EatToken(SyntaxKind.ColonToken); 159337"];
7235 [label="this.EatToken(SyntaxKind.ColonToken) 159338"];
7236 [label="param EatToken(SyntaxKind kind) 159339"];
7237 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 159340"];
7238 [label="SyntaxFacts.IsAnyToken(kind) 159341"];
7239 [label="param IsAnyToken(SyntaxKind kind) 159342"];
7240 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 159343"];
7241 [label="return true; 159344"];
7242 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 159345"];
7243 [label="MoveToNextToken(); 159346"];
7244 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 159347"];
7245 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 159348"];
7246 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 159349"];
7247 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 159350"];
7248 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 159351"];
7249 [label="param TryGetNode(SyntaxFactoryContext context) 159352"];
7250 [label="param GetNodeFlags(SyntaxFactoryContext context) 159353"];
7251 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 159354"];
7252 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 159355"];
7253 [label="param SetFactoryContext(SyntaxFactoryContext context) 159356"];
7254 [label="param SetFactoryContext(this) 159357"];
7255 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 159358"];
7256 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 159359"];
7257 [label="labels.Add(label); 159360"];
7258 [label="IsPossibleSwitchSection() 159361"];
7259 [label="param IsPossibleSwitchSection(this) 159362"];
7260 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159363"];
7261 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 159364"];
7262 [label="this.CurrentToken 159365"];
7263 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159366"];
7264 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159367"];
7265 [label="this.CurrentToken.Kind 159368"];
7266 [label="get { return (SyntaxKind)this.RawKind; } 159369"];
7267 [label="do\n                {\n                    SyntaxToken specifier;\n                    SwitchLabelSyntax label;\n                    SyntaxToken colon;\n                    if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = _syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    }\n\n                    labels.Add(label);\n                }\n                while (IsPossibleSwitchSection()); 159370"];
7268 [label="CSharpSyntaxNode tmp = labels[labels.Count - 1]; 159371"];
7269 [label="CSharpSyntaxNode tmp = labels[labels.Count - 1]; 159372"];
7270 [label="CSharpSyntaxNode tmp = labels[labels.Count - 1]; 159373"];
7271 [label="this.ParseStatements(ref tmp, statements, true); 159374"];
7272 [label="this.ParseStatements(ref tmp, statements, true); 159375"];
7273 [label="this.ParseStatements(ref tmp, statements, true); 159376"];
7274 [label="this.ParseStatements(ref tmp, statements, true) 159377"];
7275 [label="param ParseStatements(ref CSharpSyntaxNode previousNode) 159378"];
7276 [label="param ParseStatements(SyntaxListBuilder<StatementSyntax> statements) 159379"];
7277 [label="param ParseStatements(bool stopOnSwitchSections) 159380"];
7278 [label="param ParseStatements(this) 159381"];
7279 [label="var saveTerm = _termState; 159382"];
7280 [label="_termState |= TerminatorState.IsPossibleStatementStartOrStop; 159383"];
7281 [label="_termState 159384"];
7282 [label="if (stopOnSwitchSections)\n            {\n                _termState |= TerminatorState.IsSwitchSectionStart;\n            } 159385"];
7283 [label="_termState |= TerminatorState.IsSwitchSectionStart; 159386"];
7284 [label="_termState 159387"];
7285 [label="int lastTokenPosition = -1; 159388"];
7286 [label="this.CurrentToken 159389"];
7287 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159390"];
7288 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159391"];
7289 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 159392"];
7290 [label="this.CurrentToken.Kind 159393"];
7291 [label="get { return (SyntaxKind)this.RawKind; } 159394"];
7292 [label="this.CurrentToken 159395"];
7293 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159396"];
7294 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159397"];
7295 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 159398"];
7296 [label="this.CurrentToken.Kind 159399"];
7297 [label="get { return (SyntaxKind)this.RawKind; } 159400"];
7298 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 159401"];
7299 [label="this.IsPossibleSwitchSection() 159402"];
7300 [label="param IsPossibleSwitchSection(this) 159403"];
7301 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159404"];
7302 [label="this.CurrentToken 159405"];
7303 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159406"];
7304 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159407"];
7305 [label="this.CurrentToken.Kind 159408"];
7306 [label="get { return (SyntaxKind)this.RawKind; } 159409"];
7307 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 159410"];
7308 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 159411"];
7309 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 159412"];
7310 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 159413"];
7311 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 159414"];
7312 [label="IsMakingProgress(ref lastTokenPosition) 159415"];
7313 [label="param IsMakingProgress(ref int lastTokenPosition) 159416"];
7314 [label="param IsMakingProgress(bool assertIfFalse = true) 159417"];
7315 [label="param IsMakingProgress(this) 159418"];
7316 [label="_firstToken + _tokenOffset 159419"];
7317 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 159420"];
7318 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 159421"];
7319 [label="if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                } 159422"];
7320 [label="this.IsPossibleStatement(acceptAccessibilityMods: true) 159423"];
7321 [label="param IsPossibleStatement(bool acceptAccessibilityMods) 159424"];
7322 [label="param IsPossibleStatement(this) 159425"];
7323 [label="this.CurrentToken 159426"];
7324 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159427"];
7325 [label="var tk = this.CurrentToken.Kind; 159428"];
7326 [label="this.CurrentToken.Kind 159429"];
7327 [label="get { return (SyntaxKind)this.RawKind; } 159430"];
7328 [label="switch (tk)\n            {\n                case SyntaxKind.FixedKeyword:\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.ThrowKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                case SyntaxKind.RefKeyword:\n                case SyntaxKind.ExternKeyword:\n                case SyntaxKind.OpenBracketToken:\n                    return true;\n\n                case SyntaxKind.IdentifierToken:\n                    return IsTrueIdentifier();\n\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.FinallyKeyword:\n                    return !_isInTry;\n\n                // Accessibility modifiers are not legal in a statement,\n                // but a common mistake for local functions. Parse to give a\n                // better error message.\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PrivateKeyword:\n                    return acceptAccessibilityMods;\n                default:\n                    return IsPredefinedType(tk)\n                        || IsPossibleExpression();\n            } 159431"];
7329 [label="IsTrueIdentifier() 159432"];
7330 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 159433"];
7331 [label="this.CurrentToken 159434"];
7332 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159435"];
7333 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 159436"];
7334 [label="return _syntaxFactoryContext.IsInQuery; 159437"];
7335 [label="return IsTrueIdentifier(); 159438"];
7336 [label="if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                } 159439"];
7337 [label="this.ParsePossiblyAttributedStatement() 159440"];
7338 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 159441"];
7339 [label="this.CurrentToken.Kind 159442"];
7340 [label="get { return (SyntaxKind)this.RawKind; } 159443"];
7341 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 159444"];
7342 [label="false 159445"];
7343 [label="isGlobal: false 159446"];
7344 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 159447"];
7345 [label="param ParseStatementCore(bool isGlobal) 159448"];
7346 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 159449"];
7347 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 159450"];
7348 [label="canReuseStatement(attributes, isGlobal) 159451"];
7349 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 159452"];
7350 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 159453"];
7351 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 159454"];
7352 [label="this.IsIncrementalAndFactoryContextMatches 159455"];
7353 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 159456"];
7354 [label="base.IsIncremental 159457"];
7355 [label="get\n            {\n                return _isIncremental;\n            } 159458"];
7356 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 159459"];
7357 [label="return false; 159460"];
7358 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 159461"];
7359 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 159462"];
7360 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 159463"];
7361 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 159464"];
7362 [label="StatementSyntax result; 159465"];
7363 [label="result = TryParseStatementStartingWithIdentifier(attributes, isGlobal); 159466"];
7364 [label="result = TryParseStatementStartingWithIdentifier(attributes, isGlobal); 159467"];
7365 [label="TryParseStatementStartingWithIdentifier(attributes, isGlobal) 159468"];
7366 [label="param TryParseStatementStartingWithIdentifier(SyntaxList<AttributeListSyntax> attributes) 159469"];
7367 [label="param TryParseStatementStartingWithIdentifier(bool isGlobal) 159470"];
7368 [label="param TryParseStatementStartingWithIdentifier(this) 159471"];
7369 [label="this.CurrentToken 159472"];
7370 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159473"];
7371 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.ForEachKeyword)\n            {\n                return this.ParseForEachStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncStreams));\n            }\n            else if (IsPossibleAwaitUsing())\n            {\n                if (PeekToken(2).Kind == SyntaxKind.OpenParenToken)\n                {\n                    // `await using Type ...` is handled below in ParseLocalDeclarationStatement\n                    return this.ParseUsingStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncUsing));\n                }\n            }\n            else if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 159474"];
7372 [label="this.CurrentToken.ContextualKind 159475"];
7373 [label="get\n            {\n                return this.Kind;\n            } 159476"];
7374 [label="IsPossibleAwaitUsing() 159477"];
7375 [label="=> CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 159478"];
7376 [label="CurrentToken 159479"];
7377 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159480"];
7378 [label="CurrentToken.ContextualKind 159481"];
7379 [label="get\n            {\n                return this.Kind;\n            } 159482"];
7380 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword 159483"];
7381 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 159484"];
7382 [label="if (IsPossibleAwaitUsing())\n            {\n                if (PeekToken(2).Kind == SyntaxKind.OpenParenToken)\n                {\n                    // `await using Type ...` is handled below in ParseLocalDeclarationStatement\n                    return this.ParseUsingStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncUsing));\n                }\n            }\n            else if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 159485"];
7383 [label="this.IsPossibleLabeledStatement() 159486"];
7384 [label="param IsPossibleLabeledStatement(this) 159487"];
7385 [label="return this.PeekToken(1).Kind == SyntaxKind.ColonToken && this.IsTrueIdentifier(); 159488"];
7386 [label="this.PeekToken(1) 159489"];
7387 [label="param PeekToken(int n) 159490"];
7388 [label="param PeekToken(this) 159491"];
7389 [label="Debug.Assert(n >= 0); 159492"];
7390 [label="Debug.Assert(n >= 0); 159493"];
7391 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159494"];
7392 [label="return _lexedTokens[_tokenOffset + n]; 159495"];
7393 [label="this.PeekToken(1).Kind 159496"];
7394 [label="get { return (SyntaxKind)this.RawKind; } 159497"];
7395 [label="if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 159498"];
7396 [label="this.IsPossibleYieldStatement() 159499"];
7397 [label="param IsPossibleYieldStatement(this) 159500"];
7398 [label="this.CurrentToken 159501"];
7399 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159502"];
7400 [label="return this.CurrentToken.ContextualKind == SyntaxKind.YieldKeyword && (this.PeekToken(1).Kind == SyntaxKind.ReturnKeyword || this.PeekToken(1).Kind == SyntaxKind.BreakKeyword); 159503"];
7401 [label="this.CurrentToken.ContextualKind 159504"];
7402 [label="get\n            {\n                return this.Kind;\n            } 159505"];
7403 [label="if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 159506"];
7404 [label="this.IsPossibleAwaitExpressionStatement() 159507"];
7405 [label="param IsPossibleAwaitExpressionStatement(this) 159508"];
7406 [label="this.IsScript 159509"];
7407 [label="get { return Options.Kind == SourceCodeKind.Script; } 159510"];
7408 [label="Options 159511"];
7409 [label="get { return this.lexer.Options; } 159512"];
7410 [label="this.lexer.Options 159513"];
7411 [label="get { return _options; } 159514"];
7412 [label="return _options; 159515"];
7413 [label="return this.lexer.Options; 159516"];
7414 [label="return Options.Kind == SourceCodeKind.Script; 159517"];
7415 [label="return (this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword; 159518"];
7416 [label="this.IsInAsync 159519"];
7417 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 159520"];
7418 [label="return _syntaxFactoryContext.IsInAsync; 159521"];
7419 [label="return (this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword; 159522"];
7420 [label="return (this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword; 159523"];
7421 [label="if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 159524"];
7422 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 159525"];
7423 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 159526"];
7424 [label="this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript) 159527"];
7425 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 159528"];
7426 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 159529"];
7427 [label="param IsQueryExpression(this) 159530"];
7428 [label="this.CurrentToken 159531"];
7429 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159532"];
7430 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 159533"];
7431 [label="this.CurrentToken.ContextualKind 159534"];
7432 [label="get\n            {\n                return this.Kind;\n            } 159535"];
7433 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 159536"];
7434 [label="return null; 159537"];
7435 [label="result = TryParseStatementStartingWithIdentifier(attributes, isGlobal); 159538"];
7436 [label="if (result != null)\n                            return result; 159539"];
7437 [label="if (result != null)\n                            return result; 159540"];
7438 [label="return ParseStatementCoreRest(attributes, isGlobal, ref resetPointBeforeStatement); 159541"];
7439 [label="return ParseStatementCoreRest(attributes, isGlobal, ref resetPointBeforeStatement); 159542"];
7440 [label="return ParseStatementCoreRest(attributes, isGlobal, ref resetPointBeforeStatement); 159543"];
7441 [label="ParseStatementCoreRest(attributes, isGlobal, ref resetPointBeforeStatement) 159544"];
7442 [label="param ParseStatementCoreRest(SyntaxList<AttributeListSyntax> attributes) 159545"];
7443 [label="param ParseStatementCoreRest(bool isGlobal) 159546"];
7444 [label="param ParseStatementCoreRest(ref ResetPoint resetPointBeforeStatement) 159547"];
7445 [label="param ParseStatementCoreRest(this) 159548"];
7446 [label="isGlobal = isGlobal && IsScript; 159549"];
7447 [label="if (!this.IsPossibleLocalDeclarationStatement(isGlobal))\n            {\n                return this.ParseExpressionStatement(attributes);\n            } 159550"];
7448 [label="this.IsPossibleLocalDeclarationStatement(isGlobal) 159551"];
7449 [label="param IsPossibleLocalDeclarationStatement(bool isGlobalScriptLevel) 159552"];
7450 [label="param IsPossibleLocalDeclarationStatement(this) 159553"];
7451 [label="this.CurrentToken 159554"];
7452 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159555"];
7453 [label="var tk = this.CurrentToken.Kind; 159556"];
7454 [label="this.CurrentToken.Kind 159557"];
7455 [label="get { return (SyntaxKind)this.RawKind; } 159558"];
7456 [label="if (tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)) // e.g. `int (x, y)` is an error decl expression\n            {\n                return true;\n            } 159559"];
7457 [label="if (tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)) // e.g. `int (x, y)` is an error decl expression\n            {\n                return true;\n            } 159560"];
7458 [label="IsDeclarationModifier(tk) 159561"];
7459 [label="param IsDeclarationModifier(SyntaxKind kind) 159562"];
7460 [label="switch (kind)\n            {\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 159563"];
7461 [label="return false; 159564"];
7462 [label="SyntaxFacts.IsPredefinedType(tk) 159565"];
7463 [label="param IsPredefinedType(SyntaxKind kind) 159566"];
7464 [label="if (tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)) // e.g. `int (x, y)` is an error decl expression\n            {\n                return true;\n            } 159567"];
7465 [label="if (tk == SyntaxKind.UsingKeyword)\n            {\n                Debug.Assert(PeekToken(1).Kind != SyntaxKind.OpenParenToken);\n                return true;\n            } 159568"];
7466 [label="IsPossibleAwaitUsing() 159569"];
7467 [label="=> CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 159570"];
7468 [label="CurrentToken 159571"];
7469 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159572"];
7470 [label="CurrentToken.ContextualKind 159573"];
7471 [label="get\n            {\n                return this.Kind;\n            } 159574"];
7472 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword 159575"];
7473 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 159576"];
7474 [label="if (IsPossibleAwaitUsing())\n            {\n                Debug.Assert(PeekToken(2).Kind != SyntaxKind.OpenParenToken);\n                return true;\n            } 159577"];
7475 [label="this.CurrentToken 159578"];
7476 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159579"];
7477 [label="tk = this.CurrentToken.ContextualKind; 159580"];
7478 [label="this.CurrentToken.ContextualKind 159581"];
7479 [label="get\n            {\n                return this.Kind;\n            } 159582"];
7480 [label="var isPossibleAttributeOrModifier = (IsAdditionalLocalFunctionModifier(tk) || tk == SyntaxKind.OpenBracketToken)\n                && (tk != SyntaxKind.AsyncKeyword || ShouldAsyncBeTreatedAsModifier(parsingStatementNotDeclaration: true)); 159583"];
7481 [label="IsAdditionalLocalFunctionModifier(tk) 159584"];
7482 [label="param IsAdditionalLocalFunctionModifier(SyntaxKind kind) 159585"];
7483 [label="switch (kind)\n            {\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.ExternKeyword:\n                // Not a valid modifier, but we should parse to give a good\n                // error message\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PrivateKeyword:\n                    return true;\n\n                default:\n                    return false;\n            } 159586"];
7484 [label="return false; 159587"];
7485 [label="var isPossibleAttributeOrModifier = (IsAdditionalLocalFunctionModifier(tk) || tk == SyntaxKind.OpenBracketToken)\n                && (tk != SyntaxKind.AsyncKeyword || ShouldAsyncBeTreatedAsModifier(parsingStatementNotDeclaration: true)); 159588"];
7486 [label="if (isPossibleAttributeOrModifier)\n            {\n                return true;\n            } 159589"];
7487 [label="return IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(isGlobalScriptLevel); 159590"];
7488 [label="IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(isGlobalScriptLevel) 159591"];
7489 [label="param IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(bool isGlobalScriptLevel) 159592"];
7490 [label="param IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(this) 159593"];
7491 [label="this.CurrentToken 159594"];
7492 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159595"];
7493 [label="bool? typedIdentifier = IsPossibleTypedIdentifierStart(this.CurrentToken, this.PeekToken(1), allowThisKeyword: false); 159596"];
7494 [label="bool? typedIdentifier = IsPossibleTypedIdentifierStart(this.CurrentToken, this.PeekToken(1), allowThisKeyword: false); 159597"];
7495 [label="this.PeekToken(1) 159598"];
7496 [label="param PeekToken(int n) 159599"];
7497 [label="param PeekToken(this) 159600"];
7498 [label="Debug.Assert(n >= 0); 159601"];
7499 [label="Debug.Assert(n >= 0); 159602"];
7500 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159603"];
7501 [label="return _lexedTokens[_tokenOffset + n]; 159604"];
7502 [label="IsPossibleTypedIdentifierStart(this.CurrentToken, this.PeekToken(1), allowThisKeyword: false) 159605"];
7503 [label="param IsPossibleTypedIdentifierStart(SyntaxToken current) 159606"];
7504 [label="param IsPossibleTypedIdentifierStart(SyntaxToken next) 159607"];
7505 [label="param IsPossibleTypedIdentifierStart(bool allowThisKeyword) 159608"];
7506 [label="param IsPossibleTypedIdentifierStart(this) 159609"];
7507 [label="if (IsTrueIdentifier(current))\n            {\n                switch (next.Kind)\n                {\n                    // tokens that can be in type names...\n                    case SyntaxKind.DotToken:\n                    case SyntaxKind.AsteriskToken:\n                    case SyntaxKind.QuestionToken:\n                    case SyntaxKind.OpenBracketToken:\n                    case SyntaxKind.LessThanToken:\n                    case SyntaxKind.ColonColonToken:\n                        return null;\n\n                    case SyntaxKind.OpenParenToken:\n                        if (current.IsIdentifierVar())\n                        {\n                            // potentially either a tuple type in a local declaration (true), or\n                            // a tuple lvalue in a deconstruction assignment (false).\n                            return null;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n\n                    case SyntaxKind.IdentifierToken:\n                        return IsTrueIdentifier(next);\n\n                    case SyntaxKind.ThisKeyword:\n                        return allowThisKeyword;\n\n                    default:\n                        return false;\n                }\n            } 159610"];
7508 [label="IsTrueIdentifier(current) 159611"];
7509 [label="param IsTrueIdentifier(SyntaxToken token) 159612"];
7510 [label="param IsTrueIdentifier(this) 159613"];
7511 [label="token.Kind 159614"];
7512 [label="get { return (SyntaxKind)this.RawKind; } 159615"];
7513 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 159616"];
7514 [label="this.IsInQuery 159617"];
7515 [label="get { return _syntaxFactoryContext.IsInQuery; } 159618"];
7516 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 159619"];
7517 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 159620"];
7518 [label="next.Kind 159621"];
7519 [label="get { return (SyntaxKind)this.RawKind; } 159622"];
7520 [label="switch (next.Kind)\n                {\n                    // tokens that can be in type names...\n                    case SyntaxKind.DotToken:\n                    case SyntaxKind.AsteriskToken:\n                    case SyntaxKind.QuestionToken:\n                    case SyntaxKind.OpenBracketToken:\n                    case SyntaxKind.LessThanToken:\n                    case SyntaxKind.ColonColonToken:\n                        return null;\n\n                    case SyntaxKind.OpenParenToken:\n                        if (current.IsIdentifierVar())\n                        {\n                            // potentially either a tuple type in a local declaration (true), or\n                            // a tuple lvalue in a deconstruction assignment (false).\n                            return null;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n\n                    case SyntaxKind.IdentifierToken:\n                        return IsTrueIdentifier(next);\n\n                    case SyntaxKind.ThisKeyword:\n                        return allowThisKeyword;\n\n                    default:\n                        return false;\n                } 159623"];
7521 [label="if (current.IsIdentifierVar())\n                        {\n                            // potentially either a tuple type in a local declaration (true), or\n                            // a tuple lvalue in a deconstruction assignment (false).\n                            return null;\n                        }\n                        else\n                        {\n                            return false;\n                        } 159624"];
7522 [label="current.IsIdentifierVar() 159625"];
7523 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 159626"];
7524 [label="return false; 159627"];
7525 [label="if (typedIdentifier != null)\n            {\n                return typedIdentifier.Value;\n            } 159628"];
7526 [label="if (typedIdentifier != null)\n            {\n                return typedIdentifier.Value;\n            } 159629"];
7527 [label="return typedIdentifier.Value; 159630"];
7528 [label="return IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(isGlobalScriptLevel); 159631"];
7529 [label="if (!this.IsPossibleLocalDeclarationStatement(isGlobal))\n            {\n                return this.ParseExpressionStatement(attributes);\n            } 159632"];
7530 [label="return this.ParseExpressionStatement(attributes); 159633"];
7531 [label="this.ParseExpressionStatement(attributes) 159634"];
7532 [label="param ParseExpressionStatement(SyntaxList<AttributeListSyntax> attributes) 159635"];
7533 [label="param ParseExpressionStatement(this) 159636"];
7534 [label="return ParseExpressionStatement(attributes, this.ParseExpressionCore()); 159637"];
7535 [label="this.ParseExpressionCore() 159638"];
7536 [label="param ParseExpressionCore(this) 159639"];
7537 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 159640"];
7538 [label="ExpressionSyntax leftOperand; 159641"];
7539 [label="Precedence newPrecedence = 0; 159642"];
7540 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 159643"];
7541 [label="IsInvalidSubExpression(tk) 159644"];
7542 [label="param IsInvalidSubExpression(SyntaxKind kind) 159645"];
7543 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 159646"];
7544 [label="return false; 159647"];
7545 [label="param IsAwaitExpression(this) 159648"];
7546 [label="this.CurrentToken 159649"];
7547 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159650"];
7548 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 159651"];
7549 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 159652"];
7550 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 159653"];
7551 [label="param IsQueryExpression(this) 159654"];
7552 [label="this.CurrentToken 159655"];
7553 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159656"];
7554 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 159657"];
7555 [label="this.CurrentToken.ContextualKind 159658"];
7556 [label="get\n            {\n                return this.Kind;\n            } 159659"];
7557 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 159660"];
7558 [label="this.CurrentToken 159661"];
7559 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159662"];
7560 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 159663"];
7561 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 159664"];
7562 [label="this.PeekToken(tokenIndex) 159665"];
7563 [label="param PeekToken(int n) 159666"];
7564 [label="Debug.Assert(n >= 0); 159667"];
7565 [label="Debug.Assert(n >= 0); 159668"];
7566 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159669"];
7567 [label="this.PeekToken(tokenIndex).Kind 159670"];
7568 [label="get { return (SyntaxKind)this.RawKind; } 159671"];
7569 [label="this.PeekToken(tokenIndex) 159672"];
7570 [label="param PeekToken(int n) 159673"];
7571 [label="Debug.Assert(n >= 0); 159674"];
7572 [label="Debug.Assert(n >= 0); 159675"];
7573 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159676"];
7574 [label="this.PeekToken(tokenIndex).ContextualKind 159677"];
7575 [label="get\n            {\n                return this.Kind;\n            } 159678"];
7576 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 159679"];
7577 [label="Debug.Assert(n >= 0); 159680"];
7578 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159681"];
7579 [label="param IsPossibleLambdaExpression(Precedence precedence) 159682"];
7580 [label="this.CurrentToken 159683"];
7581 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 159684"];
7582 [label="this.CurrentToken.Kind 159685"];
7583 [label="get { return (SyntaxKind)this.RawKind; } 159686"];
7584 [label="this.CurrentToken 159687"];
7585 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 159688"];
7586 [label="this.IsTrueIdentifier(this.CurrentToken) 159689"];
7587 [label="param IsTrueIdentifier(SyntaxToken token) 159690"];
7588 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 159691"];
7589 [label="if (precedence > Precedence.Lambda)\n            {\n                return false;\n            } 159692"];
7590 [label="int peekIndex; 159693"];
7591 [label="bool seenStatic; 159694"];
7592 [label="seenStatic = false; 159695"];
7593 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on => then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static =>`\n                // 2. `async static =>`\n\n                // This is an error case, but we have enough code in front of us to be certain\n                // the user was trying to write a static lambda.\n                return true;\n            } 159696"];
7594 [label="this.PeekToken(peekIndex) 159697"];
7595 [label="param PeekToken(int n) 159698"];
7596 [label="Debug.Assert(n >= 0); 159699"];
7597 [label="Debug.Assert(n >= 0); 159700"];
7598 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159701"];
7599 [label="this.PeekToken(peekIndex).Kind 159702"];
7600 [label="get { return (SyntaxKind)this.RawKind; } 159703"];
7601 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 159704"];
7602 [label="this.PeekToken(peekIndex) 159705"];
7603 [label="param PeekToken(int n) 159706"];
7604 [label="Debug.Assert(n >= 0); 159707"];
7605 [label="Debug.Assert(n >= 0); 159708"];
7606 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159709"];
7607 [label="this.PeekToken(peekIndex).Kind 159710"];
7608 [label="get { return (SyntaxKind)this.RawKind; } 159711"];
7609 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 159712"];
7610 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 159713"];
7611 [label="this.PeekToken(peekIndex + 1) 159714"];
7612 [label="param PeekToken(int n) 159715"];
7613 [label="Debug.Assert(n >= 0); 159716"];
7614 [label="Debug.Assert(n >= 0); 159717"];
7615 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159718"];
7616 [label="this.PeekToken(peekIndex + 1).Kind 159719"];
7617 [label="get { return (SyntaxKind)this.RawKind; } 159720"];
7618 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 159721"];
7619 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.OpenParenToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on ( then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static (...\n                // 2. `async static (...\n                return true;\n            } 159722"];
7620 [label="this.PeekToken(peekIndex) 159723"];
7621 [label="param PeekToken(int n) 159724"];
7622 [label="Debug.Assert(n >= 0); 159725"];
7623 [label="Debug.Assert(n >= 0); 159726"];
7624 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159727"];
7625 [label="this.PeekToken(peekIndex).Kind 159728"];
7626 [label="get { return (SyntaxKind)this.RawKind; } 159729"];
7627 [label="Debug.Assert(n >= 0); 159730"];
7628 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159731"];
7629 [label="return _lexedTokens[_tokenOffset + n]; 159732"];
7630 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 159733"];
7631 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 159734"];
7632 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 159735"];
7633 [label="this.IsIncrementalAndFactoryContextMatches 159736"];
7634 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 159737"];
7635 [label="base.IsIncremental 159738"];
7636 [label="get\n            {\n                return _isIncremental;\n            } 159739"];
7637 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 159740"];
7638 [label="return false; 159741"];
7639 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 159742"];
7640 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 159743"];
7641 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 159744"];
7642 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 159745"];
7643 [label="this.CurrentToken 159746"];
7644 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159747"];
7645 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 159748"];
7646 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 159749"];
7647 [label="IsCurrentTokenQueryKeywordInQuery() 159750"];
7648 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 159751"];
7649 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 159752"];
7650 [label="param GetTrailingTrivia(this) 159753"];
7651 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 159754"];
7652 [label="MoveToNextToken(); 159755"];
7653 [label="this.IsInAsync 159756"];
7654 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 159757"];
7655 [label="return _syntaxFactoryContext.IsInAsync; 159758"];
7656 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 159759"];
7657 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 159760"];
7658 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159761"];
7659 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 159762"];
7660 [label="this.CurrentToken.Kind 159763"];
7661 [label="get { return (SyntaxKind)this.RawKind; } 159764"];
7662 [label="this.CurrentToken 159765"];
7663 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159766"];
7664 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 159767"];
7665 [label="this.CurrentToken.Kind 159768"];
7666 [label="get { return (SyntaxKind)this.RawKind; } 159769"];
7667 [label="param ParseParenthesizedArgumentList(this) 159770"];
7668 [label="this.IsIncrementalAndFactoryContextMatches 159771"];
7669 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 159772"];
7670 [label="base.IsIncremental 159773"];
7671 [label="get\n            {\n                return _isIncremental;\n            } 159774"];
7672 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 159775"];
7673 [label="return false; 159776"];
7674 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.ArgumentList)\n            {\n                return (ArgumentListSyntax)this.EatNode();\n            } 159777"];
7675 [label="ParseArgumentList(\n                openToken: out SyntaxToken openToken,\n                arguments: out SeparatedSyntaxList<ArgumentSyntax> arguments,\n                closeToken: out SyntaxToken closeToken,\n                openKind: SyntaxKind.OpenParenToken,\n                closeKind: SyntaxKind.CloseParenToken); 159778"];
7676 [label="ParseArgumentList(\n                openToken: out SyntaxToken openToken,\n                arguments: out SeparatedSyntaxList<ArgumentSyntax> arguments,\n                closeToken: out SyntaxToken closeToken,\n                openKind: SyntaxKind.OpenParenToken,\n                closeKind: SyntaxKind.CloseParenToken); 159779"];
7677 [label="ParseArgumentList(\n                openToken: out SyntaxToken openToken,\n                arguments: out SeparatedSyntaxList<ArgumentSyntax> arguments,\n                closeToken: out SyntaxToken closeToken,\n                openKind: SyntaxKind.OpenParenToken,\n                closeKind: SyntaxKind.CloseParenToken); 159780"];
7678 [label="param EatTokenAsKind(SyntaxKind expected) 159781"];
7679 [label="param EatTokenAsKind(this) 159782"];
7680 [label="Debug.Assert(SyntaxFacts.IsAnyToken(expected)); 159783"];
7681 [label="SyntaxFacts.IsAnyToken(expected) 159784"];
7682 [label="param IsAnyToken(SyntaxKind kind) 159785"];
7683 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 159786"];
7684 [label="return true; 159787"];
7685 [label="this.CurrentToken 159788"];
7686 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159789"];
7687 [label="var ct = this.CurrentToken; 159790"];
7688 [label="ct.Kind 159791"];
7689 [label="get { return (SyntaxKind)this.RawKind; } 159792"];
7690 [label="if (ct.Kind == expected)\n            {\n                MoveToNextToken();\n                return ct;\n            } 159793"];
7691 [label="if (ct.Kind == expected)\n            {\n                MoveToNextToken();\n                return ct;\n            } 159794"];
7692 [label="MoveToNextToken() 159795"];
7693 [label="param GetTrailingTrivia(this) 159796"];
7694 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 159797"];
7695 [label="MoveToNextToken(); 159798"];
7696 [label="return ct; 159799"];
7697 [label="ParseArgumentList(\n                openToken: out SyntaxToken openToken,\n                arguments: out SeparatedSyntaxList<ArgumentSyntax> arguments,\n                closeToken: out SyntaxToken closeToken,\n                openKind: SyntaxKind.OpenParenToken,\n                closeKind: SyntaxKind.CloseParenToken); 159800"];
7698 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159801"];
7699 [label="param GetTrailingTrivia(this) 159802"];
7700 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 159803"];
7701 [label="MoveToNextToken(); 159804"];
7702 [label="return _syntaxFactory.ArgumentList(openToken, arguments, closeToken); 159805"];
7703 [label="return _syntaxFactory.ArgumentList(openToken, arguments, closeToken); 159806"];
7704 [label="param GetNodeFlags(SyntaxFactoryContext context) 159807"];
7705 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 159808"];
7706 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 159809"];
7707 [label="param SetFactoryContext(SyntaxFactoryContext context) 159810"];
7708 [label="param SetFactoryContext(this) 159811"];
7709 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 159812"];
7710 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 159813"];
7711 [label="param TryGetNode(int kind) 159814"];
7712 [label="param TryGetNode(GreenNode child1) 159815"];
7713 [label="param TryGetNode(GreenNode child2) 159816"];
7714 [label="param TryGetNode(SyntaxFactoryContext context) 159817"];
7715 [label="param TryGetNode(out int hash) 159818"];
7716 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 159819"];
7717 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 159820"];
7718 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 159821"];
7719 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 159822"];
7720 [label="GetNodeFlags(context) 159823"];
7721 [label="param GetNodeFlags(SyntaxFactoryContext context) 159824"];
7722 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 159825"];
7723 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 159826"];
7724 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 159827"];
7725 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 159828"];
7726 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 159829"];
7727 [label="param SetFactoryContext(SyntaxFactoryContext context) 159830"];
7728 [label="param SetFactoryContext(this) 159831"];
7729 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 159832"];
7730 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 159833"];
7731 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159834"];
7732 [label="param ParseExpressionContinued(Precedence precedence) 159835"];
7733 [label="param ParseExpressionContinued(this) 159836"];
7734 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 159837"];
7735 [label="this.CurrentToken 159838"];
7736 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159839"];
7737 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159840"];
7738 [label="var tk = this.CurrentToken.ContextualKind; 159841"];
7739 [label="this.CurrentToken.ContextualKind 159842"];
7740 [label="get\n            {\n                return this.Kind;\n            } 159843"];
7741 [label="bool isAssignmentOperator = false; 159844"];
7742 [label="SyntaxKind opKind; 159845"];
7743 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 159846"];
7744 [label="IsExpectedBinaryOperator(tk) 159847"];
7745 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 159848"];
7746 [label="return SyntaxFacts.IsBinaryExpression(kind); 159849"];
7747 [label="SyntaxFacts.IsBinaryExpression(kind) 159850"];
7748 [label="param IsBinaryExpression(SyntaxKind token) 159851"];
7749 [label="return GetBinaryExpression(token) != SyntaxKind.None; 159852"];
7750 [label="GetBinaryExpression(token) 159853"];
7751 [label="param GetBinaryExpression(SyntaxKind token) 159854"];
7752 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 159855"];
7753 [label="return SyntaxKind.None; 159856"];
7754 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 159857"];
7755 [label="IsExpectedAssignmentOperator(tk) 159858"];
7756 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 159859"];
7757 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 159860"];
7758 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 159861"];
7759 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 159862"];
7760 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 159863"];
7761 [label="return false; 159864"];
7762 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 159865"];
7763 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 159866"];
7764 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 159867"];
7765 [label="CurrentToken 159868"];
7766 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159869"];
7767 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159870"];
7768 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 159871"];
7769 [label="CurrentToken.Kind 159872"];
7770 [label="get { return (SyntaxKind)this.RawKind; } 159873"];
7771 [label="_ = GetPrecedence(result.Kind); 159874"];
7772 [label="result.Kind 159875"];
7773 [label="get { return (SyntaxKind)this.RawKind; } 159876"];
7774 [label="_ = GetPrecedence(result.Kind); 159877"];
7775 [label="GetPrecedence(result.Kind) 159878"];
7776 [label="param GetPrecedence(SyntaxKind op) 159879"];
7777 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 159880"];
7778 [label="return Precedence.Primary; 159881"];
7779 [label="return ParseExpressionStatement(attributes, this.ParseExpressionCore()); 159882"];
7780 [label="ParseExpressionStatement(attributes, this.ParseExpressionCore()) 159883"];
7781 [label="param ParseExpressionStatement(SyntaxList<AttributeListSyntax> attributes) 159884"];
7782 [label="param ParseExpressionStatement(ExpressionSyntax expression) 159885"];
7783 [label="param ParseExpressionStatement(this) 159886"];
7784 [label="SyntaxToken semicolon; 159887"];
7785 [label="IsScript 159888"];
7786 [label="get { return Options.Kind == SourceCodeKind.Script; } 159889"];
7787 [label="Options 159890"];
7788 [label="get { return this.lexer.Options; } 159891"];
7789 [label="this.lexer.Options 159892"];
7790 [label="get { return _options; } 159893"];
7791 [label="return _options; 159894"];
7792 [label="return this.lexer.Options; 159895"];
7793 [label="return Options.Kind == SourceCodeKind.Script; 159896"];
7794 [label="if (IsScript && this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n            {\n                semicolon = SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken);\n            }\n            else\n            {\n                // Do not report an error if the expression is not a statement expression.\n                // The error is reported in semantic analysis.\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            } 159897"];
7795 [label="semicolon = this.EatToken(SyntaxKind.SemicolonToken); 159898"];
7796 [label="this.EatToken(SyntaxKind.SemicolonToken) 159899"];
7797 [label="param EatToken(SyntaxKind kind) 159900"];
7798 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 159901"];
7799 [label="SyntaxFacts.IsAnyToken(kind) 159902"];
7800 [label="param IsAnyToken(SyntaxKind kind) 159903"];
7801 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 159904"];
7802 [label="return true; 159905"];
7803 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 159906"];
7804 [label="MoveToNextToken(); 159907"];
7805 [label="return _syntaxFactory.ExpressionStatement(attributes, expression, semicolon); 159908"];
7806 [label="return _syntaxFactory.ExpressionStatement(attributes, expression, semicolon); 159909"];
7807 [label="return _syntaxFactory.ExpressionStatement(attributes, expression, semicolon); 159910"];
7808 [label="return _syntaxFactory.ExpressionStatement(attributes, expression, semicolon); 159911"];
7809 [label="return _syntaxFactory.ExpressionStatement(attributes, expression, semicolon); 159912"];
7810 [label="param GetNodeFlags(SyntaxFactoryContext context) 159913"];
7811 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 159914"];
7812 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 159915"];
7813 [label="param SetFactoryContext(SyntaxFactoryContext context) 159916"];
7814 [label="param SetFactoryContext(this) 159917"];
7815 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 159918"];
7816 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 159919"];
7817 [label="_recursionDepth 159920"];
7818 [label="this.Release(ref resetPointBeforeStatement); 159921"];
7819 [label="this.Release(ref resetPointBeforeStatement) 159922"];
7820 [label="param Release(ref ResetPoint state) 159923"];
7821 [label="base.Release(ref state.BaseResetPoint); 159924"];
7822 [label="param Release(ref ResetPoint point) 159925"];
7823 [label="Debug.Assert(_resetCount == point.ResetCount); 159926"];
7824 [label="_resetCount 159927"];
7825 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 159928"];
7826 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 159929"];
7827 [label="base.Release(ref state.BaseResetPoint); 159930"];
7828 [label="this.Release(ref resetPointBeforeStatement); 159931"];
7829 [label="var statement = this.ParsePossiblyAttributedStatement(); 159932"];
7830 [label="if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    } 159933"];
7831 [label="if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    } 159934"];
7832 [label="statements.Add(statement); 159935"];
7833 [label="statements.Add(statement); 159936"];
7834 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159937"];
7835 [label="param IsMakingProgress(bool assertIfFalse = true) 159938"];
7836 [label="param IsPossibleStatement(bool acceptAccessibilityMods) 159939"];
7837 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 159940"];
7838 [label="this.CurrentToken 159941"];
7839 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159942"];
7840 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 159943"];
7841 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 159944"];
7842 [label="this.CurrentToken.Kind 159945"];
7843 [label="get { return (SyntaxKind)this.RawKind; } 159946"];
7844 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 159947"];
7845 [label="false 159948"];
7846 [label="isGlobal: false 159949"];
7847 [label="param ParseStatementCore(bool isGlobal) 159950"];
7848 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 159951"];
7849 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 159952"];
7850 [label="canReuseStatement(attributes, isGlobal) 159953"];
7851 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 159954"];
7852 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 159955"];
7853 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 159956"];
7854 [label="this.IsIncrementalAndFactoryContextMatches 159957"];
7855 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 159958"];
7856 [label="base.IsIncremental 159959"];
7857 [label="get\n            {\n                return _isIncremental;\n            } 159960"];
7858 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 159961"];
7859 [label="return false; 159962"];
7860 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 159963"];
7861 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 159964"];
7862 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 159965"];
7863 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 159966"];
7864 [label="StatementSyntax result; 159967"];
7865 [label="result = TryParseStatementStartingWithIdentifier(attributes, isGlobal); 159968"];
7866 [label="result = TryParseStatementStartingWithIdentifier(attributes, isGlobal); 159969"];
7867 [label="TryParseStatementStartingWithIdentifier(attributes, isGlobal) 159970"];
7868 [label="param TryParseStatementStartingWithIdentifier(SyntaxList<AttributeListSyntax> attributes) 159971"];
7869 [label="param TryParseStatementStartingWithIdentifier(bool isGlobal) 159972"];
7870 [label="param TryParseStatementStartingWithIdentifier(this) 159973"];
7871 [label="this.CurrentToken 159974"];
7872 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159975"];
7873 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.ForEachKeyword)\n            {\n                return this.ParseForEachStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncStreams));\n            }\n            else if (IsPossibleAwaitUsing())\n            {\n                if (PeekToken(2).Kind == SyntaxKind.OpenParenToken)\n                {\n                    // `await using Type ...` is handled below in ParseLocalDeclarationStatement\n                    return this.ParseUsingStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncUsing));\n                }\n            }\n            else if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 159976"];
7874 [label="this.CurrentToken.ContextualKind 159977"];
7875 [label="get\n            {\n                return this.Kind;\n            } 159978"];
7876 [label="IsPossibleAwaitUsing() 159979"];
7877 [label="=> CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 159980"];
7878 [label="CurrentToken 159981"];
7879 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159982"];
7880 [label="CurrentToken.ContextualKind 159983"];
7881 [label="get\n            {\n                return this.Kind;\n            } 159984"];
7882 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword 159985"];
7883 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 159986"];
7884 [label="if (IsPossibleAwaitUsing())\n            {\n                if (PeekToken(2).Kind == SyntaxKind.OpenParenToken)\n                {\n                    // `await using Type ...` is handled below in ParseLocalDeclarationStatement\n                    return this.ParseUsingStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncUsing));\n                }\n            }\n            else if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 159987"];
7885 [label="this.IsPossibleLabeledStatement() 159988"];
7886 [label="param IsPossibleLabeledStatement(this) 159989"];
7887 [label="return this.PeekToken(1).Kind == SyntaxKind.ColonToken && this.IsTrueIdentifier(); 159990"];
7888 [label="this.PeekToken(1) 159991"];
7889 [label="param PeekToken(int n) 159992"];
7890 [label="param PeekToken(this) 159993"];
7891 [label="Debug.Assert(n >= 0); 159994"];
7892 [label="Debug.Assert(n >= 0); 159995"];
7893 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159996"];
7894 [label="return _lexedTokens[_tokenOffset + n]; 159997"];
7895 [label="this.PeekToken(1).Kind 159998"];
7896 [label="get { return (SyntaxKind)this.RawKind; } 159999"];
7897 [label="if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 160000"];
7898 [label="this.IsPossibleYieldStatement() 160001"];
7899 [label="param IsPossibleYieldStatement(this) 160002"];
7900 [label="this.CurrentToken 160003"];
7901 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 160004"];
7902 [label="return this.CurrentToken.ContextualKind == SyntaxKind.YieldKeyword && (this.PeekToken(1).Kind == SyntaxKind.ReturnKeyword || this.PeekToken(1).Kind == SyntaxKind.BreakKeyword); 160005"];
7903 [label="this.CurrentToken.ContextualKind 160006"];
7904 [label="get\n            {\n                return this.Kind;\n            } 160007"];
7905 [label="if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 160008"];
7906 [label="this.IsPossibleAwaitExpressionStatement() 160009"];
7907 [label="param IsPossibleAwaitExpressionStatement(this) 160010"];
7908 [label="this.IsScript 160011"];
7909 [label="get { return Options.Kind == SourceCodeKind.Script; } 160012"];
7910 [label="return (this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword; 160013"];
7911 [label="this.IsInAsync 160014"];
7912 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 160015"];
7913 [label="return _syntaxFactoryContext.IsInAsync; 160016"];
7914 [label="return (this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword; 160017"];
7915 [label="return (this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword; 160018"];
7916 [label="if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 160019"];
7917 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 160020"];
7918 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 160021"];
7919 [label="this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript) 160022"];
7920 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 160023"];
7921 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 160024"];
7922 [label="param IsQueryExpression(this) 160025"];
7923 [label="this.CurrentToken 160026"];
7924 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 160027"];
7925 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 160028"];
7926 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 160029"];
7927 [label="return null; 160030"];
7928 [label="result = TryParseStatementStartingWithIdentifier(attributes, isGlobal); 160031"];
7929 [label="if (result != null)\n                            return result; 160032"];
7930 [label="if (result != null)\n                            return result; 160033"];
7931 [label="param ParseStatementCoreRest(bool isGlobal) 160034"];
7932 [label="param ParseStatementCoreRest(ref ResetPoint resetPointBeforeStatement) 160035"];
7933 [label="isGlobal = isGlobal && IsScript; 160036"];
7934 [label="param IsPossibleLocalDeclarationStatement(bool isGlobalScriptLevel) 160037"];
7935 [label="this.CurrentToken 160038"];
7936 [label="var tk = this.CurrentToken.Kind; 160039"];
7937 [label="this.CurrentToken.Kind 160040"];
7938 [label="get { return (SyntaxKind)this.RawKind; } 160041"];
7939 [label="if (tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)) // e.g. `int (x, y)` is an error decl expression\n            {\n                return true;\n            } 160042"];
7940 [label="if (tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)) // e.g. `int (x, y)` is an error decl expression\n            {\n                return true;\n            } 160043"];
7941 [label="IsDeclarationModifier(tk) 160044"];
7942 [label="param IsDeclarationModifier(SyntaxKind kind) 160045"];
7943 [label="switch (kind)\n            {\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 160046"];
7944 [label="return false; 160047"];
7945 [label="SyntaxFacts.IsPredefinedType(tk) 160048"];
7946 [label="param IsPredefinedType(SyntaxKind kind) 160049"];
7947 [label="if (tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)) // e.g. `int (x, y)` is an error decl expression\n            {\n                return true;\n            } 160050"];
7948 [label="if (tk == SyntaxKind.UsingKeyword)\n            {\n                Debug.Assert(PeekToken(1).Kind != SyntaxKind.OpenParenToken);\n                return true;\n            } 160051"];
7949 [label="IsPossibleAwaitUsing() 160052"];
7950 [label="=> CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 160053"];
7951 [label="CurrentToken 160054"];
7952 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 160055"];
7953 [label="CurrentToken.ContextualKind 160056"];
7954 [label="get\n            {\n                return this.Kind;\n            } 160057"];
7955 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword 160058"];
7956 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 160059"];
7957 [label="if (IsPossibleAwaitUsing())\n            {\n                Debug.Assert(PeekToken(2).Kind != SyntaxKind.OpenParenToken);\n                return true;\n            } 160060"];
7958 [label="this.CurrentToken 160061"];
7959 [label="tk = this.CurrentToken.ContextualKind; 160062"];
7960 [label="this.CurrentToken.ContextualKind 160063"];
7961 [label="get\n            {\n                return this.Kind;\n            } 160064"];
7962 [label="var isPossibleAttributeOrModifier = (IsAdditionalLocalFunctionModifier(tk) || tk == SyntaxKind.OpenBracketToken)\n                && (tk != SyntaxKind.AsyncKeyword || ShouldAsyncBeTreatedAsModifier(parsingStatementNotDeclaration: true)); 160065"];
7963 [label="IsAdditionalLocalFunctionModifier(tk) 160066"];
7964 [label="param IsAdditionalLocalFunctionModifier(SyntaxKind kind) 160067"];
7965 [label="switch (kind)\n            {\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.ExternKeyword:\n                // Not a valid modifier, but we should parse to give a good\n                // error message\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PrivateKeyword:\n                    return true;\n\n                default:\n                    return false;\n            } 160068"];
7966 [label="return false; 160069"];
7967 [label="var isPossibleAttributeOrModifier = (IsAdditionalLocalFunctionModifier(tk) || tk == SyntaxKind.OpenBracketToken)\n                && (tk != SyntaxKind.AsyncKeyword || ShouldAsyncBeTreatedAsModifier(parsingStatementNotDeclaration: true)); 160070"];
7968 [label="if (isPossibleAttributeOrModifier)\n            {\n                return true;\n            } 160071"];
7969 [label="param IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(bool isGlobalScriptLevel) 160072"];
7970 [label="Debug.Assert(n >= 0); 160073"];
7971 [label="Debug.Assert(n >= 0); 160074"];
7972 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 160075"];
7973 [label="param IsPossibleTypedIdentifierStart(bool allowThisKeyword) 160076"];
7974 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 160077"];
7975 [label="ExpressionSyntax leftOperand; 160078"];
7976 [label="Precedence newPrecedence = 0; 160079"];
7977 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 160080"];
7978 [label="IsInvalidSubExpression(tk) 160081"];
7979 [label="param IsInvalidSubExpression(SyntaxKind kind) 160082"];
7980 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 160083"];
7981 [label="return false; 160084"];
7982 [label="param IsAwaitExpression(this) 160085"];
7983 [label="this.CurrentToken 160086"];
7984 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 160087"];
7985 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 160088"];
7986 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 160089"];
7987 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 160090"];
7988 [label="param IsQueryExpression(this) 160091"];
7989 [label="this.CurrentToken 160092"];
7990 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 160093"];
7991 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 160094"];
7992 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 160095"];
7993 [label="this.CurrentToken 160096"];
7994 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 160097"];
7995 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 160098"];
7996 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 160099"];
7997 [label="Debug.Assert(n >= 0); 160100"];
7998 [label="Debug.Assert(n >= 0); 160101"];
7999 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 160102"];
8000 [label="this.PeekToken(tokenIndex).Kind 160103"];
8001 [label="get { return (SyntaxKind)this.RawKind; } 160104"];
8002 [label="this.PeekToken(tokenIndex) 160105"];
8003 [label="param PeekToken(int n) 160106"];
8004 [label="Debug.Assert(n >= 0); 160107"];
8005 [label="Debug.Assert(n >= 0); 160108"];
8006 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 160109"];
8007 [label="this.PeekToken(tokenIndex).ContextualKind 160110"];
8008 [label="get\n            {\n                return this.Kind;\n            } 160111"];
8009 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 160112"];
8010 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 160113"];
8011 [label="return _lexedTokens[_tokenOffset + n]; 160114"];
8012 [label="param IsPossibleLambdaExpression(Precedence precedence) 160115"];
8013 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 160116"];
8014 [label="this.CurrentToken.Kind 160117"];
8015 [label="get { return (SyntaxKind)this.RawKind; } 160118"];
8016 [label="this.CurrentToken 160119"];
8017 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 160120"];
8018 [label="this.IsTrueIdentifier(this.CurrentToken) 160121"];
8019 [label="param IsTrueIdentifier(SyntaxToken token) 160122"];
8020 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 160123"];
8021 [label="if (precedence > Precedence.Lambda)\n            {\n                return false;\n            } 160124"];
8022 [label="int peekIndex; 160125"];
8023 [label="bool seenStatic; 160126"];
8024 [label="seenStatic = false; 160127"];
8025 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on => then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static =>`\n                // 2. `async static =>`\n\n                // This is an error case, but we have enough code in front of us to be certain\n                // the user was trying to write a static lambda.\n                return true;\n            } 160128"];
8026 [label="Debug.Assert(n >= 0); 160129"];
8027 [label="Debug.Assert(n >= 0); 160130"];
8028 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 160131"];
8029 [label="this.PeekToken(peekIndex).Kind 160132"];
8030 [label="get { return (SyntaxKind)this.RawKind; } 160133"];
8031 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 160134"];
8032 [label="this.PeekToken(peekIndex) 160135"];
8033 [label="param PeekToken(int n) 160136"];
8034 [label="Debug.Assert(n >= 0); 160137"];
8035 [label="Debug.Assert(n >= 0); 160138"];
8036 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 160139"];
8037 [label="this.PeekToken(peekIndex).Kind 160140"];
8038 [label="get { return (SyntaxKind)this.RawKind; } 160141"];
8039 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 160142"];
8040 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 160143"];
8041 [label="this.PeekToken(peekIndex + 1) 160144"];
8042 [label="param PeekToken(int n) 160145"];
8043 [label="Debug.Assert(n >= 0); 160146"];
8044 [label="Debug.Assert(n >= 0); 160147"];
8045 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 160148"];
8046 [label="this.PeekToken(peekIndex + 1).Kind 160149"];
8047 [label="get { return (SyntaxKind)this.RawKind; } 160150"];
8048 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 160151"];
8049 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.OpenParenToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on ( then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static (...\n                // 2. `async static (...\n                return true;\n            } 160152"];
8050 [label="this.PeekToken(peekIndex) 160153"];
8051 [label="param PeekToken(int n) 160154"];
8052 [label="Debug.Assert(n >= 0); 160155"];
8053 [label="Debug.Assert(n >= 0); 160156"];
8054 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 160157"];
8055 [label="this.PeekToken(peekIndex).Kind 160158"];
8056 [label="get { return (SyntaxKind)this.RawKind; } 160159"];
8057 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 160160"];
8058 [label="return _lexedTokens[_tokenOffset + n]; 160161"];
8059 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 160162"];
8060 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 160163"];
8061 [label="this.IsIncrementalAndFactoryContextMatches 160164"];
8062 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 160165"];
8063 [label="base.IsIncremental 160166"];
8064 [label="get\n            {\n                return _isIncremental;\n            } 160167"];
8065 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 160168"];
8066 [label="return false; 160169"];
8067 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 160170"];
8068 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 160171"];
8069 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 160172"];
8070 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 160173"];
8071 [label="this.CurrentToken 160174"];
8072 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 160175"];
8073 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 160176"];
8074 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 160177"];
8075 [label="IsCurrentTokenQueryKeywordInQuery() 160178"];
8076 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 160179"];
8077 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 160180"];
8078 [label="param GetTrailingTrivia(this) 160181"];
8079 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 160182"];
8080 [label="MoveToNextToken(); 160183"];
8081 [label="this.IsInAsync 160184"];
8082 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 160185"];
8083 [label="return _syntaxFactoryContext.IsInAsync; 160186"];
8084 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 160187"];
8085 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 160188"];
8086 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 160189"];
8087 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 160190"];
8088 [label="this.CurrentToken.Kind 160191"];
8089 [label="get { return (SyntaxKind)this.RawKind; } 160192"];
8090 [label="this.CurrentToken 160193"];
8091 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 160194"];
8092 [label="this.CurrentToken.Kind 160195"];
8093 [label="get { return (SyntaxKind)this.RawKind; } 160196"];
8094 [label="this.IsIncrementalAndFactoryContextMatches 160197"];
8095 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 160198"];
8096 [label="base.IsIncremental 160199"];
8097 [label="get\n            {\n                return _isIncremental;\n            } 160200"];
8098 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 160201"];
8099 [label="return false; 160202"];
8100 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.ArgumentList)\n            {\n                return (ArgumentListSyntax)this.EatNode();\n            } 160203"];
8101 [label="Debug.Assert(SyntaxFacts.IsAnyToken(expected)); 160204"];
8102 [label="SyntaxFacts.IsAnyToken(expected) 160205"];
8103 [label="param IsAnyToken(SyntaxKind kind) 160206"];
8104 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 160207"];
8105 [label="return true; 160208"];
8106 [label="param GetTrailingTrivia(this) 160209"];
8107 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 160210"];
8108 [label="MoveToNextToken(); 160211"];
8109 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 160212"];
8110 [label="param GetNodeFlags(SyntaxFactoryContext context) 160213"];
8111 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 160214"];
8112 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 160215"];
8113 [label="param TryGetNode(SyntaxFactoryContext context) 160216"];
8114 [label="param GetNodeFlags(SyntaxFactoryContext context) 160217"];
8115 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 160218"];
8116 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 160219"];
8117 [label="param SetFactoryContext(SyntaxFactoryContext context) 160220"];
8118 [label="param SetFactoryContext(this) 160221"];
8119 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 160222"];
8120 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 160223"];
8121 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 160224"];
8122 [label="param ParseExpressionContinued(Precedence precedence) 160225"];
8123 [label="param ParseExpressionContinued(this) 160226"];
8124 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 160227"];
8125 [label="this.CurrentToken 160228"];
8126 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 160229"];
8127 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 160230"];
8128 [label="var tk = this.CurrentToken.ContextualKind; 160231"];
8129 [label="this.CurrentToken.ContextualKind 160232"];
8130 [label="get\n            {\n                return this.Kind;\n            } 160233"];
8131 [label="bool isAssignmentOperator = false; 160234"];
8132 [label="SyntaxKind opKind; 160235"];
8133 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 160236"];
8134 [label="IsExpectedBinaryOperator(tk) 160237"];
8135 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 160238"];
8136 [label="return SyntaxFacts.IsBinaryExpression(kind); 160239"];
8137 [label="SyntaxFacts.IsBinaryExpression(kind) 160240"];
8138 [label="param IsBinaryExpression(SyntaxKind token) 160241"];
8139 [label="return GetBinaryExpression(token) != SyntaxKind.None; 160242"];
8140 [label="GetBinaryExpression(token) 160243"];
8141 [label="param GetBinaryExpression(SyntaxKind token) 160244"];
8142 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 160245"];
8143 [label="return SyntaxKind.None; 160246"];
8144 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 160247"];
8145 [label="IsExpectedAssignmentOperator(tk) 160248"];
8146 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 160249"];
8147 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 160250"];
8148 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 160251"];
8149 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 160252"];
8150 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 160253"];
8151 [label="return false; 160254"];
8152 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 160255"];
8153 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 160256"];
8154 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 160257"];
8155 [label="CurrentToken 160258"];
8156 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 160259"];
8157 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 160260"];
8158 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 160261"];
8159 [label="CurrentToken.Kind 160262"];
8160 [label="get { return (SyntaxKind)this.RawKind; } 160263"];
8161 [label="_ = GetPrecedence(result.Kind); 160264"];
8162 [label="result.Kind 160265"];
8163 [label="get { return (SyntaxKind)this.RawKind; } 160266"];
8164 [label="_ = GetPrecedence(result.Kind); 160267"];
8165 [label="GetPrecedence(result.Kind) 160268"];
8166 [label="param GetPrecedence(SyntaxKind op) 160269"];
8167 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 160270"];
8168 [label="return Precedence.Primary; 160271"];
8169 [label="SyntaxToken semicolon; 160272"];
8170 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 160273"];
8171 [label="SyntaxFacts.IsAnyToken(kind) 160274"];
8172 [label="param IsAnyToken(SyntaxKind kind) 160275"];
8173 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 160276"];
8174 [label="return true; 160277"];
8175 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 160278"];
8176 [label="MoveToNextToken(); 160279"];
8177 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 160280"];
8178 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 160281"];
8179 [label="this.Release(ref resetPointBeforeStatement); 160282"];
8180 [label="param Release(ref ResetPoint state) 160283"];
8181 [label="base.Release(ref state.BaseResetPoint); 160284"];
8182 [label="param Release(ref ResetPoint point) 160285"];
8183 [label="Debug.Assert(_resetCount == point.ResetCount); 160286"];
8184 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 160287"];
8185 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 160288"];
8186 [label="base.Release(ref state.BaseResetPoint); 160289"];
8187 [label="this.Release(ref resetPointBeforeStatement); 160290"];
8188 [label="_termState 160291"];
8189 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 160292"];
8190 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 160293"];
8191 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 160294"];
8192 [label="return _syntaxFactory.SwitchSection(labels, statements); 160295"];
8193 [label="return _syntaxFactory.SwitchSection(labels, statements); 160296"];
8194 [label="return _syntaxFactory.SwitchSection(labels, statements); 160297"];
8195 [label="return _syntaxFactory.SwitchSection(labels, statements); 160298"];
8196 [label="GetNodeFlags(context) 160299"];
8197 [label="param GetNodeFlags(SyntaxFactoryContext context) 160300"];
8198 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 160301"];
8199 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 160302"];
8200 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 160303"];
8201 [label="param SetFactoryContext(SyntaxFactoryContext context) 160304"];
8202 [label="param SetFactoryContext(this) 160305"];
8203 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 160306"];
8204 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 160307"];
8205 [label="_pool.Free(statements); 160308"];
8206 [label="_pool.Free(statements); 160309"];
8207 [label="_pool.Free(labels); 160310"];
8208 [label="_pool.Free(labels); 160311"];
8209 [label="var swcase = this.ParseSwitchSection(); 160312"];
8210 [label="sections.Add(swcase); 160313"];
8211 [label="sections.Add(swcase); 160314"];
8212 [label="this.CurrentToken 160315"];
8213 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 160316"];
8214 [label="this.CurrentToken.Kind 160317"];
8215 [label="var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken); 160318"];
8216 [label="this.EatToken(SyntaxKind.CloseBraceToken) 160319"];
8217 [label="param EatToken(SyntaxKind kind) 160320"];
8218 [label="param EatToken(this) 160321"];
8219 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 160322"];
8220 [label="SyntaxFacts.IsAnyToken(kind) 160323"];
8221 [label="param IsAnyToken(SyntaxKind kind) 160324"];
8222 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 160325"];
8223 [label="return true; 160326"];
8224 [label="this.CurrentToken 160327"];
8225 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 160328"];
8226 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 160329"];
8227 [label="ct.Kind 160330"];
8228 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 160331"];
8229 [label="param GetTrailingTrivia(this) 160332"];
8230 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 160333"];
8231 [label="MoveToNextToken(); 160334"];
8232 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 160335"];
8233 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 160336"];
8234 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 160337"];
8235 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 160338"];
8236 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 160339"];
8237 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 160340"];
8238 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 160341"];
8239 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 160342"];
8240 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 160343"];
8241 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 160344"];
8242 [label="param CSharpSyntaxNode(this) 160345"];
8243 [label="GreenStats.NoteGreen(this); 160346"];
8244 [label="param SetFactoryContext(SyntaxFactoryContext context) 160347"];
8245 [label="param SetFactoryContext(this) 160348"];
8246 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 160349"];
8247 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 160350"];
8248 [label="_pool.Free(sections); 160351"];
8249 [label="_pool.Free(sections); 160352"];
8250 [label="this.Release(ref resetPointBeforeStatement); 160353"];
8251 [label="this.Release(ref resetPointBeforeStatement) 160354"];
8252 [label="param Release(ref ResetPoint state) 160355"];
8253 [label="param Release(this) 160356"];
8254 [label="base.Release(ref state.BaseResetPoint); 160357"];
8255 [label="base.Release(ref state.BaseResetPoint) 160358"];
8256 [label="param Release(ref ResetPoint point) 160359"];
8257 [label="param Release(this) 160360"];
8258 [label="Debug.Assert(_resetCount == point.ResetCount); 160361"];
8259 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 160362"];
8260 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 160363"];
8261 [label="_resetStart = -1; 160364"];
8262 [label="_resetStart 160365"];
8263 [label="base.Release(ref state.BaseResetPoint); 160366"];
8264 [label="this.Release(ref resetPointBeforeStatement); 160367"];
8265 [label="var node = parser.ParseStatement(); 160368"];
8266 [label="if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node); 160369"];
8267 [label="node = parser.ConsumeUnexpectedTokens(node); 160370"];
8268 [label="parser.ConsumeUnexpectedTokens(node) 160371"];
8269 [label="param ConsumeUnexpectedTokens(TNode node) 160372"];
8270 [label="param ConsumeUnexpectedTokens(this) 160373"];
8271 [label="this.CurrentToken 160374"];
8272 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 160375"];
8273 [label="this.FetchCurrentToken() 160376"];
8274 [label="param FetchCurrentToken(this) 160377"];
8275 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 160378"];
8276 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 160379"];
8277 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 160380"];
8278 [label="if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken) return node; 160381"];
8279 [label="this.CurrentToken.Kind 160382"];
8280 [label="get { return (SyntaxKind)this.RawKind; } 160383"];
8281 [label="return node; 160384"];
8282 [label="return (StatementSyntax)node.CreateRed(); 160385"];
8283 [label="return (StatementSyntax)node.CreateRed(); 160386"];
8284 [label="return (StatementSyntax)node.CreateRed(); 160387"];
8285 [label="param CSharpSyntaxNode(GreenNode green) 160388"];
8286 [label="param CSharpSyntaxNode(SyntaxNode? parent) 160389"];
8287 [label="param CSharpSyntaxNode(int position) 160390"];
8288 [label="param CSharpSyntaxNode(this) 160391"];
8289 [label="green 160392"];
8290 [label="parent 160393"];
8291 [label="position 160394"];
8292 [label="param CSharpSyntaxNode(this) 160395"];
8293 [label="param CSharpSyntaxNode(this) 160396"];
8294 [label="CustomAssert.NotNull(statement); 160397"];
8295 [label="CustomAssert.Equal(SyntaxKind.SwitchStatement, statement.Kind()); 160398"];
8296 [label="statement.Kind() 160399"];
8297 [label="param Kind(this) 160400"];
8298 [label="return (SyntaxKind)this.Green.RawKind; 160401"];
8299 [label="CustomAssert.Equal(SyntaxKind.SwitchStatement, statement.Kind()); 160402"];
8300 [label="CustomAssert.Equal(text, statement.ToString()); 160403"];
8301 [label="CustomAssert.Equal(text, statement.ToString()); 160404"];
8302 [label="CustomAssert.Equal(text, statement.ToString()); 160405"];
8303 [label="=> true 160406"];
8304 [label="true 160407"];
8305 [label="CustomAssert.Equal(text, statement.ToString()); 160408"];
8306 [label="param WriteTokenTo(System.IO.TextWriter writer) 160409"];
8307 [label="param WriteTokenTo(bool leading) 160410"];
8308 [label="param WriteTokenTo(bool trailing) 160411"];
8309 [label="param WriteTokenTo(this) 160412"];
8310 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 160413"];
8311 [label="this.Text 160414"];
8312 [label="get { return SyntaxFacts.GetText(this.Kind); } 160415"];
8313 [label="this.Kind 160416"];
8314 [label="get { return (SyntaxKind)this.RawKind; } 160417"];
8315 [label="return (SyntaxKind)this.RawKind; 160418"];
8316 [label="return SyntaxFacts.GetText(this.Kind); 160419"];
8317 [label="SyntaxFacts.GetText(this.Kind) 160420"];
8318 [label="param GetText(SyntaxKind kind) 160421"];
8319 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 160422"];
8320 [label="return 'switch'; 160423"];
8321 [label="writer.Write(this.Text); 160424"];
8322 [label="writer.Write(this.Text); 160425"];
8323 [label="if (trailing)\n            {\n                var trivia = this.GetTrailingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 160426"];
8324 [label="this.GetTrailingTrivia() 160427"];
8325 [label="param GetTrailingTrivia(this) 160428"];
8326 [label="return this.TrailingField; 160429"];
8327 [label="var trivia = this.GetTrailingTrivia(); 160430"];
8328 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160431"];
8329 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160432"];
8330 [label="trivia.WriteTo(writer, true, true); 160433"];
8331 [label="trivia.WriteTo(writer, true, true); 160434"];
8332 [label="=> true 160435"];
8333 [label="true 160436"];
8334 [label="param WriteTriviaTo(System.IO.TextWriter writer) 160437"];
8335 [label="param WriteTriviaTo(this) 160438"];
8336 [label="writer.Write(Text); 160439"];
8337 [label="writer.Write(Text); 160440"];
8338 [label="this.GetLeadingTrivia() 160441"];
8339 [label="param GetLeadingTrivia(this) 160442"];
8340 [label="return null; 160443"];
8341 [label="var trivia = this.GetLeadingTrivia(); 160444"];
8342 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160445"];
8343 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160446"];
8344 [label="return '('; 160447"];
8345 [label="param GetTrailingTrivia(this) 160448"];
8346 [label="var trivia = this.GetTrailingTrivia(); 160449"];
8347 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160450"];
8348 [label="get { return this.TextField; } 160451"];
8349 [label="return this.TextField; 160452"];
8350 [label="param GetLeadingTrivia(this) 160453"];
8351 [label="return this.LeadingField; 160454"];
8352 [label="var trivia = this.GetLeadingTrivia(); 160455"];
8353 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160456"];
8354 [label="return ')'; 160457"];
8355 [label="=> true 160458"];
8356 [label="return this.LeadingField; 160459"];
8357 [label="var trivia = this.GetLeadingTrivia(); 160460"];
8358 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160461"];
8359 [label="return '{'; 160462"];
8360 [label="=> true 160463"];
8361 [label="return this.LeadingField; 160464"];
8362 [label="var trivia = this.GetLeadingTrivia(); 160465"];
8363 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160466"];
8364 [label="return 'case'; 160467"];
8365 [label="=> true 160468"];
8366 [label="return this.LeadingField; 160469"];
8367 [label="var trivia = this.GetLeadingTrivia(); 160470"];
8368 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160471"];
8369 [label="return ':'; 160472"];
8370 [label="=> true 160473"];
8371 [label="return this.LeadingField; 160474"];
8372 [label="var trivia = this.GetLeadingTrivia(); 160475"];
8373 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160476"];
8374 [label="return ';'; 160477"];
8375 [label="=> true 160478"];
8376 [label="return this.LeadingField; 160479"];
8377 [label="var trivia = this.GetLeadingTrivia(); 160480"];
8378 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160481"];
8379 [label="return '}'; 160482"];
8380 [label="CustomAssert.Equal(0, statement.Errors().Length); 160483"];
8381 [label="CustomAssert.Equal(0, statement.Errors().Length); 160484"];
8382 [label="statement.Errors() 160485"];
8383 [label="param Errors(this SyntaxNode node) 160486"];
8384 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 160487"];
8385 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 160488"];
8386 [label="node.Green.ErrorsOrWarnings(errorsOnly: true) 160489"];
8387 [label="param ErrorsOrWarnings(this GreenNode node) 160490"];
8388 [label="param ErrorsOrWarnings(bool errorsOnly) 160491"];
8389 [label="ArrayBuilder<DiagnosticInfo> b = ArrayBuilder<DiagnosticInfo>.GetInstance(); 160492"];
8390 [label="var l = new SyntaxDiagnosticInfoList(node); 160493"];
8391 [label="foreach (var item in l)\n            {\n                if (item.Severity == (errorsOnly ? DiagnosticSeverity.Error : DiagnosticSeverity.Warning))\n                    b.Add(item);\n            } 160494"];
8392 [label="return b.ToImmutableAndFree(); 160495"];
8393 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 160496"];
8394 [label="CustomAssert.Equal(0, statement.Errors().Length); 160497"];
8395 [label="var ss = (SwitchStatementSyntax)statement; 160498"];
8396 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 160499"];
8397 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 160500"];
8398 [label="ss.SwitchKeyword 160501"];
8399 [label="=> true 160502"];
8400 [label="true 160503"];
8401 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 160504"];
8402 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 160505"];
8403 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 160506"];
8404 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 160507"];
8405 [label="ss.SwitchKeyword 160508"];
8406 [label="=> true 160509"];
8407 [label="true 160510"];
8408 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 160511"];
8409 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 160512"];
8410 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 160513"];
8411 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 160514"];
8412 [label="ss.OpenParenToken 160515"];
8413 [label="=> true 160516"];
8414 [label="true 160517"];
8415 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 160518"];
8416 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 160519"];
8417 [label="CustomAssert.NotNull(ss.Expression); 160520"];
8418 [label="ss.Expression 160521"];
8419 [label="param CSharpSyntaxNode(GreenNode green) 160522"];
8420 [label="param CSharpSyntaxNode(SyntaxNode? parent) 160523"];
8421 [label="param CSharpSyntaxNode(int position) 160524"];
8422 [label="param CSharpSyntaxNode(this) 160525"];
8423 [label="param CSharpSyntaxNode(this) 160526"];
8424 [label="CustomAssert.Equal('a', ss.Expression.ToString()); 160527"];
8425 [label="ss.Expression.ToString() 160528"];
8426 [label="param ToString(this) 160529"];
8427 [label="this.Identifier.Text 160530"];
8428 [label="get { return this.TextField; } 160531"];
8429 [label="return this.Identifier.Text; 160532"];
8430 [label="CustomAssert.Equal('a', ss.Expression.ToString()); 160533"];
8431 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 160534"];
8432 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 160535"];
8433 [label="ss.CloseParenToken 160536"];
8434 [label="=> true 160537"];
8435 [label="true 160538"];
8436 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 160539"];
8437 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 160540"];
8438 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 160541"];
8439 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 160542"];
8440 [label="ss.OpenBraceToken 160543"];
8441 [label="=> true 160544"];
8442 [label="true 160545"];
8443 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 160546"];
8444 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 160547"];
8445 [label="CustomAssert.Equal(1, ss.Sections.Count); 160548"];
8446 [label="CustomAssert.Equal(1, ss.Sections.Count); 160549"];
8447 [label="ss.Sections 160550"];
8448 [label="param CSharpSyntaxNode(GreenNode green) 160551"];
8449 [label="param CSharpSyntaxNode(SyntaxNode? parent) 160552"];
8450 [label="param CSharpSyntaxNode(int position) 160553"];
8451 [label="param CSharpSyntaxNode(this) 160554"];
8452 [label="param CSharpSyntaxNode(this) 160555"];
8453 [label="CustomAssert.Equal(1, ss.Sections[0].Labels.Count); 160556"];
8454 [label="CustomAssert.Equal(1, ss.Sections[0].Labels.Count); 160557"];
8455 [label="ss.Sections[0].Labels 160558"];
8456 [label="param CSharpSyntaxNode(GreenNode green) 160559"];
8457 [label="param CSharpSyntaxNode(SyntaxNode? parent) 160560"];
8458 [label="param CSharpSyntaxNode(int position) 160561"];
8459 [label="param CSharpSyntaxNode(this) 160562"];
8460 [label="param CSharpSyntaxNode(this) 160563"];
8461 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 160564"];
8462 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 160565"];
8463 [label="ss.Sections[0].Labels[0].Keyword 160566"];
8464 [label="=> true 160567"];
8465 [label="true 160568"];
8466 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 160569"];
8467 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 160570"];
8468 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 160571"];
8469 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 160572"];
8470 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 160573"];
8471 [label="ss.Sections[0].Labels[0].Keyword 160574"];
8472 [label="=> true 160575"];
8473 [label="true 160576"];
8474 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 160577"];
8475 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 160578"];
8476 [label="var caseLabelSyntax = ss.Sections[0].Labels[0] as CaseSwitchLabelSyntax; 160579"];
8477 [label="var caseLabelSyntax = ss.Sections[0].Labels[0] as CaseSwitchLabelSyntax; 160580"];
8478 [label="CustomAssert.NotNull(caseLabelSyntax); 160581"];
8479 [label="CustomAssert.NotNull(caseLabelSyntax.Value); 160582"];
8480 [label="caseLabelSyntax.Value 160583"];
8481 [label="param CSharpSyntaxNode(GreenNode green) 160584"];
8482 [label="param CSharpSyntaxNode(SyntaxNode? parent) 160585"];
8483 [label="param CSharpSyntaxNode(int position) 160586"];
8484 [label="param CSharpSyntaxNode(this) 160587"];
8485 [label="param CSharpSyntaxNode(this) 160588"];
8486 [label="CustomAssert.Equal('b', caseLabelSyntax.Value.ToString()); 160589"];
8487 [label="caseLabelSyntax.Value.ToString() 160590"];
8488 [label="param ToString(this) 160591"];
8489 [label="this.Identifier.Text 160592"];
8490 [label="get { return this.TextField; } 160593"];
8491 [label="return this.Identifier.Text; 160594"];
8492 [label="CustomAssert.Equal('b', caseLabelSyntax.Value.ToString()); 160595"];
8493 [label="CustomAssert.Equal(2, ss.Sections[0].Statements.Count); 160596"];
8494 [label="CustomAssert.Equal(2, ss.Sections[0].Statements.Count); 160597"];
8495 [label="CustomAssert.Equal('s1();', ss.Sections[0].Statements[0].ToString()); 160598"];
8496 [label="CustomAssert.Equal('s1();', ss.Sections[0].Statements[0].ToString()); 160599"];
8497 [label="param CSharpSyntaxNode(this) 160600"];
8498 [label="=> true 160601"];
8499 [label="true 160602"];
8500 [label="param WriteTokenTo(bool leading) 160603"];
8501 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 160604"];
8502 [label="this.Text 160605"];
8503 [label="param GetTrailingTrivia(this) 160606"];
8504 [label="this.GetLeadingTrivia() 160607"];
8505 [label="param GetLeadingTrivia(this) 160608"];
8506 [label="return null; 160609"];
8507 [label="var trivia = this.GetLeadingTrivia(); 160610"];
8508 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160611"];
8509 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160612"];
8510 [label="this.Kind 160613"];
8511 [label="SyntaxFacts.GetText(this.Kind) 160614"];
8512 [label="param GetLeadingTrivia(this) 160615"];
8513 [label="return this.LeadingField; 160616"];
8514 [label="var trivia = this.GetLeadingTrivia(); 160617"];
8515 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160618"];
8516 [label="CustomAssert.Equal('s2();', ss.Sections[0].Statements[1].ToString()); 160619"];
8517 [label="CustomAssert.Equal('s2();', ss.Sections[0].Statements[1].ToString()); 160620"];
8518 [label="param CSharpSyntaxNode(this) 160621"];
8519 [label="=> true 160622"];
8520 [label="true 160623"];
8521 [label="param WriteTokenTo(bool leading) 160624"];
8522 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 160625"];
8523 [label="this.Text 160626"];
8524 [label="param GetTrailingTrivia(this) 160627"];
8525 [label="this.GetLeadingTrivia() 160628"];
8526 [label="param GetLeadingTrivia(this) 160629"];
8527 [label="return null; 160630"];
8528 [label="var trivia = this.GetLeadingTrivia(); 160631"];
8529 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160632"];
8530 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160633"];
8531 [label="this.Kind 160634"];
8532 [label="SyntaxFacts.GetText(this.Kind) 160635"];
8533 [label="param GetLeadingTrivia(this) 160636"];
8534 [label="return this.LeadingField; 160637"];
8535 [label="var trivia = this.GetLeadingTrivia(); 160638"];
8536 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 160639"];
8537 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 160640"];
8538 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 160641"];
8539 [label="ss.CloseBraceToken 160642"];
8540 [label="=> true 160643"];
8541 [label="true 160644"];
8542 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 160645"];
8543 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 160646"];
2 -> 0;
2 -> 1;
3 -> 1;
5 -> 4;
7 -> 6;
9 -> 8;
11 -> 10;
13 -> 12;
15 -> 14;
17 -> 16;
19 -> 18;
21 -> 20;
23 -> 22;
25 -> 24;
27 -> 26;
29 -> 28;
31 -> 30;
33 -> 32;
35 -> 34;
37 -> 36;
39 -> 38;
41 -> 40;
42 -> 0;
43 -> 0;
44 -> 42;
44 -> 43;
44 -> 0;
45 -> 44;
46 -> 0;
47 -> 0;
48 -> 46;
48 -> 47;
48 -> 44;
49 -> 48;
50 -> 0;
51 -> 50;
52 -> 51;
52 -> 50;
53 -> 52;
55 -> 0;
56 -> 54;
56 -> 55;
57 -> 56;
58 -> 0;
59 -> 0;
60 -> 58;
60 -> 59;
60 -> 0;
61 -> 60;
62 -> 0;
63 -> 0;
64 -> 62;
64 -> 63;
64 -> 48;
65 -> 64;
66 -> 0;
67 -> 0;
68 -> 66;
68 -> 67;
68 -> 64;
69 -> 68;
70 -> 0;
71 -> 0;
72 -> 70;
72 -> 71;
72 -> 68;
73 -> 72;
74 -> 0;
75 -> 0;
76 -> 74;
76 -> 75;
76 -> 0;
77 -> 76;
78 -> 0;
79 -> 0;
80 -> 78;
80 -> 79;
80 -> 0;
81 -> 80;
82 -> 0;
83 -> 0;
84 -> 82;
84 -> 83;
84 -> 0;
85 -> 84;
86 -> 0;
87 -> 0;
88 -> 86;
88 -> 87;
88 -> 72;
89 -> 88;
90 -> 0;
91 -> 0;
92 -> 90;
92 -> 91;
92 -> 0;
93 -> 92;
95 -> 0;
96 -> 94;
96 -> 95;
97 -> 96;
98 -> 0;
99 -> 0;
100 -> 98;
100 -> 99;
100 -> 88;
101 -> 100;
102 -> 0;
103 -> 0;
104 -> 102;
104 -> 103;
104 -> 0;
105 -> 104;
106 -> 0;
107 -> 0;
108 -> 106;
108 -> 107;
108 -> 0;
109 -> 108;
110 -> 0;
111 -> 0;
112 -> 110;
112 -> 111;
112 -> 0;
113 -> 112;
114 -> 0;
115 -> 0;
116 -> 114;
116 -> 115;
116 -> 0;
117 -> 116;
118 -> 0;
119 -> 0;
120 -> 118;
120 -> 119;
120 -> 0;
121 -> 120;
122 -> 0;
123 -> 0;
124 -> 122;
124 -> 123;
124 -> 100;
125 -> 124;
126 -> 0;
127 -> 0;
128 -> 126;
128 -> 127;
128 -> 124;
129 -> 128;
130 -> 0;
131 -> 0;
132 -> 130;
132 -> 131;
132 -> 128;
133 -> 132;
134 -> 0;
135 -> 0;
136 -> 134;
136 -> 135;
136 -> 132;
137 -> 136;
138 -> 0;
139 -> 0;
140 -> 138;
140 -> 139;
140 -> 0;
141 -> 140;
142 -> 0;
143 -> 0;
144 -> 142;
144 -> 143;
144 -> 0;
145 -> 144;
146 -> 0;
147 -> 0;
148 -> 146;
148 -> 147;
148 -> 136;
149 -> 148;
150 -> 0;
151 -> 0;
152 -> 150;
152 -> 151;
152 -> 0;
153 -> 152;
154 -> 0;
155 -> 0;
156 -> 154;
156 -> 155;
156 -> 0;
157 -> 156;
158 -> 0;
159 -> 0;
160 -> 158;
160 -> 159;
160 -> 0;
161 -> 160;
162 -> 0;
163 -> 0;
164 -> 162;
164 -> 163;
164 -> 148;
165 -> 164;
166 -> 0;
167 -> 0;
168 -> 166;
168 -> 167;
168 -> 0;
169 -> 168;
170 -> 0;
171 -> 0;
172 -> 170;
172 -> 171;
172 -> 0;
173 -> 172;
175 -> 174;
177 -> 175;
177 -> 176;
178 -> 177;
180 -> 0;
180 -> 179;
181 -> 180;
181 -> 0;
182 -> 181;
184 -> 183;
186 -> 185;
188 -> 187;
190 -> 189;
191 -> 1;
192 -> 1;
193 -> 191;
193 -> 1;
194 -> 193;
194 -> 192;
195 -> 192;
196 -> 195;
197 -> 196;
198 -> 197;
199 -> 198;
199 -> 197;
200 -> 195;
200 -> 192;
201 -> 195;
201 -> 192;
202 -> 195;
202 -> 192;
203 -> 194;
203 -> 195;
203 -> 192;
204 -> 1;
204 -> 2;
204 -> 199;
204 -> 200;
204 -> 201;
204 -> 203;
205 -> 1;
206 -> 1;
207 -> 206;
207 -> 1;
208 -> 1;
209 -> 1;
210 -> 207;
210 -> 209;
211 -> 208;
211 -> 209;
212 -> 208;
212 -> 209;
213 -> 205;
213 -> 209;
215 -> 214;
216 -> 215;
218 -> 216;
218 -> 217;
219 -> 217;
220 -> 217;
221 -> 218;
221 -> 217;
222 -> 219;
222 -> 221;
223 -> 0;
223 -> 222;
224 -> 217;
225 -> 223;
225 -> 224;
225 -> 217;
227 -> 0;
227 -> 217;
228 -> 218;
228 -> 217;
229 -> 217;
230 -> 227;
230 -> 229;
231 -> 228;
231 -> 229;
232 -> 230;
232 -> 229;
233 -> 231;
233 -> 229;
234 -> 229;
235 -> 229;
236 -> 232;
236 -> 235;
237 -> 233;
237 -> 235;
238 -> 234;
238 -> 235;
239 -> 234;
239 -> 235;
240 -> 234;
240 -> 235;
241 -> 236;
241 -> 235;
242 -> 238;
242 -> 235;
243 -> 239;
243 -> 235;
245 -> 244;
246 -> 237;
246 -> 235;
247 -> 235;
248 -> 241;
248 -> 247;
249 -> 242;
249 -> 247;
250 -> 243;
250 -> 247;
251 -> 246;
251 -> 247;
252 -> 240;
252 -> 247;
253 -> 248;
253 -> 247;
254 -> 249;
254 -> 247;
255 -> 250;
255 -> 247;
256 -> 251;
256 -> 247;
257 -> 247;
258 -> 257;
258 -> 253;
258 -> 254;
258 -> 255;
258 -> 256;
258 -> 247;
259 -> 257;
259 -> 247;
260 -> 259;
260 -> 258;
260 -> 247;
261 -> 240;
261 -> 235;
262 -> 237;
262 -> 240;
262 -> 235;
263 -> 236;
263 -> 0;
263 -> 235;
264 -> 234;
264 -> 217;
265 -> 219;
265 -> 217;
266 -> 264;
266 -> 265;
267 -> 266;
270 -> 268;
270 -> 269;
271 -> 269;
272 -> 269;
273 -> 270;
273 -> 269;
274 -> 271;
274 -> 273;
275 -> 0;
275 -> 274;
276 -> 269;
277 -> 275;
277 -> 276;
277 -> 269;
278 -> 0;
278 -> 269;
279 -> 270;
279 -> 269;
280 -> 269;
281 -> 278;
281 -> 280;
282 -> 279;
282 -> 280;
283 -> 281;
283 -> 280;
284 -> 282;
284 -> 280;
285 -> 280;
286 -> 280;
287 -> 283;
287 -> 286;
288 -> 284;
288 -> 286;
289 -> 285;
289 -> 286;
290 -> 285;
290 -> 286;
291 -> 285;
291 -> 286;
292 -> 287;
292 -> 286;
293 -> 289;
293 -> 286;
294 -> 290;
294 -> 286;
295 -> 288;
295 -> 286;
296 -> 286;
297 -> 292;
297 -> 296;
298 -> 293;
298 -> 296;
299 -> 294;
299 -> 296;
300 -> 295;
300 -> 296;
301 -> 291;
301 -> 296;
302 -> 297;
302 -> 296;
303 -> 298;
303 -> 296;
304 -> 299;
304 -> 296;
305 -> 300;
305 -> 296;
306 -> 296;
307 -> 306;
307 -> 302;
307 -> 303;
307 -> 304;
307 -> 305;
307 -> 296;
308 -> 306;
308 -> 296;
309 -> 308;
309 -> 307;
309 -> 296;
310 -> 291;
310 -> 286;
311 -> 288;
311 -> 291;
311 -> 286;
312 -> 287;
312 -> 0;
312 -> 286;
313 -> 285;
313 -> 269;
314 -> 271;
314 -> 269;
315 -> 313;
315 -> 314;
316 -> 315;
319 -> 317;
319 -> 318;
320 -> 318;
321 -> 318;
322 -> 319;
322 -> 318;
323 -> 320;
323 -> 322;
324 -> 0;
324 -> 323;
325 -> 318;
326 -> 324;
326 -> 325;
326 -> 318;
327 -> 0;
327 -> 318;
328 -> 319;
328 -> 318;
329 -> 318;
330 -> 327;
330 -> 329;
331 -> 328;
331 -> 329;
332 -> 330;
332 -> 329;
333 -> 331;
333 -> 329;
334 -> 329;
335 -> 329;
336 -> 332;
336 -> 335;
337 -> 333;
337 -> 335;
338 -> 334;
338 -> 335;
339 -> 334;
339 -> 335;
340 -> 334;
340 -> 335;
341 -> 336;
341 -> 335;
342 -> 338;
342 -> 335;
343 -> 339;
343 -> 335;
344 -> 337;
344 -> 335;
345 -> 335;
346 -> 341;
346 -> 345;
347 -> 342;
347 -> 345;
348 -> 343;
348 -> 345;
349 -> 344;
349 -> 345;
350 -> 340;
350 -> 345;
351 -> 346;
351 -> 345;
352 -> 347;
352 -> 345;
353 -> 348;
353 -> 345;
354 -> 349;
354 -> 345;
355 -> 345;
356 -> 355;
356 -> 351;
356 -> 352;
356 -> 353;
356 -> 354;
356 -> 345;
357 -> 355;
357 -> 345;
358 -> 357;
358 -> 356;
358 -> 345;
359 -> 340;
359 -> 335;
360 -> 337;
360 -> 340;
360 -> 335;
361 -> 336;
361 -> 0;
361 -> 335;
362 -> 334;
362 -> 318;
363 -> 320;
363 -> 318;
364 -> 362;
364 -> 363;
365 -> 364;
368 -> 366;
368 -> 367;
369 -> 367;
370 -> 0;
370 -> 367;
371 -> 368;
371 -> 367;
372 -> 367;
373 -> 370;
373 -> 372;
374 -> 371;
374 -> 372;
375 -> 373;
375 -> 372;
376 -> 374;
376 -> 372;
377 -> 372;
378 -> 372;
379 -> 375;
379 -> 378;
380 -> 376;
380 -> 378;
381 -> 377;
381 -> 378;
382 -> 377;
382 -> 378;
383 -> 377;
383 -> 378;
384 -> 379;
384 -> 378;
385 -> 381;
385 -> 378;
386 -> 382;
386 -> 378;
387 -> 380;
387 -> 378;
388 -> 378;
389 -> 384;
389 -> 388;
390 -> 385;
390 -> 388;
391 -> 386;
391 -> 388;
392 -> 387;
392 -> 388;
393 -> 383;
393 -> 388;
394 -> 389;
394 -> 388;
395 -> 390;
395 -> 388;
396 -> 391;
396 -> 388;
397 -> 392;
397 -> 388;
398 -> 388;
399 -> 398;
399 -> 394;
399 -> 395;
399 -> 396;
399 -> 397;
399 -> 388;
400 -> 398;
400 -> 388;
401 -> 400;
401 -> 399;
401 -> 388;
402 -> 383;
402 -> 378;
403 -> 380;
403 -> 383;
403 -> 378;
404 -> 379;
404 -> 0;
404 -> 378;
405 -> 377;
405 -> 367;
406 -> 369;
406 -> 367;
407 -> 405;
407 -> 406;
408 -> 407;
411 -> 409;
411 -> 410;
412 -> 410;
413 -> 0;
413 -> 410;
414 -> 411;
414 -> 410;
415 -> 410;
416 -> 413;
416 -> 415;
417 -> 414;
417 -> 415;
418 -> 416;
418 -> 415;
419 -> 417;
419 -> 415;
420 -> 415;
421 -> 415;
422 -> 418;
422 -> 421;
423 -> 419;
423 -> 421;
424 -> 420;
424 -> 421;
425 -> 420;
425 -> 421;
426 -> 420;
426 -> 421;
427 -> 422;
427 -> 421;
428 -> 424;
428 -> 421;
429 -> 425;
429 -> 421;
430 -> 423;
430 -> 421;
431 -> 421;
432 -> 427;
432 -> 431;
433 -> 428;
433 -> 431;
434 -> 429;
434 -> 431;
435 -> 430;
435 -> 431;
436 -> 426;
436 -> 431;
437 -> 432;
437 -> 431;
438 -> 433;
438 -> 431;
439 -> 434;
439 -> 431;
440 -> 435;
440 -> 431;
441 -> 431;
442 -> 441;
442 -> 437;
442 -> 438;
442 -> 439;
442 -> 440;
442 -> 431;
443 -> 441;
443 -> 431;
444 -> 443;
444 -> 442;
444 -> 431;
445 -> 426;
445 -> 421;
446 -> 423;
446 -> 426;
446 -> 421;
447 -> 422;
447 -> 0;
447 -> 421;
448 -> 420;
448 -> 410;
449 -> 412;
449 -> 410;
450 -> 448;
450 -> 449;
451 -> 450;
452 -> 215;
454 -> 453;
456 -> 452;
456 -> 455;
457 -> 454;
457 -> 455;
458 -> 455;
459 -> 456;
459 -> 455;
460 -> 457;
460 -> 459;
461 -> 0;
461 -> 460;
462 -> 455;
463 -> 461;
463 -> 462;
463 -> 455;
464 -> 0;
464 -> 455;
465 -> 456;
465 -> 455;
466 -> 455;
467 -> 464;
467 -> 466;
468 -> 465;
468 -> 466;
469 -> 467;
469 -> 466;
470 -> 468;
470 -> 466;
471 -> 466;
472 -> 466;
473 -> 469;
473 -> 472;
474 -> 470;
474 -> 472;
475 -> 471;
475 -> 472;
476 -> 471;
476 -> 472;
477 -> 471;
477 -> 472;
478 -> 473;
478 -> 472;
479 -> 475;
479 -> 472;
480 -> 476;
480 -> 472;
481 -> 474;
481 -> 472;
482 -> 472;
483 -> 478;
483 -> 482;
484 -> 479;
484 -> 482;
485 -> 480;
485 -> 482;
486 -> 481;
486 -> 482;
487 -> 477;
487 -> 482;
488 -> 483;
488 -> 482;
489 -> 484;
489 -> 482;
490 -> 485;
490 -> 482;
491 -> 486;
491 -> 482;
492 -> 482;
493 -> 492;
493 -> 488;
493 -> 489;
493 -> 490;
493 -> 491;
493 -> 482;
494 -> 492;
494 -> 482;
495 -> 494;
495 -> 493;
495 -> 482;
496 -> 477;
496 -> 472;
497 -> 474;
497 -> 477;
497 -> 472;
498 -> 473;
498 -> 0;
498 -> 472;
499 -> 471;
499 -> 455;
500 -> 457;
500 -> 455;
501 -> 499;
501 -> 455;
502 -> 455;
503 -> 0;
503 -> 502;
503 -> 455;
504 -> 501;
504 -> 502;
504 -> 495;
504 -> 496;
504 -> 497;
504 -> 503;
504 -> 0;
504 -> 455;
505 -> 504;
505 -> 502;
506 -> 504;
506 -> 502;
507 -> 502;
508 -> 506;
508 -> 507;
509 -> 508;
509 -> 504;
509 -> 507;
510 -> 509;
510 -> 502;
511 -> 506;
511 -> 504;
511 -> 502;
512 -> 505;
512 -> 502;
513 -> 502;
514 -> 502;
515 -> 510;
515 -> 514;
516 -> 511;
516 -> 514;
517 -> 511;
517 -> 514;
518 -> 512;
518 -> 514;
519 -> 513;
519 -> 514;
520 -> 514;
521 -> 519;
521 -> 520;
522 -> 520;
523 -> 522;
523 -> 515;
523 -> 517;
523 -> 518;
523 -> 516;
523 -> 511;
523 -> 520;
524 -> 522;
524 -> 520;
525 -> 519;
525 -> 514;
526 -> 515;
526 -> 0;
526 -> 514;
527 -> 523;
530 -> 529;
532 -> 528;
532 -> 531;
533 -> 530;
533 -> 531;
534 -> 531;
535 -> 532;
535 -> 531;
536 -> 533;
536 -> 535;
537 -> 0;
537 -> 536;
538 -> 531;
539 -> 537;
539 -> 538;
539 -> 531;
540 -> 0;
540 -> 531;
541 -> 532;
541 -> 531;
542 -> 531;
543 -> 540;
543 -> 542;
544 -> 541;
544 -> 542;
545 -> 543;
545 -> 542;
546 -> 544;
546 -> 542;
547 -> 542;
548 -> 542;
549 -> 545;
549 -> 548;
550 -> 546;
550 -> 548;
551 -> 547;
551 -> 548;
552 -> 547;
552 -> 548;
553 -> 547;
553 -> 548;
554 -> 549;
554 -> 548;
555 -> 551;
555 -> 548;
556 -> 552;
556 -> 548;
557 -> 550;
557 -> 548;
558 -> 548;
559 -> 554;
559 -> 558;
560 -> 555;
560 -> 558;
561 -> 556;
561 -> 558;
562 -> 557;
562 -> 558;
563 -> 553;
563 -> 558;
564 -> 559;
564 -> 558;
565 -> 560;
565 -> 558;
566 -> 561;
566 -> 558;
567 -> 562;
567 -> 558;
568 -> 558;
569 -> 568;
569 -> 564;
569 -> 565;
569 -> 566;
569 -> 567;
569 -> 558;
570 -> 568;
570 -> 558;
571 -> 570;
571 -> 569;
571 -> 558;
572 -> 553;
572 -> 548;
573 -> 550;
573 -> 553;
573 -> 548;
574 -> 549;
574 -> 0;
574 -> 548;
575 -> 547;
575 -> 531;
576 -> 533;
576 -> 531;
577 -> 575;
577 -> 531;
578 -> 531;
579 -> 0;
579 -> 578;
579 -> 531;
580 -> 577;
580 -> 578;
580 -> 571;
580 -> 572;
580 -> 573;
580 -> 579;
580 -> 523;
580 -> 531;
581 -> 578;
582 -> 578;
583 -> 578;
584 -> 582;
584 -> 583;
585 -> 583;
586 -> 584;
586 -> 585;
587 -> 585;
588 -> 587;
588 -> 585;
589 -> 584;
589 -> 583;
590 -> 580;
590 -> 0;
590 -> 583;
591 -> 580;
594 -> 593;
596 -> 592;
596 -> 595;
597 -> 594;
597 -> 595;
598 -> 595;
599 -> 596;
599 -> 595;
600 -> 597;
600 -> 599;
601 -> 0;
601 -> 600;
602 -> 595;
603 -> 601;
603 -> 602;
603 -> 595;
604 -> 0;
604 -> 595;
605 -> 596;
605 -> 595;
606 -> 595;
607 -> 604;
607 -> 606;
608 -> 605;
608 -> 606;
609 -> 607;
609 -> 606;
610 -> 608;
610 -> 606;
611 -> 606;
612 -> 606;
613 -> 609;
613 -> 612;
614 -> 610;
614 -> 612;
615 -> 611;
615 -> 612;
616 -> 611;
616 -> 612;
617 -> 611;
617 -> 612;
618 -> 613;
618 -> 612;
619 -> 615;
619 -> 612;
620 -> 616;
620 -> 612;
621 -> 614;
621 -> 612;
622 -> 612;
623 -> 618;
623 -> 622;
624 -> 619;
624 -> 622;
625 -> 620;
625 -> 622;
626 -> 621;
626 -> 622;
627 -> 617;
627 -> 622;
628 -> 623;
628 -> 622;
629 -> 624;
629 -> 622;
630 -> 625;
630 -> 622;
631 -> 626;
631 -> 622;
632 -> 622;
633 -> 632;
633 -> 628;
633 -> 629;
633 -> 630;
633 -> 631;
633 -> 622;
634 -> 632;
634 -> 622;
635 -> 634;
635 -> 633;
635 -> 622;
636 -> 617;
636 -> 612;
637 -> 614;
637 -> 617;
637 -> 612;
638 -> 613;
638 -> 0;
638 -> 612;
639 -> 611;
639 -> 595;
640 -> 597;
640 -> 595;
641 -> 639;
641 -> 595;
642 -> 595;
643 -> 0;
643 -> 642;
643 -> 595;
644 -> 641;
644 -> 642;
644 -> 635;
644 -> 636;
644 -> 637;
644 -> 643;
644 -> 580;
644 -> 595;
645 -> 642;
646 -> 642;
647 -> 642;
648 -> 646;
648 -> 647;
649 -> 647;
650 -> 648;
650 -> 649;
651 -> 649;
652 -> 651;
652 -> 649;
653 -> 648;
653 -> 647;
654 -> 644;
654 -> 0;
654 -> 647;
655 -> 644;
658 -> 657;
660 -> 656;
660 -> 659;
661 -> 658;
661 -> 659;
662 -> 0;
662 -> 659;
663 -> 660;
663 -> 659;
664 -> 659;
665 -> 662;
665 -> 664;
666 -> 663;
666 -> 664;
667 -> 665;
667 -> 664;
668 -> 666;
668 -> 664;
669 -> 664;
670 -> 664;
671 -> 667;
671 -> 670;
672 -> 668;
672 -> 670;
673 -> 669;
673 -> 670;
674 -> 669;
674 -> 670;
675 -> 669;
675 -> 670;
676 -> 671;
676 -> 670;
677 -> 673;
677 -> 670;
678 -> 674;
678 -> 670;
679 -> 672;
679 -> 670;
680 -> 670;
681 -> 676;
681 -> 680;
682 -> 677;
682 -> 680;
683 -> 678;
683 -> 680;
684 -> 679;
684 -> 680;
685 -> 675;
685 -> 680;
686 -> 681;
686 -> 680;
687 -> 682;
687 -> 680;
688 -> 683;
688 -> 680;
689 -> 684;
689 -> 680;
690 -> 680;
691 -> 690;
691 -> 686;
691 -> 687;
691 -> 688;
691 -> 689;
691 -> 680;
692 -> 690;
692 -> 680;
693 -> 692;
693 -> 691;
693 -> 680;
694 -> 675;
694 -> 670;
695 -> 672;
695 -> 675;
695 -> 670;
696 -> 671;
696 -> 0;
696 -> 670;
697 -> 669;
697 -> 659;
698 -> 661;
698 -> 659;
699 -> 697;
699 -> 659;
700 -> 659;
701 -> 0;
701 -> 700;
701 -> 659;
702 -> 699;
702 -> 700;
702 -> 693;
702 -> 694;
702 -> 695;
702 -> 701;
702 -> 644;
702 -> 659;
703 -> 700;
704 -> 700;
705 -> 700;
706 -> 704;
706 -> 705;
707 -> 705;
708 -> 706;
708 -> 707;
709 -> 707;
710 -> 709;
710 -> 707;
711 -> 706;
711 -> 705;
712 -> 702;
712 -> 0;
712 -> 705;
713 -> 702;
716 -> 715;
718 -> 714;
718 -> 717;
719 -> 716;
719 -> 717;
720 -> 0;
720 -> 717;
721 -> 718;
721 -> 717;
722 -> 717;
723 -> 720;
723 -> 722;
724 -> 721;
724 -> 722;
725 -> 723;
725 -> 722;
726 -> 724;
726 -> 722;
727 -> 722;
728 -> 722;
729 -> 725;
729 -> 728;
730 -> 726;
730 -> 728;
731 -> 727;
731 -> 728;
732 -> 727;
732 -> 728;
733 -> 727;
733 -> 728;
734 -> 729;
734 -> 728;
735 -> 731;
735 -> 728;
736 -> 732;
736 -> 728;
737 -> 730;
737 -> 728;
738 -> 728;
739 -> 734;
739 -> 738;
740 -> 735;
740 -> 738;
741 -> 736;
741 -> 738;
742 -> 737;
742 -> 738;
743 -> 733;
743 -> 738;
744 -> 739;
744 -> 738;
745 -> 740;
745 -> 738;
746 -> 741;
746 -> 738;
747 -> 742;
747 -> 738;
748 -> 738;
749 -> 748;
749 -> 744;
749 -> 745;
749 -> 746;
749 -> 747;
749 -> 738;
750 -> 748;
750 -> 738;
751 -> 750;
751 -> 749;
751 -> 738;
752 -> 733;
752 -> 728;
753 -> 730;
753 -> 733;
753 -> 728;
754 -> 729;
754 -> 0;
754 -> 728;
755 -> 727;
755 -> 717;
756 -> 719;
756 -> 717;
757 -> 755;
757 -> 717;
758 -> 717;
759 -> 0;
759 -> 758;
759 -> 717;
760 -> 757;
760 -> 758;
760 -> 751;
760 -> 752;
760 -> 753;
760 -> 759;
760 -> 702;
760 -> 717;
761 -> 758;
762 -> 758;
763 -> 758;
764 -> 762;
764 -> 763;
765 -> 763;
766 -> 764;
766 -> 765;
767 -> 765;
768 -> 767;
768 -> 765;
769 -> 764;
769 -> 763;
770 -> 760;
770 -> 0;
770 -> 763;
771 -> 760;
772 -> 0;
774 -> 773;
776 -> 772;
776 -> 775;
777 -> 774;
777 -> 775;
778 -> 0;
778 -> 775;
779 -> 776;
779 -> 775;
780 -> 775;
781 -> 778;
781 -> 780;
782 -> 779;
782 -> 780;
783 -> 781;
783 -> 780;
784 -> 782;
784 -> 780;
785 -> 780;
786 -> 780;
787 -> 783;
787 -> 786;
788 -> 784;
788 -> 786;
789 -> 785;
789 -> 786;
790 -> 785;
790 -> 786;
791 -> 785;
791 -> 786;
792 -> 787;
792 -> 786;
793 -> 789;
793 -> 786;
794 -> 790;
794 -> 786;
795 -> 788;
795 -> 786;
796 -> 786;
797 -> 792;
797 -> 796;
798 -> 793;
798 -> 796;
799 -> 794;
799 -> 796;
800 -> 795;
800 -> 796;
801 -> 791;
801 -> 796;
802 -> 797;
802 -> 796;
803 -> 798;
803 -> 796;
804 -> 799;
804 -> 796;
805 -> 800;
805 -> 796;
806 -> 796;
807 -> 806;
807 -> 802;
807 -> 803;
807 -> 804;
807 -> 805;
807 -> 796;
808 -> 806;
808 -> 796;
809 -> 808;
809 -> 807;
809 -> 796;
810 -> 791;
810 -> 786;
811 -> 788;
811 -> 791;
811 -> 786;
812 -> 787;
812 -> 0;
812 -> 786;
813 -> 785;
813 -> 775;
814 -> 777;
814 -> 775;
815 -> 813;
815 -> 775;
816 -> 775;
817 -> 0;
817 -> 816;
817 -> 775;
818 -> 815;
818 -> 816;
818 -> 809;
818 -> 810;
818 -> 811;
818 -> 817;
818 -> 760;
818 -> 775;
819 -> 816;
820 -> 816;
821 -> 816;
822 -> 820;
822 -> 821;
823 -> 821;
824 -> 822;
824 -> 823;
825 -> 823;
826 -> 825;
826 -> 823;
827 -> 822;
827 -> 821;
828 -> 818;
828 -> 0;
828 -> 821;
829 -> 818;
832 -> 267;
832 -> 831;
833 -> 831;
834 -> 832;
834 -> 831;
835 -> 833;
835 -> 834;
835 -> 260;
835 -> 261;
835 -> 262;
835 -> 831;
837 -> 316;
837 -> 836;
838 -> 836;
839 -> 837;
839 -> 836;
840 -> 838;
840 -> 839;
840 -> 309;
840 -> 310;
840 -> 311;
840 -> 836;
842 -> 365;
842 -> 841;
843 -> 841;
844 -> 842;
844 -> 841;
845 -> 843;
845 -> 844;
845 -> 358;
845 -> 359;
845 -> 360;
845 -> 841;
847 -> 408;
847 -> 846;
848 -> 846;
849 -> 847;
849 -> 846;
850 -> 848;
850 -> 849;
850 -> 401;
850 -> 402;
850 -> 403;
850 -> 846;
852 -> 451;
852 -> 851;
853 -> 851;
854 -> 852;
854 -> 851;
855 -> 853;
855 -> 854;
855 -> 444;
855 -> 445;
855 -> 446;
855 -> 851;
857 -> 527;
857 -> 856;
858 -> 856;
859 -> 857;
859 -> 856;
860 -> 858;
860 -> 859;
860 -> 818;
860 -> 856;
862 -> 591;
862 -> 861;
863 -> 861;
864 -> 862;
864 -> 861;
865 -> 863;
865 -> 864;
865 -> 860;
865 -> 861;
867 -> 655;
867 -> 866;
868 -> 866;
869 -> 867;
869 -> 866;
870 -> 868;
870 -> 869;
870 -> 865;
870 -> 866;
872 -> 713;
872 -> 871;
873 -> 871;
874 -> 872;
874 -> 871;
875 -> 873;
875 -> 874;
875 -> 870;
875 -> 871;
877 -> 771;
877 -> 876;
878 -> 876;
879 -> 877;
879 -> 876;
880 -> 878;
880 -> 879;
880 -> 875;
880 -> 876;
882 -> 829;
882 -> 881;
883 -> 881;
884 -> 882;
884 -> 881;
885 -> 883;
885 -> 884;
885 -> 880;
885 -> 881;
886 -> 210;
886 -> 209;
887 -> 211;
887 -> 209;
888 -> 212;
888 -> 209;
889 -> 209;
890 -> 209;
891 -> 886;
891 -> 890;
892 -> 887;
892 -> 890;
893 -> 888;
893 -> 890;
894 -> 889;
894 -> 890;
895 -> 891;
895 -> 890;
896 -> 892;
896 -> 890;
897 -> 893;
897 -> 890;
898 -> 890;
899 -> 895;
899 -> 898;
900 -> 896;
900 -> 898;
901 -> 897;
901 -> 898;
902 -> 899;
902 -> 898;
903 -> 900;
903 -> 898;
904 -> 898;
905 -> 902;
905 -> 904;
906 -> 903;
906 -> 904;
907 -> 905;
907 -> 904;
908 -> 0;
908 -> 904;
909 -> 904;
910 -> 906;
910 -> 904;
911 -> 907;
911 -> 910;
911 -> 904;
913 -> 912;
916 -> 915;
918 -> 917;
929 -> 920;
929 -> 919;
930 -> 921;
930 -> 919;
931 -> 922;
931 -> 919;
932 -> 923;
932 -> 919;
933 -> 924;
933 -> 919;
934 -> 925;
934 -> 919;
935 -> 926;
935 -> 919;
936 -> 927;
936 -> 919;
937 -> 928;
937 -> 919;
938 -> 919;
940 -> 939;
941 -> 0;
941 -> 898;
942 -> 941;
942 -> 901;
942 -> 898;
943 -> 898;
944 -> 898;
945 -> 911;
945 -> 944;
946 -> 942;
946 -> 944;
947 -> 943;
947 -> 944;
948 -> 943;
948 -> 944;
949 -> 943;
949 -> 944;
950 -> 945;
950 -> 944;
951 -> 944;
952 -> 950;
952 -> 951;
953 -> 949;
953 -> 951;
954 -> 953;
954 -> 951;
955 -> 953;
955 -> 951;
956 -> 0;
958 -> 957;
960 -> 959;
961 -> 960;
962 -> 952;
962 -> 951;
963 -> 951;
964 -> 951;
965 -> 962;
965 -> 964;
966 -> 963;
966 -> 964;
967 -> 966;
967 -> 964;
968 -> 966;
968 -> 964;
969 -> 966;
969 -> 964;
970 -> 966;
970 -> 964;
971 -> 966;
971 -> 964;
972 -> 966;
972 -> 964;
973 -> 966;
973 -> 964;
974 -> 966;
974 -> 964;
975 -> 965;
975 -> 966;
975 -> 964;
976 -> 964;
977 -> 976;
977 -> 966;
977 -> 964;
978 -> 964;
979 -> 978;
979 -> 966;
979 -> 964;
980 -> 965;
980 -> 911;
980 -> 966;
980 -> 964;
981 -> 964;
982 -> 981;
982 -> 966;
982 -> 964;
983 -> 961;
983 -> 960;
983 -> 964;
984 -> 983;
984 -> 966;
984 -> 964;
985 -> 964;
986 -> 985;
986 -> 966;
986 -> 964;
987 -> 963;
987 -> 953;
987 -> 951;
988 -> 949;
988 -> 944;
989 -> 949;
989 -> 944;
990 -> 949;
990 -> 944;
991 -> 949;
991 -> 944;
992 -> 949;
992 -> 944;
993 -> 949;
993 -> 944;
994 -> 949;
994 -> 944;
995 -> 949;
995 -> 944;
996 -> 949;
996 -> 944;
997 -> 949;
997 -> 944;
998 -> 944;
999 -> 998;
999 -> 944;
1000 -> 999;
1000 -> 949;
1000 -> 944;
1001 -> 944;
1002 -> 1001;
1002 -> 944;
1003 -> 1002;
1003 -> 949;
1003 -> 944;
1004 -> 949;
1004 -> 944;
1005 -> 949;
1005 -> 944;
1006 -> 944;
1007 -> 946;
1007 -> 1006;
1007 -> 944;
1008 -> 946;
1008 -> 949;
1008 -> 944;
1009 -> 944;
1010 -> 1009;
1010 -> 949;
1010 -> 944;
1011 -> 944;
1012 -> 1011;
1012 -> 949;
1012 -> 944;
1015 -> 1013;
1015 -> 1014;
1016 -> 1015;
1018 -> 1017;
1019 -> 944;
1020 -> 944;
1021 -> 1019;
1021 -> 1020;
1022 -> 1021;
1022 -> 1020;
1023 -> 1021;
1023 -> 1020;
1024 -> 1021;
1024 -> 1020;
1025 -> 1020;
1026 -> 1025;
1026 -> 1021;
1026 -> 1020;
1027 -> 1020;
1028 -> 1027;
1028 -> 1021;
1028 -> 1020;
1029 -> 1016;
1029 -> 1015;
1029 -> 1020;
1030 -> 1029;
1030 -> 1021;
1030 -> 1020;
1031 -> 1019;
1031 -> 949;
1031 -> 944;
1032 -> 949;
1032 -> 944;
1033 -> 947;
1033 -> 949;
1033 -> 944;
1034 -> 948;
1034 -> 949;
1034 -> 944;
1035 -> 943;
1035 -> 890;
1036 -> 1035;
1036 -> 890;
1037 -> 890;
1038 -> 1036;
1038 -> 1037;
1039 -> 0;
1040 -> 1038;
1040 -> 1037;
1041 -> 1037;
1042 -> 1037;
1043 -> 1040;
1043 -> 1042;
1044 -> 1041;
1044 -> 1042;
1045 -> 1041;
1045 -> 1042;
1046 -> 1041;
1046 -> 1042;
1047 -> 1041;
1047 -> 1042;
1048 -> 1041;
1048 -> 1042;
1051 -> 1049;
1051 -> 1050;
1052 -> 1051;
1053 -> 1043;
1053 -> 1042;
1054 -> 1046;
1054 -> 1042;
1055 -> 1044;
1055 -> 1042;
1056 -> 1045;
1056 -> 1042;
1057 -> 1042;
1058 -> 1042;
1059 -> 1047;
1059 -> 1042;
1060 -> 1042;
1061 -> 1053;
1061 -> 1060;
1062 -> 1054;
1062 -> 1060;
1063 -> 1055;
1063 -> 1060;
1064 -> 1056;
1064 -> 1060;
1065 -> 1057;
1065 -> 1060;
1066 -> 1058;
1066 -> 1060;
1067 -> 1059;
1067 -> 1060;
1068 -> 1048;
1068 -> 1060;
1069 -> 1068;
1069 -> 1060;
1070 -> 1068;
1070 -> 1060;
1071 -> 1068;
1071 -> 1060;
1072 -> 1068;
1072 -> 1060;
1073 -> 1068;
1073 -> 1060;
1074 -> 1068;
1074 -> 1060;
1075 -> 1068;
1075 -> 1060;
1076 -> 1068;
1076 -> 1060;
1077 -> 1068;
1077 -> 1060;
1078 -> 1068;
1078 -> 1060;
1079 -> 1068;
1079 -> 1060;
1080 -> 1068;
1080 -> 1060;
1081 -> 1068;
1081 -> 1060;
1082 -> 1061;
1082 -> 1068;
1082 -> 1060;
1083 -> 1062;
1083 -> 1068;
1083 -> 1060;
1084 -> 1065;
1084 -> 1068;
1084 -> 1060;
1085 -> 1067;
1085 -> 1068;
1085 -> 1060;
1086 -> 1060;
1087 -> 1086;
1087 -> 1068;
1087 -> 1060;
1088 -> 1060;
1089 -> 1063;
1089 -> 1088;
1089 -> 1060;
1090 -> 1089;
1090 -> 1068;
1090 -> 1060;
1091 -> 1060;
1092 -> 1068;
1092 -> 1091;
1093 -> 1092;
1093 -> 1090;
1093 -> 1091;
1094 -> 1093;
1094 -> 1060;
1095 -> 1094;
1095 -> 1065;
1095 -> 1060;
1096 -> 1095;
1097 -> 1096;
1097 -> 1068;
1097 -> 1095;
1098 -> 1095;
1099 -> 1098;
1099 -> 1068;
1099 -> 1095;
1100 -> 1060;
1101 -> 1068;
1101 -> 1100;
1102 -> 1101;
1102 -> 1090;
1102 -> 1100;
1103 -> 1102;
1103 -> 1060;
1104 -> 1066;
1104 -> 1103;
1104 -> 1060;
1105 -> 1104;
1105 -> 1067;
1105 -> 1041;
1105 -> 1060;
1106 -> 1105;
1107 -> 1068;
1107 -> 1106;
1108 -> 1106;
1109 -> 1106;
1110 -> 1107;
1110 -> 1082;
1110 -> 987;
1110 -> 1109;
1111 -> 1110;
1111 -> 975;
1111 -> 1109;
1112 -> 1111;
1112 -> 1106;
1113 -> 1112;
1113 -> 1106;
1114 -> 1113;
1114 -> 1107;
1114 -> 1106;
1115 -> 1107;
1115 -> 1082;
1115 -> 1106;
1116 -> 1107;
1116 -> 1083;
1116 -> 1106;
1117 -> 1106;
1118 -> 1117;
1118 -> 1112;
1118 -> 1106;
1119 -> 1116;
1119 -> 1118;
1120 -> 1118;
1121 -> 1119;
1121 -> 1120;
1122 -> 1115;
1122 -> 1120;
1123 -> 914;
1123 -> 1120;
1124 -> 1121;
1124 -> 1122;
1124 -> 1120;
1125 -> 1122;
1125 -> 1124;
1125 -> 1120;
1126 -> 1122;
1126 -> 987;
1126 -> 955;
1126 -> 1008;
1126 -> 1124;
1126 -> 1010;
1126 -> 1012;
1126 -> 992;
1126 -> 1031;
1126 -> 1033;
1126 -> 1034;
1126 -> 996;
1126 -> 997;
1126 -> 1000;
1126 -> 1003;
1126 -> 1004;
1126 -> 1032;
1126 -> 975;
1126 -> 977;
1126 -> 979;
1126 -> 980;
1126 -> 984;
1126 -> 972;
1126 -> 986;
1126 -> 982;
1126 -> 911;
1126 -> 999;
1126 -> 1002;
1126 -> 0;
1126 -> 1009;
1126 -> 1011;
1126 -> 1026;
1126 -> 1028;
1126 -> 1030;
1126 -> 1029;
1126 -> 1027;
1126 -> 1025;
1126 -> 981;
1126 -> 983;
1126 -> 1125;
1127 -> 1125;
1128 -> 1126;
1128 -> 1127;
1129 -> 1127;
1130 -> 1128;
1130 -> 1126;
1130 -> 1129;
1131 -> 1130;
1131 -> 1126;
1131 -> 1129;
1132 -> 1127;
1133 -> 1127;
1134 -> 1133;
1134 -> 1128;
1134 -> 1127;
1135 -> 1126;
1135 -> 1127;
1136 -> 1135;
1136 -> 1126;
1136 -> 1127;
1137 -> 1126;
1137 -> 1136;
1137 -> 1131;
1137 -> 1134;
1137 -> 1125;
1138 -> 1126;
1138 -> 1127;
1139 -> 1138;
1139 -> 1137;
1139 -> 1127;
1140 -> 1126;
1140 -> 1127;
1141 -> 1140;
1141 -> 1139;
1141 -> 1127;
1142 -> 1126;
1142 -> 1127;
1143 -> 1126;
1143 -> 1127;
1144 -> 1143;
1144 -> 1141;
1144 -> 1142;
1144 -> 1127;
1145 -> 1144;
1145 -> 1143;
1145 -> 1127;
1146 -> 1126;
1146 -> 1127;
1147 -> 1146;
1147 -> 1141;
1147 -> 1127;
1148 -> 1126;
1148 -> 1147;
1148 -> 1141;
1148 -> 1145;
1148 -> 1125;
1149 -> 1126;
1149 -> 1127;
1150 -> 1126;
1150 -> 1127;
1151 -> 1149;
1151 -> 1150;
1151 -> 1148;
1151 -> 1127;
1152 -> 1127;
1153 -> 1151;
1153 -> 1152;
1153 -> 1127;
1154 -> 1151;
1154 -> 1150;
1154 -> 1148;
1154 -> 1127;
1155 -> 1151;
1155 -> 1150;
1155 -> 1153;
1156 -> 1125;
1157 -> 1122;
1157 -> 1156;
1158 -> 1157;
1158 -> 1155;
1158 -> 1156;
1159 -> 1156;
1160 -> 1157;
1160 -> 1158;
1160 -> 1159;
1161 -> 1160;
1161 -> 1158;
1161 -> 1159;
1162 -> 1161;
1162 -> 1156;
1163 -> 1156;
1164 -> 1157;
1164 -> 1158;
1164 -> 1156;
1165 -> 1156;
1166 -> 1162;
1166 -> 1165;
1167 -> 1163;
1167 -> 1165;
1168 -> 1164;
1168 -> 1165;
1169 -> 1157;
1169 -> 1165;
1170 -> 1167;
1170 -> 1165;
1171 -> 1165;
1172 -> 1171;
1173 -> 1169;
1173 -> 1172;
1174 -> 1172;
1175 -> 1173;
1175 -> 1158;
1175 -> 1174;
1176 -> 1172;
1177 -> 1172;
1178 -> 1177;
1178 -> 1173;
1178 -> 1172;
1179 -> 1171;
1180 -> 1171;
1181 -> 1169;
1181 -> 1158;
1181 -> 1180;
1182 -> 1181;
1182 -> 1158;
1182 -> 1180;
1183 -> 1180;
1184 -> 1181;
1184 -> 1183;
1185 -> 1184;
1185 -> 1158;
1185 -> 1183;
1186 -> 1185;
1187 -> 1184;
1187 -> 1186;
1188 -> 1187;
1188 -> 1158;
1188 -> 1186;
1189 -> 1188;
1189 -> 1185;
1190 -> 1185;
1191 -> 1184;
1191 -> 1158;
1191 -> 1175;
1191 -> 1190;
1191 -> 1185;
1192 -> 1184;
1192 -> 1158;
1192 -> 1175;
1192 -> 1178;
1192 -> 1185;
1193 -> 1184;
1193 -> 1158;
1193 -> 1185;
1194 -> 1184;
1194 -> 1158;
1194 -> 1175;
1194 -> 1178;
1194 -> 1185;
1195 -> 1184;
1195 -> 1158;
1195 -> 1185;
1196 -> 1194;
1196 -> 1185;
1197 -> 1184;
1197 -> 1196;
1197 -> 1194;
1197 -> 1185;
1198 -> 1197;
1198 -> 1184;
1198 -> 1185;
1199 -> 1185;
1200 -> 1194;
1200 -> 1199;
1200 -> 1185;
1201 -> 1200;
1201 -> 1180;
1202 -> 1181;
1202 -> 1196;
1202 -> 1198;
1202 -> 1180;
1203 -> 1202;
1203 -> 1171;
1204 -> 1171;
1205 -> 1203;
1205 -> 1204;
1205 -> 1171;
1206 -> 1205;
1207 -> 1203;
1207 -> 1171;
1208 -> 1207;
1209 -> 1157;
1209 -> 1196;
1209 -> 1168;
1209 -> 1156;
1210 -> 1156;
1211 -> 1156;
1212 -> 1157;
1212 -> 1211;
1213 -> 1211;
1214 -> 1212;
1214 -> 1196;
1214 -> 1213;
1215 -> 1211;
1216 -> 1211;
1217 -> 1216;
1217 -> 1212;
1217 -> 1211;
1218 -> 1156;
1219 -> 1210;
1219 -> 1156;
1220 -> 1219;
1220 -> 1157;
1220 -> 1196;
1220 -> 1198;
1220 -> 1168;
1220 -> 1214;
1220 -> 1217;
1220 -> 1210;
1220 -> 1156;
1221 -> 1156;
1222 -> 1220;
1222 -> 1221;
1223 -> 1222;
1223 -> 1220;
1223 -> 1221;
1224 -> 1220;
1224 -> 1223;
1224 -> 1221;
1225 -> 1220;
1225 -> 1223;
1225 -> 1221;
1226 -> 1220;
1226 -> 1221;
1227 -> 1220;
1227 -> 1221;
1228 -> 0;
1228 -> 1226;
1228 -> 1221;
1229 -> 1226;
1229 -> 1221;
1230 -> 1221;
1231 -> 1229;
1231 -> 1230;
1232 -> 1227;
1232 -> 1230;
1233 -> 1231;
1233 -> 1230;
1234 -> 1233;
1234 -> 1232;
1234 -> 1225;
1234 -> 1228;
1234 -> 1230;
1235 -> 1230;
1236 -> 1234;
1236 -> 1235;
1237 -> 1234;
1237 -> 1235;
1238 -> 1234;
1238 -> 1235;
1239 -> 1234;
1239 -> 1235;
1240 -> 1236;
1240 -> 1235;
1241 -> 1237;
1241 -> 1235;
1242 -> 1238;
1242 -> 1235;
1243 -> 1239;
1243 -> 1234;
1243 -> 1240;
1243 -> 1241;
1243 -> 1242;
1243 -> 1235;
1244 -> 1243;
1245 -> 0;
1245 -> 1244;
1246 -> 1244;
1247 -> 1245;
1247 -> 1246;
1248 -> 1227;
1248 -> 1246;
1249 -> 1248;
1249 -> 1243;
1249 -> 1246;
1250 -> 1246;
1251 -> 1249;
1251 -> 1250;
1252 -> 1251;
1252 -> 0;
1252 -> 1250;
1253 -> 1252;
1253 -> 1247;
1253 -> 1246;
1254 -> 1243;
1254 -> 1253;
1255 -> 1253;
1256 -> 1254;
1256 -> 1255;
1257 -> 1254;
1257 -> 1255;
1258 -> 1227;
1258 -> 1243;
1258 -> 1255;
1259 -> 1256;
1259 -> 1018;
1259 -> 1255;
1261 -> 1260;
1262 -> 1260;
1263 -> 1256;
1263 -> 1255;
1264 -> 1263;
1264 -> 1258;
1264 -> 1243;
1264 -> 1255;
1265 -> 1255;
1266 -> 1264;
1266 -> 1265;
1267 -> 1266;
1267 -> 1265;
1268 -> 0;
1268 -> 1267;
1269 -> 1268;
1269 -> 0;
1269 -> 1255;
1270 -> 1243;
1270 -> 1268;
1270 -> 1269;
1271 -> 1269;
1272 -> 1270;
1272 -> 1271;
1273 -> 1272;
1273 -> 1271;
1274 -> 1273;
1275 -> 1243;
1275 -> 1268;
1275 -> 0;
1275 -> 1244;
1276 -> 1243;
1277 -> 1243;
1277 -> 1276;
1277 -> 1268;
1277 -> 1156;
1278 -> 1209;
1278 -> 1156;
1279 -> 1156;
1280 -> 1278;
1280 -> 1279;
1281 -> 1279;
1282 -> 1279;
1283 -> 1280;
1283 -> 1282;
1283 -> 1279;
1284 -> 1283;
1285 -> 1284;
1285 -> 1280;
1285 -> 1277;
1285 -> 1283;
1286 -> 1281;
1286 -> 1279;
1287 -> 1286;
1287 -> 1156;
1288 -> 1156;
1289 -> 1287;
1289 -> 1288;
1290 -> 1157;
1290 -> 1288;
1291 -> 1288;
1292 -> 1290;
1292 -> 1277;
1292 -> 1291;
1292 -> 1288;
1293 -> 1292;
1294 -> 1293;
1294 -> 1156;
1295 -> 1157;
1295 -> 1277;
1295 -> 1156;
1296 -> 1156;
1297 -> 1157;
1297 -> 1295;
1297 -> 1156;
1298 -> 1156;
1299 -> 1296;
1299 -> 1298;
1300 -> 1296;
1300 -> 1298;
1301 -> 1297;
1301 -> 1298;
1302 -> 1157;
1302 -> 1298;
1303 -> 1300;
1303 -> 1298;
1304 -> 1298;
1305 -> 1304;
1306 -> 1302;
1306 -> 1305;
1307 -> 1305;
1308 -> 1306;
1308 -> 1295;
1308 -> 1307;
1309 -> 1305;
1310 -> 1305;
1311 -> 1310;
1311 -> 1306;
1311 -> 1305;
1312 -> 1304;
1313 -> 1304;
1314 -> 1302;
1314 -> 1295;
1314 -> 1313;
1315 -> 1314;
1315 -> 1295;
1315 -> 1313;
1316 -> 1314;
1316 -> 1304;
1317 -> 1304;
1318 -> 1316;
1318 -> 1317;
1318 -> 1304;
1319 -> 1302;
1319 -> 1295;
1319 -> 1308;
1319 -> 1311;
1319 -> 1318;
1320 -> 1318;
1321 -> 1319;
1321 -> 1320;
1322 -> 1319;
1322 -> 1320;
1323 -> 1322;
1323 -> 1319;
1323 -> 1320;
1324 -> 1319;
1324 -> 1323;
1324 -> 1320;
1325 -> 1319;
1325 -> 1320;
1326 -> 1325;
1326 -> 1323;
1326 -> 1320;
1327 -> 1301;
1327 -> 1318;
1328 -> 1318;
1329 -> 1326;
1329 -> 1328;
1330 -> 1327;
1330 -> 1328;
1331 -> 1302;
1331 -> 1328;
1332 -> 1328;
1333 -> 1331;
1333 -> 1332;
1334 -> 1332;
1335 -> 1333;
1335 -> 1326;
1335 -> 1334;
1335 -> 1332;
1336 -> 1335;
1336 -> 1328;
1337 -> 1328;
1338 -> 1330;
1338 -> 1337;
1338 -> 1328;
1339 -> 1329;
1339 -> 1328;
1340 -> 1330;
1340 -> 1339;
1340 -> 1326;
1340 -> 1328;
1341 -> 1340;
1341 -> 1313;
1342 -> 1340;
1343 -> 1340;
1343 -> 1304;
1344 -> 1343;
1345 -> 1157;
1345 -> 1340;
1345 -> 1330;
1345 -> 1156;
1346 -> 1277;
1346 -> 1156;
1347 -> 1209;
1347 -> 1156;
1348 -> 1345;
1348 -> 1156;
1349 -> 1294;
1349 -> 1156;
1350 -> 1156;
1351 -> 1346;
1351 -> 1350;
1352 -> 1347;
1352 -> 1350;
1353 -> 1348;
1353 -> 1350;
1354 -> 1349;
1354 -> 1350;
1355 -> 1157;
1355 -> 1350;
1356 -> 1351;
1356 -> 1277;
1356 -> 0;
1356 -> 1350;
1357 -> 1352;
1357 -> 1340;
1357 -> 1311;
1357 -> 1330;
1357 -> 1350;
1358 -> 1353;
1358 -> 1357;
1358 -> 1350;
1359 -> 1350;
1360 -> 1351;
1360 -> 1277;
1360 -> 1350;
1361 -> 1351;
1361 -> 1277;
1361 -> 1360;
1362 -> 1351;
1362 -> 1277;
1362 -> 1361;
1363 -> 1361;
1364 -> 1362;
1364 -> 1363;
1365 -> 1364;
1365 -> 0;
1365 -> 1363;
1366 -> 1357;
1366 -> 1361;
1367 -> 1351;
1367 -> 1277;
1367 -> 1361;
1368 -> 1358;
1368 -> 1361;
1369 -> 1361;
1370 -> 1366;
1370 -> 1369;
1371 -> 1367;
1371 -> 1369;
1372 -> 1368;
1372 -> 1369;
1373 -> 0;
1374 -> 0;
1376 -> 1374;
1376 -> 1375;
1377 -> 1376;
1378 -> 1377;
1380 -> 1374;
1380 -> 1379;
1381 -> 1380;
1382 -> 1381;
1384 -> 1374;
1384 -> 1383;
1385 -> 1384;
1386 -> 1385;
1388 -> 1374;
1388 -> 1387;
1389 -> 1388;
1390 -> 1389;
1392 -> 1373;
1393 -> 1392;
1393 -> 1374;
1394 -> 1378;
1394 -> 1377;
1394 -> 1392;
1394 -> 1393;
1395 -> 1392;
1395 -> 1393;
1396 -> 1393;
1397 -> 1393;
1398 -> 1395;
1398 -> 1397;
1399 -> 1396;
1399 -> 1397;
1400 -> 1398;
1400 -> 1397;
1401 -> 1397;
1402 -> 1400;
1402 -> 1401;
1403 -> 1399;
1403 -> 1401;
1404 -> 1402;
1404 -> 1401;
1405 -> 1401;
1406 -> 1405;
1406 -> 1404;
1406 -> 1401;
1407 -> 1405;
1407 -> 1401;
1408 -> 1407;
1408 -> 1406;
1408 -> 1401;
1409 -> 1397;
1410 -> 1399;
1410 -> 1409;
1411 -> 1409;
1412 -> 1410;
1412 -> 1411;
1413 -> 1412;
1413 -> 1408;
1413 -> 1411;
1414 -> 1413;
1414 -> 1409;
1415 -> 1409;
1416 -> 1414;
1416 -> 1415;
1417 -> 1416;
1417 -> 1415;
1418 -> 1417;
1419 -> 1418;
1419 -> 1397;
1420 -> 1419;
1420 -> 1399;
1420 -> 1397;
1421 -> 1399;
1421 -> 1408;
1421 -> 0;
1421 -> 1397;
1422 -> 1421;
1422 -> 1399;
1422 -> 1397;
1423 -> 1396;
1423 -> 1394;
1423 -> 1393;
1425 -> 1382;
1425 -> 1381;
1425 -> 1392;
1425 -> 1393;
1426 -> 1392;
1426 -> 1393;
1427 -> 829;
1427 -> 1393;
1428 -> 1393;
1429 -> 1393;
1430 -> 1426;
1430 -> 1429;
1431 -> 1427;
1431 -> 1429;
1432 -> 1427;
1432 -> 1429;
1433 -> 1428;
1433 -> 1429;
1434 -> 1430;
1434 -> 1429;
1435 -> 1429;
1436 -> 1434;
1436 -> 1435;
1437 -> 1433;
1437 -> 1435;
1438 -> 1436;
1438 -> 1435;
1439 -> 1435;
1440 -> 1438;
1440 -> 1439;
1441 -> 1437;
1441 -> 1439;
1442 -> 1440;
1442 -> 1439;
1443 -> 1439;
1444 -> 1443;
1444 -> 1442;
1444 -> 1439;
1445 -> 1443;
1445 -> 1439;
1446 -> 1445;
1446 -> 1444;
1446 -> 1439;
1447 -> 1435;
1448 -> 1437;
1448 -> 1447;
1449 -> 1447;
1450 -> 1448;
1450 -> 1449;
1451 -> 1450;
1451 -> 1446;
1451 -> 1449;
1452 -> 1451;
1452 -> 1447;
1453 -> 1447;
1454 -> 1452;
1454 -> 1453;
1455 -> 1454;
1455 -> 1453;
1456 -> 1455;
1457 -> 1456;
1457 -> 1435;
1458 -> 1457;
1458 -> 1437;
1458 -> 1435;
1459 -> 1437;
1459 -> 1446;
1459 -> 0;
1459 -> 1435;
1460 -> 1459;
1460 -> 1437;
1460 -> 1435;
1461 -> 1433;
1461 -> 1429;
1462 -> 1433;
1462 -> 1429;
1463 -> 1429;
1464 -> 1431;
1464 -> 1463;
1464 -> 1429;
1465 -> 1431;
1465 -> 1464;
1466 -> 1433;
1466 -> 1465;
1466 -> 1446;
1466 -> 1458;
1466 -> 1460;
1466 -> 1461;
1466 -> 1462;
1466 -> 885;
1466 -> 1464;
1467 -> 1431;
1467 -> 1433;
1467 -> 1464;
1468 -> 1429;
1469 -> 1432;
1469 -> 1468;
1469 -> 1429;
1470 -> 1432;
1470 -> 1469;
1471 -> 1433;
1471 -> 1470;
1471 -> 1466;
1471 -> 1467;
1471 -> 1469;
1472 -> 1432;
1472 -> 1433;
1472 -> 1469;
1473 -> 1428;
1473 -> 1425;
1473 -> 1393;
1474 -> 1386;
1474 -> 1385;
1474 -> 1392;
1474 -> 1393;
1475 -> 1392;
1475 -> 1393;
1476 -> 1393;
1477 -> 408;
1477 -> 1393;
1478 -> 1393;
1479 -> 1475;
1479 -> 1478;
1480 -> 1476;
1480 -> 1478;
1481 -> 1477;
1481 -> 1478;
1482 -> 1476;
1482 -> 1478;
1483 -> 1479;
1483 -> 1478;
1484 -> 1478;
1485 -> 1483;
1485 -> 1484;
1486 -> 1482;
1486 -> 1484;
1487 -> 1485;
1487 -> 1484;
1488 -> 1484;
1489 -> 1487;
1489 -> 1488;
1490 -> 1486;
1490 -> 1488;
1491 -> 1489;
1491 -> 1488;
1492 -> 1488;
1493 -> 1492;
1493 -> 1491;
1493 -> 1488;
1494 -> 1492;
1494 -> 1488;
1495 -> 1494;
1495 -> 1493;
1495 -> 1488;
1496 -> 1484;
1497 -> 1486;
1497 -> 1496;
1498 -> 1496;
1499 -> 1497;
1499 -> 1498;
1500 -> 1499;
1500 -> 1495;
1500 -> 1498;
1501 -> 1500;
1501 -> 1496;
1502 -> 1496;
1503 -> 1501;
1503 -> 1502;
1504 -> 1503;
1504 -> 1502;
1505 -> 1504;
1506 -> 1505;
1506 -> 1484;
1507 -> 1506;
1507 -> 1486;
1507 -> 1484;
1508 -> 1486;
1508 -> 1495;
1508 -> 0;
1508 -> 1484;
1509 -> 1508;
1509 -> 1486;
1509 -> 1484;
1510 -> 1482;
1510 -> 1478;
1511 -> 1482;
1511 -> 1478;
1512 -> 1478;
1513 -> 1480;
1513 -> 1512;
1513 -> 1478;
1514 -> 1478;
1515 -> 1481;
1515 -> 1514;
1515 -> 1478;
1516 -> 1481;
1516 -> 1515;
1517 -> 1482;
1517 -> 1516;
1517 -> 1495;
1517 -> 1507;
1517 -> 1509;
1517 -> 1510;
1517 -> 1511;
1517 -> 850;
1517 -> 1515;
1518 -> 1481;
1518 -> 1482;
1518 -> 1515;
1519 -> 1476;
1519 -> 1474;
1519 -> 1393;
1520 -> 1390;
1520 -> 1389;
1520 -> 1392;
1520 -> 1393;
1521 -> 1392;
1521 -> 1393;
1522 -> 1393;
1523 -> 267;
1523 -> 1393;
1524 -> 1393;
1525 -> 1521;
1525 -> 1524;
1526 -> 1522;
1526 -> 1524;
1527 -> 1523;
1527 -> 1524;
1528 -> 1522;
1528 -> 1524;
1529 -> 1525;
1529 -> 1524;
1530 -> 1524;
1531 -> 1529;
1531 -> 1530;
1532 -> 1528;
1532 -> 1530;
1533 -> 1531;
1533 -> 1530;
1534 -> 1530;
1535 -> 1533;
1535 -> 1534;
1536 -> 1532;
1536 -> 1534;
1537 -> 1535;
1537 -> 1534;
1538 -> 1534;
1539 -> 1538;
1539 -> 1537;
1539 -> 1534;
1540 -> 1538;
1540 -> 1534;
1541 -> 1540;
1541 -> 1539;
1541 -> 1534;
1542 -> 1530;
1543 -> 1532;
1543 -> 1542;
1544 -> 1542;
1545 -> 1543;
1545 -> 1544;
1546 -> 1545;
1546 -> 1541;
1546 -> 1544;
1547 -> 1546;
1547 -> 1542;
1548 -> 1542;
1549 -> 1547;
1549 -> 1548;
1550 -> 1549;
1550 -> 1548;
1551 -> 1550;
1552 -> 1551;
1552 -> 1530;
1553 -> 1552;
1553 -> 1532;
1553 -> 1530;
1554 -> 1532;
1554 -> 1541;
1554 -> 0;
1554 -> 1530;
1555 -> 1554;
1555 -> 1532;
1555 -> 1530;
1556 -> 1528;
1556 -> 1524;
1557 -> 1528;
1557 -> 1524;
1558 -> 1524;
1559 -> 1526;
1559 -> 1558;
1559 -> 1524;
1560 -> 1524;
1561 -> 1527;
1561 -> 1560;
1561 -> 1524;
1562 -> 1527;
1562 -> 1561;
1563 -> 1528;
1563 -> 1562;
1563 -> 1541;
1563 -> 1553;
1563 -> 1555;
1563 -> 1556;
1563 -> 1557;
1563 -> 835;
1563 -> 1561;
1564 -> 1527;
1564 -> 1528;
1564 -> 1561;
1565 -> 1522;
1565 -> 1520;
1565 -> 1393;
1566 -> 1378;
1566 -> 1377;
1566 -> 1393;
1567 -> 1396;
1567 -> 1397;
1568 -> 1567;
1568 -> 1397;
1569 -> 1568;
1569 -> 1401;
1570 -> 1569;
1570 -> 1401;
1571 -> 1405;
1571 -> 1570;
1571 -> 1401;
1572 -> 1407;
1572 -> 1571;
1572 -> 1401;
1573 -> 1412;
1573 -> 1572;
1573 -> 1411;
1574 -> 1573;
1574 -> 1409;
1575 -> 1574;
1575 -> 1415;
1576 -> 1575;
1576 -> 1415;
1577 -> 1576;
1578 -> 1577;
1578 -> 1397;
1579 -> 1578;
1579 -> 1399;
1579 -> 1397;
1580 -> 1399;
1580 -> 1572;
1580 -> 0;
1580 -> 1397;
1581 -> 1580;
1581 -> 1399;
1581 -> 1397;
1582 -> 1396;
1582 -> 1566;
1582 -> 1393;
1583 -> 1382;
1583 -> 1381;
1583 -> 1393;
1584 -> 1428;
1584 -> 1429;
1585 -> 1584;
1585 -> 1429;
1586 -> 1585;
1586 -> 1435;
1587 -> 1586;
1587 -> 1435;
1588 -> 1587;
1588 -> 1439;
1589 -> 1588;
1589 -> 1439;
1590 -> 1443;
1590 -> 1589;
1590 -> 1439;
1591 -> 1445;
1591 -> 1590;
1591 -> 1439;
1592 -> 1450;
1592 -> 1591;
1592 -> 1449;
1593 -> 1592;
1593 -> 1447;
1594 -> 1593;
1594 -> 1453;
1595 -> 1594;
1595 -> 1453;
1596 -> 1595;
1597 -> 1596;
1597 -> 1435;
1598 -> 1597;
1598 -> 1437;
1598 -> 1435;
1599 -> 1437;
1599 -> 1591;
1599 -> 0;
1599 -> 1435;
1600 -> 1599;
1600 -> 1437;
1600 -> 1435;
1601 -> 1433;
1601 -> 1465;
1601 -> 1591;
1601 -> 1598;
1601 -> 1600;
1601 -> 1461;
1601 -> 1462;
1601 -> 1471;
1601 -> 1472;
1601 -> 1464;
1602 -> 1428;
1602 -> 1583;
1602 -> 1393;
1603 -> 1386;
1603 -> 1385;
1603 -> 1393;
1604 -> 1476;
1604 -> 1478;
1605 -> 1604;
1605 -> 1478;
1606 -> 1605;
1606 -> 1484;
1607 -> 1606;
1607 -> 1484;
1608 -> 1607;
1608 -> 1488;
1609 -> 1608;
1609 -> 1488;
1610 -> 1492;
1610 -> 1609;
1610 -> 1488;
1611 -> 1494;
1611 -> 1610;
1611 -> 1488;
1612 -> 1499;
1612 -> 1611;
1612 -> 1498;
1613 -> 1612;
1613 -> 1496;
1614 -> 1613;
1614 -> 1502;
1615 -> 1614;
1615 -> 1502;
1616 -> 1615;
1617 -> 1616;
1617 -> 1484;
1618 -> 1617;
1618 -> 1486;
1618 -> 1484;
1619 -> 1486;
1619 -> 1611;
1619 -> 0;
1619 -> 1484;
1620 -> 1619;
1620 -> 1486;
1620 -> 1484;
1621 -> 1482;
1621 -> 1516;
1621 -> 1611;
1621 -> 1618;
1621 -> 1620;
1621 -> 1510;
1621 -> 1511;
1621 -> 1517;
1621 -> 1518;
1621 -> 1515;
1622 -> 1476;
1622 -> 1603;
1622 -> 1393;
1623 -> 1390;
1623 -> 1389;
1623 -> 1393;
1624 -> 1522;
1624 -> 1524;
1625 -> 1624;
1625 -> 1524;
1626 -> 1625;
1626 -> 1530;
1627 -> 1626;
1627 -> 1530;
1628 -> 1627;
1628 -> 1534;
1629 -> 1628;
1629 -> 1534;
1630 -> 1538;
1630 -> 1629;
1630 -> 1534;
1631 -> 1540;
1631 -> 1630;
1631 -> 1534;
1632 -> 1545;
1632 -> 1631;
1632 -> 1544;
1633 -> 1632;
1633 -> 1542;
1634 -> 1633;
1634 -> 1548;
1635 -> 1634;
1635 -> 1548;
1636 -> 1635;
1637 -> 1636;
1637 -> 1530;
1638 -> 1637;
1638 -> 1532;
1638 -> 1530;
1639 -> 1532;
1639 -> 1631;
1639 -> 0;
1639 -> 1530;
1640 -> 1639;
1640 -> 1532;
1640 -> 1530;
1641 -> 1528;
1641 -> 1562;
1641 -> 1631;
1641 -> 1638;
1641 -> 1640;
1641 -> 1556;
1641 -> 1557;
1641 -> 1563;
1641 -> 1564;
1641 -> 1561;
1642 -> 1522;
1642 -> 1623;
1642 -> 1393;
1643 -> 1576;
1644 -> 1643;
1644 -> 1397;
1645 -> 1644;
1645 -> 1399;
1645 -> 1397;
1646 -> 1595;
1647 -> 1646;
1647 -> 1435;
1648 -> 1647;
1648 -> 1437;
1648 -> 1435;
1649 -> 1433;
1649 -> 1465;
1649 -> 1591;
1649 -> 1648;
1649 -> 1600;
1649 -> 1461;
1649 -> 1462;
1649 -> 1601;
1649 -> 1472;
1649 -> 1464;
1650 -> 1615;
1651 -> 1650;
1651 -> 1484;
1652 -> 1651;
1652 -> 1486;
1652 -> 1484;
1653 -> 1482;
1653 -> 1516;
1653 -> 1611;
1653 -> 1652;
1653 -> 1620;
1653 -> 1510;
1653 -> 1511;
1653 -> 1621;
1653 -> 1518;
1653 -> 1515;
1654 -> 1635;
1655 -> 1654;
1655 -> 1530;
1656 -> 1655;
1656 -> 1532;
1656 -> 1530;
1657 -> 1528;
1657 -> 1562;
1657 -> 1631;
1657 -> 1656;
1657 -> 1640;
1657 -> 1556;
1657 -> 1557;
1657 -> 1641;
1657 -> 1564;
1657 -> 1561;
1658 -> 1576;
1659 -> 1658;
1659 -> 1397;
1660 -> 1659;
1660 -> 1399;
1660 -> 1397;
1661 -> 1595;
1662 -> 1661;
1662 -> 1435;
1663 -> 1662;
1663 -> 1437;
1663 -> 1435;
1664 -> 1433;
1664 -> 1465;
1664 -> 1591;
1664 -> 1663;
1664 -> 1600;
1664 -> 1461;
1664 -> 1462;
1664 -> 1649;
1664 -> 1472;
1664 -> 1464;
1665 -> 1615;
1666 -> 1665;
1666 -> 1484;
1667 -> 1666;
1667 -> 1486;
1667 -> 1484;
1668 -> 1482;
1668 -> 1516;
1668 -> 1611;
1668 -> 1667;
1668 -> 1620;
1668 -> 1510;
1668 -> 1511;
1668 -> 1653;
1668 -> 1518;
1668 -> 1515;
1669 -> 1635;
1670 -> 1669;
1670 -> 1530;
1671 -> 1670;
1671 -> 1532;
1671 -> 1530;
1672 -> 1528;
1672 -> 1562;
1672 -> 1631;
1672 -> 1671;
1672 -> 1640;
1672 -> 1556;
1672 -> 1557;
1672 -> 1657;
1672 -> 1564;
1672 -> 1561;
1673 -> 1576;
1674 -> 1673;
1674 -> 1397;
1675 -> 1674;
1675 -> 1399;
1675 -> 1397;
1676 -> 1595;
1677 -> 1676;
1677 -> 1435;
1678 -> 1677;
1678 -> 1437;
1678 -> 1435;
1679 -> 1433;
1679 -> 1465;
1679 -> 1591;
1679 -> 1678;
1679 -> 1600;
1679 -> 1461;
1679 -> 1462;
1679 -> 1664;
1679 -> 1472;
1679 -> 1464;
1680 -> 1615;
1681 -> 1680;
1681 -> 1484;
1682 -> 1681;
1682 -> 1486;
1682 -> 1484;
1683 -> 1482;
1683 -> 1516;
1683 -> 1611;
1683 -> 1682;
1683 -> 1620;
1683 -> 1510;
1683 -> 1511;
1683 -> 1668;
1683 -> 1518;
1683 -> 1515;
1684 -> 1635;
1685 -> 1684;
1685 -> 1530;
1686 -> 1685;
1686 -> 1532;
1686 -> 1530;
1687 -> 1528;
1687 -> 1562;
1687 -> 1631;
1687 -> 1686;
1687 -> 1640;
1687 -> 1556;
1687 -> 1557;
1687 -> 1672;
1687 -> 1564;
1687 -> 1561;
1688 -> 1576;
1689 -> 1688;
1689 -> 1397;
1690 -> 1689;
1690 -> 1399;
1690 -> 1397;
1691 -> 1595;
1692 -> 1691;
1692 -> 1435;
1693 -> 1692;
1693 -> 1437;
1693 -> 1435;
1694 -> 1433;
1694 -> 1465;
1694 -> 1591;
1694 -> 1693;
1694 -> 1600;
1694 -> 1461;
1694 -> 1462;
1694 -> 1679;
1694 -> 1472;
1694 -> 1464;
1695 -> 1615;
1696 -> 1695;
1696 -> 1484;
1697 -> 1696;
1697 -> 1486;
1697 -> 1484;
1698 -> 1482;
1698 -> 1516;
1698 -> 1611;
1698 -> 1697;
1698 -> 1620;
1698 -> 1510;
1698 -> 1511;
1698 -> 1683;
1698 -> 1518;
1698 -> 1515;
1699 -> 1635;
1700 -> 1699;
1700 -> 1530;
1701 -> 1700;
1701 -> 1532;
1701 -> 1530;
1702 -> 1528;
1702 -> 1562;
1702 -> 1631;
1702 -> 1701;
1702 -> 1640;
1702 -> 1556;
1702 -> 1557;
1702 -> 1687;
1702 -> 1564;
1702 -> 1561;
1703 -> 1576;
1704 -> 1703;
1704 -> 1397;
1705 -> 1704;
1705 -> 1399;
1705 -> 1397;
1706 -> 1595;
1707 -> 1706;
1707 -> 1435;
1708 -> 1707;
1708 -> 1437;
1708 -> 1435;
1709 -> 1433;
1709 -> 1465;
1709 -> 1591;
1709 -> 1708;
1709 -> 1600;
1709 -> 1461;
1709 -> 1462;
1709 -> 1694;
1709 -> 1472;
1709 -> 1464;
1710 -> 1615;
1711 -> 1710;
1711 -> 1484;
1712 -> 1711;
1712 -> 1486;
1712 -> 1484;
1713 -> 1482;
1713 -> 1516;
1713 -> 1611;
1713 -> 1712;
1713 -> 1620;
1713 -> 1510;
1713 -> 1511;
1713 -> 1698;
1713 -> 1518;
1713 -> 1515;
1714 -> 1635;
1715 -> 1714;
1715 -> 1530;
1716 -> 1715;
1716 -> 1532;
1716 -> 1530;
1717 -> 1528;
1717 -> 1562;
1717 -> 1631;
1717 -> 1716;
1717 -> 1640;
1717 -> 1556;
1717 -> 1557;
1717 -> 1702;
1717 -> 1564;
1717 -> 1561;
1718 -> 1576;
1719 -> 1718;
1719 -> 1397;
1720 -> 1719;
1720 -> 1399;
1720 -> 1397;
1721 -> 1595;
1722 -> 1721;
1722 -> 1435;
1723 -> 1722;
1723 -> 1437;
1723 -> 1435;
1724 -> 1433;
1724 -> 1465;
1724 -> 1591;
1724 -> 1723;
1724 -> 1600;
1724 -> 1461;
1724 -> 1462;
1724 -> 1709;
1724 -> 1472;
1724 -> 1464;
1725 -> 1615;
1726 -> 1725;
1726 -> 1484;
1727 -> 1726;
1727 -> 1486;
1727 -> 1484;
1728 -> 1482;
1728 -> 1516;
1728 -> 1611;
1728 -> 1727;
1728 -> 1620;
1728 -> 1510;
1728 -> 1511;
1728 -> 1713;
1728 -> 1518;
1728 -> 1515;
1729 -> 1635;
1730 -> 1729;
1730 -> 1530;
1731 -> 1730;
1731 -> 1532;
1731 -> 1530;
1732 -> 1528;
1732 -> 1562;
1732 -> 1631;
1732 -> 1731;
1732 -> 1640;
1732 -> 1556;
1732 -> 1557;
1732 -> 1717;
1732 -> 1564;
1732 -> 1561;
1733 -> 1576;
1734 -> 1733;
1734 -> 1397;
1735 -> 1734;
1735 -> 1399;
1735 -> 1397;
1736 -> 1595;
1737 -> 1736;
1737 -> 1435;
1738 -> 1737;
1738 -> 1437;
1738 -> 1435;
1739 -> 1433;
1739 -> 1465;
1739 -> 1591;
1739 -> 1738;
1739 -> 1600;
1739 -> 1461;
1739 -> 1462;
1739 -> 1724;
1739 -> 1472;
1739 -> 1464;
1740 -> 1615;
1741 -> 1740;
1741 -> 1484;
1742 -> 1741;
1742 -> 1486;
1742 -> 1484;
1743 -> 1482;
1743 -> 1516;
1743 -> 1611;
1743 -> 1742;
1743 -> 1620;
1743 -> 1510;
1743 -> 1511;
1743 -> 1728;
1743 -> 1518;
1743 -> 1515;
1744 -> 1635;
1745 -> 1744;
1745 -> 1530;
1746 -> 1745;
1746 -> 1532;
1746 -> 1530;
1747 -> 1528;
1747 -> 1562;
1747 -> 1631;
1747 -> 1746;
1747 -> 1640;
1747 -> 1556;
1747 -> 1557;
1747 -> 1732;
1747 -> 1564;
1747 -> 1561;
1748 -> 1576;
1749 -> 1748;
1749 -> 1397;
1750 -> 1749;
1750 -> 1399;
1750 -> 1397;
1751 -> 1595;
1752 -> 1751;
1752 -> 1435;
1753 -> 1752;
1753 -> 1437;
1753 -> 1435;
1754 -> 1433;
1754 -> 1465;
1754 -> 1591;
1754 -> 1753;
1754 -> 1600;
1754 -> 1461;
1754 -> 1462;
1754 -> 1739;
1754 -> 1472;
1754 -> 1464;
1755 -> 1615;
1756 -> 1755;
1756 -> 1484;
1757 -> 1756;
1757 -> 1486;
1757 -> 1484;
1758 -> 1482;
1758 -> 1516;
1758 -> 1611;
1758 -> 1757;
1758 -> 1620;
1758 -> 1510;
1758 -> 1511;
1758 -> 1743;
1758 -> 1518;
1758 -> 1515;
1759 -> 1635;
1760 -> 1759;
1760 -> 1530;
1761 -> 1760;
1761 -> 1532;
1761 -> 1530;
1762 -> 1528;
1762 -> 1562;
1762 -> 1631;
1762 -> 1761;
1762 -> 1640;
1762 -> 1556;
1762 -> 1557;
1762 -> 1747;
1762 -> 1564;
1762 -> 1561;
1763 -> 1576;
1764 -> 1763;
1764 -> 1397;
1765 -> 1764;
1765 -> 1399;
1765 -> 1397;
1766 -> 1595;
1767 -> 1766;
1767 -> 1435;
1768 -> 1767;
1768 -> 1437;
1768 -> 1435;
1769 -> 1433;
1769 -> 1465;
1769 -> 1591;
1769 -> 1768;
1769 -> 1600;
1769 -> 1461;
1769 -> 1462;
1769 -> 1754;
1769 -> 1472;
1769 -> 1464;
1770 -> 1615;
1771 -> 1770;
1771 -> 1484;
1772 -> 1771;
1772 -> 1486;
1772 -> 1484;
1773 -> 1482;
1773 -> 1516;
1773 -> 1611;
1773 -> 1772;
1773 -> 1620;
1773 -> 1510;
1773 -> 1511;
1773 -> 1758;
1773 -> 1518;
1773 -> 1515;
1774 -> 1635;
1775 -> 1774;
1775 -> 1530;
1776 -> 1775;
1776 -> 1532;
1776 -> 1530;
1777 -> 1528;
1777 -> 1562;
1777 -> 1631;
1777 -> 1776;
1777 -> 1640;
1777 -> 1556;
1777 -> 1557;
1777 -> 1762;
1777 -> 1564;
1777 -> 1561;
1778 -> 1576;
1779 -> 1778;
1779 -> 1397;
1780 -> 1779;
1780 -> 1399;
1780 -> 1397;
1781 -> 1595;
1782 -> 1781;
1782 -> 1435;
1783 -> 1782;
1783 -> 1437;
1783 -> 1435;
1784 -> 1433;
1784 -> 1465;
1784 -> 1591;
1784 -> 1783;
1784 -> 1600;
1784 -> 1461;
1784 -> 1462;
1784 -> 1769;
1784 -> 1472;
1784 -> 1464;
1785 -> 1615;
1786 -> 1785;
1786 -> 1484;
1787 -> 1786;
1787 -> 1486;
1787 -> 1484;
1788 -> 1482;
1788 -> 1516;
1788 -> 1611;
1788 -> 1787;
1788 -> 1620;
1788 -> 1510;
1788 -> 1511;
1788 -> 1773;
1788 -> 1518;
1788 -> 1515;
1789 -> 1635;
1790 -> 1789;
1790 -> 1530;
1791 -> 1790;
1791 -> 1532;
1791 -> 1530;
1792 -> 1528;
1792 -> 1562;
1792 -> 1631;
1792 -> 1791;
1792 -> 1640;
1792 -> 1556;
1792 -> 1557;
1792 -> 1777;
1792 -> 1564;
1792 -> 1561;
1793 -> 1576;
1794 -> 1793;
1794 -> 1397;
1795 -> 1794;
1795 -> 1399;
1795 -> 1397;
1796 -> 1595;
1797 -> 1796;
1797 -> 1435;
1798 -> 1797;
1798 -> 1437;
1798 -> 1435;
1799 -> 1433;
1799 -> 1465;
1799 -> 1591;
1799 -> 1798;
1799 -> 1600;
1799 -> 1461;
1799 -> 1462;
1799 -> 1784;
1799 -> 1472;
1799 -> 1464;
1800 -> 1615;
1801 -> 1800;
1801 -> 1484;
1802 -> 1801;
1802 -> 1486;
1802 -> 1484;
1803 -> 1482;
1803 -> 1516;
1803 -> 1611;
1803 -> 1802;
1803 -> 1620;
1803 -> 1510;
1803 -> 1511;
1803 -> 1788;
1803 -> 1518;
1803 -> 1515;
1804 -> 1635;
1805 -> 1804;
1805 -> 1530;
1806 -> 1805;
1806 -> 1532;
1806 -> 1530;
1807 -> 1528;
1807 -> 1562;
1807 -> 1631;
1807 -> 1806;
1807 -> 1640;
1807 -> 1556;
1807 -> 1557;
1807 -> 1792;
1807 -> 1564;
1807 -> 1561;
1808 -> 1576;
1809 -> 1808;
1809 -> 1397;
1810 -> 1809;
1810 -> 1399;
1810 -> 1397;
1811 -> 1595;
1812 -> 1811;
1812 -> 1435;
1813 -> 1812;
1813 -> 1437;
1813 -> 1435;
1814 -> 1433;
1814 -> 1465;
1814 -> 1591;
1814 -> 1813;
1814 -> 1600;
1814 -> 1461;
1814 -> 1462;
1814 -> 1799;
1814 -> 1472;
1814 -> 1464;
1815 -> 1615;
1816 -> 1815;
1816 -> 1484;
1817 -> 1816;
1817 -> 1486;
1817 -> 1484;
1818 -> 1482;
1818 -> 1516;
1818 -> 1611;
1818 -> 1817;
1818 -> 1620;
1818 -> 1510;
1818 -> 1511;
1818 -> 1803;
1818 -> 1518;
1818 -> 1515;
1819 -> 1635;
1820 -> 1819;
1820 -> 1530;
1821 -> 1820;
1821 -> 1532;
1821 -> 1530;
1822 -> 1528;
1822 -> 1562;
1822 -> 1631;
1822 -> 1821;
1822 -> 1640;
1822 -> 1556;
1822 -> 1557;
1822 -> 1807;
1822 -> 1564;
1822 -> 1561;
1823 -> 1576;
1824 -> 1823;
1824 -> 1397;
1825 -> 1824;
1825 -> 1399;
1825 -> 1397;
1826 -> 1595;
1827 -> 1826;
1827 -> 1435;
1828 -> 1827;
1828 -> 1437;
1828 -> 1435;
1829 -> 1433;
1829 -> 1465;
1829 -> 1591;
1829 -> 1828;
1829 -> 1600;
1829 -> 1461;
1829 -> 1462;
1829 -> 1814;
1829 -> 1472;
1829 -> 1464;
1830 -> 1615;
1831 -> 1830;
1831 -> 1484;
1832 -> 1831;
1832 -> 1486;
1832 -> 1484;
1833 -> 1482;
1833 -> 1516;
1833 -> 1611;
1833 -> 1832;
1833 -> 1620;
1833 -> 1510;
1833 -> 1511;
1833 -> 1818;
1833 -> 1518;
1833 -> 1515;
1834 -> 1635;
1835 -> 1834;
1835 -> 1530;
1836 -> 1835;
1836 -> 1532;
1836 -> 1530;
1837 -> 1528;
1837 -> 1562;
1837 -> 1631;
1837 -> 1836;
1837 -> 1640;
1837 -> 1556;
1837 -> 1557;
1837 -> 1822;
1837 -> 1564;
1837 -> 1561;
1838 -> 1576;
1839 -> 1838;
1839 -> 1397;
1840 -> 1839;
1840 -> 1399;
1840 -> 1397;
1841 -> 1595;
1842 -> 1841;
1842 -> 1435;
1843 -> 1842;
1843 -> 1437;
1843 -> 1435;
1844 -> 1433;
1844 -> 1465;
1844 -> 1591;
1844 -> 1843;
1844 -> 1600;
1844 -> 1461;
1844 -> 1462;
1844 -> 1829;
1844 -> 1472;
1844 -> 1464;
1845 -> 1615;
1846 -> 1845;
1846 -> 1484;
1847 -> 1846;
1847 -> 1486;
1847 -> 1484;
1848 -> 1482;
1848 -> 1516;
1848 -> 1611;
1848 -> 1847;
1848 -> 1620;
1848 -> 1510;
1848 -> 1511;
1848 -> 1833;
1848 -> 1518;
1848 -> 1515;
1849 -> 1635;
1850 -> 1849;
1850 -> 1530;
1851 -> 1850;
1851 -> 1532;
1851 -> 1530;
1852 -> 1528;
1852 -> 1562;
1852 -> 1631;
1852 -> 1851;
1852 -> 1640;
1852 -> 1556;
1852 -> 1557;
1852 -> 1837;
1852 -> 1564;
1852 -> 1561;
1853 -> 1576;
1854 -> 1853;
1854 -> 1397;
1855 -> 1854;
1855 -> 1399;
1855 -> 1397;
1856 -> 1595;
1857 -> 1856;
1857 -> 1435;
1858 -> 1857;
1858 -> 1437;
1858 -> 1435;
1859 -> 1433;
1859 -> 1465;
1859 -> 1591;
1859 -> 1858;
1859 -> 1600;
1859 -> 1461;
1859 -> 1462;
1859 -> 1844;
1859 -> 1472;
1859 -> 1464;
1860 -> 1615;
1861 -> 1860;
1861 -> 1484;
1862 -> 1861;
1862 -> 1486;
1862 -> 1484;
1863 -> 1482;
1863 -> 1516;
1863 -> 1611;
1863 -> 1862;
1863 -> 1620;
1863 -> 1510;
1863 -> 1511;
1863 -> 1848;
1863 -> 1518;
1863 -> 1515;
1864 -> 1635;
1865 -> 1864;
1865 -> 1530;
1866 -> 1865;
1866 -> 1532;
1866 -> 1530;
1867 -> 1528;
1867 -> 1562;
1867 -> 1631;
1867 -> 1866;
1867 -> 1640;
1867 -> 1556;
1867 -> 1557;
1867 -> 1852;
1867 -> 1564;
1867 -> 1561;
1868 -> 1576;
1869 -> 1868;
1869 -> 1397;
1870 -> 1869;
1870 -> 1399;
1870 -> 1397;
1871 -> 1595;
1872 -> 1871;
1872 -> 1435;
1873 -> 1872;
1873 -> 1437;
1873 -> 1435;
1874 -> 1433;
1874 -> 1465;
1874 -> 1591;
1874 -> 1873;
1874 -> 1600;
1874 -> 1461;
1874 -> 1462;
1874 -> 1859;
1874 -> 1472;
1874 -> 1464;
1875 -> 1615;
1876 -> 1875;
1876 -> 1484;
1877 -> 1876;
1877 -> 1486;
1877 -> 1484;
1878 -> 1482;
1878 -> 1516;
1878 -> 1611;
1878 -> 1877;
1878 -> 1620;
1878 -> 1510;
1878 -> 1511;
1878 -> 1863;
1878 -> 1518;
1878 -> 1515;
1879 -> 1635;
1880 -> 1879;
1880 -> 1530;
1881 -> 1880;
1881 -> 1532;
1881 -> 1530;
1882 -> 1528;
1882 -> 1562;
1882 -> 1631;
1882 -> 1881;
1882 -> 1640;
1882 -> 1556;
1882 -> 1557;
1882 -> 1867;
1882 -> 1564;
1882 -> 1561;
1883 -> 1576;
1884 -> 1883;
1884 -> 1397;
1885 -> 1884;
1885 -> 1399;
1885 -> 1397;
1886 -> 1595;
1887 -> 1886;
1887 -> 1435;
1888 -> 1887;
1888 -> 1437;
1888 -> 1435;
1889 -> 1433;
1889 -> 1465;
1889 -> 1591;
1889 -> 1888;
1889 -> 1600;
1889 -> 1461;
1889 -> 1462;
1889 -> 1874;
1889 -> 1472;
1889 -> 1464;
1890 -> 1615;
1891 -> 1890;
1891 -> 1484;
1892 -> 1891;
1892 -> 1486;
1892 -> 1484;
1893 -> 1482;
1893 -> 1516;
1893 -> 1611;
1893 -> 1892;
1893 -> 1620;
1893 -> 1510;
1893 -> 1511;
1893 -> 1878;
1893 -> 1518;
1893 -> 1515;
1894 -> 1635;
1895 -> 1894;
1895 -> 1530;
1896 -> 1895;
1896 -> 1532;
1896 -> 1530;
1897 -> 1528;
1897 -> 1562;
1897 -> 1631;
1897 -> 1896;
1897 -> 1640;
1897 -> 1556;
1897 -> 1557;
1897 -> 1882;
1897 -> 1564;
1897 -> 1561;
1898 -> 1576;
1899 -> 1898;
1899 -> 1397;
1900 -> 1899;
1900 -> 1399;
1900 -> 1397;
1901 -> 1595;
1902 -> 1901;
1902 -> 1435;
1903 -> 1902;
1903 -> 1437;
1903 -> 1435;
1904 -> 1433;
1904 -> 1465;
1904 -> 1591;
1904 -> 1903;
1904 -> 1600;
1904 -> 1461;
1904 -> 1462;
1904 -> 1889;
1904 -> 1472;
1904 -> 1464;
1905 -> 1615;
1906 -> 1905;
1906 -> 1484;
1907 -> 1906;
1907 -> 1486;
1907 -> 1484;
1908 -> 1482;
1908 -> 1516;
1908 -> 1611;
1908 -> 1907;
1908 -> 1620;
1908 -> 1510;
1908 -> 1511;
1908 -> 1893;
1908 -> 1518;
1908 -> 1515;
1909 -> 1635;
1910 -> 1909;
1910 -> 1530;
1911 -> 1910;
1911 -> 1532;
1911 -> 1530;
1912 -> 1528;
1912 -> 1562;
1912 -> 1631;
1912 -> 1911;
1912 -> 1640;
1912 -> 1556;
1912 -> 1557;
1912 -> 1897;
1912 -> 1564;
1912 -> 1561;
1913 -> 1576;
1914 -> 1913;
1914 -> 1397;
1915 -> 1914;
1915 -> 1399;
1915 -> 1397;
1916 -> 1595;
1917 -> 1916;
1917 -> 1435;
1918 -> 1917;
1918 -> 1437;
1918 -> 1435;
1919 -> 1433;
1919 -> 1465;
1919 -> 1591;
1919 -> 1918;
1919 -> 1600;
1919 -> 1461;
1919 -> 1462;
1919 -> 1904;
1919 -> 1472;
1919 -> 1464;
1920 -> 1615;
1921 -> 1920;
1921 -> 1484;
1922 -> 1921;
1922 -> 1486;
1922 -> 1484;
1923 -> 1482;
1923 -> 1516;
1923 -> 1611;
1923 -> 1922;
1923 -> 1620;
1923 -> 1510;
1923 -> 1511;
1923 -> 1908;
1923 -> 1518;
1923 -> 1515;
1924 -> 1635;
1925 -> 1924;
1925 -> 1530;
1926 -> 1925;
1926 -> 1532;
1926 -> 1530;
1927 -> 1528;
1927 -> 1562;
1927 -> 1631;
1927 -> 1926;
1927 -> 1640;
1927 -> 1556;
1927 -> 1557;
1927 -> 1912;
1927 -> 1564;
1927 -> 1561;
1928 -> 1576;
1929 -> 1928;
1929 -> 1397;
1930 -> 1929;
1930 -> 1399;
1930 -> 1397;
1931 -> 1595;
1932 -> 1931;
1932 -> 1435;
1933 -> 1932;
1933 -> 1437;
1933 -> 1435;
1934 -> 1433;
1934 -> 1465;
1934 -> 1591;
1934 -> 1933;
1934 -> 1600;
1934 -> 1461;
1934 -> 1462;
1934 -> 1919;
1934 -> 1472;
1934 -> 1464;
1935 -> 1615;
1936 -> 1935;
1936 -> 1484;
1937 -> 1936;
1937 -> 1486;
1937 -> 1484;
1938 -> 1482;
1938 -> 1516;
1938 -> 1611;
1938 -> 1937;
1938 -> 1620;
1938 -> 1510;
1938 -> 1511;
1938 -> 1923;
1938 -> 1518;
1938 -> 1515;
1939 -> 1635;
1940 -> 1939;
1940 -> 1530;
1941 -> 1940;
1941 -> 1532;
1941 -> 1530;
1942 -> 1528;
1942 -> 1562;
1942 -> 1631;
1942 -> 1941;
1942 -> 1640;
1942 -> 1556;
1942 -> 1557;
1942 -> 1927;
1942 -> 1564;
1942 -> 1561;
1943 -> 1576;
1944 -> 1943;
1944 -> 1397;
1945 -> 1944;
1945 -> 1399;
1945 -> 1397;
1946 -> 1595;
1947 -> 1946;
1947 -> 1435;
1948 -> 1947;
1948 -> 1437;
1948 -> 1435;
1949 -> 1433;
1949 -> 1465;
1949 -> 1591;
1949 -> 1948;
1949 -> 1600;
1949 -> 1461;
1949 -> 1462;
1949 -> 1934;
1949 -> 1472;
1949 -> 1464;
1950 -> 1615;
1951 -> 1950;
1951 -> 1484;
1952 -> 1951;
1952 -> 1486;
1952 -> 1484;
1953 -> 1482;
1953 -> 1516;
1953 -> 1611;
1953 -> 1952;
1953 -> 1620;
1953 -> 1510;
1953 -> 1511;
1953 -> 1938;
1953 -> 1518;
1953 -> 1515;
1954 -> 1635;
1955 -> 1954;
1955 -> 1530;
1956 -> 1955;
1956 -> 1532;
1956 -> 1530;
1957 -> 1528;
1957 -> 1562;
1957 -> 1631;
1957 -> 1956;
1957 -> 1640;
1957 -> 1556;
1957 -> 1557;
1957 -> 1942;
1957 -> 1564;
1957 -> 1561;
1958 -> 1576;
1959 -> 1958;
1959 -> 1397;
1960 -> 1959;
1960 -> 1399;
1960 -> 1397;
1961 -> 1595;
1962 -> 1961;
1962 -> 1435;
1963 -> 1962;
1963 -> 1437;
1963 -> 1435;
1964 -> 1433;
1964 -> 1465;
1964 -> 1591;
1964 -> 1963;
1964 -> 1600;
1964 -> 1461;
1964 -> 1462;
1964 -> 1949;
1964 -> 1472;
1964 -> 1464;
1965 -> 1615;
1966 -> 1965;
1966 -> 1484;
1967 -> 1966;
1967 -> 1486;
1967 -> 1484;
1968 -> 1482;
1968 -> 1516;
1968 -> 1611;
1968 -> 1967;
1968 -> 1620;
1968 -> 1510;
1968 -> 1511;
1968 -> 1953;
1968 -> 1518;
1968 -> 1515;
1969 -> 1635;
1970 -> 1969;
1970 -> 1530;
1971 -> 1970;
1971 -> 1532;
1971 -> 1530;
1972 -> 1528;
1972 -> 1562;
1972 -> 1631;
1972 -> 1971;
1972 -> 1640;
1972 -> 1556;
1972 -> 1557;
1972 -> 1957;
1972 -> 1564;
1972 -> 1561;
1973 -> 1576;
1974 -> 1973;
1974 -> 1397;
1975 -> 1974;
1975 -> 1399;
1975 -> 1397;
1976 -> 1595;
1977 -> 1976;
1977 -> 1435;
1978 -> 1977;
1978 -> 1437;
1978 -> 1435;
1979 -> 1433;
1979 -> 1465;
1979 -> 1591;
1979 -> 1978;
1979 -> 1600;
1979 -> 1461;
1979 -> 1462;
1979 -> 1964;
1979 -> 1472;
1979 -> 1464;
1980 -> 1615;
1981 -> 1980;
1981 -> 1484;
1982 -> 1981;
1982 -> 1486;
1982 -> 1484;
1983 -> 1482;
1983 -> 1516;
1983 -> 1611;
1983 -> 1982;
1983 -> 1620;
1983 -> 1510;
1983 -> 1511;
1983 -> 1968;
1983 -> 1518;
1983 -> 1515;
1984 -> 1635;
1985 -> 1984;
1985 -> 1530;
1986 -> 1985;
1986 -> 1532;
1986 -> 1530;
1987 -> 1528;
1987 -> 1562;
1987 -> 1631;
1987 -> 1986;
1987 -> 1640;
1987 -> 1556;
1987 -> 1557;
1987 -> 1972;
1987 -> 1564;
1987 -> 1561;
1988 -> 1576;
1989 -> 1988;
1989 -> 1397;
1990 -> 1989;
1990 -> 1399;
1990 -> 1397;
1991 -> 1595;
1992 -> 1991;
1992 -> 1435;
1993 -> 1992;
1993 -> 1437;
1993 -> 1435;
1994 -> 1433;
1994 -> 1465;
1994 -> 1591;
1994 -> 1993;
1994 -> 1600;
1994 -> 1461;
1994 -> 1462;
1994 -> 1979;
1994 -> 1472;
1994 -> 1464;
1995 -> 1615;
1996 -> 1995;
1996 -> 1484;
1997 -> 1996;
1997 -> 1486;
1997 -> 1484;
1998 -> 1482;
1998 -> 1516;
1998 -> 1611;
1998 -> 1997;
1998 -> 1620;
1998 -> 1510;
1998 -> 1511;
1998 -> 1983;
1998 -> 1518;
1998 -> 1515;
1999 -> 1635;
2000 -> 1999;
2000 -> 1530;
2001 -> 2000;
2001 -> 1532;
2001 -> 1530;
2002 -> 1528;
2002 -> 1562;
2002 -> 1631;
2002 -> 2001;
2002 -> 1640;
2002 -> 1556;
2002 -> 1557;
2002 -> 1987;
2002 -> 1564;
2002 -> 1561;
2003 -> 1576;
2004 -> 2003;
2004 -> 1397;
2005 -> 2004;
2005 -> 1399;
2005 -> 1397;
2006 -> 1595;
2007 -> 2006;
2007 -> 1435;
2008 -> 2007;
2008 -> 1437;
2008 -> 1435;
2009 -> 1433;
2009 -> 1465;
2009 -> 1591;
2009 -> 2008;
2009 -> 1600;
2009 -> 1461;
2009 -> 1462;
2009 -> 1994;
2009 -> 1472;
2009 -> 1464;
2010 -> 1615;
2011 -> 2010;
2011 -> 1484;
2012 -> 2011;
2012 -> 1486;
2012 -> 1484;
2013 -> 1482;
2013 -> 1516;
2013 -> 1611;
2013 -> 2012;
2013 -> 1620;
2013 -> 1510;
2013 -> 1511;
2013 -> 1998;
2013 -> 1518;
2013 -> 1515;
2014 -> 1635;
2015 -> 2014;
2015 -> 1530;
2016 -> 2015;
2016 -> 1532;
2016 -> 1530;
2017 -> 1528;
2017 -> 1562;
2017 -> 1631;
2017 -> 2016;
2017 -> 1640;
2017 -> 1556;
2017 -> 1557;
2017 -> 2002;
2017 -> 1564;
2017 -> 1561;
2018 -> 1576;
2019 -> 2018;
2019 -> 1397;
2020 -> 2019;
2020 -> 1399;
2020 -> 1397;
2021 -> 1595;
2022 -> 2021;
2022 -> 1435;
2023 -> 2022;
2023 -> 1437;
2023 -> 1435;
2024 -> 1433;
2024 -> 1465;
2024 -> 1591;
2024 -> 2023;
2024 -> 1600;
2024 -> 1461;
2024 -> 1462;
2024 -> 2009;
2024 -> 1472;
2024 -> 1464;
2025 -> 1615;
2026 -> 2025;
2026 -> 1484;
2027 -> 2026;
2027 -> 1486;
2027 -> 1484;
2028 -> 1482;
2028 -> 1516;
2028 -> 1611;
2028 -> 2027;
2028 -> 1620;
2028 -> 1510;
2028 -> 1511;
2028 -> 2013;
2028 -> 1518;
2028 -> 1515;
2029 -> 1635;
2030 -> 2029;
2030 -> 1530;
2031 -> 2030;
2031 -> 1532;
2031 -> 1530;
2032 -> 1528;
2032 -> 1562;
2032 -> 1631;
2032 -> 2031;
2032 -> 1640;
2032 -> 1556;
2032 -> 1557;
2032 -> 2017;
2032 -> 1564;
2032 -> 1561;
2033 -> 1576;
2034 -> 2033;
2034 -> 1397;
2035 -> 2034;
2035 -> 1399;
2035 -> 1397;
2036 -> 1595;
2037 -> 2036;
2037 -> 1435;
2038 -> 2037;
2038 -> 1437;
2038 -> 1435;
2039 -> 1433;
2039 -> 1465;
2039 -> 1591;
2039 -> 2038;
2039 -> 1600;
2039 -> 1461;
2039 -> 1462;
2039 -> 2024;
2039 -> 1472;
2039 -> 1464;
2040 -> 1615;
2041 -> 2040;
2041 -> 1484;
2042 -> 2041;
2042 -> 1486;
2042 -> 1484;
2043 -> 1482;
2043 -> 1516;
2043 -> 1611;
2043 -> 2042;
2043 -> 1620;
2043 -> 1510;
2043 -> 1511;
2043 -> 2028;
2043 -> 1518;
2043 -> 1515;
2044 -> 1635;
2045 -> 2044;
2045 -> 1530;
2046 -> 2045;
2046 -> 1532;
2046 -> 1530;
2047 -> 1528;
2047 -> 1562;
2047 -> 1631;
2047 -> 2046;
2047 -> 1640;
2047 -> 1556;
2047 -> 1557;
2047 -> 2032;
2047 -> 1564;
2047 -> 1561;
2048 -> 1576;
2049 -> 2048;
2049 -> 1397;
2050 -> 2049;
2050 -> 1399;
2050 -> 1397;
2051 -> 1595;
2052 -> 2051;
2052 -> 1435;
2053 -> 2052;
2053 -> 1437;
2053 -> 1435;
2054 -> 1433;
2054 -> 1465;
2054 -> 1591;
2054 -> 2053;
2054 -> 1600;
2054 -> 1461;
2054 -> 1462;
2054 -> 2039;
2054 -> 1472;
2054 -> 1464;
2055 -> 1615;
2056 -> 2055;
2056 -> 1484;
2057 -> 2056;
2057 -> 1486;
2057 -> 1484;
2058 -> 1482;
2058 -> 1516;
2058 -> 1611;
2058 -> 2057;
2058 -> 1620;
2058 -> 1510;
2058 -> 1511;
2058 -> 2043;
2058 -> 1518;
2058 -> 1515;
2059 -> 1635;
2060 -> 2059;
2060 -> 1530;
2061 -> 2060;
2061 -> 1532;
2061 -> 1530;
2062 -> 1528;
2062 -> 1562;
2062 -> 1631;
2062 -> 2061;
2062 -> 1640;
2062 -> 1556;
2062 -> 1557;
2062 -> 2047;
2062 -> 1564;
2062 -> 1561;
2063 -> 0;
2063 -> 1576;
2064 -> 2063;
2064 -> 1397;
2065 -> 2064;
2065 -> 1399;
2065 -> 1397;
2066 -> 0;
2066 -> 1595;
2067 -> 2066;
2067 -> 1435;
2068 -> 2067;
2068 -> 1437;
2068 -> 1435;
2069 -> 1433;
2069 -> 1465;
2069 -> 1591;
2069 -> 2068;
2069 -> 1600;
2069 -> 1461;
2069 -> 1462;
2069 -> 2054;
2069 -> 1472;
2069 -> 1464;
2070 -> 0;
2070 -> 1615;
2071 -> 2070;
2071 -> 1484;
2072 -> 2071;
2072 -> 1486;
2072 -> 1484;
2073 -> 1482;
2073 -> 1516;
2073 -> 1611;
2073 -> 2072;
2073 -> 1620;
2073 -> 1510;
2073 -> 1511;
2073 -> 2058;
2073 -> 1518;
2073 -> 1515;
2074 -> 0;
2074 -> 1635;
2075 -> 2074;
2075 -> 1530;
2076 -> 2075;
2076 -> 1532;
2076 -> 1530;
2077 -> 1528;
2077 -> 1562;
2077 -> 1631;
2077 -> 2076;
2077 -> 1640;
2077 -> 1556;
2077 -> 1557;
2077 -> 2062;
2077 -> 1564;
2077 -> 1561;
2078 -> 1576;
2079 -> 2078;
2079 -> 1397;
2080 -> 2079;
2080 -> 1399;
2080 -> 1397;
2081 -> 1595;
2082 -> 2081;
2082 -> 1435;
2083 -> 2082;
2083 -> 1437;
2083 -> 1435;
2084 -> 1433;
2084 -> 1465;
2084 -> 1591;
2084 -> 2083;
2084 -> 1600;
2084 -> 1461;
2084 -> 1462;
2084 -> 2069;
2084 -> 1472;
2084 -> 1464;
2085 -> 1615;
2086 -> 2085;
2086 -> 1484;
2087 -> 2086;
2087 -> 1486;
2087 -> 1484;
2088 -> 1482;
2088 -> 1516;
2088 -> 1611;
2088 -> 2087;
2088 -> 1620;
2088 -> 1510;
2088 -> 1511;
2088 -> 2073;
2088 -> 1518;
2088 -> 1515;
2089 -> 1635;
2090 -> 2089;
2090 -> 1530;
2091 -> 2090;
2091 -> 1532;
2091 -> 1530;
2092 -> 1528;
2092 -> 1562;
2092 -> 1631;
2092 -> 2091;
2092 -> 1640;
2092 -> 1556;
2092 -> 1557;
2092 -> 2077;
2092 -> 1564;
2092 -> 1561;
2093 -> 1576;
2094 -> 2093;
2094 -> 1397;
2095 -> 2094;
2095 -> 1399;
2095 -> 1397;
2096 -> 1595;
2097 -> 2096;
2097 -> 1435;
2098 -> 2097;
2098 -> 1437;
2098 -> 1435;
2099 -> 1433;
2099 -> 1465;
2099 -> 1591;
2099 -> 2098;
2099 -> 1600;
2099 -> 1461;
2099 -> 1462;
2099 -> 2084;
2099 -> 1472;
2099 -> 1464;
2100 -> 1615;
2101 -> 2100;
2101 -> 1484;
2102 -> 2101;
2102 -> 1486;
2102 -> 1484;
2103 -> 1482;
2103 -> 1516;
2103 -> 1611;
2103 -> 2102;
2103 -> 1620;
2103 -> 1510;
2103 -> 1511;
2103 -> 2088;
2103 -> 1518;
2103 -> 1515;
2104 -> 1635;
2105 -> 2104;
2105 -> 1530;
2106 -> 2105;
2106 -> 1532;
2106 -> 1530;
2107 -> 1528;
2107 -> 1562;
2107 -> 1631;
2107 -> 2106;
2107 -> 1640;
2107 -> 1556;
2107 -> 1557;
2107 -> 2092;
2107 -> 1564;
2107 -> 1561;
2108 -> 1576;
2109 -> 2108;
2109 -> 1397;
2110 -> 2109;
2110 -> 1399;
2110 -> 1397;
2111 -> 1595;
2112 -> 2111;
2112 -> 1435;
2113 -> 2112;
2113 -> 1437;
2113 -> 1435;
2114 -> 1433;
2114 -> 1465;
2114 -> 1591;
2114 -> 2113;
2114 -> 1600;
2114 -> 1461;
2114 -> 1462;
2114 -> 2099;
2114 -> 1472;
2114 -> 1464;
2115 -> 1615;
2116 -> 2115;
2116 -> 1484;
2117 -> 2116;
2117 -> 1486;
2117 -> 1484;
2118 -> 1482;
2118 -> 1516;
2118 -> 1611;
2118 -> 2117;
2118 -> 1620;
2118 -> 1510;
2118 -> 1511;
2118 -> 2103;
2118 -> 1518;
2118 -> 1515;
2119 -> 1635;
2120 -> 2119;
2120 -> 1530;
2121 -> 2120;
2121 -> 1532;
2121 -> 1530;
2122 -> 1528;
2122 -> 1562;
2122 -> 1631;
2122 -> 2121;
2122 -> 1640;
2122 -> 1556;
2122 -> 1557;
2122 -> 2107;
2122 -> 1564;
2122 -> 1561;
2123 -> 1576;
2124 -> 2123;
2124 -> 1397;
2125 -> 2124;
2125 -> 1399;
2125 -> 1397;
2126 -> 1595;
2127 -> 2126;
2127 -> 1435;
2128 -> 2127;
2128 -> 1437;
2128 -> 1435;
2129 -> 1433;
2129 -> 1465;
2129 -> 1591;
2129 -> 2128;
2129 -> 1600;
2129 -> 1461;
2129 -> 1462;
2129 -> 2114;
2129 -> 1472;
2129 -> 1464;
2130 -> 1615;
2131 -> 2130;
2131 -> 1484;
2132 -> 2131;
2132 -> 1486;
2132 -> 1484;
2133 -> 1482;
2133 -> 1516;
2133 -> 1611;
2133 -> 2132;
2133 -> 1620;
2133 -> 1510;
2133 -> 1511;
2133 -> 2118;
2133 -> 1518;
2133 -> 1515;
2134 -> 1635;
2135 -> 2134;
2135 -> 1530;
2136 -> 2135;
2136 -> 1532;
2136 -> 1530;
2137 -> 1528;
2137 -> 1562;
2137 -> 1631;
2137 -> 2136;
2137 -> 1640;
2137 -> 1556;
2137 -> 1557;
2137 -> 2122;
2137 -> 1564;
2137 -> 1561;
2138 -> 1576;
2139 -> 2138;
2139 -> 1397;
2140 -> 2139;
2140 -> 1399;
2140 -> 1397;
2141 -> 1595;
2142 -> 2141;
2142 -> 1435;
2143 -> 2142;
2143 -> 1437;
2143 -> 1435;
2144 -> 1433;
2144 -> 1465;
2144 -> 1591;
2144 -> 2143;
2144 -> 1600;
2144 -> 1461;
2144 -> 1462;
2144 -> 2129;
2144 -> 1472;
2144 -> 1464;
2145 -> 1615;
2146 -> 2145;
2146 -> 1484;
2147 -> 2146;
2147 -> 1486;
2147 -> 1484;
2148 -> 1482;
2148 -> 1516;
2148 -> 1611;
2148 -> 2147;
2148 -> 1620;
2148 -> 1510;
2148 -> 1511;
2148 -> 2133;
2148 -> 1518;
2148 -> 1515;
2149 -> 1635;
2150 -> 2149;
2150 -> 1530;
2151 -> 2150;
2151 -> 1532;
2151 -> 1530;
2152 -> 1528;
2152 -> 1562;
2152 -> 1631;
2152 -> 2151;
2152 -> 1640;
2152 -> 1556;
2152 -> 1557;
2152 -> 2137;
2152 -> 1564;
2152 -> 1561;
2153 -> 1576;
2154 -> 2153;
2154 -> 1397;
2155 -> 2154;
2155 -> 1399;
2155 -> 1397;
2156 -> 1595;
2157 -> 2156;
2157 -> 1435;
2158 -> 2157;
2158 -> 1437;
2158 -> 1435;
2159 -> 1433;
2159 -> 1465;
2159 -> 1591;
2159 -> 2158;
2159 -> 1600;
2159 -> 1461;
2159 -> 1462;
2159 -> 2144;
2159 -> 1472;
2159 -> 1464;
2160 -> 1615;
2161 -> 2160;
2161 -> 1484;
2162 -> 2161;
2162 -> 1486;
2162 -> 1484;
2163 -> 1482;
2163 -> 1516;
2163 -> 1611;
2163 -> 2162;
2163 -> 1620;
2163 -> 1510;
2163 -> 1511;
2163 -> 2148;
2163 -> 1518;
2163 -> 1515;
2164 -> 1635;
2165 -> 2164;
2165 -> 1530;
2166 -> 2165;
2166 -> 1532;
2166 -> 1530;
2167 -> 1528;
2167 -> 1562;
2167 -> 1631;
2167 -> 2166;
2167 -> 1640;
2167 -> 1556;
2167 -> 1557;
2167 -> 2152;
2167 -> 1564;
2167 -> 1561;
2168 -> 1576;
2169 -> 2168;
2169 -> 1397;
2170 -> 2169;
2170 -> 1399;
2170 -> 1397;
2171 -> 1595;
2172 -> 2171;
2172 -> 1435;
2173 -> 2172;
2173 -> 1437;
2173 -> 1435;
2174 -> 1433;
2174 -> 1465;
2174 -> 1591;
2174 -> 2173;
2174 -> 1600;
2174 -> 1461;
2174 -> 1462;
2174 -> 2159;
2174 -> 1472;
2174 -> 1464;
2175 -> 1615;
2176 -> 2175;
2176 -> 1484;
2177 -> 2176;
2177 -> 1486;
2177 -> 1484;
2178 -> 1482;
2178 -> 1516;
2178 -> 1611;
2178 -> 2177;
2178 -> 1620;
2178 -> 1510;
2178 -> 1511;
2178 -> 2163;
2178 -> 1518;
2178 -> 1515;
2179 -> 1635;
2180 -> 2179;
2180 -> 1530;
2181 -> 2180;
2181 -> 1532;
2181 -> 1530;
2182 -> 1528;
2182 -> 1562;
2182 -> 1631;
2182 -> 2181;
2182 -> 1640;
2182 -> 1556;
2182 -> 1557;
2182 -> 2167;
2182 -> 1564;
2182 -> 1561;
2183 -> 1576;
2184 -> 2183;
2184 -> 1397;
2185 -> 2184;
2185 -> 1399;
2185 -> 1397;
2186 -> 1595;
2187 -> 2186;
2187 -> 1435;
2188 -> 2187;
2188 -> 1437;
2188 -> 1435;
2189 -> 1433;
2189 -> 1465;
2189 -> 1591;
2189 -> 2188;
2189 -> 1600;
2189 -> 1461;
2189 -> 1462;
2189 -> 2174;
2189 -> 1472;
2189 -> 1464;
2190 -> 1615;
2191 -> 2190;
2191 -> 1484;
2192 -> 2191;
2192 -> 1486;
2192 -> 1484;
2193 -> 1482;
2193 -> 1516;
2193 -> 1611;
2193 -> 2192;
2193 -> 1620;
2193 -> 1510;
2193 -> 1511;
2193 -> 2178;
2193 -> 1518;
2193 -> 1515;
2194 -> 1635;
2195 -> 2194;
2195 -> 1530;
2196 -> 2195;
2196 -> 1532;
2196 -> 1530;
2197 -> 1528;
2197 -> 1562;
2197 -> 1631;
2197 -> 2196;
2197 -> 1640;
2197 -> 1556;
2197 -> 1557;
2197 -> 2182;
2197 -> 1564;
2197 -> 1561;
2198 -> 1576;
2199 -> 2198;
2199 -> 1397;
2200 -> 2199;
2200 -> 1399;
2200 -> 1397;
2201 -> 1595;
2202 -> 2201;
2202 -> 1435;
2203 -> 2202;
2203 -> 1437;
2203 -> 1435;
2204 -> 1433;
2204 -> 1465;
2204 -> 1591;
2204 -> 2203;
2204 -> 1600;
2204 -> 1461;
2204 -> 1462;
2204 -> 2189;
2204 -> 1472;
2204 -> 1464;
2205 -> 1615;
2206 -> 2205;
2206 -> 1484;
2207 -> 2206;
2207 -> 1486;
2207 -> 1484;
2208 -> 1482;
2208 -> 1516;
2208 -> 1611;
2208 -> 2207;
2208 -> 1620;
2208 -> 1510;
2208 -> 1511;
2208 -> 2193;
2208 -> 1518;
2208 -> 1515;
2209 -> 1635;
2210 -> 2209;
2210 -> 1530;
2211 -> 2210;
2211 -> 1532;
2211 -> 1530;
2212 -> 1528;
2212 -> 1562;
2212 -> 1631;
2212 -> 2211;
2212 -> 1640;
2212 -> 1556;
2212 -> 1557;
2212 -> 2197;
2212 -> 1564;
2212 -> 1561;
2213 -> 1576;
2214 -> 2213;
2214 -> 1397;
2215 -> 2214;
2215 -> 1399;
2215 -> 1397;
2216 -> 1595;
2217 -> 2216;
2217 -> 1435;
2218 -> 2217;
2218 -> 1437;
2218 -> 1435;
2219 -> 1433;
2219 -> 1465;
2219 -> 1591;
2219 -> 2218;
2219 -> 1600;
2219 -> 1461;
2219 -> 1462;
2219 -> 2204;
2219 -> 1472;
2219 -> 1464;
2220 -> 1615;
2221 -> 2220;
2221 -> 1484;
2222 -> 2221;
2222 -> 1486;
2222 -> 1484;
2223 -> 1482;
2223 -> 1516;
2223 -> 1611;
2223 -> 2222;
2223 -> 1620;
2223 -> 1510;
2223 -> 1511;
2223 -> 2208;
2223 -> 1518;
2223 -> 1515;
2224 -> 1635;
2225 -> 2224;
2225 -> 1530;
2226 -> 2225;
2226 -> 1532;
2226 -> 1530;
2227 -> 1528;
2227 -> 1562;
2227 -> 1631;
2227 -> 2226;
2227 -> 1640;
2227 -> 1556;
2227 -> 1557;
2227 -> 2212;
2227 -> 1564;
2227 -> 1561;
2228 -> 1576;
2229 -> 2228;
2229 -> 1397;
2230 -> 2229;
2230 -> 1399;
2230 -> 1397;
2231 -> 1595;
2232 -> 2231;
2232 -> 1435;
2233 -> 2232;
2233 -> 1437;
2233 -> 1435;
2234 -> 1433;
2234 -> 1465;
2234 -> 1591;
2234 -> 2233;
2234 -> 1600;
2234 -> 1461;
2234 -> 1462;
2234 -> 2219;
2234 -> 1472;
2234 -> 1464;
2235 -> 1615;
2236 -> 2235;
2236 -> 1484;
2237 -> 2236;
2237 -> 1486;
2237 -> 1484;
2238 -> 1482;
2238 -> 1516;
2238 -> 1611;
2238 -> 2237;
2238 -> 1620;
2238 -> 1510;
2238 -> 1511;
2238 -> 2223;
2238 -> 1518;
2238 -> 1515;
2239 -> 1635;
2240 -> 2239;
2240 -> 1530;
2241 -> 2240;
2241 -> 1532;
2241 -> 1530;
2242 -> 1528;
2242 -> 1562;
2242 -> 1631;
2242 -> 2241;
2242 -> 1640;
2242 -> 1556;
2242 -> 1557;
2242 -> 2227;
2242 -> 1564;
2242 -> 1561;
2243 -> 1576;
2244 -> 2243;
2244 -> 1397;
2245 -> 2244;
2245 -> 1399;
2245 -> 1397;
2246 -> 1595;
2247 -> 2246;
2247 -> 1435;
2248 -> 2247;
2248 -> 1437;
2248 -> 1435;
2249 -> 1433;
2249 -> 1465;
2249 -> 1591;
2249 -> 2248;
2249 -> 1600;
2249 -> 1461;
2249 -> 1462;
2249 -> 2234;
2249 -> 1472;
2249 -> 1464;
2250 -> 1615;
2251 -> 2250;
2251 -> 1484;
2252 -> 2251;
2252 -> 1486;
2252 -> 1484;
2253 -> 1482;
2253 -> 1516;
2253 -> 1611;
2253 -> 2252;
2253 -> 1620;
2253 -> 1510;
2253 -> 1511;
2253 -> 2238;
2253 -> 1518;
2253 -> 1515;
2254 -> 1635;
2255 -> 2254;
2255 -> 1530;
2256 -> 2255;
2256 -> 1532;
2256 -> 1530;
2257 -> 1528;
2257 -> 1562;
2257 -> 1631;
2257 -> 2256;
2257 -> 1640;
2257 -> 1556;
2257 -> 1557;
2257 -> 2242;
2257 -> 1564;
2257 -> 1561;
2258 -> 1576;
2259 -> 2258;
2259 -> 1397;
2260 -> 2259;
2260 -> 1399;
2260 -> 1397;
2261 -> 1595;
2262 -> 2261;
2262 -> 1435;
2263 -> 2262;
2263 -> 1437;
2263 -> 1435;
2264 -> 1433;
2264 -> 1465;
2264 -> 1591;
2264 -> 2263;
2264 -> 1600;
2264 -> 1461;
2264 -> 1462;
2264 -> 2249;
2264 -> 1472;
2264 -> 1464;
2265 -> 1615;
2266 -> 2265;
2266 -> 1484;
2267 -> 2266;
2267 -> 1486;
2267 -> 1484;
2268 -> 1482;
2268 -> 1516;
2268 -> 1611;
2268 -> 2267;
2268 -> 1620;
2268 -> 1510;
2268 -> 1511;
2268 -> 2253;
2268 -> 1518;
2268 -> 1515;
2269 -> 1635;
2270 -> 2269;
2270 -> 1530;
2271 -> 2270;
2271 -> 1532;
2271 -> 1530;
2272 -> 1528;
2272 -> 1562;
2272 -> 1631;
2272 -> 2271;
2272 -> 1640;
2272 -> 1556;
2272 -> 1557;
2272 -> 2257;
2272 -> 1564;
2272 -> 1561;
2273 -> 1576;
2274 -> 2273;
2274 -> 1397;
2275 -> 2274;
2275 -> 1399;
2275 -> 1397;
2276 -> 1595;
2277 -> 2276;
2277 -> 1435;
2278 -> 2277;
2278 -> 1437;
2278 -> 1435;
2279 -> 1433;
2279 -> 1465;
2279 -> 1591;
2279 -> 2278;
2279 -> 1600;
2279 -> 1461;
2279 -> 1462;
2279 -> 2264;
2279 -> 1472;
2279 -> 1464;
2280 -> 1615;
2281 -> 2280;
2281 -> 1484;
2282 -> 2281;
2282 -> 1486;
2282 -> 1484;
2283 -> 1482;
2283 -> 1516;
2283 -> 1611;
2283 -> 2282;
2283 -> 1620;
2283 -> 1510;
2283 -> 1511;
2283 -> 2268;
2283 -> 1518;
2283 -> 1515;
2284 -> 1635;
2285 -> 2284;
2285 -> 1530;
2286 -> 2285;
2286 -> 1532;
2286 -> 1530;
2287 -> 1528;
2287 -> 1562;
2287 -> 1631;
2287 -> 2286;
2287 -> 1640;
2287 -> 1556;
2287 -> 1557;
2287 -> 2272;
2287 -> 1564;
2287 -> 1561;
2288 -> 1576;
2289 -> 2288;
2289 -> 1397;
2290 -> 2289;
2290 -> 1399;
2290 -> 1397;
2291 -> 1595;
2292 -> 2291;
2292 -> 1435;
2293 -> 2292;
2293 -> 1437;
2293 -> 1435;
2294 -> 1433;
2294 -> 1465;
2294 -> 1591;
2294 -> 2293;
2294 -> 1600;
2294 -> 1461;
2294 -> 1462;
2294 -> 2279;
2294 -> 1472;
2294 -> 1464;
2295 -> 1615;
2296 -> 2295;
2296 -> 1484;
2297 -> 2296;
2297 -> 1486;
2297 -> 1484;
2298 -> 1482;
2298 -> 1516;
2298 -> 1611;
2298 -> 2297;
2298 -> 1620;
2298 -> 1510;
2298 -> 1511;
2298 -> 2283;
2298 -> 1518;
2298 -> 1515;
2299 -> 1635;
2300 -> 2299;
2300 -> 1530;
2301 -> 2300;
2301 -> 1532;
2301 -> 1530;
2302 -> 1528;
2302 -> 1562;
2302 -> 1631;
2302 -> 2301;
2302 -> 1640;
2302 -> 1556;
2302 -> 1557;
2302 -> 2287;
2302 -> 1564;
2302 -> 1561;
2303 -> 1576;
2304 -> 2303;
2304 -> 1397;
2305 -> 2304;
2305 -> 1399;
2305 -> 1397;
2306 -> 1595;
2307 -> 2306;
2307 -> 1435;
2308 -> 2307;
2308 -> 1437;
2308 -> 1435;
2309 -> 1433;
2309 -> 1465;
2309 -> 1591;
2309 -> 2308;
2309 -> 1600;
2309 -> 1461;
2309 -> 1462;
2309 -> 2294;
2309 -> 1472;
2309 -> 1464;
2310 -> 1615;
2311 -> 2310;
2311 -> 1484;
2312 -> 2311;
2312 -> 1486;
2312 -> 1484;
2313 -> 1482;
2313 -> 1516;
2313 -> 1611;
2313 -> 2312;
2313 -> 1620;
2313 -> 1510;
2313 -> 1511;
2313 -> 2298;
2313 -> 1518;
2313 -> 1515;
2314 -> 1635;
2315 -> 2314;
2315 -> 1530;
2316 -> 2315;
2316 -> 1532;
2316 -> 1530;
2317 -> 1528;
2317 -> 1562;
2317 -> 1631;
2317 -> 2316;
2317 -> 1640;
2317 -> 1556;
2317 -> 1557;
2317 -> 2302;
2317 -> 1564;
2317 -> 1561;
2318 -> 1576;
2319 -> 2318;
2319 -> 1397;
2320 -> 2319;
2320 -> 1399;
2320 -> 1397;
2321 -> 1595;
2322 -> 2321;
2322 -> 1435;
2323 -> 2322;
2323 -> 1437;
2323 -> 1435;
2324 -> 1433;
2324 -> 1465;
2324 -> 1591;
2324 -> 2323;
2324 -> 1600;
2324 -> 1461;
2324 -> 1462;
2324 -> 2309;
2324 -> 1472;
2324 -> 1464;
2325 -> 1615;
2326 -> 2325;
2326 -> 1484;
2327 -> 2326;
2327 -> 1486;
2327 -> 1484;
2328 -> 1482;
2328 -> 1516;
2328 -> 1611;
2328 -> 2327;
2328 -> 1620;
2328 -> 1510;
2328 -> 1511;
2328 -> 2313;
2328 -> 1518;
2328 -> 1515;
2329 -> 1635;
2330 -> 2329;
2330 -> 1530;
2331 -> 2330;
2331 -> 1532;
2331 -> 1530;
2332 -> 1528;
2332 -> 1562;
2332 -> 1631;
2332 -> 2331;
2332 -> 1640;
2332 -> 1556;
2332 -> 1557;
2332 -> 2317;
2332 -> 1564;
2332 -> 1561;
2333 -> 1576;
2334 -> 2333;
2334 -> 1397;
2335 -> 2334;
2335 -> 1399;
2335 -> 1397;
2336 -> 1595;
2337 -> 2336;
2337 -> 1435;
2338 -> 2337;
2338 -> 1437;
2338 -> 1435;
2339 -> 1433;
2339 -> 1465;
2339 -> 1591;
2339 -> 2338;
2339 -> 1600;
2339 -> 1461;
2339 -> 1462;
2339 -> 2324;
2339 -> 1472;
2339 -> 1464;
2340 -> 1615;
2341 -> 2340;
2341 -> 1484;
2342 -> 2341;
2342 -> 1486;
2342 -> 1484;
2343 -> 1482;
2343 -> 1516;
2343 -> 1611;
2343 -> 2342;
2343 -> 1620;
2343 -> 1510;
2343 -> 1511;
2343 -> 2328;
2343 -> 1518;
2343 -> 1515;
2344 -> 1635;
2345 -> 2344;
2345 -> 1530;
2346 -> 2345;
2346 -> 1532;
2346 -> 1530;
2347 -> 1528;
2347 -> 1562;
2347 -> 1631;
2347 -> 2346;
2347 -> 1640;
2347 -> 1556;
2347 -> 1557;
2347 -> 2332;
2347 -> 1564;
2347 -> 1561;
2348 -> 1576;
2349 -> 2348;
2349 -> 1397;
2350 -> 2349;
2350 -> 1399;
2350 -> 1397;
2351 -> 1595;
2352 -> 2351;
2352 -> 1435;
2353 -> 2352;
2353 -> 1437;
2353 -> 1435;
2354 -> 1433;
2354 -> 1465;
2354 -> 1591;
2354 -> 2353;
2354 -> 1600;
2354 -> 1461;
2354 -> 1462;
2354 -> 2339;
2354 -> 1472;
2354 -> 1464;
2355 -> 1615;
2356 -> 2355;
2356 -> 1484;
2357 -> 2356;
2357 -> 1486;
2357 -> 1484;
2358 -> 1482;
2358 -> 1516;
2358 -> 1611;
2358 -> 2357;
2358 -> 1620;
2358 -> 1510;
2358 -> 1511;
2358 -> 2343;
2358 -> 1518;
2358 -> 1515;
2359 -> 1635;
2360 -> 2359;
2360 -> 1530;
2361 -> 2360;
2361 -> 1532;
2361 -> 1530;
2362 -> 1528;
2362 -> 1562;
2362 -> 1631;
2362 -> 2361;
2362 -> 1640;
2362 -> 1556;
2362 -> 1557;
2362 -> 2347;
2362 -> 1564;
2362 -> 1561;
2363 -> 1576;
2364 -> 2363;
2364 -> 1397;
2365 -> 2364;
2365 -> 1399;
2365 -> 1397;
2366 -> 1595;
2367 -> 2366;
2367 -> 1435;
2368 -> 2367;
2368 -> 1437;
2368 -> 1435;
2369 -> 1433;
2369 -> 1465;
2369 -> 1591;
2369 -> 2368;
2369 -> 1600;
2369 -> 1461;
2369 -> 1462;
2369 -> 2354;
2369 -> 1472;
2369 -> 1464;
2370 -> 1615;
2371 -> 2370;
2371 -> 1484;
2372 -> 2371;
2372 -> 1486;
2372 -> 1484;
2373 -> 1482;
2373 -> 1516;
2373 -> 1611;
2373 -> 2372;
2373 -> 1620;
2373 -> 1510;
2373 -> 1511;
2373 -> 2358;
2373 -> 1518;
2373 -> 1515;
2374 -> 1635;
2375 -> 2374;
2375 -> 1530;
2376 -> 2375;
2376 -> 1532;
2376 -> 1530;
2377 -> 1528;
2377 -> 1562;
2377 -> 1631;
2377 -> 2376;
2377 -> 1640;
2377 -> 1556;
2377 -> 1557;
2377 -> 2362;
2377 -> 1564;
2377 -> 1561;
2378 -> 1576;
2379 -> 2378;
2379 -> 1397;
2380 -> 2379;
2380 -> 1399;
2380 -> 1397;
2381 -> 1595;
2382 -> 2381;
2382 -> 1435;
2383 -> 2382;
2383 -> 1437;
2383 -> 1435;
2384 -> 1433;
2384 -> 1465;
2384 -> 1591;
2384 -> 2383;
2384 -> 1600;
2384 -> 1461;
2384 -> 1462;
2384 -> 2369;
2384 -> 1472;
2384 -> 1464;
2385 -> 1615;
2386 -> 2385;
2386 -> 1484;
2387 -> 2386;
2387 -> 1486;
2387 -> 1484;
2388 -> 1482;
2388 -> 1516;
2388 -> 1611;
2388 -> 2387;
2388 -> 1620;
2388 -> 1510;
2388 -> 1511;
2388 -> 2373;
2388 -> 1518;
2388 -> 1515;
2389 -> 1635;
2390 -> 2389;
2390 -> 1530;
2391 -> 2390;
2391 -> 1532;
2391 -> 1530;
2392 -> 1528;
2392 -> 1562;
2392 -> 1631;
2392 -> 2391;
2392 -> 1640;
2392 -> 1556;
2392 -> 1557;
2392 -> 2377;
2392 -> 1564;
2392 -> 1561;
2393 -> 1576;
2394 -> 2393;
2394 -> 1397;
2395 -> 2394;
2395 -> 1399;
2395 -> 1397;
2396 -> 1595;
2397 -> 2396;
2397 -> 1435;
2398 -> 2397;
2398 -> 1437;
2398 -> 1435;
2399 -> 1433;
2399 -> 1465;
2399 -> 1591;
2399 -> 2398;
2399 -> 1600;
2399 -> 1461;
2399 -> 1462;
2399 -> 2384;
2399 -> 1472;
2399 -> 1464;
2400 -> 1615;
2401 -> 2400;
2401 -> 1484;
2402 -> 2401;
2402 -> 1486;
2402 -> 1484;
2403 -> 1482;
2403 -> 1516;
2403 -> 1611;
2403 -> 2402;
2403 -> 1620;
2403 -> 1510;
2403 -> 1511;
2403 -> 2388;
2403 -> 1518;
2403 -> 1515;
2404 -> 1635;
2405 -> 2404;
2405 -> 1530;
2406 -> 2405;
2406 -> 1532;
2406 -> 1530;
2407 -> 1528;
2407 -> 1562;
2407 -> 1631;
2407 -> 2406;
2407 -> 1640;
2407 -> 1556;
2407 -> 1557;
2407 -> 2392;
2407 -> 1564;
2407 -> 1561;
2408 -> 1576;
2409 -> 2408;
2409 -> 1397;
2410 -> 2409;
2410 -> 1399;
2410 -> 1397;
2411 -> 1595;
2412 -> 2411;
2412 -> 1435;
2413 -> 2412;
2413 -> 1437;
2413 -> 1435;
2414 -> 1433;
2414 -> 1465;
2414 -> 1591;
2414 -> 2413;
2414 -> 1600;
2414 -> 1461;
2414 -> 1462;
2414 -> 2399;
2414 -> 1472;
2414 -> 1464;
2415 -> 1615;
2416 -> 2415;
2416 -> 1484;
2417 -> 2416;
2417 -> 1486;
2417 -> 1484;
2418 -> 1482;
2418 -> 1516;
2418 -> 1611;
2418 -> 2417;
2418 -> 1620;
2418 -> 1510;
2418 -> 1511;
2418 -> 2403;
2418 -> 1518;
2418 -> 1515;
2419 -> 1635;
2420 -> 2419;
2420 -> 1530;
2421 -> 2420;
2421 -> 1532;
2421 -> 1530;
2422 -> 1528;
2422 -> 1562;
2422 -> 1631;
2422 -> 2421;
2422 -> 1640;
2422 -> 1556;
2422 -> 1557;
2422 -> 2407;
2422 -> 1564;
2422 -> 1561;
2423 -> 1576;
2424 -> 2423;
2424 -> 1397;
2425 -> 2424;
2425 -> 1399;
2425 -> 1397;
2426 -> 1595;
2427 -> 2426;
2427 -> 1435;
2428 -> 2427;
2428 -> 1437;
2428 -> 1435;
2429 -> 1433;
2429 -> 1465;
2429 -> 1591;
2429 -> 2428;
2429 -> 1600;
2429 -> 1461;
2429 -> 1462;
2429 -> 2414;
2429 -> 1472;
2429 -> 1464;
2430 -> 1615;
2431 -> 2430;
2431 -> 1484;
2432 -> 2431;
2432 -> 1486;
2432 -> 1484;
2433 -> 1482;
2433 -> 1516;
2433 -> 1611;
2433 -> 2432;
2433 -> 1620;
2433 -> 1510;
2433 -> 1511;
2433 -> 2418;
2433 -> 1518;
2433 -> 1515;
2434 -> 1635;
2435 -> 2434;
2435 -> 1530;
2436 -> 2435;
2436 -> 1532;
2436 -> 1530;
2437 -> 1528;
2437 -> 1562;
2437 -> 1631;
2437 -> 2436;
2437 -> 1640;
2437 -> 1556;
2437 -> 1557;
2437 -> 2422;
2437 -> 1564;
2437 -> 1561;
2438 -> 1576;
2439 -> 2438;
2439 -> 1397;
2440 -> 2439;
2440 -> 1399;
2440 -> 1397;
2441 -> 1595;
2442 -> 2441;
2442 -> 1435;
2443 -> 2442;
2443 -> 1437;
2443 -> 1435;
2444 -> 1433;
2444 -> 1465;
2444 -> 1591;
2444 -> 2443;
2444 -> 1600;
2444 -> 1461;
2444 -> 1462;
2444 -> 2429;
2444 -> 1472;
2444 -> 1464;
2445 -> 1615;
2446 -> 2445;
2446 -> 1484;
2447 -> 2446;
2447 -> 1486;
2447 -> 1484;
2448 -> 1482;
2448 -> 1516;
2448 -> 1611;
2448 -> 2447;
2448 -> 1620;
2448 -> 1510;
2448 -> 1511;
2448 -> 2433;
2448 -> 1518;
2448 -> 1515;
2449 -> 1635;
2450 -> 2449;
2450 -> 1530;
2451 -> 2450;
2451 -> 1532;
2451 -> 1530;
2452 -> 1528;
2452 -> 1562;
2452 -> 1631;
2452 -> 2451;
2452 -> 1640;
2452 -> 1556;
2452 -> 1557;
2452 -> 2437;
2452 -> 1564;
2452 -> 1561;
2453 -> 1576;
2454 -> 2453;
2454 -> 1397;
2455 -> 2454;
2455 -> 1399;
2455 -> 1397;
2456 -> 1595;
2457 -> 2456;
2457 -> 1435;
2458 -> 2457;
2458 -> 1437;
2458 -> 1435;
2459 -> 1433;
2459 -> 1465;
2459 -> 1591;
2459 -> 2458;
2459 -> 1600;
2459 -> 1461;
2459 -> 1462;
2459 -> 2444;
2459 -> 1472;
2459 -> 1464;
2460 -> 1615;
2461 -> 2460;
2461 -> 1484;
2462 -> 2461;
2462 -> 1486;
2462 -> 1484;
2463 -> 1482;
2463 -> 1516;
2463 -> 1611;
2463 -> 2462;
2463 -> 1620;
2463 -> 1510;
2463 -> 1511;
2463 -> 2448;
2463 -> 1518;
2463 -> 1515;
2464 -> 1635;
2465 -> 2464;
2465 -> 1530;
2466 -> 2465;
2466 -> 1532;
2466 -> 1530;
2467 -> 1528;
2467 -> 1562;
2467 -> 1631;
2467 -> 2466;
2467 -> 1640;
2467 -> 1556;
2467 -> 1557;
2467 -> 2452;
2467 -> 1564;
2467 -> 1561;
2468 -> 1576;
2469 -> 2468;
2469 -> 1397;
2470 -> 2469;
2470 -> 1399;
2470 -> 1397;
2471 -> 1595;
2472 -> 2471;
2472 -> 1435;
2473 -> 2472;
2473 -> 1437;
2473 -> 1435;
2474 -> 1433;
2474 -> 1465;
2474 -> 1591;
2474 -> 2473;
2474 -> 1600;
2474 -> 1461;
2474 -> 1462;
2474 -> 2459;
2474 -> 1472;
2474 -> 1464;
2475 -> 1615;
2476 -> 2475;
2476 -> 1484;
2477 -> 2476;
2477 -> 1486;
2477 -> 1484;
2478 -> 1482;
2478 -> 1516;
2478 -> 1611;
2478 -> 2477;
2478 -> 1620;
2478 -> 1510;
2478 -> 1511;
2478 -> 2463;
2478 -> 1518;
2478 -> 1515;
2479 -> 1635;
2480 -> 2479;
2480 -> 1530;
2481 -> 2480;
2481 -> 1532;
2481 -> 1530;
2482 -> 1528;
2482 -> 1562;
2482 -> 1631;
2482 -> 2481;
2482 -> 1640;
2482 -> 1556;
2482 -> 1557;
2482 -> 2467;
2482 -> 1564;
2482 -> 1561;
2483 -> 1576;
2484 -> 2483;
2484 -> 1397;
2485 -> 2484;
2485 -> 1399;
2485 -> 1397;
2486 -> 1595;
2487 -> 2486;
2487 -> 1435;
2488 -> 2487;
2488 -> 1437;
2488 -> 1435;
2489 -> 1433;
2489 -> 1465;
2489 -> 1591;
2489 -> 2488;
2489 -> 1600;
2489 -> 1461;
2489 -> 1462;
2489 -> 2474;
2489 -> 1472;
2489 -> 1464;
2490 -> 1615;
2491 -> 2490;
2491 -> 1484;
2492 -> 2491;
2492 -> 1486;
2492 -> 1484;
2493 -> 1482;
2493 -> 1516;
2493 -> 1611;
2493 -> 2492;
2493 -> 1620;
2493 -> 1510;
2493 -> 1511;
2493 -> 2478;
2493 -> 1518;
2493 -> 1515;
2494 -> 1635;
2495 -> 2494;
2495 -> 1530;
2496 -> 2495;
2496 -> 1532;
2496 -> 1530;
2497 -> 1528;
2497 -> 1562;
2497 -> 1631;
2497 -> 2496;
2497 -> 1640;
2497 -> 1556;
2497 -> 1557;
2497 -> 2482;
2497 -> 1564;
2497 -> 1561;
2498 -> 1576;
2499 -> 2498;
2499 -> 1397;
2500 -> 2499;
2500 -> 1399;
2500 -> 1397;
2501 -> 1595;
2502 -> 2501;
2502 -> 1435;
2503 -> 2502;
2503 -> 1437;
2503 -> 1435;
2504 -> 1433;
2504 -> 1465;
2504 -> 1591;
2504 -> 2503;
2504 -> 1600;
2504 -> 1461;
2504 -> 1462;
2504 -> 2489;
2504 -> 1472;
2504 -> 1464;
2505 -> 1615;
2506 -> 2505;
2506 -> 1484;
2507 -> 2506;
2507 -> 1486;
2507 -> 1484;
2508 -> 1482;
2508 -> 1516;
2508 -> 1611;
2508 -> 2507;
2508 -> 1620;
2508 -> 1510;
2508 -> 1511;
2508 -> 2493;
2508 -> 1518;
2508 -> 1515;
2509 -> 1635;
2510 -> 2509;
2510 -> 1530;
2511 -> 2510;
2511 -> 1532;
2511 -> 1530;
2512 -> 1528;
2512 -> 1562;
2512 -> 1631;
2512 -> 2511;
2512 -> 1640;
2512 -> 1556;
2512 -> 1557;
2512 -> 2497;
2512 -> 1564;
2512 -> 1561;
2513 -> 1576;
2514 -> 2513;
2514 -> 1397;
2515 -> 2514;
2515 -> 1399;
2515 -> 1397;
2516 -> 1595;
2517 -> 2516;
2517 -> 1435;
2518 -> 2517;
2518 -> 1437;
2518 -> 1435;
2519 -> 1433;
2519 -> 1465;
2519 -> 1591;
2519 -> 2518;
2519 -> 1600;
2519 -> 1461;
2519 -> 1462;
2519 -> 2504;
2519 -> 1472;
2519 -> 1464;
2520 -> 1615;
2521 -> 2520;
2521 -> 1484;
2522 -> 2521;
2522 -> 1486;
2522 -> 1484;
2523 -> 1482;
2523 -> 1516;
2523 -> 1611;
2523 -> 2522;
2523 -> 1620;
2523 -> 1510;
2523 -> 1511;
2523 -> 2508;
2523 -> 1518;
2523 -> 1515;
2524 -> 1635;
2525 -> 2524;
2525 -> 1530;
2526 -> 2525;
2526 -> 1532;
2526 -> 1530;
2527 -> 1528;
2527 -> 1562;
2527 -> 1631;
2527 -> 2526;
2527 -> 1640;
2527 -> 1556;
2527 -> 1557;
2527 -> 2512;
2527 -> 1564;
2527 -> 1561;
2528 -> 1576;
2529 -> 2528;
2529 -> 1397;
2530 -> 2529;
2530 -> 1399;
2530 -> 1397;
2531 -> 1595;
2532 -> 2531;
2532 -> 1435;
2533 -> 2532;
2533 -> 1437;
2533 -> 1435;
2534 -> 1433;
2534 -> 1465;
2534 -> 1591;
2534 -> 2533;
2534 -> 1600;
2534 -> 1461;
2534 -> 1462;
2534 -> 2519;
2534 -> 1472;
2534 -> 1464;
2535 -> 1615;
2536 -> 2535;
2536 -> 1484;
2537 -> 2536;
2537 -> 1486;
2537 -> 1484;
2538 -> 1482;
2538 -> 1516;
2538 -> 1611;
2538 -> 2537;
2538 -> 1620;
2538 -> 1510;
2538 -> 1511;
2538 -> 2523;
2538 -> 1518;
2538 -> 1515;
2539 -> 1635;
2540 -> 2539;
2540 -> 1530;
2541 -> 2540;
2541 -> 1532;
2541 -> 1530;
2542 -> 1528;
2542 -> 1562;
2542 -> 1631;
2542 -> 2541;
2542 -> 1640;
2542 -> 1556;
2542 -> 1557;
2542 -> 2527;
2542 -> 1564;
2542 -> 1561;
2543 -> 1576;
2544 -> 2543;
2544 -> 1397;
2545 -> 2544;
2545 -> 1399;
2545 -> 1397;
2546 -> 1595;
2547 -> 2546;
2547 -> 1435;
2548 -> 2547;
2548 -> 1437;
2548 -> 1435;
2549 -> 1433;
2549 -> 1465;
2549 -> 1591;
2549 -> 2548;
2549 -> 1600;
2549 -> 1461;
2549 -> 1462;
2549 -> 2534;
2549 -> 1472;
2549 -> 1464;
2550 -> 1615;
2551 -> 2550;
2551 -> 1484;
2552 -> 2551;
2552 -> 1486;
2552 -> 1484;
2553 -> 1482;
2553 -> 1516;
2553 -> 1611;
2553 -> 2552;
2553 -> 1620;
2553 -> 1510;
2553 -> 1511;
2553 -> 2538;
2553 -> 1518;
2553 -> 1515;
2554 -> 1635;
2555 -> 2554;
2555 -> 1530;
2556 -> 2555;
2556 -> 1532;
2556 -> 1530;
2557 -> 1528;
2557 -> 1562;
2557 -> 1631;
2557 -> 2556;
2557 -> 1640;
2557 -> 1556;
2557 -> 1557;
2557 -> 2542;
2557 -> 1564;
2557 -> 1561;
2558 -> 1576;
2559 -> 2558;
2559 -> 1397;
2560 -> 2559;
2560 -> 1399;
2560 -> 1397;
2561 -> 1595;
2562 -> 2561;
2562 -> 1435;
2563 -> 2562;
2563 -> 1437;
2563 -> 1435;
2564 -> 1433;
2564 -> 1465;
2564 -> 1591;
2564 -> 2563;
2564 -> 1600;
2564 -> 1461;
2564 -> 1462;
2564 -> 2549;
2564 -> 1472;
2564 -> 1464;
2565 -> 1615;
2566 -> 2565;
2566 -> 1484;
2567 -> 2566;
2567 -> 1486;
2567 -> 1484;
2568 -> 1482;
2568 -> 1516;
2568 -> 1611;
2568 -> 2567;
2568 -> 1620;
2568 -> 1510;
2568 -> 1511;
2568 -> 2553;
2568 -> 1518;
2568 -> 1515;
2569 -> 1635;
2570 -> 2569;
2570 -> 1530;
2571 -> 2570;
2571 -> 1532;
2571 -> 1530;
2572 -> 1528;
2572 -> 1562;
2572 -> 1631;
2572 -> 2571;
2572 -> 1640;
2572 -> 1556;
2572 -> 1557;
2572 -> 2557;
2572 -> 1564;
2572 -> 1561;
2573 -> 1576;
2574 -> 2573;
2574 -> 1397;
2575 -> 2574;
2575 -> 1399;
2575 -> 1397;
2576 -> 1595;
2577 -> 2576;
2577 -> 1435;
2578 -> 2577;
2578 -> 1437;
2578 -> 1435;
2579 -> 1433;
2579 -> 1465;
2579 -> 1591;
2579 -> 2578;
2579 -> 1600;
2579 -> 1461;
2579 -> 1462;
2579 -> 2564;
2579 -> 1472;
2579 -> 1464;
2580 -> 1615;
2581 -> 2580;
2581 -> 1484;
2582 -> 2581;
2582 -> 1486;
2582 -> 1484;
2583 -> 1482;
2583 -> 1516;
2583 -> 1611;
2583 -> 2582;
2583 -> 1620;
2583 -> 1510;
2583 -> 1511;
2583 -> 2568;
2583 -> 1518;
2583 -> 1515;
2584 -> 1635;
2585 -> 2584;
2585 -> 1530;
2586 -> 2585;
2586 -> 1532;
2586 -> 1530;
2587 -> 1528;
2587 -> 1562;
2587 -> 1631;
2587 -> 2586;
2587 -> 1640;
2587 -> 1556;
2587 -> 1557;
2587 -> 2572;
2587 -> 1564;
2587 -> 1561;
2588 -> 1576;
2589 -> 2588;
2589 -> 1397;
2590 -> 2589;
2590 -> 1399;
2590 -> 1397;
2591 -> 1595;
2592 -> 2591;
2592 -> 1435;
2593 -> 2592;
2593 -> 1437;
2593 -> 1435;
2594 -> 1433;
2594 -> 1465;
2594 -> 1591;
2594 -> 2593;
2594 -> 1600;
2594 -> 1461;
2594 -> 1462;
2594 -> 2579;
2594 -> 1472;
2594 -> 1464;
2595 -> 1615;
2596 -> 2595;
2596 -> 1484;
2597 -> 2596;
2597 -> 1486;
2597 -> 1484;
2598 -> 1482;
2598 -> 1516;
2598 -> 1611;
2598 -> 2597;
2598 -> 1620;
2598 -> 1510;
2598 -> 1511;
2598 -> 2583;
2598 -> 1518;
2598 -> 1515;
2599 -> 1635;
2600 -> 2599;
2600 -> 1530;
2601 -> 2600;
2601 -> 1532;
2601 -> 1530;
2602 -> 1528;
2602 -> 1562;
2602 -> 1631;
2602 -> 2601;
2602 -> 1640;
2602 -> 1556;
2602 -> 1557;
2602 -> 2587;
2602 -> 1564;
2602 -> 1561;
2603 -> 1576;
2604 -> 2603;
2604 -> 1397;
2605 -> 2604;
2605 -> 1399;
2605 -> 1397;
2606 -> 1595;
2607 -> 2606;
2607 -> 1435;
2608 -> 2607;
2608 -> 1437;
2608 -> 1435;
2609 -> 1433;
2609 -> 1465;
2609 -> 1591;
2609 -> 2608;
2609 -> 1600;
2609 -> 1461;
2609 -> 1462;
2609 -> 2594;
2609 -> 1472;
2609 -> 1464;
2610 -> 1615;
2611 -> 2610;
2611 -> 1484;
2612 -> 2611;
2612 -> 1486;
2612 -> 1484;
2613 -> 1482;
2613 -> 1516;
2613 -> 1611;
2613 -> 2612;
2613 -> 1620;
2613 -> 1510;
2613 -> 1511;
2613 -> 2598;
2613 -> 1518;
2613 -> 1515;
2614 -> 1635;
2615 -> 2614;
2615 -> 1530;
2616 -> 2615;
2616 -> 1532;
2616 -> 1530;
2617 -> 1528;
2617 -> 1562;
2617 -> 1631;
2617 -> 2616;
2617 -> 1640;
2617 -> 1556;
2617 -> 1557;
2617 -> 2602;
2617 -> 1564;
2617 -> 1561;
2618 -> 1576;
2619 -> 2618;
2619 -> 1397;
2620 -> 2619;
2620 -> 1399;
2620 -> 1397;
2621 -> 1595;
2622 -> 2621;
2622 -> 1435;
2623 -> 2622;
2623 -> 1437;
2623 -> 1435;
2624 -> 1433;
2624 -> 1465;
2624 -> 1591;
2624 -> 2623;
2624 -> 1600;
2624 -> 1461;
2624 -> 1462;
2624 -> 2609;
2624 -> 1472;
2624 -> 1464;
2625 -> 1615;
2626 -> 2625;
2626 -> 1484;
2627 -> 2626;
2627 -> 1486;
2627 -> 1484;
2628 -> 1482;
2628 -> 1516;
2628 -> 1611;
2628 -> 2627;
2628 -> 1620;
2628 -> 1510;
2628 -> 1511;
2628 -> 2613;
2628 -> 1518;
2628 -> 1515;
2629 -> 1635;
2630 -> 2629;
2630 -> 1530;
2631 -> 2630;
2631 -> 1532;
2631 -> 1530;
2632 -> 1528;
2632 -> 1562;
2632 -> 1631;
2632 -> 2631;
2632 -> 1640;
2632 -> 1556;
2632 -> 1557;
2632 -> 2617;
2632 -> 1564;
2632 -> 1561;
2633 -> 1576;
2634 -> 2633;
2634 -> 1397;
2635 -> 2634;
2635 -> 1399;
2635 -> 1397;
2636 -> 1595;
2637 -> 2636;
2637 -> 1435;
2638 -> 2637;
2638 -> 1437;
2638 -> 1435;
2639 -> 1433;
2639 -> 1465;
2639 -> 1591;
2639 -> 2638;
2639 -> 1600;
2639 -> 1461;
2639 -> 1462;
2639 -> 2624;
2639 -> 1472;
2639 -> 1464;
2640 -> 1615;
2641 -> 2640;
2641 -> 1484;
2642 -> 2641;
2642 -> 1486;
2642 -> 1484;
2643 -> 1482;
2643 -> 1516;
2643 -> 1611;
2643 -> 2642;
2643 -> 1620;
2643 -> 1510;
2643 -> 1511;
2643 -> 2628;
2643 -> 1518;
2643 -> 1515;
2644 -> 1635;
2645 -> 2644;
2645 -> 1530;
2646 -> 2645;
2646 -> 1532;
2646 -> 1530;
2647 -> 1528;
2647 -> 1562;
2647 -> 1631;
2647 -> 2646;
2647 -> 1640;
2647 -> 1556;
2647 -> 1557;
2647 -> 2632;
2647 -> 1564;
2647 -> 1561;
2648 -> 1576;
2649 -> 2648;
2649 -> 1397;
2650 -> 2649;
2650 -> 1399;
2650 -> 1397;
2651 -> 1595;
2652 -> 2651;
2652 -> 1435;
2653 -> 2652;
2653 -> 1437;
2653 -> 1435;
2654 -> 1433;
2654 -> 1465;
2654 -> 1591;
2654 -> 2653;
2654 -> 1600;
2654 -> 1461;
2654 -> 1462;
2654 -> 2639;
2654 -> 1472;
2654 -> 1464;
2655 -> 1615;
2656 -> 2655;
2656 -> 1484;
2657 -> 2656;
2657 -> 1486;
2657 -> 1484;
2658 -> 1482;
2658 -> 1516;
2658 -> 1611;
2658 -> 2657;
2658 -> 1620;
2658 -> 1510;
2658 -> 1511;
2658 -> 2643;
2658 -> 1518;
2658 -> 1515;
2659 -> 1635;
2660 -> 2659;
2660 -> 1530;
2661 -> 2660;
2661 -> 1532;
2661 -> 1530;
2662 -> 1528;
2662 -> 1562;
2662 -> 1631;
2662 -> 2661;
2662 -> 1640;
2662 -> 1556;
2662 -> 1557;
2662 -> 2647;
2662 -> 1564;
2662 -> 1561;
2663 -> 1576;
2664 -> 2663;
2664 -> 1397;
2665 -> 2664;
2665 -> 1399;
2665 -> 1397;
2666 -> 1595;
2667 -> 2666;
2667 -> 1435;
2668 -> 2667;
2668 -> 1437;
2668 -> 1435;
2669 -> 1433;
2669 -> 1465;
2669 -> 1591;
2669 -> 2668;
2669 -> 1600;
2669 -> 1461;
2669 -> 1462;
2669 -> 2654;
2669 -> 1472;
2669 -> 1464;
2670 -> 1615;
2671 -> 2670;
2671 -> 1484;
2672 -> 2671;
2672 -> 1486;
2672 -> 1484;
2673 -> 1482;
2673 -> 1516;
2673 -> 1611;
2673 -> 2672;
2673 -> 1620;
2673 -> 1510;
2673 -> 1511;
2673 -> 2658;
2673 -> 1518;
2673 -> 1515;
2674 -> 1635;
2675 -> 2674;
2675 -> 1530;
2676 -> 2675;
2676 -> 1532;
2676 -> 1530;
2677 -> 1528;
2677 -> 1562;
2677 -> 1631;
2677 -> 2676;
2677 -> 1640;
2677 -> 1556;
2677 -> 1557;
2677 -> 2662;
2677 -> 1564;
2677 -> 1561;
2678 -> 1576;
2679 -> 2678;
2679 -> 1397;
2680 -> 2679;
2680 -> 1399;
2680 -> 1397;
2681 -> 1595;
2682 -> 2681;
2682 -> 1435;
2683 -> 2682;
2683 -> 1437;
2683 -> 1435;
2684 -> 1433;
2684 -> 1465;
2684 -> 1591;
2684 -> 2683;
2684 -> 1600;
2684 -> 1461;
2684 -> 1462;
2684 -> 2669;
2684 -> 1472;
2684 -> 1464;
2685 -> 1615;
2686 -> 2685;
2686 -> 1484;
2687 -> 2686;
2687 -> 1486;
2687 -> 1484;
2688 -> 1482;
2688 -> 1516;
2688 -> 1611;
2688 -> 2687;
2688 -> 1620;
2688 -> 1510;
2688 -> 1511;
2688 -> 2673;
2688 -> 1518;
2688 -> 1515;
2689 -> 1635;
2690 -> 2689;
2690 -> 1530;
2691 -> 2690;
2691 -> 1532;
2691 -> 1530;
2692 -> 1528;
2692 -> 1562;
2692 -> 1631;
2692 -> 2691;
2692 -> 1640;
2692 -> 1556;
2692 -> 1557;
2692 -> 2677;
2692 -> 1564;
2692 -> 1561;
2693 -> 1576;
2694 -> 2693;
2694 -> 1397;
2695 -> 2694;
2695 -> 1399;
2695 -> 1397;
2696 -> 1595;
2697 -> 2696;
2697 -> 1435;
2698 -> 2697;
2698 -> 1437;
2698 -> 1435;
2699 -> 1433;
2699 -> 1465;
2699 -> 1591;
2699 -> 2698;
2699 -> 1600;
2699 -> 1461;
2699 -> 1462;
2699 -> 2684;
2699 -> 1472;
2699 -> 1464;
2700 -> 1615;
2701 -> 2700;
2701 -> 1484;
2702 -> 2701;
2702 -> 1486;
2702 -> 1484;
2703 -> 1482;
2703 -> 1516;
2703 -> 1611;
2703 -> 2702;
2703 -> 1620;
2703 -> 1510;
2703 -> 1511;
2703 -> 2688;
2703 -> 1518;
2703 -> 1515;
2704 -> 1635;
2705 -> 2704;
2705 -> 1530;
2706 -> 2705;
2706 -> 1532;
2706 -> 1530;
2707 -> 1528;
2707 -> 1562;
2707 -> 1631;
2707 -> 2706;
2707 -> 1640;
2707 -> 1556;
2707 -> 1557;
2707 -> 2692;
2707 -> 1564;
2707 -> 1561;
2708 -> 1576;
2709 -> 2708;
2709 -> 1397;
2710 -> 2709;
2710 -> 1399;
2710 -> 1397;
2711 -> 1595;
2712 -> 2711;
2712 -> 1435;
2713 -> 2712;
2713 -> 1437;
2713 -> 1435;
2714 -> 1433;
2714 -> 1465;
2714 -> 1591;
2714 -> 2713;
2714 -> 1600;
2714 -> 1461;
2714 -> 1462;
2714 -> 2699;
2714 -> 1472;
2714 -> 1464;
2715 -> 1615;
2716 -> 2715;
2716 -> 1484;
2717 -> 2716;
2717 -> 1486;
2717 -> 1484;
2718 -> 1482;
2718 -> 1516;
2718 -> 1611;
2718 -> 2717;
2718 -> 1620;
2718 -> 1510;
2718 -> 1511;
2718 -> 2703;
2718 -> 1518;
2718 -> 1515;
2719 -> 1635;
2720 -> 2719;
2720 -> 1530;
2721 -> 2720;
2721 -> 1532;
2721 -> 1530;
2722 -> 1528;
2722 -> 1562;
2722 -> 1631;
2722 -> 2721;
2722 -> 1640;
2722 -> 1556;
2722 -> 1557;
2722 -> 2707;
2722 -> 1564;
2722 -> 1561;
2723 -> 1576;
2724 -> 2723;
2724 -> 1397;
2725 -> 2724;
2725 -> 1399;
2725 -> 1397;
2726 -> 1595;
2727 -> 2726;
2727 -> 1435;
2728 -> 2727;
2728 -> 1437;
2728 -> 1435;
2729 -> 1433;
2729 -> 1465;
2729 -> 1591;
2729 -> 2728;
2729 -> 1600;
2729 -> 1461;
2729 -> 1462;
2729 -> 2714;
2729 -> 1472;
2729 -> 1464;
2730 -> 1615;
2731 -> 2730;
2731 -> 1484;
2732 -> 2731;
2732 -> 1486;
2732 -> 1484;
2733 -> 1482;
2733 -> 1516;
2733 -> 1611;
2733 -> 2732;
2733 -> 1620;
2733 -> 1510;
2733 -> 1511;
2733 -> 2718;
2733 -> 1518;
2733 -> 1515;
2734 -> 1635;
2735 -> 2734;
2735 -> 1530;
2736 -> 2735;
2736 -> 1532;
2736 -> 1530;
2737 -> 1528;
2737 -> 1562;
2737 -> 1631;
2737 -> 2736;
2737 -> 1640;
2737 -> 1556;
2737 -> 1557;
2737 -> 2722;
2737 -> 1564;
2737 -> 1561;
2738 -> 1576;
2739 -> 2738;
2739 -> 1397;
2740 -> 2739;
2740 -> 1399;
2740 -> 1397;
2741 -> 1595;
2742 -> 2741;
2742 -> 1435;
2743 -> 2742;
2743 -> 1437;
2743 -> 1435;
2744 -> 1433;
2744 -> 1465;
2744 -> 1591;
2744 -> 2743;
2744 -> 1600;
2744 -> 1461;
2744 -> 1462;
2744 -> 2729;
2744 -> 1472;
2744 -> 1464;
2745 -> 1615;
2746 -> 2745;
2746 -> 1484;
2747 -> 2746;
2747 -> 1486;
2747 -> 1484;
2748 -> 1482;
2748 -> 1516;
2748 -> 1611;
2748 -> 2747;
2748 -> 1620;
2748 -> 1510;
2748 -> 1511;
2748 -> 2733;
2748 -> 1518;
2748 -> 1515;
2749 -> 1635;
2750 -> 2749;
2750 -> 1530;
2751 -> 2750;
2751 -> 1532;
2751 -> 1530;
2752 -> 1528;
2752 -> 1562;
2752 -> 1631;
2752 -> 2751;
2752 -> 1640;
2752 -> 1556;
2752 -> 1557;
2752 -> 2737;
2752 -> 1564;
2752 -> 1561;
2753 -> 1576;
2754 -> 2753;
2754 -> 1397;
2755 -> 2754;
2755 -> 1399;
2755 -> 1397;
2756 -> 1595;
2757 -> 2756;
2757 -> 1435;
2758 -> 2757;
2758 -> 1437;
2758 -> 1435;
2759 -> 1433;
2759 -> 1465;
2759 -> 1591;
2759 -> 2758;
2759 -> 1600;
2759 -> 1461;
2759 -> 1462;
2759 -> 2744;
2759 -> 1472;
2759 -> 1464;
2760 -> 1615;
2761 -> 2760;
2761 -> 1484;
2762 -> 2761;
2762 -> 1486;
2762 -> 1484;
2763 -> 1482;
2763 -> 1516;
2763 -> 1611;
2763 -> 2762;
2763 -> 1620;
2763 -> 1510;
2763 -> 1511;
2763 -> 2748;
2763 -> 1518;
2763 -> 1515;
2764 -> 1635;
2765 -> 2764;
2765 -> 1530;
2766 -> 2765;
2766 -> 1532;
2766 -> 1530;
2767 -> 1528;
2767 -> 1562;
2767 -> 1631;
2767 -> 2766;
2767 -> 1640;
2767 -> 1556;
2767 -> 1557;
2767 -> 2752;
2767 -> 1564;
2767 -> 1561;
2768 -> 1576;
2769 -> 2768;
2769 -> 1397;
2770 -> 2769;
2770 -> 1399;
2770 -> 1397;
2771 -> 1595;
2772 -> 2771;
2772 -> 1435;
2773 -> 2772;
2773 -> 1437;
2773 -> 1435;
2774 -> 1433;
2774 -> 1465;
2774 -> 1591;
2774 -> 2773;
2774 -> 1600;
2774 -> 1461;
2774 -> 1462;
2774 -> 2759;
2774 -> 1472;
2774 -> 1464;
2775 -> 1615;
2776 -> 2775;
2776 -> 1484;
2777 -> 2776;
2777 -> 1486;
2777 -> 1484;
2778 -> 1482;
2778 -> 1516;
2778 -> 1611;
2778 -> 2777;
2778 -> 1620;
2778 -> 1510;
2778 -> 1511;
2778 -> 2763;
2778 -> 1518;
2778 -> 1515;
2779 -> 1635;
2780 -> 2779;
2780 -> 1530;
2781 -> 2780;
2781 -> 1532;
2781 -> 1530;
2782 -> 1528;
2782 -> 1562;
2782 -> 1631;
2782 -> 2781;
2782 -> 1640;
2782 -> 1556;
2782 -> 1557;
2782 -> 2767;
2782 -> 1564;
2782 -> 1561;
2783 -> 1576;
2784 -> 2783;
2784 -> 1397;
2785 -> 2784;
2785 -> 1399;
2785 -> 1397;
2786 -> 1595;
2787 -> 2786;
2787 -> 1435;
2788 -> 2787;
2788 -> 1437;
2788 -> 1435;
2789 -> 1433;
2789 -> 1465;
2789 -> 1591;
2789 -> 2788;
2789 -> 1600;
2789 -> 1461;
2789 -> 1462;
2789 -> 2774;
2789 -> 1472;
2789 -> 1464;
2790 -> 1615;
2791 -> 2790;
2791 -> 1484;
2792 -> 2791;
2792 -> 1486;
2792 -> 1484;
2793 -> 1482;
2793 -> 1516;
2793 -> 1611;
2793 -> 2792;
2793 -> 1620;
2793 -> 1510;
2793 -> 1511;
2793 -> 2778;
2793 -> 1518;
2793 -> 1515;
2794 -> 1635;
2795 -> 2794;
2795 -> 1530;
2796 -> 2795;
2796 -> 1532;
2796 -> 1530;
2797 -> 1528;
2797 -> 1562;
2797 -> 1631;
2797 -> 2796;
2797 -> 1640;
2797 -> 1556;
2797 -> 1557;
2797 -> 2782;
2797 -> 1564;
2797 -> 1561;
2798 -> 1576;
2799 -> 2798;
2799 -> 1397;
2800 -> 2799;
2800 -> 1399;
2800 -> 1397;
2801 -> 1595;
2802 -> 2801;
2802 -> 1435;
2803 -> 2802;
2803 -> 1437;
2803 -> 1435;
2804 -> 1433;
2804 -> 1465;
2804 -> 1591;
2804 -> 2803;
2804 -> 1600;
2804 -> 1461;
2804 -> 1462;
2804 -> 2789;
2804 -> 1472;
2804 -> 1464;
2805 -> 1615;
2806 -> 2805;
2806 -> 1484;
2807 -> 2806;
2807 -> 1486;
2807 -> 1484;
2808 -> 1482;
2808 -> 1516;
2808 -> 1611;
2808 -> 2807;
2808 -> 1620;
2808 -> 1510;
2808 -> 1511;
2808 -> 2793;
2808 -> 1518;
2808 -> 1515;
2809 -> 1635;
2810 -> 2809;
2810 -> 1530;
2811 -> 2810;
2811 -> 1532;
2811 -> 1530;
2812 -> 1528;
2812 -> 1562;
2812 -> 1631;
2812 -> 2811;
2812 -> 1640;
2812 -> 1556;
2812 -> 1557;
2812 -> 2797;
2812 -> 1564;
2812 -> 1561;
2813 -> 1576;
2814 -> 2813;
2814 -> 1397;
2815 -> 2814;
2815 -> 1399;
2815 -> 1397;
2816 -> 1595;
2817 -> 2816;
2817 -> 1435;
2818 -> 2817;
2818 -> 1437;
2818 -> 1435;
2819 -> 1433;
2819 -> 1465;
2819 -> 1591;
2819 -> 2818;
2819 -> 1600;
2819 -> 1461;
2819 -> 1462;
2819 -> 2804;
2819 -> 1472;
2819 -> 1464;
2820 -> 1615;
2821 -> 2820;
2821 -> 1484;
2822 -> 2821;
2822 -> 1486;
2822 -> 1484;
2823 -> 1482;
2823 -> 1516;
2823 -> 1611;
2823 -> 2822;
2823 -> 1620;
2823 -> 1510;
2823 -> 1511;
2823 -> 2808;
2823 -> 1518;
2823 -> 1515;
2824 -> 1635;
2825 -> 2824;
2825 -> 1530;
2826 -> 2825;
2826 -> 1532;
2826 -> 1530;
2827 -> 1528;
2827 -> 1562;
2827 -> 1631;
2827 -> 2826;
2827 -> 1640;
2827 -> 1556;
2827 -> 1557;
2827 -> 2812;
2827 -> 1564;
2827 -> 1561;
2828 -> 1576;
2829 -> 2828;
2829 -> 1397;
2830 -> 2829;
2830 -> 1399;
2830 -> 1397;
2831 -> 1595;
2832 -> 2831;
2832 -> 1435;
2833 -> 2832;
2833 -> 1437;
2833 -> 1435;
2834 -> 1433;
2834 -> 1465;
2834 -> 1591;
2834 -> 2833;
2834 -> 1600;
2834 -> 1461;
2834 -> 1462;
2834 -> 2819;
2834 -> 1472;
2834 -> 1464;
2835 -> 1615;
2836 -> 2835;
2836 -> 1484;
2837 -> 2836;
2837 -> 1486;
2837 -> 1484;
2838 -> 1482;
2838 -> 1516;
2838 -> 1611;
2838 -> 2837;
2838 -> 1620;
2838 -> 1510;
2838 -> 1511;
2838 -> 2823;
2838 -> 1518;
2838 -> 1515;
2839 -> 1635;
2840 -> 2839;
2840 -> 1530;
2841 -> 2840;
2841 -> 1532;
2841 -> 1530;
2842 -> 1528;
2842 -> 1562;
2842 -> 1631;
2842 -> 2841;
2842 -> 1640;
2842 -> 1556;
2842 -> 1557;
2842 -> 2827;
2842 -> 1564;
2842 -> 1561;
2843 -> 1576;
2844 -> 2843;
2844 -> 1397;
2845 -> 2844;
2845 -> 1399;
2845 -> 1397;
2846 -> 1595;
2847 -> 2846;
2847 -> 1435;
2848 -> 2847;
2848 -> 1437;
2848 -> 1435;
2849 -> 1433;
2849 -> 1465;
2849 -> 1591;
2849 -> 2848;
2849 -> 1600;
2849 -> 1461;
2849 -> 1462;
2849 -> 2834;
2849 -> 1472;
2849 -> 1464;
2850 -> 1615;
2851 -> 2850;
2851 -> 1484;
2852 -> 2851;
2852 -> 1486;
2852 -> 1484;
2853 -> 1482;
2853 -> 1516;
2853 -> 1611;
2853 -> 2852;
2853 -> 1620;
2853 -> 1510;
2853 -> 1511;
2853 -> 2838;
2853 -> 1518;
2853 -> 1515;
2854 -> 1635;
2855 -> 2854;
2855 -> 1530;
2856 -> 2855;
2856 -> 1532;
2856 -> 1530;
2857 -> 1528;
2857 -> 1562;
2857 -> 1631;
2857 -> 2856;
2857 -> 1640;
2857 -> 1556;
2857 -> 1557;
2857 -> 2842;
2857 -> 1564;
2857 -> 1561;
2858 -> 1576;
2859 -> 2858;
2859 -> 1397;
2860 -> 2859;
2860 -> 1399;
2860 -> 1397;
2861 -> 1595;
2862 -> 2861;
2862 -> 1435;
2863 -> 2862;
2863 -> 1437;
2863 -> 1435;
2864 -> 1433;
2864 -> 1465;
2864 -> 1591;
2864 -> 2863;
2864 -> 1600;
2864 -> 1461;
2864 -> 1462;
2864 -> 2849;
2864 -> 1472;
2864 -> 1464;
2865 -> 1615;
2866 -> 2865;
2866 -> 1484;
2867 -> 2866;
2867 -> 1486;
2867 -> 1484;
2868 -> 1482;
2868 -> 1516;
2868 -> 1611;
2868 -> 2867;
2868 -> 1620;
2868 -> 1510;
2868 -> 1511;
2868 -> 2853;
2868 -> 1518;
2868 -> 1515;
2869 -> 1635;
2870 -> 2869;
2870 -> 1530;
2871 -> 2870;
2871 -> 1532;
2871 -> 1530;
2872 -> 1528;
2872 -> 1562;
2872 -> 1631;
2872 -> 2871;
2872 -> 1640;
2872 -> 1556;
2872 -> 1557;
2872 -> 2857;
2872 -> 1564;
2872 -> 1561;
2873 -> 1576;
2874 -> 2873;
2874 -> 1397;
2875 -> 2874;
2875 -> 1399;
2875 -> 1397;
2876 -> 1595;
2877 -> 2876;
2877 -> 1435;
2878 -> 2877;
2878 -> 1437;
2878 -> 1435;
2879 -> 1433;
2879 -> 1465;
2879 -> 1591;
2879 -> 2878;
2879 -> 1600;
2879 -> 1461;
2879 -> 1462;
2879 -> 2864;
2879 -> 1472;
2879 -> 1464;
2880 -> 1615;
2881 -> 2880;
2881 -> 1484;
2882 -> 2881;
2882 -> 1486;
2882 -> 1484;
2883 -> 1482;
2883 -> 1516;
2883 -> 1611;
2883 -> 2882;
2883 -> 1620;
2883 -> 1510;
2883 -> 1511;
2883 -> 2868;
2883 -> 1518;
2883 -> 1515;
2884 -> 1635;
2885 -> 2884;
2885 -> 1530;
2886 -> 2885;
2886 -> 1532;
2886 -> 1530;
2887 -> 1528;
2887 -> 1562;
2887 -> 1631;
2887 -> 2886;
2887 -> 1640;
2887 -> 1556;
2887 -> 1557;
2887 -> 2872;
2887 -> 1564;
2887 -> 1561;
2888 -> 1576;
2889 -> 2888;
2889 -> 1397;
2890 -> 2889;
2890 -> 1399;
2890 -> 1397;
2891 -> 1595;
2892 -> 2891;
2892 -> 1435;
2893 -> 2892;
2893 -> 1437;
2893 -> 1435;
2894 -> 1433;
2894 -> 1465;
2894 -> 1591;
2894 -> 2893;
2894 -> 1600;
2894 -> 1461;
2894 -> 1462;
2894 -> 2879;
2894 -> 1472;
2894 -> 1464;
2895 -> 1615;
2896 -> 2895;
2896 -> 1484;
2897 -> 2896;
2897 -> 1486;
2897 -> 1484;
2898 -> 1482;
2898 -> 1516;
2898 -> 1611;
2898 -> 2897;
2898 -> 1620;
2898 -> 1510;
2898 -> 1511;
2898 -> 2883;
2898 -> 1518;
2898 -> 1515;
2899 -> 1635;
2900 -> 2899;
2900 -> 1530;
2901 -> 2900;
2901 -> 1532;
2901 -> 1530;
2902 -> 1528;
2902 -> 1562;
2902 -> 1631;
2902 -> 2901;
2902 -> 1640;
2902 -> 1556;
2902 -> 1557;
2902 -> 2887;
2902 -> 1564;
2902 -> 1561;
2903 -> 1576;
2904 -> 2903;
2904 -> 1397;
2905 -> 2904;
2905 -> 1399;
2905 -> 1397;
2906 -> 1595;
2907 -> 2906;
2907 -> 1435;
2908 -> 2907;
2908 -> 1437;
2908 -> 1435;
2909 -> 1433;
2909 -> 1465;
2909 -> 1591;
2909 -> 2908;
2909 -> 1600;
2909 -> 1461;
2909 -> 1462;
2909 -> 2894;
2909 -> 1472;
2909 -> 1464;
2910 -> 1615;
2911 -> 2910;
2911 -> 1484;
2912 -> 2911;
2912 -> 1486;
2912 -> 1484;
2913 -> 1482;
2913 -> 1516;
2913 -> 1611;
2913 -> 2912;
2913 -> 1620;
2913 -> 1510;
2913 -> 1511;
2913 -> 2898;
2913 -> 1518;
2913 -> 1515;
2914 -> 1635;
2915 -> 2914;
2915 -> 1530;
2916 -> 2915;
2916 -> 1532;
2916 -> 1530;
2917 -> 1528;
2917 -> 1562;
2917 -> 1631;
2917 -> 2916;
2917 -> 1640;
2917 -> 1556;
2917 -> 1557;
2917 -> 2902;
2917 -> 1564;
2917 -> 1561;
2918 -> 1576;
2919 -> 2918;
2919 -> 1397;
2920 -> 2919;
2920 -> 1399;
2920 -> 1397;
2921 -> 1595;
2922 -> 2921;
2922 -> 1435;
2923 -> 2922;
2923 -> 1437;
2923 -> 1435;
2924 -> 1433;
2924 -> 1465;
2924 -> 1591;
2924 -> 2923;
2924 -> 1600;
2924 -> 1461;
2924 -> 1462;
2924 -> 2909;
2924 -> 1472;
2924 -> 1464;
2925 -> 1615;
2926 -> 2925;
2926 -> 1484;
2927 -> 2926;
2927 -> 1486;
2927 -> 1484;
2928 -> 1482;
2928 -> 1516;
2928 -> 1611;
2928 -> 2927;
2928 -> 1620;
2928 -> 1510;
2928 -> 1511;
2928 -> 2913;
2928 -> 1518;
2928 -> 1515;
2929 -> 1635;
2930 -> 2929;
2930 -> 1530;
2931 -> 2930;
2931 -> 1532;
2931 -> 1530;
2932 -> 1528;
2932 -> 1562;
2932 -> 1631;
2932 -> 2931;
2932 -> 1640;
2932 -> 1556;
2932 -> 1557;
2932 -> 2917;
2932 -> 1564;
2932 -> 1561;
2933 -> 1576;
2934 -> 2933;
2934 -> 1397;
2935 -> 2934;
2935 -> 1399;
2935 -> 1397;
2936 -> 1595;
2937 -> 2936;
2937 -> 1435;
2938 -> 2937;
2938 -> 1437;
2938 -> 1435;
2939 -> 1433;
2939 -> 1465;
2939 -> 1591;
2939 -> 2938;
2939 -> 1600;
2939 -> 1461;
2939 -> 1462;
2939 -> 2924;
2939 -> 1472;
2939 -> 1464;
2940 -> 1615;
2941 -> 2940;
2941 -> 1484;
2942 -> 2941;
2942 -> 1486;
2942 -> 1484;
2943 -> 1482;
2943 -> 1516;
2943 -> 1611;
2943 -> 2942;
2943 -> 1620;
2943 -> 1510;
2943 -> 1511;
2943 -> 2928;
2943 -> 1518;
2943 -> 1515;
2944 -> 1635;
2945 -> 2944;
2945 -> 1530;
2946 -> 2945;
2946 -> 1532;
2946 -> 1530;
2947 -> 1528;
2947 -> 1562;
2947 -> 1631;
2947 -> 2946;
2947 -> 1640;
2947 -> 1556;
2947 -> 1557;
2947 -> 2932;
2947 -> 1564;
2947 -> 1561;
2948 -> 1576;
2949 -> 2948;
2949 -> 1397;
2950 -> 2949;
2950 -> 1399;
2950 -> 1397;
2951 -> 1595;
2952 -> 2951;
2952 -> 1435;
2953 -> 2952;
2953 -> 1437;
2953 -> 1435;
2954 -> 1433;
2954 -> 1465;
2954 -> 1591;
2954 -> 2953;
2954 -> 1600;
2954 -> 1461;
2954 -> 1462;
2954 -> 2939;
2954 -> 1472;
2954 -> 1464;
2955 -> 1615;
2956 -> 2955;
2956 -> 1484;
2957 -> 2956;
2957 -> 1486;
2957 -> 1484;
2958 -> 1482;
2958 -> 1516;
2958 -> 1611;
2958 -> 2957;
2958 -> 1620;
2958 -> 1510;
2958 -> 1511;
2958 -> 2943;
2958 -> 1518;
2958 -> 1515;
2959 -> 1635;
2960 -> 2959;
2960 -> 1530;
2961 -> 2960;
2961 -> 1532;
2961 -> 1530;
2962 -> 1528;
2962 -> 1562;
2962 -> 1631;
2962 -> 2961;
2962 -> 1640;
2962 -> 1556;
2962 -> 1557;
2962 -> 2947;
2962 -> 1564;
2962 -> 1561;
2963 -> 1576;
2964 -> 2963;
2964 -> 1397;
2965 -> 2964;
2965 -> 1399;
2965 -> 1397;
2966 -> 1595;
2967 -> 2966;
2967 -> 1435;
2968 -> 2967;
2968 -> 1437;
2968 -> 1435;
2969 -> 1433;
2969 -> 1465;
2969 -> 1591;
2969 -> 2968;
2969 -> 1600;
2969 -> 1461;
2969 -> 1462;
2969 -> 2954;
2969 -> 1472;
2969 -> 1464;
2970 -> 1615;
2971 -> 2970;
2971 -> 1484;
2972 -> 2971;
2972 -> 1486;
2972 -> 1484;
2973 -> 1482;
2973 -> 1516;
2973 -> 1611;
2973 -> 2972;
2973 -> 1620;
2973 -> 1510;
2973 -> 1511;
2973 -> 2958;
2973 -> 1518;
2973 -> 1515;
2974 -> 1635;
2975 -> 2974;
2975 -> 1530;
2976 -> 2975;
2976 -> 1532;
2976 -> 1530;
2977 -> 1528;
2977 -> 1562;
2977 -> 1631;
2977 -> 2976;
2977 -> 1640;
2977 -> 1556;
2977 -> 1557;
2977 -> 2962;
2977 -> 1564;
2977 -> 1561;
2978 -> 1576;
2979 -> 2978;
2979 -> 1397;
2980 -> 2979;
2980 -> 1399;
2980 -> 1397;
2981 -> 1595;
2982 -> 2981;
2982 -> 1435;
2983 -> 2982;
2983 -> 1437;
2983 -> 1435;
2984 -> 1433;
2984 -> 1465;
2984 -> 1591;
2984 -> 2983;
2984 -> 1600;
2984 -> 1461;
2984 -> 1462;
2984 -> 2969;
2984 -> 1472;
2984 -> 1464;
2985 -> 1615;
2986 -> 2985;
2986 -> 1484;
2987 -> 2986;
2987 -> 1486;
2987 -> 1484;
2988 -> 1482;
2988 -> 1516;
2988 -> 1611;
2988 -> 2987;
2988 -> 1620;
2988 -> 1510;
2988 -> 1511;
2988 -> 2973;
2988 -> 1518;
2988 -> 1515;
2989 -> 1635;
2990 -> 2989;
2990 -> 1530;
2991 -> 2990;
2991 -> 1532;
2991 -> 1530;
2992 -> 1528;
2992 -> 1562;
2992 -> 1631;
2992 -> 2991;
2992 -> 1640;
2992 -> 1556;
2992 -> 1557;
2992 -> 2977;
2992 -> 1564;
2992 -> 1561;
2993 -> 1576;
2994 -> 2993;
2994 -> 1397;
2995 -> 2994;
2995 -> 1399;
2995 -> 1397;
2996 -> 1595;
2997 -> 2996;
2997 -> 1435;
2998 -> 2997;
2998 -> 1437;
2998 -> 1435;
2999 -> 1433;
2999 -> 1465;
2999 -> 1591;
2999 -> 2998;
2999 -> 1600;
2999 -> 1461;
2999 -> 1462;
2999 -> 2984;
2999 -> 1472;
2999 -> 1464;
3000 -> 1615;
3001 -> 3000;
3001 -> 1484;
3002 -> 3001;
3002 -> 1486;
3002 -> 1484;
3003 -> 1482;
3003 -> 1516;
3003 -> 1611;
3003 -> 3002;
3003 -> 1620;
3003 -> 1510;
3003 -> 1511;
3003 -> 2988;
3003 -> 1518;
3003 -> 1515;
3004 -> 1635;
3005 -> 3004;
3005 -> 1530;
3006 -> 3005;
3006 -> 1532;
3006 -> 1530;
3007 -> 1528;
3007 -> 1562;
3007 -> 1631;
3007 -> 3006;
3007 -> 1640;
3007 -> 1556;
3007 -> 1557;
3007 -> 2992;
3007 -> 1564;
3007 -> 1561;
3008 -> 1576;
3009 -> 3008;
3009 -> 1397;
3010 -> 3009;
3010 -> 1399;
3010 -> 1397;
3011 -> 1595;
3012 -> 3011;
3012 -> 1435;
3013 -> 3012;
3013 -> 1437;
3013 -> 1435;
3014 -> 1433;
3014 -> 1465;
3014 -> 1591;
3014 -> 3013;
3014 -> 1600;
3014 -> 1461;
3014 -> 1462;
3014 -> 2999;
3014 -> 1472;
3014 -> 1464;
3015 -> 1615;
3016 -> 3015;
3016 -> 1484;
3017 -> 3016;
3017 -> 1486;
3017 -> 1484;
3018 -> 1482;
3018 -> 1516;
3018 -> 1611;
3018 -> 3017;
3018 -> 1620;
3018 -> 1510;
3018 -> 1511;
3018 -> 3003;
3018 -> 1518;
3018 -> 1515;
3019 -> 1635;
3020 -> 3019;
3020 -> 1530;
3021 -> 3020;
3021 -> 1532;
3021 -> 1530;
3022 -> 1528;
3022 -> 1562;
3022 -> 1631;
3022 -> 3021;
3022 -> 1640;
3022 -> 1556;
3022 -> 1557;
3022 -> 3007;
3022 -> 1564;
3022 -> 1561;
3023 -> 1576;
3024 -> 3023;
3024 -> 1397;
3025 -> 3024;
3025 -> 1399;
3025 -> 1397;
3026 -> 1595;
3027 -> 3026;
3027 -> 1435;
3028 -> 3027;
3028 -> 1437;
3028 -> 1435;
3029 -> 1433;
3029 -> 1465;
3029 -> 1591;
3029 -> 3028;
3029 -> 1600;
3029 -> 1461;
3029 -> 1462;
3029 -> 3014;
3029 -> 1472;
3029 -> 1464;
3030 -> 1615;
3031 -> 3030;
3031 -> 1484;
3032 -> 3031;
3032 -> 1486;
3032 -> 1484;
3033 -> 1482;
3033 -> 1516;
3033 -> 1611;
3033 -> 3032;
3033 -> 1620;
3033 -> 1510;
3033 -> 1511;
3033 -> 3018;
3033 -> 1518;
3033 -> 1515;
3034 -> 1635;
3035 -> 3034;
3035 -> 1530;
3036 -> 3035;
3036 -> 1532;
3036 -> 1530;
3037 -> 1528;
3037 -> 1562;
3037 -> 1631;
3037 -> 3036;
3037 -> 1640;
3037 -> 1556;
3037 -> 1557;
3037 -> 3022;
3037 -> 1564;
3037 -> 1561;
3038 -> 1576;
3039 -> 3038;
3039 -> 1397;
3040 -> 3039;
3040 -> 1399;
3040 -> 1397;
3041 -> 1595;
3042 -> 3041;
3042 -> 1435;
3043 -> 3042;
3043 -> 1437;
3043 -> 1435;
3044 -> 1433;
3044 -> 1465;
3044 -> 1591;
3044 -> 3043;
3044 -> 1600;
3044 -> 1461;
3044 -> 1462;
3044 -> 3029;
3044 -> 1472;
3044 -> 1464;
3045 -> 1615;
3046 -> 3045;
3046 -> 1484;
3047 -> 3046;
3047 -> 1486;
3047 -> 1484;
3048 -> 1482;
3048 -> 1516;
3048 -> 1611;
3048 -> 3047;
3048 -> 1620;
3048 -> 1510;
3048 -> 1511;
3048 -> 3033;
3048 -> 1518;
3048 -> 1515;
3049 -> 1635;
3050 -> 3049;
3050 -> 1530;
3051 -> 3050;
3051 -> 1532;
3051 -> 1530;
3052 -> 1528;
3052 -> 1562;
3052 -> 1631;
3052 -> 3051;
3052 -> 1640;
3052 -> 1556;
3052 -> 1557;
3052 -> 3037;
3052 -> 1564;
3052 -> 1561;
3053 -> 1576;
3054 -> 3053;
3054 -> 1397;
3055 -> 3054;
3055 -> 1399;
3055 -> 1397;
3056 -> 1595;
3057 -> 3056;
3057 -> 1435;
3058 -> 3057;
3058 -> 1437;
3058 -> 1435;
3059 -> 1433;
3059 -> 1465;
3059 -> 1591;
3059 -> 3058;
3059 -> 1600;
3059 -> 1461;
3059 -> 1462;
3059 -> 3044;
3059 -> 1472;
3059 -> 1464;
3060 -> 1615;
3061 -> 3060;
3061 -> 1484;
3062 -> 3061;
3062 -> 1486;
3062 -> 1484;
3063 -> 1482;
3063 -> 1516;
3063 -> 1611;
3063 -> 3062;
3063 -> 1620;
3063 -> 1510;
3063 -> 1511;
3063 -> 3048;
3063 -> 1518;
3063 -> 1515;
3064 -> 1635;
3065 -> 3064;
3065 -> 1530;
3066 -> 3065;
3066 -> 1532;
3066 -> 1530;
3067 -> 1528;
3067 -> 1562;
3067 -> 1631;
3067 -> 3066;
3067 -> 1640;
3067 -> 1556;
3067 -> 1557;
3067 -> 3052;
3067 -> 1564;
3067 -> 1561;
3068 -> 1576;
3069 -> 3068;
3069 -> 1397;
3070 -> 3069;
3070 -> 1399;
3070 -> 1397;
3071 -> 1595;
3072 -> 3071;
3072 -> 1435;
3073 -> 3072;
3073 -> 1437;
3073 -> 1435;
3074 -> 1433;
3074 -> 1465;
3074 -> 1591;
3074 -> 3073;
3074 -> 1600;
3074 -> 1461;
3074 -> 1462;
3074 -> 3059;
3074 -> 1472;
3074 -> 1464;
3075 -> 1615;
3076 -> 3075;
3076 -> 1484;
3077 -> 3076;
3077 -> 1486;
3077 -> 1484;
3078 -> 1482;
3078 -> 1516;
3078 -> 1611;
3078 -> 3077;
3078 -> 1620;
3078 -> 1510;
3078 -> 1511;
3078 -> 3063;
3078 -> 1518;
3078 -> 1515;
3079 -> 1635;
3080 -> 3079;
3080 -> 1530;
3081 -> 3080;
3081 -> 1532;
3081 -> 1530;
3082 -> 1528;
3082 -> 1562;
3082 -> 1631;
3082 -> 3081;
3082 -> 1640;
3082 -> 1556;
3082 -> 1557;
3082 -> 3067;
3082 -> 1564;
3082 -> 1561;
3083 -> 1576;
3084 -> 3083;
3084 -> 1397;
3085 -> 3084;
3085 -> 1399;
3085 -> 1397;
3086 -> 1595;
3087 -> 3086;
3087 -> 1435;
3088 -> 3087;
3088 -> 1437;
3088 -> 1435;
3089 -> 1433;
3089 -> 1465;
3089 -> 1591;
3089 -> 3088;
3089 -> 1600;
3089 -> 1461;
3089 -> 1462;
3089 -> 3074;
3089 -> 1472;
3089 -> 1464;
3090 -> 1615;
3091 -> 3090;
3091 -> 1484;
3092 -> 3091;
3092 -> 1486;
3092 -> 1484;
3093 -> 1482;
3093 -> 1516;
3093 -> 1611;
3093 -> 3092;
3093 -> 1620;
3093 -> 1510;
3093 -> 1511;
3093 -> 3078;
3093 -> 1518;
3093 -> 1515;
3094 -> 1635;
3095 -> 3094;
3095 -> 1530;
3096 -> 3095;
3096 -> 1532;
3096 -> 1530;
3097 -> 1528;
3097 -> 1562;
3097 -> 1631;
3097 -> 3096;
3097 -> 1640;
3097 -> 1556;
3097 -> 1557;
3097 -> 3082;
3097 -> 1564;
3097 -> 1561;
3098 -> 1576;
3099 -> 3098;
3099 -> 1397;
3100 -> 3099;
3100 -> 1399;
3100 -> 1397;
3101 -> 1595;
3102 -> 3101;
3102 -> 1435;
3103 -> 3102;
3103 -> 1437;
3103 -> 1435;
3104 -> 1433;
3104 -> 1465;
3104 -> 1591;
3104 -> 3103;
3104 -> 1600;
3104 -> 1461;
3104 -> 1462;
3104 -> 3089;
3104 -> 1472;
3104 -> 1464;
3105 -> 1615;
3106 -> 3105;
3106 -> 1484;
3107 -> 3106;
3107 -> 1486;
3107 -> 1484;
3108 -> 1482;
3108 -> 1516;
3108 -> 1611;
3108 -> 3107;
3108 -> 1620;
3108 -> 1510;
3108 -> 1511;
3108 -> 3093;
3108 -> 1518;
3108 -> 1515;
3109 -> 1635;
3110 -> 3109;
3110 -> 1530;
3111 -> 3110;
3111 -> 1532;
3111 -> 1530;
3112 -> 1528;
3112 -> 1562;
3112 -> 1631;
3112 -> 3111;
3112 -> 1640;
3112 -> 1556;
3112 -> 1557;
3112 -> 3097;
3112 -> 1564;
3112 -> 1561;
3113 -> 1576;
3114 -> 3113;
3114 -> 1397;
3115 -> 3114;
3115 -> 1399;
3115 -> 1397;
3116 -> 1595;
3117 -> 3116;
3117 -> 1435;
3118 -> 3117;
3118 -> 1437;
3118 -> 1435;
3119 -> 1433;
3119 -> 1465;
3119 -> 1591;
3119 -> 3118;
3119 -> 1600;
3119 -> 1461;
3119 -> 1462;
3119 -> 3104;
3119 -> 1472;
3119 -> 1464;
3120 -> 1615;
3121 -> 3120;
3121 -> 1484;
3122 -> 3121;
3122 -> 1486;
3122 -> 1484;
3123 -> 1482;
3123 -> 1516;
3123 -> 1611;
3123 -> 3122;
3123 -> 1620;
3123 -> 1510;
3123 -> 1511;
3123 -> 3108;
3123 -> 1518;
3123 -> 1515;
3124 -> 1635;
3125 -> 3124;
3125 -> 1530;
3126 -> 3125;
3126 -> 1532;
3126 -> 1530;
3127 -> 1528;
3127 -> 1562;
3127 -> 1631;
3127 -> 3126;
3127 -> 1640;
3127 -> 1556;
3127 -> 1557;
3127 -> 3112;
3127 -> 1564;
3127 -> 1561;
3128 -> 1576;
3129 -> 3128;
3129 -> 1397;
3130 -> 3129;
3130 -> 1399;
3130 -> 1397;
3131 -> 1595;
3132 -> 3131;
3132 -> 1435;
3133 -> 3132;
3133 -> 1437;
3133 -> 1435;
3134 -> 1433;
3134 -> 1465;
3134 -> 1591;
3134 -> 3133;
3134 -> 1600;
3134 -> 1461;
3134 -> 1462;
3134 -> 3119;
3134 -> 1472;
3134 -> 1464;
3135 -> 1615;
3136 -> 3135;
3136 -> 1484;
3137 -> 3136;
3137 -> 1486;
3137 -> 1484;
3138 -> 1482;
3138 -> 1516;
3138 -> 1611;
3138 -> 3137;
3138 -> 1620;
3138 -> 1510;
3138 -> 1511;
3138 -> 3123;
3138 -> 1518;
3138 -> 1515;
3139 -> 1635;
3140 -> 3139;
3140 -> 1530;
3141 -> 3140;
3141 -> 1532;
3141 -> 1530;
3142 -> 1528;
3142 -> 1562;
3142 -> 1631;
3142 -> 3141;
3142 -> 1640;
3142 -> 1556;
3142 -> 1557;
3142 -> 3127;
3142 -> 1564;
3142 -> 1561;
3143 -> 1576;
3144 -> 3143;
3144 -> 1397;
3145 -> 3144;
3145 -> 1399;
3145 -> 1397;
3146 -> 1595;
3147 -> 3146;
3147 -> 1435;
3148 -> 3147;
3148 -> 1437;
3148 -> 1435;
3149 -> 1433;
3149 -> 1465;
3149 -> 1591;
3149 -> 3148;
3149 -> 1600;
3149 -> 1461;
3149 -> 1462;
3149 -> 3134;
3149 -> 1472;
3149 -> 1464;
3150 -> 1615;
3151 -> 3150;
3151 -> 1484;
3152 -> 3151;
3152 -> 1486;
3152 -> 1484;
3153 -> 1482;
3153 -> 1516;
3153 -> 1611;
3153 -> 3152;
3153 -> 1620;
3153 -> 1510;
3153 -> 1511;
3153 -> 3138;
3153 -> 1518;
3153 -> 1515;
3154 -> 1635;
3155 -> 3154;
3155 -> 1530;
3156 -> 3155;
3156 -> 1532;
3156 -> 1530;
3157 -> 1528;
3157 -> 1562;
3157 -> 1631;
3157 -> 3156;
3157 -> 1640;
3157 -> 1556;
3157 -> 1557;
3157 -> 3142;
3157 -> 1564;
3157 -> 1561;
3158 -> 1576;
3159 -> 3158;
3159 -> 1397;
3160 -> 3159;
3160 -> 1399;
3160 -> 1397;
3161 -> 1595;
3162 -> 3161;
3162 -> 1435;
3163 -> 3162;
3163 -> 1437;
3163 -> 1435;
3164 -> 1433;
3164 -> 1465;
3164 -> 1591;
3164 -> 3163;
3164 -> 1600;
3164 -> 1461;
3164 -> 1462;
3164 -> 3149;
3164 -> 1472;
3164 -> 1464;
3165 -> 1615;
3166 -> 3165;
3166 -> 1484;
3167 -> 3166;
3167 -> 1486;
3167 -> 1484;
3168 -> 1482;
3168 -> 1516;
3168 -> 1611;
3168 -> 3167;
3168 -> 1620;
3168 -> 1510;
3168 -> 1511;
3168 -> 3153;
3168 -> 1518;
3168 -> 1515;
3169 -> 1635;
3170 -> 3169;
3170 -> 1530;
3171 -> 3170;
3171 -> 1532;
3171 -> 1530;
3172 -> 1528;
3172 -> 1562;
3172 -> 1631;
3172 -> 3171;
3172 -> 1640;
3172 -> 1556;
3172 -> 1557;
3172 -> 3157;
3172 -> 1564;
3172 -> 1561;
3173 -> 1576;
3174 -> 3173;
3174 -> 1397;
3175 -> 3174;
3175 -> 1399;
3175 -> 1397;
3176 -> 1595;
3177 -> 3176;
3177 -> 1435;
3178 -> 3177;
3178 -> 1437;
3178 -> 1435;
3179 -> 1433;
3179 -> 1465;
3179 -> 1591;
3179 -> 3178;
3179 -> 1600;
3179 -> 1461;
3179 -> 1462;
3179 -> 3164;
3179 -> 1472;
3179 -> 1464;
3180 -> 1615;
3181 -> 3180;
3181 -> 1484;
3182 -> 3181;
3182 -> 1486;
3182 -> 1484;
3183 -> 1482;
3183 -> 1516;
3183 -> 1611;
3183 -> 3182;
3183 -> 1620;
3183 -> 1510;
3183 -> 1511;
3183 -> 3168;
3183 -> 1518;
3183 -> 1515;
3184 -> 1635;
3185 -> 3184;
3185 -> 1530;
3186 -> 3185;
3186 -> 1532;
3186 -> 1530;
3187 -> 1528;
3187 -> 1562;
3187 -> 1631;
3187 -> 3186;
3187 -> 1640;
3187 -> 1556;
3187 -> 1557;
3187 -> 3172;
3187 -> 1564;
3187 -> 1561;
3188 -> 1576;
3189 -> 3188;
3189 -> 1397;
3190 -> 3189;
3190 -> 1399;
3190 -> 1397;
3191 -> 1595;
3192 -> 3191;
3192 -> 1435;
3193 -> 3192;
3193 -> 1437;
3193 -> 1435;
3194 -> 1433;
3194 -> 1465;
3194 -> 1591;
3194 -> 3193;
3194 -> 1600;
3194 -> 1461;
3194 -> 1462;
3194 -> 3179;
3194 -> 1472;
3194 -> 1464;
3195 -> 1615;
3196 -> 3195;
3196 -> 1484;
3197 -> 3196;
3197 -> 1486;
3197 -> 1484;
3198 -> 1482;
3198 -> 1516;
3198 -> 1611;
3198 -> 3197;
3198 -> 1620;
3198 -> 1510;
3198 -> 1511;
3198 -> 3183;
3198 -> 1518;
3198 -> 1515;
3199 -> 1635;
3200 -> 3199;
3200 -> 1530;
3201 -> 3200;
3201 -> 1532;
3201 -> 1530;
3202 -> 1528;
3202 -> 1562;
3202 -> 1631;
3202 -> 3201;
3202 -> 1640;
3202 -> 1556;
3202 -> 1557;
3202 -> 3187;
3202 -> 1564;
3202 -> 1561;
3203 -> 1576;
3204 -> 3203;
3204 -> 1397;
3205 -> 3204;
3205 -> 1399;
3205 -> 1397;
3206 -> 1595;
3207 -> 3206;
3207 -> 1435;
3208 -> 3207;
3208 -> 1437;
3208 -> 1435;
3209 -> 1433;
3209 -> 1465;
3209 -> 1591;
3209 -> 3208;
3209 -> 1600;
3209 -> 1461;
3209 -> 1462;
3209 -> 3194;
3209 -> 1472;
3209 -> 1464;
3210 -> 1615;
3211 -> 3210;
3211 -> 1484;
3212 -> 3211;
3212 -> 1486;
3212 -> 1484;
3213 -> 1482;
3213 -> 1516;
3213 -> 1611;
3213 -> 3212;
3213 -> 1620;
3213 -> 1510;
3213 -> 1511;
3213 -> 3198;
3213 -> 1518;
3213 -> 1515;
3214 -> 1635;
3215 -> 3214;
3215 -> 1530;
3216 -> 3215;
3216 -> 1532;
3216 -> 1530;
3217 -> 1528;
3217 -> 1562;
3217 -> 1631;
3217 -> 3216;
3217 -> 1640;
3217 -> 1556;
3217 -> 1557;
3217 -> 3202;
3217 -> 1564;
3217 -> 1561;
3218 -> 1576;
3219 -> 3218;
3219 -> 1397;
3220 -> 3219;
3220 -> 1399;
3220 -> 1397;
3221 -> 1595;
3222 -> 3221;
3222 -> 1435;
3223 -> 3222;
3223 -> 1437;
3223 -> 1435;
3224 -> 1433;
3224 -> 1465;
3224 -> 1591;
3224 -> 3223;
3224 -> 1600;
3224 -> 1461;
3224 -> 1462;
3224 -> 3209;
3224 -> 1472;
3224 -> 1464;
3225 -> 1615;
3226 -> 3225;
3226 -> 1484;
3227 -> 3226;
3227 -> 1486;
3227 -> 1484;
3228 -> 1482;
3228 -> 1516;
3228 -> 1611;
3228 -> 3227;
3228 -> 1620;
3228 -> 1510;
3228 -> 1511;
3228 -> 3213;
3228 -> 1518;
3228 -> 1515;
3229 -> 1635;
3230 -> 3229;
3230 -> 1530;
3231 -> 3230;
3231 -> 1532;
3231 -> 1530;
3232 -> 1528;
3232 -> 1562;
3232 -> 1631;
3232 -> 3231;
3232 -> 1640;
3232 -> 1556;
3232 -> 1557;
3232 -> 3217;
3232 -> 1564;
3232 -> 1561;
3233 -> 1576;
3234 -> 3233;
3234 -> 1397;
3235 -> 3234;
3235 -> 1399;
3235 -> 1397;
3236 -> 1595;
3237 -> 3236;
3237 -> 1435;
3238 -> 3237;
3238 -> 1437;
3238 -> 1435;
3239 -> 1433;
3239 -> 1465;
3239 -> 1591;
3239 -> 3238;
3239 -> 1600;
3239 -> 1461;
3239 -> 1462;
3239 -> 3224;
3239 -> 1472;
3239 -> 1464;
3240 -> 1615;
3241 -> 3240;
3241 -> 1484;
3242 -> 3241;
3242 -> 1486;
3242 -> 1484;
3243 -> 1482;
3243 -> 1516;
3243 -> 1611;
3243 -> 3242;
3243 -> 1620;
3243 -> 1510;
3243 -> 1511;
3243 -> 3228;
3243 -> 1518;
3243 -> 1515;
3244 -> 1635;
3245 -> 3244;
3245 -> 1530;
3246 -> 3245;
3246 -> 1532;
3246 -> 1530;
3247 -> 1528;
3247 -> 1562;
3247 -> 1631;
3247 -> 3246;
3247 -> 1640;
3247 -> 1556;
3247 -> 1557;
3247 -> 3232;
3247 -> 1564;
3247 -> 1561;
3248 -> 1576;
3249 -> 3248;
3249 -> 1397;
3250 -> 3249;
3250 -> 1399;
3250 -> 1397;
3251 -> 1595;
3252 -> 3251;
3252 -> 1435;
3253 -> 3252;
3253 -> 1437;
3253 -> 1435;
3254 -> 1433;
3254 -> 1465;
3254 -> 1591;
3254 -> 3253;
3254 -> 1600;
3254 -> 1461;
3254 -> 1462;
3254 -> 3239;
3254 -> 1472;
3254 -> 1464;
3255 -> 1615;
3256 -> 3255;
3256 -> 1484;
3257 -> 3256;
3257 -> 1486;
3257 -> 1484;
3258 -> 1482;
3258 -> 1516;
3258 -> 1611;
3258 -> 3257;
3258 -> 1620;
3258 -> 1510;
3258 -> 1511;
3258 -> 3243;
3258 -> 1518;
3258 -> 1515;
3259 -> 1635;
3260 -> 3259;
3260 -> 1530;
3261 -> 3260;
3261 -> 1532;
3261 -> 1530;
3262 -> 1528;
3262 -> 1562;
3262 -> 1631;
3262 -> 3261;
3262 -> 1640;
3262 -> 1556;
3262 -> 1557;
3262 -> 3247;
3262 -> 1564;
3262 -> 1561;
3263 -> 1576;
3264 -> 3263;
3264 -> 1397;
3265 -> 3264;
3265 -> 1399;
3265 -> 1397;
3266 -> 1595;
3267 -> 3266;
3267 -> 1435;
3268 -> 3267;
3268 -> 1437;
3268 -> 1435;
3269 -> 1433;
3269 -> 1465;
3269 -> 1591;
3269 -> 3268;
3269 -> 1600;
3269 -> 1461;
3269 -> 1462;
3269 -> 3254;
3269 -> 1472;
3269 -> 1464;
3270 -> 1615;
3271 -> 3270;
3271 -> 1484;
3272 -> 3271;
3272 -> 1486;
3272 -> 1484;
3273 -> 1482;
3273 -> 1516;
3273 -> 1611;
3273 -> 3272;
3273 -> 1620;
3273 -> 1510;
3273 -> 1511;
3273 -> 3258;
3273 -> 1518;
3273 -> 1515;
3274 -> 1635;
3275 -> 3274;
3275 -> 1530;
3276 -> 3275;
3276 -> 1532;
3276 -> 1530;
3277 -> 1528;
3277 -> 1562;
3277 -> 1631;
3277 -> 3276;
3277 -> 1640;
3277 -> 1556;
3277 -> 1557;
3277 -> 3262;
3277 -> 1564;
3277 -> 1561;
3278 -> 1576;
3279 -> 3278;
3279 -> 1397;
3280 -> 3279;
3280 -> 1399;
3280 -> 1397;
3281 -> 1595;
3282 -> 3281;
3282 -> 1435;
3283 -> 3282;
3283 -> 1437;
3283 -> 1435;
3284 -> 1433;
3284 -> 1465;
3284 -> 1591;
3284 -> 3283;
3284 -> 1600;
3284 -> 1461;
3284 -> 1462;
3284 -> 3269;
3284 -> 1472;
3284 -> 1464;
3285 -> 1615;
3286 -> 3285;
3286 -> 1484;
3287 -> 3286;
3287 -> 1486;
3287 -> 1484;
3288 -> 1482;
3288 -> 1516;
3288 -> 1611;
3288 -> 3287;
3288 -> 1620;
3288 -> 1510;
3288 -> 1511;
3288 -> 3273;
3288 -> 1518;
3288 -> 1515;
3289 -> 1635;
3290 -> 3289;
3290 -> 1530;
3291 -> 3290;
3291 -> 1532;
3291 -> 1530;
3292 -> 1528;
3292 -> 1562;
3292 -> 1631;
3292 -> 3291;
3292 -> 1640;
3292 -> 1556;
3292 -> 1557;
3292 -> 3277;
3292 -> 1564;
3292 -> 1561;
3293 -> 1576;
3294 -> 3293;
3294 -> 1397;
3295 -> 3294;
3295 -> 1399;
3295 -> 1397;
3296 -> 1595;
3297 -> 3296;
3297 -> 1435;
3298 -> 3297;
3298 -> 1437;
3298 -> 1435;
3299 -> 1433;
3299 -> 1465;
3299 -> 1591;
3299 -> 3298;
3299 -> 1600;
3299 -> 1461;
3299 -> 1462;
3299 -> 3284;
3299 -> 1472;
3299 -> 1464;
3300 -> 1615;
3301 -> 3300;
3301 -> 1484;
3302 -> 3301;
3302 -> 1486;
3302 -> 1484;
3303 -> 1482;
3303 -> 1516;
3303 -> 1611;
3303 -> 3302;
3303 -> 1620;
3303 -> 1510;
3303 -> 1511;
3303 -> 3288;
3303 -> 1518;
3303 -> 1515;
3304 -> 1635;
3305 -> 3304;
3305 -> 1530;
3306 -> 3305;
3306 -> 1532;
3306 -> 1530;
3307 -> 1528;
3307 -> 1562;
3307 -> 1631;
3307 -> 3306;
3307 -> 1640;
3307 -> 1556;
3307 -> 1557;
3307 -> 3292;
3307 -> 1564;
3307 -> 1561;
3308 -> 1576;
3309 -> 3308;
3309 -> 1397;
3310 -> 3309;
3310 -> 1399;
3310 -> 1397;
3311 -> 1595;
3312 -> 3311;
3312 -> 1435;
3313 -> 3312;
3313 -> 1437;
3313 -> 1435;
3314 -> 1433;
3314 -> 1465;
3314 -> 1591;
3314 -> 3313;
3314 -> 1600;
3314 -> 1461;
3314 -> 1462;
3314 -> 3299;
3314 -> 1472;
3314 -> 1464;
3315 -> 1615;
3316 -> 3315;
3316 -> 1484;
3317 -> 3316;
3317 -> 1486;
3317 -> 1484;
3318 -> 1482;
3318 -> 1516;
3318 -> 1611;
3318 -> 3317;
3318 -> 1620;
3318 -> 1510;
3318 -> 1511;
3318 -> 3303;
3318 -> 1518;
3318 -> 1515;
3319 -> 1635;
3320 -> 3319;
3320 -> 1530;
3321 -> 3320;
3321 -> 1532;
3321 -> 1530;
3322 -> 1528;
3322 -> 1562;
3322 -> 1631;
3322 -> 3321;
3322 -> 1640;
3322 -> 1556;
3322 -> 1557;
3322 -> 3307;
3322 -> 1564;
3322 -> 1561;
3323 -> 1576;
3324 -> 3323;
3324 -> 1397;
3325 -> 3324;
3325 -> 1399;
3325 -> 1397;
3326 -> 1595;
3327 -> 3326;
3327 -> 1435;
3328 -> 3327;
3328 -> 1437;
3328 -> 1435;
3329 -> 1433;
3329 -> 1465;
3329 -> 1591;
3329 -> 3328;
3329 -> 1600;
3329 -> 1461;
3329 -> 1462;
3329 -> 3314;
3329 -> 1472;
3329 -> 1464;
3330 -> 1615;
3331 -> 3330;
3331 -> 1484;
3332 -> 3331;
3332 -> 1486;
3332 -> 1484;
3333 -> 1482;
3333 -> 1516;
3333 -> 1611;
3333 -> 3332;
3333 -> 1620;
3333 -> 1510;
3333 -> 1511;
3333 -> 3318;
3333 -> 1518;
3333 -> 1515;
3334 -> 1635;
3335 -> 3334;
3335 -> 1530;
3336 -> 3335;
3336 -> 1532;
3336 -> 1530;
3337 -> 1528;
3337 -> 1562;
3337 -> 1631;
3337 -> 3336;
3337 -> 1640;
3337 -> 1556;
3337 -> 1557;
3337 -> 3322;
3337 -> 1564;
3337 -> 1561;
3338 -> 1576;
3339 -> 3338;
3339 -> 1397;
3340 -> 3339;
3340 -> 1399;
3340 -> 1397;
3341 -> 1595;
3342 -> 3341;
3342 -> 1435;
3343 -> 3342;
3343 -> 1437;
3343 -> 1435;
3344 -> 1433;
3344 -> 1465;
3344 -> 1591;
3344 -> 3343;
3344 -> 1600;
3344 -> 1461;
3344 -> 1462;
3344 -> 3329;
3344 -> 1472;
3344 -> 1464;
3345 -> 1615;
3346 -> 3345;
3346 -> 1484;
3347 -> 3346;
3347 -> 1486;
3347 -> 1484;
3348 -> 1482;
3348 -> 1516;
3348 -> 1611;
3348 -> 3347;
3348 -> 1620;
3348 -> 1510;
3348 -> 1511;
3348 -> 3333;
3348 -> 1518;
3348 -> 1515;
3349 -> 1635;
3350 -> 3349;
3350 -> 1530;
3351 -> 3350;
3351 -> 1532;
3351 -> 1530;
3352 -> 1528;
3352 -> 1562;
3352 -> 1631;
3352 -> 3351;
3352 -> 1640;
3352 -> 1556;
3352 -> 1557;
3352 -> 3337;
3352 -> 1564;
3352 -> 1561;
3353 -> 1576;
3354 -> 3353;
3354 -> 1397;
3355 -> 3354;
3355 -> 1399;
3355 -> 1397;
3356 -> 1595;
3357 -> 3356;
3357 -> 1435;
3358 -> 3357;
3358 -> 1437;
3358 -> 1435;
3359 -> 1433;
3359 -> 1465;
3359 -> 1591;
3359 -> 3358;
3359 -> 1600;
3359 -> 1461;
3359 -> 1462;
3359 -> 3344;
3359 -> 1472;
3359 -> 1464;
3360 -> 1615;
3361 -> 3360;
3361 -> 1484;
3362 -> 3361;
3362 -> 1486;
3362 -> 1484;
3363 -> 1482;
3363 -> 1516;
3363 -> 1611;
3363 -> 3362;
3363 -> 1620;
3363 -> 1510;
3363 -> 1511;
3363 -> 3348;
3363 -> 1518;
3363 -> 1515;
3364 -> 1635;
3365 -> 3364;
3365 -> 1530;
3366 -> 3365;
3366 -> 1532;
3366 -> 1530;
3367 -> 1528;
3367 -> 1562;
3367 -> 1631;
3367 -> 3366;
3367 -> 1640;
3367 -> 1556;
3367 -> 1557;
3367 -> 3352;
3367 -> 1564;
3367 -> 1561;
3368 -> 1576;
3369 -> 3368;
3369 -> 1397;
3370 -> 3369;
3370 -> 1399;
3370 -> 1397;
3371 -> 1595;
3372 -> 3371;
3372 -> 1435;
3373 -> 3372;
3373 -> 1437;
3373 -> 1435;
3374 -> 1433;
3374 -> 1465;
3374 -> 1591;
3374 -> 3373;
3374 -> 1600;
3374 -> 1461;
3374 -> 1462;
3374 -> 3359;
3374 -> 1472;
3374 -> 1464;
3375 -> 1615;
3376 -> 3375;
3376 -> 1484;
3377 -> 3376;
3377 -> 1486;
3377 -> 1484;
3378 -> 1482;
3378 -> 1516;
3378 -> 1611;
3378 -> 3377;
3378 -> 1620;
3378 -> 1510;
3378 -> 1511;
3378 -> 3363;
3378 -> 1518;
3378 -> 1515;
3379 -> 1635;
3380 -> 3379;
3380 -> 1530;
3381 -> 3380;
3381 -> 1532;
3381 -> 1530;
3382 -> 1528;
3382 -> 1562;
3382 -> 1631;
3382 -> 3381;
3382 -> 1640;
3382 -> 1556;
3382 -> 1557;
3382 -> 3367;
3382 -> 1564;
3382 -> 1561;
3383 -> 1576;
3384 -> 3383;
3384 -> 1397;
3385 -> 3384;
3385 -> 1399;
3385 -> 1397;
3386 -> 1595;
3387 -> 3386;
3387 -> 1435;
3388 -> 3387;
3388 -> 1437;
3388 -> 1435;
3389 -> 1433;
3389 -> 1465;
3389 -> 1591;
3389 -> 3388;
3389 -> 1600;
3389 -> 1461;
3389 -> 1462;
3389 -> 3374;
3389 -> 1472;
3389 -> 1464;
3390 -> 1615;
3391 -> 3390;
3391 -> 1484;
3392 -> 3391;
3392 -> 1486;
3392 -> 1484;
3393 -> 1482;
3393 -> 1516;
3393 -> 1611;
3393 -> 3392;
3393 -> 1620;
3393 -> 1510;
3393 -> 1511;
3393 -> 3378;
3393 -> 1518;
3393 -> 1515;
3394 -> 1635;
3395 -> 3394;
3395 -> 1530;
3396 -> 3395;
3396 -> 1532;
3396 -> 1530;
3397 -> 1528;
3397 -> 1562;
3397 -> 1631;
3397 -> 3396;
3397 -> 1640;
3397 -> 1556;
3397 -> 1557;
3397 -> 3382;
3397 -> 1564;
3397 -> 1561;
3398 -> 1576;
3399 -> 3398;
3399 -> 1397;
3400 -> 3399;
3400 -> 1399;
3400 -> 1397;
3401 -> 1595;
3402 -> 3401;
3402 -> 1435;
3403 -> 3402;
3403 -> 1437;
3403 -> 1435;
3404 -> 1433;
3404 -> 1465;
3404 -> 1591;
3404 -> 3403;
3404 -> 1600;
3404 -> 1461;
3404 -> 1462;
3404 -> 3389;
3404 -> 1472;
3404 -> 1464;
3405 -> 1615;
3406 -> 3405;
3406 -> 1484;
3407 -> 3406;
3407 -> 1486;
3407 -> 1484;
3408 -> 1482;
3408 -> 1516;
3408 -> 1611;
3408 -> 3407;
3408 -> 1620;
3408 -> 1510;
3408 -> 1511;
3408 -> 3393;
3408 -> 1518;
3408 -> 1515;
3409 -> 1635;
3410 -> 3409;
3410 -> 1530;
3411 -> 3410;
3411 -> 1532;
3411 -> 1530;
3412 -> 1528;
3412 -> 1562;
3412 -> 1631;
3412 -> 3411;
3412 -> 1640;
3412 -> 1556;
3412 -> 1557;
3412 -> 3397;
3412 -> 1564;
3412 -> 1561;
3413 -> 1576;
3414 -> 3413;
3414 -> 1397;
3415 -> 3414;
3415 -> 1399;
3415 -> 1397;
3416 -> 1595;
3417 -> 3416;
3417 -> 1435;
3418 -> 3417;
3418 -> 1437;
3418 -> 1435;
3419 -> 1433;
3419 -> 1465;
3419 -> 1591;
3419 -> 3418;
3419 -> 1600;
3419 -> 1461;
3419 -> 1462;
3419 -> 3404;
3419 -> 1472;
3419 -> 1464;
3420 -> 1615;
3421 -> 3420;
3421 -> 1484;
3422 -> 3421;
3422 -> 1486;
3422 -> 1484;
3423 -> 1482;
3423 -> 1516;
3423 -> 1611;
3423 -> 3422;
3423 -> 1620;
3423 -> 1510;
3423 -> 1511;
3423 -> 3408;
3423 -> 1518;
3423 -> 1515;
3424 -> 1635;
3425 -> 3424;
3425 -> 1530;
3426 -> 3425;
3426 -> 1532;
3426 -> 1530;
3427 -> 1528;
3427 -> 1562;
3427 -> 1631;
3427 -> 3426;
3427 -> 1640;
3427 -> 1556;
3427 -> 1557;
3427 -> 3412;
3427 -> 1564;
3427 -> 1561;
3428 -> 1576;
3429 -> 3428;
3429 -> 1397;
3430 -> 3429;
3430 -> 1399;
3430 -> 1397;
3431 -> 1595;
3432 -> 3431;
3432 -> 1435;
3433 -> 3432;
3433 -> 1437;
3433 -> 1435;
3434 -> 1433;
3434 -> 1465;
3434 -> 1591;
3434 -> 3433;
3434 -> 1600;
3434 -> 1461;
3434 -> 1462;
3434 -> 3419;
3434 -> 1472;
3434 -> 1464;
3435 -> 1615;
3436 -> 3435;
3436 -> 1484;
3437 -> 3436;
3437 -> 1486;
3437 -> 1484;
3438 -> 1482;
3438 -> 1516;
3438 -> 1611;
3438 -> 3437;
3438 -> 1620;
3438 -> 1510;
3438 -> 1511;
3438 -> 3423;
3438 -> 1518;
3438 -> 1515;
3439 -> 1635;
3440 -> 3439;
3440 -> 1530;
3441 -> 3440;
3441 -> 1532;
3441 -> 1530;
3442 -> 1528;
3442 -> 1562;
3442 -> 1631;
3442 -> 3441;
3442 -> 1640;
3442 -> 1556;
3442 -> 1557;
3442 -> 3427;
3442 -> 1564;
3442 -> 1561;
3443 -> 1576;
3444 -> 3443;
3444 -> 1397;
3445 -> 3444;
3445 -> 1399;
3445 -> 1397;
3446 -> 1595;
3447 -> 3446;
3447 -> 1435;
3448 -> 3447;
3448 -> 1437;
3448 -> 1435;
3449 -> 1433;
3449 -> 1465;
3449 -> 1591;
3449 -> 3448;
3449 -> 1600;
3449 -> 1461;
3449 -> 1462;
3449 -> 3434;
3449 -> 1472;
3449 -> 1464;
3450 -> 1615;
3451 -> 3450;
3451 -> 1484;
3452 -> 3451;
3452 -> 1486;
3452 -> 1484;
3453 -> 1482;
3453 -> 1516;
3453 -> 1611;
3453 -> 3452;
3453 -> 1620;
3453 -> 1510;
3453 -> 1511;
3453 -> 3438;
3453 -> 1518;
3453 -> 1515;
3454 -> 1635;
3455 -> 3454;
3455 -> 1530;
3456 -> 3455;
3456 -> 1532;
3456 -> 1530;
3457 -> 1528;
3457 -> 1562;
3457 -> 1631;
3457 -> 3456;
3457 -> 1640;
3457 -> 1556;
3457 -> 1557;
3457 -> 3442;
3457 -> 1564;
3457 -> 1561;
3458 -> 1576;
3459 -> 3458;
3459 -> 1397;
3460 -> 3459;
3460 -> 1399;
3460 -> 1397;
3461 -> 1595;
3462 -> 3461;
3462 -> 1435;
3463 -> 3462;
3463 -> 1437;
3463 -> 1435;
3464 -> 1433;
3464 -> 1465;
3464 -> 1591;
3464 -> 3463;
3464 -> 1600;
3464 -> 1461;
3464 -> 1462;
3464 -> 3449;
3464 -> 1472;
3464 -> 1464;
3465 -> 1615;
3466 -> 3465;
3466 -> 1484;
3467 -> 3466;
3467 -> 1486;
3467 -> 1484;
3468 -> 1482;
3468 -> 1516;
3468 -> 1611;
3468 -> 3467;
3468 -> 1620;
3468 -> 1510;
3468 -> 1511;
3468 -> 3453;
3468 -> 1518;
3468 -> 1515;
3469 -> 1635;
3470 -> 3469;
3470 -> 1530;
3471 -> 3470;
3471 -> 1532;
3471 -> 1530;
3472 -> 1528;
3472 -> 1562;
3472 -> 1631;
3472 -> 3471;
3472 -> 1640;
3472 -> 1556;
3472 -> 1557;
3472 -> 3457;
3472 -> 1564;
3472 -> 1561;
3473 -> 1576;
3474 -> 3473;
3474 -> 1397;
3475 -> 3474;
3475 -> 1399;
3475 -> 1397;
3476 -> 1595;
3477 -> 3476;
3477 -> 1435;
3478 -> 3477;
3478 -> 1437;
3478 -> 1435;
3479 -> 1433;
3479 -> 1465;
3479 -> 1591;
3479 -> 3478;
3479 -> 1600;
3479 -> 1461;
3479 -> 1462;
3479 -> 3464;
3479 -> 1472;
3479 -> 1464;
3480 -> 1615;
3481 -> 3480;
3481 -> 1484;
3482 -> 3481;
3482 -> 1486;
3482 -> 1484;
3483 -> 1482;
3483 -> 1516;
3483 -> 1611;
3483 -> 3482;
3483 -> 1620;
3483 -> 1510;
3483 -> 1511;
3483 -> 3468;
3483 -> 1518;
3483 -> 1515;
3484 -> 1635;
3485 -> 3484;
3485 -> 1530;
3486 -> 3485;
3486 -> 1532;
3486 -> 1530;
3487 -> 1528;
3487 -> 1562;
3487 -> 1631;
3487 -> 3486;
3487 -> 1640;
3487 -> 1556;
3487 -> 1557;
3487 -> 3472;
3487 -> 1564;
3487 -> 1561;
3488 -> 1576;
3489 -> 3488;
3489 -> 1397;
3490 -> 3489;
3490 -> 1399;
3490 -> 1397;
3491 -> 1595;
3492 -> 3491;
3492 -> 1435;
3493 -> 3492;
3493 -> 1437;
3493 -> 1435;
3494 -> 1433;
3494 -> 1465;
3494 -> 1591;
3494 -> 3493;
3494 -> 1600;
3494 -> 1461;
3494 -> 1462;
3494 -> 3479;
3494 -> 1472;
3494 -> 1464;
3495 -> 1615;
3496 -> 3495;
3496 -> 1484;
3497 -> 3496;
3497 -> 1486;
3497 -> 1484;
3498 -> 1482;
3498 -> 1516;
3498 -> 1611;
3498 -> 3497;
3498 -> 1620;
3498 -> 1510;
3498 -> 1511;
3498 -> 3483;
3498 -> 1518;
3498 -> 1515;
3499 -> 1635;
3500 -> 3499;
3500 -> 1530;
3501 -> 3500;
3501 -> 1532;
3501 -> 1530;
3502 -> 1528;
3502 -> 1562;
3502 -> 1631;
3502 -> 3501;
3502 -> 1640;
3502 -> 1556;
3502 -> 1557;
3502 -> 3487;
3502 -> 1564;
3502 -> 1561;
3503 -> 1576;
3504 -> 3503;
3504 -> 1397;
3505 -> 3504;
3505 -> 1399;
3505 -> 1397;
3506 -> 1595;
3507 -> 3506;
3507 -> 1435;
3508 -> 3507;
3508 -> 1437;
3508 -> 1435;
3509 -> 1433;
3509 -> 1465;
3509 -> 1591;
3509 -> 3508;
3509 -> 1600;
3509 -> 1461;
3509 -> 1462;
3509 -> 3494;
3509 -> 1472;
3509 -> 1464;
3510 -> 1615;
3511 -> 3510;
3511 -> 1484;
3512 -> 3511;
3512 -> 1486;
3512 -> 1484;
3513 -> 1482;
3513 -> 1516;
3513 -> 1611;
3513 -> 3512;
3513 -> 1620;
3513 -> 1510;
3513 -> 1511;
3513 -> 3498;
3513 -> 1518;
3513 -> 1515;
3514 -> 1635;
3515 -> 3514;
3515 -> 1530;
3516 -> 3515;
3516 -> 1532;
3516 -> 1530;
3517 -> 1528;
3517 -> 1562;
3517 -> 1631;
3517 -> 3516;
3517 -> 1640;
3517 -> 1556;
3517 -> 1557;
3517 -> 3502;
3517 -> 1564;
3517 -> 1561;
3518 -> 1576;
3519 -> 3518;
3519 -> 1397;
3520 -> 3519;
3520 -> 1399;
3520 -> 1397;
3521 -> 1595;
3522 -> 3521;
3522 -> 1435;
3523 -> 3522;
3523 -> 1437;
3523 -> 1435;
3524 -> 1433;
3524 -> 1465;
3524 -> 1591;
3524 -> 3523;
3524 -> 1600;
3524 -> 1461;
3524 -> 1462;
3524 -> 3509;
3524 -> 1472;
3524 -> 1464;
3525 -> 1615;
3526 -> 3525;
3526 -> 1484;
3527 -> 3526;
3527 -> 1486;
3527 -> 1484;
3528 -> 1482;
3528 -> 1516;
3528 -> 1611;
3528 -> 3527;
3528 -> 1620;
3528 -> 1510;
3528 -> 1511;
3528 -> 3513;
3528 -> 1518;
3528 -> 1515;
3529 -> 1635;
3530 -> 3529;
3530 -> 1530;
3531 -> 3530;
3531 -> 1532;
3531 -> 1530;
3532 -> 1528;
3532 -> 1562;
3532 -> 1631;
3532 -> 3531;
3532 -> 1640;
3532 -> 1556;
3532 -> 1557;
3532 -> 3517;
3532 -> 1564;
3532 -> 1561;
3533 -> 1576;
3534 -> 3533;
3534 -> 1397;
3535 -> 3534;
3535 -> 1399;
3535 -> 1397;
3536 -> 1595;
3537 -> 3536;
3537 -> 1435;
3538 -> 3537;
3538 -> 1437;
3538 -> 1435;
3539 -> 1433;
3539 -> 1465;
3539 -> 1591;
3539 -> 3538;
3539 -> 1600;
3539 -> 1461;
3539 -> 1462;
3539 -> 3524;
3539 -> 1472;
3539 -> 1464;
3540 -> 1615;
3541 -> 3540;
3541 -> 1484;
3542 -> 3541;
3542 -> 1486;
3542 -> 1484;
3543 -> 1482;
3543 -> 1516;
3543 -> 1611;
3543 -> 3542;
3543 -> 1620;
3543 -> 1510;
3543 -> 1511;
3543 -> 3528;
3543 -> 1518;
3543 -> 1515;
3544 -> 1635;
3545 -> 3544;
3545 -> 1530;
3546 -> 3545;
3546 -> 1532;
3546 -> 1530;
3547 -> 1528;
3547 -> 1562;
3547 -> 1631;
3547 -> 3546;
3547 -> 1640;
3547 -> 1556;
3547 -> 1557;
3547 -> 3532;
3547 -> 1564;
3547 -> 1561;
3548 -> 1576;
3549 -> 3548;
3549 -> 1397;
3550 -> 3549;
3550 -> 1399;
3550 -> 1397;
3551 -> 1595;
3552 -> 3551;
3552 -> 1435;
3553 -> 3552;
3553 -> 1437;
3553 -> 1435;
3554 -> 1433;
3554 -> 1465;
3554 -> 1591;
3554 -> 3553;
3554 -> 1600;
3554 -> 1461;
3554 -> 1462;
3554 -> 3539;
3554 -> 1472;
3554 -> 1464;
3555 -> 1615;
3556 -> 3555;
3556 -> 1484;
3557 -> 3556;
3557 -> 1486;
3557 -> 1484;
3558 -> 1482;
3558 -> 1516;
3558 -> 1611;
3558 -> 3557;
3558 -> 1620;
3558 -> 1510;
3558 -> 1511;
3558 -> 3543;
3558 -> 1518;
3558 -> 1515;
3559 -> 1635;
3560 -> 3559;
3560 -> 1530;
3561 -> 3560;
3561 -> 1532;
3561 -> 1530;
3562 -> 1528;
3562 -> 1562;
3562 -> 1631;
3562 -> 3561;
3562 -> 1640;
3562 -> 1556;
3562 -> 1557;
3562 -> 3547;
3562 -> 1564;
3562 -> 1561;
3563 -> 1576;
3564 -> 3563;
3564 -> 1397;
3565 -> 3564;
3565 -> 1399;
3565 -> 1397;
3566 -> 1595;
3567 -> 3566;
3567 -> 1435;
3568 -> 3567;
3568 -> 1437;
3568 -> 1435;
3569 -> 1433;
3569 -> 1465;
3569 -> 1591;
3569 -> 3568;
3569 -> 1600;
3569 -> 1461;
3569 -> 1462;
3569 -> 3554;
3569 -> 1472;
3569 -> 1464;
3570 -> 1615;
3571 -> 3570;
3571 -> 1484;
3572 -> 3571;
3572 -> 1486;
3572 -> 1484;
3573 -> 1482;
3573 -> 1516;
3573 -> 1611;
3573 -> 3572;
3573 -> 1620;
3573 -> 1510;
3573 -> 1511;
3573 -> 3558;
3573 -> 1518;
3573 -> 1515;
3574 -> 1635;
3575 -> 3574;
3575 -> 1530;
3576 -> 3575;
3576 -> 1532;
3576 -> 1530;
3577 -> 1528;
3577 -> 1562;
3577 -> 1631;
3577 -> 3576;
3577 -> 1640;
3577 -> 1556;
3577 -> 1557;
3577 -> 3562;
3577 -> 1564;
3577 -> 1561;
3578 -> 1576;
3579 -> 3578;
3579 -> 1397;
3580 -> 3579;
3580 -> 1399;
3580 -> 1397;
3581 -> 1595;
3582 -> 3581;
3582 -> 1435;
3583 -> 3582;
3583 -> 1437;
3583 -> 1435;
3584 -> 1433;
3584 -> 1465;
3584 -> 1591;
3584 -> 3583;
3584 -> 1600;
3584 -> 1461;
3584 -> 1462;
3584 -> 3569;
3584 -> 1472;
3584 -> 1464;
3585 -> 1615;
3586 -> 3585;
3586 -> 1484;
3587 -> 3586;
3587 -> 1486;
3587 -> 1484;
3588 -> 1482;
3588 -> 1516;
3588 -> 1611;
3588 -> 3587;
3588 -> 1620;
3588 -> 1510;
3588 -> 1511;
3588 -> 3573;
3588 -> 1518;
3588 -> 1515;
3589 -> 1635;
3590 -> 3589;
3590 -> 1530;
3591 -> 3590;
3591 -> 1532;
3591 -> 1530;
3592 -> 1528;
3592 -> 1562;
3592 -> 1631;
3592 -> 3591;
3592 -> 1640;
3592 -> 1556;
3592 -> 1557;
3592 -> 3577;
3592 -> 1564;
3592 -> 1561;
3593 -> 1576;
3594 -> 3593;
3594 -> 1397;
3595 -> 3594;
3595 -> 1399;
3595 -> 1397;
3596 -> 1595;
3597 -> 3596;
3597 -> 1435;
3598 -> 3597;
3598 -> 1437;
3598 -> 1435;
3599 -> 1433;
3599 -> 1465;
3599 -> 1591;
3599 -> 3598;
3599 -> 1600;
3599 -> 1461;
3599 -> 1462;
3599 -> 3584;
3599 -> 1472;
3599 -> 1464;
3600 -> 1615;
3601 -> 3600;
3601 -> 1484;
3602 -> 3601;
3602 -> 1486;
3602 -> 1484;
3603 -> 1482;
3603 -> 1516;
3603 -> 1611;
3603 -> 3602;
3603 -> 1620;
3603 -> 1510;
3603 -> 1511;
3603 -> 3588;
3603 -> 1518;
3603 -> 1515;
3604 -> 1635;
3605 -> 3604;
3605 -> 1530;
3606 -> 3605;
3606 -> 1532;
3606 -> 1530;
3607 -> 1528;
3607 -> 1562;
3607 -> 1631;
3607 -> 3606;
3607 -> 1640;
3607 -> 1556;
3607 -> 1557;
3607 -> 3592;
3607 -> 1564;
3607 -> 1561;
3608 -> 1576;
3609 -> 3608;
3609 -> 1397;
3610 -> 3609;
3610 -> 1399;
3610 -> 1397;
3611 -> 1595;
3612 -> 3611;
3612 -> 1435;
3613 -> 3612;
3613 -> 1437;
3613 -> 1435;
3614 -> 1433;
3614 -> 1465;
3614 -> 1591;
3614 -> 3613;
3614 -> 1600;
3614 -> 1461;
3614 -> 1462;
3614 -> 3599;
3614 -> 1472;
3614 -> 1464;
3615 -> 1615;
3616 -> 3615;
3616 -> 1484;
3617 -> 3616;
3617 -> 1486;
3617 -> 1484;
3618 -> 1482;
3618 -> 1516;
3618 -> 1611;
3618 -> 3617;
3618 -> 1620;
3618 -> 1510;
3618 -> 1511;
3618 -> 3603;
3618 -> 1518;
3618 -> 1515;
3619 -> 1635;
3620 -> 3619;
3620 -> 1530;
3621 -> 3620;
3621 -> 1532;
3621 -> 1530;
3622 -> 1528;
3622 -> 1562;
3622 -> 1631;
3622 -> 3621;
3622 -> 1640;
3622 -> 1556;
3622 -> 1557;
3622 -> 3607;
3622 -> 1564;
3622 -> 1561;
3623 -> 1576;
3624 -> 3623;
3624 -> 1397;
3625 -> 3624;
3625 -> 1399;
3625 -> 1397;
3626 -> 1595;
3627 -> 3626;
3627 -> 1435;
3628 -> 3627;
3628 -> 1437;
3628 -> 1435;
3629 -> 1433;
3629 -> 1465;
3629 -> 1591;
3629 -> 3628;
3629 -> 1600;
3629 -> 1461;
3629 -> 1462;
3629 -> 3614;
3629 -> 1472;
3629 -> 1464;
3630 -> 1615;
3631 -> 3630;
3631 -> 1484;
3632 -> 3631;
3632 -> 1486;
3632 -> 1484;
3633 -> 1482;
3633 -> 1516;
3633 -> 1611;
3633 -> 3632;
3633 -> 1620;
3633 -> 1510;
3633 -> 1511;
3633 -> 3618;
3633 -> 1518;
3633 -> 1515;
3634 -> 1635;
3635 -> 3634;
3635 -> 1530;
3636 -> 3635;
3636 -> 1532;
3636 -> 1530;
3637 -> 1528;
3637 -> 1562;
3637 -> 1631;
3637 -> 3636;
3637 -> 1640;
3637 -> 1556;
3637 -> 1557;
3637 -> 3622;
3637 -> 1564;
3637 -> 1561;
3638 -> 1576;
3639 -> 3638;
3639 -> 1397;
3640 -> 3639;
3640 -> 1399;
3640 -> 1397;
3641 -> 1595;
3642 -> 3641;
3642 -> 1435;
3643 -> 3642;
3643 -> 1437;
3643 -> 1435;
3644 -> 1433;
3644 -> 1465;
3644 -> 1591;
3644 -> 3643;
3644 -> 1600;
3644 -> 1461;
3644 -> 1462;
3644 -> 3629;
3644 -> 1472;
3644 -> 1464;
3645 -> 1615;
3646 -> 3645;
3646 -> 1484;
3647 -> 3646;
3647 -> 1486;
3647 -> 1484;
3648 -> 1482;
3648 -> 1516;
3648 -> 1611;
3648 -> 3647;
3648 -> 1620;
3648 -> 1510;
3648 -> 1511;
3648 -> 3633;
3648 -> 1518;
3648 -> 1515;
3649 -> 1635;
3650 -> 3649;
3650 -> 1530;
3651 -> 3650;
3651 -> 1532;
3651 -> 1530;
3652 -> 1528;
3652 -> 1562;
3652 -> 1631;
3652 -> 3651;
3652 -> 1640;
3652 -> 1556;
3652 -> 1557;
3652 -> 3637;
3652 -> 1564;
3652 -> 1561;
3653 -> 1576;
3654 -> 3653;
3654 -> 1397;
3655 -> 3654;
3655 -> 1399;
3655 -> 1397;
3656 -> 1595;
3657 -> 3656;
3657 -> 1435;
3658 -> 3657;
3658 -> 1437;
3658 -> 1435;
3659 -> 1433;
3659 -> 1465;
3659 -> 1591;
3659 -> 3658;
3659 -> 1600;
3659 -> 1461;
3659 -> 1462;
3659 -> 3644;
3659 -> 1472;
3659 -> 1464;
3660 -> 1615;
3661 -> 3660;
3661 -> 1484;
3662 -> 3661;
3662 -> 1486;
3662 -> 1484;
3663 -> 1482;
3663 -> 1516;
3663 -> 1611;
3663 -> 3662;
3663 -> 1620;
3663 -> 1510;
3663 -> 1511;
3663 -> 3648;
3663 -> 1518;
3663 -> 1515;
3664 -> 1635;
3665 -> 3664;
3665 -> 1530;
3666 -> 3665;
3666 -> 1532;
3666 -> 1530;
3667 -> 1528;
3667 -> 1562;
3667 -> 1631;
3667 -> 3666;
3667 -> 1640;
3667 -> 1556;
3667 -> 1557;
3667 -> 3652;
3667 -> 1564;
3667 -> 1561;
3668 -> 1576;
3669 -> 3668;
3669 -> 1397;
3670 -> 3669;
3670 -> 1399;
3670 -> 1397;
3671 -> 1595;
3672 -> 3671;
3672 -> 1435;
3673 -> 3672;
3673 -> 1437;
3673 -> 1435;
3674 -> 1433;
3674 -> 1465;
3674 -> 1591;
3674 -> 3673;
3674 -> 1600;
3674 -> 1461;
3674 -> 1462;
3674 -> 3659;
3674 -> 1472;
3674 -> 1464;
3675 -> 1615;
3676 -> 3675;
3676 -> 1484;
3677 -> 3676;
3677 -> 1486;
3677 -> 1484;
3678 -> 1482;
3678 -> 1516;
3678 -> 1611;
3678 -> 3677;
3678 -> 1620;
3678 -> 1510;
3678 -> 1511;
3678 -> 3663;
3678 -> 1518;
3678 -> 1515;
3679 -> 1635;
3680 -> 3679;
3680 -> 1530;
3681 -> 3680;
3681 -> 1532;
3681 -> 1530;
3682 -> 1528;
3682 -> 1562;
3682 -> 1631;
3682 -> 3681;
3682 -> 1640;
3682 -> 1556;
3682 -> 1557;
3682 -> 3667;
3682 -> 1564;
3682 -> 1561;
3683 -> 1576;
3684 -> 3683;
3684 -> 1397;
3685 -> 3684;
3685 -> 1399;
3685 -> 1397;
3686 -> 1595;
3687 -> 3686;
3687 -> 1435;
3688 -> 3687;
3688 -> 1437;
3688 -> 1435;
3689 -> 1433;
3689 -> 1465;
3689 -> 1591;
3689 -> 3688;
3689 -> 1600;
3689 -> 1461;
3689 -> 1462;
3689 -> 3674;
3689 -> 1472;
3689 -> 1464;
3690 -> 1615;
3691 -> 3690;
3691 -> 1484;
3692 -> 3691;
3692 -> 1486;
3692 -> 1484;
3693 -> 1482;
3693 -> 1516;
3693 -> 1611;
3693 -> 3692;
3693 -> 1620;
3693 -> 1510;
3693 -> 1511;
3693 -> 3678;
3693 -> 1518;
3693 -> 1515;
3694 -> 1635;
3695 -> 3694;
3695 -> 1530;
3696 -> 3695;
3696 -> 1532;
3696 -> 1530;
3697 -> 1528;
3697 -> 1562;
3697 -> 1631;
3697 -> 3696;
3697 -> 1640;
3697 -> 1556;
3697 -> 1557;
3697 -> 3682;
3697 -> 1564;
3697 -> 1561;
3698 -> 1576;
3699 -> 3698;
3699 -> 1397;
3700 -> 3699;
3700 -> 1399;
3700 -> 1397;
3701 -> 1595;
3702 -> 3701;
3702 -> 1435;
3703 -> 3702;
3703 -> 1437;
3703 -> 1435;
3704 -> 1433;
3704 -> 1465;
3704 -> 1591;
3704 -> 3703;
3704 -> 1600;
3704 -> 1461;
3704 -> 1462;
3704 -> 3689;
3704 -> 1472;
3704 -> 1464;
3705 -> 1615;
3706 -> 3705;
3706 -> 1484;
3707 -> 3706;
3707 -> 1486;
3707 -> 1484;
3708 -> 1482;
3708 -> 1516;
3708 -> 1611;
3708 -> 3707;
3708 -> 1620;
3708 -> 1510;
3708 -> 1511;
3708 -> 3693;
3708 -> 1518;
3708 -> 1515;
3709 -> 1635;
3710 -> 3709;
3710 -> 1530;
3711 -> 3710;
3711 -> 1532;
3711 -> 1530;
3712 -> 1528;
3712 -> 1562;
3712 -> 1631;
3712 -> 3711;
3712 -> 1640;
3712 -> 1556;
3712 -> 1557;
3712 -> 3697;
3712 -> 1564;
3712 -> 1561;
3713 -> 1576;
3714 -> 3713;
3714 -> 1397;
3715 -> 3714;
3715 -> 1399;
3715 -> 1397;
3716 -> 1595;
3717 -> 3716;
3717 -> 1435;
3718 -> 3717;
3718 -> 1437;
3718 -> 1435;
3719 -> 1433;
3719 -> 1465;
3719 -> 1591;
3719 -> 3718;
3719 -> 1600;
3719 -> 1461;
3719 -> 1462;
3719 -> 3704;
3719 -> 1472;
3719 -> 1464;
3720 -> 1615;
3721 -> 3720;
3721 -> 1484;
3722 -> 3721;
3722 -> 1486;
3722 -> 1484;
3723 -> 1482;
3723 -> 1516;
3723 -> 1611;
3723 -> 3722;
3723 -> 1620;
3723 -> 1510;
3723 -> 1511;
3723 -> 3708;
3723 -> 1518;
3723 -> 1515;
3724 -> 1635;
3725 -> 3724;
3725 -> 1530;
3726 -> 3725;
3726 -> 1532;
3726 -> 1530;
3727 -> 1528;
3727 -> 1562;
3727 -> 1631;
3727 -> 3726;
3727 -> 1640;
3727 -> 1556;
3727 -> 1557;
3727 -> 3712;
3727 -> 1564;
3727 -> 1561;
3728 -> 1576;
3729 -> 3728;
3729 -> 1397;
3730 -> 3729;
3730 -> 1399;
3730 -> 1397;
3731 -> 1595;
3732 -> 3731;
3732 -> 1435;
3733 -> 3732;
3733 -> 1437;
3733 -> 1435;
3734 -> 1433;
3734 -> 1465;
3734 -> 1591;
3734 -> 3733;
3734 -> 1600;
3734 -> 1461;
3734 -> 1462;
3734 -> 3719;
3734 -> 1472;
3734 -> 1464;
3735 -> 1615;
3736 -> 3735;
3736 -> 1484;
3737 -> 3736;
3737 -> 1486;
3737 -> 1484;
3738 -> 1482;
3738 -> 1516;
3738 -> 1611;
3738 -> 3737;
3738 -> 1620;
3738 -> 1510;
3738 -> 1511;
3738 -> 3723;
3738 -> 1518;
3738 -> 1515;
3739 -> 1635;
3740 -> 3739;
3740 -> 1530;
3741 -> 3740;
3741 -> 1532;
3741 -> 1530;
3742 -> 1528;
3742 -> 1562;
3742 -> 1631;
3742 -> 3741;
3742 -> 1640;
3742 -> 1556;
3742 -> 1557;
3742 -> 3727;
3742 -> 1564;
3742 -> 1561;
3743 -> 1576;
3744 -> 3743;
3744 -> 1397;
3745 -> 3744;
3745 -> 1399;
3745 -> 1397;
3746 -> 1595;
3747 -> 3746;
3747 -> 1435;
3748 -> 3747;
3748 -> 1437;
3748 -> 1435;
3749 -> 1433;
3749 -> 1465;
3749 -> 1591;
3749 -> 3748;
3749 -> 1600;
3749 -> 1461;
3749 -> 1462;
3749 -> 3734;
3749 -> 1472;
3749 -> 1464;
3750 -> 1615;
3751 -> 3750;
3751 -> 1484;
3752 -> 3751;
3752 -> 1486;
3752 -> 1484;
3753 -> 1482;
3753 -> 1516;
3753 -> 1611;
3753 -> 3752;
3753 -> 1620;
3753 -> 1510;
3753 -> 1511;
3753 -> 3738;
3753 -> 1518;
3753 -> 1515;
3754 -> 1635;
3755 -> 3754;
3755 -> 1530;
3756 -> 3755;
3756 -> 1532;
3756 -> 1530;
3757 -> 1528;
3757 -> 1562;
3757 -> 1631;
3757 -> 3756;
3757 -> 1640;
3757 -> 1556;
3757 -> 1557;
3757 -> 3742;
3757 -> 1564;
3757 -> 1561;
3758 -> 1576;
3759 -> 3758;
3759 -> 1397;
3760 -> 3759;
3760 -> 1399;
3760 -> 1397;
3761 -> 1595;
3762 -> 3761;
3762 -> 1435;
3763 -> 3762;
3763 -> 1437;
3763 -> 1435;
3764 -> 1433;
3764 -> 1465;
3764 -> 1591;
3764 -> 3763;
3764 -> 1600;
3764 -> 1461;
3764 -> 1462;
3764 -> 3749;
3764 -> 1472;
3764 -> 1464;
3765 -> 1615;
3766 -> 3765;
3766 -> 1484;
3767 -> 3766;
3767 -> 1486;
3767 -> 1484;
3768 -> 1482;
3768 -> 1516;
3768 -> 1611;
3768 -> 3767;
3768 -> 1620;
3768 -> 1510;
3768 -> 1511;
3768 -> 3753;
3768 -> 1518;
3768 -> 1515;
3769 -> 1635;
3770 -> 3769;
3770 -> 1530;
3771 -> 3770;
3771 -> 1532;
3771 -> 1530;
3772 -> 1528;
3772 -> 1562;
3772 -> 1631;
3772 -> 3771;
3772 -> 1640;
3772 -> 1556;
3772 -> 1557;
3772 -> 3757;
3772 -> 1564;
3772 -> 1561;
3773 -> 1576;
3774 -> 3773;
3774 -> 1397;
3775 -> 3774;
3775 -> 1399;
3775 -> 1397;
3776 -> 1595;
3777 -> 3776;
3777 -> 1435;
3778 -> 3777;
3778 -> 1437;
3778 -> 1435;
3779 -> 1433;
3779 -> 1465;
3779 -> 1591;
3779 -> 3778;
3779 -> 1600;
3779 -> 1461;
3779 -> 1462;
3779 -> 3764;
3779 -> 1472;
3779 -> 1464;
3780 -> 1615;
3781 -> 3780;
3781 -> 1484;
3782 -> 3781;
3782 -> 1486;
3782 -> 1484;
3783 -> 1482;
3783 -> 1516;
3783 -> 1611;
3783 -> 3782;
3783 -> 1620;
3783 -> 1510;
3783 -> 1511;
3783 -> 3768;
3783 -> 1518;
3783 -> 1515;
3784 -> 1635;
3785 -> 3784;
3785 -> 1530;
3786 -> 3785;
3786 -> 1532;
3786 -> 1530;
3787 -> 1528;
3787 -> 1562;
3787 -> 1631;
3787 -> 3786;
3787 -> 1640;
3787 -> 1556;
3787 -> 1557;
3787 -> 3772;
3787 -> 1564;
3787 -> 1561;
3788 -> 1576;
3789 -> 3788;
3789 -> 1397;
3790 -> 3789;
3790 -> 1399;
3790 -> 1397;
3791 -> 1595;
3792 -> 3791;
3792 -> 1435;
3793 -> 3792;
3793 -> 1437;
3793 -> 1435;
3794 -> 1433;
3794 -> 1465;
3794 -> 1591;
3794 -> 3793;
3794 -> 1600;
3794 -> 1461;
3794 -> 1462;
3794 -> 3779;
3794 -> 1472;
3794 -> 1464;
3795 -> 1615;
3796 -> 3795;
3796 -> 1484;
3797 -> 3796;
3797 -> 1486;
3797 -> 1484;
3798 -> 1482;
3798 -> 1516;
3798 -> 1611;
3798 -> 3797;
3798 -> 1620;
3798 -> 1510;
3798 -> 1511;
3798 -> 3783;
3798 -> 1518;
3798 -> 1515;
3799 -> 1635;
3800 -> 3799;
3800 -> 1530;
3801 -> 3800;
3801 -> 1532;
3801 -> 1530;
3802 -> 1528;
3802 -> 1562;
3802 -> 1631;
3802 -> 3801;
3802 -> 1640;
3802 -> 1556;
3802 -> 1557;
3802 -> 3787;
3802 -> 1564;
3802 -> 1561;
3803 -> 1576;
3804 -> 3803;
3804 -> 1397;
3805 -> 3804;
3805 -> 1399;
3805 -> 1397;
3806 -> 1595;
3807 -> 3806;
3807 -> 1435;
3808 -> 3807;
3808 -> 1437;
3808 -> 1435;
3809 -> 1433;
3809 -> 1465;
3809 -> 1591;
3809 -> 3808;
3809 -> 1600;
3809 -> 1461;
3809 -> 1462;
3809 -> 3794;
3809 -> 1472;
3809 -> 1464;
3810 -> 1615;
3811 -> 3810;
3811 -> 1484;
3812 -> 3811;
3812 -> 1486;
3812 -> 1484;
3813 -> 1482;
3813 -> 1516;
3813 -> 1611;
3813 -> 3812;
3813 -> 1620;
3813 -> 1510;
3813 -> 1511;
3813 -> 3798;
3813 -> 1518;
3813 -> 1515;
3814 -> 1635;
3815 -> 3814;
3815 -> 1530;
3816 -> 3815;
3816 -> 1532;
3816 -> 1530;
3817 -> 1528;
3817 -> 1562;
3817 -> 1631;
3817 -> 3816;
3817 -> 1640;
3817 -> 1556;
3817 -> 1557;
3817 -> 3802;
3817 -> 1564;
3817 -> 1561;
3818 -> 1576;
3819 -> 3818;
3819 -> 1397;
3820 -> 3819;
3820 -> 1399;
3820 -> 1397;
3821 -> 1595;
3822 -> 3821;
3822 -> 1435;
3823 -> 3822;
3823 -> 1437;
3823 -> 1435;
3824 -> 1433;
3824 -> 1465;
3824 -> 1591;
3824 -> 3823;
3824 -> 1600;
3824 -> 1461;
3824 -> 1462;
3824 -> 3809;
3824 -> 1472;
3824 -> 1464;
3825 -> 1615;
3826 -> 3825;
3826 -> 1484;
3827 -> 3826;
3827 -> 1486;
3827 -> 1484;
3828 -> 1482;
3828 -> 1516;
3828 -> 1611;
3828 -> 3827;
3828 -> 1620;
3828 -> 1510;
3828 -> 1511;
3828 -> 3813;
3828 -> 1518;
3828 -> 1515;
3829 -> 1635;
3830 -> 3829;
3830 -> 1530;
3831 -> 3830;
3831 -> 1532;
3831 -> 1530;
3832 -> 1528;
3832 -> 1562;
3832 -> 1631;
3832 -> 3831;
3832 -> 1640;
3832 -> 1556;
3832 -> 1557;
3832 -> 3817;
3832 -> 1564;
3832 -> 1561;
3833 -> 1576;
3834 -> 3833;
3834 -> 1397;
3835 -> 3834;
3835 -> 1399;
3835 -> 1397;
3836 -> 1595;
3837 -> 3836;
3837 -> 1435;
3838 -> 3837;
3838 -> 1437;
3838 -> 1435;
3839 -> 1433;
3839 -> 1465;
3839 -> 1591;
3839 -> 3838;
3839 -> 1600;
3839 -> 1461;
3839 -> 1462;
3839 -> 3824;
3839 -> 1472;
3839 -> 1464;
3840 -> 1615;
3841 -> 3840;
3841 -> 1484;
3842 -> 3841;
3842 -> 1486;
3842 -> 1484;
3843 -> 1482;
3843 -> 1516;
3843 -> 1611;
3843 -> 3842;
3843 -> 1620;
3843 -> 1510;
3843 -> 1511;
3843 -> 3828;
3843 -> 1518;
3843 -> 1515;
3844 -> 1635;
3845 -> 3844;
3845 -> 1530;
3846 -> 3845;
3846 -> 1532;
3846 -> 1530;
3847 -> 1528;
3847 -> 1562;
3847 -> 1631;
3847 -> 3846;
3847 -> 1640;
3847 -> 1556;
3847 -> 1557;
3847 -> 3832;
3847 -> 1564;
3847 -> 1561;
3848 -> 1576;
3849 -> 3848;
3849 -> 1397;
3850 -> 3849;
3850 -> 1399;
3850 -> 1397;
3851 -> 1595;
3852 -> 3851;
3852 -> 1435;
3853 -> 3852;
3853 -> 1437;
3853 -> 1435;
3854 -> 1433;
3854 -> 1465;
3854 -> 1591;
3854 -> 3853;
3854 -> 1600;
3854 -> 1461;
3854 -> 1462;
3854 -> 3839;
3854 -> 1472;
3854 -> 1464;
3855 -> 1615;
3856 -> 3855;
3856 -> 1484;
3857 -> 3856;
3857 -> 1486;
3857 -> 1484;
3858 -> 1482;
3858 -> 1516;
3858 -> 1611;
3858 -> 3857;
3858 -> 1620;
3858 -> 1510;
3858 -> 1511;
3858 -> 3843;
3858 -> 1518;
3858 -> 1515;
3859 -> 1635;
3860 -> 3859;
3860 -> 1530;
3861 -> 3860;
3861 -> 1532;
3861 -> 1530;
3862 -> 1528;
3862 -> 1562;
3862 -> 1631;
3862 -> 3861;
3862 -> 1640;
3862 -> 1556;
3862 -> 1557;
3862 -> 3847;
3862 -> 1564;
3862 -> 1561;
3863 -> 1576;
3864 -> 3863;
3864 -> 1397;
3865 -> 3864;
3865 -> 1399;
3865 -> 1397;
3866 -> 1595;
3867 -> 3866;
3867 -> 1435;
3868 -> 3867;
3868 -> 1437;
3868 -> 1435;
3869 -> 1433;
3869 -> 1465;
3869 -> 1591;
3869 -> 3868;
3869 -> 1600;
3869 -> 1461;
3869 -> 1462;
3869 -> 3854;
3869 -> 1472;
3869 -> 1464;
3870 -> 1615;
3871 -> 3870;
3871 -> 1484;
3872 -> 3871;
3872 -> 1486;
3872 -> 1484;
3873 -> 1482;
3873 -> 1516;
3873 -> 1611;
3873 -> 3872;
3873 -> 1620;
3873 -> 1510;
3873 -> 1511;
3873 -> 3858;
3873 -> 1518;
3873 -> 1515;
3874 -> 1635;
3875 -> 3874;
3875 -> 1530;
3876 -> 3875;
3876 -> 1532;
3876 -> 1530;
3877 -> 1528;
3877 -> 1562;
3877 -> 1631;
3877 -> 3876;
3877 -> 1640;
3877 -> 1556;
3877 -> 1557;
3877 -> 3862;
3877 -> 1564;
3877 -> 1561;
3878 -> 1576;
3879 -> 3878;
3879 -> 1397;
3880 -> 3879;
3880 -> 1399;
3880 -> 1397;
3881 -> 1595;
3882 -> 3881;
3882 -> 1435;
3883 -> 3882;
3883 -> 1437;
3883 -> 1435;
3884 -> 1433;
3884 -> 1465;
3884 -> 1591;
3884 -> 3883;
3884 -> 1600;
3884 -> 1461;
3884 -> 1462;
3884 -> 3869;
3884 -> 1472;
3884 -> 1464;
3885 -> 1615;
3886 -> 3885;
3886 -> 1484;
3887 -> 3886;
3887 -> 1486;
3887 -> 1484;
3888 -> 1482;
3888 -> 1516;
3888 -> 1611;
3888 -> 3887;
3888 -> 1620;
3888 -> 1510;
3888 -> 1511;
3888 -> 3873;
3888 -> 1518;
3888 -> 1515;
3889 -> 1635;
3890 -> 3889;
3890 -> 1530;
3891 -> 3890;
3891 -> 1532;
3891 -> 1530;
3892 -> 1528;
3892 -> 1562;
3892 -> 1631;
3892 -> 3891;
3892 -> 1640;
3892 -> 1556;
3892 -> 1557;
3892 -> 3877;
3892 -> 1564;
3892 -> 1561;
3893 -> 1576;
3894 -> 3893;
3894 -> 1397;
3895 -> 3894;
3895 -> 1399;
3895 -> 1397;
3896 -> 1595;
3897 -> 3896;
3897 -> 1435;
3898 -> 3897;
3898 -> 1437;
3898 -> 1435;
3899 -> 1433;
3899 -> 1465;
3899 -> 1591;
3899 -> 3898;
3899 -> 1600;
3899 -> 1461;
3899 -> 1462;
3899 -> 3884;
3899 -> 1472;
3899 -> 1464;
3900 -> 1615;
3901 -> 3900;
3901 -> 1484;
3902 -> 3901;
3902 -> 1486;
3902 -> 1484;
3903 -> 1482;
3903 -> 1516;
3903 -> 1611;
3903 -> 3902;
3903 -> 1620;
3903 -> 1510;
3903 -> 1511;
3903 -> 3888;
3903 -> 1518;
3903 -> 1515;
3904 -> 1635;
3905 -> 3904;
3905 -> 1530;
3906 -> 3905;
3906 -> 1532;
3906 -> 1530;
3907 -> 1528;
3907 -> 1562;
3907 -> 1631;
3907 -> 3906;
3907 -> 1640;
3907 -> 1556;
3907 -> 1557;
3907 -> 3892;
3907 -> 1564;
3907 -> 1561;
3908 -> 1576;
3909 -> 3908;
3909 -> 1397;
3910 -> 3909;
3910 -> 1399;
3910 -> 1397;
3911 -> 1595;
3912 -> 3911;
3912 -> 1435;
3913 -> 3912;
3913 -> 1437;
3913 -> 1435;
3914 -> 1433;
3914 -> 1465;
3914 -> 1591;
3914 -> 3913;
3914 -> 1600;
3914 -> 1461;
3914 -> 1462;
3914 -> 3899;
3914 -> 1472;
3914 -> 1464;
3915 -> 1615;
3916 -> 3915;
3916 -> 1484;
3917 -> 3916;
3917 -> 1486;
3917 -> 1484;
3918 -> 1482;
3918 -> 1516;
3918 -> 1611;
3918 -> 3917;
3918 -> 1620;
3918 -> 1510;
3918 -> 1511;
3918 -> 3903;
3918 -> 1518;
3918 -> 1515;
3919 -> 1635;
3920 -> 3919;
3920 -> 1530;
3921 -> 3920;
3921 -> 1532;
3921 -> 1530;
3922 -> 1528;
3922 -> 1562;
3922 -> 1631;
3922 -> 3921;
3922 -> 1640;
3922 -> 1556;
3922 -> 1557;
3922 -> 3907;
3922 -> 1564;
3922 -> 1561;
3923 -> 1576;
3924 -> 3923;
3924 -> 1397;
3925 -> 3924;
3925 -> 1399;
3925 -> 1397;
3926 -> 1595;
3927 -> 3926;
3927 -> 1435;
3928 -> 3927;
3928 -> 1437;
3928 -> 1435;
3929 -> 1433;
3929 -> 1465;
3929 -> 1591;
3929 -> 3928;
3929 -> 1600;
3929 -> 1461;
3929 -> 1462;
3929 -> 3914;
3929 -> 1472;
3929 -> 1464;
3930 -> 1615;
3931 -> 3930;
3931 -> 1484;
3932 -> 3931;
3932 -> 1486;
3932 -> 1484;
3933 -> 1482;
3933 -> 1516;
3933 -> 1611;
3933 -> 3932;
3933 -> 1620;
3933 -> 1510;
3933 -> 1511;
3933 -> 3918;
3933 -> 1518;
3933 -> 1515;
3934 -> 1635;
3935 -> 3934;
3935 -> 1530;
3936 -> 3935;
3936 -> 1532;
3936 -> 1530;
3937 -> 1528;
3937 -> 1562;
3937 -> 1631;
3937 -> 3936;
3937 -> 1640;
3937 -> 1556;
3937 -> 1557;
3937 -> 3922;
3937 -> 1564;
3937 -> 1561;
3938 -> 1576;
3939 -> 3938;
3939 -> 1397;
3940 -> 3939;
3940 -> 1399;
3940 -> 1397;
3941 -> 1595;
3942 -> 3941;
3942 -> 1435;
3943 -> 3942;
3943 -> 1437;
3943 -> 1435;
3944 -> 1433;
3944 -> 1465;
3944 -> 1591;
3944 -> 3943;
3944 -> 1600;
3944 -> 1461;
3944 -> 1462;
3944 -> 3929;
3944 -> 1472;
3944 -> 1464;
3945 -> 1615;
3946 -> 3945;
3946 -> 1484;
3947 -> 3946;
3947 -> 1486;
3947 -> 1484;
3948 -> 1482;
3948 -> 1516;
3948 -> 1611;
3948 -> 3947;
3948 -> 1620;
3948 -> 1510;
3948 -> 1511;
3948 -> 3933;
3948 -> 1518;
3948 -> 1515;
3949 -> 1635;
3950 -> 3949;
3950 -> 1530;
3951 -> 3950;
3951 -> 1532;
3951 -> 1530;
3952 -> 1528;
3952 -> 1562;
3952 -> 1631;
3952 -> 3951;
3952 -> 1640;
3952 -> 1556;
3952 -> 1557;
3952 -> 3937;
3952 -> 1564;
3952 -> 1561;
3953 -> 1576;
3954 -> 3953;
3954 -> 1397;
3955 -> 3954;
3955 -> 1399;
3955 -> 1397;
3956 -> 1595;
3957 -> 3956;
3957 -> 1435;
3958 -> 3957;
3958 -> 1437;
3958 -> 1435;
3959 -> 1433;
3959 -> 1465;
3959 -> 1591;
3959 -> 3958;
3959 -> 1600;
3959 -> 1461;
3959 -> 1462;
3959 -> 3944;
3959 -> 1472;
3959 -> 1464;
3960 -> 1615;
3961 -> 3960;
3961 -> 1484;
3962 -> 3961;
3962 -> 1486;
3962 -> 1484;
3963 -> 1482;
3963 -> 1516;
3963 -> 1611;
3963 -> 3962;
3963 -> 1620;
3963 -> 1510;
3963 -> 1511;
3963 -> 3948;
3963 -> 1518;
3963 -> 1515;
3964 -> 1635;
3965 -> 3964;
3965 -> 1530;
3966 -> 3965;
3966 -> 1532;
3966 -> 1530;
3967 -> 1528;
3967 -> 1562;
3967 -> 1631;
3967 -> 3966;
3967 -> 1640;
3967 -> 1556;
3967 -> 1557;
3967 -> 3952;
3967 -> 1564;
3967 -> 1561;
3968 -> 1576;
3969 -> 3968;
3969 -> 1397;
3970 -> 3969;
3970 -> 1399;
3970 -> 1397;
3971 -> 1595;
3972 -> 3971;
3972 -> 1435;
3973 -> 3972;
3973 -> 1437;
3973 -> 1435;
3974 -> 1433;
3974 -> 1465;
3974 -> 1591;
3974 -> 3973;
3974 -> 1600;
3974 -> 1461;
3974 -> 1462;
3974 -> 3959;
3974 -> 1472;
3974 -> 1464;
3975 -> 1615;
3976 -> 3975;
3976 -> 1484;
3977 -> 3976;
3977 -> 1486;
3977 -> 1484;
3978 -> 1482;
3978 -> 1516;
3978 -> 1611;
3978 -> 3977;
3978 -> 1620;
3978 -> 1510;
3978 -> 1511;
3978 -> 3963;
3978 -> 1518;
3978 -> 1515;
3979 -> 1635;
3980 -> 3979;
3980 -> 1530;
3981 -> 3980;
3981 -> 1532;
3981 -> 1530;
3982 -> 1528;
3982 -> 1562;
3982 -> 1631;
3982 -> 3981;
3982 -> 1640;
3982 -> 1556;
3982 -> 1557;
3982 -> 3967;
3982 -> 1564;
3982 -> 1561;
3983 -> 1576;
3984 -> 3983;
3984 -> 1397;
3985 -> 3984;
3985 -> 1399;
3985 -> 1397;
3986 -> 1595;
3987 -> 3986;
3987 -> 1435;
3988 -> 3987;
3988 -> 1437;
3988 -> 1435;
3989 -> 1433;
3989 -> 1465;
3989 -> 1591;
3989 -> 3988;
3989 -> 1600;
3989 -> 1461;
3989 -> 1462;
3989 -> 3974;
3989 -> 1472;
3989 -> 1464;
3990 -> 1615;
3991 -> 3990;
3991 -> 1484;
3992 -> 3991;
3992 -> 1486;
3992 -> 1484;
3993 -> 1482;
3993 -> 1516;
3993 -> 1611;
3993 -> 3992;
3993 -> 1620;
3993 -> 1510;
3993 -> 1511;
3993 -> 3978;
3993 -> 1518;
3993 -> 1515;
3994 -> 1635;
3995 -> 3994;
3995 -> 1530;
3996 -> 3995;
3996 -> 1532;
3996 -> 1530;
3997 -> 1528;
3997 -> 1562;
3997 -> 1631;
3997 -> 3996;
3997 -> 1640;
3997 -> 1556;
3997 -> 1557;
3997 -> 3982;
3997 -> 1564;
3997 -> 1561;
3998 -> 1576;
3999 -> 3998;
3999 -> 1397;
4000 -> 3999;
4000 -> 1399;
4000 -> 1397;
4001 -> 1595;
4002 -> 4001;
4002 -> 1435;
4003 -> 4002;
4003 -> 1437;
4003 -> 1435;
4004 -> 1433;
4004 -> 1465;
4004 -> 1591;
4004 -> 4003;
4004 -> 1600;
4004 -> 1461;
4004 -> 1462;
4004 -> 3989;
4004 -> 1472;
4004 -> 1464;
4005 -> 1615;
4006 -> 4005;
4006 -> 1484;
4007 -> 4006;
4007 -> 1486;
4007 -> 1484;
4008 -> 1482;
4008 -> 1516;
4008 -> 1611;
4008 -> 4007;
4008 -> 1620;
4008 -> 1510;
4008 -> 1511;
4008 -> 3993;
4008 -> 1518;
4008 -> 1515;
4009 -> 1635;
4010 -> 4009;
4010 -> 1530;
4011 -> 4010;
4011 -> 1532;
4011 -> 1530;
4012 -> 1528;
4012 -> 1562;
4012 -> 1631;
4012 -> 4011;
4012 -> 1640;
4012 -> 1556;
4012 -> 1557;
4012 -> 3997;
4012 -> 1564;
4012 -> 1561;
4013 -> 1576;
4014 -> 4013;
4014 -> 1397;
4015 -> 4014;
4015 -> 1399;
4015 -> 1397;
4016 -> 1595;
4017 -> 4016;
4017 -> 1435;
4018 -> 4017;
4018 -> 1437;
4018 -> 1435;
4019 -> 1433;
4019 -> 1465;
4019 -> 1591;
4019 -> 4018;
4019 -> 1600;
4019 -> 1461;
4019 -> 1462;
4019 -> 4004;
4019 -> 1472;
4019 -> 1464;
4020 -> 1615;
4021 -> 4020;
4021 -> 1484;
4022 -> 4021;
4022 -> 1486;
4022 -> 1484;
4023 -> 1482;
4023 -> 1516;
4023 -> 1611;
4023 -> 4022;
4023 -> 1620;
4023 -> 1510;
4023 -> 1511;
4023 -> 4008;
4023 -> 1518;
4023 -> 1515;
4024 -> 1635;
4025 -> 4024;
4025 -> 1530;
4026 -> 4025;
4026 -> 1532;
4026 -> 1530;
4027 -> 1528;
4027 -> 1562;
4027 -> 1631;
4027 -> 4026;
4027 -> 1640;
4027 -> 1556;
4027 -> 1557;
4027 -> 4012;
4027 -> 1564;
4027 -> 1561;
4028 -> 1576;
4029 -> 4028;
4029 -> 1397;
4030 -> 4029;
4030 -> 1399;
4030 -> 1397;
4031 -> 1595;
4032 -> 4031;
4032 -> 1435;
4033 -> 4032;
4033 -> 1437;
4033 -> 1435;
4034 -> 1433;
4034 -> 1465;
4034 -> 1591;
4034 -> 4033;
4034 -> 1600;
4034 -> 1461;
4034 -> 1462;
4034 -> 4019;
4034 -> 1472;
4034 -> 1464;
4035 -> 1615;
4036 -> 4035;
4036 -> 1484;
4037 -> 4036;
4037 -> 1486;
4037 -> 1484;
4038 -> 1482;
4038 -> 1516;
4038 -> 1611;
4038 -> 4037;
4038 -> 1620;
4038 -> 1510;
4038 -> 1511;
4038 -> 4023;
4038 -> 1518;
4038 -> 1515;
4039 -> 1635;
4040 -> 4039;
4040 -> 1530;
4041 -> 4040;
4041 -> 1532;
4041 -> 1530;
4042 -> 1528;
4042 -> 1562;
4042 -> 1631;
4042 -> 4041;
4042 -> 1640;
4042 -> 1556;
4042 -> 1557;
4042 -> 4027;
4042 -> 1564;
4042 -> 1561;
4043 -> 1576;
4044 -> 4043;
4044 -> 1397;
4045 -> 4044;
4045 -> 1399;
4045 -> 1397;
4046 -> 1595;
4047 -> 4046;
4047 -> 1435;
4048 -> 4047;
4048 -> 1437;
4048 -> 1435;
4049 -> 1433;
4049 -> 1465;
4049 -> 1591;
4049 -> 4048;
4049 -> 1600;
4049 -> 1461;
4049 -> 1462;
4049 -> 4034;
4049 -> 1472;
4049 -> 1464;
4050 -> 1615;
4051 -> 4050;
4051 -> 1484;
4052 -> 4051;
4052 -> 1486;
4052 -> 1484;
4053 -> 1482;
4053 -> 1516;
4053 -> 1611;
4053 -> 4052;
4053 -> 1620;
4053 -> 1510;
4053 -> 1511;
4053 -> 4038;
4053 -> 1518;
4053 -> 1515;
4054 -> 1635;
4055 -> 4054;
4055 -> 1530;
4056 -> 4055;
4056 -> 1532;
4056 -> 1530;
4057 -> 1528;
4057 -> 1562;
4057 -> 1631;
4057 -> 4056;
4057 -> 1640;
4057 -> 1556;
4057 -> 1557;
4057 -> 4042;
4057 -> 1564;
4057 -> 1561;
4058 -> 1576;
4059 -> 4058;
4059 -> 1397;
4060 -> 4059;
4060 -> 1399;
4060 -> 1397;
4061 -> 1595;
4062 -> 4061;
4062 -> 1435;
4063 -> 4062;
4063 -> 1437;
4063 -> 1435;
4064 -> 1433;
4064 -> 1465;
4064 -> 1591;
4064 -> 4063;
4064 -> 1600;
4064 -> 1461;
4064 -> 1462;
4064 -> 4049;
4064 -> 1472;
4064 -> 1464;
4065 -> 1615;
4066 -> 4065;
4066 -> 1484;
4067 -> 4066;
4067 -> 1486;
4067 -> 1484;
4068 -> 1482;
4068 -> 1516;
4068 -> 1611;
4068 -> 4067;
4068 -> 1620;
4068 -> 1510;
4068 -> 1511;
4068 -> 4053;
4068 -> 1518;
4068 -> 1515;
4069 -> 1635;
4070 -> 4069;
4070 -> 1530;
4071 -> 4070;
4071 -> 1532;
4071 -> 1530;
4072 -> 1528;
4072 -> 1562;
4072 -> 1631;
4072 -> 4071;
4072 -> 1640;
4072 -> 1556;
4072 -> 1557;
4072 -> 4057;
4072 -> 1564;
4072 -> 1561;
4073 -> 1576;
4074 -> 4073;
4074 -> 1397;
4075 -> 4074;
4075 -> 1399;
4075 -> 1397;
4076 -> 1595;
4077 -> 4076;
4077 -> 1435;
4078 -> 4077;
4078 -> 1437;
4078 -> 1435;
4079 -> 1433;
4079 -> 1465;
4079 -> 1591;
4079 -> 4078;
4079 -> 1600;
4079 -> 1461;
4079 -> 1462;
4079 -> 4064;
4079 -> 1472;
4079 -> 1464;
4080 -> 1615;
4081 -> 4080;
4081 -> 1484;
4082 -> 4081;
4082 -> 1486;
4082 -> 1484;
4083 -> 1482;
4083 -> 1516;
4083 -> 1611;
4083 -> 4082;
4083 -> 1620;
4083 -> 1510;
4083 -> 1511;
4083 -> 4068;
4083 -> 1518;
4083 -> 1515;
4084 -> 1635;
4085 -> 4084;
4085 -> 1530;
4086 -> 4085;
4086 -> 1532;
4086 -> 1530;
4087 -> 1528;
4087 -> 1562;
4087 -> 1631;
4087 -> 4086;
4087 -> 1640;
4087 -> 1556;
4087 -> 1557;
4087 -> 4072;
4087 -> 1564;
4087 -> 1561;
4088 -> 1576;
4089 -> 4088;
4089 -> 1397;
4090 -> 4089;
4090 -> 1399;
4090 -> 1397;
4091 -> 1595;
4092 -> 4091;
4092 -> 1435;
4093 -> 4092;
4093 -> 1437;
4093 -> 1435;
4094 -> 1433;
4094 -> 1465;
4094 -> 1591;
4094 -> 4093;
4094 -> 1600;
4094 -> 1461;
4094 -> 1462;
4094 -> 4079;
4094 -> 1472;
4094 -> 1464;
4095 -> 1615;
4096 -> 4095;
4096 -> 1484;
4097 -> 4096;
4097 -> 1486;
4097 -> 1484;
4098 -> 1482;
4098 -> 1516;
4098 -> 1611;
4098 -> 4097;
4098 -> 1620;
4098 -> 1510;
4098 -> 1511;
4098 -> 4083;
4098 -> 1518;
4098 -> 1515;
4099 -> 1635;
4100 -> 4099;
4100 -> 1530;
4101 -> 4100;
4101 -> 1532;
4101 -> 1530;
4102 -> 1528;
4102 -> 1562;
4102 -> 1631;
4102 -> 4101;
4102 -> 1640;
4102 -> 1556;
4102 -> 1557;
4102 -> 4087;
4102 -> 1564;
4102 -> 1561;
4103 -> 1576;
4104 -> 4103;
4104 -> 1397;
4105 -> 4104;
4105 -> 1399;
4105 -> 1397;
4106 -> 1595;
4107 -> 4106;
4107 -> 1435;
4108 -> 4107;
4108 -> 1437;
4108 -> 1435;
4109 -> 1433;
4109 -> 1465;
4109 -> 1591;
4109 -> 4108;
4109 -> 1600;
4109 -> 1461;
4109 -> 1462;
4109 -> 4094;
4109 -> 1472;
4109 -> 1464;
4110 -> 1615;
4111 -> 4110;
4111 -> 1484;
4112 -> 4111;
4112 -> 1486;
4112 -> 1484;
4113 -> 1482;
4113 -> 1516;
4113 -> 1611;
4113 -> 4112;
4113 -> 1620;
4113 -> 1510;
4113 -> 1511;
4113 -> 4098;
4113 -> 1518;
4113 -> 1515;
4114 -> 1635;
4115 -> 4114;
4115 -> 1530;
4116 -> 4115;
4116 -> 1532;
4116 -> 1530;
4117 -> 1528;
4117 -> 1562;
4117 -> 1631;
4117 -> 4116;
4117 -> 1640;
4117 -> 1556;
4117 -> 1557;
4117 -> 4102;
4117 -> 1564;
4117 -> 1561;
4118 -> 1576;
4119 -> 4118;
4119 -> 1397;
4120 -> 4119;
4120 -> 1399;
4120 -> 1397;
4121 -> 1595;
4122 -> 4121;
4122 -> 1435;
4123 -> 4122;
4123 -> 1437;
4123 -> 1435;
4124 -> 1433;
4124 -> 1465;
4124 -> 1591;
4124 -> 4123;
4124 -> 1600;
4124 -> 1461;
4124 -> 1462;
4124 -> 4109;
4124 -> 1472;
4124 -> 1464;
4125 -> 1615;
4126 -> 4125;
4126 -> 1484;
4127 -> 4126;
4127 -> 1486;
4127 -> 1484;
4128 -> 1482;
4128 -> 1516;
4128 -> 1611;
4128 -> 4127;
4128 -> 1620;
4128 -> 1510;
4128 -> 1511;
4128 -> 4113;
4128 -> 1518;
4128 -> 1515;
4129 -> 1635;
4130 -> 4129;
4130 -> 1530;
4131 -> 4130;
4131 -> 1532;
4131 -> 1530;
4132 -> 1528;
4132 -> 1562;
4132 -> 1631;
4132 -> 4131;
4132 -> 1640;
4132 -> 1556;
4132 -> 1557;
4132 -> 4117;
4132 -> 1564;
4132 -> 1561;
4133 -> 1576;
4134 -> 4133;
4134 -> 1397;
4135 -> 4134;
4135 -> 1399;
4135 -> 1397;
4136 -> 1595;
4137 -> 4136;
4137 -> 1435;
4138 -> 4137;
4138 -> 1437;
4138 -> 1435;
4139 -> 1433;
4139 -> 1465;
4139 -> 1591;
4139 -> 4138;
4139 -> 1600;
4139 -> 1461;
4139 -> 1462;
4139 -> 4124;
4139 -> 1472;
4139 -> 1464;
4140 -> 1615;
4141 -> 4140;
4141 -> 1484;
4142 -> 4141;
4142 -> 1486;
4142 -> 1484;
4143 -> 1482;
4143 -> 1516;
4143 -> 1611;
4143 -> 4142;
4143 -> 1620;
4143 -> 1510;
4143 -> 1511;
4143 -> 4128;
4143 -> 1518;
4143 -> 1515;
4144 -> 1635;
4145 -> 4144;
4145 -> 1530;
4146 -> 4145;
4146 -> 1532;
4146 -> 1530;
4147 -> 1528;
4147 -> 1562;
4147 -> 1631;
4147 -> 4146;
4147 -> 1640;
4147 -> 1556;
4147 -> 1557;
4147 -> 4132;
4147 -> 1564;
4147 -> 1561;
4148 -> 1576;
4149 -> 4148;
4149 -> 1397;
4150 -> 4149;
4150 -> 1399;
4150 -> 1397;
4151 -> 1595;
4152 -> 4151;
4152 -> 1435;
4153 -> 4152;
4153 -> 1437;
4153 -> 1435;
4154 -> 1433;
4154 -> 1465;
4154 -> 1591;
4154 -> 4153;
4154 -> 1600;
4154 -> 1461;
4154 -> 1462;
4154 -> 4139;
4154 -> 1472;
4154 -> 1464;
4155 -> 1615;
4156 -> 4155;
4156 -> 1484;
4157 -> 4156;
4157 -> 1486;
4157 -> 1484;
4158 -> 1482;
4158 -> 1516;
4158 -> 1611;
4158 -> 4157;
4158 -> 1620;
4158 -> 1510;
4158 -> 1511;
4158 -> 4143;
4158 -> 1518;
4158 -> 1515;
4159 -> 1635;
4160 -> 4159;
4160 -> 1530;
4161 -> 4160;
4161 -> 1532;
4161 -> 1530;
4162 -> 1528;
4162 -> 1562;
4162 -> 1631;
4162 -> 4161;
4162 -> 1640;
4162 -> 1556;
4162 -> 1557;
4162 -> 4147;
4162 -> 1564;
4162 -> 1561;
4163 -> 1576;
4164 -> 4163;
4164 -> 1397;
4165 -> 4164;
4165 -> 1399;
4165 -> 1397;
4166 -> 1595;
4167 -> 4166;
4167 -> 1435;
4168 -> 4167;
4168 -> 1437;
4168 -> 1435;
4169 -> 1433;
4169 -> 1465;
4169 -> 1591;
4169 -> 4168;
4169 -> 1600;
4169 -> 1461;
4169 -> 1462;
4169 -> 4154;
4169 -> 1472;
4169 -> 1464;
4170 -> 1615;
4171 -> 4170;
4171 -> 1484;
4172 -> 4171;
4172 -> 1486;
4172 -> 1484;
4173 -> 1482;
4173 -> 1516;
4173 -> 1611;
4173 -> 4172;
4173 -> 1620;
4173 -> 1510;
4173 -> 1511;
4173 -> 4158;
4173 -> 1518;
4173 -> 1515;
4174 -> 1635;
4175 -> 4174;
4175 -> 1530;
4176 -> 4175;
4176 -> 1532;
4176 -> 1530;
4177 -> 1528;
4177 -> 1562;
4177 -> 1631;
4177 -> 4176;
4177 -> 1640;
4177 -> 1556;
4177 -> 1557;
4177 -> 4162;
4177 -> 1564;
4177 -> 1561;
4178 -> 1576;
4179 -> 4178;
4179 -> 1397;
4180 -> 4179;
4180 -> 1399;
4180 -> 1397;
4181 -> 1595;
4182 -> 4181;
4182 -> 1435;
4183 -> 4182;
4183 -> 1437;
4183 -> 1435;
4184 -> 1433;
4184 -> 1465;
4184 -> 1591;
4184 -> 4183;
4184 -> 1600;
4184 -> 1461;
4184 -> 1462;
4184 -> 4169;
4184 -> 1472;
4184 -> 1464;
4185 -> 1615;
4186 -> 4185;
4186 -> 1484;
4187 -> 4186;
4187 -> 1486;
4187 -> 1484;
4188 -> 1482;
4188 -> 1516;
4188 -> 1611;
4188 -> 4187;
4188 -> 1620;
4188 -> 1510;
4188 -> 1511;
4188 -> 4173;
4188 -> 1518;
4188 -> 1515;
4189 -> 1635;
4190 -> 4189;
4190 -> 1530;
4191 -> 4190;
4191 -> 1532;
4191 -> 1530;
4192 -> 1528;
4192 -> 1562;
4192 -> 1631;
4192 -> 4191;
4192 -> 1640;
4192 -> 1556;
4192 -> 1557;
4192 -> 4177;
4192 -> 1564;
4192 -> 1561;
4193 -> 1576;
4194 -> 4193;
4194 -> 1397;
4195 -> 4194;
4195 -> 1399;
4195 -> 1397;
4196 -> 1595;
4197 -> 4196;
4197 -> 1435;
4198 -> 4197;
4198 -> 1437;
4198 -> 1435;
4199 -> 1433;
4199 -> 1465;
4199 -> 1591;
4199 -> 4198;
4199 -> 1600;
4199 -> 1461;
4199 -> 1462;
4199 -> 4184;
4199 -> 1472;
4199 -> 1464;
4200 -> 1615;
4201 -> 4200;
4201 -> 1484;
4202 -> 4201;
4202 -> 1486;
4202 -> 1484;
4203 -> 1482;
4203 -> 1516;
4203 -> 1611;
4203 -> 4202;
4203 -> 1620;
4203 -> 1510;
4203 -> 1511;
4203 -> 4188;
4203 -> 1518;
4203 -> 1515;
4204 -> 1635;
4205 -> 4204;
4205 -> 1530;
4206 -> 4205;
4206 -> 1532;
4206 -> 1530;
4207 -> 1528;
4207 -> 1562;
4207 -> 1631;
4207 -> 4206;
4207 -> 1640;
4207 -> 1556;
4207 -> 1557;
4207 -> 4192;
4207 -> 1564;
4207 -> 1561;
4208 -> 1576;
4209 -> 4208;
4209 -> 1397;
4210 -> 4209;
4210 -> 1399;
4210 -> 1397;
4211 -> 1595;
4212 -> 4211;
4212 -> 1435;
4213 -> 4212;
4213 -> 1437;
4213 -> 1435;
4214 -> 1433;
4214 -> 1465;
4214 -> 1591;
4214 -> 4213;
4214 -> 1600;
4214 -> 1461;
4214 -> 1462;
4214 -> 4199;
4214 -> 1472;
4214 -> 1464;
4215 -> 1615;
4216 -> 4215;
4216 -> 1484;
4217 -> 4216;
4217 -> 1486;
4217 -> 1484;
4218 -> 1482;
4218 -> 1516;
4218 -> 1611;
4218 -> 4217;
4218 -> 1620;
4218 -> 1510;
4218 -> 1511;
4218 -> 4203;
4218 -> 1518;
4218 -> 1515;
4219 -> 1635;
4220 -> 4219;
4220 -> 1530;
4221 -> 4220;
4221 -> 1532;
4221 -> 1530;
4222 -> 1528;
4222 -> 1562;
4222 -> 1631;
4222 -> 4221;
4222 -> 1640;
4222 -> 1556;
4222 -> 1557;
4222 -> 4207;
4222 -> 1564;
4222 -> 1561;
4223 -> 1576;
4224 -> 4223;
4224 -> 1397;
4225 -> 4224;
4225 -> 1399;
4225 -> 1397;
4226 -> 1595;
4227 -> 4226;
4227 -> 1435;
4228 -> 4227;
4228 -> 1437;
4228 -> 1435;
4229 -> 1433;
4229 -> 1465;
4229 -> 1591;
4229 -> 4228;
4229 -> 1600;
4229 -> 1461;
4229 -> 1462;
4229 -> 4214;
4229 -> 1472;
4229 -> 1464;
4230 -> 1615;
4231 -> 4230;
4231 -> 1484;
4232 -> 4231;
4232 -> 1486;
4232 -> 1484;
4233 -> 1482;
4233 -> 1516;
4233 -> 1611;
4233 -> 4232;
4233 -> 1620;
4233 -> 1510;
4233 -> 1511;
4233 -> 4218;
4233 -> 1518;
4233 -> 1515;
4234 -> 1635;
4235 -> 4234;
4235 -> 1530;
4236 -> 4235;
4236 -> 1532;
4236 -> 1530;
4237 -> 1528;
4237 -> 1562;
4237 -> 1631;
4237 -> 4236;
4237 -> 1640;
4237 -> 1556;
4237 -> 1557;
4237 -> 4222;
4237 -> 1564;
4237 -> 1561;
4238 -> 1576;
4239 -> 4238;
4239 -> 1397;
4240 -> 4239;
4240 -> 1399;
4240 -> 1397;
4241 -> 1595;
4242 -> 4241;
4242 -> 1435;
4243 -> 4242;
4243 -> 1437;
4243 -> 1435;
4244 -> 1433;
4244 -> 1465;
4244 -> 1591;
4244 -> 4243;
4244 -> 1600;
4244 -> 1461;
4244 -> 1462;
4244 -> 4229;
4244 -> 1472;
4244 -> 1464;
4245 -> 1615;
4246 -> 4245;
4246 -> 1484;
4247 -> 4246;
4247 -> 1486;
4247 -> 1484;
4248 -> 1482;
4248 -> 1516;
4248 -> 1611;
4248 -> 4247;
4248 -> 1620;
4248 -> 1510;
4248 -> 1511;
4248 -> 4233;
4248 -> 1518;
4248 -> 1515;
4249 -> 1635;
4250 -> 4249;
4250 -> 1530;
4251 -> 4250;
4251 -> 1532;
4251 -> 1530;
4252 -> 1528;
4252 -> 1562;
4252 -> 1631;
4252 -> 4251;
4252 -> 1640;
4252 -> 1556;
4252 -> 1557;
4252 -> 4237;
4252 -> 1564;
4252 -> 1561;
4253 -> 1576;
4254 -> 4253;
4254 -> 1397;
4255 -> 4254;
4255 -> 1399;
4255 -> 1397;
4256 -> 1595;
4257 -> 4256;
4257 -> 1435;
4258 -> 4257;
4258 -> 1437;
4258 -> 1435;
4259 -> 1433;
4259 -> 1465;
4259 -> 1591;
4259 -> 4258;
4259 -> 1600;
4259 -> 1461;
4259 -> 1462;
4259 -> 4244;
4259 -> 1472;
4259 -> 1464;
4260 -> 1615;
4261 -> 4260;
4261 -> 1484;
4262 -> 4261;
4262 -> 1486;
4262 -> 1484;
4263 -> 1482;
4263 -> 1516;
4263 -> 1611;
4263 -> 4262;
4263 -> 1620;
4263 -> 1510;
4263 -> 1511;
4263 -> 4248;
4263 -> 1518;
4263 -> 1515;
4264 -> 1635;
4265 -> 4264;
4265 -> 1530;
4266 -> 4265;
4266 -> 1532;
4266 -> 1530;
4267 -> 1528;
4267 -> 1562;
4267 -> 1631;
4267 -> 4266;
4267 -> 1640;
4267 -> 1556;
4267 -> 1557;
4267 -> 4252;
4267 -> 1564;
4267 -> 1561;
4268 -> 1576;
4269 -> 4268;
4269 -> 1397;
4270 -> 4269;
4270 -> 1399;
4270 -> 1397;
4271 -> 1595;
4272 -> 4271;
4272 -> 1435;
4273 -> 4272;
4273 -> 1437;
4273 -> 1435;
4274 -> 1433;
4274 -> 1465;
4274 -> 1591;
4274 -> 4273;
4274 -> 1600;
4274 -> 1461;
4274 -> 1462;
4274 -> 4259;
4274 -> 1472;
4274 -> 1464;
4275 -> 1615;
4276 -> 4275;
4276 -> 1484;
4277 -> 4276;
4277 -> 1486;
4277 -> 1484;
4278 -> 1482;
4278 -> 1516;
4278 -> 1611;
4278 -> 4277;
4278 -> 1620;
4278 -> 1510;
4278 -> 1511;
4278 -> 4263;
4278 -> 1518;
4278 -> 1515;
4279 -> 1635;
4280 -> 4279;
4280 -> 1530;
4281 -> 4280;
4281 -> 1532;
4281 -> 1530;
4282 -> 1528;
4282 -> 1562;
4282 -> 1631;
4282 -> 4281;
4282 -> 1640;
4282 -> 1556;
4282 -> 1557;
4282 -> 4267;
4282 -> 1564;
4282 -> 1561;
4283 -> 1576;
4284 -> 4283;
4284 -> 1397;
4285 -> 4284;
4285 -> 1399;
4285 -> 1397;
4286 -> 1595;
4287 -> 4286;
4287 -> 1435;
4288 -> 4287;
4288 -> 1437;
4288 -> 1435;
4289 -> 1433;
4289 -> 1465;
4289 -> 1591;
4289 -> 4288;
4289 -> 1600;
4289 -> 1461;
4289 -> 1462;
4289 -> 4274;
4289 -> 1472;
4289 -> 1464;
4290 -> 1615;
4291 -> 4290;
4291 -> 1484;
4292 -> 4291;
4292 -> 1486;
4292 -> 1484;
4293 -> 1482;
4293 -> 1516;
4293 -> 1611;
4293 -> 4292;
4293 -> 1620;
4293 -> 1510;
4293 -> 1511;
4293 -> 4278;
4293 -> 1518;
4293 -> 1515;
4294 -> 1635;
4295 -> 4294;
4295 -> 1530;
4296 -> 4295;
4296 -> 1532;
4296 -> 1530;
4297 -> 1528;
4297 -> 1562;
4297 -> 1631;
4297 -> 4296;
4297 -> 1640;
4297 -> 1556;
4297 -> 1557;
4297 -> 4282;
4297 -> 1564;
4297 -> 1561;
4298 -> 1576;
4299 -> 4298;
4299 -> 1397;
4300 -> 4299;
4300 -> 1399;
4300 -> 1397;
4301 -> 1595;
4302 -> 4301;
4302 -> 1435;
4303 -> 4302;
4303 -> 1437;
4303 -> 1435;
4304 -> 1433;
4304 -> 1465;
4304 -> 1591;
4304 -> 4303;
4304 -> 1600;
4304 -> 1461;
4304 -> 1462;
4304 -> 4289;
4304 -> 1472;
4304 -> 1464;
4305 -> 1615;
4306 -> 4305;
4306 -> 1484;
4307 -> 4306;
4307 -> 1486;
4307 -> 1484;
4308 -> 1482;
4308 -> 1516;
4308 -> 1611;
4308 -> 4307;
4308 -> 1620;
4308 -> 1510;
4308 -> 1511;
4308 -> 4293;
4308 -> 1518;
4308 -> 1515;
4309 -> 1635;
4310 -> 4309;
4310 -> 1530;
4311 -> 4310;
4311 -> 1532;
4311 -> 1530;
4312 -> 1528;
4312 -> 1562;
4312 -> 1631;
4312 -> 4311;
4312 -> 1640;
4312 -> 1556;
4312 -> 1557;
4312 -> 4297;
4312 -> 1564;
4312 -> 1561;
4313 -> 1576;
4314 -> 4313;
4314 -> 1397;
4315 -> 4314;
4315 -> 1399;
4315 -> 1397;
4316 -> 1595;
4317 -> 4316;
4317 -> 1435;
4318 -> 4317;
4318 -> 1437;
4318 -> 1435;
4319 -> 1433;
4319 -> 1465;
4319 -> 1591;
4319 -> 4318;
4319 -> 1600;
4319 -> 1461;
4319 -> 1462;
4319 -> 4304;
4319 -> 1472;
4319 -> 1464;
4320 -> 1615;
4321 -> 4320;
4321 -> 1484;
4322 -> 4321;
4322 -> 1486;
4322 -> 1484;
4323 -> 1482;
4323 -> 1516;
4323 -> 1611;
4323 -> 4322;
4323 -> 1620;
4323 -> 1510;
4323 -> 1511;
4323 -> 4308;
4323 -> 1518;
4323 -> 1515;
4324 -> 1635;
4325 -> 4324;
4325 -> 1530;
4326 -> 4325;
4326 -> 1532;
4326 -> 1530;
4327 -> 1528;
4327 -> 1562;
4327 -> 1631;
4327 -> 4326;
4327 -> 1640;
4327 -> 1556;
4327 -> 1557;
4327 -> 4312;
4327 -> 1564;
4327 -> 1561;
4328 -> 1576;
4329 -> 4328;
4329 -> 1397;
4330 -> 4329;
4330 -> 1399;
4330 -> 1397;
4331 -> 1595;
4332 -> 4331;
4332 -> 1435;
4333 -> 4332;
4333 -> 1437;
4333 -> 1435;
4334 -> 1433;
4334 -> 1465;
4334 -> 1591;
4334 -> 4333;
4334 -> 1600;
4334 -> 1461;
4334 -> 1462;
4334 -> 4319;
4334 -> 1472;
4334 -> 1464;
4335 -> 1615;
4336 -> 4335;
4336 -> 1484;
4337 -> 4336;
4337 -> 1486;
4337 -> 1484;
4338 -> 1482;
4338 -> 1516;
4338 -> 1611;
4338 -> 4337;
4338 -> 1620;
4338 -> 1510;
4338 -> 1511;
4338 -> 4323;
4338 -> 1518;
4338 -> 1515;
4339 -> 1635;
4340 -> 4339;
4340 -> 1530;
4341 -> 4340;
4341 -> 1532;
4341 -> 1530;
4342 -> 1528;
4342 -> 1562;
4342 -> 1631;
4342 -> 4341;
4342 -> 1640;
4342 -> 1556;
4342 -> 1557;
4342 -> 4327;
4342 -> 1564;
4342 -> 1561;
4343 -> 1576;
4344 -> 4343;
4344 -> 1397;
4345 -> 4344;
4345 -> 1399;
4345 -> 1397;
4346 -> 1595;
4347 -> 4346;
4347 -> 1435;
4348 -> 4347;
4348 -> 1437;
4348 -> 1435;
4349 -> 1433;
4349 -> 1465;
4349 -> 1591;
4349 -> 4348;
4349 -> 1600;
4349 -> 1461;
4349 -> 1462;
4349 -> 4334;
4349 -> 1472;
4349 -> 1464;
4350 -> 1615;
4351 -> 4350;
4351 -> 1484;
4352 -> 4351;
4352 -> 1486;
4352 -> 1484;
4353 -> 1482;
4353 -> 1516;
4353 -> 1611;
4353 -> 4352;
4353 -> 1620;
4353 -> 1510;
4353 -> 1511;
4353 -> 4338;
4353 -> 1518;
4353 -> 1515;
4354 -> 1635;
4355 -> 4354;
4355 -> 1530;
4356 -> 4355;
4356 -> 1532;
4356 -> 1530;
4357 -> 1528;
4357 -> 1562;
4357 -> 1631;
4357 -> 4356;
4357 -> 1640;
4357 -> 1556;
4357 -> 1557;
4357 -> 4342;
4357 -> 1564;
4357 -> 1561;
4358 -> 1576;
4359 -> 4358;
4359 -> 1397;
4360 -> 4359;
4360 -> 1399;
4360 -> 1397;
4361 -> 1595;
4362 -> 4361;
4362 -> 1435;
4363 -> 4362;
4363 -> 1437;
4363 -> 1435;
4364 -> 1433;
4364 -> 1465;
4364 -> 1591;
4364 -> 4363;
4364 -> 1600;
4364 -> 1461;
4364 -> 1462;
4364 -> 4349;
4364 -> 1472;
4364 -> 1464;
4365 -> 1615;
4366 -> 4365;
4366 -> 1484;
4367 -> 4366;
4367 -> 1486;
4367 -> 1484;
4368 -> 1482;
4368 -> 1516;
4368 -> 1611;
4368 -> 4367;
4368 -> 1620;
4368 -> 1510;
4368 -> 1511;
4368 -> 4353;
4368 -> 1518;
4368 -> 1515;
4369 -> 1635;
4370 -> 4369;
4370 -> 1530;
4371 -> 4370;
4371 -> 1532;
4371 -> 1530;
4372 -> 1528;
4372 -> 1562;
4372 -> 1631;
4372 -> 4371;
4372 -> 1640;
4372 -> 1556;
4372 -> 1557;
4372 -> 4357;
4372 -> 1564;
4372 -> 1561;
4373 -> 1576;
4374 -> 4373;
4374 -> 1397;
4375 -> 4374;
4375 -> 1399;
4375 -> 1397;
4376 -> 1595;
4377 -> 4376;
4377 -> 1435;
4378 -> 4377;
4378 -> 1437;
4378 -> 1435;
4379 -> 1433;
4379 -> 1465;
4379 -> 1591;
4379 -> 4378;
4379 -> 1600;
4379 -> 1461;
4379 -> 1462;
4379 -> 4364;
4379 -> 1472;
4379 -> 1464;
4380 -> 1615;
4381 -> 4380;
4381 -> 1484;
4382 -> 4381;
4382 -> 1486;
4382 -> 1484;
4383 -> 1482;
4383 -> 1516;
4383 -> 1611;
4383 -> 4382;
4383 -> 1620;
4383 -> 1510;
4383 -> 1511;
4383 -> 4368;
4383 -> 1518;
4383 -> 1515;
4384 -> 1635;
4385 -> 4384;
4385 -> 1530;
4386 -> 4385;
4386 -> 1532;
4386 -> 1530;
4387 -> 1528;
4387 -> 1562;
4387 -> 1631;
4387 -> 4386;
4387 -> 1640;
4387 -> 1556;
4387 -> 1557;
4387 -> 4372;
4387 -> 1564;
4387 -> 1561;
4388 -> 1576;
4389 -> 4388;
4389 -> 1397;
4390 -> 4389;
4390 -> 1399;
4390 -> 1397;
4391 -> 1595;
4392 -> 4391;
4392 -> 1435;
4393 -> 4392;
4393 -> 1437;
4393 -> 1435;
4394 -> 1433;
4394 -> 1465;
4394 -> 1591;
4394 -> 4393;
4394 -> 1600;
4394 -> 1461;
4394 -> 1462;
4394 -> 4379;
4394 -> 1472;
4394 -> 1464;
4395 -> 1615;
4396 -> 4395;
4396 -> 1484;
4397 -> 4396;
4397 -> 1486;
4397 -> 1484;
4398 -> 1482;
4398 -> 1516;
4398 -> 1611;
4398 -> 4397;
4398 -> 1620;
4398 -> 1510;
4398 -> 1511;
4398 -> 4383;
4398 -> 1518;
4398 -> 1515;
4399 -> 1635;
4400 -> 4399;
4400 -> 1530;
4401 -> 4400;
4401 -> 1532;
4401 -> 1530;
4402 -> 1528;
4402 -> 1562;
4402 -> 1631;
4402 -> 4401;
4402 -> 1640;
4402 -> 1556;
4402 -> 1557;
4402 -> 4387;
4402 -> 1564;
4402 -> 1561;
4403 -> 1576;
4404 -> 4403;
4404 -> 1397;
4405 -> 4404;
4405 -> 1399;
4405 -> 1397;
4406 -> 1595;
4407 -> 4406;
4407 -> 1435;
4408 -> 4407;
4408 -> 1437;
4408 -> 1435;
4409 -> 1433;
4409 -> 1465;
4409 -> 1591;
4409 -> 4408;
4409 -> 1600;
4409 -> 1461;
4409 -> 1462;
4409 -> 4394;
4409 -> 1472;
4409 -> 1464;
4410 -> 1615;
4411 -> 4410;
4411 -> 1484;
4412 -> 4411;
4412 -> 1486;
4412 -> 1484;
4413 -> 1482;
4413 -> 1516;
4413 -> 1611;
4413 -> 4412;
4413 -> 1620;
4413 -> 1510;
4413 -> 1511;
4413 -> 4398;
4413 -> 1518;
4413 -> 1515;
4414 -> 1635;
4415 -> 4414;
4415 -> 1530;
4416 -> 4415;
4416 -> 1532;
4416 -> 1530;
4417 -> 1528;
4417 -> 1562;
4417 -> 1631;
4417 -> 4416;
4417 -> 1640;
4417 -> 1556;
4417 -> 1557;
4417 -> 4402;
4417 -> 1564;
4417 -> 1561;
4418 -> 1576;
4419 -> 4418;
4419 -> 1397;
4420 -> 4419;
4420 -> 1399;
4420 -> 1397;
4421 -> 1595;
4422 -> 4421;
4422 -> 1435;
4423 -> 4422;
4423 -> 1437;
4423 -> 1435;
4424 -> 1433;
4424 -> 1465;
4424 -> 1591;
4424 -> 4423;
4424 -> 1600;
4424 -> 1461;
4424 -> 1462;
4424 -> 4409;
4424 -> 1472;
4424 -> 1464;
4425 -> 1615;
4426 -> 4425;
4426 -> 1484;
4427 -> 4426;
4427 -> 1486;
4427 -> 1484;
4428 -> 1482;
4428 -> 1516;
4428 -> 1611;
4428 -> 4427;
4428 -> 1620;
4428 -> 1510;
4428 -> 1511;
4428 -> 4413;
4428 -> 1518;
4428 -> 1515;
4429 -> 1635;
4430 -> 4429;
4430 -> 1530;
4431 -> 4430;
4431 -> 1532;
4431 -> 1530;
4432 -> 1528;
4432 -> 1562;
4432 -> 1631;
4432 -> 4431;
4432 -> 1640;
4432 -> 1556;
4432 -> 1557;
4432 -> 4417;
4432 -> 1564;
4432 -> 1561;
4433 -> 1576;
4434 -> 4433;
4434 -> 1397;
4435 -> 4434;
4435 -> 1399;
4435 -> 1397;
4436 -> 1595;
4437 -> 4436;
4437 -> 1435;
4438 -> 4437;
4438 -> 1437;
4438 -> 1435;
4439 -> 1433;
4439 -> 1465;
4439 -> 1591;
4439 -> 4438;
4439 -> 1600;
4439 -> 1461;
4439 -> 1462;
4439 -> 4424;
4439 -> 1472;
4439 -> 1464;
4440 -> 1615;
4441 -> 4440;
4441 -> 1484;
4442 -> 4441;
4442 -> 1486;
4442 -> 1484;
4443 -> 1482;
4443 -> 1516;
4443 -> 1611;
4443 -> 4442;
4443 -> 1620;
4443 -> 1510;
4443 -> 1511;
4443 -> 4428;
4443 -> 1518;
4443 -> 1515;
4444 -> 1635;
4445 -> 4444;
4445 -> 1530;
4446 -> 4445;
4446 -> 1532;
4446 -> 1530;
4447 -> 1528;
4447 -> 1562;
4447 -> 1631;
4447 -> 4446;
4447 -> 1640;
4447 -> 1556;
4447 -> 1557;
4447 -> 4432;
4447 -> 1564;
4447 -> 1561;
4448 -> 1576;
4449 -> 4448;
4449 -> 1397;
4450 -> 4449;
4450 -> 1399;
4450 -> 1397;
4451 -> 1595;
4452 -> 4451;
4452 -> 1435;
4453 -> 4452;
4453 -> 1437;
4453 -> 1435;
4454 -> 1433;
4454 -> 1465;
4454 -> 1591;
4454 -> 4453;
4454 -> 1600;
4454 -> 1461;
4454 -> 1462;
4454 -> 4439;
4454 -> 1472;
4454 -> 1464;
4455 -> 1615;
4456 -> 4455;
4456 -> 1484;
4457 -> 4456;
4457 -> 1486;
4457 -> 1484;
4458 -> 1482;
4458 -> 1516;
4458 -> 1611;
4458 -> 4457;
4458 -> 1620;
4458 -> 1510;
4458 -> 1511;
4458 -> 4443;
4458 -> 1518;
4458 -> 1515;
4459 -> 1635;
4460 -> 4459;
4460 -> 1530;
4461 -> 4460;
4461 -> 1532;
4461 -> 1530;
4462 -> 1528;
4462 -> 1562;
4462 -> 1631;
4462 -> 4461;
4462 -> 1640;
4462 -> 1556;
4462 -> 1557;
4462 -> 4447;
4462 -> 1564;
4462 -> 1561;
4463 -> 1576;
4464 -> 4463;
4464 -> 1397;
4465 -> 4464;
4465 -> 1399;
4465 -> 1397;
4466 -> 1595;
4467 -> 4466;
4467 -> 1435;
4468 -> 4467;
4468 -> 1437;
4468 -> 1435;
4469 -> 1433;
4469 -> 1465;
4469 -> 1591;
4469 -> 4468;
4469 -> 1600;
4469 -> 1461;
4469 -> 1462;
4469 -> 4454;
4469 -> 1472;
4469 -> 1464;
4470 -> 1615;
4471 -> 4470;
4471 -> 1484;
4472 -> 4471;
4472 -> 1486;
4472 -> 1484;
4473 -> 1482;
4473 -> 1516;
4473 -> 1611;
4473 -> 4472;
4473 -> 1620;
4473 -> 1510;
4473 -> 1511;
4473 -> 4458;
4473 -> 1518;
4473 -> 1515;
4474 -> 1635;
4475 -> 4474;
4475 -> 1530;
4476 -> 4475;
4476 -> 1532;
4476 -> 1530;
4477 -> 1528;
4477 -> 1562;
4477 -> 1631;
4477 -> 4476;
4477 -> 1640;
4477 -> 1556;
4477 -> 1557;
4477 -> 4462;
4477 -> 1564;
4477 -> 1561;
4478 -> 1576;
4479 -> 4478;
4479 -> 1397;
4480 -> 4479;
4480 -> 1399;
4480 -> 1397;
4481 -> 1595;
4482 -> 4481;
4482 -> 1435;
4483 -> 4482;
4483 -> 1437;
4483 -> 1435;
4484 -> 1433;
4484 -> 1465;
4484 -> 1591;
4484 -> 4483;
4484 -> 1600;
4484 -> 1461;
4484 -> 1462;
4484 -> 4469;
4484 -> 1472;
4484 -> 1464;
4485 -> 1615;
4486 -> 4485;
4486 -> 1484;
4487 -> 4486;
4487 -> 1486;
4487 -> 1484;
4488 -> 1482;
4488 -> 1516;
4488 -> 1611;
4488 -> 4487;
4488 -> 1620;
4488 -> 1510;
4488 -> 1511;
4488 -> 4473;
4488 -> 1518;
4488 -> 1515;
4489 -> 1635;
4490 -> 4489;
4490 -> 1530;
4491 -> 4490;
4491 -> 1532;
4491 -> 1530;
4492 -> 1528;
4492 -> 1562;
4492 -> 1631;
4492 -> 4491;
4492 -> 1640;
4492 -> 1556;
4492 -> 1557;
4492 -> 4477;
4492 -> 1564;
4492 -> 1561;
4493 -> 1576;
4494 -> 4493;
4494 -> 1397;
4495 -> 4494;
4495 -> 1399;
4495 -> 1397;
4496 -> 1595;
4497 -> 4496;
4497 -> 1435;
4498 -> 4497;
4498 -> 1437;
4498 -> 1435;
4499 -> 1433;
4499 -> 1465;
4499 -> 1591;
4499 -> 4498;
4499 -> 1600;
4499 -> 1461;
4499 -> 1462;
4499 -> 4484;
4499 -> 1472;
4499 -> 1464;
4500 -> 1615;
4501 -> 4500;
4501 -> 1484;
4502 -> 4501;
4502 -> 1486;
4502 -> 1484;
4503 -> 1482;
4503 -> 1516;
4503 -> 1611;
4503 -> 4502;
4503 -> 1620;
4503 -> 1510;
4503 -> 1511;
4503 -> 4488;
4503 -> 1518;
4503 -> 1515;
4504 -> 1635;
4505 -> 4504;
4505 -> 1530;
4506 -> 4505;
4506 -> 1532;
4506 -> 1530;
4507 -> 1528;
4507 -> 1562;
4507 -> 1631;
4507 -> 4506;
4507 -> 1640;
4507 -> 1556;
4507 -> 1557;
4507 -> 4492;
4507 -> 1564;
4507 -> 1561;
4508 -> 1576;
4509 -> 4508;
4509 -> 1397;
4510 -> 4509;
4510 -> 1399;
4510 -> 1397;
4511 -> 1595;
4512 -> 4511;
4512 -> 1435;
4513 -> 4512;
4513 -> 1437;
4513 -> 1435;
4514 -> 1433;
4514 -> 1465;
4514 -> 1591;
4514 -> 4513;
4514 -> 1600;
4514 -> 1461;
4514 -> 1462;
4514 -> 4499;
4514 -> 1472;
4514 -> 1464;
4515 -> 1615;
4516 -> 4515;
4516 -> 1484;
4517 -> 4516;
4517 -> 1486;
4517 -> 1484;
4518 -> 1482;
4518 -> 1516;
4518 -> 1611;
4518 -> 4517;
4518 -> 1620;
4518 -> 1510;
4518 -> 1511;
4518 -> 4503;
4518 -> 1518;
4518 -> 1515;
4519 -> 1635;
4520 -> 4519;
4520 -> 1530;
4521 -> 4520;
4521 -> 1532;
4521 -> 1530;
4522 -> 1528;
4522 -> 1562;
4522 -> 1631;
4522 -> 4521;
4522 -> 1640;
4522 -> 1556;
4522 -> 1557;
4522 -> 4507;
4522 -> 1564;
4522 -> 1561;
4523 -> 1576;
4524 -> 4523;
4524 -> 1397;
4525 -> 4524;
4525 -> 1399;
4525 -> 1397;
4526 -> 1595;
4527 -> 4526;
4527 -> 1435;
4528 -> 4527;
4528 -> 1437;
4528 -> 1435;
4529 -> 1433;
4529 -> 1465;
4529 -> 1591;
4529 -> 4528;
4529 -> 1600;
4529 -> 1461;
4529 -> 1462;
4529 -> 4514;
4529 -> 1472;
4529 -> 1464;
4530 -> 1615;
4531 -> 4530;
4531 -> 1484;
4532 -> 4531;
4532 -> 1486;
4532 -> 1484;
4533 -> 1482;
4533 -> 1516;
4533 -> 1611;
4533 -> 4532;
4533 -> 1620;
4533 -> 1510;
4533 -> 1511;
4533 -> 4518;
4533 -> 1518;
4533 -> 1515;
4534 -> 1635;
4535 -> 4534;
4535 -> 1530;
4536 -> 4535;
4536 -> 1532;
4536 -> 1530;
4537 -> 1528;
4537 -> 1562;
4537 -> 1631;
4537 -> 4536;
4537 -> 1640;
4537 -> 1556;
4537 -> 1557;
4537 -> 4522;
4537 -> 1564;
4537 -> 1561;
4538 -> 1576;
4539 -> 4538;
4539 -> 1397;
4540 -> 4539;
4540 -> 1399;
4540 -> 1397;
4541 -> 1595;
4542 -> 4541;
4542 -> 1435;
4543 -> 4542;
4543 -> 1437;
4543 -> 1435;
4544 -> 1433;
4544 -> 1465;
4544 -> 1591;
4544 -> 4543;
4544 -> 1600;
4544 -> 1461;
4544 -> 1462;
4544 -> 4529;
4544 -> 1472;
4544 -> 1464;
4545 -> 1615;
4546 -> 4545;
4546 -> 1484;
4547 -> 4546;
4547 -> 1486;
4547 -> 1484;
4548 -> 1482;
4548 -> 1516;
4548 -> 1611;
4548 -> 4547;
4548 -> 1620;
4548 -> 1510;
4548 -> 1511;
4548 -> 4533;
4548 -> 1518;
4548 -> 1515;
4549 -> 1635;
4550 -> 4549;
4550 -> 1530;
4551 -> 4550;
4551 -> 1532;
4551 -> 1530;
4552 -> 1528;
4552 -> 1562;
4552 -> 1631;
4552 -> 4551;
4552 -> 1640;
4552 -> 1556;
4552 -> 1557;
4552 -> 4537;
4552 -> 1564;
4552 -> 1561;
4553 -> 1576;
4554 -> 4553;
4554 -> 1397;
4555 -> 4554;
4555 -> 1399;
4555 -> 1397;
4556 -> 1595;
4557 -> 4556;
4557 -> 1435;
4558 -> 4557;
4558 -> 1437;
4558 -> 1435;
4559 -> 1433;
4559 -> 1465;
4559 -> 1591;
4559 -> 4558;
4559 -> 1600;
4559 -> 1461;
4559 -> 1462;
4559 -> 4544;
4559 -> 1472;
4559 -> 1464;
4560 -> 1615;
4561 -> 4560;
4561 -> 1484;
4562 -> 4561;
4562 -> 1486;
4562 -> 1484;
4563 -> 1482;
4563 -> 1516;
4563 -> 1611;
4563 -> 4562;
4563 -> 1620;
4563 -> 1510;
4563 -> 1511;
4563 -> 4548;
4563 -> 1518;
4563 -> 1515;
4564 -> 1635;
4565 -> 4564;
4565 -> 1530;
4566 -> 4565;
4566 -> 1532;
4566 -> 1530;
4567 -> 1528;
4567 -> 1562;
4567 -> 1631;
4567 -> 4566;
4567 -> 1640;
4567 -> 1556;
4567 -> 1557;
4567 -> 4552;
4567 -> 1564;
4567 -> 1561;
4568 -> 1576;
4569 -> 4568;
4569 -> 1397;
4570 -> 4569;
4570 -> 1399;
4570 -> 1397;
4571 -> 1595;
4572 -> 4571;
4572 -> 1435;
4573 -> 4572;
4573 -> 1437;
4573 -> 1435;
4574 -> 1433;
4574 -> 1465;
4574 -> 1591;
4574 -> 4573;
4574 -> 1600;
4574 -> 1461;
4574 -> 1462;
4574 -> 4559;
4574 -> 1472;
4574 -> 1464;
4575 -> 1615;
4576 -> 4575;
4576 -> 1484;
4577 -> 4576;
4577 -> 1486;
4577 -> 1484;
4578 -> 1482;
4578 -> 1516;
4578 -> 1611;
4578 -> 4577;
4578 -> 1620;
4578 -> 1510;
4578 -> 1511;
4578 -> 4563;
4578 -> 1518;
4578 -> 1515;
4579 -> 1635;
4580 -> 4579;
4580 -> 1530;
4581 -> 4580;
4581 -> 1532;
4581 -> 1530;
4582 -> 1528;
4582 -> 1562;
4582 -> 1631;
4582 -> 4581;
4582 -> 1640;
4582 -> 1556;
4582 -> 1557;
4582 -> 4567;
4582 -> 1564;
4582 -> 1561;
4583 -> 1576;
4584 -> 4583;
4584 -> 1397;
4585 -> 4584;
4585 -> 1399;
4585 -> 1397;
4586 -> 1595;
4587 -> 4586;
4587 -> 1435;
4588 -> 4587;
4588 -> 1437;
4588 -> 1435;
4589 -> 1433;
4589 -> 1465;
4589 -> 1591;
4589 -> 4588;
4589 -> 1600;
4589 -> 1461;
4589 -> 1462;
4589 -> 4574;
4589 -> 1472;
4589 -> 1464;
4590 -> 1615;
4591 -> 4590;
4591 -> 1484;
4592 -> 4591;
4592 -> 1486;
4592 -> 1484;
4593 -> 1482;
4593 -> 1516;
4593 -> 1611;
4593 -> 4592;
4593 -> 1620;
4593 -> 1510;
4593 -> 1511;
4593 -> 4578;
4593 -> 1518;
4593 -> 1515;
4594 -> 1635;
4595 -> 4594;
4595 -> 1530;
4596 -> 4595;
4596 -> 1532;
4596 -> 1530;
4597 -> 1528;
4597 -> 1562;
4597 -> 1631;
4597 -> 4596;
4597 -> 1640;
4597 -> 1556;
4597 -> 1557;
4597 -> 4582;
4597 -> 1564;
4597 -> 1561;
4598 -> 1576;
4599 -> 4598;
4599 -> 1397;
4600 -> 4599;
4600 -> 1399;
4600 -> 1397;
4601 -> 1595;
4602 -> 4601;
4602 -> 1435;
4603 -> 4602;
4603 -> 1437;
4603 -> 1435;
4604 -> 1433;
4604 -> 1465;
4604 -> 1591;
4604 -> 4603;
4604 -> 1600;
4604 -> 1461;
4604 -> 1462;
4604 -> 4589;
4604 -> 1472;
4604 -> 1464;
4605 -> 1615;
4606 -> 4605;
4606 -> 1484;
4607 -> 4606;
4607 -> 1486;
4607 -> 1484;
4608 -> 1482;
4608 -> 1516;
4608 -> 1611;
4608 -> 4607;
4608 -> 1620;
4608 -> 1510;
4608 -> 1511;
4608 -> 4593;
4608 -> 1518;
4608 -> 1515;
4609 -> 1635;
4610 -> 4609;
4610 -> 1530;
4611 -> 4610;
4611 -> 1532;
4611 -> 1530;
4612 -> 1528;
4612 -> 1562;
4612 -> 1631;
4612 -> 4611;
4612 -> 1640;
4612 -> 1556;
4612 -> 1557;
4612 -> 4597;
4612 -> 1564;
4612 -> 1561;
4613 -> 1576;
4614 -> 4613;
4614 -> 1397;
4615 -> 4614;
4615 -> 1399;
4615 -> 1397;
4616 -> 1595;
4617 -> 4616;
4617 -> 1435;
4618 -> 4617;
4618 -> 1437;
4618 -> 1435;
4619 -> 1433;
4619 -> 1465;
4619 -> 1591;
4619 -> 4618;
4619 -> 1600;
4619 -> 1461;
4619 -> 1462;
4619 -> 4604;
4619 -> 1472;
4619 -> 1464;
4620 -> 1615;
4621 -> 4620;
4621 -> 1484;
4622 -> 4621;
4622 -> 1486;
4622 -> 1484;
4623 -> 1482;
4623 -> 1516;
4623 -> 1611;
4623 -> 4622;
4623 -> 1620;
4623 -> 1510;
4623 -> 1511;
4623 -> 4608;
4623 -> 1518;
4623 -> 1515;
4624 -> 1635;
4625 -> 4624;
4625 -> 1530;
4626 -> 4625;
4626 -> 1532;
4626 -> 1530;
4627 -> 1528;
4627 -> 1562;
4627 -> 1631;
4627 -> 4626;
4627 -> 1640;
4627 -> 1556;
4627 -> 1557;
4627 -> 4612;
4627 -> 1564;
4627 -> 1561;
4628 -> 1576;
4629 -> 4628;
4629 -> 1397;
4630 -> 4629;
4630 -> 1399;
4630 -> 1397;
4631 -> 1595;
4632 -> 4631;
4632 -> 1435;
4633 -> 4632;
4633 -> 1437;
4633 -> 1435;
4634 -> 1433;
4634 -> 1465;
4634 -> 1591;
4634 -> 4633;
4634 -> 1600;
4634 -> 1461;
4634 -> 1462;
4634 -> 4619;
4634 -> 1472;
4634 -> 1464;
4635 -> 1615;
4636 -> 4635;
4636 -> 1484;
4637 -> 4636;
4637 -> 1486;
4637 -> 1484;
4638 -> 1482;
4638 -> 1516;
4638 -> 1611;
4638 -> 4637;
4638 -> 1620;
4638 -> 1510;
4638 -> 1511;
4638 -> 4623;
4638 -> 1518;
4638 -> 1515;
4639 -> 1635;
4640 -> 4639;
4640 -> 1530;
4641 -> 4640;
4641 -> 1532;
4641 -> 1530;
4642 -> 1528;
4642 -> 1562;
4642 -> 1631;
4642 -> 4641;
4642 -> 1640;
4642 -> 1556;
4642 -> 1557;
4642 -> 4627;
4642 -> 1564;
4642 -> 1561;
4643 -> 1576;
4644 -> 4643;
4644 -> 1397;
4645 -> 4644;
4645 -> 1399;
4645 -> 1397;
4646 -> 1595;
4647 -> 4646;
4647 -> 1435;
4648 -> 4647;
4648 -> 1437;
4648 -> 1435;
4649 -> 1433;
4649 -> 1465;
4649 -> 1591;
4649 -> 4648;
4649 -> 1600;
4649 -> 1461;
4649 -> 1462;
4649 -> 4634;
4649 -> 1472;
4649 -> 1464;
4650 -> 1615;
4651 -> 4650;
4651 -> 1484;
4652 -> 4651;
4652 -> 1486;
4652 -> 1484;
4653 -> 1482;
4653 -> 1516;
4653 -> 1611;
4653 -> 4652;
4653 -> 1620;
4653 -> 1510;
4653 -> 1511;
4653 -> 4638;
4653 -> 1518;
4653 -> 1515;
4654 -> 1635;
4655 -> 4654;
4655 -> 1530;
4656 -> 4655;
4656 -> 1532;
4656 -> 1530;
4657 -> 1528;
4657 -> 1562;
4657 -> 1631;
4657 -> 4656;
4657 -> 1640;
4657 -> 1556;
4657 -> 1557;
4657 -> 4642;
4657 -> 1564;
4657 -> 1561;
4658 -> 1576;
4659 -> 4658;
4659 -> 1397;
4660 -> 4659;
4660 -> 1399;
4660 -> 1397;
4661 -> 1595;
4662 -> 4661;
4662 -> 1435;
4663 -> 4662;
4663 -> 1437;
4663 -> 1435;
4664 -> 1433;
4664 -> 1465;
4664 -> 1591;
4664 -> 4663;
4664 -> 1600;
4664 -> 1461;
4664 -> 1462;
4664 -> 4649;
4664 -> 1472;
4664 -> 1464;
4665 -> 1615;
4666 -> 4665;
4666 -> 1484;
4667 -> 4666;
4667 -> 1486;
4667 -> 1484;
4668 -> 1482;
4668 -> 1516;
4668 -> 1611;
4668 -> 4667;
4668 -> 1620;
4668 -> 1510;
4668 -> 1511;
4668 -> 4653;
4668 -> 1518;
4668 -> 1515;
4669 -> 1635;
4670 -> 4669;
4670 -> 1530;
4671 -> 4670;
4671 -> 1532;
4671 -> 1530;
4672 -> 1528;
4672 -> 1562;
4672 -> 1631;
4672 -> 4671;
4672 -> 1640;
4672 -> 1556;
4672 -> 1557;
4672 -> 4657;
4672 -> 1564;
4672 -> 1561;
4673 -> 1576;
4674 -> 4673;
4674 -> 1397;
4675 -> 4674;
4675 -> 1399;
4675 -> 1397;
4676 -> 1595;
4677 -> 4676;
4677 -> 1435;
4678 -> 4677;
4678 -> 1437;
4678 -> 1435;
4679 -> 1433;
4679 -> 1465;
4679 -> 1591;
4679 -> 4678;
4679 -> 1600;
4679 -> 1461;
4679 -> 1462;
4679 -> 4664;
4679 -> 1472;
4679 -> 1464;
4680 -> 1615;
4681 -> 4680;
4681 -> 1484;
4682 -> 4681;
4682 -> 1486;
4682 -> 1484;
4683 -> 1482;
4683 -> 1516;
4683 -> 1611;
4683 -> 4682;
4683 -> 1620;
4683 -> 1510;
4683 -> 1511;
4683 -> 4668;
4683 -> 1518;
4683 -> 1515;
4684 -> 1635;
4685 -> 4684;
4685 -> 1530;
4686 -> 4685;
4686 -> 1532;
4686 -> 1530;
4687 -> 1528;
4687 -> 1562;
4687 -> 1631;
4687 -> 4686;
4687 -> 1640;
4687 -> 1556;
4687 -> 1557;
4687 -> 4672;
4687 -> 1564;
4687 -> 1561;
4688 -> 1576;
4689 -> 4688;
4689 -> 1397;
4690 -> 4689;
4690 -> 1399;
4690 -> 1397;
4691 -> 1595;
4692 -> 4691;
4692 -> 1435;
4693 -> 4692;
4693 -> 1437;
4693 -> 1435;
4694 -> 1433;
4694 -> 1465;
4694 -> 1591;
4694 -> 4693;
4694 -> 1600;
4694 -> 1461;
4694 -> 1462;
4694 -> 4679;
4694 -> 1472;
4694 -> 1464;
4695 -> 1615;
4696 -> 4695;
4696 -> 1484;
4697 -> 4696;
4697 -> 1486;
4697 -> 1484;
4698 -> 1482;
4698 -> 1516;
4698 -> 1611;
4698 -> 4697;
4698 -> 1620;
4698 -> 1510;
4698 -> 1511;
4698 -> 4683;
4698 -> 1518;
4698 -> 1515;
4699 -> 1635;
4700 -> 4699;
4700 -> 1530;
4701 -> 4700;
4701 -> 1532;
4701 -> 1530;
4702 -> 1528;
4702 -> 1562;
4702 -> 1631;
4702 -> 4701;
4702 -> 1640;
4702 -> 1556;
4702 -> 1557;
4702 -> 4687;
4702 -> 1564;
4702 -> 1561;
4703 -> 1576;
4704 -> 4703;
4704 -> 1397;
4705 -> 4704;
4705 -> 1399;
4705 -> 1397;
4706 -> 1595;
4707 -> 4706;
4707 -> 1435;
4708 -> 4707;
4708 -> 1437;
4708 -> 1435;
4709 -> 1433;
4709 -> 1465;
4709 -> 1591;
4709 -> 4708;
4709 -> 1600;
4709 -> 1461;
4709 -> 1462;
4709 -> 4694;
4709 -> 1472;
4709 -> 1464;
4710 -> 1615;
4711 -> 4710;
4711 -> 1484;
4712 -> 4711;
4712 -> 1486;
4712 -> 1484;
4713 -> 1482;
4713 -> 1516;
4713 -> 1611;
4713 -> 4712;
4713 -> 1620;
4713 -> 1510;
4713 -> 1511;
4713 -> 4698;
4713 -> 1518;
4713 -> 1515;
4714 -> 1635;
4715 -> 4714;
4715 -> 1530;
4716 -> 4715;
4716 -> 1532;
4716 -> 1530;
4717 -> 1528;
4717 -> 1562;
4717 -> 1631;
4717 -> 4716;
4717 -> 1640;
4717 -> 1556;
4717 -> 1557;
4717 -> 4702;
4717 -> 1564;
4717 -> 1561;
4718 -> 1576;
4719 -> 4718;
4719 -> 1397;
4720 -> 4719;
4720 -> 1399;
4720 -> 1397;
4721 -> 1595;
4722 -> 4721;
4722 -> 1435;
4723 -> 4722;
4723 -> 1437;
4723 -> 1435;
4724 -> 1433;
4724 -> 1465;
4724 -> 1591;
4724 -> 4723;
4724 -> 1600;
4724 -> 1461;
4724 -> 1462;
4724 -> 4709;
4724 -> 1472;
4724 -> 1464;
4725 -> 1615;
4726 -> 4725;
4726 -> 1484;
4727 -> 4726;
4727 -> 1486;
4727 -> 1484;
4728 -> 1482;
4728 -> 1516;
4728 -> 1611;
4728 -> 4727;
4728 -> 1620;
4728 -> 1510;
4728 -> 1511;
4728 -> 4713;
4728 -> 1518;
4728 -> 1515;
4729 -> 1635;
4730 -> 4729;
4730 -> 1530;
4731 -> 4730;
4731 -> 1532;
4731 -> 1530;
4732 -> 1528;
4732 -> 1562;
4732 -> 1631;
4732 -> 4731;
4732 -> 1640;
4732 -> 1556;
4732 -> 1557;
4732 -> 4717;
4732 -> 1564;
4732 -> 1561;
4733 -> 1576;
4734 -> 4733;
4734 -> 1397;
4735 -> 4734;
4735 -> 1399;
4735 -> 1397;
4736 -> 1595;
4737 -> 4736;
4737 -> 1435;
4738 -> 4737;
4738 -> 1437;
4738 -> 1435;
4739 -> 1433;
4739 -> 1465;
4739 -> 1591;
4739 -> 4738;
4739 -> 1600;
4739 -> 1461;
4739 -> 1462;
4739 -> 4724;
4739 -> 1472;
4739 -> 1464;
4740 -> 1615;
4741 -> 4740;
4741 -> 1484;
4742 -> 4741;
4742 -> 1486;
4742 -> 1484;
4743 -> 1482;
4743 -> 1516;
4743 -> 1611;
4743 -> 4742;
4743 -> 1620;
4743 -> 1510;
4743 -> 1511;
4743 -> 4728;
4743 -> 1518;
4743 -> 1515;
4744 -> 1635;
4745 -> 4744;
4745 -> 1530;
4746 -> 4745;
4746 -> 1532;
4746 -> 1530;
4747 -> 1528;
4747 -> 1562;
4747 -> 1631;
4747 -> 4746;
4747 -> 1640;
4747 -> 1556;
4747 -> 1557;
4747 -> 4732;
4747 -> 1564;
4747 -> 1561;
4748 -> 1576;
4749 -> 4748;
4749 -> 1397;
4750 -> 4749;
4750 -> 1399;
4750 -> 1397;
4751 -> 1595;
4752 -> 4751;
4752 -> 1435;
4753 -> 4752;
4753 -> 1437;
4753 -> 1435;
4754 -> 1433;
4754 -> 1465;
4754 -> 1591;
4754 -> 4753;
4754 -> 1600;
4754 -> 1461;
4754 -> 1462;
4754 -> 4739;
4754 -> 1472;
4754 -> 1464;
4755 -> 1615;
4756 -> 4755;
4756 -> 1484;
4757 -> 4756;
4757 -> 1486;
4757 -> 1484;
4758 -> 1482;
4758 -> 1516;
4758 -> 1611;
4758 -> 4757;
4758 -> 1620;
4758 -> 1510;
4758 -> 1511;
4758 -> 4743;
4758 -> 1518;
4758 -> 1515;
4759 -> 1635;
4760 -> 4759;
4760 -> 1530;
4761 -> 4760;
4761 -> 1532;
4761 -> 1530;
4762 -> 1528;
4762 -> 1562;
4762 -> 1631;
4762 -> 4761;
4762 -> 1640;
4762 -> 1556;
4762 -> 1557;
4762 -> 4747;
4762 -> 1564;
4762 -> 1561;
4763 -> 1576;
4764 -> 4763;
4764 -> 1397;
4765 -> 4764;
4765 -> 1399;
4765 -> 1397;
4766 -> 1595;
4767 -> 4766;
4767 -> 1435;
4768 -> 4767;
4768 -> 1437;
4768 -> 1435;
4769 -> 1433;
4769 -> 1465;
4769 -> 1591;
4769 -> 4768;
4769 -> 1600;
4769 -> 1461;
4769 -> 1462;
4769 -> 4754;
4769 -> 1472;
4769 -> 1464;
4770 -> 1615;
4771 -> 4770;
4771 -> 1484;
4772 -> 4771;
4772 -> 1486;
4772 -> 1484;
4773 -> 1482;
4773 -> 1516;
4773 -> 1611;
4773 -> 4772;
4773 -> 1620;
4773 -> 1510;
4773 -> 1511;
4773 -> 4758;
4773 -> 1518;
4773 -> 1515;
4774 -> 1635;
4775 -> 4774;
4775 -> 1530;
4776 -> 4775;
4776 -> 1532;
4776 -> 1530;
4777 -> 1528;
4777 -> 1562;
4777 -> 1631;
4777 -> 4776;
4777 -> 1640;
4777 -> 1556;
4777 -> 1557;
4777 -> 4762;
4777 -> 1564;
4777 -> 1561;
4778 -> 1576;
4779 -> 4778;
4779 -> 1397;
4780 -> 4779;
4780 -> 1399;
4780 -> 1397;
4781 -> 1595;
4782 -> 4781;
4782 -> 1435;
4783 -> 4782;
4783 -> 1437;
4783 -> 1435;
4784 -> 1433;
4784 -> 1465;
4784 -> 1591;
4784 -> 4783;
4784 -> 1600;
4784 -> 1461;
4784 -> 1462;
4784 -> 4769;
4784 -> 1472;
4784 -> 1464;
4785 -> 1615;
4786 -> 4785;
4786 -> 1484;
4787 -> 4786;
4787 -> 1486;
4787 -> 1484;
4788 -> 1482;
4788 -> 1516;
4788 -> 1611;
4788 -> 4787;
4788 -> 1620;
4788 -> 1510;
4788 -> 1511;
4788 -> 4773;
4788 -> 1518;
4788 -> 1515;
4789 -> 1635;
4790 -> 4789;
4790 -> 1530;
4791 -> 4790;
4791 -> 1532;
4791 -> 1530;
4792 -> 1528;
4792 -> 1562;
4792 -> 1631;
4792 -> 4791;
4792 -> 1640;
4792 -> 1556;
4792 -> 1557;
4792 -> 4777;
4792 -> 1564;
4792 -> 1561;
4793 -> 1371;
4793 -> 1369;
4794 -> 1370;
4794 -> 1369;
4795 -> 1372;
4795 -> 1369;
4796 -> 1369;
4797 -> 4793;
4797 -> 4796;
4798 -> 4794;
4798 -> 4796;
4799 -> 4795;
4799 -> 4796;
4800 -> 4797;
4800 -> 1374;
4800 -> 4796;
4801 -> 4796;
4802 -> 4798;
4802 -> 4801;
4802 -> 4796;
4803 -> 4802;
4804 -> 4799;
4804 -> 4803;
4804 -> 4802;
4805 -> 4799;
4805 -> 408;
4805 -> 4804;
4806 -> 1386;
4806 -> 1385;
4806 -> 4797;
4806 -> 4805;
4807 -> 1350;
4808 -> 1354;
4808 -> 4807;
4808 -> 1350;
4809 -> 4806;
4809 -> 1350;
4810 -> 4809;
4810 -> 1118;
4811 -> 1118;
4812 -> 4810;
4812 -> 4811;
4813 -> 1107;
4813 -> 4811;
4814 -> 4811;
4815 -> 4812;
4815 -> 4814;
4815 -> 4811;
4816 -> 4813;
4816 -> 1078;
4816 -> 1114;
4816 -> 1113;
4816 -> 4811;
4817 -> 4813;
4817 -> 1114;
4817 -> 1113;
4817 -> 1078;
4817 -> 4811;
4818 -> 4812;
4818 -> 4817;
4818 -> 4811;
4819 -> 4813;
4819 -> 1078;
4819 -> 4811;
4820 -> 1118;
4821 -> 1118;
4822 -> 4809;
4822 -> 4821;
4823 -> 4822;
4823 -> 4821;
4824 -> 4823;
4824 -> 1118;
4825 -> 1358;
4826 -> 1358;
4827 -> 4826;
4827 -> 1358;
4828 -> 1358;
4829 -> 1358;
4830 -> 1358;
4831 -> 1358;
4832 -> 1358;
4833 -> 1358;
4834 -> 4828;
4834 -> 1358;
4835 -> 4829;
4835 -> 1358;
4836 -> 4830;
4836 -> 1358;
4837 -> 4831;
4837 -> 1358;
4838 -> 4833;
4838 -> 4827;
4838 -> 4834;
4838 -> 4835;
4838 -> 4836;
4838 -> 4837;
4838 -> 1358;
4839 -> 1358;
4840 -> 4838;
4840 -> 4839;
4840 -> 1358;
4841 -> 4832;
4841 -> 4838;
4841 -> 4840;
4842 -> 4840;
4843 -> 4841;
4843 -> 4842;
4844 -> 4842;
4845 -> 4843;
4845 -> 4841;
4845 -> 4844;
4846 -> 4845;
4846 -> 4842;
4847 -> 4842;
4848 -> 4843;
4848 -> 4841;
4848 -> 4847;
4849 -> 4848;
4849 -> 4842;
4850 -> 4842;
4851 -> 4849;
4851 -> 4850;
4852 -> 4843;
4852 -> 4841;
4852 -> 4850;
4853 -> 4842;
4854 -> 4842;
4855 -> 4843;
4855 -> 4854;
4856 -> 4855;
4856 -> 4841;
4856 -> 4851;
4856 -> 4854;
4857 -> 4854;
4858 -> 4855;
4858 -> 4856;
4858 -> 4857;
4859 -> 4858;
4859 -> 4854;
4860 -> 4854;
4861 -> 4860;
4861 -> 4854;
4862 -> 4854;
4863 -> 4854;
4864 -> 4856;
4864 -> 4854;
4865 -> 4856;
4866 -> 4856;
4866 -> 4854;
4867 -> 4866;
4868 -> 4854;
4869 -> 4856;
4869 -> 4854;
4870 -> 4854;
4871 -> 4869;
4871 -> 4870;
4872 -> 4870;
4873 -> 4870;
4874 -> 4871;
4874 -> 4873;
4874 -> 4870;
4875 -> 4874;
4876 -> 4872;
4876 -> 4870;
4877 -> 4876;
4877 -> 4854;
4878 -> 4854;
4879 -> 4877;
4879 -> 4878;
4880 -> 4855;
4880 -> 4878;
4881 -> 4878;
4882 -> 4880;
4882 -> 4856;
4882 -> 4881;
4882 -> 4878;
4883 -> 4882;
4884 -> 4883;
4884 -> 4854;
4885 -> 4854;
4886 -> 4856;
4886 -> 4854;
4887 -> 4884;
4887 -> 4854;
4888 -> 4855;
4888 -> 4854;
4889 -> 4886;
4889 -> 4856;
4889 -> 0;
4889 -> 4854;
4890 -> 4854;
4891 -> 4886;
4891 -> 4856;
4891 -> 4854;
4892 -> 4886;
4892 -> 4856;
4892 -> 4891;
4893 -> 4886;
4893 -> 4856;
4893 -> 4892;
4894 -> 4892;
4895 -> 4893;
4895 -> 4894;
4896 -> 4895;
4896 -> 0;
4896 -> 4894;
4897 -> 4856;
4897 -> 4892;
4898 -> 4886;
4898 -> 4856;
4898 -> 4892;
4899 -> 4892;
4900 -> 4897;
4900 -> 4899;
4901 -> 4898;
4901 -> 4899;
4902 -> 4897;
4902 -> 4899;
4903 -> 4901;
4903 -> 4899;
4904 -> 4900;
4904 -> 4899;
4905 -> 4902;
4905 -> 4899;
4906 -> 4899;
4907 -> 4903;
4907 -> 4906;
4908 -> 4904;
4908 -> 4906;
4909 -> 4905;
4909 -> 4906;
4910 -> 4907;
4910 -> 1374;
4910 -> 4906;
4911 -> 4906;
4912 -> 4908;
4912 -> 4911;
4912 -> 4906;
4913 -> 4912;
4914 -> 4909;
4914 -> 4913;
4914 -> 4912;
4915 -> 1378;
4915 -> 1377;
4915 -> 4907;
4915 -> 4914;
4916 -> 4854;
4917 -> 4887;
4917 -> 4916;
4917 -> 4854;
4918 -> 4915;
4918 -> 4854;
4919 -> 4918;
4919 -> 4842;
4920 -> 4846;
4920 -> 4919;
4920 -> 4842;
4921 -> 4919;
4921 -> 4842;
4922 -> 4828;
4922 -> 4840;
4923 -> 4829;
4923 -> 4840;
4924 -> 4830;
4924 -> 4840;
4925 -> 4831;
4925 -> 4840;
4926 -> 4921;
4926 -> 4840;
4927 -> 4921;
4927 -> 1358;
4928 -> 1358;
4928 -> 4927;
4928 -> 4926;
4929 -> 4928;
4929 -> 1118;
4930 -> 4929;
4930 -> 4811;
4931 -> 4930;
4931 -> 4814;
4931 -> 4811;
4932 -> 4813;
4932 -> 4819;
4932 -> 1114;
4932 -> 1113;
4932 -> 4811;
4933 -> 4813;
4933 -> 1114;
4933 -> 1113;
4933 -> 4819;
4933 -> 4811;
4934 -> 4930;
4934 -> 4933;
4934 -> 4811;
4935 -> 4928;
4935 -> 4821;
4936 -> 4935;
4936 -> 4928;
4936 -> 4821;
4937 -> 4936;
4937 -> 1118;
4938 -> 4928;
4939 -> 4928;
4940 -> 4939;
4940 -> 4928;
4941 -> 4928;
4942 -> 4941;
4942 -> 4928;
4943 -> 4941;
4943 -> 4928;
4944 -> 4943;
4944 -> 4928;
4945 -> 4928;
4946 -> 4928;
4947 -> 4928;
4948 -> 4928;
4949 -> 4948;
4950 -> 4928;
4951 -> 4941;
4952 -> 4941;
4953 -> 4941;
4953 -> 1018;
4954 -> 0;
4954 -> 4941;
4955 -> 4941;
4956 -> 4955;
4956 -> 4941;
4957 -> 0;
4957 -> 4956;
4958 -> 4941;
4958 -> 4957;
4958 -> 4954;
4959 -> 4958;
4959 -> 0;
4959 -> 4941;
4960 -> 0;
4960 -> 4941;
4960 -> 4959;
4961 -> 0;
4961 -> 4941;
4961 -> 4959;
4962 -> 4941;
4962 -> 4958;
4962 -> 4960;
4962 -> 0;
4963 -> 4941;
4963 -> 4958;
4963 -> 4960;
4963 -> 4961;
4963 -> 4928;
4964 -> 4941;
4964 -> 4928;
4965 -> 4928;
4966 -> 4964;
4966 -> 4965;
4967 -> 4965;
4968 -> 4965;
4969 -> 4966;
4969 -> 4968;
4969 -> 4965;
4970 -> 4969;
4971 -> 4970;
4971 -> 4966;
4971 -> 4963;
4971 -> 4969;
4972 -> 4967;
4972 -> 4965;
4973 -> 4972;
4973 -> 4928;
4974 -> 4928;
4975 -> 4973;
4975 -> 4974;
4976 -> 4928;
4976 -> 4974;
4977 -> 4974;
4978 -> 4976;
4978 -> 4963;
4978 -> 4977;
4978 -> 4974;
4979 -> 4978;
4980 -> 4979;
4980 -> 4928;
4981 -> 4928;
4982 -> 4928;
4983 -> 4982;
4983 -> 4928;
4984 -> 4963;
4984 -> 4928;
4985 -> 4963;
4986 -> 4963;
4986 -> 4928;
4987 -> 4986;
4988 -> 4980;
4988 -> 4928;
4989 -> 4928;
4990 -> 4963;
4990 -> 0;
4990 -> 4928;
4991 -> 4928;
4992 -> 4963;
4992 -> 4991;
4992 -> 4928;
4993 -> 4928;
4994 -> 4963;
4995 -> 4963;
4996 -> 4994;
4996 -> 4995;
4997 -> 4994;
4997 -> 4995;
4998 -> 4994;
4998 -> 4995;
4999 -> 4994;
4999 -> 4995;
5000 -> 4994;
5000 -> 4995;
5001 -> 4996;
5001 -> 4995;
5002 -> 4997;
5002 -> 4995;
5003 -> 4998;
5003 -> 4995;
5004 -> 4999;
5004 -> 4995;
5005 -> 5000;
5005 -> 4995;
5006 -> 4995;
5007 -> 5001;
5007 -> 5006;
5008 -> 5002;
5008 -> 5006;
5009 -> 5003;
5009 -> 5006;
5010 -> 5004;
5010 -> 5006;
5011 -> 5005;
5011 -> 5006;
5012 -> 5007;
5012 -> 0;
5012 -> 5006;
5013 -> 5010;
5013 -> 5009;
5013 -> 5006;
5014 -> 5012;
5014 -> 5013;
5014 -> 5006;
5015 -> 5008;
5015 -> 5014;
5016 -> 5009;
5016 -> 5014;
5017 -> 5011;
5017 -> 5014;
5018 -> 5014;
5019 -> 5015;
5019 -> 5018;
5020 -> 5016;
5020 -> 5018;
5021 -> 5017;
5021 -> 5018;
5022 -> 5018;
5023 -> 5019;
5023 -> 5022;
5023 -> 5018;
5024 -> 5023;
5025 -> 5021;
5025 -> 5024;
5025 -> 5023;
5026 -> 5020;
5026 -> 5025;
5027 -> 5025;
5028 -> 5026;
5028 -> 5027;
5030 -> 5028;
5030 -> 5027;
5031 -> 5027;
5032 -> 5027;
5033 -> 5030;
5033 -> 5032;
5034 -> 5031;
5034 -> 5032;
5035 -> 0;
5035 -> 5032;
5036 -> 5033;
5036 -> 5032;
5037 -> 5032;
5038 -> 5035;
5038 -> 5037;
5039 -> 5036;
5039 -> 5037;
5040 -> 5034;
5040 -> 5037;
5041 -> 5038;
5041 -> 5037;
5042 -> 5039;
5042 -> 5037;
5043 -> 5037;
5044 -> 5041;
5044 -> 5043;
5045 -> 5042;
5045 -> 5043;
5046 -> 5040;
5046 -> 5043;
5047 -> 5044;
5047 -> 5043;
5048 -> 5045;
5048 -> 5043;
5049 -> 5043;
5050 -> 5049;
5050 -> 5047;
5050 -> 5048;
5050 -> 5043;
5051 -> 5049;
5051 -> 5043;
5052 -> 5051;
5052 -> 5050;
5052 -> 5043;
5053 -> 5040;
5053 -> 5052;
5053 -> 0;
5053 -> 5037;
5054 -> 5053;
5054 -> 5040;
5054 -> 5037;
5055 -> 5034;
5055 -> 5032;
5056 -> 5033;
5056 -> 5034;
5056 -> 5032;
5057 -> 5031;
5057 -> 5025;
5058 -> 4928;
5059 -> 4988;
5059 -> 5058;
5059 -> 4928;
5060 -> 4940;
5060 -> 5057;
5060 -> 5052;
5060 -> 4928;
5061 -> 4928;
5061 -> 5057;
5061 -> 4963;
5061 -> 5052;
5061 -> 5054;
5061 -> 5055;
5061 -> 5056;
5062 -> 5061;
5062 -> 1118;
5063 -> 5062;
5063 -> 4811;
5064 -> 5063;
5064 -> 4814;
5064 -> 4811;
5065 -> 5063;
5065 -> 4933;
5065 -> 4811;
5066 -> 5061;
5066 -> 4821;
5067 -> 5066;
5067 -> 5061;
5067 -> 4821;
5068 -> 5067;
5068 -> 1118;
5069 -> 5061;
5070 -> 5061;
5071 -> 5070;
5071 -> 5061;
5072 -> 5061;
5073 -> 5061;
5074 -> 5073;
5074 -> 5061;
5075 -> 5061;
5076 -> 5061;
5077 -> 5061;
5078 -> 5061;
5079 -> 5078;
5080 -> 5061;
5081 -> 5061;
5082 -> 5061;
5083 -> 5081;
5083 -> 5082;
5084 -> 5082;
5085 -> 5082;
5086 -> 5083;
5086 -> 5085;
5086 -> 5082;
5087 -> 5086;
5088 -> 5084;
5088 -> 5082;
5089 -> 5088;
5089 -> 5061;
5090 -> 5061;
5091 -> 5089;
5091 -> 5090;
5092 -> 5061;
5092 -> 5090;
5093 -> 5090;
5094 -> 5092;
5094 -> 5061;
5094 -> 5093;
5094 -> 5090;
5095 -> 5094;
5096 -> 5095;
5096 -> 5061;
5097 -> 5061;
5098 -> 5061;
5099 -> 5097;
5099 -> 5098;
5100 -> 5098;
5101 -> 5099;
5101 -> 5070;
5101 -> 5100;
5101 -> 5098;
5102 -> 5101;
5102 -> 5061;
5103 -> 5061;
5104 -> 5070;
5104 -> 5103;
5104 -> 5061;
5105 -> 5070;
5105 -> 5061;
5106 -> 5070;
5107 -> 5070;
5107 -> 5061;
5108 -> 5107;
5109 -> 5096;
5109 -> 5061;
5110 -> 5061;
5111 -> 5061;
5111 -> 0;
5112 -> 5061;
5113 -> 5061;
5114 -> 5061;
5115 -> 5113;
5115 -> 5114;
5116 -> 5115;
5116 -> 0;
5116 -> 5114;
5117 -> 5070;
5117 -> 1374;
5117 -> 5061;
5118 -> 5070;
5118 -> 408;
5119 -> 1386;
5119 -> 1385;
5119 -> 5070;
5119 -> 5118;
5120 -> 5061;
5121 -> 5109;
5121 -> 5120;
5121 -> 5061;
5122 -> 5071;
5122 -> 5119;
5122 -> 5061;
5123 -> 5119;
5123 -> 1118;
5124 -> 5123;
5124 -> 4811;
5125 -> 5124;
5125 -> 4814;
5125 -> 4811;
5126 -> 5124;
5126 -> 4933;
5126 -> 4811;
5127 -> 5119;
5127 -> 4821;
5128 -> 5127;
5128 -> 5119;
5128 -> 4821;
5129 -> 5128;
5129 -> 1118;
5130 -> 5119;
5131 -> 5119;
5132 -> 5119;
5133 -> 5119;
5134 -> 5133;
5134 -> 5119;
5135 -> 5119;
5136 -> 5119;
5137 -> 5119;
5138 -> 5119;
5139 -> 5138;
5140 -> 5119;
5141 -> 5119;
5142 -> 5119;
5143 -> 5141;
5143 -> 5142;
5144 -> 5142;
5145 -> 5142;
5146 -> 5143;
5146 -> 5145;
5146 -> 5142;
5147 -> 5146;
5148 -> 5144;
5148 -> 5142;
5149 -> 5148;
5149 -> 5119;
5150 -> 5119;
5151 -> 5149;
5151 -> 5150;
5152 -> 5119;
5152 -> 5150;
5153 -> 5150;
5154 -> 5152;
5154 -> 5119;
5154 -> 5153;
5154 -> 5150;
5155 -> 5154;
5156 -> 5155;
5156 -> 5119;
5157 -> 5119;
5158 -> 5119;
5159 -> 5157;
5159 -> 5158;
5160 -> 5158;
5161 -> 5159;
5161 -> 5119;
5161 -> 5160;
5161 -> 5158;
5162 -> 5161;
5162 -> 5119;
5163 -> 5119;
5164 -> 5156;
5164 -> 5119;
5165 -> 5119;
5166 -> 5119;
5166 -> 0;
5167 -> 5119;
5168 -> 5119;
5169 -> 5119;
5170 -> 5168;
5170 -> 5169;
5171 -> 5170;
5171 -> 0;
5171 -> 5169;
5172 -> 5119;
5172 -> 1374;
5173 -> 5119;
5174 -> 5164;
5174 -> 5173;
5174 -> 5119;
5175 -> 5131;
5175 -> 5119;
5176 -> 5119;
5177 -> 5119;
5177 -> 1018;
5178 -> 0;
5178 -> 5119;
5179 -> 5119;
5179 -> 5178;
5180 -> 5178;
5181 -> 5179;
5181 -> 5180;
5182 -> 5181;
5182 -> 5180;
5183 -> 5182;
5184 -> 5119;
5184 -> 5178;
5184 -> 0;
5185 -> 5147;
5185 -> 5143;
5185 -> 5178;
5185 -> 5146;
5186 -> 5152;
5186 -> 5178;
5186 -> 5153;
5186 -> 5150;
5187 -> 5186;
5188 -> 5187;
5188 -> 5119;
5189 -> 5178;
5189 -> 5119;
5190 -> 5178;
5191 -> 5119;
5191 -> 5178;
5192 -> 5178;
5193 -> 5191;
5193 -> 5192;
5194 -> 5192;
5195 -> 5193;
5195 -> 5178;
5195 -> 5194;
5195 -> 5192;
5196 -> 5195;
5196 -> 5178;
5197 -> 5178;
5198 -> 5178;
5199 -> 5178;
5199 -> 5119;
5200 -> 5199;
5201 -> 5188;
5201 -> 5119;
5202 -> 5178;
5202 -> 0;
5202 -> 5119;
5203 -> 5178;
5204 -> 5178;
5205 -> 5203;
5205 -> 5204;
5206 -> 5205;
5206 -> 0;
5206 -> 5204;
5207 -> 5178;
5207 -> 1374;
5208 -> 5201;
5208 -> 5173;
5208 -> 5119;
5209 -> 5131;
5209 -> 5178;
5209 -> 5119;
5210 -> 5178;
5210 -> 1118;
5211 -> 5210;
5211 -> 4811;
5212 -> 5211;
5212 -> 4814;
5212 -> 4811;
5213 -> 5211;
5213 -> 4933;
5213 -> 4811;
5214 -> 5178;
5214 -> 4821;
5215 -> 5214;
5215 -> 5178;
5215 -> 4821;
5216 -> 5215;
5216 -> 1118;
5217 -> 5178;
5218 -> 5178;
5219 -> 5178;
5220 -> 5178;
5221 -> 5220;
5221 -> 5178;
5222 -> 5178;
5223 -> 5178;
5224 -> 5223;
5225 -> 5178;
5226 -> 5178;
5227 -> 5178;
5227 -> 1018;
5228 -> 5178;
5228 -> 0;
5229 -> 5178;
5230 -> 5178;
5231 -> 5229;
5231 -> 5230;
5232 -> 5230;
5233 -> 5230;
5234 -> 5231;
5234 -> 5233;
5234 -> 5230;
5235 -> 5234;
5236 -> 5232;
5236 -> 5230;
5237 -> 5236;
5237 -> 5178;
5238 -> 5178;
5239 -> 5237;
5239 -> 5238;
5240 -> 5178;
5240 -> 5238;
5241 -> 5238;
5242 -> 5240;
5242 -> 5178;
5242 -> 5241;
5242 -> 5238;
5243 -> 5242;
5244 -> 5243;
5244 -> 5178;
5245 -> 5244;
5245 -> 5178;
5246 -> 5178;
5247 -> 5178;
5247 -> 0;
5248 -> 5178;
5249 -> 5178;
5250 -> 5178;
5251 -> 5245;
5251 -> 5250;
5251 -> 5178;
5252 -> 5218;
5252 -> 5178;
5253 -> 5178;
5254 -> 5253;
5254 -> 5192;
5255 -> 5254;
5255 -> 5178;
5255 -> 5194;
5255 -> 5192;
5256 -> 5255;
5256 -> 5178;
5257 -> 5178;
5258 -> 5257;
5258 -> 5178;
5259 -> 5258;
5260 -> 5259;
5260 -> 5178;
5261 -> 956;
5261 -> 5260;
5262 -> 5261;
5263 -> 5261;
5263 -> 5262;
5264 -> 5262;
5265 -> 5263;
5265 -> 5264;
5266 -> 5264;
5267 -> 5265;
5267 -> 5266;
5267 -> 5264;
5268 -> 5265;
5268 -> 5264;
5269 -> 5261;
5269 -> 5267;
5270 -> 5267;
5271 -> 5269;
5271 -> 5270;
5272 -> 5270;
5273 -> 5271;
5273 -> 5272;
5273 -> 5270;
5274 -> 5261;
5274 -> 5178;
5275 -> 5274;
5276 -> 5214;
5276 -> 4821;
5277 -> 5276;
5277 -> 1118;
5278 -> 5257;
5278 -> 5178;
5279 -> 5257;
5279 -> 5178;
5280 -> 5279;
5280 -> 5178;
5281 -> 5257;
5282 -> 5257;
5283 -> 5282;
5284 -> 5283;
5284 -> 5257;
5285 -> 956;
5285 -> 5284;
5286 -> 5257;
5287 -> 5286;
5287 -> 5285;
5287 -> 5257;
5288 -> 5257;
5289 -> 5286;
5289 -> 5288;
5290 -> 5289;
5290 -> 5285;
5290 -> 5288;
5291 -> 5290;
5291 -> 5257;
5292 -> 0;
5294 -> 5292;
5294 -> 5293;
5295 -> 5293;
5296 -> 5294;
5296 -> 5295;
5296 -> 5293;
5297 -> 5293;
5300 -> 5298;
5300 -> 5299;
5301 -> 5299;
5302 -> 5300;
5302 -> 5301;
5302 -> 5299;
5303 -> 5299;
5304 -> 5257;
5305 -> 5304;
5305 -> 5291;
5305 -> 5257;
5306 -> 5257;
5307 -> 5305;
5307 -> 5306;
5308 -> 5307;
5308 -> 5306;
5309 -> 5306;
5310 -> 5308;
5310 -> 5309;
5310 -> 5306;
5311 -> 5308;
5311 -> 5306;
5312 -> 5257;
5313 -> 5311;
5313 -> 5312;
5313 -> 5257;
5314 -> 5257;
5315 -> 5314;
5315 -> 5313;
5315 -> 5257;
5316 -> 5257;
5317 -> 5315;
5317 -> 5316;
5318 -> 5316;
5319 -> 5317;
5319 -> 5318;
5319 -> 5316;
5320 -> 5257;
5321 -> 5317;
5321 -> 5320;
5321 -> 5257;
5322 -> 5257;
5322 -> 5178;
5323 -> 5322;
5323 -> 5230;
5324 -> 5323;
5324 -> 5233;
5324 -> 5230;
5325 -> 5324;
5326 -> 5325;
5326 -> 5323;
5326 -> 5321;
5326 -> 5324;
5327 -> 5240;
5327 -> 5321;
5327 -> 5241;
5327 -> 5238;
5328 -> 5327;
5329 -> 5328;
5329 -> 5178;
5330 -> 5321;
5331 -> 5321;
5331 -> 5330;
5332 -> 5330;
5333 -> 5331;
5333 -> 5332;
5334 -> 5332;
5335 -> 5333;
5335 -> 5334;
5335 -> 5332;
5336 -> 5333;
5336 -> 5332;
5337 -> 5321;
5337 -> 5335;
5338 -> 5335;
5339 -> 5337;
5339 -> 5338;
5340 -> 5338;
5341 -> 5339;
5341 -> 5340;
5341 -> 5338;
5342 -> 5321;
5342 -> 5178;
5343 -> 5342;
5344 -> 5329;
5344 -> 5178;
5345 -> 5321;
5345 -> 0;
5345 -> 5178;
5346 -> 5321;
5347 -> 5321;
5348 -> 5346;
5348 -> 5347;
5349 -> 5346;
5349 -> 5347;
5350 -> 5346;
5350 -> 5347;
5351 -> 5349;
5351 -> 1374;
5351 -> 5347;
5352 -> 5344;
5352 -> 5250;
5352 -> 5178;
5353 -> 5349;
5353 -> 1118;
5354 -> 5353;
5354 -> 4811;
5355 -> 5354;
5355 -> 4814;
5355 -> 4811;
5356 -> 5354;
5356 -> 4933;
5356 -> 4811;
5357 -> 5349;
5357 -> 4821;
5358 -> 5357;
5358 -> 4821;
5359 -> 5358;
5359 -> 1118;
5360 -> 1105;
5361 -> 1042;
5362 -> 5361;
5362 -> 1048;
5362 -> 1042;
5363 -> 1048;
5363 -> 1042;
5364 -> 1048;
5364 -> 1042;
5365 -> 1048;
5365 -> 1042;
5366 -> 1048;
5366 -> 1042;
5367 -> 1048;
5367 -> 1042;
5368 -> 1048;
5368 -> 1042;
5369 -> 1042;
5370 -> 5369;
5370 -> 1048;
5370 -> 1042;
5371 -> 1048;
5371 -> 5370;
5371 -> 1042;
5372 -> 1042;
5373 -> 5372;
5373 -> 1048;
5373 -> 1042;
5374 -> 1041;
5374 -> 890;
5375 -> 890;
5376 -> 5374;
5376 -> 5375;
5377 -> 5376;
5377 -> 5375;
5378 -> 0;
5378 -> 5375;
5379 -> 5375;
5380 -> 5377;
5380 -> 5379;
5381 -> 5378;
5381 -> 5379;
5382 -> 5376;
5382 -> 5379;
5383 -> 5379;
5384 -> 5382;
5384 -> 5365;
5384 -> 5383;
5384 -> 5379;
5385 -> 5380;
5385 -> 5377;
5385 -> 1082;
5385 -> 1090;
5385 -> 1084;
5385 -> 1083;
5385 -> 1073;
5385 -> 1114;
5385 -> 1075;
5385 -> 1076;
5385 -> 1077;
5385 -> 4819;
5385 -> 1079;
5385 -> 1080;
5385 -> 1081;
5385 -> 1085;
5385 -> 1087;
5385 -> 1097;
5385 -> 5362;
5385 -> 5370;
5385 -> 5373;
5385 -> 5365;
5385 -> 5366;
5385 -> 5367;
5385 -> 5368;
5385 -> 5321;
5385 -> 1041;
5385 -> 1086;
5385 -> 1096;
5385 -> 1113;
5385 -> 5361;
5385 -> 5371;
5385 -> 5379;
5386 -> 5379;
5387 -> 5385;
5387 -> 5386;
5388 -> 5386;
5389 -> 5387;
5389 -> 5388;
5390 -> 5389;
5390 -> 5385;
5390 -> 5388;
5391 -> 5389;
5391 -> 5390;
5391 -> 5388;
5392 -> 5389;
5392 -> 5390;
5392 -> 0;
5392 -> 5388;
5393 -> 5392;
5393 -> 5389;
5393 -> 5388;
5394 -> 5388;
5395 -> 5389;
5395 -> 5394;
5396 -> 5394;
5397 -> 5395;
5397 -> 5396;
5398 -> 5396;
5399 -> 5397;
5399 -> 5398;
5400 -> 5399;
5400 -> 5390;
5400 -> 5398;
5401 -> 5398;
5402 -> 5399;
5402 -> 5390;
5402 -> 5401;
5402 -> 5398;
5403 -> 5399;
5403 -> 5390;
5403 -> 5393;
5403 -> 5402;
5404 -> 5403;
5404 -> 5396;
5405 -> 5404;
5405 -> 5397;
5405 -> 5396;
5406 -> 5405;
5406 -> 5394;
5407 -> 5394;
5408 -> 5406;
5408 -> 5407;
5409 -> 5408;
5409 -> 5390;
5409 -> 5407;
5410 -> 5409;
5410 -> 5388;
5411 -> 5391;
5411 -> 5389;
5411 -> 5388;
5412 -> 5390;
5412 -> 5393;
5412 -> 5411;
5412 -> 5405;
5412 -> 5388;
5413 -> 5390;
5413 -> 5388;
5414 -> 5389;
5414 -> 5412;
5414 -> 5413;
5414 -> 5388;
5415 -> 5386;
5416 -> 5415;
5416 -> 5386;
5417 -> 5386;
5418 -> 5412;
5418 -> 5417;
5419 -> 5416;
5419 -> 5417;
5420 -> 5387;
5420 -> 5417;
5421 -> 5418;
5421 -> 5417;
5422 -> 5419;
5422 -> 5417;
5423 -> 5417;
5424 -> 5421;
5424 -> 5423;
5425 -> 5422;
5425 -> 5423;
5426 -> 5420;
5426 -> 5423;
5427 -> 5423;
5428 -> 5426;
5428 -> 5427;
5429 -> 5427;
5430 -> 5428;
5430 -> 5429;
5431 -> 5430;
5431 -> 5414;
5431 -> 5429;
5432 -> 5431;
5432 -> 5427;
5433 -> 5432;
5434 -> 5433;
5434 -> 5423;
5435 -> 5434;
5435 -> 5417;
5436 -> 5417;
5437 -> 5420;
5437 -> 5436;
5438 -> 5436;
5439 -> 5437;
5439 -> 5438;
5440 -> 5438;
5441 -> 5439;
5441 -> 5440;
5442 -> 5441;
5442 -> 5414;
5442 -> 5440;
5443 -> 5442;
5443 -> 5438;
5444 -> 5438;
5445 -> 5439;
5445 -> 5414;
5445 -> 5444;
5445 -> 5438;
5446 -> 5443;
5446 -> 5439;
5446 -> 5445;
5447 -> 5439;
5447 -> 5414;
5447 -> 5438;
5448 -> 5439;
5448 -> 5414;
5448 -> 5447;
5448 -> 5438;
5449 -> 5439;
5449 -> 5414;
5449 -> 5438;
5450 -> 5443;
5450 -> 5438;
5451 -> 5448;
5451 -> 5449;
5451 -> 5450;
5451 -> 5414;
5451 -> 5446;
5451 -> 5447;
5451 -> 5438;
5452 -> 5451;
5452 -> 5436;
5453 -> 5437;
5453 -> 5451;
5453 -> 5436;
5454 -> 5436;
5455 -> 5436;
5456 -> 5452;
5456 -> 5455;
5457 -> 5453;
5457 -> 5455;
5458 -> 5453;
5458 -> 5455;
5459 -> 5453;
5459 -> 5455;
5460 -> 5453;
5460 -> 5455;
5461 -> 5454;
5461 -> 5455;
5462 -> 5456;
5462 -> 5461;
5462 -> 5455;
5463 -> 5457;
5463 -> 5461;
5463 -> 5455;
5464 -> 5458;
5464 -> 5461;
5464 -> 5455;
5465 -> 5459;
5465 -> 5461;
5465 -> 5455;
5466 -> 5460;
5466 -> 5461;
5466 -> 5455;
5467 -> 5454;
5467 -> 5417;
5468 -> 5420;
5468 -> 5451;
5468 -> 5417;
5469 -> 5420;
5469 -> 5451;
5469 -> 5468;
5469 -> 5417;
5470 -> 5417;
5471 -> 5417;
5472 -> 5420;
5472 -> 5471;
5473 -> 5472;
5473 -> 5451;
5473 -> 5471;
5474 -> 5473;
5474 -> 5417;
5475 -> 5417;
5476 -> 5474;
5476 -> 5475;
5477 -> 5476;
5477 -> 5451;
5477 -> 5475;
5478 -> 5418;
5478 -> 5477;
5479 -> 5477;
5480 -> 5478;
5480 -> 5479;
5481 -> 5420;
5481 -> 5479;
5482 -> 5479;
5483 -> 5481;
5483 -> 5482;
5484 -> 5483;
5484 -> 5479;
5485 -> 5479;
5486 -> 5484;
5486 -> 5485;
5487 -> 0;
5487 -> 5479;
5488 -> 5479;
5489 -> 5487;
5489 -> 5488;
5490 -> 5481;
5490 -> 5488;
5491 -> 5489;
5491 -> 5488;
5492 -> 5488;
5493 -> 5491;
5493 -> 5492;
5494 -> 5493;
5494 -> 0;
5494 -> 5492;
5495 -> 5494;
5496 -> 5488;
5497 -> 5490;
5497 -> 5496;
5498 -> 5497;
5498 -> 5488;
5499 -> 5488;
5500 -> 5498;
5500 -> 5499;
5501 -> 5500;
5501 -> 5488;
5502 -> 5501;
5502 -> 5489;
5502 -> 5488;
5503 -> 5502;
5504 -> 5490;
5504 -> 5503;
5505 -> 5503;
5506 -> 5504;
5506 -> 5451;
5506 -> 5505;
5507 -> 5506;
5507 -> 5451;
5507 -> 5505;
5508 -> 5507;
5508 -> 5503;
5509 -> 5508;
5509 -> 5504;
5509 -> 5503;
5510 -> 5503;
5511 -> 5510;
5511 -> 5504;
5511 -> 5503;
5512 -> 5503;
5513 -> 5504;
5513 -> 5451;
5513 -> 5512;
5513 -> 5503;
5514 -> 5504;
5514 -> 5451;
5514 -> 5503;
5515 -> 5502;
5516 -> 5498;
5516 -> 5502;
5517 -> 5479;
5518 -> 5481;
5518 -> 5517;
5519 -> 0;
5519 -> 5517;
5520 -> 5517;
5521 -> 5519;
5521 -> 5520;
5522 -> 5518;
5522 -> 5520;
5523 -> 5522;
5523 -> 5451;
5523 -> 5468;
5523 -> 5520;
5524 -> 5522;
5524 -> 5451;
5524 -> 5468;
5524 -> 5523;
5524 -> 5520;
5525 -> 5521;
5525 -> 5520;
5526 -> 5520;
5527 -> 5525;
5527 -> 5526;
5528 -> 5522;
5528 -> 5526;
5529 -> 5526;
5530 -> 5526;
5531 -> 5526;
5532 -> 5528;
5532 -> 5531;
5533 -> 5532;
5533 -> 5451;
5533 -> 5514;
5533 -> 5531;
5534 -> 5532;
5534 -> 5451;
5534 -> 5468;
5534 -> 5523;
5534 -> 5509;
5534 -> 5511;
5534 -> 5514;
5535 -> 5534;
5535 -> 5526;
5536 -> 5526;
5537 -> 5535;
5537 -> 5536;
5538 -> 5537;
5538 -> 5526;
5539 -> 5526;
5540 -> 5538;
5540 -> 5539;
5541 -> 5540;
5541 -> 5539;
5542 -> 5541;
5543 -> 5537;
5543 -> 5526;
5544 -> 5526;
5545 -> 5543;
5545 -> 5544;
5546 -> 5545;
5546 -> 5544;
5547 -> 5544;
5548 -> 5546;
5548 -> 5547;
5549 -> 5548;
5549 -> 5547;
5550 -> 5547;
5551 -> 5549;
5551 -> 5550;
5552 -> 5551;
5552 -> 5550;
5553 -> 0;
5553 -> 5552;
5554 -> 5537;
5554 -> 0;
5554 -> 5553;
5555 -> 5554;
5556 -> 5528;
5556 -> 5555;
5557 -> 5555;
5558 -> 5556;
5558 -> 5557;
5559 -> 5558;
5559 -> 5555;
5560 -> 5555;
5561 -> 5559;
5561 -> 5560;
5562 -> 5560;
5563 -> 5561;
5563 -> 5562;
5564 -> 5563;
5564 -> 5560;
5565 -> 5555;
5566 -> 5565;
5566 -> 5554;
5567 -> 5566;
5568 -> 5566;
5569 -> 5567;
5569 -> 5568;
5570 -> 5567;
5570 -> 5568;
5571 -> 5528;
5571 -> 5568;
5572 -> 5568;
5573 -> 5571;
5573 -> 5572;
5574 -> 5573;
5574 -> 5568;
5575 -> 5568;
5576 -> 5574;
5576 -> 5575;
5577 -> 5575;
5578 -> 5576;
5578 -> 5577;
5579 -> 5578;
5579 -> 5575;
5580 -> 5568;
5581 -> 5580;
5581 -> 5566;
5582 -> 5581;
5583 -> 5582;
5583 -> 5581;
5584 -> 5581;
5585 -> 5583;
5585 -> 5584;
5586 -> 5584;
5587 -> 5585;
5587 -> 5586;
5588 -> 5587;
5588 -> 5584;
5589 -> 5537;
5589 -> 0;
5589 -> 5588;
5590 -> 5527;
5590 -> 5589;
5591 -> 5589;
5592 -> 5590;
5592 -> 5591;
5593 -> 5528;
5593 -> 5591;
5594 -> 5592;
5594 -> 0;
5594 -> 5591;
5595 -> 5591;
5596 -> 5593;
5596 -> 5595;
5597 -> 5596;
5597 -> 5591;
5598 -> 5591;
5599 -> 5597;
5599 -> 5598;
5600 -> 5598;
5601 -> 5599;
5601 -> 5600;
5602 -> 5601;
5602 -> 5598;
5603 -> 5591;
5604 -> 5593;
5604 -> 5603;
5605 -> 5604;
5605 -> 5591;
5606 -> 5591;
5607 -> 5605;
5607 -> 5606;
5608 -> 5591;
5609 -> 5607;
5609 -> 5608;
5610 -> 5609;
5610 -> 5608;
5611 -> 5608;
5612 -> 5610;
5612 -> 5611;
5613 -> 5612;
5613 -> 5611;
5614 -> 5613;
5615 -> 5602;
5615 -> 5614;
5615 -> 5591;
5616 -> 5594;
5616 -> 5615;
5616 -> 5591;
5617 -> 5616;
5618 -> 5527;
5618 -> 5617;
5619 -> 5617;
5620 -> 5618;
5620 -> 5619;
5621 -> 5528;
5621 -> 5619;
5622 -> 5620;
5622 -> 5619;
5623 -> 5619;
5624 -> 5622;
5624 -> 5623;
5625 -> 5621;
5625 -> 5623;
5626 -> 5623;
5627 -> 5625;
5627 -> 5626;
5628 -> 5627;
5628 -> 5623;
5629 -> 5623;
5630 -> 5628;
5630 -> 5629;
5631 -> 5630;
5631 -> 5623;
5632 -> 5624;
5632 -> 5631;
5633 -> 5631;
5634 -> 5632;
5634 -> 5633;
5635 -> 5625;
5635 -> 5633;
5636 -> 5633;
5637 -> 5635;
5637 -> 5636;
5638 -> 5637;
5638 -> 5633;
5639 -> 5633;
5640 -> 5638;
5640 -> 5639;
5641 -> 5633;
5642 -> 5635;
5642 -> 5641;
5643 -> 5642;
5643 -> 5641;
5644 -> 5641;
5645 -> 5641;
5646 -> 5643;
5646 -> 5645;
5647 -> 5643;
5647 -> 5645;
5648 -> 5643;
5648 -> 5645;
5649 -> 5643;
5649 -> 5645;
5650 -> 5643;
5650 -> 5645;
5651 -> 5644;
5651 -> 5645;
5652 -> 5646;
5652 -> 5651;
5652 -> 5645;
5653 -> 5647;
5653 -> 5651;
5653 -> 5645;
5654 -> 5648;
5654 -> 5651;
5654 -> 5645;
5655 -> 5649;
5655 -> 5651;
5655 -> 5645;
5656 -> 5650;
5656 -> 5651;
5656 -> 5645;
5657 -> 5644;
5657 -> 5633;
5658 -> 5634;
5658 -> 5633;
5659 -> 5633;
5660 -> 5658;
5660 -> 5659;
5661 -> 5635;
5661 -> 5659;
5662 -> 5660;
5662 -> 0;
5662 -> 5659;
5663 -> 5659;
5664 -> 5659;
5665 -> 5663;
5665 -> 5664;
5666 -> 5661;
5666 -> 5664;
5667 -> 5664;
5668 -> 5665;
5668 -> 5667;
5668 -> 5664;
5669 -> 5666;
5669 -> 5642;
5669 -> 5665;
5669 -> 5664;
5670 -> 5664;
5671 -> 5666;
5671 -> 5642;
5671 -> 5670;
5671 -> 5664;
5672 -> 5666;
5672 -> 5642;
5672 -> 5665;
5672 -> 5671;
5673 -> 5659;
5674 -> 5672;
5674 -> 5673;
5675 -> 5659;
5676 -> 5661;
5676 -> 5675;
5677 -> 5676;
5677 -> 5642;
5677 -> 5675;
5678 -> 5677;
5678 -> 5659;
5679 -> 5674;
5679 -> 5678;
5679 -> 5659;
5680 -> 5659;
5681 -> 5663;
5681 -> 5680;
5682 -> 5661;
5682 -> 5680;
5683 -> 5680;
5684 -> 5681;
5684 -> 5683;
5684 -> 5680;
5685 -> 5682;
5685 -> 5642;
5685 -> 5681;
5685 -> 5680;
5686 -> 5680;
5687 -> 5682;
5687 -> 5642;
5687 -> 5686;
5687 -> 5680;
5688 -> 5682;
5688 -> 5642;
5688 -> 5681;
5688 -> 5687;
5689 -> 5659;
5690 -> 5688;
5690 -> 5689;
5691 -> 5679;
5691 -> 5690;
5691 -> 5659;
5692 -> 5659;
5693 -> 5659;
5694 -> 5692;
5694 -> 5693;
5695 -> 5661;
5695 -> 5693;
5696 -> 5693;
5697 -> 5694;
5697 -> 5696;
5697 -> 5693;
5698 -> 5695;
5698 -> 5642;
5698 -> 5694;
5698 -> 5693;
5699 -> 5693;
5700 -> 5695;
5700 -> 5642;
5700 -> 5699;
5700 -> 5693;
5701 -> 5695;
5701 -> 5642;
5701 -> 5694;
5701 -> 5700;
5702 -> 5659;
5703 -> 5701;
5703 -> 5702;
5704 -> 5661;
5704 -> 5702;
5705 -> 5702;
5706 -> 5703;
5706 -> 5705;
5707 -> 5706;
5707 -> 5702;
5708 -> 5702;
5709 -> 5704;
5709 -> 5708;
5710 -> 5709;
5710 -> 5642;
5710 -> 5708;
5711 -> 5710;
5711 -> 5702;
5712 -> 5707;
5712 -> 5711;
5712 -> 5702;
5713 -> 5659;
5714 -> 5692;
5714 -> 5713;
5715 -> 5661;
5715 -> 5713;
5716 -> 5713;
5717 -> 5714;
5717 -> 5716;
5717 -> 5713;
5718 -> 5715;
5718 -> 5642;
5718 -> 5714;
5718 -> 5713;
5719 -> 5713;
5720 -> 5715;
5720 -> 5642;
5720 -> 5719;
5720 -> 5713;
5721 -> 5715;
5721 -> 5642;
5721 -> 5714;
5721 -> 5720;
5722 -> 5659;
5723 -> 5721;
5723 -> 5722;
5724 -> 5712;
5724 -> 5723;
5724 -> 5659;
5725 -> 5659;
5726 -> 5692;
5726 -> 5725;
5727 -> 5661;
5727 -> 5725;
5728 -> 5725;
5729 -> 5726;
5729 -> 5728;
5729 -> 5725;
5730 -> 5727;
5730 -> 5642;
5730 -> 5726;
5730 -> 5725;
5731 -> 5725;
5732 -> 5727;
5732 -> 5642;
5732 -> 5731;
5732 -> 5725;
5733 -> 5727;
5733 -> 5642;
5733 -> 5726;
5733 -> 5732;
5734 -> 5659;
5735 -> 5733;
5735 -> 5734;
5736 -> 5724;
5736 -> 5735;
5736 -> 5659;
5737 -> 5659;
5738 -> 5659;
5739 -> 5737;
5739 -> 5738;
5740 -> 5661;
5740 -> 5738;
5741 -> 5738;
5742 -> 5739;
5742 -> 5741;
5742 -> 5738;
5743 -> 5740;
5743 -> 5642;
5743 -> 5739;
5743 -> 5738;
5744 -> 5738;
5745 -> 5740;
5745 -> 5642;
5745 -> 5744;
5745 -> 5738;
5746 -> 5740;
5746 -> 5642;
5746 -> 5739;
5746 -> 5745;
5747 -> 5659;
5748 -> 5746;
5748 -> 5747;
5749 -> 5659;
5750 -> 5659;
5751 -> 5749;
5751 -> 5750;
5752 -> 5661;
5752 -> 5750;
5753 -> 5750;
5754 -> 5751;
5754 -> 5753;
5754 -> 5750;
5755 -> 5752;
5755 -> 5642;
5755 -> 5751;
5755 -> 5750;
5756 -> 5750;
5757 -> 5752;
5757 -> 5642;
5757 -> 5756;
5757 -> 5750;
5758 -> 5752;
5758 -> 5642;
5758 -> 5751;
5758 -> 5757;
5759 -> 5659;
5760 -> 5758;
5760 -> 5759;
5761 -> 5659;
5762 -> 5761;
5762 -> 5633;
5763 -> 5633;
5764 -> 5633;
5765 -> 5763;
5765 -> 5764;
5766 -> 5635;
5766 -> 5764;
5767 -> 5764;
5768 -> 5766;
5768 -> 5767;
5769 -> 5768;
5769 -> 5642;
5769 -> 5767;
5770 -> 5769;
5770 -> 5764;
5771 -> 5764;
5772 -> 5770;
5772 -> 5771;
5773 -> 5764;
5774 -> 5766;
5774 -> 5773;
5775 -> 5773;
5776 -> 5774;
5776 -> 5775;
5777 -> 5776;
5777 -> 5642;
5777 -> 5775;
5778 -> 5777;
5778 -> 5773;
5779 -> 5773;
5780 -> 5774;
5780 -> 5779;
5781 -> 5780;
5781 -> 5642;
5781 -> 5779;
5782 -> 5779;
5783 -> 5782;
5783 -> 5780;
5783 -> 5779;
5784 -> 5779;
5785 -> 5780;
5785 -> 5642;
5785 -> 5784;
5785 -> 5779;
5786 -> 5780;
5786 -> 5642;
5786 -> 5779;
5787 -> 5773;
5788 -> 5778;
5788 -> 5773;
5789 -> 5788;
5789 -> 5764;
5790 -> 5765;
5790 -> 5764;
5791 -> 5764;
5792 -> 5790;
5792 -> 5791;
5793 -> 5766;
5793 -> 5791;
5794 -> 5791;
5795 -> 5792;
5795 -> 5791;
5796 -> 5791;
5797 -> 5794;
5797 -> 5796;
5798 -> 5795;
5798 -> 5796;
5799 -> 5793;
5799 -> 5796;
5800 -> 5798;
5800 -> 5796;
5801 -> 0;
5801 -> 5800;
5802 -> 5797;
5802 -> 5796;
5803 -> 5801;
5803 -> 5802;
5803 -> 5799;
5803 -> 5642;
5803 -> 5783;
5803 -> 5780;
5803 -> 5786;
5803 -> 5796;
5804 -> 5796;
5805 -> 5803;
5805 -> 5804;
5806 -> 5803;
5806 -> 5804;
5807 -> 5803;
5807 -> 5804;
5808 -> 5804;
5809 -> 5806;
5809 -> 5808;
5809 -> 5804;
5810 -> 5807;
5810 -> 5803;
5810 -> 5806;
5810 -> 5804;
5811 -> 5804;
5812 -> 5807;
5812 -> 5803;
5812 -> 5811;
5812 -> 5804;
5813 -> 5807;
5813 -> 5803;
5813 -> 5806;
5813 -> 5812;
5814 -> 5803;
5814 -> 5804;
5815 -> 5803;
5815 -> 5804;
5816 -> 5804;
5817 -> 5815;
5817 -> 5816;
5818 -> 5817;
5818 -> 5813;
5818 -> 5816;
5819 -> 5818;
5819 -> 5804;
5820 -> 5804;
5821 -> 5819;
5821 -> 5820;
5822 -> 5804;
5823 -> 5815;
5823 -> 5822;
5824 -> 5822;
5825 -> 5823;
5825 -> 5824;
5826 -> 5825;
5826 -> 5813;
5826 -> 5824;
5827 -> 5826;
5827 -> 5822;
5828 -> 5822;
5829 -> 5827;
5829 -> 5828;
5830 -> 5829;
5831 -> 5823;
5831 -> 5830;
5832 -> 5830;
5833 -> 5831;
5833 -> 5832;
5834 -> 5833;
5834 -> 5830;
5835 -> 5830;
5836 -> 5834;
5836 -> 5835;
5837 -> 5830;
5838 -> 5837;
5838 -> 5829;
5839 -> 5829;
5840 -> 5823;
5840 -> 5839;
5841 -> 5839;
5842 -> 5840;
5842 -> 5841;
5843 -> 5842;
5843 -> 5813;
5843 -> 5841;
5844 -> 5843;
5844 -> 5839;
5845 -> 5844;
5845 -> 5829;
5846 -> 5838;
5846 -> 5845;
5846 -> 5829;
5847 -> 5829;
5848 -> 5823;
5848 -> 5847;
5849 -> 5847;
5850 -> 5848;
5850 -> 5849;
5851 -> 5850;
5851 -> 5847;
5852 -> 5847;
5853 -> 5851;
5853 -> 5852;
5854 -> 5853;
5854 -> 5829;
5855 -> 5846;
5855 -> 5854;
5855 -> 5829;
5856 -> 5855;
5857 -> 5856;
5857 -> 5804;
5858 -> 5821;
5858 -> 5857;
5858 -> 5804;
5859 -> 5804;
5860 -> 5815;
5860 -> 5859;
5861 -> 5859;
5862 -> 5860;
5862 -> 5861;
5863 -> 5862;
5863 -> 5813;
5863 -> 5861;
5864 -> 5863;
5864 -> 5859;
5865 -> 5859;
5866 -> 5860;
5866 -> 5813;
5866 -> 5865;
5867 -> 5865;
5868 -> 5865;
5869 -> 5860;
5869 -> 5813;
5869 -> 5868;
5869 -> 5865;
5870 -> 5860;
5870 -> 5813;
5870 -> 5865;
5871 -> 5859;
5872 -> 5864;
5872 -> 5859;
5873 -> 5872;
5873 -> 5804;
5874 -> 5804;
5875 -> 5815;
5875 -> 5874;
5876 -> 5875;
5876 -> 5813;
5876 -> 5870;
5876 -> 5874;
5877 -> 5875;
5877 -> 5813;
5877 -> 5874;
5878 -> 5875;
5878 -> 5813;
5878 -> 5860;
5878 -> 5870;
5878 -> 5877;
5879 -> 5878;
5879 -> 5804;
5880 -> 5804;
5881 -> 5879;
5881 -> 5880;
5882 -> 0;
5882 -> 5881;
5883 -> 5873;
5883 -> 5882;
5883 -> 5813;
5883 -> 5860;
5883 -> 5878;
5883 -> 5870;
5883 -> 5796;
5884 -> 5873;
5884 -> 5804;
5885 -> 5804;
5886 -> 5884;
5886 -> 5885;
5887 -> 5886;
5887 -> 5883;
5887 -> 5885;
5888 -> 5887;
5888 -> 5804;
5889 -> 5804;
5890 -> 5888;
5890 -> 5889;
5891 -> 5804;
5892 -> 5884;
5892 -> 5891;
5893 -> 5892;
5893 -> 5883;
5893 -> 5891;
5894 -> 5893;
5894 -> 5804;
5895 -> 5804;
5896 -> 5894;
5896 -> 5895;
5897 -> 5890;
5897 -> 5896;
5897 -> 5804;
5898 -> 5873;
5898 -> 5804;
5899 -> 5873;
5899 -> 5804;
5900 -> 5873;
5900 -> 5804;
5901 -> 5804;
5902 -> 5900;
5902 -> 5901;
5903 -> 5902;
5903 -> 5897;
5903 -> 5901;
5904 -> 5903;
5904 -> 5804;
5905 -> 5904;
5905 -> 5898;
5905 -> 5804;
5906 -> 5904;
5906 -> 5905;
5907 -> 5905;
5908 -> 5906;
5908 -> 5907;
5908 -> 5796;
5909 -> 5799;
5909 -> 5801;
5909 -> 5802;
5909 -> 5803;
5909 -> 5813;
5909 -> 5882;
5909 -> 5897;
5909 -> 5907;
5909 -> 5906;
5909 -> 5796;
5910 -> 5909;
5910 -> 0;
5910 -> 5764;
5911 -> 5764;
5912 -> 5766;
5912 -> 5911;
5913 -> 5912;
5913 -> 5909;
5913 -> 5911;
5914 -> 5913;
5914 -> 5764;
5915 -> 5764;
5916 -> 5914;
5916 -> 5915;
5917 -> 5764;
5918 -> 5766;
5918 -> 5917;
5919 -> 5917;
5920 -> 5918;
5920 -> 5919;
5921 -> 5920;
5921 -> 5909;
5921 -> 5919;
5922 -> 5917;
5923 -> 5918;
5923 -> 5922;
5924 -> 5923;
5924 -> 5909;
5924 -> 5922;
5925 -> 5922;
5926 -> 5923;
5926 -> 5909;
5926 -> 5925;
5926 -> 5922;
5927 -> 5923;
5927 -> 5909;
5927 -> 5922;
5928 -> 5917;
5929 -> 5921;
5929 -> 5764;
5930 -> 5909;
5930 -> 5764;
5931 -> 5930;
5932 -> 5931;
5932 -> 5909;
5932 -> 5927;
5933 -> 5931;
5933 -> 5909;
5933 -> 5924;
5933 -> 5923;
5933 -> 5927;
5934 -> 5933;
5934 -> 5930;
5935 -> 5930;
5936 -> 5934;
5936 -> 5935;
5937 -> 5930;
5938 -> 5936;
5938 -> 5937;
5939 -> 5938;
5939 -> 5937;
5940 -> 5939;
5941 -> 5657;
5941 -> 5633;
5942 -> 5633;
5943 -> 5941;
5943 -> 5942;
5944 -> 5635;
5944 -> 5942;
5945 -> 5943;
5945 -> 5653;
5945 -> 5944;
5945 -> 5942;
5946 -> 5943;
5946 -> 5654;
5946 -> 5944;
5946 -> 5942;
5947 -> 5943;
5947 -> 5655;
5947 -> 5944;
5947 -> 5909;
5947 -> 5942;
5948 -> 5943;
5948 -> 5656;
5948 -> 5944;
5948 -> 5909;
5948 -> 5942;
5949 -> 5943;
5949 -> 5652;
5949 -> 5942;
5950 -> 5942;
5951 -> 5949;
5951 -> 5950;
5952 -> 5944;
5952 -> 5950;
5953 -> 5951;
5953 -> 5642;
5953 -> 5952;
5953 -> 5909;
5953 -> 5950;
5954 -> 5950;
5955 -> 5953;
5955 -> 5954;
5955 -> 5950;
5956 -> 5953;
5956 -> 5952;
5956 -> 5909;
5956 -> 5950;
5957 -> 5951;
5957 -> 5642;
5957 -> 5952;
5957 -> 5950;
5958 -> 5950;
5959 -> 5953;
5959 -> 5958;
5959 -> 5950;
5960 -> 5953;
5960 -> 5952;
5960 -> 5909;
5960 -> 5950;
5961 -> 5953;
5961 -> 5952;
5961 -> 5950;
5962 -> 5950;
5963 -> 5962;
5963 -> 5952;
5963 -> 5950;
5964 -> 5950;
5965 -> 5964;
5965 -> 5952;
5965 -> 5950;
5966 -> 5951;
5966 -> 5642;
5966 -> 5952;
5966 -> 5950;
5967 -> 5950;
5968 -> 5952;
5968 -> 5909;
5968 -> 5967;
5968 -> 5950;
5969 -> 5942;
5970 -> 5633;
5971 -> 5634;
5971 -> 5633;
5972 -> 5633;
5973 -> 5971;
5973 -> 5972;
5974 -> 5635;
5974 -> 5972;
5975 -> 5973;
5975 -> 0;
5975 -> 5972;
5976 -> 5972;
5977 -> 5974;
5977 -> 5976;
5978 -> 5977;
5978 -> 5909;
5978 -> 5927;
5978 -> 5961;
5978 -> 5976;
5979 -> 5977;
5979 -> 5909;
5979 -> 5976;
5980 -> 5977;
5980 -> 5909;
5980 -> 5976;
5981 -> 5977;
5981 -> 5909;
5981 -> 5957;
5981 -> 5976;
5982 -> 5977;
5982 -> 5909;
5982 -> 5924;
5982 -> 5966;
5982 -> 5976;
5983 -> 5980;
5983 -> 5981;
5983 -> 5978;
5983 -> 5982;
5983 -> 5909;
5983 -> 5924;
5983 -> 5966;
5983 -> 5923;
5983 -> 5933;
5983 -> 5963;
5983 -> 5927;
5983 -> 5961;
5983 -> 5945;
5983 -> 5946;
5983 -> 5947;
5983 -> 5948;
5983 -> 5957;
5983 -> 5965;
5983 -> 5964;
5983 -> 5976;
5984 -> 5976;
5985 -> 5976;
5986 -> 5984;
5986 -> 5985;
5987 -> 5984;
5987 -> 5972;
5988 -> 5972;
5989 -> 5972;
5990 -> 5989;
5991 -> 5974;
5991 -> 5990;
5992 -> 5990;
5993 -> 5991;
5993 -> 5992;
5994 -> 5993;
5994 -> 5983;
5994 -> 5992;
5995 -> 5993;
5995 -> 5983;
5995 -> 5992;
5996 -> 5990;
5997 -> 5991;
5997 -> 5996;
5998 -> 5997;
5998 -> 5983;
5998 -> 5995;
5998 -> 5996;
5999 -> 5996;
6000 -> 5999;
6000 -> 5997;
6000 -> 5996;
6001 -> 5996;
6002 -> 5997;
6002 -> 5983;
6002 -> 6001;
6002 -> 5996;
6003 -> 5997;
6003 -> 5983;
6003 -> 5996;
6004 -> 5990;
6005 -> 5995;
6005 -> 5989;
6006 -> 5989;
6007 -> 5974;
6007 -> 6006;
6008 -> 6007;
6008 -> 5983;
6008 -> 6003;
6008 -> 6006;
6009 -> 6007;
6009 -> 5983;
6009 -> 6006;
6010 -> 6007;
6010 -> 5983;
6010 -> 5995;
6010 -> 5997;
6010 -> 6000;
6010 -> 6003;
6010 -> 6009;
6011 -> 6010;
6011 -> 5989;
6012 -> 5989;
6013 -> 6011;
6013 -> 6012;
6014 -> 5989;
6015 -> 5974;
6015 -> 6014;
6016 -> 6015;
6016 -> 5983;
6016 -> 5995;
6016 -> 5997;
6016 -> 6010;
6016 -> 6014;
6017 -> 6016;
6017 -> 5989;
6018 -> 5989;
6019 -> 6017;
6019 -> 6018;
6020 -> 5989;
6021 -> 5989;
6022 -> 6020;
6022 -> 6021;
6023 -> 5974;
6023 -> 6021;
6024 -> 6021;
6025 -> 6022;
6025 -> 6021;
6026 -> 6021;
6027 -> 6024;
6027 -> 6026;
6028 -> 6025;
6028 -> 6026;
6029 -> 6023;
6029 -> 6026;
6030 -> 6028;
6030 -> 6026;
6031 -> 5801;
6031 -> 6030;
6032 -> 6027;
6032 -> 6026;
6033 -> 6031;
6033 -> 6032;
6033 -> 6029;
6033 -> 5983;
6033 -> 5995;
6033 -> 5997;
6033 -> 6010;
6033 -> 6000;
6033 -> 6003;
6033 -> 6026;
6034 -> 6026;
6035 -> 6034;
6036 -> 6033;
6036 -> 6035;
6036 -> 6034;
6037 -> 6033;
6037 -> 6034;
6038 -> 6034;
6039 -> 6033;
6039 -> 6034;
6040 -> 6034;
6041 -> 6033;
6041 -> 6040;
6042 -> 6041;
6042 -> 6034;
6043 -> 6034;
6044 -> 6042;
6044 -> 6043;
6045 -> 6034;
6046 -> 6033;
6046 -> 6045;
6047 -> 6045;
6048 -> 6046;
6048 -> 6047;
6049 -> 6048;
6049 -> 6045;
6050 -> 6045;
6051 -> 6049;
6051 -> 6050;
6052 -> 6051;
6053 -> 6046;
6053 -> 6052;
6054 -> 6052;
6055 -> 6053;
6055 -> 6054;
6056 -> 6055;
6056 -> 6052;
6057 -> 6052;
6058 -> 6056;
6058 -> 6057;
6059 -> 6052;
6060 -> 6059;
6060 -> 6051;
6061 -> 6051;
6062 -> 6046;
6062 -> 6061;
6063 -> 6061;
6064 -> 6062;
6064 -> 6063;
6065 -> 6064;
6065 -> 6033;
6065 -> 6063;
6066 -> 6065;
6066 -> 6061;
6067 -> 6066;
6067 -> 6051;
6068 -> 6060;
6068 -> 6067;
6068 -> 6051;
6069 -> 6051;
6070 -> 6046;
6070 -> 6069;
6071 -> 6069;
6072 -> 6070;
6072 -> 6071;
6073 -> 6072;
6073 -> 6069;
6074 -> 6069;
6075 -> 6073;
6075 -> 6074;
6076 -> 6075;
6076 -> 6051;
6077 -> 6068;
6077 -> 6076;
6077 -> 6051;
6078 -> 6077;
6079 -> 6078;
6079 -> 6034;
6080 -> 6044;
6080 -> 6079;
6080 -> 6034;
6081 -> 6034;
6082 -> 6081;
6083 -> 6081;
6084 -> 6033;
6084 -> 6083;
6085 -> 6083;
6086 -> 6083;
6087 -> 6033;
6087 -> 6086;
6087 -> 6083;
6088 -> 6081;
6089 -> 6034;
6090 -> 6033;
6090 -> 6089;
6091 -> 6034;
6092 -> 6034;
6093 -> 6034;
6094 -> 6034;
6095 -> 6034;
6096 -> 6033;
6096 -> 6034;
6097 -> 6034;
6098 -> 5989;
6099 -> 5974;
6099 -> 6098;
6100 -> 6098;
6101 -> 6099;
6101 -> 6100;
6102 -> 6101;
6102 -> 6033;
6102 -> 6100;
6103 -> 6102;
6103 -> 6098;
6104 -> 6098;
6105 -> 6103;
6105 -> 6104;
6106 -> 6098;
6107 -> 6106;
6107 -> 5989;
6108 -> 5989;
6109 -> 5974;
6109 -> 6108;
6110 -> 6109;
6110 -> 6033;
6110 -> 6108;
6111 -> 6110;
6111 -> 5989;
6112 -> 5989;
6113 -> 6111;
6113 -> 6112;
6114 -> 6113;
6115 -> 6113;
6116 -> 6114;
6116 -> 6115;
6117 -> 6115;
6118 -> 6116;
6118 -> 6117;
6118 -> 6115;
6119 -> 6115;
6119 -> 6033;
6119 -> 6116;
6120 -> 6113;
6121 -> 6116;
6121 -> 6120;
6122 -> 5987;
6122 -> 6113;
6123 -> 6113;
6124 -> 6122;
6124 -> 6123;
6125 -> 6123;
6126 -> 6124;
6126 -> 6125;
6126 -> 6123;
6127 -> 6124;
6127 -> 6123;
6127 -> 6033;
6128 -> 6123;
6129 -> 6124;
6129 -> 6128;
6129 -> 6123;
6130 -> 6124;
6130 -> 6123;
6130 -> 6033;
6131 -> 6123;
6132 -> 6113;
6133 -> 6124;
6133 -> 6113;
6134 -> 6113;
6135 -> 6133;
6135 -> 6134;
6136 -> 5974;
6136 -> 6134;
6137 -> 6135;
6137 -> 6124;
6137 -> 6134;
6138 -> 6134;
6139 -> 6137;
6139 -> 6138;
6140 -> 6136;
6140 -> 6138;
6141 -> 6140;
6141 -> 6033;
6141 -> 6139;
6141 -> 5983;
6141 -> 6138;
6142 -> 6140;
6142 -> 6033;
6142 -> 6138;
6143 -> 6138;
6144 -> 6140;
6144 -> 6033;
6144 -> 6142;
6144 -> 6143;
6144 -> 6138;
6145 -> 6134;
6146 -> 6113;
6147 -> 6121;
6147 -> 5633;
6148 -> 5943;
6148 -> 5633;
6149 -> 5633;
6150 -> 6148;
6150 -> 6149;
6151 -> 5635;
6151 -> 6149;
6152 -> 6150;
6152 -> 5653;
6152 -> 6151;
6152 -> 6149;
6153 -> 6150;
6153 -> 5654;
6153 -> 6151;
6153 -> 6149;
6154 -> 6150;
6154 -> 5655;
6154 -> 6151;
6154 -> 6033;
6154 -> 6149;
6155 -> 6150;
6155 -> 5656;
6155 -> 6151;
6155 -> 6033;
6155 -> 6149;
6156 -> 6150;
6156 -> 5951;
6156 -> 6149;
6157 -> 6149;
6158 -> 6151;
6158 -> 6157;
6159 -> 6156;
6159 -> 5642;
6159 -> 6158;
6159 -> 6033;
6159 -> 6157;
6160 -> 6157;
6161 -> 6159;
6161 -> 6160;
6161 -> 6157;
6162 -> 6159;
6162 -> 6158;
6162 -> 6033;
6162 -> 6157;
6163 -> 6156;
6163 -> 5642;
6163 -> 6158;
6163 -> 6157;
6164 -> 6157;
6165 -> 6159;
6165 -> 6164;
6165 -> 6157;
6166 -> 6159;
6166 -> 6158;
6166 -> 6033;
6166 -> 6157;
6167 -> 6157;
6168 -> 6167;
6168 -> 6158;
6168 -> 6157;
6169 -> 6157;
6170 -> 6169;
6170 -> 6158;
6170 -> 6157;
6171 -> 6156;
6171 -> 5642;
6171 -> 6158;
6171 -> 6157;
6172 -> 6157;
6173 -> 6158;
6173 -> 6033;
6173 -> 6172;
6173 -> 6157;
6174 -> 6149;
6175 -> 5633;
6176 -> 0;
6176 -> 5633;
6177 -> 5633;
6178 -> 6176;
6178 -> 6177;
6179 -> 5635;
6179 -> 6177;
6180 -> 6178;
6180 -> 6177;
6181 -> 6177;
6182 -> 6180;
6182 -> 6181;
6183 -> 6182;
6183 -> 0;
6183 -> 6181;
6184 -> 6183;
6185 -> 6179;
6185 -> 6033;
6185 -> 6124;
6185 -> 6159;
6185 -> 6177;
6186 -> 6179;
6186 -> 6033;
6186 -> 6177;
6187 -> 6179;
6187 -> 6033;
6187 -> 6124;
6187 -> 6152;
6187 -> 6153;
6187 -> 6154;
6187 -> 6155;
6187 -> 6163;
6187 -> 6159;
6187 -> 6123;
6187 -> 6168;
6187 -> 6170;
6187 -> 6171;
6187 -> 6142;
6187 -> 6186;
6188 -> 6187;
6188 -> 6178;
6188 -> 6177;
6189 -> 6188;
6189 -> 6033;
6189 -> 6123;
6189 -> 6168;
6189 -> 6187;
6190 -> 6188;
6191 -> 6188;
6192 -> 6187;
6192 -> 6188;
6193 -> 0;
6193 -> 5633;
6194 -> 5633;
6195 -> 5633;
6196 -> 6193;
6196 -> 6195;
6197 -> 6194;
6197 -> 6195;
6198 -> 6194;
6198 -> 6195;
6199 -> 5635;
6199 -> 6195;
6200 -> 6196;
6200 -> 6195;
6201 -> 6198;
6201 -> 6195;
6202 -> 6195;
6203 -> 6200;
6203 -> 6202;
6204 -> 6201;
6204 -> 6202;
6205 -> 6199;
6205 -> 6202;
6206 -> 6202;
6207 -> 6205;
6207 -> 6206;
6208 -> 6207;
6208 -> 6033;
6208 -> 6124;
6208 -> 6152;
6208 -> 6153;
6208 -> 6154;
6208 -> 6155;
6208 -> 6163;
6208 -> 6159;
6208 -> 6188;
6208 -> 6123;
6208 -> 6168;
6208 -> 6187;
6208 -> 6170;
6208 -> 6171;
6208 -> 6142;
6208 -> 6206;
6209 -> 6208;
6209 -> 6202;
6210 -> 6202;
6211 -> 6205;
6211 -> 6210;
6212 -> 6211;
6212 -> 6033;
6212 -> 6124;
6212 -> 6159;
6212 -> 6188;
6212 -> 6210;
6213 -> 6211;
6213 -> 6033;
6213 -> 6142;
6213 -> 6210;
6214 -> 6211;
6214 -> 6033;
6214 -> 6142;
6214 -> 6210;
6215 -> 6211;
6215 -> 6033;
6215 -> 6124;
6215 -> 6163;
6215 -> 6210;
6216 -> 6211;
6216 -> 6033;
6216 -> 6124;
6216 -> 6171;
6216 -> 6188;
6216 -> 6210;
6217 -> 6210;
6218 -> 6210;
6219 -> 6217;
6219 -> 6218;
6220 -> 6217;
6220 -> 6202;
6221 -> 6202;
6222 -> 6205;
6222 -> 6221;
6223 -> 6221;
6224 -> 6222;
6224 -> 6223;
6225 -> 6224;
6225 -> 6212;
6225 -> 6223;
6226 -> 6224;
6226 -> 6212;
6226 -> 6223;
6227 -> 6226;
6227 -> 6221;
6228 -> 6221;
6229 -> 6227;
6229 -> 6228;
6230 -> 6229;
6231 -> 6230;
6231 -> 6202;
6232 -> 6202;
6233 -> 6203;
6233 -> 6202;
6234 -> 6232;
6234 -> 6202;
6235 -> 6233;
6235 -> 6234;
6235 -> 6205;
6235 -> 6212;
6235 -> 6226;
6235 -> 6202;
6236 -> 6202;
6237 -> 6236;
6238 -> 6235;
6238 -> 6237;
6238 -> 6236;
6239 -> 6235;
6239 -> 6236;
6240 -> 6236;
6241 -> 6235;
6241 -> 6236;
6242 -> 6236;
6243 -> 6235;
6243 -> 6242;
6244 -> 6243;
6244 -> 6236;
6245 -> 6236;
6246 -> 6244;
6246 -> 6245;
6247 -> 6236;
6248 -> 6235;
6248 -> 6247;
6249 -> 6247;
6250 -> 6248;
6250 -> 6249;
6251 -> 6250;
6251 -> 6247;
6252 -> 6247;
6253 -> 6251;
6253 -> 6252;
6254 -> 6253;
6255 -> 6248;
6255 -> 6254;
6256 -> 6254;
6257 -> 6255;
6257 -> 6256;
6258 -> 6257;
6258 -> 6254;
6259 -> 6254;
6260 -> 6258;
6260 -> 6259;
6261 -> 6254;
6262 -> 6261;
6262 -> 6253;
6263 -> 6253;
6264 -> 6248;
6264 -> 6263;
6265 -> 6263;
6266 -> 6264;
6266 -> 6265;
6267 -> 6266;
6267 -> 6235;
6267 -> 6265;
6268 -> 6267;
6268 -> 6263;
6269 -> 6268;
6269 -> 6253;
6270 -> 6262;
6270 -> 6269;
6270 -> 6253;
6271 -> 6253;
6272 -> 6248;
6272 -> 6271;
6273 -> 6271;
6274 -> 6272;
6274 -> 6273;
6275 -> 6274;
6275 -> 6271;
6276 -> 6271;
6277 -> 6275;
6277 -> 6276;
6278 -> 6277;
6278 -> 6253;
6279 -> 6270;
6279 -> 6278;
6279 -> 6253;
6280 -> 6279;
6281 -> 6280;
6281 -> 6236;
6282 -> 6246;
6282 -> 6281;
6282 -> 6236;
6283 -> 6236;
6284 -> 6283;
6285 -> 6283;
6286 -> 6235;
6286 -> 6285;
6287 -> 6285;
6288 -> 6285;
6289 -> 6235;
6289 -> 6288;
6289 -> 6285;
6290 -> 6283;
6291 -> 6236;
6292 -> 6235;
6292 -> 6291;
6293 -> 6236;
6294 -> 6236;
6295 -> 6236;
6296 -> 6236;
6297 -> 6236;
6298 -> 6235;
6298 -> 6236;
6299 -> 6236;
6300 -> 6202;
6301 -> 6235;
6301 -> 6300;
6302 -> 6301;
6302 -> 6202;
6303 -> 6202;
6304 -> 6302;
6304 -> 6303;
6305 -> 6231;
6305 -> 6304;
6305 -> 6202;
6306 -> 6204;
6306 -> 6305;
6306 -> 6202;
6307 -> 6202;
6308 -> 6306;
6308 -> 6307;
6309 -> 6205;
6309 -> 6307;
6310 -> 6307;
6311 -> 6309;
6311 -> 6310;
6312 -> 6311;
6312 -> 6235;
6312 -> 6310;
6313 -> 6312;
6313 -> 6307;
6314 -> 6307;
6315 -> 6313;
6315 -> 6314;
6316 -> 6315;
6317 -> 6316;
6317 -> 6202;
6318 -> 6317;
6319 -> 6220;
6319 -> 6317;
6320 -> 6317;
6321 -> 6319;
6321 -> 6320;
6322 -> 6320;
6323 -> 6321;
6323 -> 6322;
6323 -> 6320;
6324 -> 6321;
6324 -> 6320;
6324 -> 6235;
6325 -> 6320;
6326 -> 6321;
6326 -> 6325;
6326 -> 6320;
6327 -> 6321;
6327 -> 6320;
6327 -> 6235;
6328 -> 6320;
6329 -> 6317;
6330 -> 6321;
6330 -> 6317;
6331 -> 6317;
6332 -> 6330;
6332 -> 6331;
6333 -> 6332;
6333 -> 6321;
6333 -> 6331;
6334 -> 6333;
6334 -> 6331;
6335 -> 6331;
6335 -> 6235;
6335 -> 6334;
6335 -> 6212;
6336 -> 6331;
6337 -> 6331;
6338 -> 6317;
6339 -> 6318;
6340 -> 6339;
6340 -> 6235;
6341 -> 6339;
6342 -> 6339;
6343 -> 6339;
6343 -> 6235;
6343 -> 6321;
6344 -> 6339;
6344 -> 6235;
6344 -> 6321;
6344 -> 6320;
6344 -> 6331;
6345 -> 6344;
6345 -> 6339;
6346 -> 6339;
6347 -> 6345;
6347 -> 6346;
6348 -> 6347;
6348 -> 6346;
6349 -> 6348;
6350 -> 6339;
6350 -> 6344;
6351 -> 6344;
6352 -> 6350;
6352 -> 6351;
6353 -> 6352;
6353 -> 6344;
6354 -> 6344;
6355 -> 6353;
6355 -> 6354;
6356 -> 6344;
6357 -> 6344;
6358 -> 6339;
6358 -> 6344;
6359 -> 6344;
6360 -> 6358;
6360 -> 6359;
6361 -> 6360;
6361 -> 6344;
6362 -> 6344;
6363 -> 6361;
6363 -> 6362;
6364 -> 6339;
6364 -> 6354;
6365 -> 6364;
6365 -> 6354;
6366 -> 6365;
6366 -> 6354;
6367 -> 6366;
6367 -> 6354;
6368 -> 6354;
6369 -> 6354;
6369 -> 6368;
6370 -> 6368;
6371 -> 6369;
6371 -> 6370;
6372 -> 6371;
6372 -> 6368;
6373 -> 6368;
6374 -> 6372;
6374 -> 6373;
6375 -> 6374;
6376 -> 6369;
6376 -> 6375;
6377 -> 6375;
6378 -> 6376;
6378 -> 6377;
6379 -> 6378;
6379 -> 6375;
6380 -> 6375;
6381 -> 6379;
6381 -> 6380;
6382 -> 6375;
6383 -> 6382;
6383 -> 6374;
6384 -> 6374;
6385 -> 6369;
6385 -> 6384;
6386 -> 6384;
6387 -> 6385;
6387 -> 6386;
6388 -> 6387;
6388 -> 6235;
6388 -> 6321;
6388 -> 6320;
6388 -> 6344;
6388 -> 6331;
6388 -> 6339;
6388 -> 6386;
6389 -> 6388;
6389 -> 6384;
6390 -> 6389;
6390 -> 6374;
6391 -> 6383;
6391 -> 6390;
6391 -> 6374;
6392 -> 6374;
6393 -> 6369;
6393 -> 6392;
6394 -> 6392;
6395 -> 6393;
6395 -> 6394;
6396 -> 6395;
6396 -> 6392;
6397 -> 6392;
6398 -> 6396;
6398 -> 6397;
6399 -> 6398;
6399 -> 6374;
6400 -> 6391;
6400 -> 6399;
6400 -> 6374;
6401 -> 6400;
6402 -> 6401;
6402 -> 6354;
6403 -> 6402;
6404 -> 6354;
6404 -> 6403;
6405 -> 6403;
6406 -> 6405;
6406 -> 6403;
6407 -> 6403;
6408 -> 6406;
6408 -> 6407;
6409 -> 6404;
6409 -> 6407;
6410 -> 6407;
6411 -> 6408;
6411 -> 6410;
6411 -> 6407;
6412 -> 6409;
6412 -> 6235;
6412 -> 6321;
6412 -> 6408;
6412 -> 6407;
6413 -> 6409;
6413 -> 6235;
6413 -> 6321;
6413 -> 6408;
6414 -> 6403;
6415 -> 6413;
6415 -> 6414;
6416 -> 6403;
6417 -> 6406;
6417 -> 6416;
6418 -> 6404;
6418 -> 6416;
6419 -> 6416;
6420 -> 6417;
6420 -> 6419;
6420 -> 6416;
6421 -> 6418;
6421 -> 6235;
6421 -> 6321;
6421 -> 6417;
6421 -> 6416;
6422 -> 6418;
6422 -> 6235;
6422 -> 6321;
6422 -> 6417;
6423 -> 6403;
6424 -> 6422;
6424 -> 6423;
6425 -> 6415;
6425 -> 6424;
6425 -> 6403;
6426 -> 6405;
6426 -> 6403;
6427 -> 6403;
6428 -> 6426;
6428 -> 6427;
6429 -> 6404;
6429 -> 6427;
6430 -> 6427;
6431 -> 6428;
6431 -> 6430;
6431 -> 6427;
6432 -> 6429;
6432 -> 6235;
6432 -> 6321;
6432 -> 6428;
6432 -> 6427;
6433 -> 6429;
6433 -> 6235;
6433 -> 6321;
6433 -> 6428;
6434 -> 6403;
6435 -> 6433;
6435 -> 6434;
6436 -> 6435;
6436 -> 6402;
6437 -> 6367;
6437 -> 6436;
6438 -> 6436;
6439 -> 6437;
6439 -> 6438;
6440 -> 6354;
6440 -> 6438;
6441 -> 6438;
6442 -> 6440;
6442 -> 6441;
6443 -> 6442;
6443 -> 6438;
6444 -> 6438;
6445 -> 6443;
6445 -> 6444;
6446 -> 6438;
6447 -> 6440;
6447 -> 6446;
6448 -> 6447;
6448 -> 6438;
6449 -> 6438;
6450 -> 6448;
6450 -> 6449;
6451 -> 6440;
6451 -> 6449;
6452 -> 6449;
6453 -> 6450;
6453 -> 6452;
6454 -> 6453;
6454 -> 6449;
6455 -> 6449;
6456 -> 6451;
6456 -> 6455;
6457 -> 6456;
6457 -> 6449;
6458 -> 6454;
6458 -> 6457;
6458 -> 6449;
6459 -> 6445;
6459 -> 6458;
6459 -> 6438;
6460 -> 6439;
6460 -> 0;
6460 -> 6438;
6461 -> 6438;
6462 -> 6438;
6463 -> 6438;
6464 -> 6440;
6464 -> 6463;
6465 -> 6464;
6465 -> 6438;
6466 -> 6438;
6467 -> 6465;
6467 -> 6466;
6468 -> 6467;
6469 -> 6468;
6469 -> 6467;
6470 -> 6467;
6471 -> 6469;
6471 -> 6470;
6472 -> 6471;
6473 -> 6471;
6474 -> 6472;
6474 -> 6438;
6475 -> 6438;
6476 -> 6474;
6476 -> 6475;
6477 -> 6440;
6477 -> 6475;
6478 -> 6475;
6479 -> 6476;
6479 -> 6478;
6479 -> 6475;
6480 -> 6477;
6480 -> 6235;
6480 -> 6321;
6480 -> 6476;
6480 -> 6475;
6481 -> 6438;
6482 -> 6476;
6482 -> 6481;
6483 -> 6472;
6483 -> 6438;
6484 -> 6438;
6485 -> 6483;
6485 -> 6484;
6486 -> 6440;
6486 -> 6484;
6487 -> 6484;
6488 -> 6485;
6488 -> 6487;
6488 -> 6484;
6489 -> 6486;
6489 -> 6235;
6489 -> 6321;
6489 -> 6485;
6489 -> 6484;
6490 -> 6438;
6491 -> 6485;
6491 -> 6490;
6492 -> 6438;
6493 -> 6472;
6493 -> 6492;
6493 -> 6438;
6494 -> 6438;
6495 -> 6493;
6495 -> 6494;
6496 -> 6440;
6496 -> 6494;
6497 -> 6494;
6498 -> 6495;
6498 -> 6497;
6498 -> 6494;
6499 -> 6496;
6499 -> 6235;
6499 -> 6321;
6499 -> 6495;
6499 -> 6494;
6500 -> 6438;
6501 -> 6495;
6501 -> 6500;
6502 -> 6491;
6502 -> 6501;
6502 -> 6438;
6503 -> 6472;
6503 -> 6438;
6504 -> 6438;
6505 -> 6503;
6505 -> 6504;
6506 -> 6440;
6506 -> 6504;
6507 -> 6504;
6508 -> 6505;
6508 -> 6507;
6508 -> 6504;
6509 -> 6506;
6509 -> 6235;
6509 -> 6321;
6509 -> 6505;
6509 -> 6504;
6510 -> 6438;
6511 -> 6505;
6511 -> 6510;
6512 -> 6472;
6512 -> 6438;
6513 -> 6438;
6514 -> 6512;
6514 -> 6513;
6515 -> 6440;
6515 -> 6513;
6516 -> 6513;
6517 -> 6514;
6517 -> 6516;
6517 -> 6513;
6518 -> 6515;
6518 -> 6235;
6518 -> 6321;
6518 -> 6514;
6518 -> 6513;
6519 -> 6438;
6520 -> 6514;
6520 -> 6519;
6521 -> 6520;
6522 -> 6521;
6522 -> 6436;
6523 -> 6367;
6523 -> 6522;
6524 -> 6522;
6525 -> 6523;
6525 -> 6524;
6526 -> 0;
6526 -> 6525;
6527 -> 6525;
6528 -> 6526;
6528 -> 6527;
6529 -> 6354;
6529 -> 6527;
6530 -> 6528;
6530 -> 6527;
6531 -> 6527;
6532 -> 6530;
6532 -> 6531;
6533 -> 6529;
6533 -> 6531;
6534 -> 6531;
6535 -> 6531;
6536 -> 6534;
6536 -> 6535;
6537 -> 6533;
6537 -> 6535;
6538 -> 6535;
6539 -> 6537;
6539 -> 6538;
6540 -> 6538;
6541 -> 6539;
6541 -> 6540;
6542 -> 6541;
6542 -> 6538;
6543 -> 6542;
6544 -> 6543;
6544 -> 6535;
6545 -> 6536;
6545 -> 6535;
6546 -> 6535;
6547 -> 6545;
6547 -> 6546;
6548 -> 6537;
6548 -> 6546;
6549 -> 6546;
6550 -> 6548;
6550 -> 6549;
6551 -> 6550;
6551 -> 6546;
6552 -> 6546;
6553 -> 6551;
6553 -> 6552;
6554 -> 6553;
6554 -> 0;
6554 -> 6546;
6555 -> 6554;
6556 -> 6548;
6556 -> 6555;
6557 -> 6555;
6558 -> 6556;
6558 -> 6557;
6559 -> 6558;
6559 -> 6555;
6560 -> 6555;
6561 -> 6559;
6561 -> 6560;
6562 -> 6555;
6562 -> 6554;
6563 -> 6554;
6564 -> 6563;
6564 -> 6554;
6565 -> 6562;
6565 -> 6564;
6565 -> 6554;
6566 -> 6554;
6567 -> 6566;
6567 -> 6235;
6567 -> 6320;
6567 -> 6344;
6568 -> 6566;
6569 -> 6566;
6570 -> 6566;
6570 -> 6554;
6571 -> 6554;
6572 -> 6548;
6572 -> 6571;
6573 -> 6572;
6573 -> 6235;
6573 -> 6321;
6573 -> 6566;
6573 -> 6320;
6573 -> 6344;
6573 -> 6331;
6573 -> 6339;
6573 -> 6571;
6574 -> 6573;
6574 -> 6554;
6575 -> 6570;
6575 -> 6554;
6576 -> 6575;
6576 -> 6535;
6577 -> 6576;
6577 -> 6535;
6578 -> 6535;
6579 -> 6577;
6579 -> 6578;
6580 -> 6577;
6580 -> 6578;
6581 -> 6579;
6581 -> 6578;
6582 -> 6578;
6583 -> 6582;
6583 -> 6581;
6583 -> 6578;
6584 -> 6582;
6584 -> 6578;
6585 -> 6584;
6585 -> 6583;
6585 -> 6578;
6586 -> 6585;
6586 -> 6531;
6587 -> 6586;
6587 -> 6585;
6587 -> 6531;
6588 -> 6586;
6588 -> 6531;
6589 -> 6531;
6590 -> 6533;
6590 -> 6589;
6591 -> 6590;
6591 -> 6585;
6591 -> 6589;
6592 -> 6590;
6592 -> 6585;
6592 -> 6589;
6593 -> 6592;
6593 -> 6531;
6594 -> 6531;
6595 -> 6593;
6595 -> 6594;
6596 -> 6588;
6596 -> 6531;
6597 -> 6596;
6597 -> 6527;
6598 -> 6527;
6599 -> 6529;
6599 -> 6598;
6600 -> 6599;
6600 -> 6585;
6600 -> 6592;
6600 -> 6598;
6601 -> 6600;
6601 -> 6527;
6602 -> 6527;
6603 -> 6601;
6603 -> 6602;
6604 -> 6597;
6604 -> 6527;
6605 -> 6604;
6605 -> 6525;
6606 -> 6605;
6606 -> 6354;
6606 -> 6585;
6606 -> 6592;
6607 -> 6354;
6608 -> 6606;
6608 -> 6339;
6609 -> 6339;
6610 -> 6339;
6611 -> 6608;
6611 -> 6610;
6612 -> 6609;
6612 -> 6610;
6613 -> 6339;
6613 -> 6610;
6614 -> 6610;
6615 -> 6614;
6616 -> 6613;
6616 -> 6615;
6617 -> 6616;
6617 -> 6606;
6617 -> 6615;
6618 -> 6617;
6618 -> 6614;
6619 -> 6614;
6620 -> 6618;
6620 -> 6619;
6621 -> 6614;
6622 -> 6614;
6623 -> 6620;
6623 -> 6614;
6624 -> 6614;
6625 -> 6623;
6625 -> 6624;
6626 -> 6625;
6626 -> 6624;
6627 -> 6624;
6628 -> 6626;
6628 -> 6627;
6629 -> 6628;
6629 -> 6627;
6630 -> 6627;
6631 -> 6629;
6631 -> 6630;
6632 -> 6631;
6632 -> 6630;
6633 -> 0;
6633 -> 6632;
6634 -> 6620;
6634 -> 6633;
6635 -> 6633;
6636 -> 6634;
6636 -> 6635;
6637 -> 6636;
6637 -> 6635;
6638 -> 6635;
6639 -> 6637;
6639 -> 6638;
6640 -> 6639;
6640 -> 6638;
6641 -> 6640;
6642 -> 6620;
6642 -> 0;
6642 -> 6641;
6643 -> 6620;
6643 -> 0;
6643 -> 6642;
6644 -> 6620;
6644 -> 0;
6644 -> 6643;
6645 -> 6610;
6646 -> 6613;
6646 -> 6645;
6647 -> 6646;
6647 -> 6606;
6647 -> 6645;
6648 -> 6647;
6648 -> 6610;
6649 -> 6610;
6650 -> 6648;
6650 -> 6649;
6651 -> 6611;
6651 -> 6610;
6652 -> 6339;
6653 -> 6339;
6654 -> 6651;
6654 -> 6653;
6655 -> 6654;
6655 -> 6339;
6656 -> 6339;
6657 -> 6655;
6657 -> 6656;
6658 -> 6657;
6658 -> 6656;
6659 -> 0;
6659 -> 6658;
6660 -> 6339;
6660 -> 6606;
6661 -> 6651;
6661 -> 6339;
6662 -> 5633;
6663 -> 5635;
6663 -> 6662;
6664 -> 6663;
6664 -> 6606;
6664 -> 6662;
6665 -> 6664;
6665 -> 5633;
6666 -> 5633;
6667 -> 6665;
6667 -> 6666;
6668 -> 5633;
6669 -> 6661;
6669 -> 6668;
6670 -> 6669;
6670 -> 5633;
6671 -> 5633;
6672 -> 5635;
6672 -> 6671;
6673 -> 6672;
6673 -> 6606;
6673 -> 6671;
6674 -> 6673;
6674 -> 5633;
6675 -> 5633;
6676 -> 6674;
6676 -> 6675;
6677 -> 6670;
6677 -> 6676;
6677 -> 5633;
6678 -> 0;
6678 -> 5633;
6679 -> 5633;
6680 -> 6678;
6680 -> 6679;
6681 -> 5635;
6681 -> 6679;
6682 -> 6680;
6682 -> 6679;
6683 -> 6679;
6684 -> 6682;
6684 -> 6683;
6685 -> 6684;
6685 -> 0;
6685 -> 6683;
6686 -> 6685;
6687 -> 6681;
6687 -> 6606;
6687 -> 6679;
6688 -> 6687;
6688 -> 6680;
6688 -> 6679;
6689 -> 6688;
6690 -> 6688;
6691 -> 6687;
6691 -> 6688;
6692 -> 6192;
6692 -> 5633;
6693 -> 6661;
6693 -> 5633;
6694 -> 6691;
6694 -> 5633;
6695 -> 6692;
6695 -> 6693;
6695 -> 6694;
6695 -> 5635;
6695 -> 6606;
6695 -> 6660;
6695 -> 6688;
6695 -> 5633;
6696 -> 5633;
6697 -> 6695;
6697 -> 6696;
6698 -> 6695;
6698 -> 6696;
6699 -> 6695;
6699 -> 6696;
6700 -> 6695;
6700 -> 6696;
6701 -> 6695;
6701 -> 6696;
6702 -> 6695;
6702 -> 6696;
6703 -> 6697;
6703 -> 6696;
6704 -> 6698;
6704 -> 6696;
6705 -> 6699;
6705 -> 6696;
6706 -> 6700;
6706 -> 6696;
6707 -> 6701;
6707 -> 6696;
6708 -> 6696;
6709 -> 6707;
6709 -> 6708;
6710 -> 6708;
6711 -> 6709;
6711 -> 6695;
6711 -> 6708;
6712 -> 6709;
6712 -> 6695;
6712 -> 6708;
6713 -> 6710;
6713 -> 6708;
6714 -> 6713;
6714 -> 6696;
6715 -> 6702;
6715 -> 6696;
6716 -> 6703;
6716 -> 6704;
6716 -> 6705;
6716 -> 6706;
6716 -> 6714;
6716 -> 6715;
6716 -> 6695;
6716 -> 6696;
6717 -> 6696;
6718 -> 6717;
6718 -> 6696;
6719 -> 6716;
6719 -> 6696;
6720 -> 6716;
6720 -> 6696;
6721 -> 6719;
6721 -> 6696;
6722 -> 6719;
6722 -> 6696;
6723 -> 6150;
6723 -> 5633;
6724 -> 5633;
6725 -> 6723;
6725 -> 6724;
6726 -> 5635;
6726 -> 6724;
6727 -> 6725;
6727 -> 6156;
6727 -> 6724;
6728 -> 6724;
6729 -> 6727;
6729 -> 6728;
6730 -> 6726;
6730 -> 6728;
6731 -> 6730;
6731 -> 6716;
6731 -> 6729;
6731 -> 5642;
6731 -> 6728;
6732 -> 6730;
6732 -> 6716;
6732 -> 6728;
6733 -> 6728;
6734 -> 6730;
6734 -> 6716;
6734 -> 6732;
6734 -> 6733;
6734 -> 6728;
6735 -> 6724;
6736 -> 5633;
6737 -> 6716;
6737 -> 5631;
6738 -> 6737;
6738 -> 5621;
6738 -> 6716;
6738 -> 6732;
6738 -> 5619;
6739 -> 5619;
6740 -> 6738;
6740 -> 6739;
6741 -> 5527;
6741 -> 5526;
6742 -> 5526;
6743 -> 6741;
6743 -> 6742;
6744 -> 5528;
6744 -> 6742;
6745 -> 6742;
6746 -> 6745;
6747 -> 6744;
6747 -> 6746;
6748 -> 6747;
6748 -> 6738;
6748 -> 6746;
6749 -> 6748;
6749 -> 6745;
6750 -> 6745;
6751 -> 6749;
6751 -> 6750;
6752 -> 6750;
6753 -> 6745;
6754 -> 6745;
6755 -> 6751;
6755 -> 6745;
6756 -> 6745;
6757 -> 6755;
6757 -> 6756;
6758 -> 6757;
6758 -> 6756;
6759 -> 6756;
6760 -> 6758;
6760 -> 6759;
6761 -> 6760;
6761 -> 6759;
6762 -> 6759;
6763 -> 6761;
6763 -> 6762;
6764 -> 6763;
6764 -> 6762;
6765 -> 0;
6765 -> 6764;
6766 -> 6751;
6766 -> 6765;
6767 -> 6765;
6768 -> 6766;
6768 -> 6767;
6769 -> 6768;
6769 -> 6767;
6770 -> 6767;
6771 -> 6769;
6771 -> 6770;
6772 -> 6771;
6772 -> 6770;
6773 -> 6772;
6774 -> 6751;
6774 -> 0;
6774 -> 6773;
6775 -> 6751;
6775 -> 0;
6775 -> 6774;
6776 -> 6751;
6776 -> 0;
6776 -> 6775;
6777 -> 6742;
6778 -> 6744;
6778 -> 6777;
6779 -> 6778;
6779 -> 6738;
6779 -> 6777;
6780 -> 6779;
6780 -> 6742;
6781 -> 6742;
6782 -> 6780;
6782 -> 6781;
6783 -> 5520;
6784 -> 5520;
6785 -> 6738;
6785 -> 6784;
6786 -> 6785;
6786 -> 5520;
6787 -> 5520;
6788 -> 6786;
6788 -> 6787;
6789 -> 6788;
6789 -> 6787;
6790 -> 0;
6790 -> 6789;
6791 -> 6738;
6791 -> 5479;
6792 -> 5479;
6793 -> 5479;
6794 -> 5479;
6795 -> 6791;
6795 -> 6794;
6796 -> 6795;
6796 -> 5479;
6797 -> 6791;
6797 -> 6796;
6798 -> 6797;
6798 -> 6738;
6798 -> 6796;
6799 -> 6797;
6799 -> 6738;
6799 -> 6796;
6800 -> 6797;
6800 -> 6738;
6800 -> 6796;
6801 -> 6797;
6801 -> 6738;
6801 -> 6796;
6802 -> 6796;
6803 -> 0;
6803 -> 5479;
6804 -> 5479;
6805 -> 6803;
6805 -> 6804;
6806 -> 5481;
6806 -> 6804;
6807 -> 6805;
6807 -> 6804;
6808 -> 6804;
6809 -> 6807;
6809 -> 6808;
6810 -> 6809;
6810 -> 0;
6810 -> 6808;
6811 -> 6810;
6812 -> 6804;
6813 -> 6806;
6813 -> 6812;
6814 -> 6813;
6814 -> 6801;
6814 -> 6812;
6815 -> 6804;
6816 -> 6814;
6816 -> 6805;
6816 -> 6804;
6817 -> 6816;
6818 -> 6816;
6819 -> 5481;
6819 -> 6801;
6819 -> 6816;
6819 -> 5479;
6820 -> 5479;
6821 -> 5481;
6821 -> 6820;
6822 -> 6820;
6823 -> 6821;
6823 -> 6822;
6824 -> 6823;
6824 -> 6819;
6824 -> 6822;
6825 -> 6823;
6825 -> 6819;
6825 -> 6822;
6826 -> 6825;
6826 -> 6820;
6827 -> 6820;
6828 -> 6826;
6828 -> 6827;
6829 -> 6828;
6829 -> 5479;
6830 -> 6829;
6831 -> 5481;
6831 -> 6830;
6832 -> 6830;
6833 -> 6831;
6833 -> 6832;
6834 -> 6833;
6834 -> 6830;
6835 -> 6831;
6835 -> 6819;
6835 -> 6825;
6835 -> 6830;
6836 -> 6831;
6836 -> 6835;
6836 -> 6830;
6837 -> 6830;
6838 -> 6830;
6839 -> 6830;
6840 -> 6830;
6841 -> 6831;
6841 -> 6840;
6842 -> 6841;
6842 -> 6836;
6842 -> 6840;
6843 -> 6842;
6843 -> 6830;
6844 -> 6830;
6845 -> 6843;
6845 -> 6844;
6846 -> 6845;
6847 -> 6845;
6848 -> 6847;
6849 -> 6847;
6850 -> 6847;
6850 -> 6845;
6851 -> 6845;
6852 -> 6851;
6852 -> 6836;
6852 -> 6847;
6853 -> 6851;
6853 -> 6836;
6853 -> 6847;
6854 -> 6853;
6854 -> 6845;
6855 -> 6845;
6856 -> 6854;
6856 -> 6855;
6857 -> 6856;
6858 -> 6831;
6858 -> 6857;
6859 -> 6857;
6860 -> 6858;
6860 -> 6859;
6861 -> 0;
6861 -> 6859;
6862 -> 6859;
6863 -> 6859;
6864 -> 6861;
6864 -> 6863;
6865 -> 6862;
6865 -> 6863;
6866 -> 6862;
6866 -> 6863;
6867 -> 6860;
6867 -> 6863;
6868 -> 6864;
6868 -> 6863;
6869 -> 6865;
6869 -> 6863;
6870 -> 6866;
6870 -> 6863;
6871 -> 6863;
6872 -> 6868;
6872 -> 6871;
6873 -> 6869;
6873 -> 6871;
6874 -> 6870;
6874 -> 6871;
6875 -> 6867;
6875 -> 6871;
6876 -> 6872;
6876 -> 6871;
6877 -> 6873;
6877 -> 6871;
6878 -> 6874;
6878 -> 6871;
6879 -> 6871;
6880 -> 6876;
6880 -> 6879;
6881 -> 6877;
6881 -> 6879;
6882 -> 6878;
6882 -> 6879;
6883 -> 6875;
6883 -> 6879;
6884 -> 6880;
6884 -> 6879;
6885 -> 6881;
6885 -> 6879;
6886 -> 6882;
6886 -> 6879;
6887 -> 6879;
6888 -> 6884;
6888 -> 6887;
6889 -> 6885;
6889 -> 6887;
6890 -> 6886;
6890 -> 6887;
6891 -> 6883;
6891 -> 6887;
6892 -> 6887;
6893 -> 6891;
6893 -> 6892;
6894 -> 6893;
6894 -> 6887;
6895 -> 6887;
6896 -> 6894;
6896 -> 6895;
6897 -> 6888;
6897 -> 6896;
6898 -> 6889;
6898 -> 6896;
6899 -> 6890;
6899 -> 6896;
6900 -> 6896;
6901 -> 6897;
6901 -> 6900;
6902 -> 6898;
6902 -> 6900;
6903 -> 6899;
6903 -> 6900;
6904 -> 6891;
6904 -> 6900;
6905 -> 6900;
6906 -> 6904;
6906 -> 6905;
6907 -> 6906;
6907 -> 6900;
6908 -> 6900;
6909 -> 6907;
6909 -> 6908;
6910 -> 6909;
6910 -> 6900;
6911 -> 6900;
6912 -> 6904;
6912 -> 6911;
6913 -> 6912;
6913 -> 6900;
6914 -> 6900;
6915 -> 6913;
6915 -> 6914;
6916 -> 6900;
6917 -> 6904;
6917 -> 6916;
6918 -> 6917;
6918 -> 6900;
6919 -> 6900;
6920 -> 6918;
6920 -> 6919;
6921 -> 6900;
6922 -> 6904;
6922 -> 6921;
6923 -> 6921;
6923 -> 6900;
6924 -> 6900;
6925 -> 6900;
6926 -> 6904;
6926 -> 6925;
6927 -> 6925;
6928 -> 6926;
6928 -> 6927;
6929 -> 6928;
6929 -> 6922;
6929 -> 6927;
6930 -> 6929;
6930 -> 6925;
6931 -> 6925;
6932 -> 6930;
6932 -> 6931;
6933 -> 6932;
6933 -> 6925;
6934 -> 6925;
6935 -> 6933;
6935 -> 6934;
6936 -> 6932;
6936 -> 0;
6936 -> 6925;
6937 -> 6925;
6938 -> 6926;
6938 -> 6937;
6939 -> 6938;
6939 -> 6922;
6939 -> 6937;
6940 -> 6939;
6940 -> 6925;
6941 -> 6925;
6942 -> 6940;
6942 -> 6941;
6943 -> 6936;
6943 -> 6942;
6943 -> 6925;
6944 -> 6925;
6945 -> 6926;
6945 -> 6944;
6946 -> 6945;
6946 -> 6922;
6946 -> 6944;
6947 -> 6946;
6947 -> 6925;
6948 -> 6925;
6949 -> 6947;
6949 -> 6948;
6950 -> 6943;
6950 -> 6949;
6950 -> 6925;
6951 -> 6950;
6952 -> 6951;
6952 -> 6900;
6953 -> 6902;
6953 -> 6952;
6954 -> 0;
6954 -> 6953;
6955 -> 6952;
6956 -> 6954;
6956 -> 6955;
6957 -> 6904;
6957 -> 6955;
6958 -> 6955;
6959 -> 6957;
6959 -> 6958;
6960 -> 6959;
6960 -> 6955;
6961 -> 6955;
6962 -> 6960;
6962 -> 6961;
6963 -> 6956;
6963 -> 6955;
6964 -> 6963;
6964 -> 6957;
6964 -> 6922;
6964 -> 6955;
6965 -> 6955;
6966 -> 6964;
6966 -> 6965;
6967 -> 6964;
6967 -> 6965;
6968 -> 6964;
6968 -> 6965;
6969 -> 6965;
6970 -> 6968;
6970 -> 6969;
6971 -> 6970;
6971 -> 6965;
6972 -> 6965;
6973 -> 6971;
6973 -> 6972;
6974 -> 6965;
6975 -> 6973;
6975 -> 6974;
6976 -> 6965;
6977 -> 6968;
6977 -> 6976;
6978 -> 6977;
6979 -> 6977;
6980 -> 6978;
6980 -> 6979;
6981 -> 6980;
6981 -> 6977;
6982 -> 6977;
6983 -> 6981;
6983 -> 6982;
6984 -> 6982;
6984 -> 6965;
6985 -> 6967;
6985 -> 6984;
6986 -> 6984;
6987 -> 6985;
6987 -> 6986;
6988 -> 6968;
6988 -> 6986;
6989 -> 6987;
6989 -> 6986;
6990 -> 6986;
6991 -> 6989;
6991 -> 6990;
6992 -> 6988;
6992 -> 6990;
6993 -> 6991;
6993 -> 6990;
6994 -> 6990;
6995 -> 6990;
6996 -> 6992;
6996 -> 6995;
6997 -> 6995;
6998 -> 6996;
6998 -> 6997;
6999 -> 6998;
6999 -> 6995;
7000 -> 6999;
7001 -> 7000;
7001 -> 6990;
7002 -> 6994;
7002 -> 6990;
7003 -> 6992;
7004 -> 6992;
7004 -> 7003;
7005 -> 7003;
7006 -> 7004;
7006 -> 7005;
7007 -> 7006;
7007 -> 7003;
7008 -> 7003;
7008 -> 6992;
7009 -> 6992;
7010 -> 7009;
7010 -> 6992;
7011 -> 7008;
7011 -> 7010;
7011 -> 6992;
7012 -> 6992;
7012 -> 6964;
7013 -> 6992;
7014 -> 6992;
7015 -> 6992;
7016 -> 6992;
7016 -> 7015;
7017 -> 7016;
7017 -> 6964;
7017 -> 6992;
7017 -> 7015;
7018 -> 7017;
7018 -> 6992;
7019 -> 6992;
7019 -> 6990;
7020 -> 6992;
7020 -> 6990;
7021 -> 6992;
7021 -> 6990;
7022 -> 6990;
7023 -> 7021;
7023 -> 7022;
7024 -> 6990;
7025 -> 6992;
7025 -> 7024;
7026 -> 7025;
7026 -> 6990;
7027 -> 6990;
7028 -> 7026;
7028 -> 7027;
7029 -> 6992;
7029 -> 6986;
7030 -> 6986;
7031 -> 6988;
7031 -> 7030;
7032 -> 7031;
7032 -> 6992;
7032 -> 7030;
7033 -> 7032;
7033 -> 6986;
7034 -> 6986;
7035 -> 6988;
7035 -> 7034;
7036 -> 7035;
7036 -> 6992;
7036 -> 7034;
7037 -> 7036;
7037 -> 6986;
7038 -> 6986;
7039 -> 7037;
7039 -> 7038;
7040 -> 7033;
7040 -> 7039;
7040 -> 6986;
7041 -> 7029;
7041 -> 6986;
7042 -> 7041;
7042 -> 6984;
7043 -> 6964;
7043 -> 6965;
7044 -> 6901;
7044 -> 6952;
7045 -> 6952;
7046 -> 7044;
7046 -> 7045;
7047 -> 6904;
7047 -> 7045;
7048 -> 7045;
7049 -> 7047;
7049 -> 7048;
7050 -> 7049;
7050 -> 7042;
7050 -> 7048;
7051 -> 7050;
7051 -> 7045;
7052 -> 7045;
7053 -> 7051;
7053 -> 7052;
7054 -> 7053;
7055 -> 7053;
7056 -> 7054;
7056 -> 7055;
7057 -> 7056;
7057 -> 7055;
7058 -> 7055;
7059 -> 7057;
7059 -> 7058;
7060 -> 7059;
7060 -> 7058;
7061 -> 0;
7061 -> 7060;
7062 -> 7061;
7062 -> 6952;
7063 -> 7042;
7063 -> 6900;
7064 -> 6901;
7064 -> 6900;
7065 -> 6903;
7065 -> 6900;
7066 -> 6900;
7067 -> 7063;
7067 -> 7066;
7068 -> 7064;
7068 -> 7066;
7069 -> 7065;
7069 -> 7066;
7070 -> 6904;
7070 -> 7066;
7071 -> 7066;
7072 -> 7067;
7072 -> 7071;
7073 -> 7072;
7073 -> 7066;
7074 -> 7067;
7074 -> 7073;
7075 -> 7074;
7075 -> 7042;
7075 -> 7073;
7076 -> 7073;
7077 -> 7075;
7077 -> 7076;
7078 -> 7077;
7078 -> 7073;
7079 -> 7066;
7080 -> 7070;
7080 -> 7079;
7081 -> 7080;
7081 -> 7042;
7081 -> 7079;
7082 -> 7081;
7082 -> 7066;
7083 -> 7066;
7084 -> 7082;
7084 -> 7083;
7085 -> 7066;
7086 -> 7066;
7087 -> 7085;
7087 -> 7086;
7088 -> 7070;
7088 -> 7086;
7089 -> 7086;
7090 -> 7086;
7091 -> 7088;
7091 -> 7090;
7092 -> 7091;
7092 -> 7042;
7092 -> 7090;
7093 -> 7092;
7093 -> 7086;
7094 -> 7086;
7095 -> 7093;
7095 -> 7094;
7096 -> 7086;
7097 -> 7096;
7097 -> 7066;
7098 -> 7066;
7099 -> 7067;
7099 -> 7098;
7099 -> 7066;
7100 -> 7069;
7100 -> 7099;
7101 -> 7099;
7102 -> 7099;
7103 -> 7100;
7103 -> 7102;
7104 -> 7101;
7104 -> 7102;
7105 -> 7070;
7105 -> 7102;
7106 -> 7102;
7107 -> 7102;
7108 -> 7105;
7108 -> 7107;
7109 -> 7107;
7110 -> 7109;
7110 -> 7102;
7111 -> 7102;
7112 -> 7111;
7112 -> 7099;
7113 -> 7067;
7113 -> 7112;
7114 -> 7112;
7115 -> 7112;
7116 -> 7113;
7116 -> 7115;
7117 -> 7114;
7117 -> 7115;
7118 -> 7114;
7118 -> 7115;
7119 -> 7070;
7119 -> 7115;
7120 -> 7115;
7121 -> 7116;
7121 -> 7115;
7122 -> 7116;
7122 -> 7042;
7122 -> 7115;
7123 -> 7119;
7123 -> 7042;
7123 -> 7115;
7124 -> 7121;
7124 -> 7122;
7125 -> 7122;
7126 -> 7124;
7126 -> 7125;
7127 -> 7068;
7127 -> 7125;
7128 -> 7125;
7129 -> 7126;
7129 -> 7128;
7130 -> 7127;
7130 -> 7128;
7131 -> 7070;
7131 -> 7128;
7132 -> 7128;
7133 -> 7132;
7134 -> 7131;
7134 -> 7133;
7135 -> 7134;
7135 -> 7132;
7136 -> 7132;
7137 -> 7135;
7137 -> 7136;
7138 -> 7132;
7139 -> 7132;
7140 -> 7137;
7140 -> 7132;
7141 -> 7132;
7142 -> 7140;
7142 -> 7141;
7143 -> 7142;
7143 -> 7141;
7144 -> 7141;
7145 -> 7143;
7145 -> 7144;
7146 -> 7145;
7146 -> 7144;
7147 -> 7144;
7148 -> 7146;
7148 -> 7147;
7149 -> 7148;
7149 -> 7147;
7150 -> 0;
7150 -> 7149;
7151 -> 7137;
7151 -> 7150;
7152 -> 7150;
7153 -> 7151;
7153 -> 7152;
7154 -> 7153;
7154 -> 7152;
7155 -> 7152;
7156 -> 7154;
7156 -> 7155;
7157 -> 7156;
7157 -> 7155;
7158 -> 7157;
7159 -> 7137;
7159 -> 0;
7159 -> 7158;
7160 -> 7137;
7160 -> 0;
7160 -> 7159;
7161 -> 7137;
7161 -> 0;
7161 -> 7160;
7162 -> 7128;
7163 -> 7131;
7163 -> 7162;
7164 -> 7163;
7164 -> 7128;
7165 -> 7128;
7166 -> 7164;
7166 -> 7165;
7167 -> 7129;
7167 -> 7125;
7168 -> 7167;
7168 -> 7070;
7168 -> 7042;
7168 -> 7125;
7169 -> 7125;
7170 -> 7168;
7170 -> 7169;
7171 -> 7168;
7171 -> 7169;
7172 -> 7168;
7172 -> 7169;
7173 -> 7168;
7173 -> 7169;
7174 -> 7170;
7174 -> 7169;
7175 -> 7171;
7175 -> 7169;
7176 -> 7172;
7176 -> 7169;
7177 -> 7169;
7178 -> 7176;
7178 -> 7177;
7179 -> 7178;
7179 -> 7168;
7179 -> 7177;
7180 -> 7178;
7180 -> 7168;
7180 -> 7177;
7181 -> 7177;
7181 -> 7169;
7182 -> 7173;
7182 -> 7169;
7183 -> 7174;
7183 -> 7175;
7183 -> 7181;
7183 -> 7182;
7183 -> 7168;
7183 -> 7169;
7184 -> 7183;
7184 -> 7169;
7185 -> 7183;
7185 -> 7169;
7186 -> 7184;
7186 -> 7169;
7187 -> 7184;
7187 -> 7169;
7188 -> 6900;
7189 -> 7183;
7189 -> 7188;
7189 -> 6900;
7190 -> 7183;
7190 -> 7189;
7191 -> 6923;
7191 -> 7189;
7192 -> 7189;
7193 -> 7191;
7193 -> 7192;
7194 -> 7193;
7194 -> 6922;
7194 -> 7192;
7195 -> 7194;
7195 -> 7192;
7196 -> 7192;
7196 -> 7183;
7196 -> 7195;
7196 -> 6922;
7197 -> 7192;
7198 -> 7192;
7199 -> 7189;
7200 -> 6879;
7201 -> 6883;
7201 -> 7200;
7202 -> 7201;
7202 -> 7183;
7202 -> 7200;
7203 -> 7202;
7203 -> 6879;
7204 -> 6879;
7205 -> 7203;
7205 -> 7204;
7206 -> 7190;
7206 -> 6879;
7207 -> 6871;
7208 -> 6875;
7208 -> 7207;
7209 -> 7208;
7209 -> 7183;
7209 -> 7207;
7210 -> 7209;
7210 -> 6871;
7211 -> 6871;
7212 -> 7210;
7212 -> 7211;
7213 -> 7206;
7213 -> 6871;
7214 -> 7213;
7214 -> 6859;
7215 -> 7213;
7215 -> 6859;
7216 -> 7215;
7216 -> 6857;
7217 -> 6857;
7218 -> 7216;
7218 -> 7217;
7219 -> 6858;
7219 -> 7217;
7220 -> 7217;
7221 -> 7218;
7221 -> 7220;
7222 -> 7221;
7222 -> 7217;
7223 -> 7218;
7223 -> 7222;
7224 -> 7223;
7224 -> 6856;
7225 -> 6856;
7226 -> 7225;
7226 -> 7183;
7227 -> 7226;
7227 -> 6856;
7228 -> 6856;
7229 -> 7227;
7229 -> 7228;
7230 -> 6856;
7231 -> 7224;
7231 -> 7230;
7232 -> 7231;
7232 -> 6856;
7233 -> 7224;
7233 -> 6856;
7234 -> 0;
7234 -> 7233;
7235 -> 7233;
7236 -> 7234;
7236 -> 7235;
7237 -> 7236;
7237 -> 7235;
7238 -> 7235;
7239 -> 7237;
7239 -> 7238;
7240 -> 7239;
7240 -> 0;
7240 -> 7238;
7241 -> 7240;
7242 -> 7236;
7243 -> 7236;
7244 -> 6850;
7244 -> 7233;
7245 -> 7224;
7245 -> 7233;
7246 -> 7236;
7246 -> 7233;
7247 -> 7244;
7247 -> 7245;
7247 -> 7246;
7247 -> 6831;
7247 -> 7183;
7247 -> 7192;
7247 -> 7236;
7247 -> 7233;
7248 -> 7233;
7249 -> 7247;
7249 -> 7248;
7250 -> 7249;
7250 -> 7248;
7251 -> 7250;
7251 -> 7247;
7251 -> 7248;
7252 -> 7250;
7252 -> 7247;
7252 -> 7248;
7253 -> 7249;
7253 -> 7248;
7254 -> 7249;
7254 -> 7248;
7255 -> 7253;
7255 -> 7248;
7256 -> 7253;
7256 -> 7248;
7257 -> 7249;
7257 -> 6830;
7258 -> 6830;
7259 -> 6831;
7259 -> 7258;
7260 -> 7259;
7260 -> 7257;
7260 -> 7258;
7261 -> 7259;
7261 -> 7257;
7261 -> 7258;
7262 -> 7258;
7263 -> 7259;
7263 -> 7262;
7264 -> 7263;
7264 -> 7257;
7264 -> 7261;
7264 -> 7262;
7265 -> 7258;
7266 -> 7264;
7266 -> 7265;
7267 -> 7266;
7267 -> 6830;
7268 -> 6830;
7269 -> 6835;
7269 -> 7257;
7269 -> 7268;
7269 -> 6830;
7270 -> 6835;
7270 -> 7269;
7270 -> 7257;
7270 -> 7261;
7270 -> 6830;
7271 -> 7270;
7271 -> 6830;
7272 -> 6836;
7272 -> 6830;
7273 -> 6830;
7274 -> 6830;
7275 -> 7271;
7275 -> 7274;
7276 -> 7272;
7276 -> 7274;
7277 -> 7273;
7277 -> 7274;
7278 -> 6831;
7278 -> 7274;
7279 -> 7278;
7279 -> 7270;
7279 -> 7274;
7280 -> 7278;
7280 -> 7270;
7280 -> 0;
7280 -> 7274;
7281 -> 7280;
7281 -> 7278;
7281 -> 7274;
7282 -> 7277;
7282 -> 7274;
7283 -> 7278;
7283 -> 7270;
7283 -> 7281;
7283 -> 0;
7283 -> 7282;
7284 -> 7283;
7284 -> 7278;
7284 -> 7282;
7285 -> 7274;
7286 -> 7274;
7287 -> 7278;
7287 -> 7286;
7288 -> 7287;
7288 -> 7270;
7288 -> 7286;
7289 -> 7288;
7289 -> 7274;
7290 -> 7274;
7291 -> 7289;
7291 -> 7290;
7292 -> 7274;
7293 -> 7278;
7293 -> 7292;
7294 -> 7293;
7294 -> 7270;
7294 -> 7292;
7295 -> 7294;
7295 -> 7274;
7296 -> 7274;
7297 -> 7295;
7297 -> 7296;
7298 -> 7291;
7298 -> 7297;
7298 -> 7274;
7299 -> 7274;
7300 -> 7278;
7300 -> 7299;
7301 -> 7300;
7301 -> 7270;
7301 -> 7299;
7302 -> 7299;
7303 -> 7300;
7303 -> 7302;
7304 -> 7303;
7304 -> 7270;
7304 -> 7302;
7305 -> 7299;
7306 -> 7304;
7306 -> 7305;
7307 -> 7306;
7307 -> 7274;
7308 -> 7277;
7308 -> 7307;
7308 -> 7274;
7309 -> 7298;
7309 -> 7308;
7309 -> 7274;
7310 -> 7285;
7310 -> 7274;
7311 -> 7274;
7312 -> 7274;
7313 -> 7310;
7313 -> 7312;
7314 -> 7311;
7314 -> 7312;
7315 -> 7278;
7315 -> 7312;
7316 -> 7315;
7316 -> 7270;
7316 -> 7312;
7317 -> 7316;
7317 -> 7313;
7317 -> 7312;
7318 -> 7309;
7318 -> 7317;
7318 -> 7274;
7319 -> 7318;
7320 -> 7318;
7321 -> 7319;
7321 -> 7320;
7322 -> 7278;
7322 -> 7320;
7323 -> 7320;
7324 -> 7322;
7324 -> 7323;
7325 -> 7324;
7325 -> 7320;
7326 -> 7320;
7327 -> 7325;
7327 -> 7326;
7328 -> 7327;
7328 -> 7320;
7329 -> 7328;
7330 -> 7329;
7331 -> 7329;
7332 -> 7330;
7332 -> 7331;
7333 -> 7332;
7333 -> 7329;
7334 -> 7329;
7334 -> 7270;
7334 -> 7281;
7334 -> 7284;
7335 -> 7334;
7335 -> 7328;
7336 -> 7335;
7336 -> 7318;
7337 -> 7336;
7338 -> 7337;
7339 -> 7337;
7340 -> 7338;
7340 -> 7339;
7341 -> 7340;
7341 -> 7337;
7342 -> 7337;
7343 -> 7342;
7343 -> 7337;
7344 -> 7337;
7345 -> 7343;
7345 -> 7337;
7346 -> 7344;
7346 -> 7337;
7347 -> 7345;
7347 -> 7337;
7348 -> 7337;
7349 -> 7346;
7349 -> 7348;
7350 -> 7347;
7350 -> 7348;
7351 -> 7337;
7351 -> 7348;
7352 -> 7348;
7353 -> 7351;
7353 -> 7352;
7354 -> 7352;
7355 -> 7353;
7355 -> 7354;
7356 -> 7355;
7356 -> 7352;
7357 -> 7356;
7358 -> 7357;
7358 -> 7348;
7359 -> 7358;
7359 -> 7337;
7360 -> 7337;
7361 -> 7337;
7362 -> 7337;
7363 -> 7344;
7363 -> 7337;
7364 -> 7345;
7364 -> 7337;
7365 -> 7337;
7366 -> 7363;
7366 -> 7365;
7367 -> 7364;
7367 -> 7365;
7368 -> 7337;
7368 -> 7365;
7369 -> 7365;
7370 -> 7368;
7370 -> 7369;
7371 -> 7370;
7371 -> 7365;
7372 -> 7365;
7373 -> 7371;
7373 -> 7372;
7374 -> 7373;
7375 -> 7368;
7375 -> 7374;
7376 -> 7374;
7377 -> 7375;
7377 -> 7376;
7378 -> 7374;
7379 -> 7377;
7379 -> 7378;
7380 -> 7379;
7380 -> 0;
7380 -> 7374;
7381 -> 7380;
7381 -> 7374;
7382 -> 7381;
7382 -> 7373;
7383 -> 7382;
7384 -> 7368;
7384 -> 7383;
7385 -> 7383;
7386 -> 7383;
7387 -> 7385;
7387 -> 7386;
7388 -> 7384;
7388 -> 7386;
7389 -> 7386;
7390 -> 7387;
7390 -> 7389;
7390 -> 7386;
7391 -> 7388;
7391 -> 7337;
7391 -> 7387;
7391 -> 7386;
7392 -> 7388;
7392 -> 7337;
7392 -> 7387;
7393 -> 7383;
7394 -> 7392;
7394 -> 7393;
7395 -> 7394;
7395 -> 7382;
7396 -> 7395;
7397 -> 7368;
7397 -> 7396;
7398 -> 7396;
7399 -> 7397;
7399 -> 7398;
7400 -> 7399;
7400 -> 7396;
7401 -> 7396;
7402 -> 7400;
7402 -> 7401;
7403 -> 7402;
7403 -> 7395;
7404 -> 7403;
7405 -> 7368;
7405 -> 7404;
7406 -> 7404;
7407 -> 7405;
7407 -> 7406;
7408 -> 7406;
7409 -> 7407;
7409 -> 7408;
7410 -> 7408;
7411 -> 7409;
7411 -> 7337;
7411 -> 7410;
7412 -> 7411;
7412 -> 7337;
7412 -> 7410;
7413 -> 7412;
7413 -> 7408;
7414 -> 7413;
7414 -> 7406;
7415 -> 7414;
7415 -> 7404;
7416 -> 7404;
7417 -> 7405;
7417 -> 7416;
7418 -> 7417;
7418 -> 7337;
7418 -> 7416;
7419 -> 7418;
7419 -> 7404;
7420 -> 7415;
7420 -> 7419;
7420 -> 7404;
7421 -> 7420;
7421 -> 7403;
7422 -> 7421;
7423 -> 7367;
7423 -> 7421;
7424 -> 7421;
7425 -> 7422;
7425 -> 7424;
7426 -> 7423;
7426 -> 7424;
7427 -> 7368;
7427 -> 7424;
7428 -> 7424;
7429 -> 7427;
7429 -> 7428;
7430 -> 7429;
7430 -> 7424;
7431 -> 7424;
7432 -> 7430;
7432 -> 7431;
7433 -> 7424;
7433 -> 7421;
7434 -> 7365;
7435 -> 7434;
7435 -> 7337;
7436 -> 7337;
7437 -> 7435;
7437 -> 7436;
7437 -> 7337;
7438 -> 7344;
7438 -> 7337;
7439 -> 7345;
7439 -> 7337;
7440 -> 7360;
7440 -> 7337;
7441 -> 7337;
7442 -> 7438;
7442 -> 7441;
7443 -> 7439;
7443 -> 7441;
7444 -> 7440;
7444 -> 7441;
7445 -> 7337;
7445 -> 7441;
7446 -> 7443;
7446 -> 7441;
7447 -> 7446;
7447 -> 7441;
7448 -> 7441;
7449 -> 7447;
7449 -> 7448;
7450 -> 7445;
7450 -> 7448;
7451 -> 7448;
7452 -> 7450;
7452 -> 7451;
7453 -> 7452;
7453 -> 7448;
7454 -> 7448;
7455 -> 7453;
7455 -> 7454;
7456 -> 7455;
7456 -> 0;
7456 -> 7448;
7457 -> 7455;
7457 -> 7448;
7458 -> 7448;
7459 -> 7457;
7459 -> 7458;
7460 -> 7459;
7460 -> 7458;
7461 -> 7460;
7462 -> 7448;
7463 -> 7457;
7463 -> 7462;
7464 -> 7461;
7464 -> 7463;
7464 -> 7448;
7465 -> 7455;
7465 -> 0;
7465 -> 7448;
7466 -> 7448;
7467 -> 7450;
7467 -> 7466;
7468 -> 7466;
7469 -> 7467;
7469 -> 7468;
7470 -> 7466;
7471 -> 7469;
7471 -> 7470;
7472 -> 7471;
7472 -> 0;
7472 -> 7466;
7473 -> 7472;
7473 -> 7466;
7474 -> 7473;
7474 -> 7448;
7475 -> 7448;
7476 -> 7450;
7476 -> 7475;
7477 -> 7476;
7477 -> 7448;
7478 -> 7448;
7479 -> 7477;
7479 -> 7478;
7480 -> 7479;
7480 -> 7448;
7481 -> 7448;
7482 -> 7480;
7482 -> 7481;
7483 -> 7482;
7483 -> 7481;
7484 -> 7483;
7485 -> 7479;
7485 -> 0;
7485 -> 7448;
7486 -> 7484;
7486 -> 7448;
7487 -> 7449;
7487 -> 7448;
7488 -> 7448;
7489 -> 7487;
7489 -> 7488;
7490 -> 7450;
7490 -> 7488;
7491 -> 7488;
7492 -> 7490;
7492 -> 7491;
7493 -> 7492;
7493 -> 7488;
7494 -> 7488;
7495 -> 7488;
7496 -> 7494;
7496 -> 7495;
7497 -> 7490;
7497 -> 7495;
7498 -> 7495;
7499 -> 7496;
7499 -> 7498;
7499 -> 7495;
7500 -> 7497;
7500 -> 7337;
7500 -> 7496;
7500 -> 7495;
7501 -> 7497;
7501 -> 7337;
7501 -> 7496;
7502 -> 7488;
7503 -> 7493;
7503 -> 7502;
7504 -> 7501;
7504 -> 7502;
7505 -> 7494;
7505 -> 7502;
7506 -> 7490;
7506 -> 7502;
7507 -> 7503;
7507 -> 7502;
7508 -> 7502;
7509 -> 7507;
7509 -> 7508;
7510 -> 7506;
7510 -> 7508;
7511 -> 7508;
7512 -> 7509;
7512 -> 7511;
7513 -> 7512;
7513 -> 7508;
7514 -> 7508;
7515 -> 7510;
7515 -> 7514;
7516 -> 7515;
7516 -> 7508;
7517 -> 7513;
7517 -> 7516;
7517 -> 7508;
7518 -> 7517;
7519 -> 7504;
7519 -> 7518;
7520 -> 7519;
7520 -> 7517;
7521 -> 7503;
7521 -> 7520;
7522 -> 7520;
7523 -> 7521;
7523 -> 7522;
7524 -> 7523;
7525 -> 7488;
7526 -> 7524;
7526 -> 7525;
7526 -> 7488;
7527 -> 7524;
7527 -> 7526;
7528 -> 7527;
7528 -> 7448;
7529 -> 7528;
7529 -> 7441;
7530 -> 7442;
7530 -> 7529;
7531 -> 7529;
7532 -> 7530;
7532 -> 7531;
7533 -> 7445;
7533 -> 7531;
7534 -> 7532;
7534 -> 7531;
7535 -> 7531;
7536 -> 7533;
7536 -> 7535;
7537 -> 7536;
7537 -> 7337;
7537 -> 7535;
7538 -> 7535;
7539 -> 7535;
7540 -> 7536;
7540 -> 7535;
7541 -> 7535;
7542 -> 7540;
7542 -> 7541;
7543 -> 7542;
7543 -> 7541;
7544 -> 7543;
7545 -> 7536;
7546 -> 7536;
7547 -> 7545;
7547 -> 7546;
7548 -> 7547;
7548 -> 7536;
7549 -> 7536;
7550 -> 7536;
7551 -> 7536;
7552 -> 7536;
7553 -> 7551;
7553 -> 7552;
7554 -> 7553;
7554 -> 7536;
7555 -> 7536;
7556 -> 7554;
7556 -> 7555;
7557 -> 7555;
7558 -> 7555;
7559 -> 7557;
7559 -> 7558;
7560 -> 7559;
7560 -> 7555;
7561 -> 7555;
7562 -> 7555;
7563 -> 7561;
7563 -> 7562;
7564 -> 7562;
7565 -> 7563;
7565 -> 7564;
7565 -> 7562;
7566 -> 7562;
7566 -> 7337;
7566 -> 7563;
7567 -> 7555;
7568 -> 7563;
7568 -> 7567;
7569 -> 7555;
7570 -> 7561;
7570 -> 7569;
7571 -> 7569;
7572 -> 7570;
7572 -> 7571;
7572 -> 7569;
7573 -> 7569;
7573 -> 7337;
7573 -> 7570;
7574 -> 7555;
7575 -> 7570;
7575 -> 7574;
7576 -> 7568;
7576 -> 7575;
7576 -> 7555;
7577 -> 7555;
7578 -> 7562;
7578 -> 7337;
7578 -> 7555;
7579 -> 7562;
7580 -> 7562;
7581 -> 7580;
7581 -> 7562;
7582 -> 7562;
7583 -> 7581;
7583 -> 7582;
7584 -> 7562;
7585 -> 7584;
7585 -> 7562;
7586 -> 7562;
7587 -> 7585;
7587 -> 7586;
7588 -> 7583;
7588 -> 7587;
7588 -> 7562;
7589 -> 7579;
7589 -> 0;
7589 -> 7562;
7590 -> 7562;
7591 -> 7562;
7592 -> 7580;
7593 -> 7580;
7593 -> 7562;
7594 -> 7562;
7595 -> 7593;
7595 -> 7594;
7596 -> 7594;
7597 -> 7595;
7597 -> 7596;
7597 -> 7594;
7598 -> 7594;
7598 -> 7337;
7598 -> 7595;
7599 -> 7562;
7600 -> 7595;
7600 -> 7599;
7601 -> 7580;
7601 -> 7562;
7602 -> 7562;
7603 -> 7601;
7603 -> 7602;
7604 -> 7602;
7605 -> 7603;
7605 -> 7604;
7605 -> 7602;
7606 -> 7602;
7606 -> 7337;
7606 -> 7603;
7607 -> 7562;
7608 -> 7603;
7608 -> 7607;
7609 -> 7562;
7610 -> 7580;
7610 -> 7609;
7610 -> 7562;
7611 -> 7562;
7612 -> 7610;
7612 -> 7611;
7613 -> 7611;
7614 -> 7612;
7614 -> 7613;
7614 -> 7611;
7615 -> 7611;
7615 -> 7337;
7615 -> 7612;
7616 -> 7562;
7617 -> 7612;
7617 -> 7616;
7618 -> 7608;
7618 -> 7617;
7618 -> 7562;
7619 -> 7580;
7619 -> 7562;
7620 -> 7562;
7621 -> 7619;
7621 -> 7620;
7622 -> 7620;
7623 -> 7621;
7623 -> 7622;
7623 -> 7620;
7624 -> 7620;
7624 -> 7337;
7624 -> 7621;
7625 -> 7562;
7626 -> 7621;
7626 -> 7625;
7627 -> 7580;
7627 -> 7564;
7627 -> 7562;
7628 -> 7594;
7628 -> 7337;
7628 -> 7580;
7628 -> 7562;
7629 -> 7594;
7629 -> 7337;
7629 -> 7580;
7630 -> 7629;
7631 -> 7630;
7631 -> 7629;
7632 -> 7629;
7633 -> 7629;
7634 -> 7629;
7634 -> 7633;
7635 -> 7633;
7636 -> 7634;
7636 -> 7635;
7637 -> 7636;
7637 -> 7633;
7638 -> 7637;
7639 -> 7638;
7639 -> 7629;
7640 -> 7632;
7640 -> 7629;
7641 -> 7629;
7642 -> 7629;
7642 -> 7641;
7643 -> 7641;
7644 -> 7642;
7644 -> 7643;
7645 -> 7644;
7645 -> 7641;
7646 -> 7641;
7646 -> 7629;
7647 -> 7629;
7648 -> 7647;
7648 -> 7629;
7649 -> 7646;
7649 -> 7648;
7649 -> 7629;
7650 -> 7629;
7650 -> 7337;
7651 -> 7629;
7652 -> 7629;
7653 -> 7629;
7654 -> 7629;
7654 -> 7653;
7655 -> 7654;
7655 -> 7337;
7655 -> 7536;
7655 -> 7629;
7655 -> 7653;
7656 -> 7655;
7656 -> 7629;
7657 -> 7632;
7657 -> 7629;
7658 -> 7629;
7658 -> 7632;
7659 -> 7632;
7659 -> 7629;
7660 -> 7629;
7661 -> 7659;
7661 -> 7660;
7662 -> 7629;
7663 -> 7662;
7663 -> 7632;
7664 -> 7663;
7664 -> 7629;
7665 -> 7629;
7666 -> 7664;
7666 -> 7665;
7667 -> 7632;
7667 -> 7555;
7668 -> 7555;
7669 -> 7667;
7669 -> 7668;
7670 -> 7668;
7671 -> 7669;
7671 -> 7670;
7672 -> 7671;
7672 -> 7668;
7673 -> 7672;
7674 -> 7673;
7674 -> 7555;
7675 -> 7555;
7676 -> 0;
7676 -> 7555;
7677 -> 7675;
7677 -> 7676;
7677 -> 7667;
7677 -> 7632;
7677 -> 7555;
7678 -> 7677;
7678 -> 7675;
7679 -> 7677;
7679 -> 7675;
7680 -> 7678;
7680 -> 7675;
7681 -> 7675;
7682 -> 7680;
7682 -> 7681;
7683 -> 7682;
7683 -> 0;
7683 -> 7681;
7684 -> 7683;
7685 -> 7675;
7686 -> 7679;
7686 -> 7685;
7687 -> 7686;
7687 -> 7675;
7688 -> 7675;
7689 -> 7687;
7689 -> 7688;
7690 -> 7689;
7690 -> 7675;
7691 -> 7690;
7691 -> 7678;
7691 -> 7675;
7692 -> 7691;
7693 -> 7692;
7693 -> 7677;
7694 -> 7692;
7695 -> 7691;
7696 -> 7687;
7696 -> 7691;
7697 -> 7677;
7697 -> 7696;
7697 -> 7692;
7697 -> 7555;
7698 -> 7677;
7698 -> 7697;
7698 -> 7675;
7699 -> 7697;
7700 -> 7697;
7701 -> 7697;
7702 -> 7697;
7702 -> 7555;
7703 -> 7555;
7704 -> 7702;
7704 -> 7703;
7705 -> 7704;
7705 -> 7702;
7705 -> 7703;
7706 -> 7704;
7706 -> 7702;
7706 -> 7703;
7707 -> 7702;
7707 -> 7703;
7708 -> 7702;
7708 -> 7703;
7709 -> 7707;
7709 -> 7703;
7710 -> 7707;
7710 -> 7703;
7711 -> 7632;
7711 -> 7555;
7712 -> 7632;
7712 -> 7555;
7713 -> 7632;
7713 -> 7555;
7714 -> 7632;
7714 -> 7555;
7715 -> 7632;
7715 -> 7555;
7716 -> 7711;
7716 -> 7555;
7717 -> 7712;
7717 -> 7555;
7718 -> 7713;
7718 -> 7555;
7719 -> 7714;
7719 -> 7555;
7720 -> 7555;
7721 -> 7719;
7721 -> 7720;
7722 -> 7721;
7722 -> 7702;
7722 -> 7720;
7723 -> 7721;
7723 -> 7702;
7723 -> 7720;
7724 -> 7720;
7724 -> 7555;
7725 -> 7715;
7725 -> 7555;
7726 -> 7716;
7726 -> 7717;
7726 -> 7718;
7726 -> 7724;
7726 -> 7725;
7726 -> 7702;
7726 -> 7555;
7727 -> 7726;
7727 -> 7555;
7728 -> 7726;
7728 -> 7555;
7729 -> 7727;
7729 -> 7555;
7730 -> 7727;
7730 -> 7555;
7731 -> 7726;
7731 -> 7675;
7732 -> 7535;
7733 -> 7536;
7733 -> 7535;
7734 -> 7535;
7735 -> 7734;
7736 -> 7733;
7736 -> 7735;
7737 -> 7736;
7737 -> 7726;
7737 -> 7735;
7738 -> 7737;
7738 -> 7734;
7739 -> 7734;
7740 -> 7738;
7740 -> 7739;
7741 -> 7734;
7742 -> 7734;
7743 -> 7740;
7743 -> 7734;
7744 -> 7734;
7745 -> 7743;
7745 -> 7744;
7746 -> 7745;
7746 -> 7744;
7747 -> 7744;
7748 -> 7746;
7748 -> 7747;
7749 -> 7748;
7749 -> 7747;
7750 -> 7747;
7751 -> 7749;
7751 -> 7750;
7752 -> 7751;
7752 -> 7750;
7753 -> 0;
7753 -> 7752;
7754 -> 7740;
7754 -> 7753;
7755 -> 7753;
7756 -> 7754;
7756 -> 7755;
7757 -> 7756;
7757 -> 7755;
7758 -> 7755;
7759 -> 7757;
7759 -> 7758;
7760 -> 7759;
7760 -> 7758;
7761 -> 7760;
7762 -> 7740;
7762 -> 0;
7762 -> 7761;
7763 -> 7740;
7763 -> 0;
7763 -> 7762;
7764 -> 7740;
7764 -> 0;
7764 -> 7763;
7765 -> 7535;
7766 -> 7733;
7766 -> 7765;
7767 -> 7766;
7767 -> 7726;
7767 -> 7765;
7768 -> 7767;
7768 -> 7535;
7769 -> 7535;
7770 -> 7768;
7770 -> 7769;
7771 -> 7535;
7772 -> 7535;
7773 -> 7726;
7773 -> 7772;
7774 -> 7773;
7774 -> 7535;
7775 -> 7535;
7776 -> 7774;
7776 -> 7775;
7777 -> 7776;
7777 -> 7775;
7778 -> 0;
7778 -> 7777;
7779 -> 7726;
7779 -> 7531;
7780 -> 7531;
7781 -> 7534;
7781 -> 7780;
7782 -> 7779;
7782 -> 7780;
7783 -> 7533;
7783 -> 7780;
7784 -> 7780;
7785 -> 7780;
7786 -> 7783;
7786 -> 7785;
7787 -> 7785;
7788 -> 7786;
7788 -> 7787;
7789 -> 7787;
7790 -> 7788;
7790 -> 7726;
7790 -> 7789;
7791 -> 7790;
7791 -> 7726;
7791 -> 7789;
7792 -> 7791;
7792 -> 7787;
7793 -> 7792;
7793 -> 7785;
7794 -> 7793;
7794 -> 7780;
7795 -> 0;
7795 -> 7794;
7796 -> 7794;
7797 -> 7795;
7797 -> 7796;
7798 -> 7797;
7798 -> 7796;
7799 -> 7796;
7800 -> 7798;
7800 -> 7799;
7801 -> 7800;
7801 -> 0;
7801 -> 7799;
7802 -> 7801;
7803 -> 7797;
7804 -> 7797;
7805 -> 7781;
7805 -> 7780;
7806 -> 7782;
7806 -> 7780;
7807 -> 7797;
7807 -> 7780;
7808 -> 7805;
7808 -> 7806;
7808 -> 7807;
7808 -> 7783;
7808 -> 7726;
7808 -> 7337;
7808 -> 7797;
7808 -> 7780;
7809 -> 7780;
7810 -> 7808;
7810 -> 7809;
7811 -> 7810;
7811 -> 7808;
7811 -> 7809;
7812 -> 7810;
7812 -> 7808;
7812 -> 7809;
7813 -> 7808;
7813 -> 7809;
7814 -> 7808;
7814 -> 7809;
7815 -> 7813;
7815 -> 7809;
7816 -> 7813;
7816 -> 7809;
7817 -> 7337;
7817 -> 7808;
7818 -> 7444;
7818 -> 7337;
7819 -> 7337;
7820 -> 7818;
7820 -> 7819;
7821 -> 7820;
7821 -> 7337;
7821 -> 7819;
7822 -> 7821;
7822 -> 7819;
7823 -> 7819;
7823 -> 7808;
7823 -> 7822;
7823 -> 7337;
7824 -> 7819;
7824 -> 7808;
7825 -> 7819;
7826 -> 7819;
7826 -> 7808;
7826 -> 7824;
7826 -> 7825;
7827 -> 7819;
7828 -> 7337;
7829 -> 7808;
7829 -> 7336;
7830 -> 7336;
7831 -> 7829;
7831 -> 7830;
7831 -> 7336;
7832 -> 7829;
7832 -> 7831;
7833 -> 7276;
7833 -> 7832;
7833 -> 6836;
7833 -> 7808;
7833 -> 7817;
7833 -> 7824;
7833 -> 7831;
7834 -> 7318;
7834 -> 7833;
7835 -> 7833;
7836 -> 7833;
7837 -> 7833;
7838 -> 7833;
7839 -> 7837;
7839 -> 7838;
7840 -> 7839;
7840 -> 7833;
7841 -> 7833;
7842 -> 7833;
7843 -> 7841;
7843 -> 7842;
7844 -> 7843;
7844 -> 7833;
7845 -> 7833;
7846 -> 7845;
7846 -> 7833;
7847 -> 7846;
7847 -> 7833;
7848 -> 7833;
7849 -> 7847;
7849 -> 7833;
7850 -> 7833;
7851 -> 7848;
7851 -> 7850;
7852 -> 7849;
7852 -> 7850;
7853 -> 7833;
7853 -> 7850;
7854 -> 7850;
7855 -> 7853;
7855 -> 7854;
7856 -> 7854;
7857 -> 7855;
7857 -> 7856;
7858 -> 7857;
7858 -> 7854;
7859 -> 7858;
7860 -> 7859;
7860 -> 7850;
7861 -> 7860;
7861 -> 7833;
7862 -> 7833;
7863 -> 7833;
7864 -> 7833;
7865 -> 7833;
7866 -> 7847;
7866 -> 7833;
7867 -> 7833;
7868 -> 7865;
7868 -> 7867;
7869 -> 7866;
7869 -> 7867;
7870 -> 7833;
7870 -> 7867;
7871 -> 7867;
7872 -> 7870;
7872 -> 7871;
7873 -> 7872;
7873 -> 7867;
7874 -> 7867;
7875 -> 7873;
7875 -> 7874;
7876 -> 7875;
7877 -> 7870;
7877 -> 7876;
7878 -> 7876;
7879 -> 7877;
7879 -> 7878;
7880 -> 7876;
7881 -> 7879;
7881 -> 7880;
7882 -> 7881;
7882 -> 0;
7882 -> 7876;
7883 -> 7882;
7883 -> 7876;
7884 -> 7883;
7884 -> 7875;
7885 -> 7884;
7886 -> 7870;
7886 -> 7885;
7887 -> 7885;
7888 -> 7885;
7889 -> 7887;
7889 -> 7888;
7890 -> 7886;
7890 -> 7888;
7891 -> 7888;
7892 -> 7889;
7892 -> 7891;
7892 -> 7888;
7893 -> 7890;
7893 -> 7833;
7893 -> 7889;
7893 -> 7888;
7894 -> 7890;
7894 -> 7833;
7894 -> 7889;
7895 -> 7885;
7896 -> 7894;
7896 -> 7895;
7897 -> 7896;
7897 -> 7884;
7898 -> 7897;
7899 -> 7870;
7899 -> 7898;
7900 -> 7898;
7901 -> 7899;
7901 -> 7900;
7902 -> 7901;
7902 -> 7898;
7903 -> 7898;
7904 -> 7902;
7904 -> 7903;
7905 -> 7904;
7905 -> 7897;
7906 -> 7905;
7907 -> 7870;
7907 -> 7906;
7908 -> 7906;
7909 -> 7907;
7909 -> 7908;
7910 -> 7909;
7910 -> 7906;
7911 -> 7906;
7912 -> 7907;
7912 -> 7911;
7913 -> 7912;
7913 -> 7833;
7913 -> 7911;
7914 -> 7913;
7914 -> 7906;
7915 -> 7910;
7915 -> 7914;
7915 -> 7906;
7916 -> 7915;
7916 -> 7905;
7917 -> 7916;
7918 -> 7869;
7918 -> 7916;
7919 -> 7916;
7920 -> 7917;
7920 -> 7919;
7921 -> 7918;
7921 -> 7919;
7922 -> 7870;
7922 -> 7919;
7923 -> 7919;
7924 -> 7922;
7924 -> 7923;
7925 -> 7924;
7925 -> 7919;
7926 -> 7919;
7926 -> 7916;
7927 -> 7867;
7928 -> 7927;
7928 -> 7833;
7929 -> 7833;
7930 -> 7928;
7930 -> 7929;
7930 -> 7833;
7931 -> 7847;
7931 -> 7833;
7932 -> 7862;
7932 -> 7833;
7933 -> 7931;
7933 -> 7833;
7934 -> 7933;
7934 -> 7833;
7935 -> 7833;
7936 -> 7935;
7936 -> 7833;
7937 -> 7833;
7938 -> 7936;
7938 -> 7937;
7939 -> 7938;
7939 -> 0;
7939 -> 7833;
7940 -> 7938;
7940 -> 7833;
7941 -> 7833;
7942 -> 7940;
7942 -> 7941;
7943 -> 7942;
7943 -> 7941;
7944 -> 7943;
7945 -> 7833;
7946 -> 7940;
7946 -> 7945;
7947 -> 7944;
7947 -> 7946;
7947 -> 7833;
7948 -> 7938;
7948 -> 0;
7948 -> 7833;
7949 -> 7833;
7950 -> 7833;
7950 -> 7949;
7951 -> 7949;
7952 -> 7950;
7952 -> 7951;
7953 -> 7949;
7954 -> 7952;
7954 -> 7953;
7955 -> 7954;
7955 -> 0;
7955 -> 7949;
7956 -> 7955;
7956 -> 7949;
7957 -> 7956;
7957 -> 7833;
7958 -> 7833;
7959 -> 7958;
7959 -> 7833;
7960 -> 7833;
7961 -> 7959;
7961 -> 7960;
7962 -> 7961;
7962 -> 7833;
7963 -> 7833;
7964 -> 7962;
7964 -> 7963;
7965 -> 7964;
7965 -> 7963;
7966 -> 7965;
7967 -> 7961;
7967 -> 0;
7967 -> 7833;
7968 -> 7966;
7968 -> 7833;
7969 -> 7934;
7969 -> 7833;
7970 -> 7833;
7971 -> 7935;
7971 -> 7970;
7971 -> 7833;
7972 -> 7833;
7972 -> 7935;
7973 -> 7935;
7973 -> 7833;
7974 -> 7935;
7974 -> 7833;
7975 -> 7935;
7976 -> 7935;
7977 -> 7935;
7978 -> 7935;
7979 -> 7977;
7979 -> 7978;
7980 -> 7979;
7980 -> 7978;
7981 -> 7980;
7982 -> 7935;
7983 -> 7935;
7984 -> 7982;
7984 -> 7983;
7985 -> 7984;
7985 -> 7935;
7986 -> 7935;
7987 -> 7935;
7988 -> 7935;
7989 -> 7935;
7990 -> 7988;
7990 -> 7989;
7991 -> 7990;
7991 -> 7935;
7992 -> 7935;
7993 -> 7935;
7994 -> 7992;
7994 -> 7993;
7995 -> 7994;
7995 -> 7935;
7996 -> 7935;
7997 -> 7935;
7998 -> 7996;
7998 -> 7997;
7998 -> 7935;
7999 -> 7935;
7999 -> 7833;
7999 -> 7996;
8000 -> 7935;
8001 -> 7996;
8001 -> 8000;
8002 -> 7935;
8003 -> 7996;
8003 -> 8002;
8004 -> 8002;
8005 -> 8003;
8005 -> 8004;
8005 -> 8002;
8006 -> 8002;
8006 -> 7833;
8006 -> 8003;
8007 -> 7935;
8008 -> 8003;
8008 -> 8007;
8009 -> 8001;
8009 -> 8008;
8009 -> 7935;
8010 -> 8002;
8010 -> 7833;
8010 -> 7996;
8010 -> 7935;
8011 -> 8002;
8011 -> 7833;
8011 -> 7996;
8012 -> 8011;
8013 -> 8011;
8014 -> 8011;
8015 -> 8013;
8015 -> 8014;
8016 -> 8011;
8017 -> 8016;
8017 -> 8011;
8018 -> 8011;
8019 -> 8017;
8019 -> 8018;
8020 -> 8015;
8020 -> 8019;
8020 -> 8011;
8021 -> 8012;
8021 -> 0;
8021 -> 8011;
8022 -> 8011;
8023 -> 8011;
8024 -> 8016;
8025 -> 8016;
8025 -> 8011;
8026 -> 8011;
8027 -> 8025;
8027 -> 8026;
8027 -> 8011;
8028 -> 8011;
8028 -> 7833;
8028 -> 8025;
8029 -> 8011;
8030 -> 8025;
8030 -> 8029;
8031 -> 8016;
8031 -> 8011;
8032 -> 8011;
8033 -> 8031;
8033 -> 8032;
8034 -> 8032;
8035 -> 8033;
8035 -> 8034;
8035 -> 8032;
8036 -> 8032;
8036 -> 7833;
8036 -> 8033;
8037 -> 8011;
8038 -> 8033;
8038 -> 8037;
8039 -> 8011;
8040 -> 8016;
8040 -> 8039;
8040 -> 8011;
8041 -> 8011;
8042 -> 8040;
8042 -> 8041;
8043 -> 8041;
8044 -> 8042;
8044 -> 8043;
8044 -> 8041;
8045 -> 8041;
8045 -> 7833;
8045 -> 8042;
8046 -> 8011;
8047 -> 8042;
8047 -> 8046;
8048 -> 8038;
8048 -> 8047;
8048 -> 8011;
8049 -> 8016;
8049 -> 8011;
8050 -> 8011;
8051 -> 8049;
8051 -> 8050;
8052 -> 8050;
8053 -> 8051;
8053 -> 8052;
8053 -> 8050;
8054 -> 8050;
8054 -> 7833;
8054 -> 8051;
8055 -> 8011;
8056 -> 8051;
8056 -> 8055;
8057 -> 8032;
8057 -> 7833;
8057 -> 8025;
8057 -> 8011;
8058 -> 8032;
8058 -> 7833;
8058 -> 8025;
8059 -> 8058;
8060 -> 8059;
8060 -> 8058;
8061 -> 8058;
8062 -> 8058;
8062 -> 8061;
8063 -> 8061;
8064 -> 8062;
8064 -> 8063;
8065 -> 8064;
8065 -> 8061;
8066 -> 8065;
8067 -> 8066;
8067 -> 8058;
8068 -> 8058;
8069 -> 8058;
8070 -> 8058;
8070 -> 8069;
8071 -> 8069;
8072 -> 8070;
8072 -> 8071;
8073 -> 8072;
8073 -> 8069;
8074 -> 8069;
8074 -> 8058;
8075 -> 8058;
8076 -> 8075;
8076 -> 8058;
8077 -> 8074;
8077 -> 8076;
8077 -> 8058;
8078 -> 8058;
8078 -> 7833;
8079 -> 8058;
8080 -> 8058;
8081 -> 8058;
8082 -> 8058;
8082 -> 8081;
8083 -> 8082;
8083 -> 7833;
8083 -> 7935;
8083 -> 8058;
8083 -> 8081;
8084 -> 8083;
8084 -> 8058;
8085 -> 8058;
8086 -> 8058;
8087 -> 8058;
8088 -> 8058;
8089 -> 8087;
8089 -> 8088;
8090 -> 8058;
8091 -> 8090;
8091 -> 8058;
8092 -> 8058;
8093 -> 8091;
8093 -> 8092;
8094 -> 7935;
8095 -> 8059;
8095 -> 8094;
8096 -> 8094;
8097 -> 8095;
8097 -> 8096;
8098 -> 8097;
8098 -> 8094;
8099 -> 8098;
8100 -> 8099;
8100 -> 7935;
8101 -> 8059;
8101 -> 7935;
8102 -> 7935;
8103 -> 8101;
8103 -> 8102;
8104 -> 8103;
8104 -> 0;
8104 -> 8102;
8105 -> 8104;
8106 -> 8059;
8107 -> 8059;
8108 -> 8059;
8109 -> 8059;
8109 -> 7935;
8110 -> 8059;
8110 -> 7935;
8111 -> 8110;
8111 -> 8059;
8111 -> 7935;
8112 -> 8110;
8112 -> 8059;
8112 -> 7935;
8113 -> 8059;
8113 -> 7935;
8114 -> 8113;
8114 -> 7935;
8115 -> 8114;
8115 -> 8059;
8115 -> 7935;
8116 -> 8114;
8116 -> 8059;
8116 -> 7935;
8117 -> 8113;
8117 -> 7935;
8118 -> 8113;
8118 -> 7935;
8119 -> 8117;
8119 -> 7935;
8120 -> 8117;
8120 -> 7935;
8121 -> 8113;
8121 -> 7935;
8122 -> 7935;
8123 -> 7935;
8124 -> 7935;
8125 -> 8124;
8126 -> 8123;
8126 -> 8125;
8127 -> 8126;
8127 -> 8113;
8127 -> 8125;
8128 -> 8127;
8128 -> 8124;
8129 -> 8124;
8130 -> 8128;
8130 -> 8129;
8131 -> 8124;
8132 -> 8124;
8133 -> 8130;
8133 -> 8124;
8134 -> 8124;
8135 -> 8133;
8135 -> 8134;
8136 -> 8135;
8136 -> 8134;
8137 -> 8134;
8138 -> 8136;
8138 -> 8137;
8139 -> 8138;
8139 -> 8137;
8140 -> 8137;
8141 -> 8139;
8141 -> 8140;
8142 -> 8141;
8142 -> 8140;
8143 -> 0;
8143 -> 8142;
8144 -> 8130;
8144 -> 8143;
8145 -> 8143;
8146 -> 8144;
8146 -> 8145;
8147 -> 8146;
8147 -> 8145;
8148 -> 8145;
8149 -> 8147;
8149 -> 8148;
8150 -> 8149;
8150 -> 8148;
8151 -> 8150;
8152 -> 8130;
8152 -> 0;
8152 -> 8151;
8153 -> 8130;
8153 -> 0;
8153 -> 8152;
8154 -> 8130;
8154 -> 0;
8154 -> 8153;
8155 -> 7935;
8156 -> 8123;
8156 -> 8155;
8157 -> 8156;
8157 -> 8113;
8157 -> 8155;
8158 -> 8157;
8158 -> 7935;
8159 -> 7935;
8160 -> 8158;
8160 -> 8159;
8161 -> 7935;
8162 -> 7935;
8163 -> 8113;
8163 -> 8162;
8164 -> 8163;
8164 -> 7935;
8165 -> 7935;
8166 -> 8164;
8166 -> 8165;
8167 -> 8166;
8167 -> 8165;
8168 -> 0;
8168 -> 8167;
8169 -> 7935;
8170 -> 8113;
8171 -> 8113;
8172 -> 8170;
8172 -> 8171;
8173 -> 8172;
8173 -> 0;
8173 -> 8171;
8174 -> 8173;
8175 -> 8113;
8176 -> 8113;
8177 -> 8114;
8177 -> 8113;
8177 -> 7935;
8178 -> 8114;
8178 -> 8113;
8178 -> 7935;
8179 -> 7932;
8179 -> 7833;
8180 -> 8179;
8180 -> 7833;
8181 -> 8180;
8181 -> 7833;
8182 -> 8181;
8182 -> 7833;
8183 -> 7833;
8183 -> 8113;
8183 -> 8182;
8184 -> 7833;
8185 -> 7833;
8185 -> 8113;
8185 -> 8184;
8186 -> 7833;
8187 -> 7833;
8188 -> 7279;
8188 -> 7278;
8188 -> 8113;
8189 -> 6830;
8190 -> 6835;
8190 -> 8113;
8190 -> 8189;
8190 -> 6830;
8191 -> 7275;
8191 -> 8190;
8191 -> 6830;
8192 -> 8191;
8192 -> 6830;
8193 -> 6836;
8193 -> 6830;
8194 -> 8192;
8194 -> 8193;
8194 -> 6831;
8194 -> 8113;
8194 -> 6836;
8194 -> 8188;
8194 -> 6830;
8195 -> 6830;
8196 -> 8195;
8197 -> 8194;
8197 -> 8196;
8198 -> 8197;
8198 -> 8194;
8198 -> 8196;
8199 -> 8197;
8199 -> 8194;
8199 -> 8196;
8200 -> 8196;
8200 -> 8195;
8201 -> 8194;
8201 -> 8195;
8202 -> 8194;
8202 -> 8195;
8203 -> 8201;
8203 -> 8195;
8204 -> 8201;
8204 -> 8195;
8205 -> 6836;
8205 -> 6830;
8206 -> 6831;
8206 -> 8194;
8206 -> 8205;
8206 -> 6836;
8206 -> 6830;
8207 -> 8191;
8207 -> 6830;
8208 -> 6831;
8208 -> 8206;
8208 -> 8207;
8208 -> 6830;
8209 -> 8194;
8209 -> 6829;
8210 -> 8209;
8210 -> 6829;
8211 -> 6819;
8211 -> 8210;
8211 -> 8208;
8211 -> 6829;
8212 -> 6820;
8213 -> 6821;
8213 -> 8212;
8214 -> 6820;
8215 -> 0;
8215 -> 5479;
8216 -> 5479;
8217 -> 8215;
8217 -> 8216;
8218 -> 5481;
8218 -> 8216;
8219 -> 8217;
8219 -> 8216;
8220 -> 8216;
8221 -> 8219;
8221 -> 8220;
8222 -> 8221;
8222 -> 0;
8222 -> 8220;
8223 -> 8222;
8224 -> 8216;
8225 -> 8218;
8225 -> 8224;
8226 -> 8225;
8226 -> 8211;
8226 -> 8224;
8227 -> 8216;
8228 -> 8226;
8228 -> 8217;
8228 -> 8216;
8229 -> 8228;
8229 -> 8211;
8230 -> 8228;
8231 -> 8228;
8232 -> 5480;
8232 -> 5479;
8233 -> 5516;
8233 -> 5479;
8234 -> 6798;
8234 -> 5479;
8235 -> 6799;
8235 -> 5479;
8236 -> 6800;
8236 -> 5479;
8237 -> 6816;
8237 -> 5479;
8238 -> 6819;
8238 -> 5479;
8239 -> 8228;
8239 -> 5479;
8240 -> 8232;
8240 -> 8233;
8240 -> 8234;
8240 -> 8235;
8240 -> 8236;
8240 -> 8237;
8240 -> 8238;
8240 -> 8239;
8240 -> 5481;
8240 -> 8211;
8240 -> 5412;
8240 -> 8228;
8240 -> 5479;
8241 -> 5479;
8242 -> 8241;
8243 -> 8242;
8243 -> 8241;
8244 -> 8240;
8244 -> 8241;
8245 -> 8240;
8245 -> 8241;
8246 -> 8244;
8246 -> 8240;
8246 -> 8241;
8247 -> 8244;
8247 -> 8240;
8247 -> 8241;
8248 -> 6819;
8248 -> 5479;
8249 -> 5481;
8249 -> 8240;
8249 -> 8248;
8249 -> 5479;
8250 -> 5467;
8250 -> 5477;
8251 -> 5477;
8252 -> 8250;
8252 -> 8251;
8253 -> 5420;
8253 -> 8251;
8254 -> 8252;
8254 -> 5462;
8254 -> 8251;
8255 -> 8251;
8256 -> 8254;
8256 -> 8255;
8257 -> 8253;
8257 -> 8255;
8258 -> 8257;
8258 -> 8249;
8258 -> 8256;
8258 -> 5451;
8258 -> 8255;
8259 -> 8255;
8260 -> 8257;
8260 -> 8249;
8260 -> 8259;
8260 -> 8255;
8261 -> 8260;
8262 -> 8261;
8262 -> 8257;
8262 -> 8260;
8263 -> 8251;
8264 -> 5477;
8265 -> 8262;
8265 -> 890;
8266 -> 894;
8266 -> 890;
8267 -> 8265;
8267 -> 8266;
8268 -> 8266;
8269 -> 8267;
8269 -> 8268;
8270 -> 5374;
8270 -> 8268;
8271 -> 8268;
8272 -> 8270;
8272 -> 8271;
8273 -> 8271;
8274 -> 8272;
8274 -> 8273;
8275 -> 8274;
8275 -> 8262;
8275 -> 8273;
8276 -> 8273;
8277 -> 8274;
8277 -> 8262;
8277 -> 8276;
8277 -> 8273;
8278 -> 8277;
8278 -> 8268;
8279 -> 8268;
8280 -> 8278;
8280 -> 8279;
8281 -> 8269;
8281 -> 8280;
8282 -> 8281;
8282 -> 890;
8283 -> 8281;
8283 -> 8262;
8283 -> 8277;
8283 -> 890;
8284 -> 890;
8285 -> 8283;
8285 -> 8284;
8286 -> 8283;
8286 -> 8284;
8287 -> 8283;
8287 -> 8284;
8288 -> 8282;
8288 -> 8284;
8289 -> 8285;
8289 -> 8284;
8290 -> 8286;
8290 -> 8284;
8291 -> 8287;
8291 -> 8284;
8292 -> 8284;
8293 -> 8292;
8293 -> 8289;
8293 -> 8290;
8293 -> 8291;
8293 -> 8283;
8293 -> 8284;
8294 -> 8293;
8294 -> 1;
8295 -> 0;
8295 -> 1;
8296 -> 1;
8297 -> 8293;
8297 -> 8296;
8298 -> 8297;
8298 -> 8293;
8298 -> 8296;
8299 -> 8298;
8299 -> 1;
8300 -> 206;
8300 -> 1;
8301 -> 8293;
8301 -> 1;
8302 -> 1;
8303 -> 8301;
8303 -> 8302;
8304 -> 8302;
8305 -> 8301;
8305 -> 8304;
8305 -> 1;
8306 -> 8301;
8306 -> 8302;
8307 -> 8301;
8307 -> 8302;
8308 -> 8301;
8308 -> 8302;
8309 -> 8301;
8309 -> 8302;
8310 -> 8307;
8310 -> 8302;
8311 -> 8302;
8312 -> 8309;
8312 -> 8311;
8313 -> 8311;
8314 -> 8312;
8314 -> 8313;
8315 -> 8314;
8315 -> 8305;
8315 -> 8313;
8316 -> 8315;
8316 -> 8311;
8317 -> 8311;
8318 -> 8316;
8318 -> 8317;
8319 -> 8318;
8319 -> 8317;
8320 -> 8319;
8321 -> 8320;
8321 -> 8302;
8322 -> 8306;
8322 -> 8321;
8322 -> 8305;
8322 -> 8302;
8323 -> 8308;
8323 -> 8302;
8324 -> 8323;
8325 -> 8309;
8325 -> 8324;
8326 -> 8325;
8326 -> 8322;
8326 -> 8324;
8327 -> 8326;
8327 -> 8323;
8328 -> 8323;
8329 -> 8327;
8329 -> 8328;
8329 -> 8323;
8330 -> 8306;
8330 -> 8329;
8331 -> 8329;
8332 -> 8330;
8332 -> 8331;
8333 -> 8331;
8334 -> 8330;
8334 -> 8331;
8335 -> 8330;
8335 -> 8331;
8336 -> 8335;
8336 -> 8333;
8336 -> 8331;
8337 -> 8334;
8337 -> 8336;
8337 -> 8333;
8337 -> 8331;
8338 -> 8310;
8339 -> 8309;
8339 -> 8338;
8340 -> 8338;
8341 -> 8340;
8341 -> 8310;
8342 -> 8310;
8343 -> 8341;
8343 -> 8342;
8343 -> 8310;
8344 -> 8337;
8345 -> 8309;
8345 -> 8324;
8346 -> 8324;
8346 -> 8323;
8347 -> 8346;
8347 -> 8328;
8347 -> 8323;
8348 -> 8309;
8348 -> 8311;
8349 -> 8348;
8349 -> 8344;
8349 -> 8311;
8350 -> 8309;
8350 -> 8338;
8351 -> 8350;
8351 -> 8349;
8351 -> 8338;
8352 -> 8351;
8352 -> 8310;
8353 -> 8352;
8353 -> 8342;
8353 -> 8310;
8354 -> 8349;
8355 -> 8354;
8356 -> 8350;
8356 -> 8354;
8356 -> 8338;
8357 -> 8356;
8357 -> 8310;
8358 -> 8357;
8358 -> 8342;
8358 -> 8310;
8359 -> 8354;
8360 -> 8359;
8361 -> 8350;
8361 -> 8359;
8361 -> 8338;
8362 -> 8361;
8362 -> 8310;
8363 -> 8362;
8363 -> 8342;
8363 -> 8310;
8364 -> 8359;
8365 -> 8364;
8366 -> 8350;
8366 -> 8364;
8366 -> 8338;
8367 -> 8366;
8367 -> 8310;
8368 -> 8367;
8368 -> 8342;
8368 -> 8310;
8369 -> 8364;
8370 -> 8369;
8371 -> 8350;
8371 -> 8369;
8371 -> 8338;
8372 -> 8371;
8372 -> 8310;
8373 -> 8372;
8373 -> 8342;
8373 -> 8310;
8374 -> 8369;
8375 -> 8374;
8376 -> 8350;
8376 -> 8374;
8376 -> 8338;
8377 -> 8376;
8377 -> 8310;
8378 -> 8377;
8378 -> 8342;
8378 -> 8310;
8379 -> 8374;
8380 -> 1;
8381 -> 8293;
8381 -> 1;
8382 -> 1;
8383 -> 8381;
8383 -> 8382;
8384 -> 8383;
8384 -> 8379;
8384 -> 8382;
8385 -> 8382;
8386 -> 8382;
8387 -> 8384;
8387 -> 8386;
8388 -> 8385;
8388 -> 8386;
8389 -> 8386;
8390 -> 8387;
8390 -> 8386;
8391 -> 8390;
8391 -> 8386;
8392 -> 8389;
8392 -> 8386;
8393 -> 8392;
8393 -> 8382;
8394 -> 8393;
8394 -> 1;
8395 -> 8293;
8395 -> 1;
8396 -> 1;
8397 -> 8395;
8397 -> 8390;
8397 -> 1;
8398 -> 1;
8399 -> 8397;
8399 -> 8398;
8400 -> 8398;
8401 -> 8400;
8401 -> 1;
8402 -> 8397;
8402 -> 8401;
8402 -> 1;
8403 -> 0;
8403 -> 1;
8404 -> 8395;
8404 -> 8402;
8404 -> 1;
8405 -> 1;
8406 -> 8404;
8406 -> 8405;
8407 -> 8405;
8408 -> 8407;
8408 -> 1;
8409 -> 8404;
8409 -> 8408;
8409 -> 1;
8410 -> 1;
8411 -> 8395;
8411 -> 8409;
8411 -> 1;
8412 -> 1;
8413 -> 8411;
8413 -> 8412;
8414 -> 8412;
8415 -> 8414;
8415 -> 1;
8416 -> 8411;
8416 -> 8415;
8416 -> 1;
8417 -> 8395;
8417 -> 8416;
8417 -> 1;
8418 -> 1;
8419 -> 8417;
8419 -> 8418;
8420 -> 8417;
8420 -> 8418;
8421 -> 8417;
8421 -> 8418;
8422 -> 8417;
8422 -> 8418;
8423 -> 8418;
8424 -> 1;
8425 -> 1;
8426 -> 8395;
8426 -> 8419;
8426 -> 8425;
8427 -> 8425;
8428 -> 8426;
8428 -> 8419;
8428 -> 8427;
8429 -> 8428;
8429 -> 8425;
8430 -> 8429;
8430 -> 1;
8431 -> 1;
8432 -> 8395;
8432 -> 8419;
8432 -> 1;
8433 -> 1;
8434 -> 8432;
8434 -> 8433;
8435 -> 8433;
8436 -> 8435;
8436 -> 1;
8437 -> 8432;
8437 -> 8436;
8437 -> 1;
8438 -> 1;
8439 -> 8395;
8439 -> 8437;
8439 -> 1;
8440 -> 1;
8441 -> 8439;
8441 -> 8440;
8442 -> 8440;
8443 -> 8442;
8443 -> 1;
8444 -> 8439;
8444 -> 8443;
8444 -> 1;
8445 -> 1;
8446 -> 8395;
8446 -> 8444;
8446 -> 1;
8447 -> 1;
8448 -> 8446;
8448 -> 8447;
8449 -> 8446;
8449 -> 8447;
8450 -> 8446;
8450 -> 8447;
8451 -> 8446;
8451 -> 8447;
8452 -> 8447;
8453 -> 1;
8454 -> 8395;
8454 -> 8448;
8454 -> 8453;
8454 -> 1;
8455 -> 1;
8456 -> 8454;
8456 -> 8455;
8457 -> 8454;
8457 -> 8455;
8458 -> 8454;
8458 -> 8455;
8459 -> 8454;
8459 -> 8455;
8460 -> 8455;
8461 -> 1;
8462 -> 8395;
8462 -> 8456;
8462 -> 8461;
8462 -> 1;
8463 -> 1;
8464 -> 8462;
8464 -> 8463;
8465 -> 8463;
8466 -> 8465;
8466 -> 1;
8467 -> 8462;
8467 -> 8466;
8467 -> 1;
8468 -> 0;
8468 -> 1;
8469 -> 1;
8470 -> 8395;
8470 -> 8467;
8470 -> 8469;
8470 -> 1;
8471 -> 1;
8472 -> 8470;
8472 -> 8471;
8473 -> 8471;
8474 -> 8473;
8474 -> 1;
8475 -> 8470;
8475 -> 8474;
8475 -> 1;
8476 -> 1;
8477 -> 8395;
8477 -> 8475;
8477 -> 8476;
8477 -> 1;
8478 -> 8477;
8478 -> 1;
8479 -> 8477;
8479 -> 1;
8480 -> 1;
8481 -> 8479;
8481 -> 8480;
8482 -> 8479;
8482 -> 8480;
8483 -> 8479;
8483 -> 8480;
8484 -> 8479;
8484 -> 8480;
8485 -> 8480;
8486 -> 1;
8487 -> 1;
8488 -> 8477;
8488 -> 8481;
8488 -> 8487;
8489 -> 8487;
8490 -> 8488;
8490 -> 8481;
8490 -> 8489;
8491 -> 8490;
8491 -> 8487;
8492 -> 8491;
8492 -> 1;
8493 -> 1;
8494 -> 8395;
8494 -> 8481;
8494 -> 8493;
8494 -> 1;
8495 -> 1;
8496 -> 8395;
8496 -> 8494;
8496 -> 8495;
8496 -> 1;
8497 -> 8495;
8498 -> 8496;
8498 -> 8495;
8499 -> 8495;
8500 -> 8496;
8500 -> 8495;
8501 -> 8500;
8501 -> 8495;
8502 -> 8495;
8503 -> 8496;
8504 -> 8501;
8505 -> 8496;
8505 -> 8504;
8506 -> 8504;
8507 -> 8506;
8507 -> 8501;
8508 -> 8501;
8509 -> 8507;
8509 -> 8508;
8509 -> 8501;
8510 -> 8502;
8511 -> 8502;
8512 -> 8496;
8512 -> 8504;
8513 -> 8512;
8513 -> 8496;
8513 -> 8504;
8514 -> 8513;
8514 -> 8501;
8515 -> 8514;
8515 -> 8508;
8515 -> 8501;
8516 -> 1;
8517 -> 8395;
8517 -> 8496;
8517 -> 8516;
8517 -> 1;
8518 -> 8516;
8519 -> 8517;
8519 -> 8516;
8520 -> 8516;
8521 -> 8517;
8521 -> 8516;
8522 -> 8521;
8522 -> 8516;
8523 -> 8516;
8524 -> 8517;
8525 -> 8522;
8526 -> 8517;
8526 -> 8525;
8527 -> 8525;
8528 -> 8527;
8528 -> 8522;
8529 -> 8522;
8530 -> 8528;
8530 -> 8529;
8530 -> 8522;
8531 -> 8523;
8532 -> 8523;
8533 -> 8517;
8533 -> 8525;
8534 -> 8533;
8534 -> 8517;
8534 -> 8525;
8535 -> 8534;
8535 -> 8522;
8536 -> 8535;
8536 -> 8529;
8536 -> 8522;
8537 -> 1;
8538 -> 8395;
8538 -> 8517;
8538 -> 1;
8539 -> 1;
8540 -> 8538;
8540 -> 8539;
8541 -> 8539;
8542 -> 8541;
8542 -> 1;
8543 -> 8538;
8543 -> 8542;
8543 -> 1;
}