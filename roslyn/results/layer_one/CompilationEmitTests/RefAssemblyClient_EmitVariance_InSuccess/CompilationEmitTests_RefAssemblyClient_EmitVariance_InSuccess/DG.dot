digraph G {
0 [label="EXTERNAL"];
1 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 828653"];
2 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 828654"];
3 [label="param CompilationEmitTests(this) 828655"];
4 [label="param EmitMetadataTestBase(this) 828656"];
5 [label="param CSharpTestBase(this) 828657"];
6 [label="param CommonTestBase(this) 828658"];
7 [label="param TestBase(this) 828659"];
8 [label="_temp 828660"];
9 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 828661"];
10 [label="param RefAssemblyClient_EmitVariance_InSuccess(this) 828662"];
11 [label="VerifyRefAssemblyClient(@'\npublic interface I<in T>\n{\n}',\n@'\nclass Base { }\nclass Derived : Base\n{\n    I<Derived> M(I<Base> x)\n    {\n        return x;\n    }\n}',\ncomp => comp.VerifyDiagnostics()); 828663"];
12 [label="VerifyRefAssemblyClient(@'\npublic interface I<in T>\n{\n}',\n@'\nclass Base { }\nclass Derived : Base\n{\n    I<Derived> M(I<Base> x)\n    {\n        return x;\n    }\n}',\ncomp => comp.VerifyDiagnostics()) 828664"];
13 [label="param VerifyRefAssemblyClient(string lib_cs) 828665"];
14 [label="param VerifyRefAssemblyClient(string client_cs) 828666"];
15 [label="param VerifyRefAssemblyClient(Action<CSharpCompilation> validator) 828667"];
16 [label="param VerifyRefAssemblyClient(int debugFlag = -1) 828668"];
17 [label="param VerifyRefAssemblyClient(this) 828669"];
18 [label="if (debugFlag == -1 || debugFlag == 0)\n            {\n                VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(false));\n            } 828670"];
19 [label="if (debugFlag == -1 || debugFlag == 0)\n            {\n                VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(false));\n            } 828671"];
20 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(false)); 828672"];
21 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(false)); 828673"];
22 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(false)); 828674"];
23 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(false)); 828675"];
24 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(false)) 828676"];
25 [label="param VerifyRefAssemblyClient(string lib_cs) 828677"];
26 [label="param VerifyRefAssemblyClient(string source) 828678"];
27 [label="param VerifyRefAssemblyClient(Action<CSharpCompilation> validator) 828679"];
28 [label="param VerifyRefAssemblyClient(EmitOptions emitOptions) 828680"];
29 [label="GetUniqueName() 828681"];
30 [label="return Guid.NewGuid().ToString('D'); 828682"];
31 [label="string name = GetUniqueName(); 828683"];
32 [label="var libComp = CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name); 828684"];
33 [label="var libComp = CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name); 828685"];
34 [label="var libComp = CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name); 828686"];
35 [label="CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name) 828687"];
36 [label="param operator(string source) 828688"];
37 [label="source 828689"];
38 [label="new CSharpTestSource(source) 828690"];
39 [label="param CSharpTestSource(object value) 828691"];
40 [label="param CSharpTestSource(this) 828692"];
41 [label="Value 828693"];
42 [label="var libComp = CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name); 828694"];
43 [label="param CreateCompilation(CSharpTestSource source) 828695"];
44 [label="param CreateCompilation(IEnumerable<MetadataReference> references = null) 828696"];
45 [label="param CreateCompilation(CSharpCompilationOptions options = null) 828697"];
46 [label="param CreateCompilation(CSharpParseOptions parseOptions = null) 828698"];
47 [label="param CreateCompilation(TargetFramework targetFramework = TargetFramework.Standard) 828699"];
48 [label="param CreateCompilation(string assemblyName = '') 828700"];
49 [label="param CreateCompilation(string sourceFileName = '') 828701"];
50 [label="param CreateCompilation(bool skipUsesIsNullable = false) 828702"];
51 [label="source 828703"];
52 [label="targetFramework 828704"];
53 [label="references 828705"];
54 [label="TargetFrameworkUtil.GetReferences(targetFramework, references) 828706"];
55 [label="param GetReferences(TargetFramework tf) 828707"];
56 [label="param GetReferences(IEnumerable<MetadataReference> additionalReferences) 828708"];
57 [label="var references = GetReferences(tf); 828709"];
58 [label="GetReferences(tf) 828710"];
59 [label="param GetReferences(TargetFramework targetFramework) 828711"];
60 [label="targetFramework switch\n        {\n            TargetFramework.Empty => ImmutableArray<MetadataReference>.Empty,\n            TargetFramework.Mscorlib40 => Mscorlib40References,\n            TargetFramework.Mscorlib40Extended => Mscorlib40ExtendedReferences,\n            TargetFramework.Mscorlib40AndSystemCore => Mscorlib40andSystemCoreReferences,\n            TargetFramework.Mscorlib40AndVBRuntime => Mscorlib40andVBRuntimeReferences,\n            TargetFramework.Mscorlib45 => Mscorlib45References,\n            TargetFramework.Mscorlib45Extended => Mscorlib45ExtendedReferences,\n            TargetFramework.Mscorlib45AndCSharp => Mscorlib45AndCSharpReferences,\n            TargetFramework.Mscorlib45AndVBRuntime => Mscorlib45AndVBRuntimeReferences,\n            TargetFramework.Mscorlib46 => Mscorlib46References,\n            TargetFramework.Mscorlib46Extended => Mscorlib46ExtendedReferences,\n            TargetFramework.Mscorlib461 => Mscorlib46References,\n            TargetFramework.Mscorlib461Extended => Mscorlib461ExtendedReferences,\n            TargetFramework.NetStandard20 => NetStandard20References,\n            TargetFramework.NetCoreApp => NetCoreAppReferences,\n            TargetFramework.WinRT => WinRTReferences,\n            TargetFramework.Standard => StandardReferences,\n            TargetFramework.StandardLatest => StandardLatestReferences,\n            TargetFramework.StandardAndCSharp => StandardAndCSharpReferences,\n            TargetFramework.StandardAndVBRuntime => StandardAndVBRuntimeReferences,\n            TargetFramework.StandardCompat => StandardCompatReferences,\n            TargetFramework.DefaultVb => DefaultVbReferences,\n            TargetFramework.Minimal => MinimalReferences,\n            TargetFramework.MinimalAsync => MinimalAsyncReferences,\n            _ => throw new InvalidOperationException($'Unexpected target framework {targetFramework}'),\n        } 828712"];
61 [label="StandardReferences 828713"];
62 [label="RuntimeUtilities.IsCoreClrRuntime 828714"];
63 [label="NetStandard20References 828715"];
64 [label="ImmutableArray.Create<MetadataReference>(NetStandard20.netstandard, NetStandard20.mscorlib, NetStandard20.SystemRuntime, NetStandard20.SystemCore, NetStandard20.SystemDynamicRuntime, NetStandard20.SystemLinq, NetStandard20.SystemLinqExpressions) 828716"];
65 [label="RuntimeUtilities.IsCoreClrRuntime ? NetStandard20References : Mscorlib46ExtendedReferences 828717"];
66 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 828718"];
67 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 828719"];
68 [label="return references; 828720"];
69 [label="options 828721"];
70 [label="parseOptions 828722"];
71 [label="assemblyName 828723"];
72 [label="sourceFileName 828724"];
73 [label="skipUsesIsNullable 828725"];
74 [label="CreateEmptyCompilation(source, TargetFrameworkUtil.GetReferences(targetFramework, references), options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable) 828726"];
75 [label="param CreateEmptyCompilation(CSharpTestSource source) 828727"];
76 [label="param CreateEmptyCompilation(IEnumerable<MetadataReference> references = null) 828728"];
77 [label="param CreateEmptyCompilation(CSharpCompilationOptions options = null) 828729"];
78 [label="param CreateEmptyCompilation(CSharpParseOptions parseOptions = null) 828730"];
79 [label="param CreateEmptyCompilation(string assemblyName = '') 828731"];
80 [label="param CreateEmptyCompilation(string sourceFileName = '') 828732"];
81 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 828733"];
82 [label="source 828734"];
83 [label="references 828735"];
84 [label="options 828736"];
85 [label="parseOptions 828737"];
86 [label="assemblyName 828738"];
87 [label="sourceFileName 828739"];
88 [label="skipUsesIsNullable 828740"];
89 [label="null 828741"];
90 [label="experimentalFeature: null 828742"];
91 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 828743"];
92 [label="param CreateCompilationCore(CSharpTestSource source) 828744"];
93 [label="param CreateCompilationCore(IEnumerable<MetadataReference> references) 828745"];
94 [label="param CreateCompilationCore(CSharpCompilationOptions options) 828746"];
95 [label="param CreateCompilationCore(CSharpParseOptions parseOptions) 828747"];
96 [label="param CreateCompilationCore(string assemblyName) 828748"];
97 [label="param CreateCompilationCore(string sourceFileName) 828749"];
98 [label="param CreateCompilationCore(bool skipUsesIsNullable) 828750"];
99 [label="param CreateCompilationCore(MessageID? experimentalFeature) 828751"];
100 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 828752"];
101 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 828753"];
102 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 828754"];
103 [label="param GetSyntaxTrees(CSharpParseOptions parseOptions) 828755"];
104 [label="param GetSyntaxTrees(string sourceFileName = '') 828756"];
105 [label="param GetSyntaxTrees(this) 828757"];
106 [label="switch (Value)\n            {\n                case string source:\n                    return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) };\n                case string[] sources:\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return CSharpTestBase.Parse(parseOptions, sources);\n                case SyntaxTree tree:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return new[] { tree };\n                case SyntaxTree[] trees:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return trees;\n                case CSharpTestSource[] testSources:\n                    return testSources.SelectMany(s => s.GetSyntaxTrees(parseOptions, sourceFileName)).ToArray();\n                case null:\n                    return Array.Empty<SyntaxTree>();\n                default:\n                    throw new Exception($'Unexpected value: {Value}');\n            } 828758"];
107 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 828759"];
108 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 828760"];
109 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 828761"];
110 [label="CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) 828762"];
111 [label="param Parse(string text) 828763"];
112 [label="param Parse(string filename = '') 828764"];
113 [label="param Parse(CSharpParseOptions options = null) 828765"];
114 [label="param Parse(Encoding encoding = null) 828766"];
115 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 828767"];
116 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 828768"];
117 [label="options = TestOptions.Regular; 828769"];
118 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 828770"];
119 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 828771"];
120 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 828772"];
121 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 828773"];
122 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 828774"];
123 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 828775"];
124 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 828776"];
125 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 828777"];
126 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 828778"];
127 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 828779"];
128 [label="CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)) 828780"];
129 [label="param CheckSerializable(SyntaxTree tree) 828781"];
130 [label="var stream = new MemoryStream(); 828782"];
131 [label="var root = tree.GetRoot(); 828783"];
132 [label="var root = tree.GetRoot(); 828784"];
133 [label="root.SerializeTo(stream); 828785"];
134 [label="root.SerializeTo(stream); 828786"];
135 [label="root.SerializeTo(stream); 828787"];
136 [label="stream.Position = 0; 828788"];
137 [label="stream.Position 828789"];
138 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 828790"];
139 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 828791"];
140 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 828792"];
141 [label="return tree; 828793"];
142 [label="new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) } 828794"];
143 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 828795"];
144 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 828796"];
145 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 828797"];
146 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 828798"];
147 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 828799"];
148 [label="Func<CSharpCompilation> createCompilationLambda = () => CSharpCompilation.Create(\n                assemblyName == '' ? GetUniqueName() : assemblyName,\n                syntaxTrees,\n                references,\n                options); 828800"];
149 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 828801"];
150 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 828802"];
151 [label="param ValidateIOperations(Func<Compilation> createCompilation) 828803"];
152 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 828804"];
153 [label="return; 828805"];
154 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 828806"];
155 [label="OutputKind.ConsoleApplication 828807"];
156 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 828808"];
157 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 828809"];
158 [label="s_defaultOptions = new CSharpCompilationOptions(OutputKind.ConsoleApplication) 828810"];
159 [label="OutputKind.DynamicallyLinkedLibrary 828811"];
160 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 828812"];
161 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 828813"];
162 [label="true 828814"];
163 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 828815"];
164 [label="s_defaultSubmissionOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 828816"];
165 [label="var compilation = createCompilationLambda(); 828817"];
166 [label="var compilation = createCompilationLambda(); 828818"];
167 [label="param Create(string? assemblyName) 828819"];
168 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees = null) 828820"];
169 [label="param Create(IEnumerable<MetadataReference>? references = null) 828821"];
170 [label="param Create(CSharpCompilationOptions? options = null) 828822"];
171 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 828823"];
172 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 828824"];
173 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 828825"];
174 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 828826"];
175 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 828827"];
176 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 828828"];
177 [label="param Create(string? assemblyName) 828829"];
178 [label="param Create(CSharpCompilationOptions options) 828830"];
179 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees) 828831"];
180 [label="param Create(IEnumerable<MetadataReference>? references) 828832"];
181 [label="param Create(CSharpCompilation? previousSubmission) 828833"];
182 [label="param Create(Type? returnType) 828834"];
183 [label="param Create(Type? hostObjectType) 828835"];
184 [label="param Create(bool isSubmission) 828836"];
185 [label="RoslynDebug.Assert(options != null); 828837"];
186 [label="RoslynDebug.Assert(options != null); 828838"];
187 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 828839"];
188 [label="var validatedReferences = ValidateReferences<CSharpCompilationReference>(references); 828840"];
189 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 828841"];
190 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 828842"];
191 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 828843"];
192 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 828844"];
193 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 828845"];
194 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 828846"];
195 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 828847"];
196 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 828848"];
197 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 828849"];
198 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 828850"];
199 [label="new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null) 828851"];
200 [label="param SyntaxAndDeclarationManager(ImmutableArray<SyntaxTree> externalSyntaxTrees) 828852"];
201 [label="param SyntaxAndDeclarationManager(string scriptClassName) 828853"];
202 [label="param SyntaxAndDeclarationManager(SourceReferenceResolver resolver) 828854"];
203 [label="param SyntaxAndDeclarationManager(CommonMessageProvider messageProvider) 828855"];
204 [label="param SyntaxAndDeclarationManager(bool isSubmission) 828856"];
205 [label="param SyntaxAndDeclarationManager(State state) 828857"];
206 [label="param SyntaxAndDeclarationManager(this) 828858"];
207 [label="externalSyntaxTrees 828859"];
208 [label="scriptClassName 828860"];
209 [label="resolver 828861"];
210 [label="messageProvider 828862"];
211 [label="isSubmission 828863"];
212 [label="param SyntaxAndDeclarationManager(this) 828864"];
213 [label="param SyntaxAndDeclarationManager(this) 828865"];
214 [label="_lazyState 828866"];
215 [label="_lazyState 828867"];
216 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 828868"];
217 [label="param CSharpCompilation(string? assemblyName) 828869"];
218 [label="param CSharpCompilation(CSharpCompilationOptions options) 828870"];
219 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 828871"];
220 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 828872"];
221 [label="param CSharpCompilation(Type? submissionReturnType) 828873"];
222 [label="param CSharpCompilation(Type? hostObjectType) 828874"];
223 [label="param CSharpCompilation(bool isSubmission) 828875"];
224 [label="param CSharpCompilation(ReferenceManager? referenceManager) 828876"];
225 [label="param CSharpCompilation(bool reuseReferenceManager) 828877"];
226 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 828878"];
227 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 828879"];
228 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 828880"];
229 [label="param CSharpCompilation(this) 828881"];
230 [label="assemblyName 828882"];
231 [label="options 828883"];
232 [label="references 828884"];
233 [label="previousSubmission 828885"];
234 [label="submissionReturnType 828886"];
235 [label="hostObjectType 828887"];
236 [label="isSubmission 828888"];
237 [label="referenceManager 828889"];
238 [label="reuseReferenceManager 828890"];
239 [label="syntaxAndDeclarations 828891"];
240 [label="syntaxAndDeclarations.ExternalSyntaxTrees 828892"];
241 [label="SyntaxTreeCommonFeatures(syntaxAndDeclarations.ExternalSyntaxTrees) 828893"];
242 [label="semanticModelProvider 828894"];
243 [label="eventQueue 828895"];
244 [label="param CSharpCompilation(this) 828896"];
245 [label="param CSharpCompilation(string? assemblyName) 828897"];
246 [label="param CSharpCompilation(CSharpCompilationOptions options) 828898"];
247 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 828899"];
248 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 828900"];
249 [label="param CSharpCompilation(Type? submissionReturnType) 828901"];
250 [label="param CSharpCompilation(Type? hostObjectType) 828902"];
251 [label="param CSharpCompilation(bool isSubmission) 828903"];
252 [label="param CSharpCompilation(ReferenceManager? referenceManager) 828904"];
253 [label="param CSharpCompilation(bool reuseReferenceManager) 828905"];
254 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 828906"];
255 [label="param CSharpCompilation(IReadOnlyDictionary<string, string> features) 828907"];
256 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 828908"];
257 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 828909"];
258 [label="param CSharpCompilation(this) 828910"];
259 [label="assemblyName 828911"];
260 [label="references 828912"];
261 [label="features 828913"];
262 [label="isSubmission 828914"];
263 [label="semanticModelProvider 828915"];
264 [label="eventQueue 828916"];
265 [label="param CSharpCompilation(this) 828917"];
266 [label="param CSharpCompilation(this) 828918"];
267 [label="_options 828919"];
268 [label="_globalImports 828920"];
269 [label="_previousSubmissionImports 828921"];
270 [label="_globalNamespaceAlias 828922"];
271 [label="_scriptClass 828923"];
272 [label="_lazyHostObjectTypeSymbol 828924"];
273 [label="_lazyImportInfos 828925"];
274 [label="_conversions 828926"];
275 [label="_anonymousTypeManager 828927"];
276 [label="_lazyGlobalNamespace 828928"];
277 [label="builtInOperators 828929"];
278 [label="_lazyAssemblySymbol 828930"];
279 [label="_referenceManager 828931"];
280 [label="_syntaxAndDeclarations 828932"];
281 [label="_lazyEntryPoint 828933"];
282 [label="_lazyEmitNullablePublicOnly 828934"];
283 [label="_lazyCompilationUnitCompletedTrees 828935"];
284 [label="NullableAnalysisData 828936"];
285 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 828937"];
286 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 828938"];
287 [label="_externAliasTargets 828939"];
288 [label="_moduleInitializerMethods 828940"];
289 [label="_binderFactories 828941"];
290 [label="_ignoreAccessibilityBinderFactories 828942"];
291 [label="_lazyDeclarationDiagnostics 828943"];
292 [label="_declarationDiagnosticsFrozen 828944"];
293 [label="new DiagnosticBag() 828945"];
294 [label="_additionalCodegenWarnings = new DiagnosticBag() 828946"];
295 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 828947"];
296 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 828948"];
297 [label="WellKnownMemberSignatureComparer 828949"];
298 [label="_options 828950"];
299 [label="this.builtInOperators = new BuiltInOperators(this); 828951"];
300 [label="this.builtInOperators = new BuiltInOperators(this); 828952"];
301 [label="new BuiltInOperators(this) 828953"];
302 [label="param BuiltInOperators(CSharpCompilation compilation) 828954"];
303 [label="param BuiltInOperators(this) 828955"];
304 [label="_compilation 828956"];
305 [label="_builtInUnaryOperators 828957"];
306 [label="_builtInOperators 828958"];
307 [label="_compilation 828959"];
308 [label="this.builtInOperators 828960"];
309 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 828961"];
310 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 828962"];
311 [label="_scriptClass 828963"];
312 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 828964"];
313 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 828965"];
314 [label="_globalImports 828966"];
315 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 828967"];
316 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 828968"];
317 [label="_previousSubmissionImports 828969"];
318 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 828970"];
319 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 828971"];
320 [label="_globalNamespaceAlias 828972"];
321 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 828973"];
322 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 828974"];
323 [label="_anonymousTypeManager 828975"];
324 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 828976"];
325 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 828977"];
326 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 828978"];
327 [label="LanguageVersion? result = null; 828979"];
328 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 828980"];
329 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 828981"];
330 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 828982"];
331 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 828983"];
332 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 828984"];
333 [label="this.LanguageVersion 828985"];
334 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 828986"];
335 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 828987"];
336 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 828988"];
337 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 828989"];
338 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 828990"];
339 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 828991"];
340 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 828992"];
341 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 828993"];
342 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 828994"];
343 [label="this.Options 828995"];
344 [label="get\n            {\n                return _options;\n            } 828996"];
345 [label="return _options; 828997"];
346 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 828998"];
347 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 828999"];
348 [label="_referenceManager 829000"];
349 [label="_syntaxAndDeclarations 829001"];
350 [label="Debug.Assert(_lazyAssemblySymbol is null); 829002"];
351 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 829003"];
352 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 829004"];
353 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 829005"];
354 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 829006"];
355 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 829007"];
356 [label="compilation.AddSyntaxTrees(syntaxTrees) 829008"];
357 [label="param AddSyntaxTrees(IEnumerable<SyntaxTree> trees) 829009"];
358 [label="param AddSyntaxTrees(this) 829010"];
359 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 829011"];
360 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 829012"];
361 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 829013"];
362 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 829014"];
363 [label="var externalSyntaxTrees = PooledHashSet<SyntaxTree>.GetInstance(); 829015"];
364 [label="var syntaxAndDeclarations = _syntaxAndDeclarations; 829016"];
365 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 829017"];
366 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 829018"];
367 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 829019"];
368 [label="bool reuseReferenceManager = true; 829020"];
369 [label="int i = 0; 829021"];
370 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 829022"];
371 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 829023"];
372 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 829024"];
373 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 829025"];
374 [label="if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                } 829026"];
375 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 829027"];
376 [label="externalSyntaxTrees.Add(tree); 829028"];
377 [label="externalSyntaxTrees.Add(tree); 829029"];
378 [label="reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives; 829030"];
379 [label="i++; 829031"];
380 [label="externalSyntaxTrees.Free(); 829032"];
381 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 829033"];
382 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 829034"];
383 [label="syntaxAndDeclarations.AddSyntaxTrees(trees) 829035"];
384 [label="param AddSyntaxTrees(IEnumerable<SyntaxTree> trees) 829036"];
385 [label="param AddSyntaxTrees(this) 829037"];
386 [label="var scriptClassName = this.ScriptClassName; 829038"];
387 [label="var resolver = this.Resolver; 829039"];
388 [label="var messageProvider = this.MessageProvider; 829040"];
389 [label="var isSubmission = this.IsSubmission; 829041"];
390 [label="var state = _lazyState; 829042"];
391 [label="var newExternalSyntaxTrees = this.ExternalSyntaxTrees.AddRange(trees); 829043"];
392 [label="var newExternalSyntaxTrees = this.ExternalSyntaxTrees.AddRange(trees); 829044"];
393 [label="if (state == null)\n            {\n                return this.WithExternalSyntaxTrees(newExternalSyntaxTrees);\n            } 829045"];
394 [label="if (state == null)\n            {\n                return this.WithExternalSyntaxTrees(newExternalSyntaxTrees);\n            } 829046"];
395 [label="return this.WithExternalSyntaxTrees(newExternalSyntaxTrees); 829047"];
396 [label="this.WithExternalSyntaxTrees(newExternalSyntaxTrees) 829048"];
397 [label="param WithExternalSyntaxTrees(ImmutableArray<SyntaxTree> trees) 829049"];
398 [label="param WithExternalSyntaxTrees(this) 829050"];
399 [label="return new SyntaxAndDeclarationManager(trees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission, state: null); 829051"];
400 [label="return new SyntaxAndDeclarationManager(trees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission, state: null); 829052"];
401 [label="return new SyntaxAndDeclarationManager(trees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission, state: null); 829053"];
402 [label="new SyntaxAndDeclarationManager(trees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission, state: null) 829054"];
403 [label="param SyntaxAndDeclarationManager(ImmutableArray<SyntaxTree> externalSyntaxTrees) 829055"];
404 [label="param SyntaxAndDeclarationManager(string scriptClassName) 829056"];
405 [label="param SyntaxAndDeclarationManager(SourceReferenceResolver resolver) 829057"];
406 [label="param SyntaxAndDeclarationManager(CommonMessageProvider messageProvider) 829058"];
407 [label="param SyntaxAndDeclarationManager(bool isSubmission) 829059"];
408 [label="param SyntaxAndDeclarationManager(State state) 829060"];
409 [label="param SyntaxAndDeclarationManager(this) 829061"];
410 [label="param SyntaxAndDeclarationManager(this) 829062"];
411 [label="return this.WithExternalSyntaxTrees(newExternalSyntaxTrees); 829063"];
412 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 829064"];
413 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 829065"];
414 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 829066"];
415 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 829067"];
416 [label="Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations) 829068"];
417 [label="param Update(ReferenceManager referenceManager) 829069"];
418 [label="param Update(bool reuseReferenceManager) 829070"];
419 [label="param Update(SyntaxAndDeclarationManager syntaxAndDeclarations) 829071"];
420 [label="param Update(this) 829072"];
421 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 829073"];
422 [label="this.PreviousSubmission 829074"];
423 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 829075"];
424 [label="ScriptCompilationInfo 829076"];
425 [label="ScriptCompilationInfo?.PreviousScriptCompilation 829077"];
426 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 829078"];
427 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 829079"];
428 [label="this.SubmissionReturnType 829080"];
429 [label="=> ScriptCompilationInfo 829081"];
430 [label="ScriptCompilationInfo 829082"];
431 [label="this.HostObjectType 829083"];
432 [label="=> ScriptCompilationInfo 829084"];
433 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 829085"];
434 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 829086"];
435 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 829087"];
436 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 829088"];
437 [label="new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider) 829089"];
438 [label="param CSharpCompilation(string? assemblyName) 829090"];
439 [label="param CSharpCompilation(CSharpCompilationOptions options) 829091"];
440 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 829092"];
441 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 829093"];
442 [label="param CSharpCompilation(Type? submissionReturnType) 829094"];
443 [label="param CSharpCompilation(Type? hostObjectType) 829095"];
444 [label="param CSharpCompilation(bool isSubmission) 829096"];
445 [label="param CSharpCompilation(ReferenceManager? referenceManager) 829097"];
446 [label="param CSharpCompilation(bool reuseReferenceManager) 829098"];
447 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 829099"];
448 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 829100"];
449 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 829101"];
450 [label="param CSharpCompilation(this) 829102"];
451 [label="previousSubmission 829103"];
452 [label="submissionReturnType 829104"];
453 [label="hostObjectType 829105"];
454 [label="syntaxAndDeclarations.ExternalSyntaxTrees 829106"];
455 [label="eventQueue 829107"];
456 [label="param CSharpCompilation(this) 829108"];
457 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 829109"];
458 [label="param CSharpCompilation(Type? submissionReturnType) 829110"];
459 [label="param CSharpCompilation(Type? hostObjectType) 829111"];
460 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 829112"];
461 [label="param CSharpCompilation(this) 829113"];
462 [label="eventQueue 829114"];
463 [label="param CSharpCompilation(this) 829115"];
464 [label="_options 829116"];
465 [label="_globalImports 829117"];
466 [label="_previousSubmissionImports 829118"];
467 [label="_globalNamespaceAlias 829119"];
468 [label="_scriptClass 829120"];
469 [label="_lazyHostObjectTypeSymbol 829121"];
470 [label="_lazyImportInfos 829122"];
471 [label="_conversions 829123"];
472 [label="_anonymousTypeManager 829124"];
473 [label="_lazyGlobalNamespace 829125"];
474 [label="builtInOperators 829126"];
475 [label="_lazyAssemblySymbol 829127"];
476 [label="_referenceManager 829128"];
477 [label="_syntaxAndDeclarations 829129"];
478 [label="_lazyEntryPoint 829130"];
479 [label="_lazyEmitNullablePublicOnly 829131"];
480 [label="_lazyCompilationUnitCompletedTrees 829132"];
481 [label="NullableAnalysisData 829133"];
482 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 829134"];
483 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 829135"];
484 [label="_externAliasTargets 829136"];
485 [label="_moduleInitializerMethods 829137"];
486 [label="_binderFactories 829138"];
487 [label="_ignoreAccessibilityBinderFactories 829139"];
488 [label="_lazyDeclarationDiagnostics 829140"];
489 [label="_declarationDiagnosticsFrozen 829141"];
490 [label="new DiagnosticBag() 829142"];
491 [label="_additionalCodegenWarnings = new DiagnosticBag() 829143"];
492 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 829144"];
493 [label="this.builtInOperators = new BuiltInOperators(this); 829145"];
494 [label="this.builtInOperators = new BuiltInOperators(this); 829146"];
495 [label="new BuiltInOperators(this) 829147"];
496 [label="param BuiltInOperators(CSharpCompilation compilation) 829148"];
497 [label="param BuiltInOperators(this) 829149"];
498 [label="_compilation 829150"];
499 [label="_builtInUnaryOperators 829151"];
500 [label="_builtInOperators 829152"];
501 [label="_compilation 829153"];
502 [label="this.builtInOperators 829154"];
503 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 829155"];
504 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 829156"];
505 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 829157"];
506 [label="LanguageVersion? result = null; 829158"];
507 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 829159"];
508 [label="var version = ((CSharpParseOptions)tree.Options).LanguageVersion; 829160"];
509 [label="if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                } 829161"];
510 [label="result = version; 829162"];
511 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 829163"];
512 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 829164"];
513 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 829165"];
514 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 829166"];
515 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 829167"];
516 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 829168"];
517 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 829169"];
518 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 829170"];
519 [label="referenceManager.AssertCanReuseForCompilation(this); 829171"];
520 [label="referenceManager.AssertCanReuseForCompilation(this); 829172"];
521 [label="_referenceManager 829173"];
522 [label="Debug.Assert(_lazyAssemblySymbol is null); 829174"];
523 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 829175"];
524 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 829176"];
525 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 829177"];
526 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 829178"];
527 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 829179"];
528 [label="return compilation; 829180"];
529 [label="var compilation = createCompilationLambda(); 829181"];
530 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 829182"];
531 [label="IsNullableEnabled(compilation) 829183"];
532 [label="param IsNullableEnabled(CSharpCompilation compilation) 829184"];
533 [label="compilation.SyntaxTrees 829185"];
534 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 829186"];
535 [label="_syntaxAndDeclarations.GetLazyState() 829187"];
536 [label="param GetLazyState(this) 829188"];
537 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 829189"];
538 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 829190"];
539 [label="Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null); 829191"];
540 [label="CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission) 829192"];
541 [label="param CreateState(ImmutableArray<SyntaxTree> externalSyntaxTrees) 829193"];
542 [label="param CreateState(string scriptClassName) 829194"];
543 [label="param CreateState(SourceReferenceResolver resolver) 829195"];
544 [label="param CreateState(CommonMessageProvider messageProvider) 829196"];
545 [label="param CreateState(bool isSubmission) 829197"];
546 [label="var treesBuilder = ArrayBuilder<SyntaxTree>.GetInstance(); 829198"];
547 [label="var ordinalMapBuilder = PooledDictionary<SyntaxTree, int>.GetInstance(); 829199"];
548 [label="var loadDirectiveMapBuilder = PooledDictionary<SyntaxTree, ImmutableArray<LoadDirective>>.GetInstance(); 829200"];
549 [label="var loadedSyntaxTreeMapBuilder = PooledDictionary<string, SyntaxTree>.GetInstance(); 829201"];
550 [label="var declMapBuilder = PooledDictionary<SyntaxTree, Lazy<RootSingleNamespaceDeclaration>>.GetInstance(); 829202"];
551 [label="var declTable = DeclarationTable.Empty; 829203"];
552 [label="foreach (var tree in externalSyntaxTrees)\n            {\n                AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable);\n            } 829204"];
553 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 829205"];
554 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 829206"];
555 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 829207"];
556 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 829208"];
557 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 829209"];
558 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 829210"];
559 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 829211"];
560 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 829212"];
561 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 829213"];
562 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 829214"];
563 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 829215"];
564 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable) 829216"];
565 [label="param AppendAllSyntaxTrees(ArrayBuilder<SyntaxTree> treesBuilder) 829217"];
566 [label="param AppendAllSyntaxTrees(SyntaxTree tree) 829218"];
567 [label="param AppendAllSyntaxTrees(string scriptClassName) 829219"];
568 [label="param AppendAllSyntaxTrees(SourceReferenceResolver resolver) 829220"];
569 [label="param AppendAllSyntaxTrees(CommonMessageProvider messageProvider) 829221"];
570 [label="param AppendAllSyntaxTrees(bool isSubmission) 829222"];
571 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, int> ordinalMapBuilder) 829223"];
572 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, ImmutableArray<LoadDirective>> loadDirectiveMapBuilder) 829224"];
573 [label="param AppendAllSyntaxTrees(IDictionary<string, SyntaxTree> loadedSyntaxTreeMapBuilder) 829225"];
574 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, Lazy<RootSingleNamespaceDeclaration>> declMapBuilder) 829226"];
575 [label="param AppendAllSyntaxTrees(ref DeclarationTable declTable) 829227"];
576 [label="var sourceCodeKind = tree.Options.Kind; 829228"];
577 [label="if (sourceCodeKind == SourceCodeKind.Script)\n            {\n                AppendAllLoadedSyntaxTrees(treesBuilder, tree, scriptClassName, resolver, messageProvider, isSubmission, ordinalMapBuilder, loadDirectiveMapBuilder, loadedSyntaxTreeMapBuilder, declMapBuilder, ref declTable);\n            } 829229"];
578 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 829230"];
579 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 829231"];
580 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 829232"];
581 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 829233"];
582 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 829234"];
583 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable) 829235"];
584 [label="param AddSyntaxTreeToDeclarationMapAndTable(SyntaxTree tree) 829236"];
585 [label="param AddSyntaxTreeToDeclarationMapAndTable(string scriptClassName) 829237"];
586 [label="param AddSyntaxTreeToDeclarationMapAndTable(bool isSubmission) 829238"];
587 [label="param AddSyntaxTreeToDeclarationMapAndTable(IDictionary<SyntaxTree, Lazy<RootSingleNamespaceDeclaration>> declMapBuilder) 829239"];
588 [label="param AddSyntaxTreeToDeclarationMapAndTable(ref DeclarationTable declTable) 829240"];
589 [label="var lazyRoot = new Lazy<RootSingleNamespaceDeclaration>(() => DeclarationTreeBuilder.ForTree(tree, scriptClassName, isSubmission)); 829241"];
590 [label="declMapBuilder.Add(tree, lazyRoot); 829242"];
591 [label="declMapBuilder.Add(tree, lazyRoot); 829243"];
592 [label="declMapBuilder.Add(tree, lazyRoot); 829244"];
593 [label="declTable = declTable.AddRootDeclaration(lazyRoot); 829245"];
594 [label="declTable = declTable.AddRootDeclaration(lazyRoot); 829246"];
595 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 829247"];
596 [label="treesBuilder.Add(tree); 829248"];
597 [label="treesBuilder.Add(tree); 829249"];
598 [label="ordinalMapBuilder.Add(tree, ordinalMapBuilder.Count); 829250"];
599 [label="ordinalMapBuilder.Add(tree, ordinalMapBuilder.Count); 829251"];
600 [label="ordinalMapBuilder.Add(tree, ordinalMapBuilder.Count); 829252"];
601 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 829253"];
602 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 829254"];
603 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 829255"];
604 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 829256"];
605 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 829257"];
606 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 829258"];
607 [label="new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable) 829259"];
608 [label="param State(ImmutableArray<SyntaxTree> syntaxTrees) 829260"];
609 [label="param State(ImmutableDictionary<SyntaxTree, int> syntaxTreeOrdinalMap) 829261"];
610 [label="param State(ImmutableDictionary<SyntaxTree, ImmutableArray<LoadDirective>> loadDirectiveMap) 829262"];
611 [label="param State(ImmutableDictionary<string, SyntaxTree> loadedSyntaxTreeMap) 829263"];
612 [label="param State(ImmutableDictionary<SyntaxTree, Lazy<RootSingleNamespaceDeclaration>> rootNamespaces) 829264"];
613 [label="param State(DeclarationTable declarationTable) 829265"];
614 [label="param State(this) 829266"];
615 [label="OrdinalMap 829267"];
616 [label="LoadDirectiveMap 829268"];
617 [label="LoadedSyntaxTreeMap 829269"];
618 [label="RootNamespaces 829270"];
619 [label="DeclarationTable 829271"];
620 [label="Debug.Assert(syntaxTrees.All(tree => syntaxTrees[syntaxTreeOrdinalMap[tree]] == tree)); 829272"];
621 [label="Debug.Assert(syntaxTrees.All(tree => syntaxTrees[syntaxTreeOrdinalMap[tree]] == tree)); 829273"];
622 [label="Debug.Assert(syntaxTrees.SetEquals(rootNamespaces.Keys.AsImmutable(), EqualityComparer<SyntaxTree>.Default)); 829274"];
623 [label="Debug.Assert(syntaxTrees.SetEquals(rootNamespaces.Keys.AsImmutable(), EqualityComparer<SyntaxTree>.Default)); 829275"];
624 [label="Debug.Assert(syntaxTrees.SetEquals(rootNamespaces.Keys.AsImmutable(), EqualityComparer<SyntaxTree>.Default)); 829276"];
625 [label="this.SyntaxTrees 829277"];
626 [label="this.OrdinalMap 829278"];
627 [label="this.LoadDirectiveMap 829279"];
628 [label="this.LoadedSyntaxTreeMap 829280"];
629 [label="this.RootNamespaces 829281"];
630 [label="this.DeclarationTable 829282"];
631 [label="Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null); 829283"];
632 [label="Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null); 829284"];
633 [label="Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null); 829285"];
634 [label="return _lazyState; 829286"];
635 [label="return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; 829287"];
636 [label="var trees = compilation.SyntaxTrees; 829288"];
637 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 829289"];
638 [label="var options = (CSharpParseOptions)trees[0].Options; 829290"];
639 [label="var options = (CSharpParseOptions)trees[0].Options; 829291"];
640 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 829292"];
641 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 829293"];
642 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 829294"];
643 [label="return compilation; 829295"];
644 [label="libComp.VerifyDiagnostics(); 829296"];
645 [label="libComp.VerifyDiagnostics(); 829297"];
646 [label="libComp.VerifyDiagnostics() 829298"];
647 [label="param VerifyDiagnostics(this TCompilation c) 829299"];
648 [label="param VerifyDiagnostics(params DiagnosticDescription[] expected) 829300"];
649 [label="var diagnostics = c.GetDiagnostics(); 829301"];
650 [label="c.GetDiagnostics() 829302"];
651 [label="param GetDiagnostics(CancellationToken cancellationToken = default) 829303"];
652 [label="param GetDiagnostics(this) 829304"];
653 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 829305"];
654 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 829306"];
655 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 829307"];
656 [label="GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken) 829308"];
657 [label="param GetDiagnostics(CompilationStage stage) 829309"];
658 [label="param GetDiagnostics(bool includeEarlierStages) 829310"];
659 [label="param GetDiagnostics(CancellationToken cancellationToken) 829311"];
660 [label="param GetDiagnostics(this) 829312"];
661 [label="var diagnostics = DiagnosticBag.GetInstance(); 829313"];
662 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 829314"];
663 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 829315"];
664 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 829316"];
665 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 829317"];
666 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 829318"];
667 [label="param GetDiagnostics(CompilationStage stage) 829319"];
668 [label="param GetDiagnostics(bool includeEarlierStages) 829320"];
669 [label="param GetDiagnostics(DiagnosticBag diagnostics) 829321"];
670 [label="param GetDiagnostics(CancellationToken cancellationToken = default) 829322"];
671 [label="param GetDiagnostics(this) 829323"];
672 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 829324"];
673 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 829325"];
674 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 829326"];
675 [label="this.SyntaxTrees 829327"];
676 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 829328"];
677 [label="_syntaxAndDeclarations.GetLazyState() 829329"];
678 [label="param GetLazyState(this) 829330"];
679 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 829331"];
680 [label="var syntaxTrees = this.SyntaxTrees; 829332"];
681 [label="this.Options 829333"];
682 [label="get\n            {\n                return _options;\n            } 829334"];
683 [label="return _options; 829335"];
684 [label="if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                } 829336"];
685 [label="RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken); 829337"];
686 [label="RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken); 829338"];
687 [label="RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken); 829339"];
688 [label="RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken); 829340"];
689 [label="param AppendLoadDirectiveDiagnostics(DiagnosticBag builder) 829341"];
690 [label="param AppendLoadDirectiveDiagnostics(SyntaxAndDeclarationManager syntaxAndDeclarations) 829342"];
691 [label="param AppendLoadDirectiveDiagnostics(SyntaxTree syntaxTree) 829343"];
692 [label="param AppendLoadDirectiveDiagnostics(Func<IEnumerable<Diagnostic>, IEnumerable<Diagnostic>>? locationFilterOpt = null) 829344"];
693 [label="ImmutableArray<LoadDirective> loadDirectives; 829345"];
694 [label="loadDirectives 829346"];
695 [label="syntaxAndDeclarations.GetLazyState() 829347"];
696 [label="param GetLazyState(this) 829348"];
697 [label="if (syntaxAndDeclarations.GetLazyState().LoadDirectiveMap.TryGetValue(syntaxTree, out loadDirectives))\n            {\n                Debug.Assert(!loadDirectives.IsEmpty);\n                foreach (var directive in loadDirectives)\n                {\n                    IEnumerable<Diagnostic> diagnostics = directive.Diagnostics;\n                    if (locationFilterOpt != null)\n                    {\n                        diagnostics = locationFilterOpt(diagnostics);\n                    }\n                    builder.AddRange(diagnostics);\n                }\n            } 829349"];
698 [label="if (syntaxAndDeclarations.GetLazyState().LoadDirectiveMap.TryGetValue(syntaxTree, out loadDirectives))\n            {\n                Debug.Assert(!loadDirectives.IsEmpty);\n                foreach (var directive in loadDirectives)\n                {\n                    IEnumerable<Diagnostic> diagnostics = directive.Diagnostics;\n                    if (locationFilterOpt != null)\n                    {\n                        diagnostics = locationFilterOpt(diagnostics);\n                    }\n                    builder.AddRange(diagnostics);\n                }\n            } 829350"];
699 [label="if (syntaxAndDeclarations.GetLazyState().LoadDirectiveMap.TryGetValue(syntaxTree, out loadDirectives))\n            {\n                Debug.Assert(!loadDirectives.IsEmpty);\n                foreach (var directive in loadDirectives)\n                {\n                    IEnumerable<Diagnostic> diagnostics = directive.Diagnostics;\n                    if (locationFilterOpt != null)\n                    {\n                        diagnostics = locationFilterOpt(diagnostics);\n                    }\n                    builder.AddRange(diagnostics);\n                }\n            } 829351"];
700 [label="if (syntaxAndDeclarations.GetLazyState().LoadDirectiveMap.TryGetValue(syntaxTree, out loadDirectives))\n            {\n                Debug.Assert(!loadDirectives.IsEmpty);\n                foreach (var directive in loadDirectives)\n                {\n                    IEnumerable<Diagnostic> diagnostics = directive.Diagnostics;\n                    if (locationFilterOpt != null)\n                    {\n                        diagnostics = locationFilterOpt(diagnostics);\n                    }\n                    builder.AddRange(diagnostics);\n                }\n            } 829352"];
701 [label="var parseOptionsReported = new HashSet<ParseOptions>(); 829353"];
702 [label="foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                } 829354"];
703 [label="cancellationToken.ThrowIfCancellationRequested(); 829355"];
704 [label="if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    } 829356"];
705 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 829357"];
706 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 829358"];
707 [label="CheckAssemblyName(builder); 829359"];
708 [label="CheckAssemblyName(builder); 829360"];
709 [label="CheckAssemblyName(builder); 829361"];
710 [label="get { return _syntaxAndDeclarations.MessageProvider; } 829362"];
711 [label="return _syntaxAndDeclarations.MessageProvider; 829363"];
712 [label="Options 829364"];
713 [label="get\n            {\n                return _options;\n            } 829365"];
714 [label="return _options; 829366"];
715 [label="builder.AddRange(Options.Errors); 829367"];
716 [label="Options 829368"];
717 [label="get\n            {\n                return _options;\n            } 829369"];
718 [label="return _options; 829370"];
719 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 829371"];
720 [label="cancellationToken.ThrowIfCancellationRequested(); 829372"];
721 [label="GetBoundReferenceManager() 829373"];
722 [label="param GetBoundReferenceManager(this) 829374"];
723 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 829375"];
724 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 829376"];
725 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 829377"];
726 [label="get { return this.Declarations.ReferenceDirectives; } 829378"];
727 [label="this.Declarations 829379"];
728 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 829380"];
729 [label="_syntaxAndDeclarations.GetLazyState() 829381"];
730 [label="param GetLazyState(this) 829382"];
731 [label="return _syntaxAndDeclarations.GetLazyState().DeclarationTable; 829383"];
732 [label="return this.Declarations.ReferenceDirectives; 829384"];
733 [label="get { return _options; } 829385"];
734 [label="return _options; 829386"];
735 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 829387"];
736 [label="_syntaxAndDeclarations.GetLazyState() 829388"];
737 [label="Debug.Assert(_lazyAssemblySymbol is object); 829389"];
738 [label="return _referenceManager; 829390"];
739 [label="builder.AddRange(GetBoundReferenceManager().Diagnostics); 829391"];
740 [label="cancellationToken.ThrowIfCancellationRequested(); 829392"];
741 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 829393"];
742 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 829394"];
743 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 829395"];
744 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 829396"];
745 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 829397"];
746 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 829398"];
747 [label="param GetSourceDeclarationDiagnostics(CancellationToken cancellationToken = default) 829399"];
748 [label="param GetSourceDeclarationDiagnostics(this) 829400"];
749 [label="GlobalImports 829401"];
750 [label="=> _globalImports.Value 829402"];
751 [label="_globalImports.Value 829403"];
752 [label="_globalImports.Value 829404"];
753 [label="=> Imports.FromGlobalUsings(this) 829405"];
754 [label="this 829406"];
755 [label="Imports.FromGlobalUsings(this) 829407"];
756 [label="Imports.FromGlobalUsings(this) 829408"];
757 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 829409"];
758 [label="ScriptCompilationInfo 829410"];
759 [label="ScriptCompilationInfo?.PreviousScriptCompilation 829411"];
760 [label="GlobalImports.Complete(cancellationToken); 829412"];
761 [label="GlobalImports.Complete(cancellationToken); 829413"];
762 [label="GlobalImports.Complete(cancellationToken); 829414"];
763 [label="SourceLocation? location = null; 829415"];
764 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 829416"];
765 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 829417"];
766 [label="Assembly 829418"];
767 [label="get\n            {\n                return SourceAssembly;\n            } 829419"];
768 [label="SourceAssembly 829420"];
769 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 829421"];
770 [label="GetBoundReferenceManager() 829422"];
771 [label="param GetBoundReferenceManager(this) 829423"];
772 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 829424"];
773 [label="return _referenceManager; 829425"];
774 [label="GetBoundReferenceManager(); 829426"];
775 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 829427"];
776 [label="return _lazyAssemblySymbol; 829428"];
777 [label="return SourceAssembly; 829429"];
778 [label="Assembly.ForceComplete(location, cancellationToken); 829430"];
779 [label="Assembly.ForceComplete(location, cancellationToken); 829431"];
780 [label="Assembly.ForceComplete(location, cancellationToken); 829432"];
781 [label="Assembly.ForceComplete(location, cancellationToken); 829433"];
782 [label="Assembly.ForceComplete(location, cancellationToken); 829434"];
783 [label="get\n            {\n                return Declarations.GetMergedRoot(this);\n            } 829435"];
784 [label="Declarations 829436"];
785 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 829437"];
786 [label="_syntaxAndDeclarations.GetLazyState() 829438"];
787 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 829439"];
788 [label="return Declarations.GetMergedRoot(this); 829440"];
789 [label="return Declarations.GetMergedRoot(this); 829441"];
790 [label="return Declarations.GetMergedRoot(this); 829442"];
791 [label="_syntaxAndDeclarations.GetLazyState() 829443"];
792 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 829444"];
793 [label="SourceAssembly 829445"];
794 [label="GetBoundReferenceManager() 829446"];
795 [label="param GetBoundReferenceManager(this) 829447"];
796 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 829448"];
797 [label="return _referenceManager; 829449"];
798 [label="GetBoundReferenceManager(); 829450"];
799 [label="get\n            {\n                // We should only be placing diagnostics in this bag until\n                // we are done gathering declaration diagnostics. Assert that is\n                // the case. But since we have bugs (see https://github.com/dotnet/roslyn/issues/846)\n                // we disable the assertion until they are fixed.\n                Debug.Assert(!_declarationDiagnosticsFrozen || true);\n                if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                }\n\n                return _lazyDeclarationDiagnostics;\n            } 829451"];
800 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 829452"];
801 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 829453"];
802 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 829454"];
803 [label="var diagnostics = new DiagnosticBag(); 829455"];
804 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 829456"];
805 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 829457"];
806 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 829458"];
807 [label="return _lazyDeclarationDiagnostics; 829459"];
808 [label="param SymbolDeclaredEvent(Symbol symbol) 829460"];
809 [label="param SymbolDeclaredEvent(this) 829461"];
810 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 829462"];
811 [label="param GetUnaliasedReferencedAssemblies(ArrayBuilder<AssemblySymbol> assemblies) 829463"];
812 [label="param GetUnaliasedReferencedAssemblies(this) 829464"];
813 [label="GetBoundReferenceManager() 829465"];
814 [label="param GetBoundReferenceManager(this) 829466"];
815 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 829467"];
816 [label="return _referenceManager; 829468"];
817 [label="var referenceManager = GetBoundReferenceManager(); 829469"];
818 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 829470"];
819 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 829471"];
820 [label="if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                } 829472"];
821 [label="assemblies.Add(referenceManager.ReferencedAssemblies[i]); 829473"];
822 [label="assemblies.Add(referenceManager.ReferencedAssemblies[i]); 829474"];
823 [label="get\n            {\n                return _additionalCodegenWarnings;\n            } 829475"];
824 [label="return _additionalCodegenWarnings; 829476"];
825 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 829477"];
826 [label="return _referenceManager; 829478"];
827 [label="GetBoundReferenceManager(); 829479"];
828 [label="param GetBinderFactory(SyntaxTree syntaxTree) 829480"];
829 [label="param GetBinderFactory(bool ignoreAccessibility = false) 829481"];
830 [label="param GetBinderFactory(this) 829482"];
831 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 829483"];
832 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 829484"];
833 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 829485"];
834 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 829486"];
835 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 829487"];
836 [label="param GetBinderFactory(SyntaxTree syntaxTree) 829488"];
837 [label="param GetBinderFactory(bool ignoreAccessibility) 829489"];
838 [label="param GetBinderFactory(ref WeakReference<BinderFactory>[]? cachedBinderFactories) 829490"];
839 [label="param GetBinderFactory(this) 829491"];
840 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 829492"];
841 [label="ignoreAccessibility 829493"];
842 [label="_binderFactories 829494"];
843 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 829495"];
844 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 829496"];
845 [label="var treeNum = GetSyntaxTreeOrdinal(syntaxTree); 829497"];
846 [label="GetSyntaxTreeOrdinal(syntaxTree) 829498"];
847 [label="param GetSyntaxTreeOrdinal(SyntaxTree tree) 829499"];
848 [label="param GetSyntaxTreeOrdinal(this) 829500"];
849 [label="Debug.Assert(this.ContainsSyntaxTree(tree)); 829501"];
850 [label="this.ContainsSyntaxTree(tree) 829502"];
851 [label="param ContainsSyntaxTree(SyntaxTree? syntaxTree) 829503"];
852 [label="param ContainsSyntaxTree(this) 829504"];
853 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 829505"];
854 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 829506"];
855 [label="_syntaxAndDeclarations.GetLazyState() 829507"];
856 [label="param GetLazyState(this) 829508"];
857 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 829509"];
858 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 829510"];
859 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 829511"];
860 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 829512"];
861 [label="_syntaxAndDeclarations.GetLazyState() 829513"];
862 [label="param GetLazyState(this) 829514"];
863 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 829515"];
864 [label="return _syntaxAndDeclarations.GetLazyState().OrdinalMap[tree]; 829516"];
865 [label="WeakReference<BinderFactory>[]? binderFactories = cachedBinderFactories; 829517"];
866 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 829518"];
867 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 829519"];
868 [label="this.SyntaxTrees 829520"];
869 [label="param GetLazyState(this) 829521"];
870 [label="binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length]; 829522"];
871 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 829523"];
872 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 829524"];
873 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 829525"];
874 [label="BinderFactory? previousFactory; 829526"];
875 [label="var previousWeakReference = binderFactories[treeNum]; 829527"];
876 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 829528"];
877 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 829529"];
878 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 829530"];
879 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 829531"];
880 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 829532"];
881 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 829533"];
882 [label="param AddNewFactory(SyntaxTree syntaxTree) 829534"];
883 [label="param AddNewFactory(bool ignoreAccessibility) 829535"];
884 [label="param AddNewFactory([NotNull] ref WeakReference<BinderFactory>? slot) 829536"];
885 [label="param AddNewFactory(this) 829537"];
886 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 829538"];
887 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 829539"];
888 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 829540"];
889 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 829541"];
890 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 829542"];
891 [label="var newWeakReference = new WeakReference<BinderFactory>(newFactory); 829543"];
892 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 829544"];
893 [label="BinderFactory? previousFactory; 829545"];
894 [label="WeakReference<BinderFactory>? previousWeakReference = slot; 829546"];
895 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 829547"];
896 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 829548"];
897 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 829549"];
898 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 829550"];
899 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 829551"];
900 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 829552"];
901 [label="return newFactory; 829553"];
902 [label="get\n            {\n                if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                }\n\n                return _lazyGlobalNamespace;\n            } 829554"];
903 [label="if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                } 829555"];
904 [label="var modules = ArrayBuilder<ModuleSymbol>.GetInstance(); 829556"];
905 [label="GetAllUnaliasedModules(modules); 829557"];
906 [label="GetAllUnaliasedModules(modules) 829558"];
907 [label="param GetAllUnaliasedModules(ArrayBuilder<ModuleSymbol> modules) 829559"];
908 [label="param GetAllUnaliasedModules(this) 829560"];
909 [label="Assembly 829561"];
910 [label="get\n            {\n                return SourceAssembly;\n            } 829562"];
911 [label="GetBoundReferenceManager() 829563"];
912 [label="param GetBoundReferenceManager(this) 829564"];
913 [label="GetBoundReferenceManager(); 829565"];
914 [label="modules.AddRange(Assembly.Modules); 829566"];
915 [label="modules.AddRange(Assembly.Modules); 829567"];
916 [label="GetBoundReferenceManager() 829568"];
917 [label="param GetBoundReferenceManager(this) 829569"];
918 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 829570"];
919 [label="return _referenceManager; 829571"];
920 [label="var referenceManager = GetBoundReferenceManager(); 829572"];
921 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                }\n            } 829573"];
922 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                }\n            } 829574"];
923 [label="if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                } 829575"];
924 [label="modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules); 829576"];
925 [label="GetAllUnaliasedModules(modules); 829577"];
926 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 829578"];
927 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 829579"];
928 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 829580"];
929 [label="modules.Free(); 829581"];
930 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 829582"];
931 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 829583"];
932 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 829584"];
933 [label="return _lazyGlobalNamespace; 829585"];
934 [label="get\n            {\n                return Assembly.Modules[0];\n            } 829586"];
935 [label="Assembly 829587"];
936 [label="get\n            {\n                return SourceAssembly;\n            } 829588"];
937 [label="SourceAssembly 829589"];
938 [label="GetBoundReferenceManager() 829590"];
939 [label="param GetBoundReferenceManager(this) 829591"];
940 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 829592"];
941 [label="return _referenceManager; 829593"];
942 [label="GetBoundReferenceManager(); 829594"];
943 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 829595"];
944 [label="return Assembly.Modules[0]; 829596"];
945 [label="return Assembly.Modules[0]; 829597"];
946 [label="var previousWeakReference = binderFactories[treeNum]; 829598"];
947 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 829599"];
948 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 829600"];
949 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 829601"];
950 [label="return previousFactory; 829602"];
951 [label="param ShouldEmitNullableAttributes(Symbol symbol) 829603"];
952 [label="param ShouldEmitNullableAttributes(this) 829604"];
953 [label="RoslynDebug.Assert(symbol is object); 829605"];
954 [label="RoslynDebug.Assert(symbol is object); 829606"];
955 [label="Debug.Assert(symbol.IsDefinition); 829607"];
956 [label="SourceModule 829608"];
957 [label="get\n            {\n                return Assembly.Modules[0];\n            } 829609"];
958 [label="Assembly 829610"];
959 [label="get\n            {\n                return SourceAssembly;\n            } 829611"];
960 [label="SourceAssembly 829612"];
961 [label="GetBoundReferenceManager() 829613"];
962 [label="param GetBoundReferenceManager(this) 829614"];
963 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 829615"];
964 [label="return _referenceManager; 829616"];
965 [label="GetBoundReferenceManager(); 829617"];
966 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 829618"];
967 [label="return Assembly.Modules[0]; 829619"];
968 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 829620"];
969 [label="EmitNullablePublicOnly 829621"];
970 [label="get\n            {\n                if (!_lazyEmitNullablePublicOnly.HasValue())\n                {\n                    // Lafhis\n                    var firstSt = SyntaxTrees.FirstOrDefault();\n                    bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true;\n                    _lazyEmitNullablePublicOnly = value.ToThreeState();\n                }\n                return _lazyEmitNullablePublicOnly.Value();\n            } 829622"];
971 [label="if (!_lazyEmitNullablePublicOnly.HasValue())\n                {\n                    // Lafhis\n                    var firstSt = SyntaxTrees.FirstOrDefault();\n                    bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true;\n                    _lazyEmitNullablePublicOnly = value.ToThreeState();\n                } 829623"];
972 [label="SyntaxTrees 829624"];
973 [label="var firstSt = SyntaxTrees.FirstOrDefault(); 829625"];
974 [label="bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true; 829626"];
975 [label="bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true; 829627"];
976 [label="_lazyEmitNullablePublicOnly = value.ToThreeState(); 829628"];
977 [label="_lazyEmitNullablePublicOnly 829629"];
978 [label="return _lazyEmitNullablePublicOnly.Value(); 829630"];
979 [label="if (!EmitNullablePublicOnly)\n            {\n                return true;\n            } 829631"];
980 [label="return true; 829632"];
981 [label="Debug.Assert(symbol.IsDefinition); 829633"];
982 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 829634"];
983 [label="return _referenceManager; 829635"];
984 [label="GetBoundReferenceManager(); 829636"];
985 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 829637"];
986 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 829638"];
987 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 829639"];
988 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 829640"];
989 [label="_declarationDiagnosticsFrozen = true; 829641"];
990 [label="_declarationDiagnosticsFrozen 829642"];
991 [label="_needsGeneratedAttributes_IsFrozen = true; 829643"];
992 [label="_needsGeneratedAttributes_IsFrozen 829644"];
993 [label="var result = _lazyDeclarationDiagnostics?.AsEnumerable() ?? Enumerable.Empty<Diagnostic>(); 829645"];
994 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 829646"];
995 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 829647"];
996 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 829648"];
997 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 829649"];
998 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 829650"];
999 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 829651"];
1000 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 829652"];
1001 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 829653"];
1002 [label="param GetClsComplianceDiagnostics(CancellationToken cancellationToken) 829654"];
1003 [label="param GetClsComplianceDiagnostics(this) 829655"];
1004 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 829656"];
1005 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 829657"];
1006 [label="if (_lazyClsComplianceDiagnostics.IsDefault)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken);\n                ImmutableInterlocked.InterlockedInitialize(ref _lazyClsComplianceDiagnostics, builder.ToReadOnlyAndFree());\n            } 829658"];
1007 [label="var builder = DiagnosticBag.GetInstance(); 829659"];
1008 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 829660"];
1009 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 829661"];
1010 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 829662"];
1011 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 829663"];
1012 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken) 829664"];
1013 [label="param CheckCompliance(CSharpCompilation compilation) 829665"];
1014 [label="param CheckCompliance(DiagnosticBag diagnostics) 829666"];
1015 [label="param CheckCompliance(CancellationToken cancellationToken) 829667"];
1016 [label="param CheckCompliance(SyntaxTree filterTree = null) 829668"];
1017 [label="param CheckCompliance(TextSpan? filterSpanWithinTree = null) 829669"];
1018 [label="var queue = new ConcurrentQueue<Diagnostic>(); 829670"];
1019 [label="var checker = new ClsComplianceChecker(compilation, filterTree, filterSpanWithinTree, queue, cancellationToken); 829671"];
1020 [label="var checker = new ClsComplianceChecker(compilation, filterTree, filterSpanWithinTree, queue, cancellationToken); 829672"];
1021 [label="var checker = new ClsComplianceChecker(compilation, filterTree, filterSpanWithinTree, queue, cancellationToken); 829673"];
1022 [label="var checker = new ClsComplianceChecker(compilation, filterTree, filterSpanWithinTree, queue, cancellationToken); 829674"];
1023 [label="var checker = new ClsComplianceChecker(compilation, filterTree, filterSpanWithinTree, queue, cancellationToken); 829675"];
1024 [label="var checker = new ClsComplianceChecker(compilation, filterTree, filterSpanWithinTree, queue, cancellationToken); 829676"];
1025 [label="new ClsComplianceChecker(compilation, filterTree, filterSpanWithinTree, queue, cancellationToken) 829677"];
1026 [label="param ClsComplianceChecker(CSharpCompilation compilation) 829678"];
1027 [label="param ClsComplianceChecker(SyntaxTree filterTree) 829679"];
1028 [label="param ClsComplianceChecker(TextSpan? filterSpanWithinTree) 829680"];
1029 [label="param ClsComplianceChecker(ConcurrentQueue<Diagnostic> diagnostics) 829681"];
1030 [label="param ClsComplianceChecker(CancellationToken cancellationToken) 829682"];
1031 [label="param ClsComplianceChecker(this) 829683"];
1032 [label="param ClsComplianceChecker(this) 829684"];
1033 [label="_compilation 829685"];
1034 [label="_filterTree 829686"];
1035 [label="_filterSpanWithinTree 829687"];
1036 [label="_diagnostics 829688"];
1037 [label="_declaredOrInheritedCompliance 829689"];
1038 [label="_compilerTasks 829690"];
1039 [label="_compilation 829691"];
1040 [label="_filterTree 829692"];
1041 [label="_filterSpanWithinTree 829693"];
1042 [label="_diagnostics 829694"];
1043 [label="_cancellationToken 829695"];
1044 [label="_declaredOrInheritedCompliance = new ConcurrentDictionary<Symbol, Compliance>(Symbols.SymbolEqualityComparer.ConsiderEverything); 829696"];
1045 [label="_declaredOrInheritedCompliance 829697"];
1046 [label="ConcurrentAnalysis 829698"];
1047 [label="=> _filterTree == null && _compilation.Options.ConcurrentBuild 829699"];
1048 [label="null 829700"];
1049 [label="_filterTree == null 829701"];
1050 [label="_compilation.Options 829702"];
1051 [label="get\n            {\n                return _options;\n            } 829703"];
1052 [label="_filterTree == null && _compilation.Options.ConcurrentBuild 829704"];
1053 [label="if (ConcurrentAnalysis)\n            {\n                _compilerTasks = new ConcurrentStack<Task>();\n            } 829705"];
1054 [label="_compilerTasks = new ConcurrentStack<Task>(); 829706"];
1055 [label="_compilerTasks 829707"];
1056 [label="compilation.Assembly 829708"];
1057 [label="get\n            {\n                return SourceAssembly;\n            } 829709"];
1058 [label="GetBoundReferenceManager() 829710"];
1059 [label="param GetBoundReferenceManager(this) 829711"];
1060 [label="GetBoundReferenceManager(); 829712"];
1061 [label="checker.Visit(compilation.Assembly); 829713"];
1062 [label="checker.Visit(compilation.Assembly); 829714"];
1063 [label="checker.Visit(compilation.Assembly); 829715"];
1064 [label="param VisitAssembly(AssemblySymbol symbol) 829716"];
1065 [label="param VisitAssembly(this) 829717"];
1066 [label="_cancellationToken.ThrowIfCancellationRequested(); 829718"];
1067 [label="System.Diagnostics.Debug.Assert(symbol is SourceAssemblySymbol); 829719"];
1068 [label="Compliance assemblyCompliance = GetDeclaredOrInheritedCompliance(symbol); 829720"];
1069 [label="GetDeclaredOrInheritedCompliance(symbol) 829721"];
1070 [label="param GetDeclaredOrInheritedCompliance(Symbol symbol) 829722"];
1071 [label="param GetDeclaredOrInheritedCompliance(this) 829723"];
1072 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 829724"];
1073 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 829725"];
1074 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                // Don't bother storing entries for namespaces - just go straight to the assembly.\n                return GetDeclaredOrInheritedCompliance(symbol.ContainingAssembly);\n            }\n            else if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 829726"];
1075 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 829727"];
1076 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 829728"];
1077 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 829729"];
1078 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 829730"];
1079 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 829731"];
1080 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 829732"];
1081 [label="Compliance compliance; 829733"];
1082 [label="if (_declaredOrInheritedCompliance.TryGetValue(symbol, out compliance))\n            {\n                return compliance;\n            } 829734"];
1083 [label="if (_declaredOrInheritedCompliance.TryGetValue(symbol, out compliance))\n            {\n                return compliance;\n            } 829735"];
1084 [label="if (_declaredOrInheritedCompliance.TryGetValue(symbol, out compliance))\n            {\n                return compliance;\n            } 829736"];
1085 [label="Location ignoredLocation; 829737"];
1086 [label="bool? declaredCompliance = GetDeclaredCompliance(symbol, out ignoredLocation); 829738"];
1087 [label="bool? declaredCompliance = GetDeclaredCompliance(symbol, out ignoredLocation); 829739"];
1088 [label="GetDeclaredCompliance(symbol, out ignoredLocation) 829740"];
1089 [label="param GetDeclaredCompliance(Symbol symbol) 829741"];
1090 [label="param GetDeclaredCompliance(out Location attributeLocation) 829742"];
1091 [label="param GetDeclaredCompliance(this) 829743"];
1092 [label="attributeLocation = null; 829744"];
1093 [label="foreach (CSharpAttributeData data in symbol.GetAttributes())\n            {\n                // Check signature before HasErrors to avoid realizing symbols for other attributes.\n                if (data.IsTargetAttribute(symbol, AttributeDescription.CLSCompliantAttribute))\n                {\n                    NamedTypeSymbol attributeClass = data.AttributeClass;\n                    if ((object)attributeClass != null)\n                    {\n                        DiagnosticInfo info = attributeClass.GetUseSiteDiagnostic();\n                        if (info != null)\n                        {\n                            Location location = symbol.Locations.IsEmpty ? NoLocation.Singleton : symbol.Locations[0];\n                            _diagnostics.Enqueue(new CSDiagnostic(info, location));\n                            if (info.Severity >= DiagnosticSeverity.Error)\n                            {\n                                continue;\n                            }\n                        }\n                    }\n\n                    if (!data.HasErrors)\n                    {\n                        if (!TryGetAttributeWarningLocation(data, out attributeLocation))\n                        {\n                            attributeLocation = null;\n                        }\n\n                        ImmutableArray<TypedConstant> args = data.CommonConstructorArguments;\n                        System.Diagnostics.Debug.Assert(args.Length == 1, 'We already checked the signature and HasErrors.');\n\n                        // Duplicates are reported elsewhere - we only care about the first (error-free) occurrence.\n                        return (bool)args[0].ValueInternal;\n                    }\n                }\n            } 829745"];
1094 [label="return null; 829746"];
1095 [label="bool? declaredCompliance = GetDeclaredCompliance(symbol, out ignoredLocation); 829747"];
1096 [label="if (declaredCompliance.HasValue)\n            {\n                compliance = declaredCompliance.GetValueOrDefault() ? Compliance.DeclaredTrue : Compliance.DeclaredFalse;\n            }\n            else if (symbol.Kind == SymbolKind.Assembly)\n            {\n                // Assemblies are not compliant unless specifically declared to be so.\n                compliance = Compliance.ImpliedFalse;\n            }\n            else\n            {\n                compliance = IsTrue(GetInheritedCompliance(symbol)) ? Compliance.InheritedTrue : Compliance.InheritedFalse;\n            } 829748"];
1097 [label="if (symbol.Kind == SymbolKind.Assembly)\n            {\n                // Assemblies are not compliant unless specifically declared to be so.\n                compliance = Compliance.ImpliedFalse;\n            }\n            else\n            {\n                compliance = IsTrue(GetInheritedCompliance(symbol)) ? Compliance.InheritedTrue : Compliance.InheritedFalse;\n            } 829749"];
1098 [label="compliance = Compliance.ImpliedFalse; 829750"];
1099 [label="return (symbol.Kind == SymbolKind.Assembly || symbol.Kind == SymbolKind.NamedType)\n                ? _declaredOrInheritedCompliance.GetOrAdd(symbol, compliance)\n                : compliance; 829751"];
1100 [label="(symbol.Kind == SymbolKind.Assembly || symbol.Kind == SymbolKind.NamedType) 829752"];
1101 [label="return (symbol.Kind == SymbolKind.Assembly || symbol.Kind == SymbolKind.NamedType)\n                ? _declaredOrInheritedCompliance.GetOrAdd(symbol, compliance)\n                : compliance; 829753"];
1102 [label="if (assemblyCompliance == Compliance.DeclaredFalse)\n            {\n                // Our interpretation of an assembly-level CLSCompliant attribute is as follows:\n                //   1) If true, then perform all CLS checks.\n                //   2) If false, then perform no CLS checks (dev11 still performs a few, mostly around\n                //      meaningless attributes).  Our interpretation is that the user ultimately wants\n                //      his code to be CLS-compliant, but is temporarily disabling the checks (e.g. during\n                //      refactoring/prototyping).\n                //   3) If absent, the perform all CLS checks.  Our interpretation is that - in the\n                //      absence of an assembly-level attribute - any CLS problems within the compilation\n                //      indicate that the user was trying to do something but didn't know how.  It would\n                //      be nice if the most common case (i.e. this one) was the cheapest, but we don't\n                //      want to confuse novice users.\n                return;\n            } 829754"];
1103 [label="bool assemblyComplianceValue = IsTrue(assemblyCompliance); 829755"];
1104 [label="IsTrue(assemblyCompliance) 829756"];
1105 [label="param IsTrue(Compliance compliance) 829757"];
1106 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 829758"];
1107 [label="return false; 829759"];
1108 [label="for (int i = 0; i < symbol.Modules.Length; i++)\n            {\n                ModuleSymbol module = symbol.Modules[i];\n                Location attributeLocation;\n                bool? moduleDeclaredCompliance = GetDeclaredCompliance(module, out attributeLocation);\n\n                Location warningLocation = i == 0 ? attributeLocation : module.Locations[0];\n                System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.');\n\n                if (moduleDeclaredCompliance.HasValue)\n                {\n                    if (warningLocation != null)\n                    {\n                        if (!IsDeclared(assemblyCompliance))\n                        {\n                            // This is not useful on non-source modules, but dev11 reports it anyway.\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules, warningLocation);\n                        }\n                        else if (assemblyComplianceValue != moduleDeclaredCompliance.GetValueOrDefault())\n                        {\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules2, warningLocation);\n                        }\n                    }\n                }\n                else if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                }\n            } 829760"];
1109 [label="for (int i = 0; i < symbol.Modules.Length; i++)\n            {\n                ModuleSymbol module = symbol.Modules[i];\n                Location attributeLocation;\n                bool? moduleDeclaredCompliance = GetDeclaredCompliance(module, out attributeLocation);\n\n                Location warningLocation = i == 0 ? attributeLocation : module.Locations[0];\n                System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.');\n\n                if (moduleDeclaredCompliance.HasValue)\n                {\n                    if (warningLocation != null)\n                    {\n                        if (!IsDeclared(assemblyCompliance))\n                        {\n                            // This is not useful on non-source modules, but dev11 reports it anyway.\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules, warningLocation);\n                        }\n                        else if (assemblyComplianceValue != moduleDeclaredCompliance.GetValueOrDefault())\n                        {\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules2, warningLocation);\n                        }\n                    }\n                }\n                else if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                }\n            } 829761"];
1110 [label="ModuleSymbol module = symbol.Modules[i]; 829762"];
1111 [label="Location attributeLocation; 829763"];
1112 [label="bool? moduleDeclaredCompliance = GetDeclaredCompliance(module, out attributeLocation); 829764"];
1113 [label="bool? moduleDeclaredCompliance = GetDeclaredCompliance(module, out attributeLocation); 829765"];
1114 [label="GetDeclaredCompliance(module, out attributeLocation) 829766"];
1115 [label="param GetDeclaredCompliance(Symbol symbol) 829767"];
1116 [label="param GetDeclaredCompliance(out Location attributeLocation) 829768"];
1117 [label="param GetDeclaredCompliance(this) 829769"];
1118 [label="attributeLocation = null; 829770"];
1119 [label="bool? moduleDeclaredCompliance = GetDeclaredCompliance(module, out attributeLocation); 829771"];
1120 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 829772"];
1121 [label="i == 0 829773"];
1122 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 829774"];
1123 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 829775"];
1124 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 829776"];
1125 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 829777"];
1126 [label="if (moduleDeclaredCompliance.HasValue)\n                {\n                    if (warningLocation != null)\n                    {\n                        if (!IsDeclared(assemblyCompliance))\n                        {\n                            // This is not useful on non-source modules, but dev11 reports it anyway.\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules, warningLocation);\n                        }\n                        else if (assemblyComplianceValue != moduleDeclaredCompliance.GetValueOrDefault())\n                        {\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules2, warningLocation);\n                        }\n                    }\n                }\n                else if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 829778"];
1127 [label="if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 829779"];
1128 [label="if (assemblyComplianceValue)\n            {\n                CheckForAttributeWithArrayArgument(symbol);\n            } 829780"];
1129 [label="ModuleSymbol sourceModule = symbol.Modules[0]; 829781"];
1130 [label="ModuleSymbol sourceModule = symbol.Modules[0]; 829782"];
1131 [label="if (IsTrue(GetDeclaredOrInheritedCompliance(sourceModule)))\n            {\n                CheckForAttributeWithArrayArgument(sourceModule);\n            } 829783"];
1132 [label="GetDeclaredOrInheritedCompliance(sourceModule) 829784"];
1133 [label="param GetDeclaredOrInheritedCompliance(Symbol symbol) 829785"];
1134 [label="param GetDeclaredOrInheritedCompliance(this) 829786"];
1135 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 829787"];
1136 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 829788"];
1137 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                // Don't bother storing entries for namespaces - just go straight to the assembly.\n                return GetDeclaredOrInheritedCompliance(symbol.ContainingAssembly);\n            }\n            else if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 829789"];
1138 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 829790"];
1139 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 829791"];
1140 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 829792"];
1141 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 829793"];
1142 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 829794"];
1143 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 829795"];
1144 [label="Compliance compliance; 829796"];
1145 [label="if (_declaredOrInheritedCompliance.TryGetValue(symbol, out compliance))\n            {\n                return compliance;\n            } 829797"];
1146 [label="Location ignoredLocation; 829798"];
1147 [label="bool? declaredCompliance = GetDeclaredCompliance(symbol, out ignoredLocation); 829799"];
1148 [label="GetDeclaredCompliance(symbol, out ignoredLocation) 829800"];
1149 [label="param GetDeclaredCompliance(out Location attributeLocation) 829801"];
1150 [label="param GetDeclaredCompliance(this) 829802"];
1151 [label="attributeLocation = null; 829803"];
1152 [label="return null; 829804"];
1153 [label="bool? declaredCompliance = GetDeclaredCompliance(symbol, out ignoredLocation); 829805"];
1154 [label="if (declaredCompliance.HasValue)\n            {\n                compliance = declaredCompliance.GetValueOrDefault() ? Compliance.DeclaredTrue : Compliance.DeclaredFalse;\n            }\n            else if (symbol.Kind == SymbolKind.Assembly)\n            {\n                // Assemblies are not compliant unless specifically declared to be so.\n                compliance = Compliance.ImpliedFalse;\n            }\n            else\n            {\n                compliance = IsTrue(GetInheritedCompliance(symbol)) ? Compliance.InheritedTrue : Compliance.InheritedFalse;\n            } 829806"];
1155 [label="compliance = IsTrue(GetInheritedCompliance(symbol)) ? Compliance.InheritedTrue : Compliance.InheritedFalse; 829807"];
1156 [label="GetInheritedCompliance(symbol) 829808"];
1157 [label="param GetInheritedCompliance(Symbol symbol) 829809"];
1158 [label="param GetInheritedCompliance(this) 829810"];
1159 [label="System.Diagnostics.Debug.Assert(symbol.Kind != SymbolKind.Assembly); 829811"];
1160 [label="Symbol containing = (Symbol)symbol.ContainingType ?? symbol.ContainingAssembly; 829812"];
1161 [label="System.Diagnostics.Debug.Assert((object)containing != null); 829813"];
1162 [label="System.Diagnostics.Debug.Assert((object)containing != null); 829814"];
1163 [label="return GetDeclaredOrInheritedCompliance(containing); 829815"];
1164 [label="GetDeclaredOrInheritedCompliance(containing) 829816"];
1165 [label="param GetDeclaredOrInheritedCompliance(Symbol symbol) 829817"];
1166 [label="param GetDeclaredOrInheritedCompliance(this) 829818"];
1167 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 829819"];
1168 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 829820"];
1169 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                // Don't bother storing entries for namespaces - just go straight to the assembly.\n                return GetDeclaredOrInheritedCompliance(symbol.ContainingAssembly);\n            }\n            else if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 829821"];
1170 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 829822"];
1171 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 829823"];
1172 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 829824"];
1173 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 829825"];
1174 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 829826"];
1175 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 829827"];
1176 [label="if (_declaredOrInheritedCompliance.TryGetValue(symbol, out compliance))\n            {\n                return compliance;\n            } 829828"];
1177 [label="return compliance; 829829"];
1178 [label="IsTrue(GetInheritedCompliance(symbol)) 829830"];
1179 [label="param IsTrue(Compliance compliance) 829831"];
1180 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 829832"];
1181 [label="return false; 829833"];
1182 [label="IsTrue(GetDeclaredOrInheritedCompliance(sourceModule)) 829834"];
1183 [label="param IsTrue(Compliance compliance) 829835"];
1184 [label="Visit(symbol.GlobalNamespace); 829836"];
1185 [label="Visit(symbol.GlobalNamespace); 829837"];
1186 [label="param VisitNamespace(NamespaceSymbol symbol) 829838"];
1187 [label="param VisitNamespace(this) 829839"];
1188 [label="_cancellationToken.ThrowIfCancellationRequested(); 829840"];
1189 [label="if (DoNotVisit(symbol)) return; 829841"];
1190 [label="DoNotVisit(symbol) 829842"];
1191 [label="param DoNotVisit(Symbol symbol) 829843"];
1192 [label="param DoNotVisit(this) 829844"];
1193 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                return false;\n            } 829845"];
1194 [label="return false; 829846"];
1195 [label="if (IsTrue(GetDeclaredOrInheritedCompliance(symbol)))\n            {\n                CheckName(symbol);\n                CheckMemberDistinctness(symbol);\n            } 829847"];
1196 [label="GetDeclaredOrInheritedCompliance(symbol) 829848"];
1197 [label="param GetDeclaredOrInheritedCompliance(Symbol symbol) 829849"];
1198 [label="param GetDeclaredOrInheritedCompliance(this) 829850"];
1199 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 829851"];
1200 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 829852"];
1201 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                // Don't bother storing entries for namespaces - just go straight to the assembly.\n                return GetDeclaredOrInheritedCompliance(symbol.ContainingAssembly);\n            }\n            else if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 829853"];
1202 [label="return GetDeclaredOrInheritedCompliance(symbol.ContainingAssembly); 829854"];
1203 [label="GetDeclaredOrInheritedCompliance(symbol.ContainingAssembly) 829855"];
1204 [label="param GetDeclaredOrInheritedCompliance(Symbol symbol) 829856"];
1205 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 829857"];
1206 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 829858"];
1207 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 829859"];
1208 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 829860"];
1209 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 829861"];
1210 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 829862"];
1211 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 829863"];
1212 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 829864"];
1213 [label="return compliance; 829865"];
1214 [label="IsTrue(GetDeclaredOrInheritedCompliance(symbol)) 829866"];
1215 [label="param IsTrue(Compliance compliance) 829867"];
1216 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 829868"];
1217 [label="return false; 829869"];
1218 [label="ConcurrentAnalysis 829870"];
1219 [label="=> _filterTree == null && _compilation.Options.ConcurrentBuild 829871"];
1220 [label="null 829872"];
1221 [label="_filterTree == null 829873"];
1222 [label="_compilation.Options 829874"];
1223 [label="get\n            {\n                return _options;\n            } 829875"];
1224 [label="if (ConcurrentAnalysis)\n            {\n                VisitNamespaceMembersAsTasks(symbol);\n            }\n            else\n            {\n                VisitNamespaceMembers(symbol);\n            } 829876"];
1225 [label="VisitNamespaceMembersAsTasks(symbol); 829877"];
1226 [label="VisitNamespaceMembersAsTasks(symbol) 829878"];
1227 [label="param VisitNamespaceMembersAsTasks(NamespaceSymbol symbol) 829879"];
1228 [label="param VisitNamespaceMembersAsTasks(this) 829880"];
1229 [label="foreach (var m in symbol.GetMembersUnordered())\n            {\n                _compilerTasks.Push(Task.Run(UICultureUtilities.WithCurrentUICulture(() =>\n                {\n                    try\n                    {\n                        Visit(m);\n                    }\n                    catch (Exception e) when (FatalError.ReportAndPropagateUnlessCanceled(e))\n                    {\n                        throw ExceptionUtilities.Unreachable;\n                    }\n                }), _cancellationToken));\n            } 829881"];
1230 [label="_compilerTasks.Push(Task.Run(UICultureUtilities.WithCurrentUICulture(() =>\n                {\n                    try\n                    {\n                        Visit(m);\n                    }\n                    catch (Exception e) when (FatalError.ReportAndPropagateUnlessCanceled(e))\n                    {\n                        throw ExceptionUtilities.Unreachable;\n                    }\n                }), _cancellationToken)); 829882"];
1231 [label="_compilerTasks.Push(Task.Run(UICultureUtilities.WithCurrentUICulture(() =>\n                {\n                    try\n                    {\n                        Visit(m);\n                    }\n                    catch (Exception e) when (FatalError.ReportAndPropagateUnlessCanceled(e))\n                    {\n                        throw ExceptionUtilities.Unreachable;\n                    }\n                }), _cancellationToken)); 829883"];
1232 [label="VisitNamespaceMembersAsTasks(symbol); 829884"];
1233 [label="checker.WaitForWorkers() 829885"];
1234 [label="param WaitForWorkers(this) 829886"];
1235 [label="var tasks = _compilerTasks; 829887"];
1236 [label="if (tasks == null)\n            {\n                return;\n            } 829888"];
1237 [label="if (tasks == null)\n            {\n                return;\n            } 829889"];
1238 [label="while (tasks.TryPop(out Task curTask))\n            {\n                curTask.GetAwaiter().GetResult();\n            } 829890"];
1239 [label="while (tasks.TryPop(out Task curTask))\n            {\n                curTask.GetAwaiter().GetResult();\n            } 829891"];
1240 [label="curTask.GetAwaiter().GetResult(); 829892"];
1241 [label="checker.WaitForWorkers(); 829893"];
1242 [label="foreach (Diagnostic diag in queue)\n            {\n                diagnostics.Add(diag);\n            } 829894"];
1243 [label="foreach (Diagnostic diag in queue)\n            {\n                diagnostics.Add(diag);\n            } 829895"];
1244 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyClsComplianceDiagnostics, builder.ToReadOnlyAndFree()); 829896"];
1245 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyClsComplianceDiagnostics, builder.ToReadOnlyAndFree()); 829897"];
1246 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyClsComplianceDiagnostics, builder.ToReadOnlyAndFree()); 829898"];
1247 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 829899"];
1248 [label="return _lazyClsComplianceDiagnostics; 829900"];
1249 [label="return result.AsImmutable().Concat(clsDiagnostics); 829901"];
1250 [label="return result.AsImmutable().Concat(clsDiagnostics); 829902"];
1251 [label="return result.AsImmutable().Concat(clsDiagnostics); 829903"];
1252 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 829904"];
1253 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 829905"];
1254 [label="cancellationToken.ThrowIfCancellationRequested(); 829906"];
1255 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 829907"];
1256 [label="var methodBodyDiagnostics = DiagnosticBag.GetInstance(); 829908"];
1257 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 829909"];
1258 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 829910"];
1259 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken) 829911"];
1260 [label="param GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics) 829912"];
1261 [label="param GetDiagnosticsForAllMethodBodies(CancellationToken cancellationToken) 829913"];
1262 [label="param GetDiagnosticsForAllMethodBodies(this) 829914"];
1263 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 829915"];
1264 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 829916"];
1265 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 829917"];
1266 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 829918"];
1267 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken) 829919"];
1268 [label="param CompileMethodBodies(CSharpCompilation compilation) 829920"];
1269 [label="param CompileMethodBodies(PEModuleBuilder moduleBeingBuiltOpt) 829921"];
1270 [label="param CompileMethodBodies(bool emittingPdb) 829922"];
1271 [label="param CompileMethodBodies(bool emitTestCoverageData) 829923"];
1272 [label="param CompileMethodBodies(bool hasDeclarationErrors) 829924"];
1273 [label="param CompileMethodBodies(DiagnosticBag diagnostics) 829925"];
1274 [label="param CompileMethodBodies(Predicate<Symbol> filterOpt) 829926"];
1275 [label="param CompileMethodBodies(CancellationToken cancellationToken) 829927"];
1276 [label="Debug.Assert(compilation != null); 829928"];
1277 [label="Debug.Assert(compilation != null); 829929"];
1278 [label="Debug.Assert(diagnostics != null); 829930"];
1279 [label="Debug.Assert(diagnostics != null); 829931"];
1280 [label="compilation.PreviousSubmission 829932"];
1281 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 829933"];
1282 [label="ScriptCompilationInfo 829934"];
1283 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 829935"];
1284 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 829936"];
1285 [label="MethodSymbol entryPoint = null; 829937"];
1286 [label="if (filterOpt is null)\n            {\n                entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken);\n            } 829938"];
1287 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 829939"];
1288 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 829940"];
1289 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 829941"];
1290 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 829942"];
1291 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 829943"];
1292 [label="GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken) 829944"];
1293 [label="param GetEntryPoint(CSharpCompilation compilation) 829945"];
1294 [label="param GetEntryPoint(PEModuleBuilder moduleBeingBuilt) 829946"];
1295 [label="param GetEntryPoint(bool hasDeclarationErrors) 829947"];
1296 [label="param GetEntryPoint(DiagnosticBag diagnostics) 829948"];
1297 [label="param GetEntryPoint(CancellationToken cancellationToken) 829949"];
1298 [label="var entryPointAndDiagnostics = compilation.GetEntryPointAndDiagnostics(cancellationToken); 829950"];
1299 [label="compilation.GetEntryPointAndDiagnostics(cancellationToken) 829951"];
1300 [label="param GetEntryPointAndDiagnostics(CancellationToken cancellationToken) 829952"];
1301 [label="param GetEntryPointAndDiagnostics(this) 829953"];
1302 [label="if (_lazyEntryPoint == null)\n            {\n                EntryPoint? entryPoint;\n                var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this);\n\n                if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                }\n\n                Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null);\n            } 829954"];
1303 [label="if (_lazyEntryPoint == null)\n            {\n                EntryPoint? entryPoint;\n                var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this);\n\n                if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                }\n\n                Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null);\n            } 829955"];
1304 [label="EntryPoint? entryPoint; 829956"];
1305 [label="var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this); 829957"];
1306 [label="var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this); 829958"];
1307 [label="GetBoundReferenceManager() 829959"];
1308 [label="GetBoundReferenceManager(); 829960"];
1309 [label="this.Options 829961"];
1310 [label="return _options; 829962"];
1311 [label="if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                } 829963"];
1312 [label="this.ScriptClass 829964"];
1313 [label="get { return _scriptClass.Value; } 829965"];
1314 [label="return _scriptClass.Value; 829966"];
1315 [label="_scriptClass.Value 829967"];
1316 [label="param BindScriptClass(this) 829968"];
1317 [label="return (ImplicitNamedTypeSymbol?)CommonBindScriptClass().GetSymbol(); 829969"];
1318 [label="return (ImplicitNamedTypeSymbol?)CommonBindScriptClass().GetSymbol(); 829970"];
1319 [label="get { return this.SourceModule.GetPublicSymbol(); } 829971"];
1320 [label="this.SourceModule 829972"];
1321 [label="get\n            {\n                return Assembly.Modules[0];\n            } 829973"];
1322 [label="GetBoundReferenceManager() 829974"];
1323 [label="param GetBoundReferenceManager(this) 829975"];
1324 [label="GetBoundReferenceManager(); 829976"];
1325 [label="return this.SourceModule.GetPublicSymbol(); 829977"];
1326 [label="get\n            {\n                return this.SyntaxTrees;\n            } 829978"];
1327 [label="this.SyntaxTrees 829979"];
1328 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 829980"];
1329 [label="param GetLazyState(this) 829981"];
1330 [label="return this.SyntaxTrees; 829982"];
1331 [label="if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                } 829983"];
1332 [label="if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                } 829984"];
1333 [label="if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    } 829985"];
1334 [label="null 829986"];
1335 [label="ImmutableArray<Diagnostic>.Empty 829987"];
1336 [label="new EntryPoint(null, ImmutableArray<Diagnostic>.Empty) 829988"];
1337 [label="param EntryPoint(MethodSymbol? methodSymbol) 829989"];
1338 [label="param EntryPoint(ImmutableArray<Diagnostic> diagnostics) 829990"];
1339 [label="param EntryPoint(this) 829991"];
1340 [label="MethodSymbol 829992"];
1341 [label="this.MethodSymbol 829993"];
1342 [label="this.Diagnostics 829994"];
1343 [label="None = new EntryPoint(null, ImmutableArray<Diagnostic>.Empty) 829995"];
1344 [label="entryPoint = EntryPoint.None; 829996"];
1345 [label="Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null); 829997"];
1346 [label="Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null); 829998"];
1347 [label="Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null); 829999"];
1348 [label="Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null); 830000"];
1349 [label="return _lazyEntryPoint; 830001"];
1350 [label="var entryPointAndDiagnostics = compilation.GetEntryPointAndDiagnostics(cancellationToken); 830002"];
1351 [label="Debug.Assert(!entryPointAndDiagnostics.Diagnostics.IsDefault); 830003"];
1352 [label="diagnostics.AddRange(entryPointAndDiagnostics.Diagnostics); 830004"];
1353 [label="diagnostics.AddRange(entryPointAndDiagnostics.Diagnostics); 830005"];
1354 [label="var entryPoint = entryPointAndDiagnostics.MethodSymbol; 830006"];
1355 [label="if ((object)entryPoint == null)\n            {\n                return null;\n            } 830007"];
1356 [label="if ((object)entryPoint == null)\n            {\n                return null;\n            } 830008"];
1357 [label="return null; 830009"];
1358 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 830010"];
1359 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 830011"];
1360 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 830012"];
1361 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 830013"];
1362 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 830014"];
1363 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 830015"];
1364 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 830016"];
1365 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 830017"];
1366 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 830018"];
1367 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 830019"];
1368 [label="new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken) 830020"];
1369 [label="param MethodCompiler(CSharpCompilation compilation) 830021"];
1370 [label="param MethodCompiler(PEModuleBuilder moduleBeingBuiltOpt) 830022"];
1371 [label="param MethodCompiler(bool emittingPdb) 830023"];
1372 [label="param MethodCompiler(bool emitTestCoverageData) 830024"];
1373 [label="param MethodCompiler(bool hasDeclarationErrors) 830025"];
1374 [label="param MethodCompiler(DiagnosticBag diagnostics) 830026"];
1375 [label="param MethodCompiler(Predicate<Symbol> filterOpt) 830027"];
1376 [label="param MethodCompiler(SynthesizedEntryPointSymbol.AsyncForwardEntryPoint entryPointOpt) 830028"];
1377 [label="param MethodCompiler(CancellationToken cancellationToken) 830029"];
1378 [label="param MethodCompiler(this) 830030"];
1379 [label="param MethodCompiler(this) 830031"];
1380 [label="_compilation 830032"];
1381 [label="_emittingPdb 830033"];
1382 [label="_emitTestCoverageData 830034"];
1383 [label="_diagnostics 830035"];
1384 [label="_hasDeclarationErrors 830036"];
1385 [label="_moduleBeingBuiltOpt 830037"];
1386 [label="_filterOpt 830038"];
1387 [label="_debugDocumentProvider 830039"];
1388 [label="_entryPointOpt 830040"];
1389 [label="_compilerTasks 830041"];
1390 [label="_globalHasErrors 830042"];
1391 [label="Debug.Assert(compilation != null); 830043"];
1392 [label="Debug.Assert(compilation != null); 830044"];
1393 [label="Debug.Assert(diagnostics != null); 830045"];
1394 [label="Debug.Assert(diagnostics != null); 830046"];
1395 [label="_compilation 830047"];
1396 [label="_moduleBeingBuiltOpt 830048"];
1397 [label="_emittingPdb 830049"];
1398 [label="_cancellationToken 830050"];
1399 [label="_diagnostics 830051"];
1400 [label="_filterOpt 830052"];
1401 [label="_entryPointOpt 830053"];
1402 [label="_hasDeclarationErrors 830054"];
1403 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 830055"];
1404 [label="SetGlobalErrorIfTrue(hasDeclarationErrors) 830056"];
1405 [label="param SetGlobalErrorIfTrue(bool arg) 830057"];
1406 [label="param SetGlobalErrorIfTrue(this) 830058"];
1407 [label="if (arg)\n            {\n                _globalHasErrors = true;\n            } 830059"];
1408 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 830060"];
1409 [label="if (emittingPdb || emitTestCoverageData)\n            {\n                _debugDocumentProvider = (path, basePath) => moduleBeingBuiltOpt.DebugDocumentsBuilder.GetOrAddDebugDocument(path, basePath, CreateDebugDocumentForFile);\n            } 830061"];
1410 [label="_emitTestCoverageData 830062"];
1411 [label="compilation.Options 830063"];
1412 [label="get\n            {\n                return _options;\n            } 830064"];
1413 [label="return _options; 830065"];
1414 [label="if (compilation.Options.ConcurrentBuild)\n            {\n                methodCompiler._compilerTasks = new ConcurrentStack<Task>();\n            } 830066"];
1415 [label="methodCompiler._compilerTasks = new ConcurrentStack<Task>(); 830067"];
1416 [label="methodCompiler._compilerTasks 830068"];
1417 [label="compilation.SourceModule 830069"];
1418 [label="get\n            {\n                return Assembly.Modules[0];\n            } 830070"];
1419 [label="Assembly 830071"];
1420 [label="get\n            {\n                return SourceAssembly;\n            } 830072"];
1421 [label="SourceAssembly 830073"];
1422 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 830074"];
1423 [label="GetBoundReferenceManager() 830075"];
1424 [label="param GetBoundReferenceManager(this) 830076"];
1425 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 830077"];
1426 [label="return _referenceManager; 830078"];
1427 [label="GetBoundReferenceManager(); 830079"];
1428 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 830080"];
1429 [label="return Assembly.Modules[0]; 830081"];
1430 [label="methodCompiler.CompileNamespace(compilation.SourceModule.GlobalNamespace); 830082"];
1431 [label="methodCompiler.CompileNamespace(compilation.SourceModule.GlobalNamespace) 830083"];
1432 [label="param CompileNamespace(NamespaceSymbol symbol) 830084"];
1433 [label="param CompileNamespace(this) 830085"];
1434 [label="foreach (var s in symbol.GetMembersUnordered())\n            {\n                s.Accept(this, null);\n            } 830086"];
1435 [label="s.Accept(this, null); 830087"];
1436 [label="s.Accept(this, null); 830088"];
1437 [label="s.Accept(this, null); 830089"];
1438 [label="param VisitNamedType(NamedTypeSymbol symbol) 830090"];
1439 [label="param VisitNamedType(TypeCompilationState arg) 830091"];
1440 [label="param VisitNamedType(this) 830092"];
1441 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 830093"];
1442 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 830094"];
1443 [label="PassesFilter(_filterOpt, symbol) 830095"];
1444 [label="param PassesFilter(Predicate<Symbol> filterOpt) 830096"];
1445 [label="param PassesFilter(Symbol symbol) 830097"];
1446 [label="return (filterOpt == null) || filterOpt(symbol); 830098"];
1447 [label="return (filterOpt == null) || filterOpt(symbol); 830099"];
1448 [label="arg = null; 830100"];
1449 [label="_cancellationToken.ThrowIfCancellationRequested(); 830101"];
1450 [label="_compilation.Options 830102"];
1451 [label="get\n            {\n                return _options;\n            } 830103"];
1452 [label="if (_compilation.Options.ConcurrentBuild)\n            {\n                Task worker = CompileNamedTypeAsync(symbol);\n                _compilerTasks.Push(worker);\n            }\n            else\n            {\n                CompileNamedType(symbol);\n            } 830104"];
1453 [label="Task worker = CompileNamedTypeAsync(symbol); 830105"];
1454 [label="CompileNamedTypeAsync(symbol) 830106"];
1455 [label="param CompileNamedTypeAsync(NamedTypeSymbol symbol) 830107"];
1456 [label="param CompileNamedTypeAsync(this) 830108"];
1457 [label="return Task.Run(UICultureUtilities.WithCurrentUICulture(() =>\n                {\n                    try\n                    {\n                        CompileNamedType(symbol);\n                    }\n                    catch (Exception e) when (FatalError.ReportAndPropagateUnlessCanceled(e))\n                    {\n                        throw ExceptionUtilities.Unreachable;\n                    }\n                }), _cancellationToken); 830109"];
1458 [label="return Task.Run(UICultureUtilities.WithCurrentUICulture(() =>\n                {\n                    try\n                    {\n                        CompileNamedType(symbol);\n                    }\n                    catch (Exception e) when (FatalError.ReportAndPropagateUnlessCanceled(e))\n                    {\n                        throw ExceptionUtilities.Unreachable;\n                    }\n                }), _cancellationToken); 830110"];
1459 [label="Task worker = CompileNamedTypeAsync(symbol); 830111"];
1460 [label="_compilerTasks.Push(worker); 830112"];
1461 [label="return null; 830113"];
1462 [label="s.Accept(this, null); 830114"];
1463 [label="methodCompiler.CompileNamespace(compilation.SourceModule.GlobalNamespace); 830115"];
1464 [label="methodCompiler.WaitForWorkers() 830116"];
1465 [label="param WaitForWorkers(this) 830117"];
1466 [label="var tasks = _compilerTasks; 830118"];
1467 [label="if (tasks == null)\n            {\n                return;\n            } 830119"];
1468 [label="if (tasks == null)\n            {\n                return;\n            } 830120"];
1469 [label="Task curTask; 830121"];
1470 [label="while (tasks.TryPop(out curTask))\n            {\n                curTask.GetAwaiter().GetResult();\n            } 830122"];
1471 [label="while (tasks.TryPop(out curTask))\n            {\n                curTask.GetAwaiter().GetResult();\n            } 830123"];
1472 [label="curTask.GetAwaiter().GetResult(); 830124"];
1473 [label="methodCompiler.WaitForWorkers(); 830125"];
1474 [label="if (moduleBeingBuiltOpt != null)\n            {\n                var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics);\n\n                var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics);\n\n                // By this time we have processed all types reachable from module's global namespace\n                compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics);\n                methodCompiler.WaitForWorkers();\n\n                var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass;\n                if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                }\n            } 830126"];
1475 [label="if (moduleBeingBuiltOpt != null)\n            {\n                var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics);\n\n                var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics);\n\n                // By this time we have processed all types reachable from module's global namespace\n                compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics);\n                methodCompiler.WaitForWorkers();\n\n                var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass;\n                if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                }\n            } 830127"];
1476 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 830128"];
1477 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 830129"];
1478 [label="compilation.AdditionalCodegenWarnings 830130"];
1479 [label="get\n            {\n                return _additionalCodegenWarnings;\n            } 830131"];
1480 [label="return _additionalCodegenWarnings; 830132"];
1481 [label="diagnostics.AddRange(compilation.AdditionalCodegenWarnings); 830133"];
1482 [label="if (filterOpt == null)\n            {\n                WarnUnusedFields(compilation, diagnostics, cancellationToken);\n\n                if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                }\n            } 830134"];
1483 [label="if (filterOpt == null)\n            {\n                WarnUnusedFields(compilation, diagnostics, cancellationToken);\n\n                if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                }\n            } 830135"];
1484 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 830136"];
1485 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 830137"];
1486 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 830138"];
1487 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken) 830139"];
1488 [label="param WarnUnusedFields(CSharpCompilation compilation) 830140"];
1489 [label="param WarnUnusedFields(DiagnosticBag diagnostics) 830141"];
1490 [label="param WarnUnusedFields(CancellationToken cancellationToken) 830142"];
1491 [label="compilation.Assembly 830143"];
1492 [label="get\n            {\n                return SourceAssembly;\n            } 830144"];
1493 [label="SourceAssembly 830145"];
1494 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 830146"];
1495 [label="GetBoundReferenceManager() 830147"];
1496 [label="param GetBoundReferenceManager(this) 830148"];
1497 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 830149"];
1498 [label="return _referenceManager; 830150"];
1499 [label="GetBoundReferenceManager(); 830151"];
1500 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 830152"];
1501 [label="SourceAssemblySymbol assembly = (SourceAssemblySymbol)compilation.Assembly; 830153"];
1502 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 830154"];
1503 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 830155"];
1504 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 830156"];
1505 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 830157"];
1506 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 830158"];
1507 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 830159"];
1508 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 830160"];
1509 [label="new[] { '\\r\\n', '\\r', '\\n' } 830161"];
1510 [label="'\\r\\n' 830162"];
1511 [label="'\\r' 830163"];
1512 [label="'\\n' 830164"];
1513 [label="new[] { '\\r\\n', '\\r', '\\n' } 830165"];
1514 [label="new[] { '\\r\\n', '\\r', '\\n' } 830166"];
1515 [label="new[] { '\\r\\n', '\\r', '\\n' } 830167"];
1516 [label="s_newLineSequences = new[] { '\\r\\n', '\\r', '\\n' } 830168"];
1517 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 830169"];
1518 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 830170"];
1519 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 830171"];
1520 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 830172"];
1521 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken) 830173"];
1522 [label="param WriteDocumentationCommentXml(CSharpCompilation compilation) 830174"];
1523 [label="param WriteDocumentationCommentXml(string? assemblyName) 830175"];
1524 [label="param WriteDocumentationCommentXml(Stream? xmlDocStream) 830176"];
1525 [label="param WriteDocumentationCommentXml(DiagnosticBag diagnostics) 830177"];
1526 [label="param WriteDocumentationCommentXml(CancellationToken cancellationToken) 830178"];
1527 [label="param WriteDocumentationCommentXml(SyntaxTree? filterTree = null) 830179"];
1528 [label="param WriteDocumentationCommentXml(TextSpan? filterSpanWithinTree = null) 830180"];
1529 [label="StreamWriter writer = null; 830181"];
1530 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 830182"];
1531 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 830183"];
1532 [label="compilation.SourceAssembly 830184"];
1533 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 830185"];
1534 [label="GetBoundReferenceManager() 830186"];
1535 [label="param GetBoundReferenceManager(this) 830187"];
1536 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 830188"];
1537 [label="return _referenceManager; 830189"];
1538 [label="GetBoundReferenceManager(); 830190"];
1539 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 830191"];
1540 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 830192"];
1541 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 830193"];
1542 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 830194"];
1543 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 830195"];
1544 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 830196"];
1545 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 830197"];
1546 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 830198"];
1547 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 830199"];
1548 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 830200"];
1549 [label="new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken) 830201"];
1550 [label="param DocumentationCommentCompiler(string assemblyName) 830202"];
1551 [label="param DocumentationCommentCompiler(CSharpCompilation compilation) 830203"];
1552 [label="param DocumentationCommentCompiler(TextWriter writer) 830204"];
1553 [label="param DocumentationCommentCompiler(SyntaxTree filterTree) 830205"];
1554 [label="param DocumentationCommentCompiler(TextSpan? filterSpanWithinTree) 830206"];
1555 [label="param DocumentationCommentCompiler(bool processIncludes) 830207"];
1556 [label="param DocumentationCommentCompiler(bool isForSingleSymbol) 830208"];
1557 [label="param DocumentationCommentCompiler(DiagnosticBag diagnostics) 830209"];
1558 [label="param DocumentationCommentCompiler(CancellationToken cancellationToken) 830210"];
1559 [label="param DocumentationCommentCompiler(this) 830211"];
1560 [label="param DocumentationCommentCompiler(this) 830212"];
1561 [label="_assemblyName 830213"];
1562 [label="_compilation 830214"];
1563 [label="_writer 830215"];
1564 [label="_filterTree 830216"];
1565 [label="_filterSpanWithinTree 830217"];
1566 [label="_processIncludes 830218"];
1567 [label="_isForSingleSymbol 830219"];
1568 [label="_diagnostics 830220"];
1569 [label="_lazyComparer 830221"];
1570 [label="_includedFileCache 830222"];
1571 [label="_indentDepth 830223"];
1572 [label="_temporaryStringBuilders 830224"];
1573 [label="_assemblyName 830225"];
1574 [label="_compilation 830226"];
1575 [label="_writer 830227"];
1576 [label="_filterTree 830228"];
1577 [label="_filterSpanWithinTree 830229"];
1578 [label="_processIncludes 830230"];
1579 [label="_isForSingleSymbol 830231"];
1580 [label="_diagnostics 830232"];
1581 [label="_cancellationToken 830233"];
1582 [label="compilation.SourceAssembly 830234"];
1583 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 830235"];
1584 [label="GetBoundReferenceManager() 830236"];
1585 [label="param GetBoundReferenceManager(this) 830237"];
1586 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 830238"];
1587 [label="return _referenceManager; 830239"];
1588 [label="GetBoundReferenceManager(); 830240"];
1589 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 830241"];
1590 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 830242"];
1591 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 830243"];
1592 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 830244"];
1593 [label="param VisitNamespace(NamespaceSymbol symbol) 830245"];
1594 [label="param VisitNamespace(this) 830246"];
1595 [label="_cancellationToken.ThrowIfCancellationRequested(); 830247"];
1596 [label="if (symbol.IsGlobalNamespace)\n            {\n                Debug.Assert(_assemblyName != null);\n\n                WriteLine('<?xml version=\\'1.0\\'?>');\n                WriteLine('<doc>');\n                Indent();\n\n                if (!_compilation.Options.OutputKind.IsNetModule())\n                {\n                    WriteLine('<assembly>');\n                    Indent();\n                    WriteLine('<name>{0}</name>', _assemblyName);\n                    Unindent();\n                    WriteLine('</assembly>');\n                }\n\n                WriteLine('<members>');\n                Indent();\n            } 830248"];
1597 [label="Debug.Assert(_assemblyName != null); 830249"];
1598 [label="WriteLine('<?xml version=\\'1.0\\'?>'); 830250"];
1599 [label="WriteLine('<?xml version=\\'1.0\\'?>') 830251"];
1600 [label="param WriteLine(string message) 830252"];
1601 [label="param WriteLine(this) 830253"];
1602 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830254"];
1603 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830255"];
1604 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830256"];
1605 [label="WriteLine('<doc>'); 830257"];
1606 [label="WriteLine('<doc>') 830258"];
1607 [label="param WriteLine(string message) 830259"];
1608 [label="param WriteLine(this) 830260"];
1609 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830261"];
1610 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830262"];
1611 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830263"];
1612 [label="Indent() 830264"];
1613 [label="param Indent(this) 830265"];
1614 [label="_indentDepth 830266"];
1615 [label="Indent(); 830267"];
1616 [label="_compilation.Options 830268"];
1617 [label="if (!_compilation.Options.OutputKind.IsNetModule())\n                {\n                    WriteLine('<assembly>');\n                    Indent();\n                    WriteLine('<name>{0}</name>', _assemblyName);\n                    Unindent();\n                    WriteLine('</assembly>');\n                } 830269"];
1618 [label="WriteLine('<assembly>'); 830270"];
1619 [label="WriteLine('<assembly>') 830271"];
1620 [label="param WriteLine(string message) 830272"];
1621 [label="param WriteLine(this) 830273"];
1622 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830274"];
1623 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830275"];
1624 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830276"];
1625 [label="Indent() 830277"];
1626 [label="param Indent(this) 830278"];
1627 [label="_indentDepth 830279"];
1628 [label="Indent(); 830280"];
1629 [label="WriteLine('<name>{0}</name>', _assemblyName); 830281"];
1630 [label="WriteLine('<name>{0}</name>', _assemblyName) 830282"];
1631 [label="WriteLine('<name>{0}</name>', _assemblyName) 830283"];
1632 [label="param WriteLine(string format) 830284"];
1633 [label="param WriteLine(params object[] args) 830285"];
1634 [label="param WriteLine(this) 830286"];
1635 [label="WriteLine(string.Format(format, args)); 830287"];
1636 [label="WriteLine(string.Format(format, args)); 830288"];
1637 [label="WriteLine(string.Format(format, args)); 830289"];
1638 [label="WriteLine(string.Format(format, args)) 830290"];
1639 [label="param WriteLine(string message) 830291"];
1640 [label="param WriteLine(this) 830292"];
1641 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830293"];
1642 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830294"];
1643 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830295"];
1644 [label="WriteLine(string.Format(format, args)); 830296"];
1645 [label="Unindent() 830297"];
1646 [label="param Unindent(this) 830298"];
1647 [label="_indentDepth 830299"];
1648 [label="Debug.Assert(_indentDepth >= 0); 830300"];
1649 [label="Debug.Assert(_indentDepth >= 0); 830301"];
1650 [label="Unindent(); 830302"];
1651 [label="WriteLine('</assembly>'); 830303"];
1652 [label="WriteLine('</assembly>') 830304"];
1653 [label="param WriteLine(string message) 830305"];
1654 [label="param WriteLine(this) 830306"];
1655 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830307"];
1656 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830308"];
1657 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830309"];
1658 [label="WriteLine('<members>'); 830310"];
1659 [label="WriteLine('<members>') 830311"];
1660 [label="param WriteLine(string message) 830312"];
1661 [label="param WriteLine(this) 830313"];
1662 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830314"];
1663 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830315"];
1664 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830316"];
1665 [label="Indent() 830317"];
1666 [label="param Indent(this) 830318"];
1667 [label="_indentDepth 830319"];
1668 [label="Indent(); 830320"];
1669 [label="Debug.Assert(!_isForSingleSymbol); 830321"];
1670 [label="foreach (var s in symbol.GetMembers())\n            {\n                _cancellationToken.ThrowIfCancellationRequested();\n                s.Accept(this);\n            } 830322"];
1671 [label="_cancellationToken.ThrowIfCancellationRequested(); 830323"];
1672 [label="s.Accept(this); 830324"];
1673 [label="s.Accept(this); 830325"];
1674 [label="s.Accept(this); 830326"];
1675 [label="param VisitNamedType(NamedTypeSymbol symbol) 830327"];
1676 [label="param VisitNamedType(this) 830328"];
1677 [label="_cancellationToken.ThrowIfCancellationRequested(); 830329"];
1678 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 830330"];
1679 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 830331"];
1680 [label="DefaultVisit(symbol); 830332"];
1681 [label="DefaultVisit(symbol) 830333"];
1682 [label="param DefaultVisit(Symbol symbol) 830334"];
1683 [label="param DefaultVisit(this) 830335"];
1684 [label="_cancellationToken.ThrowIfCancellationRequested(); 830336"];
1685 [label="if (ShouldSkip(symbol))\n            {\n                return;\n            } 830337"];
1686 [label="ShouldSkip(symbol) 830338"];
1687 [label="param ShouldSkip(Symbol symbol) 830339"];
1688 [label="return symbol.IsImplicitlyDeclared ||\n                symbol.IsAccessor() ||\n                symbol is SynthesizedSimpleProgramEntryPointSymbol ||\n                symbol is SimpleProgramNamedTypeSymbol ||\n                symbol is SynthesizedRecordPropertySymbol; 830340"];
1689 [label="return symbol.IsImplicitlyDeclared ||\n                symbol.IsAccessor() ||\n                symbol is SynthesizedSimpleProgramEntryPointSymbol ||\n                symbol is SimpleProgramNamedTypeSymbol ||\n                symbol is SynthesizedRecordPropertySymbol; 830341"];
1690 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 830342"];
1691 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 830343"];
1692 [label="bool isPartialMethodDefinitionPart = symbol.IsPartialDefinition(); 830344"];
1693 [label="bool isPartialMethodDefinitionPart = symbol.IsPartialDefinition(); 830345"];
1694 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 830346"];
1695 [label="DocumentationMode maxDocumentationMode; 830347"];
1696 [label="ImmutableArray<DocumentationCommentTriviaSyntax> docCommentNodes; 830348"];
1697 [label="docCommentNodes 830349"];
1698 [label="if (!TryGetDocumentationCommentNodes(symbol, out maxDocumentationMode, out docCommentNodes))\n            {\n                // If the XML in any of the doc comments is invalid, skip all further processing (for this symbol) and \n                // just write a comment saying that info was lost for this symbol.\n                string message = ErrorFacts.GetMessage(MessageID.IDS_XMLIGNORED, CultureInfo.CurrentUICulture);\n                WriteLine(string.Format(CultureInfo.CurrentUICulture, message, symbol.GetDocumentationCommentId()));\n                return;\n            } 830350"];
1699 [label="if (!TryGetDocumentationCommentNodes(symbol, out maxDocumentationMode, out docCommentNodes))\n            {\n                // If the XML in any of the doc comments is invalid, skip all further processing (for this symbol) and \n                // just write a comment saying that info was lost for this symbol.\n                string message = ErrorFacts.GetMessage(MessageID.IDS_XMLIGNORED, CultureInfo.CurrentUICulture);\n                WriteLine(string.Format(CultureInfo.CurrentUICulture, message, symbol.GetDocumentationCommentId()));\n                return;\n            } 830351"];
1700 [label="if (!TryGetDocumentationCommentNodes(symbol, out maxDocumentationMode, out docCommentNodes))\n            {\n                // If the XML in any of the doc comments is invalid, skip all further processing (for this symbol) and \n                // just write a comment saying that info was lost for this symbol.\n                string message = ErrorFacts.GetMessage(MessageID.IDS_XMLIGNORED, CultureInfo.CurrentUICulture);\n                WriteLine(string.Format(CultureInfo.CurrentUICulture, message, symbol.GetDocumentationCommentId()));\n                return;\n            } 830352"];
1701 [label="TryGetDocumentationCommentNodes(symbol, out maxDocumentationMode, out docCommentNodes) 830353"];
1702 [label="param TryGetDocumentationCommentNodes(Symbol symbol) 830354"];
1703 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 830355"];
1704 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 830356"];
1705 [label="param TryGetDocumentationCommentNodes(this) 830357"];
1706 [label="maxDocumentationMode = DocumentationMode.None; 830358"];
1707 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 830359"];
1708 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 830360"];
1709 [label="foreach (SyntaxReference reference in symbol.DeclaringSyntaxReferences)\n            {\n                DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode;\n                maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode;\n\n                ImmutableArray<DocumentationCommentTriviaSyntax> triviaList = SourceDocumentationCommentUtils.GetDocumentationCommentTriviaFromSyntaxNode((CSharpSyntaxNode)reference.GetSyntax(), _diagnostics);\n                foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                }\n            } 830361"];
1710 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 830362"];
1711 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 830363"];
1712 [label="currDocumentationMode > maxDocumentationMode 830364"];
1713 [label="ImmutableArray<DocumentationCommentTriviaSyntax> triviaList = SourceDocumentationCommentUtils.GetDocumentationCommentTriviaFromSyntaxNode((CSharpSyntaxNode)reference.GetSyntax(), _diagnostics); 830365"];
1714 [label="ImmutableArray<DocumentationCommentTriviaSyntax> triviaList = SourceDocumentationCommentUtils.GetDocumentationCommentTriviaFromSyntaxNode((CSharpSyntaxNode)reference.GetSyntax(), _diagnostics); 830366"];
1715 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 830367"];
1716 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 830368"];
1717 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 830369"];
1718 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 830370"];
1719 [label="return true; 830371"];
1720 [label="if (!TryGetDocumentationCommentNodes(symbol, out maxDocumentationMode, out docCommentNodes))\n            {\n                // If the XML in any of the doc comments is invalid, skip all further processing (for this symbol) and \n                // just write a comment saying that info was lost for this symbol.\n                string message = ErrorFacts.GetMessage(MessageID.IDS_XMLIGNORED, CultureInfo.CurrentUICulture);\n                WriteLine(string.Format(CultureInfo.CurrentUICulture, message, symbol.GetDocumentationCommentId()));\n                return;\n            } 830372"];
1721 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 830373"];
1722 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 830374"];
1723 [label="return; 830375"];
1724 [label="DefaultVisit(symbol); 830376"];
1725 [label="if (!_isForSingleSymbol)\n            {\n                foreach (Symbol member in symbol.GetMembers())\n                {\n                    _cancellationToken.ThrowIfCancellationRequested();\n                    member.Accept(this);\n                }\n            } 830377"];
1726 [label="foreach (Symbol member in symbol.GetMembers())\n                {\n                    _cancellationToken.ThrowIfCancellationRequested();\n                    member.Accept(this);\n                } 830378"];
1727 [label="if (symbol.IsGlobalNamespace)\n            {\n                Unindent();\n                WriteLine('</members>');\n                Unindent();\n                WriteLine('</doc>');\n            } 830379"];
1728 [label="Unindent() 830380"];
1729 [label="Debug.Assert(_indentDepth >= 0); 830381"];
1730 [label="Unindent(); 830382"];
1731 [label="WriteLine('</members>'); 830383"];
1732 [label="WriteLine('</members>') 830384"];
1733 [label="param WriteLine(string message) 830385"];
1734 [label="param WriteLine(this) 830386"];
1735 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830387"];
1736 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830388"];
1737 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830389"];
1738 [label="Unindent() 830390"];
1739 [label="_indentDepth 830391"];
1740 [label="Debug.Assert(_indentDepth >= 0); 830392"];
1741 [label="Debug.Assert(_indentDepth >= 0); 830393"];
1742 [label="Unindent(); 830394"];
1743 [label="WriteLine('</doc>'); 830395"];
1744 [label="WriteLine('</doc>') 830396"];
1745 [label="param WriteLine(string message) 830397"];
1746 [label="param WriteLine(this) 830398"];
1747 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830399"];
1748 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830400"];
1749 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 830401"];
1750 [label="Debug.Assert(compiler._indentDepth == 0); 830402"];
1751 [label="Debug.Assert(compiler._indentDepth == 0); 830403"];
1752 [label="writer?.Flush(); 830404"];
1753 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 830405"];
1754 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 830406"];
1755 [label="compilation.SyntaxTrees 830407"];
1756 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 830408"];
1757 [label="_syntaxAndDeclarations.GetLazyState() 830409"];
1758 [label="param GetLazyState(this) 830410"];
1759 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 830411"];
1760 [label="foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                } 830412"];
1761 [label="UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken); 830413"];
1762 [label="UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken); 830414"];
1763 [label="UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken); 830415"];
1764 [label="UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken) 830416"];
1765 [label="param ReportUnprocessed(SyntaxTree tree) 830417"];
1766 [label="param ReportUnprocessed(TextSpan? filterSpanWithinTree) 830418"];
1767 [label="param ReportUnprocessed(DiagnosticBag diagnostics) 830419"];
1768 [label="param ReportUnprocessed(CancellationToken cancellationToken) 830420"];
1769 [label="if (tree.ReportDocumentationCommentDiagnostics())\n            {\n                UnprocessedDocumentationCommentFinder finder = new UnprocessedDocumentationCommentFinder(diagnostics, filterSpanWithinTree, cancellationToken);\n                finder.Visit(tree.GetRoot(cancellationToken));\n            } 830421"];
1770 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 830422"];
1771 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 830423"];
1772 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 830424"];
1773 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken) 830425"];
1774 [label="param ReportUnusedImports(SyntaxTree? filterTree) 830426"];
1775 [label="param ReportUnusedImports(DiagnosticBag diagnostics) 830427"];
1776 [label="param ReportUnusedImports(CancellationToken cancellationToken) 830428"];
1777 [label="param ReportUnusedImports(this) 830429"];
1778 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 830430"];
1779 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 830431"];
1780 [label="CompleteTrees(filterTree); 830432"];
1781 [label="CompleteTrees(filterTree) 830433"];
1782 [label="param CompleteTrees(SyntaxTree? filterTree) 830434"];
1783 [label="param CompleteTrees(this) 830435"];
1784 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 830436"];
1785 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 830437"];
1786 [label="CompleteTrees(filterTree); 830438"];
1787 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 830439"];
1788 [label="builder.AddRangeAndFree(methodBodyDiagnostics); 830440"];
1789 [label="builder.AddRangeAndFree(methodBodyDiagnostics); 830441"];
1790 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 830442"];
1791 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 830443"];
1792 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 830444"];
1793 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 830445"];
1794 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 830446"];
1795 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 830447"];
1796 [label="return diagnostics.ToReadOnlyAndFree(); 830448"];
1797 [label="diagnostics.Verify(expected); 830449"];
1798 [label="diagnostics.Verify(expected); 830450"];
1799 [label="diagnostics.Verify(expected) 830451"];
1800 [label="param Verify(this ImmutableArray<Diagnostic> actual) 830452"];
1801 [label="param Verify(params DiagnosticDescription[] expected) 830453"];
1802 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 830454"];
1803 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 830455"];
1804 [label="Verify((IEnumerable<Diagnostic>)actual, expected) 830456"];
1805 [label="param Verify(this IEnumerable<Diagnostic> actual) 830457"];
1806 [label="param Verify(params DiagnosticDescription[] expected) 830458"];
1807 [label="Verify(actual, expected, errorCodeOnly: false); 830459"];
1808 [label="Verify(actual, expected, errorCodeOnly: false); 830460"];
1809 [label="Verify(actual, expected, errorCodeOnly: false); 830461"];
1810 [label="Verify(actual, expected, errorCodeOnly: false) 830462"];
1811 [label="param Verify(IEnumerable<Diagnostic> actual) 830463"];
1812 [label="param Verify(DiagnosticDescription[] expected) 830464"];
1813 [label="param Verify(bool errorCodeOnly) 830465"];
1814 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 830466"];
1815 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 830467"];
1816 [label="var includeDefaultSeverity = expected.Any() && expected.All(e => e.DefaultSeverity != null); 830468"];
1817 [label="var includeEffectiveSeverity = expected.Any() && expected.All(e => e.EffectiveSeverity != null); 830469"];
1818 [label="var unmatched = actual.Select(d => new DiagnosticDescription(d, errorCodeOnly, includeDefaultSeverity, includeEffectiveSeverity))\n                                  .ToList(); 830470"];
1819 [label="var unmatched = actual.Select(d => new DiagnosticDescription(d, errorCodeOnly, includeDefaultSeverity, includeEffectiveSeverity))\n                                  .ToList(); 830471"];
1820 [label="var unmatched = actual.Select(d => new DiagnosticDescription(d, errorCodeOnly, includeDefaultSeverity, includeEffectiveSeverity))\n                                  .ToList(); 830472"];
1821 [label="foreach (var d in expected)\n            {\n                int index = unmatched.IndexOf(d);\n                if (index > -1)\n                {\n                    unmatched.RemoveAt(index);\n                }\n                else\n                {\n                    CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n                }\n            } 830473"];
1822 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 830474"];
1823 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 830475"];
1824 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 830476"];
1825 [label="{ } 830477"];
1826 [label="None = { } 830478"];
1827 [label="null 830479"];
1828 [label="Any = null 830480"];
1829 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 830481"];
1830 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 830482"];
1831 [label="DiagnosticDescription.GetAssertText(expected, actual) 830483"];
1832 [label="param GetAssertText(DiagnosticDescription[] expected) 830484"];
1833 [label="param GetAssertText(IEnumerable<Diagnostic> actual) 830485"];
1834 [label="const int CSharp = 1; 830486"];
1835 [label="const int VisualBasic = 2; 830487"];
1836 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 830488"];
1837 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 830489"];
1838 [label="actual.Any() && actual.First() is CSDiagnostic 830490"];
1839 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 830491"];
1840 [label="var includeDiagnosticMessagesAsComments = (language == CSharp); 830492"];
1841 [label="int indentDepth = (language == CSharp) ? 4 : 1; 830493"];
1842 [label="(language == CSharp) 830494"];
1843 [label="var includeDefaultSeverity = expected.Any() && expected.All(d => d.DefaultSeverity != null); 830495"];
1844 [label="var includeEffectiveSeverity = expected.Any() && expected.All(d => d.EffectiveSeverity != null); 830496"];
1845 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 830497"];
1846 [label="IsSortedOrEmpty(expected) 830498"];
1847 [label="param IsSortedOrEmpty(DiagnosticDescription[] diagnostics) 830499"];
1848 [label="new LinePositionComparer() 830500"];
1849 [label="param LinePositionComparer(this) 830501"];
1850 [label="Instance = new LinePositionComparer() 830502"];
1851 [label="var comparer = LinePositionComparer.Instance; 830503"];
1852 [label="DiagnosticDescription last = null; 830504"];
1853 [label="foreach (var diagnostic in diagnostics)\n            {\n                if (diagnostic._startPosition == null)\n                {\n                    return false;\n                }\n                if (last != null && comparer.Compare(last._startPosition, diagnostic._startPosition) > 0)\n                {\n                    return false;\n                }\n                last = diagnostic;\n            } 830505"];
1854 [label="return true; 830506"];
1855 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 830507"];
1856 [label="actual = Sort(actual); 830508"];
1857 [label="Sort(actual) 830509"];
1858 [label="param Sort(IEnumerable<Diagnostic> diagnostics) 830510"];
1859 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 830511"];
1860 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 830512"];
1861 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 830513"];
1862 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 830514"];
1863 [label="var assertText = new StringBuilder(); 830515"];
1864 [label="assertText.AppendLine(); 830516"];
1865 [label="int i; 830517"];
1866 [label="assertText.AppendLine('Expected:'); 830518"];
1867 [label="assertText.AppendLine('Expected:'); 830519"];
1868 [label="var expectedText = ArrayBuilder<string>.GetInstance(); 830520"];
1869 [label="foreach (var d in expected)\n            {\n                expectedText.Add(GetDiagnosticDescription(d, indentDepth));\n            } 830521"];
1870 [label="GetCommaSeparatedLines(assertText, expectedText); 830522"];
1871 [label="GetCommaSeparatedLines(assertText, expectedText); 830523"];
1872 [label="GetCommaSeparatedLines(assertText, expectedText) 830524"];
1873 [label="param GetCommaSeparatedLines(StringBuilder sb) 830525"];
1874 [label="param GetCommaSeparatedLines(ArrayBuilder<string> lines) 830526"];
1875 [label="int n = lines.Count; 830527"];
1876 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 830528"];
1877 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 830529"];
1878 [label="GetCommaSeparatedLines(assertText, expectedText); 830530"];
1879 [label="assertText.AppendLine('Actual:'); 830531"];
1880 [label="assertText.AppendLine('Actual:'); 830532"];
1881 [label="var actualText = ArrayBuilder<string>.GetInstance(); 830533"];
1882 [label="var e = actual.GetEnumerator(); 830534"];
1883 [label="for (i = 0; e.MoveNext(); i++)\n            {\n                Diagnostic d = e.Current;\n                string message = d.ToString();\n                if (Regex.Match(message, @'{\\d+}').Success)\n                {\n                    Assert.True(false, 'Diagnostic messages should never contain unsubstituted placeholders.\\n    ' + message);\n                }\n\n                if (i > 0)\n                {\n                    assertText.AppendLine(',');\n                }\n\n                if (includeDiagnosticMessagesAsComments)\n                {\n                    Indent(assertText, indentDepth);\n                    assertText.Append('// ');\n                    assertText.AppendLine(d.ToString());\n                    var l = d.Location;\n                    if (l.IsInSource)\n                    {\n                        Indent(assertText, indentDepth);\n                        assertText.Append('// ');\n                        assertText.AppendLine(l.SourceTree.GetText().Lines.GetLineFromPosition(l.SourceSpan.Start).ToString());\n                    }\n                }\n\n                var description = new DiagnosticDescription(d, errorCodeOnly: false, includeDefaultSeverity, includeEffectiveSeverity);\n                var diffDescription = description;\n                var idx = Array.IndexOf(expected, description);\n                if (idx != -1)\n                {\n                    diffDescription = expected[idx];\n                }\n                assertText.Append(GetDiagnosticDescription(description, indentDepth));\n                actualText.Add(GetDiagnosticDescription(diffDescription, indentDepth));\n            } 830535"];
1884 [label="for (i = 0; e.MoveNext(); i++)\n            {\n                Diagnostic d = e.Current;\n                string message = d.ToString();\n                if (Regex.Match(message, @'{\\d+}').Success)\n                {\n                    Assert.True(false, 'Diagnostic messages should never contain unsubstituted placeholders.\\n    ' + message);\n                }\n\n                if (i > 0)\n                {\n                    assertText.AppendLine(',');\n                }\n\n                if (includeDiagnosticMessagesAsComments)\n                {\n                    Indent(assertText, indentDepth);\n                    assertText.Append('// ');\n                    assertText.AppendLine(d.ToString());\n                    var l = d.Location;\n                    if (l.IsInSource)\n                    {\n                        Indent(assertText, indentDepth);\n                        assertText.Append('// ');\n                        assertText.AppendLine(l.SourceTree.GetText().Lines.GetLineFromPosition(l.SourceSpan.Start).ToString());\n                    }\n                }\n\n                var description = new DiagnosticDescription(d, errorCodeOnly: false, includeDefaultSeverity, includeEffectiveSeverity);\n                var diffDescription = description;\n                var idx = Array.IndexOf(expected, description);\n                if (idx != -1)\n                {\n                    diffDescription = expected[idx];\n                }\n                assertText.Append(GetDiagnosticDescription(description, indentDepth));\n                actualText.Add(GetDiagnosticDescription(diffDescription, indentDepth));\n            } 830536"];
1885 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 830537"];
1886 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 830538"];
1887 [label="assertText.AppendLine('Diff:'); 830539"];
1888 [label="assertText.AppendLine('Diff:'); 830540"];
1889 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 830541"];
1890 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 830542"];
1891 [label="new[] { '\\r', '\\n' } 830543"];
1892 [label="'\\r' 830544"];
1893 [label="'\\n' 830545"];
1894 [label="new[] { '\\r', '\\n' } 830546"];
1895 [label="new[] { '\\r', '\\n' } 830547"];
1896 [label="s_lineSplitChars = new[] { '\\r', '\\n' } 830548"];
1897 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 830549"];
1898 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 830550"];
1899 [label="DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine) 830551"];
1900 [label="param DiffReport(IEnumerable<T> expected) 830552"];
1901 [label="param DiffReport(IEnumerable<T> actual) 830553"];
1902 [label="param DiffReport(string separator) 830554"];
1903 [label="param DiffReport(IEqualityComparer<T> comparer = null) 830555"];
1904 [label="param DiffReport(Func<T, string> toString = null) 830556"];
1905 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 830557"];
1906 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 830558"];
1907 [label="(comparer != null) 830559"];
1908 [label="EqualityComparer<T>.Default 830560"];
1909 [label="new LCS<T>(EqualityComparer<T>.Default) 830561"];
1910 [label="param LCS(IEqualityComparer<T> comparer) 830562"];
1911 [label="param LCS(this) 830563"];
1912 [label="1 830564"];
1913 [label="DeleteCost = 1 830565"];
1914 [label="1 830566"];
1915 [label="InsertCost = 1 830567"];
1916 [label="2 830568"];
1917 [label="UpdateCost = 2 830569"];
1918 [label="param LongestCommonSubsequence(this) 830570"];
1919 [label="_comparer 830571"];
1920 [label="_comparer 830572"];
1921 [label="Default = new LCS<T>(EqualityComparer<T>.Default) 830573"];
1922 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 830574"];
1923 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 830575"];
1924 [label="IList<T> expectedList = expected as IList<T> ?? new List<T>(expected); 830576"];
1925 [label="IList<T> actualList = actual as IList<T> ?? new List<T>(actual); 830577"];
1926 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 830578"];
1927 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 830579"];
1928 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 830580"];
1929 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 830581"];
1930 [label="lcs.CalculateDiff(expectedList, actualList, toString) 830582"];
1931 [label="param CalculateDiff(IList<T> sequenceA) 830583"];
1932 [label="param CalculateDiff(IList<T> sequenceB) 830584"];
1933 [label="param CalculateDiff(Func<T, string> toString) 830585"];
1934 [label="param CalculateDiff(this) 830586"];
1935 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 830587"];
1936 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 830588"];
1937 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 830589"];
1938 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 830590"];
1939 [label="GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count) 830591"];
1940 [label="param GetEdits(TSequence sequenceA) 830592"];
1941 [label="param GetEdits(int lengthA) 830593"];
1942 [label="param GetEdits(TSequence sequenceB) 830594"];
1943 [label="param GetEdits(int lengthB) 830595"];
1944 [label="param GetEdits(this) 830596"];
1945 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 830597"];
1946 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 830598"];
1947 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 830599"];
1948 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 830600"];
1949 [label="ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB) 830601"];
1950 [label="param ComputeCostMatrix(TSequence sequenceA) 830602"];
1951 [label="param ComputeCostMatrix(int lengthA) 830603"];
1952 [label="param ComputeCostMatrix(TSequence sequenceB) 830604"];
1953 [label="param ComputeCostMatrix(int lengthB) 830605"];
1954 [label="param ComputeCostMatrix(this) 830606"];
1955 [label="var la = lengthA + 1; 830607"];
1956 [label="var la = lengthA + 1; 830608"];
1957 [label="var lb = lengthB + 1; 830609"];
1958 [label="var lb = lengthB + 1; 830610"];
1959 [label="var d = new int[la, lb]; 830611"];
1960 [label="d[0, 0] = 0; 830612"];
1961 [label="d[0, 0] 830613"];
1962 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 830614"];
1963 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 830615"];
1964 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 830616"];
1965 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 830617"];
1966 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 830618"];
1967 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 830619"];
1968 [label="return d; 830620"];
1969 [label="int i = lengthA; 830621"];
1970 [label="int j = lengthB; 830622"];
1971 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 830623"];
1972 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 830624"];
1973 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 830625"];
1974 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 830626"];
1975 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 830627"];
1976 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 830628"];
1977 [label="param GetEdits(this) 830629"];
1978 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 830630"];
1979 [label="param CalculateDiff(this) 830631"];
1980 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 830632"];
1981 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 830633"];
1982 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 830634"];
1983 [label="actualText.Free(); 830635"];
1984 [label="expectedText.Free(); 830636"];
1985 [label="return assertText.ToString(); 830637"];
1986 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 830638"];
1987 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 830639"];
1988 [label="diagnostics.Verify(expected); 830640"];
1989 [label="VerifyAssemblyIds(c, diagnostics); 830641"];
1990 [label="VerifyAssemblyIds(c, diagnostics); 830642"];
1991 [label="VerifyAssemblyIds(c, diagnostics) 830643"];
1992 [label="param VerifyAssemblyIds(TCompilation c) 830644"];
1993 [label="param VerifyAssemblyIds(ImmutableArray<Diagnostic> diagnostics) 830645"];
1994 [label="foreach (var diagnostic in diagnostics)\n            {\n                // If this is a diagnostic about a missing assembly, make sure that we can get back\n                // an AssemblyIdentity when we query the compiler.  If it's not a diagnostic about\n                // a missing assembly, make sure we get no results back.\n                if (c.IsUnreferencedAssemblyIdentityDiagnosticCode(diagnostic.Code))\n                {\n                    var assemblyIds = c.GetUnreferencedAssemblyIdentities(diagnostic);\n                    CustomAssert.False(assemblyIds.IsEmpty);\n\n                    var diagnosticMessage = diagnostic.GetMessage();\n                    foreach (var id in assemblyIds)\n                    {\n                        CustomAssert.Contains(id.GetDisplayName(), diagnosticMessage);\n                    }\n                }\n                else\n                {\n                    var assemblyIds = c.GetUnreferencedAssemblyIdentities(diagnostic);\n                    CustomAssert.True(assemblyIds.IsEmpty);\n                }\n            } 830646"];
1995 [label="VerifyAssemblyIds(c, diagnostics); 830647"];
1996 [label="return c; 830648"];
1997 [label="var libImage = libComp.EmitToImageReference(emitOptions); 830649"];
1998 [label="var libImage = libComp.EmitToImageReference(emitOptions); 830650"];
1999 [label="var libImage = libComp.EmitToImageReference(emitOptions); 830651"];
2000 [label="libComp.EmitToImageReference(emitOptions) 830652"];
2001 [label="param EmitToImageReference(this Compilation comp) 830653"];
2002 [label="param EmitToImageReference(EmitOptions options = null) 830654"];
2003 [label="param EmitToImageReference(bool embedInteropTypes = false) 830655"];
2004 [label="param EmitToImageReference(ImmutableArray<string> aliases = default) 830656"];
2005 [label="param EmitToImageReference(DiagnosticDescription[] expectedWarnings = null) 830657"];
2006 [label="comp 830658"];
2007 [label="options 830659"];
2008 [label="embedInteropTypes 830660"];
2009 [label="aliases 830661"];
2010 [label="expectedWarnings 830662"];
2011 [label="EmitToPortableExecutableReference(comp, options, embedInteropTypes, aliases, expectedWarnings) 830663"];
2012 [label="param EmitToPortableExecutableReference(this Compilation comp) 830664"];
2013 [label="param EmitToPortableExecutableReference(EmitOptions options = null) 830665"];
2014 [label="param EmitToPortableExecutableReference(bool embedInteropTypes = false) 830666"];
2015 [label="param EmitToPortableExecutableReference(ImmutableArray<string> aliases = default) 830667"];
2016 [label="param EmitToPortableExecutableReference(DiagnosticDescription[] expectedWarnings = null) 830668"];
2017 [label="var image = comp.EmitToArray(options, expectedWarnings: expectedWarnings); 830669"];
2018 [label="var image = comp.EmitToArray(options, expectedWarnings: expectedWarnings); 830670"];
2019 [label="var image = comp.EmitToArray(options, expectedWarnings: expectedWarnings); 830671"];
2020 [label="var image = comp.EmitToArray(options, expectedWarnings: expectedWarnings); 830672"];
2021 [label="comp.EmitToArray(options, expectedWarnings: expectedWarnings) 830673"];
2022 [label="param EmitToArray(this Compilation compilation) 830674"];
2023 [label="param EmitToArray(EmitOptions options = null) 830675"];
2024 [label="param EmitToArray(CompilationTestData testData = null) 830676"];
2025 [label="param EmitToArray(DiagnosticDescription[] expectedWarnings = null) 830677"];
2026 [label="param EmitToArray(Stream pdbStream = null) 830678"];
2027 [label="param EmitToArray(IMethodSymbol debugEntryPoint = null) 830679"];
2028 [label="param EmitToArray(Stream sourceLinkStream = null) 830680"];
2029 [label="param EmitToArray(IEnumerable<EmbeddedText> embeddedTexts = null) 830681"];
2030 [label="param EmitToArray(IEnumerable<ResourceDescription> manifestResources = null) 830682"];
2031 [label="param EmitToArray(Stream metadataPEStream = null) 830683"];
2032 [label="var peStream = new MemoryStream(); 830684"];
2033 [label="if (pdbStream == null && compilation.Options.OptimizationLevel == OptimizationLevel.Debug && options?.DebugInformationFormat != DebugInformationFormat.Embedded)\n            {\n                if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                }\n\n                var discretePdb = (object)options != null && options.DebugInformationFormat != DebugInformationFormat.Embedded;\n                pdbStream = discretePdb ? new MemoryStream() : null;\n            } 830685"];
2034 [label="if (pdbStream == null && compilation.Options.OptimizationLevel == OptimizationLevel.Debug && options?.DebugInformationFormat != DebugInformationFormat.Embedded)\n            {\n                if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                }\n\n                var discretePdb = (object)options != null && options.DebugInformationFormat != DebugInformationFormat.Embedded;\n                pdbStream = discretePdb ? new MemoryStream() : null;\n            } 830686"];
2035 [label="if (pdbStream == null && compilation.Options.OptimizationLevel == OptimizationLevel.Debug && options?.DebugInformationFormat != DebugInformationFormat.Embedded)\n            {\n                if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                }\n\n                var discretePdb = (object)options != null && options.DebugInformationFormat != DebugInformationFormat.Embedded;\n                pdbStream = discretePdb ? new MemoryStream() : null;\n            } 830687"];
2036 [label="compilation.Options 830688"];
2037 [label="get { return _options; } 830689"];
2038 [label="if (pdbStream == null && compilation.Options.OptimizationLevel == OptimizationLevel.Debug && options?.DebugInformationFormat != DebugInformationFormat.Embedded)\n            {\n                if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                }\n\n                var discretePdb = (object)options != null && options.DebugInformationFormat != DebugInformationFormat.Embedded;\n                pdbStream = discretePdb ? new MemoryStream() : null;\n            } 830690"];
2039 [label="if (pdbStream == null && compilation.Options.OptimizationLevel == OptimizationLevel.Debug && options?.DebugInformationFormat != DebugInformationFormat.Embedded)\n            {\n                if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                }\n\n                var discretePdb = (object)options != null && options.DebugInformationFormat != DebugInformationFormat.Embedded;\n                pdbStream = discretePdb ? new MemoryStream() : null;\n            } 830691"];
2040 [label="if (pdbStream == null && compilation.Options.OptimizationLevel == OptimizationLevel.Debug && options?.DebugInformationFormat != DebugInformationFormat.Embedded)\n            {\n                if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                }\n\n                var discretePdb = (object)options != null && options.DebugInformationFormat != DebugInformationFormat.Embedded;\n                pdbStream = discretePdb ? new MemoryStream() : null;\n            } 830692"];
2041 [label="MonoHelpers.IsRunningOnMono() 830693"];
2042 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 830694"];
2043 [label="if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                } 830695"];
2044 [label="var discretePdb = (object)options != null && options.DebugInformationFormat != DebugInformationFormat.Embedded; 830696"];
2045 [label="var discretePdb = (object)options != null && options.DebugInformationFormat != DebugInformationFormat.Embedded; 830697"];
2046 [label="discretePdb 830698"];
2047 [label="pdbStream = discretePdb ? new MemoryStream() : null; 830699"];
2048 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 830700"];
2049 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 830701"];
2050 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 830702"];
2051 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 830703"];
2052 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 830704"];
2053 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 830705"];
2054 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 830706"];
2055 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 830707"];
2056 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 830708"];
2057 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 830709"];
2058 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 830710"];
2059 [label="param CreateModuleBuilder(EmitOptions emitOptions) 830711"];
2060 [label="param CreateModuleBuilder(IMethodSymbol? debugEntryPoint) 830712"];
2061 [label="param CreateModuleBuilder(Stream? sourceLinkStream) 830713"];
2062 [label="param CreateModuleBuilder(IEnumerable<EmbeddedText>? embeddedTexts) 830714"];
2063 [label="param CreateModuleBuilder(IEnumerable<ResourceDescription>? manifestResources) 830715"];
2064 [label="param CreateModuleBuilder(CompilationTestData? testData) 830716"];
2065 [label="param CreateModuleBuilder(DiagnosticBag diagnostics) 830717"];
2066 [label="param CreateModuleBuilder(CancellationToken cancellationToken) 830718"];
2067 [label="param CreateModuleBuilder(this) 830719"];
2068 [label="Debug.Assert(!IsSubmission || HasCodeToEmit()); 830720"];
2069 [label="string? runtimeMDVersion = GetRuntimeMetadataVersion(emitOptions, diagnostics); 830721"];
2070 [label="string? runtimeMDVersion = GetRuntimeMetadataVersion(emitOptions, diagnostics); 830722"];
2071 [label="GetRuntimeMetadataVersion(emitOptions, diagnostics) 830723"];
2072 [label="param GetRuntimeMetadataVersion(EmitOptions emitOptions) 830724"];
2073 [label="param GetRuntimeMetadataVersion(DiagnosticBag diagnostics) 830725"];
2074 [label="param GetRuntimeMetadataVersion(this) 830726"];
2075 [label="string? runtimeMDVersion = GetRuntimeMetadataVersion(emitOptions); 830727"];
2076 [label="GetRuntimeMetadataVersion(emitOptions) 830728"];
2077 [label="param GetRuntimeMetadataVersion(EmitOptions emitOptions) 830729"];
2078 [label="param GetRuntimeMetadataVersion(this) 830730"];
2079 [label="Assembly 830731"];
2080 [label="get\n            {\n                return SourceAssembly;\n            } 830732"];
2081 [label="SourceAssembly 830733"];
2082 [label="GetBoundReferenceManager() 830734"];
2083 [label="param GetBoundReferenceManager(this) 830735"];
2084 [label="GetBoundReferenceManager(); 830736"];
2085 [label="var corAssembly = Assembly.CorLibrary as Symbols.Metadata.PE.PEAssemblySymbol; 830737"];
2086 [label="if (corAssembly is object)\n            {\n                return corAssembly.Assembly.ManifestModule.MetadataVersion;\n            } 830738"];
2087 [label="return corAssembly.Assembly.ManifestModule.MetadataVersion; 830739"];
2088 [label="string? runtimeMDVersion = GetRuntimeMetadataVersion(emitOptions); 830740"];
2089 [label="if (runtimeMDVersion != null)\n            {\n                return runtimeMDVersion;\n            } 830741"];
2090 [label="if (runtimeMDVersion != null)\n            {\n                return runtimeMDVersion;\n            } 830742"];
2091 [label="return runtimeMDVersion; 830743"];
2092 [label="string? runtimeMDVersion = GetRuntimeMetadataVersion(emitOptions, diagnostics); 830744"];
2093 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 830745"];
2094 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 830746"];
2095 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 830747"];
2096 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 830748"];
2097 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 830749"];
2098 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 830750"];
2099 [label="get { return SourceAssembly.IsDelaySigned; } 830751"];
2100 [label="SourceAssembly 830752"];
2101 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 830753"];
2102 [label="GetBoundReferenceManager() 830754"];
2103 [label="param GetBoundReferenceManager(this) 830755"];
2104 [label="GetBoundReferenceManager(); 830756"];
2105 [label="return SourceAssembly.IsDelaySigned; 830757"];
2106 [label="SourceAssembly.IsDelaySigned 830758"];
2107 [label="get\n            {\n                return _options;\n            } 830759"];
2108 [label="get { return SourceAssembly.StrongNameKeys; } 830760"];
2109 [label="SourceAssembly 830761"];
2110 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 830762"];
2111 [label="GetBoundReferenceManager() 830763"];
2112 [label="param GetBoundReferenceManager(this) 830764"];
2113 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 830765"];
2114 [label="return _referenceManager; 830766"];
2115 [label="GetBoundReferenceManager(); 830767"];
2116 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 830768"];
2117 [label="return SourceAssembly.StrongNameKeys; 830769"];
2118 [label="=> 0x30 830770"];
2119 [label="0x30 830771"];
2120 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 830772"];
2121 [label="if (manifestResources == null)\n            {\n                manifestResources = SpecializedCollections.EmptyEnumerable<ResourceDescription>();\n            } 830773"];
2122 [label="if (manifestResources == null)\n            {\n                manifestResources = SpecializedCollections.EmptyEnumerable<ResourceDescription>();\n            } 830774"];
2123 [label="manifestResources = SpecializedCollections.EmptyEnumerable<ResourceDescription>(); 830775"];
2124 [label="PEModuleBuilder moduleBeingBuilt; 830776"];
2125 [label="if (_options.OutputKind.IsNetModule())\n            {\n                moduleBeingBuilt = new PENetModuleBuilder(\n                    (SourceModuleSymbol)SourceModule,\n                    emitOptions,\n                    moduleProps,\n                    manifestResources);\n            }\n            else\n            {\n                var kind = _options.OutputKind.IsValid() ? _options.OutputKind : OutputKind.DynamicallyLinkedLibrary;\n                moduleBeingBuilt = new PEAssemblyBuilder(\n                    SourceAssembly,\n                    emitOptions,\n                    kind,\n                    moduleProps,\n                    manifestResources);\n            } 830777"];
2126 [label="var kind = _options.OutputKind.IsValid() ? _options.OutputKind : OutputKind.DynamicallyLinkedLibrary; 830778"];
2127 [label="_options.OutputKind.IsValid() 830779"];
2128 [label="_options.OutputKind 830780"];
2129 [label="SourceAssembly 830781"];
2130 [label="GetBoundReferenceManager() 830782"];
2131 [label="GetBoundReferenceManager(); 830783"];
2132 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 830784"];
2133 [label="moduleBeingBuilt = new PEAssemblyBuilder(\n                    SourceAssembly,\n                    emitOptions,\n                    kind,\n                    moduleProps,\n                    manifestResources); 830785"];
2134 [label="moduleBeingBuilt = new PEAssemblyBuilder(\n                    SourceAssembly,\n                    emitOptions,\n                    kind,\n                    moduleProps,\n                    manifestResources); 830786"];
2135 [label="moduleBeingBuilt = new PEAssemblyBuilder(\n                    SourceAssembly,\n                    emitOptions,\n                    kind,\n                    moduleProps,\n                    manifestResources); 830787"];
2136 [label="moduleBeingBuilt = new PEAssemblyBuilder(\n                    SourceAssembly,\n                    emitOptions,\n                    kind,\n                    moduleProps,\n                    manifestResources); 830788"];
2137 [label="moduleBeingBuilt = new PEAssemblyBuilder(\n                    SourceAssembly,\n                    emitOptions,\n                    kind,\n                    moduleProps,\n                    manifestResources); 830789"];
2138 [label="moduleBeingBuilt = new PEAssemblyBuilder(\n                    SourceAssembly,\n                    emitOptions,\n                    kind,\n                    moduleProps,\n                    manifestResources); 830790"];
2139 [label="new PEAssemblyBuilder(\n                    SourceAssembly,\n                    emitOptions,\n                    kind,\n                    moduleProps,\n                    manifestResources) 830791"];
2140 [label="param PEAssemblyBuilder(SourceAssemblySymbol sourceAssembly) 830792"];
2141 [label="param PEAssemblyBuilder(EmitOptions emitOptions) 830793"];
2142 [label="param PEAssemblyBuilder(OutputKind outputKind) 830794"];
2143 [label="param PEAssemblyBuilder(Cci.ModulePropertiesForSerialization serializationProperties) 830795"];
2144 [label="param PEAssemblyBuilder(IEnumerable<ResourceDescription> manifestResources) 830796"];
2145 [label="param PEAssemblyBuilder(this) 830797"];
2146 [label="sourceAssembly 830798"];
2147 [label="emitOptions 830799"];
2148 [label="outputKind 830800"];
2149 [label="serializationProperties 830801"];
2150 [label="manifestResources 830802"];
2151 [label="ImmutableArray<NamedTypeSymbol>.Empty 830803"];
2152 [label="param PEAssemblyBuilder(this) 830804"];
2153 [label="param PEAssemblyBuilderBase(SourceAssemblySymbol sourceAssembly) 830805"];
2154 [label="param PEAssemblyBuilderBase(EmitOptions emitOptions) 830806"];
2155 [label="param PEAssemblyBuilderBase(OutputKind outputKind) 830807"];
2156 [label="param PEAssemblyBuilderBase(Cci.ModulePropertiesForSerialization serializationProperties) 830808"];
2157 [label="param PEAssemblyBuilderBase(IEnumerable<ResourceDescription> manifestResources) 830809"];
2158 [label="param PEAssemblyBuilderBase(ImmutableArray<NamedTypeSymbol> additionalTypes) 830810"];
2159 [label="param PEAssemblyBuilderBase(this) 830811"];
2160 [label="0 830812"];
2161 [label="sourceAssembly.Modules[0] 830813"];
2162 [label="emitOptions 830814"];
2163 [label="outputKind 830815"];
2164 [label="serializationProperties 830816"];
2165 [label="manifestResources 830817"];
2166 [label="param PEAssemblyBuilderBase(this) 830818"];
2167 [label="param PEModuleBuilder(SourceModuleSymbol sourceModule) 830819"];
2168 [label="param PEModuleBuilder(EmitOptions emitOptions) 830820"];
2169 [label="param PEModuleBuilder(OutputKind outputKind) 830821"];
2170 [label="param PEModuleBuilder(Cci.ModulePropertiesForSerialization serializationProperties) 830822"];
2171 [label="param PEModuleBuilder(IEnumerable<ResourceDescription> manifestResources) 830823"];
2172 [label="param PEModuleBuilder(this) 830824"];
2173 [label="sourceModule.ContainingSourceAssembly.DeclaringCompilation 830825"];
2174 [label="sourceModule 830826"];
2175 [label="serializationProperties 830827"];
2176 [label="manifestResources 830828"];
2177 [label="outputKind 830829"];
2178 [label="emitOptions 830830"];
2179 [label="new ModuleCompilationState() 830831"];
2180 [label="param ModuleCompilationState(this) 830832"];
2181 [label="param PEModuleBuilder(this) 830833"];
2182 [label="param PEModuleBuilder(this) 830834"];
2183 [label="get\n            {\n                return true;\n            } 830835"];
2184 [label="return true; 830836"];
2185 [label="param PEModuleBuilder(this) 830837"];
2186 [label="new ConcurrentDictionary<Symbol, Cci.IModuleReference>() 830838"];
2187 [label="AssemblyOrModuleSymbolToModuleRefMap = new ConcurrentDictionary<Symbol, Cci.IModuleReference>() 830839"];
2188 [label="Symbols.SymbolEqualityComparer.ConsiderEverything 830840"];
2189 [label="new ConcurrentDictionary<Symbol, object>(Symbols.SymbolEqualityComparer.ConsiderEverything) 830841"];
2190 [label="_genericInstanceMap = new ConcurrentDictionary<Symbol, object>(Symbols.SymbolEqualityComparer.ConsiderEverything) 830842"];
2191 [label="new ConcurrentSet<TypeSymbol>() 830843"];
2192 [label="_reportedErrorTypesMap = new ConcurrentSet<TypeSymbol>() 830844"];
2193 [label="_embeddedTypesManagerOpt 830845"];
2194 [label="_metadataName 830846"];
2195 [label="_fixedImplementationTypes 830847"];
2196 [label="_needsGeneratedAttributes 830848"];
2197 [label="_needsGeneratedAttributes_IsFrozen 830849"];
2198 [label="var specifiedName = sourceModule.MetadataName; 830850"];
2199 [label="_metadataName = specifiedName != Microsoft.CodeAnalysis.Compilation.UnspecifiedModuleAssemblyName ?\n                            specifiedName :\n                            emitOptions.OutputNameOverride ?? specifiedName; 830851"];
2200 [label="specifiedName != Microsoft.CodeAnalysis.Compilation.UnspecifiedModuleAssemblyName 830852"];
2201 [label="_metadataName 830853"];
2202 [label="AssemblyOrModuleSymbolToModuleRefMap.Add(sourceModule, this); 830854"];
2203 [label="AssemblyOrModuleSymbolToModuleRefMap.Add(sourceModule, this); 830855"];
2204 [label="AssemblyOrModuleSymbolToModuleRefMap.Add(sourceModule, this); 830856"];
2205 [label="AssemblyOrModuleSymbolToModuleRefMap.Add(sourceModule, this); 830857"];
2206 [label="if (sourceModule.AnyReferencedAssembliesAreLinked)\n            {\n                _embeddedTypesManagerOpt = new NoPia.EmbeddedTypesManager(this);\n            } 830858"];
2207 [label="_sourceAssembly 830859"];
2208 [label="_lazyEmbeddedAttribute 830860"];
2209 [label="_lazyIsReadOnlyAttribute 830861"];
2210 [label="_lazyIsByRefLikeAttribute 830862"];
2211 [label="_lazyIsUnmanagedAttribute 830863"];
2212 [label="_lazyNullableAttribute 830864"];
2213 [label="_lazyNullableContextAttribute 830865"];
2214 [label="_lazyNullablePublicOnlyAttribute 830866"];
2215 [label="_lazyNativeIntegerAttribute 830867"];
2216 [label="_metadataName 830868"];
2217 [label="Debug.Assert(sourceAssembly is object); 830869"];
2218 [label="_sourceAssembly 830870"];
2219 [label="_additionalTypes = additionalTypes.NullToEmpty(); 830871"];
2220 [label="_additionalTypes 830872"];
2221 [label="_metadataName = (emitOptions.OutputNameOverride == null) ? sourceAssembly.MetadataName : FileNameUtilities.ChangeExtension(emitOptions.OutputNameOverride, extension: null); 830873"];
2222 [label="_metadataName = (emitOptions.OutputNameOverride == null) ? sourceAssembly.MetadataName : FileNameUtilities.ChangeExtension(emitOptions.OutputNameOverride, extension: null); 830874"];
2223 [label="(emitOptions.OutputNameOverride == null) 830875"];
2224 [label="sourceAssembly.MetadataName 830876"];
2225 [label="_metadataName 830877"];
2226 [label="AssemblyOrModuleSymbolToModuleRefMap.Add(sourceAssembly, this); 830878"];
2227 [label="AssemblyOrModuleSymbolToModuleRefMap.Add(sourceAssembly, this); 830879"];
2228 [label="AssemblyOrModuleSymbolToModuleRefMap.Add(sourceAssembly, this); 830880"];
2229 [label="AssemblyOrModuleSymbolToModuleRefMap.Add(sourceAssembly, this); 830881"];
2230 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 830882"];
2231 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 830883"];
2232 [label="moduleBeingBuilt.SourceLinkStreamOpt 830884"];
2233 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 830885"];
2234 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 830886"];
2235 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 830887"];
2236 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 830888"];
2237 [label="return moduleBeingBuilt; 830889"];
2238 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 830890"];
2239 [label="param CompileMethods(CommonPEModuleBuilder moduleBuilder) 830891"];
2240 [label="param CompileMethods(bool emittingPdb) 830892"];
2241 [label="param CompileMethods(bool emitMetadataOnly) 830893"];
2242 [label="param CompileMethods(bool emitTestCoverageData) 830894"];
2243 [label="param CompileMethods(DiagnosticBag diagnostics) 830895"];
2244 [label="param CompileMethods(Predicate<ISymbolInternal>? filterOpt) 830896"];
2245 [label="param CompileMethods(CancellationToken cancellationToken) 830897"];
2246 [label="param CompileMethods(this) 830898"];
2247 [label="PooledHashSet<int>? excludeDiagnostics = null; 830899"];
2248 [label="if (emitMetadataOnly)\n            {\n                excludeDiagnostics = PooledHashSet<int>.GetInstance();\n                excludeDiagnostics.Add((int)ErrorCode.ERR_ConcreteMissingBody);\n            } 830900"];
2249 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 830901"];
2250 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 830902"];
2251 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 830903"];
2252 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 830904"];
2253 [label="GetDiagnostics(CompilationStage.Declare, true, cancellationToken) 830905"];
2254 [label="param GetDiagnostics(CompilationStage stage) 830906"];
2255 [label="param GetDiagnostics(bool includeEarlierStages) 830907"];
2256 [label="param GetDiagnostics(CancellationToken cancellationToken) 830908"];
2257 [label="param GetDiagnostics(this) 830909"];
2258 [label="var diagnostics = DiagnosticBag.GetInstance(); 830910"];
2259 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 830911"];
2260 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 830912"];
2261 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 830913"];
2262 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 830914"];
2263 [label="param GetDiagnostics(CompilationStage stage) 830915"];
2264 [label="param GetDiagnostics(bool includeEarlierStages) 830916"];
2265 [label="param GetDiagnostics(DiagnosticBag diagnostics) 830917"];
2266 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 830918"];
2267 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 830919"];
2268 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 830920"];
2269 [label="this.SyntaxTrees 830921"];
2270 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 830922"];
2271 [label="_syntaxAndDeclarations.GetLazyState() 830923"];
2272 [label="param GetLazyState(this) 830924"];
2273 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 830925"];
2274 [label="this.Options 830926"];
2275 [label="get\n            {\n                return _options;\n            } 830927"];
2276 [label="return _options; 830928"];
2277 [label="RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken); 830929"];
2278 [label="param AppendLoadDirectiveDiagnostics(DiagnosticBag builder) 830930"];
2279 [label="param AppendLoadDirectiveDiagnostics(Func<IEnumerable<Diagnostic>, IEnumerable<Diagnostic>>? locationFilterOpt = null) 830931"];
2280 [label="var parseOptionsReported = new HashSet<ParseOptions>(); 830932"];
2281 [label="if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    } 830933"];
2282 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 830934"];
2283 [label="CheckAssemblyName(builder); 830935"];
2284 [label="CheckAssemblyName(builder); 830936"];
2285 [label="Options 830937"];
2286 [label="get\n            {\n                return _options;\n            } 830938"];
2287 [label="Options 830939"];
2288 [label="get\n            {\n                return _options;\n            } 830940"];
2289 [label="return _options; 830941"];
2290 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 830942"];
2291 [label="GetBoundReferenceManager() 830943"];
2292 [label="param GetBoundReferenceManager(this) 830944"];
2293 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 830945"];
2294 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 830946"];
2295 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 830947"];
2296 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 830948"];
2297 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 830949"];
2298 [label="param GetSourceDeclarationDiagnostics(this) 830950"];
2299 [label="GlobalImports 830951"];
2300 [label="SourceLocation? location = null; 830952"];
2301 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 830953"];
2302 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 830954"];
2303 [label="Assembly 830955"];
2304 [label="SourceAssembly 830956"];
2305 [label="GetBoundReferenceManager() 830957"];
2306 [label="param GetBoundReferenceManager(this) 830958"];
2307 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 830959"];
2308 [label="return _referenceManager; 830960"];
2309 [label="GetBoundReferenceManager(); 830961"];
2310 [label="Assembly.ForceComplete(location, cancellationToken); 830962"];
2311 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 830963"];
2312 [label="_declarationDiagnosticsFrozen = true; 830964"];
2313 [label="_needsGeneratedAttributes_IsFrozen = true; 830965"];
2314 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 830966"];
2315 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 830967"];
2316 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 830968"];
2317 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 830969"];
2318 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 830970"];
2319 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 830971"];
2320 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 830972"];
2321 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 830973"];
2322 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 830974"];
2323 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 830975"];
2324 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 830976"];
2325 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 830977"];
2326 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 830978"];
2327 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 830979"];
2328 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 830980"];
2329 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 830981"];
2330 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 830982"];
2331 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 830983"];
2332 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 830984"];
2333 [label="excludeDiagnostics?.Free(); 830985"];
2334 [label="var moduleBeingBuilt = (PEModuleBuilder)moduleBuilder; 830986"];
2335 [label="if (emitMetadataOnly)\n            {\n                if (hasDeclarationErrors)\n                {\n                    return false;\n                }\n\n                if (moduleBeingBuilt.SourceModule.HasBadAttributes)\n                {\n                    // If there were errors but no declaration diagnostics, explicitly add a 'Failed to emit module' error.\n                    diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuilt).Name,\n                        new LocalizableResourceString(nameof(CodeAnalysisResources.ModuleHasInvalidAttributes), CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n\n                    return false;\n                }\n\n                SynthesizedMetadataCompiler.ProcessSynthesizedMembers(this, moduleBeingBuilt, cancellationToken);\n            }\n            else\n            {\n                if ((emittingPdb || emitTestCoverageData) &&\n                    !CreateDebugDocuments(moduleBeingBuilt.DebugDocumentsBuilder, moduleBeingBuilt.EmbeddedTexts, diagnostics))\n                {\n                    return false;\n                }\n\n                // Perform initial bind of method bodies in spite of earlier errors. This is the same\n                // behavior as when calling GetDiagnostics()\n\n                // Use a temporary bag so we don't have to refilter pre-existing diagnostics.\n                DiagnosticBag? methodBodyDiagnosticBag = DiagnosticBag.GetInstance();\n\n                MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken);\n\n                if (!hasDeclarationErrors && !CommonCompiler.HasUnsuppressableErrors(methodBodyDiagnosticBag))\n                {\n                    GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag);\n                }\n\n                bool hasMethodBodyError = !FilterAndAppendAndFreeDiagnostics(diagnostics, ref methodBodyDiagnosticBag, cancellationToken);\n\n                if (hasDeclarationErrors || hasMethodBodyError)\n                {\n                    return false;\n                }\n            } 830987"];
2336 [label="if ((emittingPdb || emitTestCoverageData) &&\n                    !CreateDebugDocuments(moduleBeingBuilt.DebugDocumentsBuilder, moduleBeingBuilt.EmbeddedTexts, diagnostics))\n                {\n                    return false;\n                } 830988"];
2337 [label="if ((emittingPdb || emitTestCoverageData) &&\n                    !CreateDebugDocuments(moduleBeingBuilt.DebugDocumentsBuilder, moduleBeingBuilt.EmbeddedTexts, diagnostics))\n                {\n                    return false;\n                } 830989"];
2338 [label="if ((emittingPdb || emitTestCoverageData) &&\n                    !CreateDebugDocuments(moduleBeingBuilt.DebugDocumentsBuilder, moduleBeingBuilt.EmbeddedTexts, diagnostics))\n                {\n                    return false;\n                } 830990"];
2339 [label="if ((emittingPdb || emitTestCoverageData) &&\n                    !CreateDebugDocuments(moduleBeingBuilt.DebugDocumentsBuilder, moduleBeingBuilt.EmbeddedTexts, diagnostics))\n                {\n                    return false;\n                } 830991"];
2340 [label="param AddDebugSourceDocumentsForChecksumDirectives(DebugDocumentsBuilder documentsBuilder) 830992"];
2341 [label="param AddDebugSourceDocumentsForChecksumDirectives(SyntaxTree tree) 830993"];
2342 [label="param AddDebugSourceDocumentsForChecksumDirectives(DiagnosticBag diagnostics) 830994"];
2343 [label="param AddDebugSourceDocumentsForChecksumDirectives(this) 830995"];
2344 [label="var checksumDirectives = tree.GetRoot().GetDirectives(d => d.Kind() == SyntaxKind.PragmaChecksumDirectiveTrivia &&\n                                                                 !d.ContainsDiagnostics); 830996"];
2345 [label="var checksumDirectives = tree.GetRoot().GetDirectives(d => d.Kind() == SyntaxKind.PragmaChecksumDirectiveTrivia &&\n                                                                 !d.ContainsDiagnostics); 830997"];
2346 [label="var checksumDirectives = tree.GetRoot().GetDirectives(d => d.Kind() == SyntaxKind.PragmaChecksumDirectiveTrivia &&\n                                                                 !d.ContainsDiagnostics); 830998"];
2347 [label="foreach (var directive in checksumDirectives)\n            {\n                var checksumDirective = (PragmaChecksumDirectiveTriviaSyntax)directive;\n                var path = checksumDirective.File.ValueText;\n\n                var checksumText = checksumDirective.Bytes.ValueText;\n                var normalizedPath = documentsBuilder.NormalizeDebugDocumentPath(path, basePath: tree.FilePath);\n                var existingDoc = documentsBuilder.TryGetDebugDocumentForNormalizedPath(normalizedPath);\n\n                // duplicate checksum pragmas are valid as long as values match\n                // if we have seen this document already, check for matching values.\n                if (existingDoc != null)\n                {\n                    // pragma matches a file path on an actual tree.\n                    // Dev12 compiler just ignores the pragma in this case which means that\n                    // checksum of the actual tree always wins and no warning is given.\n                    // We will continue doing the same.\n                    if (existingDoc.IsComputedChecksum)\n                    {\n                        continue;\n                    }\n\n                    var sourceInfo = existingDoc.GetSourceInfo();\n                    if (ChecksumMatches(checksumText, sourceInfo.Checksum))\n                    {\n                        var guid = Guid.Parse(checksumDirective.Guid.ValueText);\n                        if (guid == sourceInfo.ChecksumAlgorithmId)\n                        {\n                            // all parts match, nothing to do\n                            continue;\n                        }\n                    }\n\n                    // did not match to an existing document\n                    // produce a warning and ignore the pragma\n                    diagnostics.Add(ErrorCode.WRN_ConflictingChecksum, new SourceLocation(checksumDirective), path);\n                }\n                else\n                {\n                    var newDocument = new Cci.DebugSourceDocument(\n                        normalizedPath,\n                        Cci.DebugSourceDocument.CorSymLanguageTypeCSharp,\n                        MakeChecksumBytes(checksumText),\n                        Guid.Parse(checksumDirective.Guid.ValueText));\n\n                    documentsBuilder.AddDebugDocument(newDocument);\n                }\n            } 830999"];
2348 [label="if ((emittingPdb || emitTestCoverageData) &&\n                    !CreateDebugDocuments(moduleBeingBuilt.DebugDocumentsBuilder, moduleBeingBuilt.EmbeddedTexts, diagnostics))\n                {\n                    return false;\n                } 831000"];
2349 [label="DiagnosticBag? methodBodyDiagnosticBag = DiagnosticBag.GetInstance(); 831001"];
2350 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 831002"];
2351 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 831003"];
2352 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 831004"];
2353 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 831005"];
2354 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 831006"];
2355 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 831007"];
2356 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 831008"];
2357 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 831009"];
2358 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken) 831010"];
2359 [label="param CompileMethodBodies(CSharpCompilation compilation) 831011"];
2360 [label="param CompileMethodBodies(PEModuleBuilder moduleBeingBuiltOpt) 831012"];
2361 [label="param CompileMethodBodies(bool emittingPdb) 831013"];
2362 [label="param CompileMethodBodies(bool emitTestCoverageData) 831014"];
2363 [label="param CompileMethodBodies(bool hasDeclarationErrors) 831015"];
2364 [label="param CompileMethodBodies(DiagnosticBag diagnostics) 831016"];
2365 [label="param CompileMethodBodies(Predicate<Symbol> filterOpt) 831017"];
2366 [label="param CompileMethodBodies(CancellationToken cancellationToken) 831018"];
2367 [label="Debug.Assert(compilation != null); 831019"];
2368 [label="Debug.Assert(compilation != null); 831020"];
2369 [label="Debug.Assert(diagnostics != null); 831021"];
2370 [label="Debug.Assert(diagnostics != null); 831022"];
2371 [label="compilation.PreviousSubmission 831023"];
2372 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 831024"];
2373 [label="ScriptCompilationInfo 831025"];
2374 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 831026"];
2375 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 831027"];
2376 [label="MethodSymbol entryPoint = null; 831028"];
2377 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 831029"];
2378 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 831030"];
2379 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 831031"];
2380 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 831032"];
2381 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 831033"];
2382 [label="param GetEntryPoint(PEModuleBuilder moduleBeingBuilt) 831034"];
2383 [label="param GetEntryPoint(bool hasDeclarationErrors) 831035"];
2384 [label="param GetEntryPoint(CancellationToken cancellationToken) 831036"];
2385 [label="param GetEntryPointAndDiagnostics(CancellationToken cancellationToken) 831037"];
2386 [label="if (_lazyEntryPoint == null)\n            {\n                EntryPoint? entryPoint;\n                var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this);\n\n                if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                }\n\n                Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null);\n            } 831038"];
2387 [label="return _lazyEntryPoint; 831039"];
2388 [label="Debug.Assert(!entryPointAndDiagnostics.Diagnostics.IsDefault); 831040"];
2389 [label="diagnostics.AddRange(entryPointAndDiagnostics.Diagnostics); 831041"];
2390 [label="Debug.Assert(compilation != null); 831042"];
2391 [label="Debug.Assert(compilation != null); 831043"];
2392 [label="Debug.Assert(diagnostics != null); 831044"];
2393 [label="Debug.Assert(diagnostics != null); 831045"];
2394 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 831046"];
2395 [label="SetGlobalErrorIfTrue(hasDeclarationErrors) 831047"];
2396 [label="param SetGlobalErrorIfTrue(bool arg) 831048"];
2397 [label="param SetGlobalErrorIfTrue(this) 831049"];
2398 [label="if (arg)\n            {\n                _globalHasErrors = true;\n            } 831050"];
2399 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 831051"];
2400 [label="if (emittingPdb || emitTestCoverageData)\n            {\n                _debugDocumentProvider = (path, basePath) => moduleBeingBuiltOpt.DebugDocumentsBuilder.GetOrAddDebugDocument(path, basePath, CreateDebugDocumentForFile);\n            } 831052"];
2401 [label="_debugDocumentProvider = (path, basePath) => moduleBeingBuiltOpt.DebugDocumentsBuilder.GetOrAddDebugDocument(path, basePath, CreateDebugDocumentForFile); 831053"];
2402 [label="_debugDocumentProvider 831054"];
2403 [label="GetBoundReferenceManager() 831055"];
2404 [label="param GetBoundReferenceManager(this) 831056"];
2405 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 831057"];
2406 [label="return _referenceManager; 831058"];
2407 [label="GetBoundReferenceManager(); 831059"];
2408 [label="s.Accept(this, null); 831060"];
2409 [label="param VisitNamedType(NamedTypeSymbol symbol) 831061"];
2410 [label="param VisitNamedType(TypeCompilationState arg) 831062"];
2411 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 831063"];
2412 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 831064"];
2413 [label="PassesFilter(_filterOpt, symbol) 831065"];
2414 [label="param PassesFilter(Predicate<Symbol> filterOpt) 831066"];
2415 [label="param PassesFilter(Symbol symbol) 831067"];
2416 [label="return (filterOpt == null) || filterOpt(symbol); 831068"];
2417 [label="return (filterOpt == null) || filterOpt(symbol); 831069"];
2418 [label="arg = null; 831070"];
2419 [label="param CompileNamedTypeAsync(NamedTypeSymbol symbol) 831071"];
2420 [label="if (tasks == null)\n            {\n                return;\n            } 831072"];
2421 [label="if (tasks == null)\n            {\n                return;\n            } 831073"];
2422 [label="methodCompiler.WaitForWorkers(); 831074"];
2423 [label="if (moduleBeingBuiltOpt != null)\n            {\n                var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics);\n\n                var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics);\n\n                // By this time we have processed all types reachable from module's global namespace\n                compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics);\n                methodCompiler.WaitForWorkers();\n\n                var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass;\n                if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                }\n            } 831075"];
2424 [label="if (moduleBeingBuiltOpt != null)\n            {\n                var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics);\n\n                var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics);\n\n                // By this time we have processed all types reachable from module's global namespace\n                compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics);\n                methodCompiler.WaitForWorkers();\n\n                var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass;\n                if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                }\n            } 831076"];
2425 [label="var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics); 831077"];
2426 [label="moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics) 831078"];
2427 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 831079"];
2428 [label="=> _additionalTypes 831080"];
2429 [label="_additionalTypes 831081"];
2430 [label="var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics); 831082"];
2431 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics); 831083"];
2432 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics); 831084"];
2433 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics) 831085"];
2434 [label="param CompileSynthesizedMethods(ImmutableArray<NamedTypeSymbol> additionalTypes) 831086"];
2435 [label="param CompileSynthesizedMethods(DiagnosticBag diagnostics) 831087"];
2436 [label="param CompileSynthesizedMethods(this) 831088"];
2437 [label="foreach (var additionalType in additionalTypes)\n            {\n                var compilationState = new TypeCompilationState(additionalType, _compilation, _moduleBeingBuiltOpt);\n                foreach (var method in additionalType.GetMethodsToEmit())\n                {\n                    method.GenerateMethodBody(compilationState, diagnostics);\n                }\n\n                if (!diagnostics.HasAnyErrors())\n                {\n                    CompileSynthesizedMethods(compilationState);\n                }\n\n                compilationState.Free();\n            } 831089"];
2438 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics); 831090"];
2439 [label="var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics); 831091"];
2440 [label="moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics) 831092"];
2441 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 831093"];
2442 [label="param GetEmbeddedTypes(this) 831094"];
2443 [label="var builder = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 831095"];
2444 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 831096"];
2445 [label="CreateEmbeddedAttributesIfNeeded(diagnostics) 831097"];
2446 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 831098"];
2447 [label="param CreateEmbeddedAttributesIfNeeded(this) 831099"];
2448 [label="GetNeedsGeneratedAttributes() 831100"];
2449 [label="param GetNeedsGeneratedAttributes(this) 831101"];
2450 [label="_needsGeneratedAttributes_IsFrozen = true; 831102"];
2451 [label="_needsGeneratedAttributes_IsFrozen 831103"];
2452 [label="GetNeedsGeneratedAttributesInternal() 831104"];
2453 [label="param GetNeedsGeneratedAttributesInternal(this) 831105"];
2454 [label="return (EmbeddableAttributes)_needsGeneratedAttributes | Compilation.GetNeedsGeneratedAttributes(); 831106"];
2455 [label="return GetNeedsGeneratedAttributesInternal(); 831107"];
2456 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 831108"];
2457 [label="ShouldEmitNullablePublicOnlyAttribute() 831109"];
2458 [label="param ShouldEmitNullablePublicOnlyAttribute(this) 831110"];
2459 [label="return Compilation.GetUsesNullableAttributes() && Compilation.EmitNullablePublicOnly; 831111"];
2460 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 831112"];
2461 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 831113"];
2462 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 831114"];
2463 [label="return; 831115"];
2464 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 831116"];
2465 [label="builder.AddIfNotNull(_lazyEmbeddedAttribute); 831117"];
2466 [label="builder.AddIfNotNull(_lazyEmbeddedAttribute); 831118"];
2467 [label="builder.AddIfNotNull(_lazyEmbeddedAttribute); 831119"];
2468 [label="builder.AddIfNotNull(_lazyIsReadOnlyAttribute); 831120"];
2469 [label="builder.AddIfNotNull(_lazyIsReadOnlyAttribute); 831121"];
2470 [label="builder.AddIfNotNull(_lazyIsUnmanagedAttribute); 831122"];
2471 [label="builder.AddIfNotNull(_lazyIsUnmanagedAttribute); 831123"];
2472 [label="builder.AddIfNotNull(_lazyIsByRefLikeAttribute); 831124"];
2473 [label="builder.AddIfNotNull(_lazyIsByRefLikeAttribute); 831125"];
2474 [label="builder.AddIfNotNull(_lazyNullableAttribute); 831126"];
2475 [label="builder.AddIfNotNull(_lazyNullableAttribute); 831127"];
2476 [label="builder.AddIfNotNull(_lazyNullableContextAttribute); 831128"];
2477 [label="builder.AddIfNotNull(_lazyNullableContextAttribute); 831129"];
2478 [label="builder.AddIfNotNull(_lazyNullablePublicOnlyAttribute); 831130"];
2479 [label="builder.AddIfNotNull(_lazyNullablePublicOnlyAttribute); 831131"];
2480 [label="builder.AddIfNotNull(_lazyNativeIntegerAttribute); 831132"];
2481 [label="builder.AddIfNotNull(_lazyNativeIntegerAttribute); 831133"];
2482 [label="return builder.ToImmutableAndFree(); 831134"];
2483 [label="var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics); 831135"];
2484 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics); 831136"];
2485 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics); 831137"];
2486 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics) 831138"];
2487 [label="param CompileSynthesizedMethods(ImmutableArray<NamedTypeSymbol> additionalTypes) 831139"];
2488 [label="param CompileSynthesizedMethods(DiagnosticBag diagnostics) 831140"];
2489 [label="param CompileSynthesizedMethods(this) 831141"];
2490 [label="foreach (var additionalType in additionalTypes)\n            {\n                var compilationState = new TypeCompilationState(additionalType, _compilation, _moduleBeingBuiltOpt);\n                foreach (var method in additionalType.GetMethodsToEmit())\n                {\n                    method.GenerateMethodBody(compilationState, diagnostics);\n                }\n\n                if (!diagnostics.HasAnyErrors())\n                {\n                    CompileSynthesizedMethods(compilationState);\n                }\n\n                compilationState.Free();\n            } 831142"];
2491 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics); 831143"];
2492 [label="compilation.AnonymousTypeManager 831144"];
2493 [label="get\n            {\n                return _anonymousTypeManager;\n            } 831145"];
2494 [label="return _anonymousTypeManager; 831146"];
2495 [label="compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics); 831147"];
2496 [label="compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics); 831148"];
2497 [label="compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics); 831149"];
2498 [label="compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics); 831150"];
2499 [label="compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics); 831151"];
2500 [label="param GetPreviousAnonymousTypes(this) 831152"];
2501 [label="return ImmutableArray<AnonymousTypeKey>.Empty; 831153"];
2502 [label="compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics); 831154"];
2503 [label="param GetNextAnonymousTypeIndex(this) 831155"];
2504 [label="return 0; 831156"];
2505 [label="compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics); 831157"];
2506 [label="methodCompiler.WaitForWorkers() 831158"];
2507 [label="var tasks = _compilerTasks; 831159"];
2508 [label="if (tasks == null)\n            {\n                return;\n            } 831160"];
2509 [label="if (tasks == null)\n            {\n                return;\n            } 831161"];
2510 [label="methodCompiler.WaitForWorkers(); 831162"];
2511 [label="var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass; 831163"];
2512 [label="if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                } 831164"];
2513 [label="if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                } 831165"];
2514 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 831166"];
2515 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 831167"];
2516 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 831168"];
2517 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 831169"];
2518 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 831170"];
2519 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 831171"];
2520 [label="GetBoundReferenceManager() 831172"];
2521 [label="param GetBoundReferenceManager(this) 831173"];
2522 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 831174"];
2523 [label="return _referenceManager; 831175"];
2524 [label="GetBoundReferenceManager(); 831176"];
2525 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 831177"];
2526 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 831178"];
2527 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 831179"];
2528 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 831180"];
2529 [label="if (!hasDeclarationErrors && !CommonCompiler.HasUnsuppressableErrors(methodBodyDiagnosticBag))\n                {\n                    GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag);\n                } 831181"];
2530 [label="if (!hasDeclarationErrors && !CommonCompiler.HasUnsuppressableErrors(methodBodyDiagnosticBag))\n                {\n                    GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag);\n                } 831182"];
2531 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag); 831183"];
2532 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag); 831184"];
2533 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag) 831185"];
2534 [label="param GenerateModuleInitializer(PEModuleBuilder moduleBeingBuilt) 831186"];
2535 [label="param GenerateModuleInitializer(DiagnosticBag methodBodyDiagnosticBag) 831187"];
2536 [label="param GenerateModuleInitializer(this) 831188"];
2537 [label="Debug.Assert(_declarationDiagnosticsFrozen); 831189"];
2538 [label="if (_moduleInitializerMethods is object)\n            {\n                var ilBuilder = new ILBuilder(moduleBeingBuilt, new LocalSlotManager(slotAllocator: null), OptimizationLevel.Release, areLocalsZeroed: false);\n\n                foreach (MethodSymbol method in _moduleInitializerMethods.OrderBy<MethodSymbol>(LexicalOrderSymbolComparer.Instance))\n                {\n                    ilBuilder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n\n                    ilBuilder.EmitToken(\n                        moduleBeingBuilt.Translate(method, methodBodyDiagnosticBag, needDeclaration: true),\n                        CSharpSyntaxTree.Dummy.GetRoot(),\n                        methodBodyDiagnosticBag);\n                }\n\n                ilBuilder.EmitRet(isVoid: true);\n                ilBuilder.Realize();\n                moduleBeingBuilt.RootModuleType.SetStaticConstructorBody(ilBuilder.RealizedIL);\n            } 831190"];
2539 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag); 831191"];
2540 [label="bool hasMethodBodyError = !FilterAndAppendAndFreeDiagnostics(diagnostics, ref methodBodyDiagnosticBag, cancellationToken); 831192"];
2541 [label="bool hasMethodBodyError = !FilterAndAppendAndFreeDiagnostics(diagnostics, ref methodBodyDiagnosticBag, cancellationToken); 831193"];
2542 [label="bool hasMethodBodyError = !FilterAndAppendAndFreeDiagnostics(diagnostics, ref methodBodyDiagnosticBag, cancellationToken); 831194"];
2543 [label="bool hasMethodBodyError = !FilterAndAppendAndFreeDiagnostics(diagnostics, ref methodBodyDiagnosticBag, cancellationToken); 831195"];
2544 [label="bool hasMethodBodyError = !FilterAndAppendAndFreeDiagnostics(diagnostics, ref methodBodyDiagnosticBag, cancellationToken); 831196"];
2545 [label="if (hasDeclarationErrors || hasMethodBodyError)\n                {\n                    return false;\n                } 831197"];
2546 [label="return true; 831198"];
2547 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 831199"];
2548 [label="param GenerateResourcesAndDocumentationComments(CommonPEModuleBuilder moduleBuilder) 831200"];
2549 [label="param GenerateResourcesAndDocumentationComments(Stream? xmlDocStream) 831201"];
2550 [label="param GenerateResourcesAndDocumentationComments(Stream? win32Resources) 831202"];
2551 [label="param GenerateResourcesAndDocumentationComments(string? outputNameOverride) 831203"];
2552 [label="param GenerateResourcesAndDocumentationComments(DiagnosticBag diagnostics) 831204"];
2553 [label="param GenerateResourcesAndDocumentationComments(CancellationToken cancellationToken) 831205"];
2554 [label="param GenerateResourcesAndDocumentationComments(this) 831206"];
2555 [label="DiagnosticBag? resourceDiagnostics = DiagnosticBag.GetInstance(); 831207"];
2556 [label="SetupWin32Resources(moduleBuilder, win32Resources, resourceDiagnostics); 831208"];
2557 [label="SetupWin32Resources(moduleBuilder, win32Resources, resourceDiagnostics); 831209"];
2558 [label="SetupWin32Resources(moduleBuilder, win32Resources, resourceDiagnostics); 831210"];
2559 [label="SetupWin32Resources(moduleBuilder, win32Resources, resourceDiagnostics); 831211"];
2560 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 831212"];
2561 [label="SourceAssembly 831213"];
2562 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 831214"];
2563 [label="GetBoundReferenceManager() 831215"];
2564 [label="param GetBoundReferenceManager(this) 831216"];
2565 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 831217"];
2566 [label="return _referenceManager; 831218"];
2567 [label="GetBoundReferenceManager(); 831219"];
2568 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 831220"];
2569 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 831221"];
2570 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 831222"];
2571 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 831223"];
2572 [label="AddedModulesResourceNames(resourceDiagnostics) 831224"];
2573 [label="param AddedModulesResourceNames(DiagnosticBag diagnostics) 831225"];
2574 [label="param AddedModulesResourceNames(this) 831226"];
2575 [label="SourceAssembly 831227"];
2576 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 831228"];
2577 [label="GetBoundReferenceManager() 831229"];
2578 [label="param GetBoundReferenceManager(this) 831230"];
2579 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 831231"];
2580 [label="return _referenceManager; 831232"];
2581 [label="GetBoundReferenceManager(); 831233"];
2582 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 831234"];
2583 [label="ImmutableArray<ModuleSymbol> modules = SourceAssembly.Modules; 831235"];
2584 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                var m = (Symbols.Metadata.PE.PEModuleSymbol)modules[i];\n                ImmutableArray<EmbeddedResource> resources;\n\n                try\n                {\n                    resources = m.Module.GetEmbeddedResourcesOrThrow();\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    continue;\n                }\n\n                foreach (var resource in resources)\n                {\n                    yield return resource.Name;\n                }\n            } 831236"];
2585 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                var m = (Symbols.Metadata.PE.PEModuleSymbol)modules[i];\n                ImmutableArray<EmbeddedResource> resources;\n\n                try\n                {\n                    resources = m.Module.GetEmbeddedResourcesOrThrow();\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    continue;\n                }\n\n                foreach (var resource in resources)\n                {\n                    yield return resource.Name;\n                }\n            } 831237"];
2586 [label="param AddedModulesResourceNames(this) 831238"];
2587 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 831239"];
2588 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 831240"];
2589 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 831241"];
2590 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 831242"];
2591 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 831243"];
2592 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 831244"];
2593 [label="cancellationToken.ThrowIfCancellationRequested(); 831245"];
2594 [label="DiagnosticBag? xmlDiagnostics = DiagnosticBag.GetInstance(); 831246"];
2595 [label="string? assemblyName = FileNameUtilities.ChangeExtension(outputNameOverride, extension: null); 831247"];
2596 [label="string? assemblyName = FileNameUtilities.ChangeExtension(outputNameOverride, extension: null); 831248"];
2597 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 831249"];
2598 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 831250"];
2599 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 831251"];
2600 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 831252"];
2601 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 831253"];
2602 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 831254"];
2603 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken) 831255"];
2604 [label="param WriteDocumentationCommentXml(CSharpCompilation compilation) 831256"];
2605 [label="param WriteDocumentationCommentXml(string? assemblyName) 831257"];
2606 [label="param WriteDocumentationCommentXml(Stream? xmlDocStream) 831258"];
2607 [label="param WriteDocumentationCommentXml(DiagnosticBag diagnostics) 831259"];
2608 [label="param WriteDocumentationCommentXml(CancellationToken cancellationToken) 831260"];
2609 [label="param WriteDocumentationCommentXml(SyntaxTree? filterTree = null) 831261"];
2610 [label="param WriteDocumentationCommentXml(TextSpan? filterSpanWithinTree = null) 831262"];
2611 [label="StreamWriter writer = null; 831263"];
2612 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 831264"];
2613 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 831265"];
2614 [label="compilation.SourceAssembly 831266"];
2615 [label="GetBoundReferenceManager() 831267"];
2616 [label="param GetBoundReferenceManager(this) 831268"];
2617 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 831269"];
2618 [label="return _referenceManager; 831270"];
2619 [label="GetBoundReferenceManager(); 831271"];
2620 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 831272"];
2621 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 831273"];
2622 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 831274"];
2623 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 831275"];
2624 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 831276"];
2625 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 831277"];
2626 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 831278"];
2627 [label="new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken) 831279"];
2628 [label="param DocumentationCommentCompiler(TextWriter writer) 831280"];
2629 [label="param DocumentationCommentCompiler(SyntaxTree filterTree) 831281"];
2630 [label="param DocumentationCommentCompiler(TextSpan? filterSpanWithinTree) 831282"];
2631 [label="param DocumentationCommentCompiler(bool processIncludes) 831283"];
2632 [label="param DocumentationCommentCompiler(bool isForSingleSymbol) 831284"];
2633 [label="param DocumentationCommentCompiler(DiagnosticBag diagnostics) 831285"];
2634 [label="param DocumentationCommentCompiler(this) 831286"];
2635 [label="param DocumentationCommentCompiler(this) 831287"];
2636 [label="_assemblyName 831288"];
2637 [label="_compilation 831289"];
2638 [label="_writer 831290"];
2639 [label="_filterTree 831291"];
2640 [label="_filterSpanWithinTree 831292"];
2641 [label="_processIncludes 831293"];
2642 [label="_isForSingleSymbol 831294"];
2643 [label="_diagnostics 831295"];
2644 [label="_lazyComparer 831296"];
2645 [label="_includedFileCache 831297"];
2646 [label="_indentDepth 831298"];
2647 [label="_temporaryStringBuilders 831299"];
2648 [label="_writer 831300"];
2649 [label="_filterTree 831301"];
2650 [label="_filterSpanWithinTree 831302"];
2651 [label="_processIncludes 831303"];
2652 [label="_isForSingleSymbol 831304"];
2653 [label="_diagnostics 831305"];
2654 [label="compilation.SourceAssembly 831306"];
2655 [label="GetBoundReferenceManager() 831307"];
2656 [label="param GetBoundReferenceManager(this) 831308"];
2657 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 831309"];
2658 [label="return _referenceManager; 831310"];
2659 [label="GetBoundReferenceManager(); 831311"];
2660 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 831312"];
2661 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 831313"];
2662 [label="Debug.Assert(_assemblyName != null); 831314"];
2663 [label="WriteLine('<?xml version=\\'1.0\\'?>'); 831315"];
2664 [label="WriteLine('<?xml version=\\'1.0\\'?>') 831316"];
2665 [label="param WriteLine(string message) 831317"];
2666 [label="param WriteLine(this) 831318"];
2667 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831319"];
2668 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831320"];
2669 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831321"];
2670 [label="WriteLine('<doc>'); 831322"];
2671 [label="WriteLine('<doc>') 831323"];
2672 [label="param WriteLine(string message) 831324"];
2673 [label="param WriteLine(this) 831325"];
2674 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831326"];
2675 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831327"];
2676 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831328"];
2677 [label="Indent(); 831329"];
2678 [label="WriteLine('<assembly>'); 831330"];
2679 [label="WriteLine('<assembly>') 831331"];
2680 [label="param WriteLine(string message) 831332"];
2681 [label="param WriteLine(this) 831333"];
2682 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831334"];
2683 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831335"];
2684 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831336"];
2685 [label="Indent(); 831337"];
2686 [label="WriteLine('<name>{0}</name>', _assemblyName); 831338"];
2687 [label="WriteLine('<name>{0}</name>', _assemblyName) 831339"];
2688 [label="WriteLine('<name>{0}</name>', _assemblyName) 831340"];
2689 [label="param WriteLine(string format) 831341"];
2690 [label="param WriteLine(params object[] args) 831342"];
2691 [label="param WriteLine(this) 831343"];
2692 [label="WriteLine(string.Format(format, args)); 831344"];
2693 [label="WriteLine(string.Format(format, args)); 831345"];
2694 [label="WriteLine(string.Format(format, args)); 831346"];
2695 [label="WriteLine(string.Format(format, args)) 831347"];
2696 [label="param WriteLine(string message) 831348"];
2697 [label="param WriteLine(this) 831349"];
2698 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831350"];
2699 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831351"];
2700 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831352"];
2701 [label="WriteLine(string.Format(format, args)); 831353"];
2702 [label="Debug.Assert(_indentDepth >= 0); 831354"];
2703 [label="Unindent(); 831355"];
2704 [label="WriteLine('</assembly>'); 831356"];
2705 [label="WriteLine('</assembly>') 831357"];
2706 [label="param WriteLine(string message) 831358"];
2707 [label="param WriteLine(this) 831359"];
2708 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831360"];
2709 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831361"];
2710 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831362"];
2711 [label="WriteLine('<members>'); 831363"];
2712 [label="WriteLine('<members>') 831364"];
2713 [label="param WriteLine(string message) 831365"];
2714 [label="param WriteLine(this) 831366"];
2715 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831367"];
2716 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831368"];
2717 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831369"];
2718 [label="Indent(); 831370"];
2719 [label="Debug.Assert(!_isForSingleSymbol); 831371"];
2720 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 831372"];
2721 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 831373"];
2722 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 831374"];
2723 [label="DocumentationMode maxDocumentationMode; 831375"];
2724 [label="ImmutableArray<DocumentationCommentTriviaSyntax> docCommentNodes; 831376"];
2725 [label="docCommentNodes 831377"];
2726 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 831378"];
2727 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 831379"];
2728 [label="maxDocumentationMode = DocumentationMode.None; 831380"];
2729 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 831381"];
2730 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 831382"];
2731 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 831383"];
2732 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 831384"];
2733 [label="currDocumentationMode > maxDocumentationMode 831385"];
2734 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 831386"];
2735 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 831387"];
2736 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 831388"];
2737 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 831389"];
2738 [label="return true; 831390"];
2739 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 831391"];
2740 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 831392"];
2741 [label="return; 831393"];
2742 [label="Unindent(); 831394"];
2743 [label="WriteLine('</members>'); 831395"];
2744 [label="WriteLine('</members>') 831396"];
2745 [label="param WriteLine(string message) 831397"];
2746 [label="param WriteLine(this) 831398"];
2747 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831399"];
2748 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831400"];
2749 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831401"];
2750 [label="Unindent(); 831402"];
2751 [label="WriteLine('</doc>'); 831403"];
2752 [label="WriteLine('</doc>') 831404"];
2753 [label="param WriteLine(string message) 831405"];
2754 [label="param WriteLine(this) 831406"];
2755 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831407"];
2756 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831408"];
2757 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 831409"];
2758 [label="Debug.Assert(compiler._indentDepth == 0); 831410"];
2759 [label="Debug.Assert(compiler._indentDepth == 0); 831411"];
2760 [label="writer?.Flush(); 831412"];
2761 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 831413"];
2762 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 831414"];
2763 [label="compilation.SyntaxTrees 831415"];
2764 [label="_syntaxAndDeclarations.GetLazyState() 831416"];
2765 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 831417"];
2766 [label="param ReportUnprocessed(TextSpan? filterSpanWithinTree) 831418"];
2767 [label="param ReportUnprocessed(DiagnosticBag diagnostics) 831419"];
2768 [label="param ReportUnprocessed(CancellationToken cancellationToken) 831420"];
2769 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 831421"];
2770 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 831422"];
2771 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 831423"];
2772 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 831424"];
2773 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 831425"];
2774 [label="param ReportUnusedImports(SyntaxTree? filterTree) 831426"];
2775 [label="param ReportUnusedImports(DiagnosticBag diagnostics) 831427"];
2776 [label="param ReportUnusedImports(CancellationToken cancellationToken) 831428"];
2777 [label="param ReportUnusedImports(this) 831429"];
2778 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 831430"];
2779 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 831431"];
2780 [label="CompleteTrees(filterTree); 831432"];
2781 [label="CompleteTrees(filterTree) 831433"];
2782 [label="param CompleteTrees(SyntaxTree? filterTree) 831434"];
2783 [label="param CompleteTrees(this) 831435"];
2784 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 831436"];
2785 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 831437"];
2786 [label="CompleteTrees(filterTree); 831438"];
2787 [label="this.SourceModule 831439"];
2788 [label="Assembly 831440"];
2789 [label="SourceAssembly 831441"];
2790 [label="GetBoundReferenceManager() 831442"];
2791 [label="param GetBoundReferenceManager(this) 831443"];
2792 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 831444"];
2793 [label="return _referenceManager; 831445"];
2794 [label="GetBoundReferenceManager(); 831446"];
2795 [label="return Assembly.Modules[0]; 831447"];
2796 [label="get { return SourceAssembly.IsDelaySigned; } 831448"];
2797 [label="SourceAssembly 831449"];
2798 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 831450"];
2799 [label="GetBoundReferenceManager() 831451"];
2800 [label="param GetBoundReferenceManager(this) 831452"];
2801 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 831453"];
2802 [label="return _referenceManager; 831454"];
2803 [label="GetBoundReferenceManager(); 831455"];
2804 [label="SourceAssembly.IsDelaySigned 831456"];
2805 [label="get { return SourceAssembly.StrongNameKeys; } 831457"];
2806 [label="SourceAssembly 831458"];
2807 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 831459"];
2808 [label="GetBoundReferenceManager() 831460"];
2809 [label="param GetBoundReferenceManager(this) 831461"];
2810 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 831462"];
2811 [label="return _referenceManager; 831463"];
2812 [label="GetBoundReferenceManager(); 831464"];
2813 [label="param GetCorLibraryReferenceToEmit(CodeAnalysis.Emit.EmitContext context) 831465"];
2814 [label="param GetCorLibraryReferenceToEmit(this) 831466"];
2815 [label="CorLibrary 831467"];
2816 [label="get { return SourceModule.ContainingSourceAssembly.CorLibrary; } 831468"];
2817 [label="return SourceModule.ContainingSourceAssembly.CorLibrary; 831469"];
2818 [label="AssemblySymbol corLibrary = CorLibrary; 831470"];
2819 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 831471"];
2820 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 831472"];
2821 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 831473"];
2822 [label="return Translate(corLibrary, context.Diagnostics); 831474"];
2823 [label="return Translate(corLibrary, context.Diagnostics); 831475"];
2824 [label="Translate(corLibrary, context.Diagnostics) 831476"];
2825 [label="param Translate(AssemblySymbol assembly) 831477"];
2826 [label="param Translate(DiagnosticBag diagnostics) 831478"];
2827 [label="param Translate(this) 831479"];
2828 [label="if (ReferenceEquals(SourceModule.ContainingAssembly, assembly))\n            {\n                return (Cci.IAssemblyReference)this;\n            } 831480"];
2829 [label="if (ReferenceEquals(SourceModule.ContainingAssembly, assembly))\n            {\n                return (Cci.IAssemblyReference)this;\n            } 831481"];
2830 [label="if (ReferenceEquals(SourceModule.ContainingAssembly, assembly))\n            {\n                return (Cci.IAssemblyReference)this;\n            } 831482"];
2831 [label="Cci.IModuleReference reference; 831483"];
2832 [label="if (AssemblyOrModuleSymbolToModuleRefMap.TryGetValue(assembly, out reference))\n            {\n                return (Cci.IAssemblyReference)reference;\n            } 831484"];
2833 [label="if (AssemblyOrModuleSymbolToModuleRefMap.TryGetValue(assembly, out reference))\n            {\n                return (Cci.IAssemblyReference)reference;\n            } 831485"];
2834 [label="if (AssemblyOrModuleSymbolToModuleRefMap.TryGetValue(assembly, out reference))\n            {\n                return (Cci.IAssemblyReference)reference;\n            } 831486"];
2835 [label="AssemblyReference asmRef = new AssemblyReference(assembly); 831487"];
2836 [label="AssemblyReference asmRef = new AssemblyReference(assembly); 831488"];
2837 [label="new AssemblyReference(assembly) 831489"];
2838 [label="param AssemblyReference(AssemblySymbol assemblySymbol) 831490"];
2839 [label="param AssemblyReference(this) 831491"];
2840 [label="_targetAssembly 831492"];
2841 [label="Debug.Assert((object)assemblySymbol != null); 831493"];
2842 [label="Debug.Assert((object)assemblySymbol != null); 831494"];
2843 [label="_targetAssembly 831495"];
2844 [label="AssemblyReference cachedAsmRef = (AssemblyReference)AssemblyOrModuleSymbolToModuleRefMap.GetOrAdd(assembly, asmRef); 831496"];
2845 [label="AssemblyReference cachedAsmRef = (AssemblyReference)AssemblyOrModuleSymbolToModuleRefMap.GetOrAdd(assembly, asmRef); 831497"];
2846 [label="AssemblyReference cachedAsmRef = (AssemblyReference)AssemblyOrModuleSymbolToModuleRefMap.GetOrAdd(assembly, asmRef); 831498"];
2847 [label="if (cachedAsmRef == asmRef)\n            {\n                ValidateReferencedAssembly(assembly, cachedAsmRef, diagnostics);\n            } 831499"];
2848 [label="ValidateReferencedAssembly(assembly, cachedAsmRef, diagnostics); 831500"];
2849 [label="ValidateReferencedAssembly(assembly, cachedAsmRef, diagnostics); 831501"];
2850 [label="ValidateReferencedAssembly(assembly, cachedAsmRef, diagnostics); 831502"];
2851 [label="ValidateReferencedAssembly(assembly, cachedAsmRef, diagnostics) 831503"];
2852 [label="param ValidateReferencedAssembly(AssemblySymbol assembly) 831504"];
2853 [label="param ValidateReferencedAssembly(AssemblyReference asmRef) 831505"];
2854 [label="param ValidateReferencedAssembly(DiagnosticBag diagnostics) 831506"];
2855 [label="param ValidateReferencedAssembly(this) 831507"];
2856 [label="AssemblyIdentity asmIdentity = SourceModule.ContainingAssembly.Identity; 831508"];
2857 [label="asmRef.Identity 831509"];
2858 [label="=> _targetAssembly.Identity 831510"];
2859 [label="_targetAssembly.Identity 831511"];
2860 [label="AssemblyIdentity refIdentity = asmRef.Identity; 831512"];
2861 [label="if (asmIdentity.IsStrongName && !refIdentity.IsStrongName &&\n                asmRef.Identity.ContentType != AssemblyContentType.WindowsRuntime)\n            {\n                // Dev12 reported error, we have changed it to a warning to allow referencing libraries \n                // built for platforms that don't support strong names.\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName, assembly), NoLocation.Singleton);\n            } 831513"];
2862 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 831514"];
2863 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 831515"];
2864 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 831516"];
2865 [label="var refMachine = assembly.Machine; 831517"];
2866 [label="if ((object)assembly != (object)assembly.CorLibrary &&\n                !(refMachine == Machine.I386 && !assembly.Bit32Required))\n            {\n                var machine = SourceModule.Machine;\n\n                if (!(machine == Machine.I386 && !SourceModule.Bit32Required) &&\n                    machine != refMachine)\n                {\n                    // Different machine types, and neither is agnostic\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_ConflictingMachineAssembly, assembly), NoLocation.Singleton);\n                }\n            } 831518"];
2867 [label="if (_embeddedTypesManagerOpt != null && _embeddedTypesManagerOpt.IsFrozen)\n            {\n                _embeddedTypesManagerOpt.ReportIndirectReferencesToLinkedAssemblies(assembly, diagnostics);\n            } 831519"];
2868 [label="if (_embeddedTypesManagerOpt != null && _embeddedTypesManagerOpt.IsFrozen)\n            {\n                _embeddedTypesManagerOpt.ReportIndirectReferencesToLinkedAssemblies(assembly, diagnostics);\n            } 831520"];
2869 [label="ValidateReferencedAssembly(assembly, cachedAsmRef, diagnostics); 831521"];
2870 [label="AssemblyOrModuleSymbolToModuleRefMap.TryAdd(assembly.Modules[0], cachedAsmRef); 831522"];
2871 [label="AssemblyOrModuleSymbolToModuleRefMap.TryAdd(assembly.Modules[0], cachedAsmRef); 831523"];
2872 [label="AssemblyOrModuleSymbolToModuleRefMap.TryAdd(assembly.Modules[0], cachedAsmRef); 831524"];
2873 [label="return cachedAsmRef; 831525"];
2874 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 831526"];
2875 [label="=> _targetAssembly.Identity 831527"];
2876 [label="_targetAssembly.Identity 831528"];
2877 [label="param GetAssemblyReferencesFromAddedModules(DiagnosticBag diagnostics) 831529"];
2878 [label="param GetAssemblyReferencesFromAddedModules(this) 831530"];
2879 [label="ImmutableArray<ModuleSymbol> modules = SourceModule.ContainingAssembly.Modules; 831531"];
2880 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 831532"];
2881 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 831533"];
2882 [label="param GetAssemblyReferencesFromAddedModules(this) 831534"];
2883 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 831535"];
2884 [label="param GetFiles(EmitContext context) 831536"];
2885 [label="param GetFiles(this) 831537"];
2886 [label="if (!context.IsRefAssembly)\n            {\n                return getFiles(ref _lazyFiles, context, _sourceAssembly);\n            } 831538"];
2887 [label="return getFiles(ref _lazyFiles, context, _sourceAssembly); 831539"];
2888 [label="return getFiles(ref _lazyFiles, context, _sourceAssembly); 831540"];
2889 [label="getFiles(ref _lazyFiles, context, _sourceAssembly) 831541"];
2890 [label="ImmutableArray<Cci.IFileReference> getFiles(ref ImmutableArray<Cci.IFileReference> lazyFiles, EmitContext contxt, SourceAssemblySymbol sourceAssSymbol)\n            {\n                if (lazyFiles.IsDefault)\n                {\n                    var builder = ArrayBuilder<Cci.IFileReference>.GetInstance();\n                    try\n                    {\n                        var modules = sourceAssSymbol.Modules;\n                        for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        }\n\n                        if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        }\n\n                        // Dev12 compilers don't report ERR_CryptoHashFailed if there are no files to be hashed.\n                        if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        }\n                    }\n                    finally\n                    {\n                        builder.Free();\n                    }\n                }\n\n                return lazyFiles;\n            } 831542"];
2891 [label="ImmutableArray<Cci.IFileReference> getFiles(ref ImmutableArray<Cci.IFileReference> lazyFiles, EmitContext contxt, SourceAssemblySymbol sourceAssSymbol)\n            {\n                if (lazyFiles.IsDefault)\n                {\n                    var builder = ArrayBuilder<Cci.IFileReference>.GetInstance();\n                    try\n                    {\n                        var modules = sourceAssSymbol.Modules;\n                        for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        }\n\n                        if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        }\n\n                        // Dev12 compilers don't report ERR_CryptoHashFailed if there are no files to be hashed.\n                        if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        }\n                    }\n                    finally\n                    {\n                        builder.Free();\n                    }\n                }\n\n                return lazyFiles;\n            } 831543"];
2892 [label="ImmutableArray<Cci.IFileReference> getFiles(ref ImmutableArray<Cci.IFileReference> lazyFiles, EmitContext contxt, SourceAssemblySymbol sourceAssSymbol)\n            {\n                if (lazyFiles.IsDefault)\n                {\n                    var builder = ArrayBuilder<Cci.IFileReference>.GetInstance();\n                    try\n                    {\n                        var modules = sourceAssSymbol.Modules;\n                        for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        }\n\n                        if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        }\n\n                        // Dev12 compilers don't report ERR_CryptoHashFailed if there are no files to be hashed.\n                        if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        }\n                    }\n                    finally\n                    {\n                        builder.Free();\n                    }\n                }\n\n                return lazyFiles;\n            } 831544"];
2893 [label="if (lazyFiles.IsDefault)\n                {\n                    var builder = ArrayBuilder<Cci.IFileReference>.GetInstance();\n                    try\n                    {\n                        var modules = sourceAssSymbol.Modules;\n                        for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        }\n\n                        if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        }\n\n                        // Dev12 compilers don't report ERR_CryptoHashFailed if there are no files to be hashed.\n                        if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        }\n                    }\n                    finally\n                    {\n                        builder.Free();\n                    }\n                } 831545"];
2894 [label="var builder = ArrayBuilder<Cci.IFileReference>.GetInstance(); 831546"];
2895 [label="var modules = sourceAssSymbol.Modules; 831547"];
2896 [label="for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        } 831548"];
2897 [label="for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        } 831549"];
2898 [label="if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        } 831550"];
2899 [label="foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            } 831551"];
2900 [label="if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        } 831552"];
2901 [label="if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        } 831553"];
2902 [label="if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        } 831554"];
2903 [label="builder.Free(); 831555"];
2904 [label="return lazyFiles; 831556"];
2905 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 831557"];
2906 [label="=> _embeddedTypesManagerOpt 831558"];
2907 [label="_embeddedTypesManagerOpt 831559"];
2908 [label="param GetAnonymousTypeDefinitions(EmitContext context) 831560"];
2909 [label="param GetAnonymousTypeDefinitions(this) 831561"];
2910 [label="if (context.MetadataOnly)\n            {\n                return SpecializedCollections.EmptyEnumerable<Cci.INamespaceTypeDefinition>();\n            } 831562"];
2911 [label="Compilation.AnonymousTypeManager 831563"];
2912 [label="get\n            {\n                return _anonymousTypeManager;\n            } 831564"];
2913 [label="return Compilation.AnonymousTypeManager.GetAllCreatedTemplates()\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n\n#endif\n                   ; 831565"];
2914 [label="return Compilation.AnonymousTypeManager.GetAllCreatedTemplates()\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n\n#endif\n                   ; 831566"];
2915 [label="param GetAdditionalTopLevelTypeDefinitions(EmitContext context) 831567"];
2916 [label="param GetAdditionalTopLevelTypeDefinitions(this) 831568"];
2917 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 831569"];
2918 [label="GetAdditionalTopLevelTypes(context.Diagnostics) 831570"];
2919 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 831571"];
2920 [label="=> _additionalTypes 831572"];
2921 [label="_additionalTypes 831573"];
2922 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 831574"];
2923 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 831575"];
2924 [label="param GetEmbeddedTypeDefinitions(EmitContext context) 831576"];
2925 [label="param GetEmbeddedTypeDefinitions(this) 831577"];
2926 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 831578"];
2927 [label="GetEmbeddedTypes(context.Diagnostics) 831579"];
2928 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 831580"];
2929 [label="param GetEmbeddedTypes(this) 831581"];
2930 [label="var builder = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 831582"];
2931 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 831583"];
2932 [label="CreateEmbeddedAttributesIfNeeded(diagnostics) 831584"];
2933 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 831585"];
2934 [label="param CreateEmbeddedAttributesIfNeeded(this) 831586"];
2935 [label="GetNeedsGeneratedAttributes() 831587"];
2936 [label="param GetNeedsGeneratedAttributes(this) 831588"];
2937 [label="_needsGeneratedAttributes_IsFrozen = true; 831589"];
2938 [label="_needsGeneratedAttributes_IsFrozen 831590"];
2939 [label="GetNeedsGeneratedAttributesInternal() 831591"];
2940 [label="param GetNeedsGeneratedAttributesInternal(this) 831592"];
2941 [label="return (EmbeddableAttributes)_needsGeneratedAttributes | Compilation.GetNeedsGeneratedAttributes(); 831593"];
2942 [label="return GetNeedsGeneratedAttributesInternal(); 831594"];
2943 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 831595"];
2944 [label="ShouldEmitNullablePublicOnlyAttribute() 831596"];
2945 [label="param ShouldEmitNullablePublicOnlyAttribute(this) 831597"];
2946 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 831598"];
2947 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 831599"];
2948 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 831600"];
2949 [label="return; 831601"];
2950 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 831602"];
2951 [label="builder.AddIfNotNull(_lazyEmbeddedAttribute); 831603"];
2952 [label="builder.AddIfNotNull(_lazyIsReadOnlyAttribute); 831604"];
2953 [label="builder.AddIfNotNull(_lazyIsUnmanagedAttribute); 831605"];
2954 [label="builder.AddIfNotNull(_lazyIsByRefLikeAttribute); 831606"];
2955 [label="builder.AddIfNotNull(_lazyNullableAttribute); 831607"];
2956 [label="builder.AddIfNotNull(_lazyNullableContextAttribute); 831608"];
2957 [label="builder.AddIfNotNull(_lazyNullablePublicOnlyAttribute); 831609"];
2958 [label="builder.AddIfNotNull(_lazyNativeIntegerAttribute); 831610"];
2959 [label="return builder.ToImmutableAndFree(); 831611"];
2960 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 831612"];
2961 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 831613"];
2962 [label="param GetTopLevelSourceTypeDefinitions(EmitContext context) 831614"];
2963 [label="param GetTopLevelSourceTypeDefinitions(this) 831615"];
2964 [label="var namespacesToProcess = new Stack<NamespaceSymbol>(); 831616"];
2965 [label="namespacesToProcess.Push(SourceModule.GlobalNamespace); 831617"];
2966 [label="namespacesToProcess.Push(SourceModule.GlobalNamespace); 831618"];
2967 [label="while (namespacesToProcess.Count > 0)\n            {\n                var ns = namespacesToProcess.Pop();\n                foreach (var member in ns.GetMembers())\n                {\n                    if (member.Kind == SymbolKind.Namespace)\n                    {\n                        namespacesToProcess.Push((NamespaceSymbol)member);\n                    }\n                    else\n                    {\n                        yield return ((NamedTypeSymbol)member).GetCciAdapter();\n                    }\n                }\n            } 831619"];
2968 [label="while (namespacesToProcess.Count > 0)\n            {\n                var ns = namespacesToProcess.Pop();\n                foreach (var member in ns.GetMembers())\n                {\n                    if (member.Kind == SymbolKind.Namespace)\n                    {\n                        namespacesToProcess.Push((NamespaceSymbol)member);\n                    }\n                    else\n                    {\n                        yield return ((NamedTypeSymbol)member).GetCciAdapter();\n                    }\n                }\n            } 831620"];
2969 [label="var ns = namespacesToProcess.Pop(); 831621"];
2970 [label="foreach (var member in ns.GetMembers())\n                {\n                    if (member.Kind == SymbolKind.Namespace)\n                    {\n                        namespacesToProcess.Push((NamespaceSymbol)member);\n                    }\n                    else\n                    {\n                        yield return ((NamedTypeSymbol)member).GetCciAdapter();\n                    }\n                } 831622"];
2971 [label="if (member.Kind == SymbolKind.Namespace)\n                    {\n                        namespacesToProcess.Push((NamespaceSymbol)member);\n                    }\n                    else\n                    {\n                        yield return ((NamedTypeSymbol)member).GetCciAdapter();\n                    } 831623"];
2972 [label="yield return ((NamedTypeSymbol)member).GetCciAdapter(); 831624"];
2973 [label="yield return ((NamedTypeSymbol)member).GetCciAdapter(); 831625"];
2974 [label="new LexicalOrderSymbolComparer() 831626"];
2975 [label="param LexicalOrderSymbolComparer(this) 831627"];
2976 [label="Instance = new LexicalOrderSymbolComparer() 831628"];
2977 [label="param GetSynthesizedNestedTypes(NamedTypeSymbol container) 831629"];
2978 [label="param GetSynthesizedNestedTypes(this) 831630"];
2979 [label="return null; 831631"];
2980 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 831632"];
2981 [label="param GetSourceAssemblyAttributes(bool isRefAssembly) 831633"];
2982 [label="param GetSourceAssemblyAttributes(this) 831634"];
2983 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 831635"];
2984 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 831636"];
2985 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 831637"];
2986 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 831638"];
2987 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 831639"];
2988 [label="param GetSpecialType(SpecialType specialType) 831640"];
2989 [label="param GetSpecialType(this) 831641"];
2990 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 831642"];
2991 [label="NamedTypeSymbol result; 831643"];
2992 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 831644"];
2993 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 831645"];
2994 [label="Assembly 831646"];
2995 [label="GetBoundReferenceManager() 831647"];
2996 [label="GetBoundReferenceManager(); 831648"];
2997 [label="result = Assembly.GetSpecialType(specialType); 831649"];
2998 [label="result = Assembly.GetSpecialType(specialType); 831650"];
2999 [label="Debug.Assert(result.SpecialType == specialType); 831651"];
3000 [label="return result; 831652"];
3001 [label="GetBoundReferenceManager() 831653"];
3002 [label="GetBoundReferenceManager(); 831654"];
3003 [label="Debug.Assert(result.SpecialType == specialType); 831655"];
3004 [label="SourceAssembly 831656"];
3005 [label="GetBoundReferenceManager() 831657"];
3006 [label="param GetBoundReferenceManager(this) 831658"];
3007 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 831659"];
3008 [label="return _referenceManager; 831660"];
3009 [label="GetBoundReferenceManager(); 831661"];
3010 [label="GetBoundReferenceManager() 831662"];
3011 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 831663"];
3012 [label="param Translate(MethodSymbol methodSymbol) 831664"];
3013 [label="param Translate(SyntaxNode syntaxNodeOpt) 831665"];
3014 [label="param Translate(DiagnosticBag diagnostics) 831666"];
3015 [label="param Translate(BoundArgListOperator optArgList = null) 831667"];
3016 [label="param Translate(bool needDeclaration = false) 831668"];
3017 [label="param Translate(this) 831669"];
3018 [label="Debug.Assert(!methodSymbol.IsDefaultValueTypeConstructor()); 831670"];
3019 [label="Debug.Assert(!methodSymbol.IsDefaultValueTypeConstructor()); 831671"];
3020 [label="Debug.Assert(optArgList == null || (methodSymbol.IsVararg && !needDeclaration)); 831672"];
3021 [label="Debug.Assert(optArgList == null || (methodSymbol.IsVararg && !needDeclaration)); 831673"];
3022 [label="Cci.IMethodReference unexpandedMethodRef = Translate(methodSymbol, syntaxNodeOpt, diagnostics, needDeclaration); 831674"];
3023 [label="Cci.IMethodReference unexpandedMethodRef = Translate(methodSymbol, syntaxNodeOpt, diagnostics, needDeclaration); 831675"];
3024 [label="Cci.IMethodReference unexpandedMethodRef = Translate(methodSymbol, syntaxNodeOpt, diagnostics, needDeclaration); 831676"];
3025 [label="Cci.IMethodReference unexpandedMethodRef = Translate(methodSymbol, syntaxNodeOpt, diagnostics, needDeclaration); 831677"];
3026 [label="Translate(methodSymbol, syntaxNodeOpt, diagnostics, needDeclaration) 831678"];
3027 [label="param Translate(MethodSymbol methodSymbol) 831679"];
3028 [label="param Translate(SyntaxNode syntaxNodeOpt) 831680"];
3029 [label="param Translate(DiagnosticBag diagnostics) 831681"];
3030 [label="param Translate(bool needDeclaration) 831682"];
3031 [label="param Translate(this) 831683"];
3032 [label="object reference; 831684"];
3033 [label="Cci.IMethodReference methodRef; 831685"];
3034 [label="NamedTypeSymbol container = methodSymbol.ContainingType; 831686"];
3035 [label="if (container.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                methodSymbol = AnonymousTypeManager.TranslateAnonymousTypeMethodSymbol(methodSymbol);\n            } 831687"];
3036 [label="Debug.Assert(methodSymbol.IsDefinitionOrDistinct()); 831688"];
3037 [label="if (!methodSymbol.IsDefinition)\n            {\n                Debug.Assert(!needDeclaration);\n                Debug.Assert(!(methodSymbol.OriginalDefinition is NativeIntegerMethodSymbol));\n                Debug.Assert(!(methodSymbol.ConstructedFrom is NativeIntegerMethodSymbol));\n\n                return (Cci.IMethodReference)GetCciAdapter(methodSymbol);\n            }\n            else if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 831689"];
3038 [label="if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 831690"];
3039 [label="bool methodIsGeneric = methodSymbol.IsGenericMethod; 831691"];
3040 [label="bool typeIsGeneric = IsGenericType(container); 831692"];
3041 [label="IsGenericType(container) 831693"];
3042 [label="param IsGenericType(NamedTypeSymbol toCheck) 831694"];
3043 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831695"];
3044 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831696"];
3045 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 831697"];
3046 [label="toCheck = toCheck.ContainingType; 831698"];
3047 [label="return false; 831699"];
3048 [label="bool typeIsGeneric = IsGenericType(container); 831700"];
3049 [label="if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 831701"];
3050 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 831702"];
3051 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 831703"];
3052 [label="if (_embeddedTypesManagerOpt != null)\n            {\n                return _embeddedTypesManagerOpt.EmbedMethodIfNeedTo(methodSymbol.GetCciAdapter(), syntaxNodeOpt, diagnostics);\n            } 831704"];
3053 [label="if (_embeddedTypesManagerOpt != null)\n            {\n                return _embeddedTypesManagerOpt.EmbedMethodIfNeedTo(methodSymbol.GetCciAdapter(), syntaxNodeOpt, diagnostics);\n            } 831705"];
3054 [label="return methodSymbol.GetCciAdapter(); 831706"];
3055 [label="if (optArgList != null && optArgList.Arguments.Length > 0)\n            {\n                Cci.IParameterTypeInformation[] @params = new Cci.IParameterTypeInformation[optArgList.Arguments.Length];\n                int ordinal = methodSymbol.ParameterCount;\n\n                for (int i = 0; i < @params.Length; i++)\n                {\n                    @params[i] = new ArgListParameterTypeInformation(ordinal,\n                                                                    !optArgList.ArgumentRefKindsOpt.IsDefaultOrEmpty && optArgList.ArgumentRefKindsOpt[i] != RefKind.None,\n                                                                    Translate(optArgList.Arguments[i].Type, syntaxNodeOpt, diagnostics));\n                    ordinal++;\n                }\n\n                return new ExpandedVarargsMethodReference(unexpandedMethodRef, @params.AsImmutableOrNull());\n            }\n            else\n            {\n                return unexpandedMethodRef;\n            } 831707"];
3056 [label="if (optArgList != null && optArgList.Arguments.Length > 0)\n            {\n                Cci.IParameterTypeInformation[] @params = new Cci.IParameterTypeInformation[optArgList.Arguments.Length];\n                int ordinal = methodSymbol.ParameterCount;\n\n                for (int i = 0; i < @params.Length; i++)\n                {\n                    @params[i] = new ArgListParameterTypeInformation(ordinal,\n                                                                    !optArgList.ArgumentRefKindsOpt.IsDefaultOrEmpty && optArgList.ArgumentRefKindsOpt[i] != RefKind.None,\n                                                                    Translate(optArgList.Arguments[i].Type, syntaxNodeOpt, diagnostics));\n                    ordinal++;\n                }\n\n                return new ExpandedVarargsMethodReference(unexpandedMethodRef, @params.AsImmutableOrNull());\n            }\n            else\n            {\n                return unexpandedMethodRef;\n            } 831708"];
3057 [label="return unexpandedMethodRef; 831709"];
3058 [label="param Translate(TypeSymbol typeSymbol) 831710"];
3059 [label="param Translate(SyntaxNode syntaxNodeOpt) 831711"];
3060 [label="param Translate(DiagnosticBag diagnostics) 831712"];
3061 [label="param Translate(this) 831713"];
3062 [label="Debug.Assert(diagnostics != null); 831714"];
3063 [label="Debug.Assert(diagnostics != null); 831715"];
3064 [label="switch (typeSymbol.Kind)\n            {\n                case SymbolKind.DynamicType:\n                    return Translate((DynamicTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics);\n\n                case SymbolKind.ArrayType:\n                    return Translate((ArrayTypeSymbol)typeSymbol);\n\n                case SymbolKind.ErrorType:\n                case SymbolKind.NamedType:\n                    return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics);\n\n                case SymbolKind.PointerType:\n                    return Translate((PointerTypeSymbol)typeSymbol);\n\n                case SymbolKind.TypeParameter:\n                    return Translate((TypeParameterSymbol)typeSymbol);\n\n                case SymbolKind.FunctionPointerType:\n                    return Translate((FunctionPointerTypeSymbol)typeSymbol);\n            } 831716"];
3065 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 831717"];
3066 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 831718"];
3067 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 831719"];
3068 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 831720"];
3069 [label="Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics) 831721"];
3070 [label="param Translate(NamedTypeSymbol namedTypeSymbol) 831722"];
3071 [label="param Translate(SyntaxNode syntaxNodeOpt) 831723"];
3072 [label="param Translate(DiagnosticBag diagnostics) 831724"];
3073 [label="param Translate(bool fromImplements = false) 831725"];
3074 [label="param Translate(bool needDeclaration = false) 831726"];
3075 [label="param Translate(this) 831727"];
3076 [label="Debug.Assert(namedTypeSymbol.IsDefinitionOrDistinct()); 831728"];
3077 [label="Debug.Assert(diagnostics != null); 831729"];
3078 [label="Debug.Assert(diagnostics != null); 831730"];
3079 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 831731"];
3080 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 831732"];
3081 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 831733"];
3082 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 831734"];
3083 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 831735"];
3084 [label="object reference; 831736"];
3085 [label="Cci.INamedTypeReference typeRef; 831737"];
3086 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 831738"];
3087 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 831739"];
3088 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 831740"];
3089 [label="IsGenericType(container) 831741"];
3090 [label="param IsGenericType(NamedTypeSymbol toCheck) 831742"];
3091 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831743"];
3092 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831744"];
3093 [label="return false; 831745"];
3094 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 831746"];
3095 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 831747"];
3096 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 831748"];
3097 [label="return _embeddedTypesManagerOpt?.EmbedTypeIfNeedTo(namedTypeSymbol, fromImplements, syntaxNodeOpt, diagnostics) ?? namedTypeSymbol.GetCciAdapter(); 831749"];
3098 [label="return _embeddedTypesManagerOpt?.EmbedTypeIfNeedTo(namedTypeSymbol, fromImplements, syntaxNodeOpt, diagnostics) ?? namedTypeSymbol.GetCciAdapter(); 831750"];
3099 [label="param Translate(NamedTypeSymbol namedTypeSymbol) 831751"];
3100 [label="param Translate(SyntaxNode syntaxNodeOpt) 831752"];
3101 [label="param Translate(DiagnosticBag diagnostics) 831753"];
3102 [label="param Translate(bool fromImplements = false) 831754"];
3103 [label="param Translate(bool needDeclaration = false) 831755"];
3104 [label="param Translate(this) 831756"];
3105 [label="Debug.Assert(diagnostics != null); 831757"];
3106 [label="Debug.Assert(diagnostics != null); 831758"];
3107 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 831759"];
3108 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 831760"];
3109 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 831761"];
3110 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 831762"];
3111 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 831763"];
3112 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 831764"];
3113 [label="param Translate(ModuleSymbol module) 831765"];
3114 [label="param Translate(DiagnosticBag diagnostics) 831766"];
3115 [label="param Translate(this) 831767"];
3116 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 831768"];
3117 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 831769"];
3118 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 831770"];
3119 [label="if ((object)module == null)\n            {\n                return null;\n            } 831771"];
3120 [label="if ((object)module == null)\n            {\n                return null;\n            } 831772"];
3121 [label="Cci.IModuleReference moduleRef; 831773"];
3122 [label="if (AssemblyOrModuleSymbolToModuleRefMap.TryGetValue(module, out moduleRef))\n            {\n                return moduleRef;\n            } 831774"];
3123 [label="if (AssemblyOrModuleSymbolToModuleRefMap.TryGetValue(module, out moduleRef))\n            {\n                return moduleRef;\n            } 831775"];
3124 [label="if (AssemblyOrModuleSymbolToModuleRefMap.TryGetValue(module, out moduleRef))\n            {\n                return moduleRef;\n            } 831776"];
3125 [label="return moduleRef; 831777"];
3126 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 831778"];
3127 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 831779"];
3128 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 831780"];
3129 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 831781"];
3130 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 831782"];
3131 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 831783"];
3132 [label="param Translate(ImmutableArray<ParameterSymbol> @params) 831784"];
3133 [label="param Translate(this) 831785"];
3134 [label="Debug.Assert(@params.All(p => p.IsDefinitionOrDistinct())); 831786"];
3135 [label="Debug.Assert(@params.All(p => p.IsDefinitionOrDistinct())); 831787"];
3136 [label="Debug.Assert(@params.All(p => p.IsDefinitionOrDistinct())); 831788"];
3137 [label="bool mustBeTranslated = @params.Any() && MustBeWrapped(@params.First()); 831789"];
3138 [label="bool mustBeTranslated = @params.Any() && MustBeWrapped(@params.First()); 831790"];
3139 [label="MustBeWrapped(@params.First()) 831791"];
3140 [label="param MustBeWrapped(ParameterSymbol param) 831792"];
3141 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 831793"];
3142 [label="var container = param.ContainingSymbol; 831794"];
3143 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 831795"];
3144 [label="ContainerIsGeneric(container) 831796"];
3145 [label="param ContainerIsGeneric(Symbol container) 831797"];
3146 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 831798"];
3147 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 831799"];
3148 [label="IsGenericType(container.ContainingType) 831800"];
3149 [label="param IsGenericType(NamedTypeSymbol toCheck) 831801"];
3150 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831802"];
3151 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831803"];
3152 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 831804"];
3153 [label="toCheck = toCheck.ContainingType; 831805"];
3154 [label="return false; 831806"];
3155 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 831807"];
3156 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 831808"];
3157 [label="return false; 831809"];
3158 [label="bool mustBeTranslated = @params.Any() && MustBeWrapped(@params.First()); 831810"];
3159 [label="bool mustBeTranslated = @params.Any() && MustBeWrapped(@params.First()); 831811"];
3160 [label="Debug.Assert(@params.All(p => mustBeTranslated == MustBeWrapped(p)), 'either all or no parameters need translating'); 831812"];
3161 [label="Debug.Assert(@params.All(p => mustBeTranslated == MustBeWrapped(p)), 'either all or no parameters need translating'); 831813"];
3162 [label="Debug.Assert(@params.All(p => mustBeTranslated == MustBeWrapped(p)), 'either all or no parameters need translating'); 831814"];
3163 [label="param MustBeWrapped(ParameterSymbol param) 831815"];
3164 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 831816"];
3165 [label="var container = param.ContainingSymbol; 831817"];
3166 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 831818"];
3167 [label="ContainerIsGeneric(container) 831819"];
3168 [label="param ContainerIsGeneric(Symbol container) 831820"];
3169 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 831821"];
3170 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 831822"];
3171 [label="IsGenericType(container.ContainingType) 831823"];
3172 [label="param IsGenericType(NamedTypeSymbol toCheck) 831824"];
3173 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831825"];
3174 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831826"];
3175 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 831827"];
3176 [label="toCheck = toCheck.ContainingType; 831828"];
3177 [label="return false; 831829"];
3178 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 831830"];
3179 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 831831"];
3180 [label="return false; 831832"];
3181 [label="if (!mustBeTranslated)\n            {\n#if DEBUG\n                return @params.SelectAsArray<ParameterSymbol, Cci.IParameterTypeInformation>(p => p.GetCciAdapter());\n#else\n                return StaticCast<Cci.IParameterTypeInformation>.From(@params);\n#endif\n            } 831833"];
3182 [label="return @params.SelectAsArray<ParameterSymbol, Cci.IParameterTypeInformation>(p => p.GetCciAdapter()); 831834"];
3183 [label="return @params.SelectAsArray<ParameterSymbol, Cci.IParameterTypeInformation>(p => p.GetCciAdapter()); 831835"];
3184 [label="return @params.SelectAsArray<ParameterSymbol, Cci.IParameterTypeInformation>(p => p.GetCciAdapter()); 831836"];
3185 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 831837"];
3186 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 831838"];
3187 [label="param Translate(SyntaxNode syntaxNodeOpt) 831839"];
3188 [label="param Translate(DiagnosticBag diagnostics) 831840"];
3189 [label="param Translate(bool fromImplements = false) 831841"];
3190 [label="param Translate(bool needDeclaration = false) 831842"];
3191 [label="Debug.Assert(diagnostics != null); 831843"];
3192 [label="Debug.Assert(diagnostics != null); 831844"];
3193 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 831845"];
3194 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 831846"];
3195 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 831847"];
3196 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 831848"];
3197 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 831849"];
3198 [label="object reference; 831850"];
3199 [label="Cci.INamedTypeReference typeRef; 831851"];
3200 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 831852"];
3201 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 831853"];
3202 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 831854"];
3203 [label="IsGenericType(container) 831855"];
3204 [label="param IsGenericType(NamedTypeSymbol toCheck) 831856"];
3205 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831857"];
3206 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831858"];
3207 [label="return false; 831859"];
3208 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 831860"];
3209 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 831861"];
3210 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 831862"];
3211 [label="param IsPlatformType(Cci.ITypeReference typeRef) 831863"];
3212 [label="param IsPlatformType(Cci.PlatformType platformType) 831864"];
3213 [label="param IsPlatformType(this) 831865"];
3214 [label="var namedType = typeRef.GetInternalSymbol() as NamedTypeSymbol; 831866"];
3215 [label="if ((object)namedType != null)\n            {\n                if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                }\n\n                return namedType.SpecialType == (SpecialType)platformType;\n            } 831867"];
3216 [label="if ((object)namedType != null)\n            {\n                if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                }\n\n                return namedType.SpecialType == (SpecialType)platformType;\n            } 831868"];
3217 [label="if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                } 831869"];
3218 [label="return namedType.SpecialType == (SpecialType)platformType; 831870"];
3219 [label="if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                } 831871"];
3220 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 831872"];
3221 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 831873"];
3222 [label="param Translate(SyntaxNode syntaxNodeOpt) 831874"];
3223 [label="param Translate(DiagnosticBag diagnostics) 831875"];
3224 [label="param Translate(bool fromImplements = false) 831876"];
3225 [label="param Translate(bool needDeclaration = false) 831877"];
3226 [label="Debug.Assert(diagnostics != null); 831878"];
3227 [label="Debug.Assert(diagnostics != null); 831879"];
3228 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 831880"];
3229 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 831881"];
3230 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 831882"];
3231 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 831883"];
3232 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 831884"];
3233 [label="object reference; 831885"];
3234 [label="Cci.INamedTypeReference typeRef; 831886"];
3235 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 831887"];
3236 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 831888"];
3237 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 831889"];
3238 [label="IsGenericType(container) 831890"];
3239 [label="param IsGenericType(NamedTypeSymbol toCheck) 831891"];
3240 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831892"];
3241 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831893"];
3242 [label="return false; 831894"];
3243 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 831895"];
3244 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 831896"];
3245 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 831897"];
3246 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 831898"];
3247 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 831899"];
3248 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 831900"];
3249 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 831901"];
3250 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 831902"];
3251 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 831903"];
3252 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 831904"];
3253 [label="param MustBeWrapped(ParameterSymbol param) 831905"];
3254 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 831906"];
3255 [label="var container = param.ContainingSymbol; 831907"];
3256 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 831908"];
3257 [label="ContainerIsGeneric(container) 831909"];
3258 [label="param ContainerIsGeneric(Symbol container) 831910"];
3259 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 831911"];
3260 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 831912"];
3261 [label="IsGenericType(container.ContainingType) 831913"];
3262 [label="param IsGenericType(NamedTypeSymbol toCheck) 831914"];
3263 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831915"];
3264 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831916"];
3265 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 831917"];
3266 [label="toCheck = toCheck.ContainingType; 831918"];
3267 [label="return false; 831919"];
3268 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 831920"];
3269 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 831921"];
3270 [label="param MustBeWrapped(ParameterSymbol param) 831922"];
3271 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 831923"];
3272 [label="var container = param.ContainingSymbol; 831924"];
3273 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 831925"];
3274 [label="ContainerIsGeneric(container) 831926"];
3275 [label="param ContainerIsGeneric(Symbol container) 831927"];
3276 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 831928"];
3277 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 831929"];
3278 [label="IsGenericType(container.ContainingType) 831930"];
3279 [label="param IsGenericType(NamedTypeSymbol toCheck) 831931"];
3280 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831932"];
3281 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831933"];
3282 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 831934"];
3283 [label="toCheck = toCheck.ContainingType; 831935"];
3284 [label="return false; 831936"];
3285 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 831937"];
3286 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 831938"];
3287 [label="NamedTypeSymbol container = methodSymbol.ContainingType; 831939"];
3288 [label="if (container.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                methodSymbol = AnonymousTypeManager.TranslateAnonymousTypeMethodSymbol(methodSymbol);\n            } 831940"];
3289 [label="if (!methodSymbol.IsDefinition)\n            {\n                Debug.Assert(!needDeclaration);\n                Debug.Assert(!(methodSymbol.OriginalDefinition is NativeIntegerMethodSymbol));\n                Debug.Assert(!(methodSymbol.ConstructedFrom is NativeIntegerMethodSymbol));\n\n                return (Cci.IMethodReference)GetCciAdapter(methodSymbol);\n            }\n            else if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 831941"];
3290 [label="if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 831942"];
3291 [label="bool methodIsGeneric = methodSymbol.IsGenericMethod; 831943"];
3292 [label="bool typeIsGeneric = IsGenericType(container); 831944"];
3293 [label="IsGenericType(container) 831945"];
3294 [label="param IsGenericType(NamedTypeSymbol toCheck) 831946"];
3295 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831947"];
3296 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 831948"];
3297 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 831949"];
3298 [label="toCheck = toCheck.ContainingType; 831950"];
3299 [label="return false; 831951"];
3300 [label="bool typeIsGeneric = IsGenericType(container); 831952"];
3301 [label="if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 831953"];
3302 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 831954"];
3303 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 831955"];
3304 [label="if (_embeddedTypesManagerOpt != null)\n            {\n                return _embeddedTypesManagerOpt.EmbedMethodIfNeedTo(methodSymbol.GetCciAdapter(), syntaxNodeOpt, diagnostics);\n            } 831956"];
3305 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 831957"];
3306 [label="toCheck = toCheck.ContainingType; 831958"];
3307 [label="param GetSourceAssemblySecurityAttributes(this) 831959"];
3308 [label="return SourceModule.ContainingSourceAssembly.GetSecurityAttributes(); 831960"];
3309 [label="return SourceModule.ContainingSourceAssembly.GetSecurityAttributes(); 831961"];
3310 [label="return Translate(corLibrary, context.Diagnostics); 831962"];
3311 [label="param Translate(DiagnosticBag diagnostics) 831963"];
3312 [label="if (ReferenceEquals(SourceModule.ContainingAssembly, assembly))\n            {\n                return (Cci.IAssemblyReference)this;\n            } 831964"];
3313 [label="return (Cci.IAssemblyReference)reference; 831965"];
3314 [label="ImmutableArray<ModuleSymbol> modules = SourceModule.ContainingAssembly.Modules; 831966"];
3315 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 831967"];
3316 [label="param GetSourceModuleAttributes(this) 831968"];
3317 [label="return SourceModule.GetCustomAttributesToEmit(this); 831969"];
3318 [label="return SourceModule.GetCustomAttributesToEmit(this); 831970"];
3319 [label="return SourceModule.GetCustomAttributesToEmit(this); 831971"];
3320 [label="if (context.MetadataOnly)\n            {\n                return SpecializedCollections.EmptyEnumerable<Cci.INamespaceTypeDefinition>();\n            } 831972"];
3321 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 831973"];
3322 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 831974"];
3323 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 831975"];
3324 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 831976"];
3325 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 831977"];
3326 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 831978"];
3327 [label="return GetNeedsGeneratedAttributesInternal(); 831979"];
3328 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 831980"];
3329 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 831981"];
3330 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 831982"];
3331 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 831983"];
3332 [label="return; 831984"];
3333 [label="Debug.Assert(symbol.IsDefinition); 831985"];
3334 [label="SourceModule 831986"];
3335 [label="Assembly 831987"];
3336 [label="SourceAssembly 831988"];
3337 [label="GetBoundReferenceManager() 831989"];
3338 [label="param GetBoundReferenceManager(this) 831990"];
3339 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 831991"];
3340 [label="return _referenceManager; 831992"];
3341 [label="GetBoundReferenceManager(); 831993"];
3342 [label="return Assembly.Modules[0]; 831994"];
3343 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 831995"];
3344 [label="EmitNullablePublicOnly 831996"];
3345 [label="param SynthesizeNullableAttributeIfNecessary(byte? nullableContextValue) 831997"];
3346 [label="param SynthesizeNullableAttributeIfNecessary(byte nullableValue) 831998"];
3347 [label="param SynthesizeNullableAttributeIfNecessary(this) 831999"];
3348 [label="if (nullableValue == nullableContextValue ||\n                (nullableContextValue == null && nullableValue == 0))\n            {\n                return null;\n            } 832000"];
3349 [label="return null; 832001"];
3350 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 832002"];
3351 [label="param GetExportedTypes(DiagnosticBag diagnostics) 832003"];
3352 [label="param GetExportedTypes(this) 832004"];
3353 [label="Debug.Assert(HaveDeterminedTopLevelTypes); 832005"];
3354 [label="if (_lazyExportedTypes.IsDefault)\n            {\n                _lazyExportedTypes = CalculateExportedTypes();\n\n                if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                }\n            } 832006"];
3355 [label="CalculateExportedTypes() 832007"];
3356 [label="param CalculateExportedTypes(this) 832008"];
3357 [label="SourceAssemblySymbol sourceAssembly = SourceModule.ContainingSourceAssembly; 832009"];
3358 [label="var builder = ArrayBuilder<Cci.ExportedType>.GetInstance(); 832010"];
3359 [label="if (!OutputKind.IsNetModule())\n            {\n                var modules = sourceAssembly.Modules;\n                for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                }\n            } 832011"];
3360 [label="var modules = sourceAssembly.Modules; 832012"];
3361 [label="for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                } 832013"];
3362 [label="for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                } 832014"];
3363 [label="Debug.Assert(OutputKind.IsNetModule() == sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule()); 832015"];
3364 [label="sourceAssembly.DeclaringCompilation.Options 832016"];
3365 [label="get\n            {\n                return _options;\n            } 832017"];
3366 [label="Debug.Assert(OutputKind.IsNetModule() == sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule()); 832018"];
3367 [label="GetForwardedTypes(sourceAssembly, builder); 832019"];
3368 [label="GetForwardedTypes(sourceAssembly, builder); 832020"];
3369 [label="GetForwardedTypes(sourceAssembly, builder) 832021"];
3370 [label="param GetForwardedTypes(SourceAssemblySymbol sourceAssembly) 832022"];
3371 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 832023"];
3372 [label="var seenTopLevelForwardedTypes = new HashSet<NamedTypeSymbol>(); 832024"];
3373 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder); 832025"];
3374 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder); 832026"];
3375 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder); 832027"];
3376 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder) 832028"];
3377 [label="param GetForwardedTypes(HashSet<NamedTypeSymbol> seenTopLevelTypes) 832029"];
3378 [label="param GetForwardedTypes(CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData) 832030"];
3379 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 832031"];
3380 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 832032"];
3381 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 832033"];
3382 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder); 832034"];
3383 [label="sourceAssembly.DeclaringCompilation.Options 832035"];
3384 [label="get\n            {\n                return _options;\n            } 832036"];
3385 [label="if (!sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule())\n            {\n                GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder);\n            } 832037"];
3386 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder); 832038"];
3387 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder); 832039"];
3388 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder); 832040"];
3389 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder) 832041"];
3390 [label="param GetForwardedTypes(HashSet<NamedTypeSymbol> seenTopLevelTypes) 832042"];
3391 [label="param GetForwardedTypes(CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData) 832043"];
3392 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 832044"];
3393 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 832045"];
3394 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 832046"];
3395 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder); 832047"];
3396 [label="return seenTopLevelForwardedTypes; 832048"];
3397 [label="GetForwardedTypes(sourceAssembly, builder); 832049"];
3398 [label="return builder.ToImmutableAndFree(); 832050"];
3399 [label="_lazyExportedTypes = CalculateExportedTypes(); 832051"];
3400 [label="_lazyExportedTypes 832052"];
3401 [label="if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                } 832053"];
3402 [label="if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                } 832054"];
3403 [label="return _lazyExportedTypes; 832055"];
3404 [label="param AddEmbeddedResourcesFromAddedModules(ArrayBuilder<Cci.ManagedResource> builder) 832056"];
3405 [label="param AddEmbeddedResourcesFromAddedModules(DiagnosticBag diagnostics) 832057"];
3406 [label="param AddEmbeddedResourcesFromAddedModules(this) 832058"];
3407 [label="var modules = _sourceAssembly.Modules; 832059"];
3408 [label="int count = modules.Length; 832060"];
3409 [label="for (int i = 1; i < count; i++)\n            {\n                var file = (Cci.IFileReference)Translate(modules[i], diagnostics);\n\n                try\n                {\n                    foreach (EmbeddedResource resource in ((Symbols.Metadata.PE.PEModuleSymbol)modules[i]).Module.GetEmbeddedResourcesOrThrow())\n                    {\n                        builder.Add(new Cci.ManagedResource(\n                            resource.Name,\n                            (resource.Attributes & ManifestResourceAttributes.Public) != 0,\n                            null,\n                            file,\n                            resource.Offset));\n                    }\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, modules[i]), NoLocation.Singleton);\n                }\n            } 832061"];
3410 [label="for (int i = 1; i < count; i++)\n            {\n                var file = (Cci.IFileReference)Translate(modules[i], diagnostics);\n\n                try\n                {\n                    foreach (EmbeddedResource resource in ((Symbols.Metadata.PE.PEModuleSymbol)modules[i]).Module.GetEmbeddedResourcesOrThrow())\n                    {\n                        builder.Add(new Cci.ManagedResource(\n                            resource.Name,\n                            (resource.Attributes & ManifestResourceAttributes.Public) != 0,\n                            null,\n                            file,\n                            resource.Offset));\n                    }\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, modules[i]), NoLocation.Singleton);\n                }\n            } 832062"];
3411 [label="=> ImmutableArray<Cci.UsedNamespaceOrType>.Empty 832063"];
3412 [label="ImmutableArray<Cci.UsedNamespaceOrType>.Empty 832064"];
3413 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 832065"];
3414 [label="=> _sourceAssembly 832066"];
3415 [label="_sourceAssembly 832067"];
3416 [label="=> _metadataName 832068"];
3417 [label="_metadataName 832069"];
3418 [label="Debug.Assert(HaveDeterminedTopLevelTypes); 832070"];
3419 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 832071"];
3420 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 832072"];
3421 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 832073"];
3422 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 832074"];
3423 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 832075"];
3424 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 832076"];
3425 [label="get { return _metadataName; } 832077"];
3426 [label="return _metadataName; 832078"];
3427 [label="param MemberVisibility(Symbol symbol) 832079"];
3428 [label="switch (symbol.DeclaredAccessibility)\n            {\n                case Accessibility.Public:\n                    return Cci.TypeMemberVisibility.Public;\n\n                case Accessibility.Private:\n                    if (symbol.ContainingType?.TypeKind == TypeKind.Submission)\n                    {\n                        // top-level private member:\n                        return Cci.TypeMemberVisibility.Public;\n                    }\n                    else\n                    {\n                        return Cci.TypeMemberVisibility.Private;\n                    }\n\n                case Accessibility.Internal:\n                    if (symbol.ContainingAssembly.IsInteractive)\n                    {\n                        // top-level or nested internal member:\n                        return Cci.TypeMemberVisibility.Public;\n                    }\n                    else\n                    {\n                        return Cci.TypeMemberVisibility.Assembly;\n                    }\n\n                case Accessibility.Protected:\n                    if (symbol.ContainingType.TypeKind == TypeKind.Submission)\n                    {\n                        // top-level protected member:\n                        return Cci.TypeMemberVisibility.Public;\n                    }\n                    else\n                    {\n                        return Cci.TypeMemberVisibility.Family;\n                    }\n\n                case Accessibility.ProtectedAndInternal:\n                    Debug.Assert(symbol.ContainingType.TypeKind != TypeKind.Submission);\n                    return Cci.TypeMemberVisibility.FamilyAndAssembly;\n\n                case Accessibility.ProtectedOrInternal:\n                    if (symbol.ContainingAssembly.IsInteractive)\n                    {\n                        // top-level or nested protected internal member:\n                        return Cci.TypeMemberVisibility.Public;\n                    }\n                    else\n                    {\n                        return Cci.TypeMemberVisibility.FamilyOrAssembly;\n                    }\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n            } 832080"];
3429 [label="return Cci.TypeMemberVisibility.Public; 832081"];
3430 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 832082"];
3431 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 832083"];
3432 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 832084"];
3433 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 832085"];
3434 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 832086"];
3435 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 832087"];
3436 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 832088"];
3437 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 832089"];
3438 [label="GetBoundReferenceManager() 832090"];
3439 [label="GetBoundReferenceManager(); 832091"];
3440 [label="Debug.Assert(result.SpecialType == specialType); 832092"];
3441 [label="NamedTypeSymbol container = methodSymbol.ContainingType; 832093"];
3442 [label="if (container.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                methodSymbol = AnonymousTypeManager.TranslateAnonymousTypeMethodSymbol(methodSymbol);\n            } 832094"];
3443 [label="if (!methodSymbol.IsDefinition)\n            {\n                Debug.Assert(!needDeclaration);\n                Debug.Assert(!(methodSymbol.OriginalDefinition is NativeIntegerMethodSymbol));\n                Debug.Assert(!(methodSymbol.ConstructedFrom is NativeIntegerMethodSymbol));\n\n                return (Cci.IMethodReference)GetCciAdapter(methodSymbol);\n            }\n            else if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 832095"];
3444 [label="if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 832096"];
3445 [label="bool methodIsGeneric = methodSymbol.IsGenericMethod; 832097"];
3446 [label="bool typeIsGeneric = IsGenericType(container); 832098"];
3447 [label="IsGenericType(container) 832099"];
3448 [label="param IsGenericType(NamedTypeSymbol toCheck) 832100"];
3449 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 832101"];
3450 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 832102"];
3451 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 832103"];
3452 [label="toCheck = toCheck.ContainingType; 832104"];
3453 [label="return false; 832105"];
3454 [label="bool typeIsGeneric = IsGenericType(container); 832106"];
3455 [label="if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 832107"];
3456 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 832108"];
3457 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 832109"];
3458 [label="if (_embeddedTypesManagerOpt != null)\n            {\n                return _embeddedTypesManagerOpt.EmbedMethodIfNeedTo(methodSymbol.GetCciAdapter(), syntaxNodeOpt, diagnostics);\n            } 832110"];
3459 [label="param MustBeWrapped(ParameterSymbol param) 832111"];
3460 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 832112"];
3461 [label="var container = param.ContainingSymbol; 832113"];
3462 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 832114"];
3463 [label="ContainerIsGeneric(container) 832115"];
3464 [label="param ContainerIsGeneric(Symbol container) 832116"];
3465 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 832117"];
3466 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 832118"];
3467 [label="IsGenericType(container.ContainingType) 832119"];
3468 [label="param IsGenericType(NamedTypeSymbol toCheck) 832120"];
3469 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 832121"];
3470 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 832122"];
3471 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 832123"];
3472 [label="toCheck = toCheck.ContainingType; 832124"];
3473 [label="return false; 832125"];
3474 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 832126"];
3475 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 832127"];
3476 [label="param MustBeWrapped(ParameterSymbol param) 832128"];
3477 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 832129"];
3478 [label="var container = param.ContainingSymbol; 832130"];
3479 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 832131"];
3480 [label="ContainerIsGeneric(container) 832132"];
3481 [label="param ContainerIsGeneric(Symbol container) 832133"];
3482 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 832134"];
3483 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 832135"];
3484 [label="IsGenericType(container.ContainingType) 832136"];
3485 [label="param IsGenericType(NamedTypeSymbol toCheck) 832137"];
3486 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 832138"];
3487 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 832139"];
3488 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 832140"];
3489 [label="toCheck = toCheck.ContainingType; 832141"];
3490 [label="return false; 832142"];
3491 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 832143"];
3492 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 832144"];
3493 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 832145"];
3494 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 832146"];
3495 [label="param Translate(SyntaxNode syntaxNodeOpt) 832147"];
3496 [label="param Translate(DiagnosticBag diagnostics) 832148"];
3497 [label="param Translate(bool fromImplements = false) 832149"];
3498 [label="param Translate(bool needDeclaration = false) 832150"];
3499 [label="Debug.Assert(diagnostics != null); 832151"];
3500 [label="Debug.Assert(diagnostics != null); 832152"];
3501 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 832153"];
3502 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 832154"];
3503 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 832155"];
3504 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 832156"];
3505 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 832157"];
3506 [label="object reference; 832158"];
3507 [label="Cci.INamedTypeReference typeRef; 832159"];
3508 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 832160"];
3509 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 832161"];
3510 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 832162"];
3511 [label="IsGenericType(container) 832163"];
3512 [label="param IsGenericType(NamedTypeSymbol toCheck) 832164"];
3513 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 832165"];
3514 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 832166"];
3515 [label="return false; 832167"];
3516 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 832168"];
3517 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 832169"];
3518 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 832170"];
3519 [label="if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                } 832171"];
3520 [label="return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type); 832172"];
3521 [label="return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type); 832173"];
3522 [label="return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type); 832174"];
3523 [label="GetBoundReferenceManager() 832175"];
3524 [label="param GetBoundReferenceManager(this) 832176"];
3525 [label="GetBoundReferenceManager(); 832177"];
3526 [label="NamedTypeSymbol container = methodSymbol.ContainingType; 832178"];
3527 [label="if (container.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                methodSymbol = AnonymousTypeManager.TranslateAnonymousTypeMethodSymbol(methodSymbol);\n            } 832179"];
3528 [label="if (!methodSymbol.IsDefinition)\n            {\n                Debug.Assert(!needDeclaration);\n                Debug.Assert(!(methodSymbol.OriginalDefinition is NativeIntegerMethodSymbol));\n                Debug.Assert(!(methodSymbol.ConstructedFrom is NativeIntegerMethodSymbol));\n\n                return (Cci.IMethodReference)GetCciAdapter(methodSymbol);\n            }\n            else if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 832180"];
3529 [label="if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 832181"];
3530 [label="bool methodIsGeneric = methodSymbol.IsGenericMethod; 832182"];
3531 [label="bool typeIsGeneric = IsGenericType(container); 832183"];
3532 [label="IsGenericType(container) 832184"];
3533 [label="param IsGenericType(NamedTypeSymbol toCheck) 832185"];
3534 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 832186"];
3535 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 832187"];
3536 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 832188"];
3537 [label="toCheck = toCheck.ContainingType; 832189"];
3538 [label="return false; 832190"];
3539 [label="bool typeIsGeneric = IsGenericType(container); 832191"];
3540 [label="if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 832192"];
3541 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 832193"];
3542 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 832194"];
3543 [label="if (_embeddedTypesManagerOpt != null)\n            {\n                return _embeddedTypesManagerOpt.EmbedMethodIfNeedTo(methodSymbol.GetCciAdapter(), syntaxNodeOpt, diagnostics);\n            } 832195"];
3544 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 832196"];
3545 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 832197"];
3546 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 832198"];
3547 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 832199"];
3548 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 832200"];
3549 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 832201"];
3550 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 832202"];
3551 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 832203"];
3552 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 832204"];
3553 [label="param Translate(SyntaxNode syntaxNodeOpt) 832205"];
3554 [label="param Translate(DiagnosticBag diagnostics) 832206"];
3555 [label="param Translate(bool fromImplements = false) 832207"];
3556 [label="param Translate(bool needDeclaration = false) 832208"];
3557 [label="Debug.Assert(diagnostics != null); 832209"];
3558 [label="Debug.Assert(diagnostics != null); 832210"];
3559 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 832211"];
3560 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 832212"];
3561 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 832213"];
3562 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 832214"];
3563 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 832215"];
3564 [label="object reference; 832216"];
3565 [label="Cci.INamedTypeReference typeRef; 832217"];
3566 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 832218"];
3567 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 832219"];
3568 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 832220"];
3569 [label="IsGenericType(container) 832221"];
3570 [label="param IsGenericType(NamedTypeSymbol toCheck) 832222"];
3571 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 832223"];
3572 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 832224"];
3573 [label="return false; 832225"];
3574 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 832226"];
3575 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 832227"];
3576 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 832228"];
3577 [label="param MustBeWrapped(ParameterSymbol param) 832229"];
3578 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 832230"];
3579 [label="var container = param.ContainingSymbol; 832231"];
3580 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 832232"];
3581 [label="ContainerIsGeneric(container) 832233"];
3582 [label="param ContainerIsGeneric(Symbol container) 832234"];
3583 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 832235"];
3584 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 832236"];
3585 [label="IsGenericType(container.ContainingType) 832237"];
3586 [label="param IsGenericType(NamedTypeSymbol toCheck) 832238"];
3587 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 832239"];
3588 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 832240"];
3589 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 832241"];
3590 [label="toCheck = toCheck.ContainingType; 832242"];
3591 [label="return false; 832243"];
3592 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 832244"];
3593 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 832245"];
3594 [label="param MustBeWrapped(ParameterSymbol param) 832246"];
3595 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 832247"];
3596 [label="var container = param.ContainingSymbol; 832248"];
3597 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 832249"];
3598 [label="ContainerIsGeneric(container) 832250"];
3599 [label="param ContainerIsGeneric(Symbol container) 832251"];
3600 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 832252"];
3601 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 832253"];
3602 [label="IsGenericType(container.ContainingType) 832254"];
3603 [label="param IsGenericType(NamedTypeSymbol toCheck) 832255"];
3604 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 832256"];
3605 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 832257"];
3606 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 832258"];
3607 [label="toCheck = toCheck.ContainingType; 832259"];
3608 [label="return false; 832260"];
3609 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 832261"];
3610 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 832262"];
3611 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 832263"];
3612 [label="toCheck = toCheck.ContainingType; 832264"];
3613 [label="Debug.Assert(symbol.IsDefinition); 832265"];
3614 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 832266"];
3615 [label="return _referenceManager; 832267"];
3616 [label="GetBoundReferenceManager(); 832268"];
3617 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 832269"];
3618 [label="param GetSymbolToLocationMap(this) 832270"];
3619 [label="var result = new MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation>(); 832271"];
3620 [label="var namespacesAndTypesToProcess = new Stack<NamespaceOrTypeSymbol>(); 832272"];
3621 [label="namespacesAndTypesToProcess.Push(SourceModule.GlobalNamespace); 832273"];
3622 [label="namespacesAndTypesToProcess.Push(SourceModule.GlobalNamespace); 832274"];
3623 [label="Location location = null; 832275"];
3624 [label="while (namespacesAndTypesToProcess.Count > 0)\n            {\n                NamespaceOrTypeSymbol symbol = namespacesAndTypesToProcess.Pop();\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Namespace:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n\n                        // filtering out synthesized symbols not having real source \n                        // locations such as anonymous types, etc...\n                        if (location != null)\n                        {\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    case SymbolKind.NamedType:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n                        if (location != null)\n                        {\n                            //  add this named type location\n                            AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n                }\n            } 832276"];
3625 [label="while (namespacesAndTypesToProcess.Count > 0)\n            {\n                NamespaceOrTypeSymbol symbol = namespacesAndTypesToProcess.Pop();\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Namespace:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n\n                        // filtering out synthesized symbols not having real source \n                        // locations such as anonymous types, etc...\n                        if (location != null)\n                        {\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    case SymbolKind.NamedType:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n                        if (location != null)\n                        {\n                            //  add this named type location\n                            AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n                }\n            } 832277"];
3626 [label="NamespaceOrTypeSymbol symbol = namespacesAndTypesToProcess.Pop(); 832278"];
3627 [label="switch (symbol.Kind)\n                {\n                    case SymbolKind.Namespace:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n\n                        // filtering out synthesized symbols not having real source \n                        // locations such as anonymous types, etc...\n                        if (location != null)\n                        {\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    case SymbolKind.NamedType:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n                        if (location != null)\n                        {\n                            //  add this named type location\n                            AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n                } 832279"];
3628 [label="location = GetSmallestSourceLocationOrNull(symbol); 832280"];
3629 [label="GetSmallestSourceLocationOrNull(symbol) 832281"];
3630 [label="param GetSmallestSourceLocationOrNull(Symbol symbol) 832282"];
3631 [label="param GetSmallestSourceLocationOrNull(this) 832283"];
3632 [label="CSharpCompilation compilation = symbol.DeclaringCompilation; 832284"];
3633 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 832285"];
3634 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 832286"];
3635 [label="Location result = null; 832287"];
3636 [label="foreach (var loc in symbol.Locations)\n            {\n                if (loc.IsInSource && (result == null || compilation.CompareSourceLocations(result, loc) > 0))\n                {\n                    result = loc;\n                }\n            } 832288"];
3637 [label="if (loc.IsInSource && (result == null || compilation.CompareSourceLocations(result, loc) > 0))\n                {\n                    result = loc;\n                } 832289"];
3638 [label="if (loc.IsInSource && (result == null || compilation.CompareSourceLocations(result, loc) > 0))\n                {\n                    result = loc;\n                } 832290"];
3639 [label="result = loc; 832291"];
3640 [label="return result; 832292"];
3641 [label="if (location != null)\n                        {\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        } 832293"];
3642 [label="if (location != null)\n                        {\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        } 832294"];
3643 [label="foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            } 832295"];
3644 [label="switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                } 832296"];
3645 [label="namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member); 832297"];
3646 [label="location = GetSmallestSourceLocationOrNull(symbol); 832298"];
3647 [label="GetSmallestSourceLocationOrNull(symbol) 832299"];
3648 [label="param GetSmallestSourceLocationOrNull(Symbol symbol) 832300"];
3649 [label="param GetSmallestSourceLocationOrNull(this) 832301"];
3650 [label="CSharpCompilation compilation = symbol.DeclaringCompilation; 832302"];
3651 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 832303"];
3652 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 832304"];
3653 [label="if (location != null)\n                        {\n                            //  add this named type location\n                            AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        } 832305"];
3654 [label="if (location != null)\n                        {\n                            //  add this named type location\n                            AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        } 832306"];
3655 [label="AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter()); 832307"];
3656 [label="AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter()); 832308"];
3657 [label="AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter()); 832309"];
3658 [label="AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter()) 832310"];
3659 [label="param AddSymbolLocation(MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation> result) 832311"];
3660 [label="param AddSymbolLocation(Location location) 832312"];
3661 [label="param AddSymbolLocation(Cci.IDefinition definition) 832313"];
3662 [label="param AddSymbolLocation(this) 832314"];
3663 [label="FileLinePositionSpan span = location.GetLineSpan(); 832315"];
3664 [label="Cci.DebugSourceDocument doc = DebugDocumentsBuilder.TryGetDebugDocument(span.Path, basePath: location.SourceTree.FilePath); 832316"];
3665 [label="Cci.DebugSourceDocument doc = DebugDocumentsBuilder.TryGetDebugDocument(span.Path, basePath: location.SourceTree.FilePath); 832317"];
3666 [label="Cci.DebugSourceDocument doc = DebugDocumentsBuilder.TryGetDebugDocument(span.Path, basePath: location.SourceTree.FilePath); 832318"];
3667 [label="if (doc != null)\n            {\n                result.Add(doc,\n                           new Cci.DefinitionWithLocation(\n                               definition,\n                               span.StartLinePosition.Line,\n                               span.StartLinePosition.Character,\n                               span.EndLinePosition.Line,\n                               span.EndLinePosition.Character));\n            } 832319"];
3668 [label="if (doc != null)\n            {\n                result.Add(doc,\n                           new Cci.DefinitionWithLocation(\n                               definition,\n                               span.StartLinePosition.Line,\n                               span.StartLinePosition.Character,\n                               span.EndLinePosition.Line,\n                               span.EndLinePosition.Character));\n            } 832320"];
3669 [label="AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter()); 832321"];
3670 [label="foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            } 832322"];
3671 [label="return result; 832323"];
3672 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 832324"];
3673 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 832325"];
3674 [label="return _referenceManager; 832326"];
3675 [label="GetBoundReferenceManager(); 832327"];
3676 [label="CustomAssert.True(emitResult.Success, 'Diagnostics:\\r\\n' + string.Join('\\r\\n', emitResult.Diagnostics.Select(d => d.ToString()))); 832328"];
3677 [label="CustomAssert.True(emitResult.Success, 'Diagnostics:\\r\\n' + string.Join('\\r\\n', emitResult.Diagnostics.Select(d => d.ToString()))); 832329"];
3678 [label="if (expectedWarnings != null)\n            {\n                emitResult.Diagnostics.Verify(expectedWarnings);\n            } 832330"];
3679 [label="if (expectedWarnings != null)\n            {\n                emitResult.Diagnostics.Verify(expectedWarnings);\n            } 832331"];
3680 [label="return peStream.ToImmutable(); 832332"];
3681 [label="return peStream.ToImmutable(); 832333"];
3682 [label="if (comp.Options.OutputKind == OutputKind.NetModule)\n            {\n                return ModuleMetadata.CreateFromImage(image).GetReference(display: comp.MakeSourceModuleName());\n            }\n            else\n            {\n                return AssemblyMetadata.CreateFromImage(image).GetReference(aliases: aliases, embedInteropTypes: embedInteropTypes, display: comp.MakeSourceAssemblySimpleName());\n            } 832334"];
3683 [label="comp.Options 832335"];
3684 [label="get { return _options; } 832336"];
3685 [label="return AssemblyMetadata.CreateFromImage(image).GetReference(aliases: aliases, embedInteropTypes: embedInteropTypes, display: comp.MakeSourceAssemblySimpleName()); 832337"];
3686 [label="return AssemblyMetadata.CreateFromImage(image).GetReference(aliases: aliases, embedInteropTypes: embedInteropTypes, display: comp.MakeSourceAssemblySimpleName()); 832338"];
3687 [label="return AssemblyMetadata.CreateFromImage(image).GetReference(aliases: aliases, embedInteropTypes: embedInteropTypes, display: comp.MakeSourceAssemblySimpleName()); 832339"];
3688 [label="return AssemblyMetadata.CreateFromImage(image).GetReference(aliases: aliases, embedInteropTypes: embedInteropTypes, display: comp.MakeSourceAssemblySimpleName()); 832340"];
3689 [label="return AssemblyMetadata.CreateFromImage(image).GetReference(aliases: aliases, embedInteropTypes: embedInteropTypes, display: comp.MakeSourceAssemblySimpleName()); 832341"];
3690 [label="var comp = CreateCompilation(source, references: new[] { libImage },\n                options: TestOptions.DebugDll.WithAllowUnsafe(true)); 832342"];
3691 [label="var comp = CreateCompilation(source, references: new[] { libImage },\n                options: TestOptions.DebugDll.WithAllowUnsafe(true)); 832343"];
3692 [label="new[] { libImage } 832344"];
3693 [label="var comp = CreateCompilation(source, references: new[] { libImage },\n                options: TestOptions.DebugDll.WithAllowUnsafe(true)); 832345"];
3694 [label="CreateCompilation(source, references: new[] { libImage },\n                options: TestOptions.DebugDll.WithAllowUnsafe(true)) 832346"];
3695 [label="param operator(string source) 832347"];
3696 [label="source 832348"];
3697 [label="new CSharpTestSource(source) 832349"];
3698 [label="param CSharpTestSource(object value) 832350"];
3699 [label="param CSharpTestSource(this) 832351"];
3700 [label="Value 832352"];
3701 [label="var comp = CreateCompilation(source, references: new[] { libImage },\n                options: TestOptions.DebugDll.WithAllowUnsafe(true)); 832353"];
3702 [label="param CreateCompilation(CSharpTestSource source) 832354"];
3703 [label="param CreateCompilation(IEnumerable<MetadataReference> references = null) 832355"];
3704 [label="param CreateCompilation(CSharpCompilationOptions options = null) 832356"];
3705 [label="param CreateCompilation(CSharpParseOptions parseOptions = null) 832357"];
3706 [label="param CreateCompilation(TargetFramework targetFramework = TargetFramework.Standard) 832358"];
3707 [label="param CreateCompilation(string assemblyName = '') 832359"];
3708 [label="param CreateCompilation(string sourceFileName = '') 832360"];
3709 [label="param CreateCompilation(bool skipUsesIsNullable = false) 832361"];
3710 [label="source 832362"];
3711 [label="targetFramework 832363"];
3712 [label="references 832364"];
3713 [label="TargetFrameworkUtil.GetReferences(targetFramework, references) 832365"];
3714 [label="param GetReferences(TargetFramework tf) 832366"];
3715 [label="param GetReferences(IEnumerable<MetadataReference> additionalReferences) 832367"];
3716 [label="var references = GetReferences(tf); 832368"];
3717 [label="GetReferences(tf) 832369"];
3718 [label="param GetReferences(TargetFramework targetFramework) 832370"];
3719 [label="targetFramework switch\n        {\n            TargetFramework.Empty => ImmutableArray<MetadataReference>.Empty,\n            TargetFramework.Mscorlib40 => Mscorlib40References,\n            TargetFramework.Mscorlib40Extended => Mscorlib40ExtendedReferences,\n            TargetFramework.Mscorlib40AndSystemCore => Mscorlib40andSystemCoreReferences,\n            TargetFramework.Mscorlib40AndVBRuntime => Mscorlib40andVBRuntimeReferences,\n            TargetFramework.Mscorlib45 => Mscorlib45References,\n            TargetFramework.Mscorlib45Extended => Mscorlib45ExtendedReferences,\n            TargetFramework.Mscorlib45AndCSharp => Mscorlib45AndCSharpReferences,\n            TargetFramework.Mscorlib45AndVBRuntime => Mscorlib45AndVBRuntimeReferences,\n            TargetFramework.Mscorlib46 => Mscorlib46References,\n            TargetFramework.Mscorlib46Extended => Mscorlib46ExtendedReferences,\n            TargetFramework.Mscorlib461 => Mscorlib46References,\n            TargetFramework.Mscorlib461Extended => Mscorlib461ExtendedReferences,\n            TargetFramework.NetStandard20 => NetStandard20References,\n            TargetFramework.NetCoreApp => NetCoreAppReferences,\n            TargetFramework.WinRT => WinRTReferences,\n            TargetFramework.Standard => StandardReferences,\n            TargetFramework.StandardLatest => StandardLatestReferences,\n            TargetFramework.StandardAndCSharp => StandardAndCSharpReferences,\n            TargetFramework.StandardAndVBRuntime => StandardAndVBRuntimeReferences,\n            TargetFramework.StandardCompat => StandardCompatReferences,\n            TargetFramework.DefaultVb => DefaultVbReferences,\n            TargetFramework.Minimal => MinimalReferences,\n            TargetFramework.MinimalAsync => MinimalAsyncReferences,\n            _ => throw new InvalidOperationException($'Unexpected target framework {targetFramework}'),\n        } 832371"];
3720 [label="StandardReferences 832372"];
3721 [label="RuntimeUtilities.IsCoreClrRuntime 832373"];
3722 [label="NetStandard20References 832374"];
3723 [label="ImmutableArray.Create<MetadataReference>(NetStandard20.netstandard, NetStandard20.mscorlib, NetStandard20.SystemRuntime, NetStandard20.SystemCore, NetStandard20.SystemDynamicRuntime, NetStandard20.SystemLinq, NetStandard20.SystemLinqExpressions) 832375"];
3724 [label="ImmutableArray.Create<MetadataReference>(NetStandard20.netstandard, NetStandard20.mscorlib, NetStandard20.SystemRuntime, NetStandard20.SystemCore, NetStandard20.SystemDynamicRuntime, NetStandard20.SystemLinq, NetStandard20.SystemLinqExpressions) 832376"];
3725 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 832377"];
3726 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 832378"];
3727 [label="checkForDuplicateReferences(references, additionalReferences); 832379"];
3728 [label="checkForDuplicateReferences(references, additionalReferences); 832380"];
3729 [label="checkForDuplicateReferences(references, additionalReferences) 832381"];
3730 [label="void checkForDuplicateReferences(ImmutableArray<MetadataReference> refer, IEnumerable<MetadataReference> additRef)\n            {\n                var nameSet = new HashSet<string>(getNames(refer), StringComparer.OrdinalIgnoreCase);\n                foreach (var r in additRef)\n                {\n                    if (refer.Contains(r))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display}');\n                    }\n\n                    var name = getName(r);\n                    if (name != null && !nameSet.Add(name))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display} - {name}');\n                    }\n                }\n            } 832382"];
3731 [label="void checkForDuplicateReferences(ImmutableArray<MetadataReference> refer, IEnumerable<MetadataReference> additRef)\n            {\n                var nameSet = new HashSet<string>(getNames(refer), StringComparer.OrdinalIgnoreCase);\n                foreach (var r in additRef)\n                {\n                    if (refer.Contains(r))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display}');\n                    }\n\n                    var name = getName(r);\n                    if (name != null && !nameSet.Add(name))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display} - {name}');\n                    }\n                }\n            } 832383"];
3732 [label="var nameSet = new HashSet<string>(getNames(refer), StringComparer.OrdinalIgnoreCase); 832384"];
3733 [label="getNames(refer) 832385"];
3734 [label="IEnumerable<string> getNames(IEnumerable<MetadataReference> e)\n            {\n                foreach (var r in e)\n                {\n                    var name = getName(r);\n                    if (name != null)\n                    {\n                        yield return name;\n                    }\n                }\n            } 832386"];
3735 [label="foreach (var r in e)\n                {\n                    var name = getName(r);\n                    if (name != null)\n                    {\n                        yield return name;\n                    }\n                } 832387"];
3736 [label="var name = getName(r); 832388"];
3737 [label="getName(r) 832389"];
3738 [label="string getName(MetadataReference m)\n            {\n                if (m is PortableExecutableReference p &&\n                    p.GetMetadata() is AssemblyMetadata assemblyMetadata)\n                {\n                    try\n                    {\n                        var identity = assemblyMetadata.GetAssembly().Identity;\n                        return identity?.Name;\n                    }\n                    catch (BadImageFormatException)\n                    {\n                        // Happens when a native image is incorrectly passed as a PE.\n                        return null;\n                    }\n                }\n\n                return null;\n            } 832390"];
3739 [label="if (m is PortableExecutableReference p &&\n                    p.GetMetadata() is AssemblyMetadata assemblyMetadata)\n                {\n                    try\n                    {\n                        var identity = assemblyMetadata.GetAssembly().Identity;\n                        return identity?.Name;\n                    }\n                    catch (BadImageFormatException)\n                    {\n                        // Happens when a native image is incorrectly passed as a PE.\n                        return null;\n                    }\n                } 832391"];
3740 [label="var identity = assemblyMetadata.GetAssembly().Identity; 832392"];
3741 [label="return identity?.Name; 832393"];
3742 [label="if (name != null)\n                    {\n                        yield return name;\n                    } 832394"];
3743 [label="if (name != null)\n                    {\n                        yield return name;\n                    } 832395"];
3744 [label="yield return name; 832396"];
3745 [label="yield return name; 832397"];
3746 [label="return identity?.Name; 832398"];
3747 [label="if (name != null)\n                    {\n                        yield return name;\n                    } 832399"];
3748 [label="if (name != null)\n                    {\n                        yield return name;\n                    } 832400"];
3749 [label="yield return name; 832401"];
3750 [label="if (name != null)\n                    {\n                        yield return name;\n                    } 832402"];
3751 [label="yield return name; 832403"];
3752 [label="var nameSet = new HashSet<string>(getNames(refer), StringComparer.OrdinalIgnoreCase); 832404"];
3753 [label="foreach (var r in additRef)\n                {\n                    if (refer.Contains(r))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display}');\n                    }\n\n                    var name = getName(r);\n                    if (name != null && !nameSet.Add(name))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display} - {name}');\n                    }\n                } 832405"];
3754 [label="foreach (var r in additRef)\n                {\n                    if (refer.Contains(r))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display}');\n                    }\n\n                    var name = getName(r);\n                    if (name != null && !nameSet.Add(name))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display} - {name}');\n                    }\n                } 832406"];
3755 [label="if (refer.Contains(r))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display}');\n                    } 832407"];
3756 [label="if (refer.Contains(r))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display}');\n                    } 832408"];
3757 [label="var name = getName(r); 832409"];
3758 [label="getName(r) 832410"];
3759 [label="string getName(MetadataReference m)\n            {\n                if (m is PortableExecutableReference p &&\n                    p.GetMetadata() is AssemblyMetadata assemblyMetadata)\n                {\n                    try\n                    {\n                        var identity = assemblyMetadata.GetAssembly().Identity;\n                        return identity?.Name;\n                    }\n                    catch (BadImageFormatException)\n                    {\n                        // Happens when a native image is incorrectly passed as a PE.\n                        return null;\n                    }\n                }\n\n                return null;\n            } 832411"];
3760 [label="if (m is PortableExecutableReference p &&\n                    p.GetMetadata() is AssemblyMetadata assemblyMetadata)\n                {\n                    try\n                    {\n                        var identity = assemblyMetadata.GetAssembly().Identity;\n                        return identity?.Name;\n                    }\n                    catch (BadImageFormatException)\n                    {\n                        // Happens when a native image is incorrectly passed as a PE.\n                        return null;\n                    }\n                } 832412"];
3761 [label="if (m is PortableExecutableReference p &&\n                    p.GetMetadata() is AssemblyMetadata assemblyMetadata)\n                {\n                    try\n                    {\n                        var identity = assemblyMetadata.GetAssembly().Identity;\n                        return identity?.Name;\n                    }\n                    catch (BadImageFormatException)\n                    {\n                        // Happens when a native image is incorrectly passed as a PE.\n                        return null;\n                    }\n                } 832413"];
3762 [label="if (name != null && !nameSet.Add(name))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display} - {name}');\n                    } 832414"];
3763 [label="if (name != null && !nameSet.Add(name))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display} - {name}');\n                    } 832415"];
3764 [label="if (name != null && !nameSet.Add(name))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display} - {name}');\n                    } 832416"];
3765 [label="if (name != null && !nameSet.Add(name))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display} - {name}');\n                    } 832417"];
3766 [label="checkForDuplicateReferences(references, additionalReferences); 832418"];
3767 [label="return references.AddRange(additionalReferences); 832419"];
3768 [label="return references.AddRange(additionalReferences); 832420"];
3769 [label="parseOptions 832421"];
3770 [label="assemblyName 832422"];
3771 [label="sourceFileName 832423"];
3772 [label="skipUsesIsNullable 832424"];
3773 [label="CreateEmptyCompilation(source, TargetFrameworkUtil.GetReferences(targetFramework, references), options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable) 832425"];
3774 [label="param CreateEmptyCompilation(CSharpTestSource source) 832426"];
3775 [label="param CreateEmptyCompilation(CSharpParseOptions parseOptions = null) 832427"];
3776 [label="param CreateEmptyCompilation(string assemblyName = '') 832428"];
3777 [label="param CreateEmptyCompilation(string sourceFileName = '') 832429"];
3778 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 832430"];
3779 [label="source 832431"];
3780 [label="parseOptions 832432"];
3781 [label="assemblyName 832433"];
3782 [label="sourceFileName 832434"];
3783 [label="skipUsesIsNullable 832435"];
3784 [label="null 832436"];
3785 [label="experimentalFeature: null 832437"];
3786 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 832438"];
3787 [label="param CreateCompilationCore(CSharpTestSource source) 832439"];
3788 [label="param CreateCompilationCore(CSharpParseOptions parseOptions) 832440"];
3789 [label="param CreateCompilationCore(string assemblyName) 832441"];
3790 [label="param CreateCompilationCore(string sourceFileName) 832442"];
3791 [label="param CreateCompilationCore(bool skipUsesIsNullable) 832443"];
3792 [label="param CreateCompilationCore(MessageID? experimentalFeature) 832444"];
3793 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 832445"];
3794 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 832446"];
3795 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 832447"];
3796 [label="param GetSyntaxTrees(CSharpParseOptions parseOptions) 832448"];
3797 [label="param GetSyntaxTrees(string sourceFileName = '') 832449"];
3798 [label="param GetSyntaxTrees(this) 832450"];
3799 [label="switch (Value)\n            {\n                case string source:\n                    return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) };\n                case string[] sources:\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return CSharpTestBase.Parse(parseOptions, sources);\n                case SyntaxTree tree:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return new[] { tree };\n                case SyntaxTree[] trees:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return trees;\n                case CSharpTestSource[] testSources:\n                    return testSources.SelectMany(s => s.GetSyntaxTrees(parseOptions, sourceFileName)).ToArray();\n                case null:\n                    return Array.Empty<SyntaxTree>();\n                default:\n                    throw new Exception($'Unexpected value: {Value}');\n            } 832451"];
3800 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 832452"];
3801 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 832453"];
3802 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 832454"];
3803 [label="CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) 832455"];
3804 [label="param Parse(string text) 832456"];
3805 [label="param Parse(string filename = '') 832457"];
3806 [label="param Parse(CSharpParseOptions options = null) 832458"];
3807 [label="param Parse(Encoding encoding = null) 832459"];
3808 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 832460"];
3809 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 832461"];
3810 [label="options = TestOptions.Regular; 832462"];
3811 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 832463"];
3812 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 832464"];
3813 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 832465"];
3814 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 832466"];
3815 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 832467"];
3816 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 832468"];
3817 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 832469"];
3818 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 832470"];
3819 [label="CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)) 832471"];
3820 [label="var stream = new MemoryStream(); 832472"];
3821 [label="var root = tree.GetRoot(); 832473"];
3822 [label="var root = tree.GetRoot(); 832474"];
3823 [label="root.SerializeTo(stream); 832475"];
3824 [label="root.SerializeTo(stream); 832476"];
3825 [label="root.SerializeTo(stream); 832477"];
3826 [label="stream.Position = 0; 832478"];
3827 [label="stream.Position 832479"];
3828 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 832480"];
3829 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 832481"];
3830 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 832482"];
3831 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 832483"];
3832 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 832484"];
3833 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 832485"];
3834 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 832486"];
3835 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 832487"];
3836 [label="Func<CSharpCompilation> createCompilationLambda = () => CSharpCompilation.Create(\n                assemblyName == '' ? GetUniqueName() : assemblyName,\n                syntaxTrees,\n                references,\n                options); 832488"];
3837 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 832489"];
3838 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 832490"];
3839 [label="param ValidateIOperations(Func<Compilation> createCompilation) 832491"];
3840 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 832492"];
3841 [label="return; 832493"];
3842 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 832494"];
3843 [label="var compilation = createCompilationLambda(); 832495"];
3844 [label="return Guid.NewGuid().ToString('D'); 832496"];
3845 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 832497"];
3846 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 832498"];
3847 [label="param Create(CSharpCompilation? previousSubmission) 832499"];
3848 [label="param Create(Type? returnType) 832500"];
3849 [label="param Create(Type? hostObjectType) 832501"];
3850 [label="param Create(bool isSubmission) 832502"];
3851 [label="RoslynDebug.Assert(options != null); 832503"];
3852 [label="RoslynDebug.Assert(options != null); 832504"];
3853 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 832505"];
3854 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 832506"];
3855 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 832507"];
3856 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 832508"];
3857 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 832509"];
3858 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 832510"];
3859 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 832511"];
3860 [label="new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null) 832512"];
3861 [label="param SyntaxAndDeclarationManager(ImmutableArray<SyntaxTree> externalSyntaxTrees) 832513"];
3862 [label="param SyntaxAndDeclarationManager(CommonMessageProvider messageProvider) 832514"];
3863 [label="param SyntaxAndDeclarationManager(bool isSubmission) 832515"];
3864 [label="param SyntaxAndDeclarationManager(State state) 832516"];
3865 [label="param SyntaxAndDeclarationManager(this) 832517"];
3866 [label="externalSyntaxTrees 832518"];
3867 [label="messageProvider 832519"];
3868 [label="isSubmission 832520"];
3869 [label="param SyntaxAndDeclarationManager(this) 832521"];
3870 [label="_lazyState 832522"];
3871 [label="_lazyState 832523"];
3872 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 832524"];
3873 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 832525"];
3874 [label="param CSharpCompilation(Type? submissionReturnType) 832526"];
3875 [label="param CSharpCompilation(Type? hostObjectType) 832527"];
3876 [label="param CSharpCompilation(bool isSubmission) 832528"];
3877 [label="param CSharpCompilation(ReferenceManager? referenceManager) 832529"];
3878 [label="param CSharpCompilation(bool reuseReferenceManager) 832530"];
3879 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 832531"];
3880 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 832532"];
3881 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 832533"];
3882 [label="param CSharpCompilation(this) 832534"];
3883 [label="previousSubmission 832535"];
3884 [label="submissionReturnType 832536"];
3885 [label="hostObjectType 832537"];
3886 [label="isSubmission 832538"];
3887 [label="referenceManager 832539"];
3888 [label="reuseReferenceManager 832540"];
3889 [label="syntaxAndDeclarations 832541"];
3890 [label="semanticModelProvider 832542"];
3891 [label="eventQueue 832543"];
3892 [label="param CSharpCompilation(this) 832544"];
3893 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 832545"];
3894 [label="param CSharpCompilation(Type? submissionReturnType) 832546"];
3895 [label="param CSharpCompilation(Type? hostObjectType) 832547"];
3896 [label="param CSharpCompilation(bool isSubmission) 832548"];
3897 [label="param CSharpCompilation(ReferenceManager? referenceManager) 832549"];
3898 [label="param CSharpCompilation(bool reuseReferenceManager) 832550"];
3899 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 832551"];
3900 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 832552"];
3901 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 832553"];
3902 [label="param CSharpCompilation(this) 832554"];
3903 [label="isSubmission 832555"];
3904 [label="semanticModelProvider 832556"];
3905 [label="eventQueue 832557"];
3906 [label="param CSharpCompilation(this) 832558"];
3907 [label="_options 832559"];
3908 [label="_globalImports 832560"];
3909 [label="_previousSubmissionImports 832561"];
3910 [label="_globalNamespaceAlias 832562"];
3911 [label="_scriptClass 832563"];
3912 [label="_lazyHostObjectTypeSymbol 832564"];
3913 [label="_lazyImportInfos 832565"];
3914 [label="_conversions 832566"];
3915 [label="_anonymousTypeManager 832567"];
3916 [label="_lazyGlobalNamespace 832568"];
3917 [label="builtInOperators 832569"];
3918 [label="_lazyAssemblySymbol 832570"];
3919 [label="_referenceManager 832571"];
3920 [label="_syntaxAndDeclarations 832572"];
3921 [label="_lazyEntryPoint 832573"];
3922 [label="_lazyEmitNullablePublicOnly 832574"];
3923 [label="_lazyCompilationUnitCompletedTrees 832575"];
3924 [label="NullableAnalysisData 832576"];
3925 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 832577"];
3926 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 832578"];
3927 [label="_externAliasTargets 832579"];
3928 [label="_moduleInitializerMethods 832580"];
3929 [label="_binderFactories 832581"];
3930 [label="_ignoreAccessibilityBinderFactories 832582"];
3931 [label="_lazyDeclarationDiagnostics 832583"];
3932 [label="_declarationDiagnosticsFrozen 832584"];
3933 [label="new DiagnosticBag() 832585"];
3934 [label="_additionalCodegenWarnings = new DiagnosticBag() 832586"];
3935 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 832587"];
3936 [label="this.builtInOperators = new BuiltInOperators(this); 832588"];
3937 [label="this.builtInOperators = new BuiltInOperators(this); 832589"];
3938 [label="new BuiltInOperators(this) 832590"];
3939 [label="param BuiltInOperators(CSharpCompilation compilation) 832591"];
3940 [label="param BuiltInOperators(this) 832592"];
3941 [label="_compilation 832593"];
3942 [label="_builtInUnaryOperators 832594"];
3943 [label="_builtInOperators 832595"];
3944 [label="_compilation 832596"];
3945 [label="this.builtInOperators 832597"];
3946 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 832598"];
3947 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 832599"];
3948 [label="LanguageVersion? result = null; 832600"];
3949 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 832601"];
3950 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 832602"];
3951 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 832603"];
3952 [label="this.LanguageVersion 832604"];
3953 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 832605"];
3954 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 832606"];
3955 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 832607"];
3956 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 832608"];
3957 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 832609"];
3958 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 832610"];
3959 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 832611"];
3960 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 832612"];
3961 [label="this.Options 832613"];
3962 [label="get\n            {\n                return _options;\n            } 832614"];
3963 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 832615"];
3964 [label="_syntaxAndDeclarations 832616"];
3965 [label="Debug.Assert(_lazyAssemblySymbol is null); 832617"];
3966 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 832618"];
3967 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 832619"];
3968 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 832620"];
3969 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 832621"];
3970 [label="int i = 0; 832622"];
3971 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 832623"];
3972 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 832624"];
3973 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 832625"];
3974 [label="i++; 832626"];
3975 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 832627"];
3976 [label="var scriptClassName = this.ScriptClassName; 832628"];
3977 [label="var resolver = this.Resolver; 832629"];
3978 [label="var messageProvider = this.MessageProvider; 832630"];
3979 [label="var isSubmission = this.IsSubmission; 832631"];
3980 [label="this.PreviousSubmission 832632"];
3981 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 832633"];
3982 [label="param CSharpCompilation(Type? submissionReturnType) 832634"];
3983 [label="param CSharpCompilation(Type? hostObjectType) 832635"];
3984 [label="previousSubmission 832636"];
3985 [label="submissionReturnType 832637"];
3986 [label="hostObjectType 832638"];
3987 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 832639"];
3988 [label="param CSharpCompilation(Type? submissionReturnType) 832640"];
3989 [label="param CSharpCompilation(Type? hostObjectType) 832641"];
3990 [label="_compilation 832642"];
3991 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 832643"];
3992 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 832644"];
3993 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 832645"];
3994 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 832646"];
3995 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 832647"];
3996 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 832648"];
3997 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 832649"];
3998 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 832650"];
3999 [label="Debug.Assert(_lazyAssemblySymbol is null); 832651"];
4000 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 832652"];
4001 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 832653"];
4002 [label="IsNullableEnabled(compilation) 832654"];
4003 [label="compilation.SyntaxTrees 832655"];
4004 [label="_syntaxAndDeclarations.GetLazyState() 832656"];
4005 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 832657"];
4006 [label="param CreateState(SourceReferenceResolver resolver) 832658"];
4007 [label="param CreateState(CommonMessageProvider messageProvider) 832659"];
4008 [label="param AppendAllSyntaxTrees(SourceReferenceResolver resolver) 832660"];
4009 [label="param AppendAllSyntaxTrees(CommonMessageProvider messageProvider) 832661"];
4010 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, ImmutableArray<LoadDirective>> loadDirectiveMapBuilder) 832662"];
4011 [label="param AppendAllSyntaxTrees(IDictionary<string, SyntaxTree> loadedSyntaxTreeMapBuilder) 832663"];
4012 [label="var sourceCodeKind = tree.Options.Kind; 832664"];
4013 [label="if (sourceCodeKind == SourceCodeKind.Script)\n            {\n                AppendAllLoadedSyntaxTrees(treesBuilder, tree, scriptClassName, resolver, messageProvider, isSubmission, ordinalMapBuilder, loadDirectiveMapBuilder, loadedSyntaxTreeMapBuilder, declMapBuilder, ref declTable);\n            } 832665"];
4014 [label="OrdinalMap 832666"];
4015 [label="LoadDirectiveMap 832667"];
4016 [label="LoadedSyntaxTreeMap 832668"];
4017 [label="RootNamespaces 832669"];
4018 [label="DeclarationTable 832670"];
4019 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 832671"];
4020 [label="var options = (CSharpParseOptions)trees[0].Options; 832672"];
4021 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 832673"];
4022 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 832674"];
4023 [label="validator(comp); 832675"];
4024 [label="validator(comp); 832676"];
4025 [label="validator(comp); 832677"];
4026 [label="var diagnostics = c.GetDiagnostics(); 832678"];
4027 [label="c.GetDiagnostics() 832679"];
4028 [label="param GetDiagnostics(CancellationToken cancellationToken = default) 832680"];
4029 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 832681"];
4030 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 832682"];
4031 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 832683"];
4032 [label="GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken) 832684"];
4033 [label="param GetDiagnostics(CompilationStage stage) 832685"];
4034 [label="param GetDiagnostics(bool includeEarlierStages) 832686"];
4035 [label="param GetDiagnostics(CancellationToken cancellationToken) 832687"];
4036 [label="var diagnostics = DiagnosticBag.GetInstance(); 832688"];
4037 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 832689"];
4038 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 832690"];
4039 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 832691"];
4040 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 832692"];
4041 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 832693"];
4042 [label="param GetDiagnostics(CompilationStage stage) 832694"];
4043 [label="param GetDiagnostics(bool includeEarlierStages) 832695"];
4044 [label="param GetDiagnostics(DiagnosticBag diagnostics) 832696"];
4045 [label="param GetDiagnostics(CancellationToken cancellationToken = default) 832697"];
4046 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 832698"];
4047 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 832699"];
4048 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 832700"];
4049 [label="this.SyntaxTrees 832701"];
4050 [label="_syntaxAndDeclarations.GetLazyState() 832702"];
4051 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 832703"];
4052 [label="this.Options 832704"];
4053 [label="param AppendLoadDirectiveDiagnostics(DiagnosticBag builder) 832705"];
4054 [label="param AppendLoadDirectiveDiagnostics(Func<IEnumerable<Diagnostic>, IEnumerable<Diagnostic>>? locationFilterOpt = null) 832706"];
4055 [label="var parseOptionsReported = new HashSet<ParseOptions>(); 832707"];
4056 [label="if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    } 832708"];
4057 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 832709"];
4058 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 832710"];
4059 [label="CheckAssemblyName(builder); 832711"];
4060 [label="CheckAssemblyName(builder); 832712"];
4061 [label="Options 832713"];
4062 [label="Options 832714"];
4063 [label="get\n            {\n                return _options;\n            } 832715"];
4064 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 832716"];
4065 [label="GetBoundReferenceManager() 832717"];
4066 [label="Debug.Assert(_lazyAssemblySymbol is object); 832718"];
4067 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 832719"];
4068 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 832720"];
4069 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 832721"];
4070 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 832722"];
4071 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 832723"];
4072 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 832724"];
4073 [label="param GetSourceDeclarationDiagnostics(CancellationToken cancellationToken = default) 832725"];
4074 [label="GlobalImports 832726"];
4075 [label="_globalImports.Value 832727"];
4076 [label="Imports.FromGlobalUsings(this) 832728"];
4077 [label="GlobalImports.Complete(cancellationToken); 832729"];
4078 [label="SourceLocation? location = null; 832730"];
4079 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 832731"];
4080 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 832732"];
4081 [label="Assembly 832733"];
4082 [label="SourceAssembly 832734"];
4083 [label="GetBoundReferenceManager() 832735"];
4084 [label="param GetBoundReferenceManager(this) 832736"];
4085 [label="GetBoundReferenceManager(); 832737"];
4086 [label="Assembly.ForceComplete(location, cancellationToken); 832738"];
4087 [label="Assembly.ForceComplete(location, cancellationToken); 832739"];
4088 [label="Assembly.ForceComplete(location, cancellationToken); 832740"];
4089 [label="Declarations 832741"];
4090 [label="_syntaxAndDeclarations.GetLazyState() 832742"];
4091 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 832743"];
4092 [label="return Declarations.GetMergedRoot(this); 832744"];
4093 [label="_syntaxAndDeclarations.GetLazyState() 832745"];
4094 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 832746"];
4095 [label="SourceAssembly 832747"];
4096 [label="GetBoundReferenceManager() 832748"];
4097 [label="param GetBoundReferenceManager(this) 832749"];
4098 [label="GetBoundReferenceManager(); 832750"];
4099 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 832751"];
4100 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 832752"];
4101 [label="param SymbolDeclaredEvent(Symbol symbol) 832753"];
4102 [label="param SymbolDeclaredEvent(this) 832754"];
4103 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 832755"];
4104 [label="GetBoundReferenceManager() 832756"];
4105 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 832757"];
4106 [label="param Compare(Symbol x) 832758"];
4107 [label="param Compare(Symbol y) 832759"];
4108 [label="param Compare(this) 832760"];
4109 [label="int comparison; 832761"];
4110 [label="if (x == y)\n            {\n                return 0;\n            } 832762"];
4111 [label="var xSortKey = x.GetLexicalSortKey(); 832763"];
4112 [label="var xSortKey = x.GetLexicalSortKey(); 832764"];
4113 [label="this.ContainsSyntaxTree(tree) 832765"];
4114 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 832766"];
4115 [label="_syntaxAndDeclarations.GetLazyState() 832767"];
4116 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 832768"];
4117 [label="_syntaxAndDeclarations.GetLazyState() 832769"];
4118 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 832770"];
4119 [label="var ySortKey = y.GetLexicalSortKey(); 832771"];
4120 [label="var ySortKey = y.GetLexicalSortKey(); 832772"];
4121 [label="this.ContainsSyntaxTree(tree) 832773"];
4122 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 832774"];
4123 [label="_syntaxAndDeclarations.GetLazyState() 832775"];
4124 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 832776"];
4125 [label="_syntaxAndDeclarations.GetLazyState() 832777"];
4126 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 832778"];
4127 [label="Debug.Assert((object)x.DeclaringCompilation == y.DeclaringCompilation); 832779"];
4128 [label="comparison = LexicalSortKey.Compare(xSortKey, ySortKey); 832780"];
4129 [label="comparison = LexicalSortKey.Compare(xSortKey, ySortKey); 832781"];
4130 [label="if (comparison != 0)\n            {\n                return comparison;\n            } 832782"];
4131 [label="if (comparison != 0)\n            {\n                return comparison;\n            } 832783"];
4132 [label="return comparison; 832784"];
4133 [label="Debug.Assert((object)x.DeclaringCompilation == y.DeclaringCompilation); 832785"];
4134 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 832786"];
4135 [label="NamedTypeSymbol result; 832787"];
4136 [label="GetBoundReferenceManager() 832788"];
4137 [label="GetBoundReferenceManager(); 832789"];
4138 [label="Debug.Assert(result.SpecialType == specialType); 832790"];
4139 [label="Debug.Assert(symbol.IsDefinition); 832791"];
4140 [label="SourceModule 832792"];
4141 [label="Assembly 832793"];
4142 [label="SourceAssembly 832794"];
4143 [label="GetBoundReferenceManager() 832795"];
4144 [label="param GetBoundReferenceManager(this) 832796"];
4145 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 832797"];
4146 [label="return _referenceManager; 832798"];
4147 [label="GetBoundReferenceManager(); 832799"];
4148 [label="return Assembly.Modules[0]; 832800"];
4149 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 832801"];
4150 [label="EmitNullablePublicOnly 832802"];
4151 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 832803"];
4152 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 832804"];
4153 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 832805"];
4154 [label="_declarationDiagnosticsFrozen = true; 832806"];
4155 [label="_needsGeneratedAttributes_IsFrozen = true; 832807"];
4156 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 832808"];
4157 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 832809"];
4158 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 832810"];
4159 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 832811"];
4160 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 832812"];
4161 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 832813"];
4162 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 832814"];
4163 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 832815"];
4164 [label="param GetClsComplianceDiagnostics(CancellationToken cancellationToken) 832816"];
4165 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 832817"];
4166 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 832818"];
4167 [label="param CheckCompliance(DiagnosticBag diagnostics) 832819"];
4168 [label="System.Diagnostics.Debug.Assert(symbol is SourceAssemblySymbol); 832820"];
4169 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 832821"];
4170 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 832822"];
4171 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 832823"];
4172 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 832824"];
4173 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 832825"];
4174 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 832826"];
4175 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 832827"];
4176 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 832828"];
4177 [label="Location ignoredLocation; 832829"];
4178 [label="param GetDeclaredCompliance(out Location attributeLocation) 832830"];
4179 [label="param GetDeclaredCompliance(this) 832831"];
4180 [label="attributeLocation = null; 832832"];
4181 [label="if (assemblyCompliance == Compliance.DeclaredFalse)\n            {\n                // Our interpretation of an assembly-level CLSCompliant attribute is as follows:\n                //   1) If true, then perform all CLS checks.\n                //   2) If false, then perform no CLS checks (dev11 still performs a few, mostly around\n                //      meaningless attributes).  Our interpretation is that the user ultimately wants\n                //      his code to be CLS-compliant, but is temporarily disabling the checks (e.g. during\n                //      refactoring/prototyping).\n                //   3) If absent, the perform all CLS checks.  Our interpretation is that - in the\n                //      absence of an assembly-level attribute - any CLS problems within the compilation\n                //      indicate that the user was trying to do something but didn't know how.  It would\n                //      be nice if the most common case (i.e. this one) was the cheapest, but we don't\n                //      want to confuse novice users.\n                return;\n            } 832833"];
4182 [label="bool assemblyComplianceValue = IsTrue(assemblyCompliance); 832834"];
4183 [label="IsTrue(assemblyCompliance) 832835"];
4184 [label="param IsTrue(Compliance compliance) 832836"];
4185 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 832837"];
4186 [label="return false; 832838"];
4187 [label="Location attributeLocation; 832839"];
4188 [label="param GetDeclaredCompliance(out Location attributeLocation) 832840"];
4189 [label="param GetDeclaredCompliance(this) 832841"];
4190 [label="attributeLocation = null; 832842"];
4191 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 832843"];
4192 [label="i == 0 832844"];
4193 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 832845"];
4194 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 832846"];
4195 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 832847"];
4196 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 832848"];
4197 [label="if (moduleDeclaredCompliance.HasValue)\n                {\n                    if (warningLocation != null)\n                    {\n                        if (!IsDeclared(assemblyCompliance))\n                        {\n                            // This is not useful on non-source modules, but dev11 reports it anyway.\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules, warningLocation);\n                        }\n                        else if (assemblyComplianceValue != moduleDeclaredCompliance.GetValueOrDefault())\n                        {\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules2, warningLocation);\n                        }\n                    }\n                }\n                else if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 832849"];
4198 [label="if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 832850"];
4199 [label="if (assemblyComplianceValue)\n            {\n                CheckForAttributeWithArrayArgument(symbol);\n            } 832851"];
4200 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 832852"];
4201 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 832853"];
4202 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 832854"];
4203 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 832855"];
4204 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 832856"];
4205 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 832857"];
4206 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 832858"];
4207 [label="System.Diagnostics.Debug.Assert(symbol.Kind != SymbolKind.Assembly); 832859"];
4208 [label="System.Diagnostics.Debug.Assert((object)containing != null); 832860"];
4209 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 832861"];
4210 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 832862"];
4211 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 832863"];
4212 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 832864"];
4213 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 832865"];
4214 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 832866"];
4215 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 832867"];
4216 [label="return compliance; 832868"];
4217 [label="IsTrue(GetInheritedCompliance(symbol)) 832869"];
4218 [label="param IsTrue(Compliance compliance) 832870"];
4219 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 832871"];
4220 [label="return false; 832872"];
4221 [label="IsTrue(GetDeclaredOrInheritedCompliance(sourceModule)) 832873"];
4222 [label="param IsTrue(Compliance compliance) 832874"];
4223 [label="if (DoNotVisit(symbol)) return; 832875"];
4224 [label="DoNotVisit(symbol) 832876"];
4225 [label="param DoNotVisit(Symbol symbol) 832877"];
4226 [label="param DoNotVisit(this) 832878"];
4227 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                return false;\n            } 832879"];
4228 [label="return false; 832880"];
4229 [label="IsTrue(GetDeclaredOrInheritedCompliance(symbol)) 832881"];
4230 [label="param IsTrue(Compliance compliance) 832882"];
4231 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 832883"];
4232 [label="return false; 832884"];
4233 [label="if (tasks == null)\n            {\n                return;\n            } 832885"];
4234 [label="if (tasks == null)\n            {\n                return;\n            } 832886"];
4235 [label="checker.WaitForWorkers(); 832887"];
4236 [label="foreach (Diagnostic diag in queue)\n            {\n                diagnostics.Add(diag);\n            } 832888"];
4237 [label="foreach (Diagnostic diag in queue)\n            {\n                diagnostics.Add(diag);\n            } 832889"];
4238 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 832890"];
4239 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 832891"];
4240 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 832892"];
4241 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 832893"];
4242 [label="var methodBodyDiagnostics = DiagnosticBag.GetInstance(); 832894"];
4243 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 832895"];
4244 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 832896"];
4245 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken) 832897"];
4246 [label="param GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics) 832898"];
4247 [label="param GetDiagnosticsForAllMethodBodies(CancellationToken cancellationToken) 832899"];
4248 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 832900"];
4249 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 832901"];
4250 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 832902"];
4251 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken) 832903"];
4252 [label="param CompileMethodBodies(PEModuleBuilder moduleBeingBuiltOpt) 832904"];
4253 [label="param CompileMethodBodies(bool emittingPdb) 832905"];
4254 [label="param CompileMethodBodies(bool emitTestCoverageData) 832906"];
4255 [label="param CompileMethodBodies(bool hasDeclarationErrors) 832907"];
4256 [label="param CompileMethodBodies(DiagnosticBag diagnostics) 832908"];
4257 [label="param CompileMethodBodies(Predicate<Symbol> filterOpt) 832909"];
4258 [label="param CompileMethodBodies(CancellationToken cancellationToken) 832910"];
4259 [label="Debug.Assert(compilation != null); 832911"];
4260 [label="Debug.Assert(compilation != null); 832912"];
4261 [label="Debug.Assert(diagnostics != null); 832913"];
4262 [label="Debug.Assert(diagnostics != null); 832914"];
4263 [label="compilation.PreviousSubmission 832915"];
4264 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 832916"];
4265 [label="ScriptCompilationInfo 832917"];
4266 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 832918"];
4267 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 832919"];
4268 [label="MethodSymbol entryPoint = null; 832920"];
4269 [label="if (filterOpt is null)\n            {\n                entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken);\n            } 832921"];
4270 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 832922"];
4271 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 832923"];
4272 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 832924"];
4273 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 832925"];
4274 [label="GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken) 832926"];
4275 [label="param GetEntryPoint(PEModuleBuilder moduleBeingBuilt) 832927"];
4276 [label="param GetEntryPoint(bool hasDeclarationErrors) 832928"];
4277 [label="param GetEntryPoint(DiagnosticBag diagnostics) 832929"];
4278 [label="param GetEntryPoint(CancellationToken cancellationToken) 832930"];
4279 [label="var entryPointAndDiagnostics = compilation.GetEntryPointAndDiagnostics(cancellationToken); 832931"];
4280 [label="compilation.GetEntryPointAndDiagnostics(cancellationToken) 832932"];
4281 [label="param GetEntryPointAndDiagnostics(CancellationToken cancellationToken) 832933"];
4282 [label="if (_lazyEntryPoint == null)\n            {\n                EntryPoint? entryPoint;\n                var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this);\n\n                if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                }\n\n                Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null);\n            } 832934"];
4283 [label="EntryPoint? entryPoint; 832935"];
4284 [label="GetBoundReferenceManager() 832936"];
4285 [label="GetBoundReferenceManager(); 832937"];
4286 [label="Debug.Assert(!entryPointAndDiagnostics.Diagnostics.IsDefault); 832938"];
4287 [label="if ((object)entryPoint == null)\n            {\n                return null;\n            } 832939"];
4288 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 832940"];
4289 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 832941"];
4290 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 832942"];
4291 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 832943"];
4292 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 832944"];
4293 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 832945"];
4294 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 832946"];
4295 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 832947"];
4296 [label="new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken) 832948"];
4297 [label="param MethodCompiler(PEModuleBuilder moduleBeingBuiltOpt) 832949"];
4298 [label="param MethodCompiler(bool emittingPdb) 832950"];
4299 [label="param MethodCompiler(bool emitTestCoverageData) 832951"];
4300 [label="param MethodCompiler(bool hasDeclarationErrors) 832952"];
4301 [label="param MethodCompiler(DiagnosticBag diagnostics) 832953"];
4302 [label="param MethodCompiler(Predicate<Symbol> filterOpt) 832954"];
4303 [label="param MethodCompiler(CancellationToken cancellationToken) 832955"];
4304 [label="param MethodCompiler(this) 832956"];
4305 [label="param MethodCompiler(this) 832957"];
4306 [label="_compilation 832958"];
4307 [label="_emittingPdb 832959"];
4308 [label="_emitTestCoverageData 832960"];
4309 [label="_diagnostics 832961"];
4310 [label="_hasDeclarationErrors 832962"];
4311 [label="_moduleBeingBuiltOpt 832963"];
4312 [label="_filterOpt 832964"];
4313 [label="_debugDocumentProvider 832965"];
4314 [label="_entryPointOpt 832966"];
4315 [label="_compilerTasks 832967"];
4316 [label="_globalHasErrors 832968"];
4317 [label="Debug.Assert(compilation != null); 832969"];
4318 [label="Debug.Assert(compilation != null); 832970"];
4319 [label="Debug.Assert(diagnostics != null); 832971"];
4320 [label="Debug.Assert(diagnostics != null); 832972"];
4321 [label="_moduleBeingBuiltOpt 832973"];
4322 [label="_emittingPdb 832974"];
4323 [label="_cancellationToken 832975"];
4324 [label="_diagnostics 832976"];
4325 [label="_filterOpt 832977"];
4326 [label="_hasDeclarationErrors 832978"];
4327 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 832979"];
4328 [label="SetGlobalErrorIfTrue(hasDeclarationErrors) 832980"];
4329 [label="param SetGlobalErrorIfTrue(bool arg) 832981"];
4330 [label="param SetGlobalErrorIfTrue(this) 832982"];
4331 [label="if (arg)\n            {\n                _globalHasErrors = true;\n            } 832983"];
4332 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 832984"];
4333 [label="if (emittingPdb || emitTestCoverageData)\n            {\n                _debugDocumentProvider = (path, basePath) => moduleBeingBuiltOpt.DebugDocumentsBuilder.GetOrAddDebugDocument(path, basePath, CreateDebugDocumentForFile);\n            } 832985"];
4334 [label="_emitTestCoverageData 832986"];
4335 [label="compilation.Options 832987"];
4336 [label="compilation.SourceModule 832988"];
4337 [label="Assembly 832989"];
4338 [label="SourceAssembly 832990"];
4339 [label="GetBoundReferenceManager() 832991"];
4340 [label="param GetBoundReferenceManager(this) 832992"];
4341 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 832993"];
4342 [label="return _referenceManager; 832994"];
4343 [label="GetBoundReferenceManager(); 832995"];
4344 [label="return Assembly.Modules[0]; 832996"];
4345 [label="methodCompiler.CompileNamespace(compilation.SourceModule.GlobalNamespace) 832997"];
4346 [label="param CompileNamespace(this) 832998"];
4347 [label="param VisitNamedType(NamedTypeSymbol symbol) 832999"];
4348 [label="param VisitNamedType(TypeCompilationState arg) 833000"];
4349 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 833001"];
4350 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 833002"];
4351 [label="PassesFilter(_filterOpt, symbol) 833003"];
4352 [label="param PassesFilter(Predicate<Symbol> filterOpt) 833004"];
4353 [label="param PassesFilter(Symbol symbol) 833005"];
4354 [label="return (filterOpt == null) || filterOpt(symbol); 833006"];
4355 [label="return (filterOpt == null) || filterOpt(symbol); 833007"];
4356 [label="arg = null; 833008"];
4357 [label="param CompileNamedTypeAsync(NamedTypeSymbol symbol) 833009"];
4358 [label="param VisitNamedType(TypeCompilationState arg) 833010"];
4359 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 833011"];
4360 [label="PassesFilter(_filterOpt, symbol) 833012"];
4361 [label="param PassesFilter(Predicate<Symbol> filterOpt) 833013"];
4362 [label="param PassesFilter(Symbol symbol) 833014"];
4363 [label="return (filterOpt == null) || filterOpt(symbol); 833015"];
4364 [label="return (filterOpt == null) || filterOpt(symbol); 833016"];
4365 [label="arg = null; 833017"];
4366 [label="param CompileNamedTypeAsync(NamedTypeSymbol symbol) 833018"];
4367 [label="methodCompiler.CompileNamespace(compilation.SourceModule.GlobalNamespace); 833019"];
4368 [label="methodCompiler.WaitForWorkers() 833020"];
4369 [label="param WaitForWorkers(this) 833021"];
4370 [label="if (tasks == null)\n            {\n                return;\n            } 833022"];
4371 [label="if (tasks == null)\n            {\n                return;\n            } 833023"];
4372 [label="Task curTask; 833024"];
4373 [label="while (tasks.TryPop(out curTask))\n            {\n                curTask.GetAwaiter().GetResult();\n            } 833025"];
4374 [label="methodCompiler.WaitForWorkers(); 833026"];
4375 [label="if (moduleBeingBuiltOpt != null)\n            {\n                var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics);\n\n                var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics);\n\n                // By this time we have processed all types reachable from module's global namespace\n                compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics);\n                methodCompiler.WaitForWorkers();\n\n                var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass;\n                if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                }\n            } 833027"];
4376 [label="if (moduleBeingBuiltOpt != null)\n            {\n                var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics);\n\n                var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics);\n\n                // By this time we have processed all types reachable from module's global namespace\n                compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics);\n                methodCompiler.WaitForWorkers();\n\n                var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass;\n                if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                }\n            } 833028"];
4377 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 833029"];
4378 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 833030"];
4379 [label="compilation.AdditionalCodegenWarnings 833031"];
4380 [label="if (filterOpt == null)\n            {\n                WarnUnusedFields(compilation, diagnostics, cancellationToken);\n\n                if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                }\n            } 833032"];
4381 [label="if (filterOpt == null)\n            {\n                WarnUnusedFields(compilation, diagnostics, cancellationToken);\n\n                if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                }\n            } 833033"];
4382 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 833034"];
4383 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 833035"];
4384 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken) 833036"];
4385 [label="param WarnUnusedFields(DiagnosticBag diagnostics) 833037"];
4386 [label="param WarnUnusedFields(CancellationToken cancellationToken) 833038"];
4387 [label="compilation.Assembly 833039"];
4388 [label="SourceAssembly 833040"];
4389 [label="GetBoundReferenceManager() 833041"];
4390 [label="param GetBoundReferenceManager(this) 833042"];
4391 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 833043"];
4392 [label="return _referenceManager; 833044"];
4393 [label="GetBoundReferenceManager(); 833045"];
4394 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 833046"];
4395 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 833047"];
4396 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 833048"];
4397 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 833049"];
4398 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 833050"];
4399 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 833051"];
4400 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 833052"];
4401 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 833053"];
4402 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken) 833054"];
4403 [label="param WriteDocumentationCommentXml(string? assemblyName) 833055"];
4404 [label="param WriteDocumentationCommentXml(Stream? xmlDocStream) 833056"];
4405 [label="param WriteDocumentationCommentXml(DiagnosticBag diagnostics) 833057"];
4406 [label="param WriteDocumentationCommentXml(CancellationToken cancellationToken) 833058"];
4407 [label="param WriteDocumentationCommentXml(SyntaxTree? filterTree = null) 833059"];
4408 [label="param WriteDocumentationCommentXml(TextSpan? filterSpanWithinTree = null) 833060"];
4409 [label="StreamWriter writer = null; 833061"];
4410 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 833062"];
4411 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 833063"];
4412 [label="compilation.SourceAssembly 833064"];
4413 [label="GetBoundReferenceManager() 833065"];
4414 [label="param GetBoundReferenceManager(this) 833066"];
4415 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 833067"];
4416 [label="return _referenceManager; 833068"];
4417 [label="GetBoundReferenceManager(); 833069"];
4418 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 833070"];
4419 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 833071"];
4420 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 833072"];
4421 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 833073"];
4422 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 833074"];
4423 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 833075"];
4424 [label="new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken) 833076"];
4425 [label="param DocumentationCommentCompiler(TextWriter writer) 833077"];
4426 [label="param DocumentationCommentCompiler(SyntaxTree filterTree) 833078"];
4427 [label="param DocumentationCommentCompiler(TextSpan? filterSpanWithinTree) 833079"];
4428 [label="param DocumentationCommentCompiler(bool processIncludes) 833080"];
4429 [label="param DocumentationCommentCompiler(bool isForSingleSymbol) 833081"];
4430 [label="param DocumentationCommentCompiler(DiagnosticBag diagnostics) 833082"];
4431 [label="param DocumentationCommentCompiler(CancellationToken cancellationToken) 833083"];
4432 [label="param DocumentationCommentCompiler(this) 833084"];
4433 [label="param DocumentationCommentCompiler(this) 833085"];
4434 [label="_assemblyName 833086"];
4435 [label="_compilation 833087"];
4436 [label="_writer 833088"];
4437 [label="_filterTree 833089"];
4438 [label="_filterSpanWithinTree 833090"];
4439 [label="_processIncludes 833091"];
4440 [label="_isForSingleSymbol 833092"];
4441 [label="_diagnostics 833093"];
4442 [label="_lazyComparer 833094"];
4443 [label="_includedFileCache 833095"];
4444 [label="_indentDepth 833096"];
4445 [label="_temporaryStringBuilders 833097"];
4446 [label="_writer 833098"];
4447 [label="_filterTree 833099"];
4448 [label="_filterSpanWithinTree 833100"];
4449 [label="_processIncludes 833101"];
4450 [label="_isForSingleSymbol 833102"];
4451 [label="_diagnostics 833103"];
4452 [label="_cancellationToken 833104"];
4453 [label="compilation.SourceAssembly 833105"];
4454 [label="GetBoundReferenceManager() 833106"];
4455 [label="param GetBoundReferenceManager(this) 833107"];
4456 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 833108"];
4457 [label="return _referenceManager; 833109"];
4458 [label="GetBoundReferenceManager(); 833110"];
4459 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 833111"];
4460 [label="Debug.Assert(_assemblyName != null); 833112"];
4461 [label="WriteLine('<?xml version=\\'1.0\\'?>'); 833113"];
4462 [label="WriteLine('<?xml version=\\'1.0\\'?>') 833114"];
4463 [label="param WriteLine(string message) 833115"];
4464 [label="param WriteLine(this) 833116"];
4465 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833117"];
4466 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833118"];
4467 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833119"];
4468 [label="WriteLine('<doc>'); 833120"];
4469 [label="WriteLine('<doc>') 833121"];
4470 [label="param WriteLine(string message) 833122"];
4471 [label="param WriteLine(this) 833123"];
4472 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833124"];
4473 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833125"];
4474 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833126"];
4475 [label="Indent(); 833127"];
4476 [label="WriteLine('<assembly>'); 833128"];
4477 [label="WriteLine('<assembly>') 833129"];
4478 [label="param WriteLine(string message) 833130"];
4479 [label="param WriteLine(this) 833131"];
4480 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833132"];
4481 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833133"];
4482 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833134"];
4483 [label="Indent(); 833135"];
4484 [label="WriteLine('<name>{0}</name>', _assemblyName); 833136"];
4485 [label="WriteLine('<name>{0}</name>', _assemblyName) 833137"];
4486 [label="WriteLine('<name>{0}</name>', _assemblyName) 833138"];
4487 [label="param WriteLine(string format) 833139"];
4488 [label="param WriteLine(params object[] args) 833140"];
4489 [label="param WriteLine(this) 833141"];
4490 [label="WriteLine(string.Format(format, args)); 833142"];
4491 [label="WriteLine(string.Format(format, args)); 833143"];
4492 [label="WriteLine(string.Format(format, args)); 833144"];
4493 [label="WriteLine(string.Format(format, args)) 833145"];
4494 [label="param WriteLine(string message) 833146"];
4495 [label="param WriteLine(this) 833147"];
4496 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833148"];
4497 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833149"];
4498 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833150"];
4499 [label="WriteLine(string.Format(format, args)); 833151"];
4500 [label="Debug.Assert(_indentDepth >= 0); 833152"];
4501 [label="Unindent(); 833153"];
4502 [label="WriteLine('</assembly>'); 833154"];
4503 [label="WriteLine('</assembly>') 833155"];
4504 [label="param WriteLine(string message) 833156"];
4505 [label="param WriteLine(this) 833157"];
4506 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833158"];
4507 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833159"];
4508 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833160"];
4509 [label="WriteLine('<members>'); 833161"];
4510 [label="WriteLine('<members>') 833162"];
4511 [label="param WriteLine(string message) 833163"];
4512 [label="param WriteLine(this) 833164"];
4513 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833165"];
4514 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833166"];
4515 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833167"];
4516 [label="Indent(); 833168"];
4517 [label="Debug.Assert(!_isForSingleSymbol); 833169"];
4518 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 833170"];
4519 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 833171"];
4520 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 833172"];
4521 [label="DocumentationMode maxDocumentationMode; 833173"];
4522 [label="ImmutableArray<DocumentationCommentTriviaSyntax> docCommentNodes; 833174"];
4523 [label="docCommentNodes 833175"];
4524 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 833176"];
4525 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 833177"];
4526 [label="maxDocumentationMode = DocumentationMode.None; 833178"];
4527 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 833179"];
4528 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 833180"];
4529 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 833181"];
4530 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 833182"];
4531 [label="currDocumentationMode > maxDocumentationMode 833183"];
4532 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 833184"];
4533 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 833185"];
4534 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 833186"];
4535 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 833187"];
4536 [label="return true; 833188"];
4537 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 833189"];
4538 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 833190"];
4539 [label="return; 833191"];
4540 [label="_cancellationToken.ThrowIfCancellationRequested(); 833192"];
4541 [label="member.Accept(this); 833193"];
4542 [label="member.Accept(this); 833194"];
4543 [label="return; 833195"];
4544 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 833196"];
4545 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 833197"];
4546 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 833198"];
4547 [label="DocumentationMode maxDocumentationMode; 833199"];
4548 [label="ImmutableArray<DocumentationCommentTriviaSyntax> docCommentNodes; 833200"];
4549 [label="docCommentNodes 833201"];
4550 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 833202"];
4551 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 833203"];
4552 [label="maxDocumentationMode = DocumentationMode.None; 833204"];
4553 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 833205"];
4554 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 833206"];
4555 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 833207"];
4556 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 833208"];
4557 [label="currDocumentationMode > maxDocumentationMode 833209"];
4558 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 833210"];
4559 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 833211"];
4560 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 833212"];
4561 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 833213"];
4562 [label="return true; 833214"];
4563 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 833215"];
4564 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 833216"];
4565 [label="return; 833217"];
4566 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 833218"];
4567 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 833219"];
4568 [label="currDocumentationMode > maxDocumentationMode 833220"];
4569 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 833221"];
4570 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 833222"];
4571 [label="return; 833223"];
4572 [label="Debug.Assert(_indentDepth >= 0); 833224"];
4573 [label="Unindent(); 833225"];
4574 [label="WriteLine('</members>'); 833226"];
4575 [label="WriteLine('</members>') 833227"];
4576 [label="param WriteLine(string message) 833228"];
4577 [label="param WriteLine(this) 833229"];
4578 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833230"];
4579 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833231"];
4580 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833232"];
4581 [label="Unindent(); 833233"];
4582 [label="WriteLine('</doc>'); 833234"];
4583 [label="WriteLine('</doc>') 833235"];
4584 [label="param WriteLine(string message) 833236"];
4585 [label="param WriteLine(this) 833237"];
4586 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833238"];
4587 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833239"];
4588 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 833240"];
4589 [label="Debug.Assert(compiler._indentDepth == 0); 833241"];
4590 [label="Debug.Assert(compiler._indentDepth == 0); 833242"];
4591 [label="writer?.Flush(); 833243"];
4592 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 833244"];
4593 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 833245"];
4594 [label="compilation.SyntaxTrees 833246"];
4595 [label="_syntaxAndDeclarations.GetLazyState() 833247"];
4596 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 833248"];
4597 [label="param ReportUnprocessed(TextSpan? filterSpanWithinTree) 833249"];
4598 [label="param ReportUnprocessed(DiagnosticBag diagnostics) 833250"];
4599 [label="param ReportUnprocessed(CancellationToken cancellationToken) 833251"];
4600 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 833252"];
4601 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 833253"];
4602 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 833254"];
4603 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken) 833255"];
4604 [label="param ReportUnusedImports(SyntaxTree? filterTree) 833256"];
4605 [label="param ReportUnusedImports(DiagnosticBag diagnostics) 833257"];
4606 [label="param ReportUnusedImports(CancellationToken cancellationToken) 833258"];
4607 [label="param ReportUnusedImports(this) 833259"];
4608 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 833260"];
4609 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 833261"];
4610 [label="CompleteTrees(filterTree); 833262"];
4611 [label="CompleteTrees(filterTree) 833263"];
4612 [label="param CompleteTrees(SyntaxTree? filterTree) 833264"];
4613 [label="param CompleteTrees(this) 833265"];
4614 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 833266"];
4615 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 833267"];
4616 [label="CompleteTrees(filterTree); 833268"];
4617 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 833269"];
4618 [label="builder.AddRangeAndFree(methodBodyDiagnostics); 833270"];
4619 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 833271"];
4620 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 833272"];
4621 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 833273"];
4622 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 833274"];
4623 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 833275"];
4624 [label="diagnostics.Verify(expected) 833276"];
4625 [label="Verify((IEnumerable<Diagnostic>)actual, expected) 833277"];
4626 [label="Verify(actual, expected, errorCodeOnly: false); 833278"];
4627 [label="Verify(actual, expected, errorCodeOnly: false) 833279"];
4628 [label="param Verify(bool errorCodeOnly) 833280"];
4629 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 833281"];
4630 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 833282"];
4631 [label="foreach (var d in expected)\n            {\n                int index = unmatched.IndexOf(d);\n                if (index > -1)\n                {\n                    unmatched.RemoveAt(index);\n                }\n                else\n                {\n                    CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n                }\n            } 833283"];
4632 [label="foreach (var d in expected)\n            {\n                int index = unmatched.IndexOf(d);\n                if (index > -1)\n                {\n                    unmatched.RemoveAt(index);\n                }\n                else\n                {\n                    CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n                }\n            } 833284"];
4633 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 833285"];
4634 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 833286"];
4635 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 833287"];
4636 [label="DiagnosticDescription.GetAssertText(expected, actual) 833288"];
4637 [label="param GetAssertText(DiagnosticDescription[] expected) 833289"];
4638 [label="const int CSharp = 1; 833290"];
4639 [label="const int VisualBasic = 2; 833291"];
4640 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 833292"];
4641 [label="actual.Any() && actual.First() is CSDiagnostic 833293"];
4642 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 833294"];
4643 [label="var includeDiagnosticMessagesAsComments = (language == CSharp); 833295"];
4644 [label="int indentDepth = (language == CSharp) ? 4 : 1; 833296"];
4645 [label="(language == CSharp) 833297"];
4646 [label="var includeDefaultSeverity = expected.Any() && expected.All(d => d.DefaultSeverity != null); 833298"];
4647 [label="var includeDefaultSeverity = expected.Any() && expected.All(d => d.DefaultSeverity != null); 833299"];
4648 [label="var includeEffectiveSeverity = expected.Any() && expected.All(d => d.EffectiveSeverity != null); 833300"];
4649 [label="var includeEffectiveSeverity = expected.Any() && expected.All(d => d.EffectiveSeverity != null); 833301"];
4650 [label="IsSortedOrEmpty(expected) 833302"];
4651 [label="param IsSortedOrEmpty(DiagnosticDescription[] diagnostics) 833303"];
4652 [label="var comparer = LinePositionComparer.Instance; 833304"];
4653 [label="DiagnosticDescription last = null; 833305"];
4654 [label="foreach (var diagnostic in diagnostics)\n            {\n                if (diagnostic._startPosition == null)\n                {\n                    return false;\n                }\n                if (last != null && comparer.Compare(last._startPosition, diagnostic._startPosition) > 0)\n                {\n                    return false;\n                }\n                last = diagnostic;\n            } 833306"];
4655 [label="foreach (var diagnostic in diagnostics)\n            {\n                if (diagnostic._startPosition == null)\n                {\n                    return false;\n                }\n                if (last != null && comparer.Compare(last._startPosition, diagnostic._startPosition) > 0)\n                {\n                    return false;\n                }\n                last = diagnostic;\n            } 833307"];
4656 [label="return true; 833308"];
4657 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 833309"];
4658 [label="Sort(actual) 833310"];
4659 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 833311"];
4660 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 833312"];
4661 [label="var assertText = new StringBuilder(); 833313"];
4662 [label="assertText.AppendLine(); 833314"];
4663 [label="int i; 833315"];
4664 [label="assertText.AppendLine('Expected:'); 833316"];
4665 [label="assertText.AppendLine('Expected:'); 833317"];
4666 [label="var expectedText = ArrayBuilder<string>.GetInstance(); 833318"];
4667 [label="foreach (var d in expected)\n            {\n                expectedText.Add(GetDiagnosticDescription(d, indentDepth));\n            } 833319"];
4668 [label="foreach (var d in expected)\n            {\n                expectedText.Add(GetDiagnosticDescription(d, indentDepth));\n            } 833320"];
4669 [label="GetCommaSeparatedLines(assertText, expectedText); 833321"];
4670 [label="GetCommaSeparatedLines(assertText, expectedText); 833322"];
4671 [label="GetCommaSeparatedLines(assertText, expectedText) 833323"];
4672 [label="param GetCommaSeparatedLines(StringBuilder sb) 833324"];
4673 [label="param GetCommaSeparatedLines(ArrayBuilder<string> lines) 833325"];
4674 [label="int n = lines.Count; 833326"];
4675 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 833327"];
4676 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 833328"];
4677 [label="GetCommaSeparatedLines(assertText, expectedText); 833329"];
4678 [label="assertText.AppendLine('Actual:'); 833330"];
4679 [label="assertText.AppendLine('Actual:'); 833331"];
4680 [label="var actualText = ArrayBuilder<string>.GetInstance(); 833332"];
4681 [label="for (i = 0; e.MoveNext(); i++)\n            {\n                Diagnostic d = e.Current;\n                string message = d.ToString();\n                if (Regex.Match(message, @'{\\d+}').Success)\n                {\n                    Assert.True(false, 'Diagnostic messages should never contain unsubstituted placeholders.\\n    ' + message);\n                }\n\n                if (i > 0)\n                {\n                    assertText.AppendLine(',');\n                }\n\n                if (includeDiagnosticMessagesAsComments)\n                {\n                    Indent(assertText, indentDepth);\n                    assertText.Append('// ');\n                    assertText.AppendLine(d.ToString());\n                    var l = d.Location;\n                    if (l.IsInSource)\n                    {\n                        Indent(assertText, indentDepth);\n                        assertText.Append('// ');\n                        assertText.AppendLine(l.SourceTree.GetText().Lines.GetLineFromPosition(l.SourceSpan.Start).ToString());\n                    }\n                }\n\n                var description = new DiagnosticDescription(d, errorCodeOnly: false, includeDefaultSeverity, includeEffectiveSeverity);\n                var diffDescription = description;\n                var idx = Array.IndexOf(expected, description);\n                if (idx != -1)\n                {\n                    diffDescription = expected[idx];\n                }\n                assertText.Append(GetDiagnosticDescription(description, indentDepth));\n                actualText.Add(GetDiagnosticDescription(diffDescription, indentDepth));\n            } 833333"];
4682 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 833334"];
4683 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 833335"];
4684 [label="assertText.AppendLine('Diff:'); 833336"];
4685 [label="assertText.AppendLine('Diff:'); 833337"];
4686 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 833338"];
4687 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 833339"];
4688 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 833340"];
4689 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 833341"];
4690 [label="DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine) 833342"];
4691 [label="param DiffReport(IEnumerable<T> expected) 833343"];
4692 [label="param DiffReport(IEnumerable<T> actual) 833344"];
4693 [label="param DiffReport(string separator) 833345"];
4694 [label="param DiffReport(IEqualityComparer<T> comparer = null) 833346"];
4695 [label="param DiffReport(Func<T, string> toString = null) 833347"];
4696 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 833348"];
4697 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 833349"];
4698 [label="(comparer != null) 833350"];
4699 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 833351"];
4700 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 833352"];
4701 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 833353"];
4702 [label="IList<T> expectedList = expected as IList<T> ?? new List<T>(expected); 833354"];
4703 [label="IList<T> actualList = actual as IList<T> ?? new List<T>(actual); 833355"];
4704 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 833356"];
4705 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 833357"];
4706 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 833358"];
4707 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 833359"];
4708 [label="lcs.CalculateDiff(expectedList, actualList, toString) 833360"];
4709 [label="param CalculateDiff(IList<T> sequenceA) 833361"];
4710 [label="param CalculateDiff(IList<T> sequenceB) 833362"];
4711 [label="param CalculateDiff(Func<T, string> toString) 833363"];
4712 [label="param CalculateDiff(this) 833364"];
4713 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 833365"];
4714 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 833366"];
4715 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 833367"];
4716 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 833368"];
4717 [label="GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count) 833369"];
4718 [label="param GetEdits(TSequence sequenceA) 833370"];
4719 [label="param GetEdits(int lengthA) 833371"];
4720 [label="param GetEdits(TSequence sequenceB) 833372"];
4721 [label="param GetEdits(int lengthB) 833373"];
4722 [label="param GetEdits(this) 833374"];
4723 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 833375"];
4724 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 833376"];
4725 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 833377"];
4726 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 833378"];
4727 [label="ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB) 833379"];
4728 [label="param ComputeCostMatrix(TSequence sequenceA) 833380"];
4729 [label="param ComputeCostMatrix(int lengthA) 833381"];
4730 [label="param ComputeCostMatrix(TSequence sequenceB) 833382"];
4731 [label="param ComputeCostMatrix(int lengthB) 833383"];
4732 [label="param ComputeCostMatrix(this) 833384"];
4733 [label="var la = lengthA + 1; 833385"];
4734 [label="var la = lengthA + 1; 833386"];
4735 [label="var lb = lengthB + 1; 833387"];
4736 [label="var lb = lengthB + 1; 833388"];
4737 [label="var d = new int[la, lb]; 833389"];
4738 [label="d[0, 0] = 0; 833390"];
4739 [label="d[0, 0] 833391"];
4740 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 833392"];
4741 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 833393"];
4742 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 833394"];
4743 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 833395"];
4744 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 833396"];
4745 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 833397"];
4746 [label="return d; 833398"];
4747 [label="int i = lengthA; 833399"];
4748 [label="int j = lengthB; 833400"];
4749 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 833401"];
4750 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 833402"];
4751 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 833403"];
4752 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 833404"];
4753 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 833405"];
4754 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 833406"];
4755 [label="param GetEdits(this) 833407"];
4756 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 833408"];
4757 [label="param CalculateDiff(this) 833409"];
4758 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 833410"];
4759 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 833411"];
4760 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 833412"];
4761 [label="actualText.Free(); 833413"];
4762 [label="expectedText.Free(); 833414"];
4763 [label="return assertText.ToString(); 833415"];
4764 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 833416"];
4765 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 833417"];
4766 [label="diagnostics.Verify(expected); 833418"];
4767 [label="VerifyAssemblyIds(c, diagnostics); 833419"];
4768 [label="VerifyAssemblyIds(c, diagnostics); 833420"];
4769 [label="VerifyAssemblyIds(c, diagnostics) 833421"];
4770 [label="param VerifyAssemblyIds(TCompilation c) 833422"];
4771 [label="param VerifyAssemblyIds(ImmutableArray<Diagnostic> diagnostics) 833423"];
4772 [label="foreach (var diagnostic in diagnostics)\n            {\n                // If this is a diagnostic about a missing assembly, make sure that we can get back\n                // an AssemblyIdentity when we query the compiler.  If it's not a diagnostic about\n                // a missing assembly, make sure we get no results back.\n                if (c.IsUnreferencedAssemblyIdentityDiagnosticCode(diagnostic.Code))\n                {\n                    var assemblyIds = c.GetUnreferencedAssemblyIdentities(diagnostic);\n                    CustomAssert.False(assemblyIds.IsEmpty);\n\n                    var diagnosticMessage = diagnostic.GetMessage();\n                    foreach (var id in assemblyIds)\n                    {\n                        CustomAssert.Contains(id.GetDisplayName(), diagnosticMessage);\n                    }\n                }\n                else\n                {\n                    var assemblyIds = c.GetUnreferencedAssemblyIdentities(diagnostic);\n                    CustomAssert.True(assemblyIds.IsEmpty);\n                }\n            } 833424"];
4773 [label="VerifyAssemblyIds(c, diagnostics); 833425"];
4774 [label="return c; 833426"];
4775 [label="validator(comp); 833427"];
4776 [label="if (debugFlag == -1 || debugFlag == 1)\n            {\n                VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(true));\n            } 833428"];
4777 [label="if (debugFlag == -1 || debugFlag == 1)\n            {\n                VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(true));\n            } 833429"];
4778 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(true)); 833430"];
4779 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(true)); 833431"];
4780 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(true)); 833432"];
4781 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(true)); 833433"];
4782 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(true)); 833434"];
4783 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(true)) 833435"];
4784 [label="param VerifyRefAssemblyClient(string lib_cs) 833436"];
4785 [label="param VerifyRefAssemblyClient(string source) 833437"];
4786 [label="param VerifyRefAssemblyClient(Action<CSharpCompilation> validator) 833438"];
4787 [label="param VerifyRefAssemblyClient(EmitOptions emitOptions) 833439"];
4788 [label="GetUniqueName() 833440"];
4789 [label="return Guid.NewGuid().ToString('D'); 833441"];
4790 [label="string name = GetUniqueName(); 833442"];
4791 [label="var libComp = CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name); 833443"];
4792 [label="var libComp = CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name); 833444"];
4793 [label="var libComp = CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name); 833445"];
4794 [label="var libComp = CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name); 833446"];
4795 [label="CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name) 833447"];
4796 [label="param operator(string source) 833448"];
4797 [label="source 833449"];
4798 [label="new CSharpTestSource(source) 833450"];
4799 [label="param CSharpTestSource(object value) 833451"];
4800 [label="param CSharpTestSource(this) 833452"];
4801 [label="Value 833453"];
4802 [label="var libComp = CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name); 833454"];
4803 [label="param CreateCompilation(CSharpTestSource source) 833455"];
4804 [label="param CreateCompilation(IEnumerable<MetadataReference> references = null) 833456"];
4805 [label="param CreateCompilation(CSharpParseOptions parseOptions = null) 833457"];
4806 [label="param CreateCompilation(TargetFramework targetFramework = TargetFramework.Standard) 833458"];
4807 [label="param CreateCompilation(string assemblyName = '') 833459"];
4808 [label="param CreateCompilation(string sourceFileName = '') 833460"];
4809 [label="param CreateCompilation(bool skipUsesIsNullable = false) 833461"];
4810 [label="source 833462"];
4811 [label="targetFramework 833463"];
4812 [label="references 833464"];
4813 [label="TargetFrameworkUtil.GetReferences(targetFramework, references) 833465"];
4814 [label="param GetReferences(TargetFramework tf) 833466"];
4815 [label="param GetReferences(IEnumerable<MetadataReference> additionalReferences) 833467"];
4816 [label="var references = GetReferences(tf); 833468"];
4817 [label="GetReferences(tf) 833469"];
4818 [label="param GetReferences(TargetFramework targetFramework) 833470"];
4819 [label="targetFramework switch\n        {\n            TargetFramework.Empty => ImmutableArray<MetadataReference>.Empty,\n            TargetFramework.Mscorlib40 => Mscorlib40References,\n            TargetFramework.Mscorlib40Extended => Mscorlib40ExtendedReferences,\n            TargetFramework.Mscorlib40AndSystemCore => Mscorlib40andSystemCoreReferences,\n            TargetFramework.Mscorlib40AndVBRuntime => Mscorlib40andVBRuntimeReferences,\n            TargetFramework.Mscorlib45 => Mscorlib45References,\n            TargetFramework.Mscorlib45Extended => Mscorlib45ExtendedReferences,\n            TargetFramework.Mscorlib45AndCSharp => Mscorlib45AndCSharpReferences,\n            TargetFramework.Mscorlib45AndVBRuntime => Mscorlib45AndVBRuntimeReferences,\n            TargetFramework.Mscorlib46 => Mscorlib46References,\n            TargetFramework.Mscorlib46Extended => Mscorlib46ExtendedReferences,\n            TargetFramework.Mscorlib461 => Mscorlib46References,\n            TargetFramework.Mscorlib461Extended => Mscorlib461ExtendedReferences,\n            TargetFramework.NetStandard20 => NetStandard20References,\n            TargetFramework.NetCoreApp => NetCoreAppReferences,\n            TargetFramework.WinRT => WinRTReferences,\n            TargetFramework.Standard => StandardReferences,\n            TargetFramework.StandardLatest => StandardLatestReferences,\n            TargetFramework.StandardAndCSharp => StandardAndCSharpReferences,\n            TargetFramework.StandardAndVBRuntime => StandardAndVBRuntimeReferences,\n            TargetFramework.StandardCompat => StandardCompatReferences,\n            TargetFramework.DefaultVb => DefaultVbReferences,\n            TargetFramework.Minimal => MinimalReferences,\n            TargetFramework.MinimalAsync => MinimalAsyncReferences,\n            _ => throw new InvalidOperationException($'Unexpected target framework {targetFramework}'),\n        } 833471"];
4820 [label="StandardReferences 833472"];
4821 [label="RuntimeUtilities.IsCoreClrRuntime 833473"];
4822 [label="NetStandard20References 833474"];
4823 [label="ImmutableArray.Create<MetadataReference>(NetStandard20.netstandard, NetStandard20.mscorlib, NetStandard20.SystemRuntime, NetStandard20.SystemCore, NetStandard20.SystemDynamicRuntime, NetStandard20.SystemLinq, NetStandard20.SystemLinqExpressions) 833475"];
4824 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 833476"];
4825 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 833477"];
4826 [label="parseOptions 833478"];
4827 [label="assemblyName 833479"];
4828 [label="sourceFileName 833480"];
4829 [label="skipUsesIsNullable 833481"];
4830 [label="CreateEmptyCompilation(source, TargetFrameworkUtil.GetReferences(targetFramework, references), options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable) 833482"];
4831 [label="param CreateEmptyCompilation(CSharpTestSource source) 833483"];
4832 [label="param CreateEmptyCompilation(CSharpParseOptions parseOptions = null) 833484"];
4833 [label="param CreateEmptyCompilation(string assemblyName = '') 833485"];
4834 [label="param CreateEmptyCompilation(string sourceFileName = '') 833486"];
4835 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 833487"];
4836 [label="source 833488"];
4837 [label="parseOptions 833489"];
4838 [label="assemblyName 833490"];
4839 [label="sourceFileName 833491"];
4840 [label="skipUsesIsNullable 833492"];
4841 [label="null 833493"];
4842 [label="experimentalFeature: null 833494"];
4843 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 833495"];
4844 [label="param CreateCompilationCore(CSharpTestSource source) 833496"];
4845 [label="param CreateCompilationCore(CSharpParseOptions parseOptions) 833497"];
4846 [label="param CreateCompilationCore(string assemblyName) 833498"];
4847 [label="param CreateCompilationCore(string sourceFileName) 833499"];
4848 [label="param CreateCompilationCore(bool skipUsesIsNullable) 833500"];
4849 [label="param CreateCompilationCore(MessageID? experimentalFeature) 833501"];
4850 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 833502"];
4851 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 833503"];
4852 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 833504"];
4853 [label="param GetSyntaxTrees(CSharpParseOptions parseOptions) 833505"];
4854 [label="param GetSyntaxTrees(string sourceFileName = '') 833506"];
4855 [label="param GetSyntaxTrees(this) 833507"];
4856 [label="switch (Value)\n            {\n                case string source:\n                    return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) };\n                case string[] sources:\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return CSharpTestBase.Parse(parseOptions, sources);\n                case SyntaxTree tree:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return new[] { tree };\n                case SyntaxTree[] trees:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return trees;\n                case CSharpTestSource[] testSources:\n                    return testSources.SelectMany(s => s.GetSyntaxTrees(parseOptions, sourceFileName)).ToArray();\n                case null:\n                    return Array.Empty<SyntaxTree>();\n                default:\n                    throw new Exception($'Unexpected value: {Value}');\n            } 833508"];
4857 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 833509"];
4858 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 833510"];
4859 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 833511"];
4860 [label="CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) 833512"];
4861 [label="param Parse(string text) 833513"];
4862 [label="param Parse(string filename = '') 833514"];
4863 [label="param Parse(CSharpParseOptions options = null) 833515"];
4864 [label="param Parse(Encoding encoding = null) 833516"];
4865 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 833517"];
4866 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 833518"];
4867 [label="options = TestOptions.Regular; 833519"];
4868 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 833520"];
4869 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 833521"];
4870 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 833522"];
4871 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 833523"];
4872 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 833524"];
4873 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 833525"];
4874 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 833526"];
4875 [label="CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)) 833527"];
4876 [label="var stream = new MemoryStream(); 833528"];
4877 [label="var root = tree.GetRoot(); 833529"];
4878 [label="var root = tree.GetRoot(); 833530"];
4879 [label="root.SerializeTo(stream); 833531"];
4880 [label="root.SerializeTo(stream); 833532"];
4881 [label="root.SerializeTo(stream); 833533"];
4882 [label="stream.Position = 0; 833534"];
4883 [label="stream.Position 833535"];
4884 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 833536"];
4885 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 833537"];
4886 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 833538"];
4887 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 833539"];
4888 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 833540"];
4889 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 833541"];
4890 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 833542"];
4891 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 833543"];
4892 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 833544"];
4893 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 833545"];
4894 [label="param ValidateIOperations(Func<Compilation> createCompilation) 833546"];
4895 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 833547"];
4896 [label="return; 833548"];
4897 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 833549"];
4898 [label="var compilation = createCompilationLambda(); 833550"];
4899 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 833551"];
4900 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 833552"];
4901 [label="param Create(CSharpCompilation? previousSubmission) 833553"];
4902 [label="param Create(Type? returnType) 833554"];
4903 [label="param Create(Type? hostObjectType) 833555"];
4904 [label="param Create(bool isSubmission) 833556"];
4905 [label="RoslynDebug.Assert(options != null); 833557"];
4906 [label="RoslynDebug.Assert(options != null); 833558"];
4907 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 833559"];
4908 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 833560"];
4909 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 833561"];
4910 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 833562"];
4911 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 833563"];
4912 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 833564"];
4913 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 833565"];
4914 [label="new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null) 833566"];
4915 [label="param SyntaxAndDeclarationManager(ImmutableArray<SyntaxTree> externalSyntaxTrees) 833567"];
4916 [label="param SyntaxAndDeclarationManager(CommonMessageProvider messageProvider) 833568"];
4917 [label="param SyntaxAndDeclarationManager(bool isSubmission) 833569"];
4918 [label="param SyntaxAndDeclarationManager(State state) 833570"];
4919 [label="param SyntaxAndDeclarationManager(this) 833571"];
4920 [label="externalSyntaxTrees 833572"];
4921 [label="messageProvider 833573"];
4922 [label="isSubmission 833574"];
4923 [label="param SyntaxAndDeclarationManager(this) 833575"];
4924 [label="_lazyState 833576"];
4925 [label="_lazyState 833577"];
4926 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 833578"];
4927 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 833579"];
4928 [label="param CSharpCompilation(Type? submissionReturnType) 833580"];
4929 [label="param CSharpCompilation(Type? hostObjectType) 833581"];
4930 [label="param CSharpCompilation(bool isSubmission) 833582"];
4931 [label="param CSharpCompilation(ReferenceManager? referenceManager) 833583"];
4932 [label="param CSharpCompilation(bool reuseReferenceManager) 833584"];
4933 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 833585"];
4934 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 833586"];
4935 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 833587"];
4936 [label="param CSharpCompilation(this) 833588"];
4937 [label="previousSubmission 833589"];
4938 [label="submissionReturnType 833590"];
4939 [label="hostObjectType 833591"];
4940 [label="isSubmission 833592"];
4941 [label="referenceManager 833593"];
4942 [label="reuseReferenceManager 833594"];
4943 [label="syntaxAndDeclarations 833595"];
4944 [label="semanticModelProvider 833596"];
4945 [label="eventQueue 833597"];
4946 [label="param CSharpCompilation(this) 833598"];
4947 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 833599"];
4948 [label="param CSharpCompilation(Type? submissionReturnType) 833600"];
4949 [label="param CSharpCompilation(Type? hostObjectType) 833601"];
4950 [label="param CSharpCompilation(bool isSubmission) 833602"];
4951 [label="param CSharpCompilation(ReferenceManager? referenceManager) 833603"];
4952 [label="param CSharpCompilation(bool reuseReferenceManager) 833604"];
4953 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 833605"];
4954 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 833606"];
4955 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 833607"];
4956 [label="param CSharpCompilation(this) 833608"];
4957 [label="isSubmission 833609"];
4958 [label="semanticModelProvider 833610"];
4959 [label="eventQueue 833611"];
4960 [label="param CSharpCompilation(this) 833612"];
4961 [label="_options 833613"];
4962 [label="_globalImports 833614"];
4963 [label="_previousSubmissionImports 833615"];
4964 [label="_globalNamespaceAlias 833616"];
4965 [label="_scriptClass 833617"];
4966 [label="_lazyHostObjectTypeSymbol 833618"];
4967 [label="_lazyImportInfos 833619"];
4968 [label="_conversions 833620"];
4969 [label="_anonymousTypeManager 833621"];
4970 [label="_lazyGlobalNamespace 833622"];
4971 [label="builtInOperators 833623"];
4972 [label="_lazyAssemblySymbol 833624"];
4973 [label="_referenceManager 833625"];
4974 [label="_syntaxAndDeclarations 833626"];
4975 [label="_lazyEntryPoint 833627"];
4976 [label="_lazyEmitNullablePublicOnly 833628"];
4977 [label="_lazyCompilationUnitCompletedTrees 833629"];
4978 [label="NullableAnalysisData 833630"];
4979 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 833631"];
4980 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 833632"];
4981 [label="_externAliasTargets 833633"];
4982 [label="_moduleInitializerMethods 833634"];
4983 [label="_binderFactories 833635"];
4984 [label="_ignoreAccessibilityBinderFactories 833636"];
4985 [label="_lazyDeclarationDiagnostics 833637"];
4986 [label="_declarationDiagnosticsFrozen 833638"];
4987 [label="new DiagnosticBag() 833639"];
4988 [label="_additionalCodegenWarnings = new DiagnosticBag() 833640"];
4989 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 833641"];
4990 [label="this.builtInOperators = new BuiltInOperators(this); 833642"];
4991 [label="this.builtInOperators = new BuiltInOperators(this); 833643"];
4992 [label="new BuiltInOperators(this) 833644"];
4993 [label="param BuiltInOperators(CSharpCompilation compilation) 833645"];
4994 [label="param BuiltInOperators(this) 833646"];
4995 [label="_compilation 833647"];
4996 [label="_builtInUnaryOperators 833648"];
4997 [label="_builtInOperators 833649"];
4998 [label="_compilation 833650"];
4999 [label="this.builtInOperators 833651"];
5000 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 833652"];
5001 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 833653"];
5002 [label="LanguageVersion? result = null; 833654"];
5003 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 833655"];
5004 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 833656"];
5005 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 833657"];
5006 [label="this.LanguageVersion 833658"];
5007 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 833659"];
5008 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 833660"];
5009 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 833661"];
5010 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 833662"];
5011 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 833663"];
5012 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 833664"];
5013 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 833665"];
5014 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 833666"];
5015 [label="this.Options 833667"];
5016 [label="get\n            {\n                return _options;\n            } 833668"];
5017 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 833669"];
5018 [label="_syntaxAndDeclarations 833670"];
5019 [label="Debug.Assert(_lazyAssemblySymbol is null); 833671"];
5020 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 833672"];
5021 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 833673"];
5022 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 833674"];
5023 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 833675"];
5024 [label="int i = 0; 833676"];
5025 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 833677"];
5026 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 833678"];
5027 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 833679"];
5028 [label="i++; 833680"];
5029 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 833681"];
5030 [label="var scriptClassName = this.ScriptClassName; 833682"];
5031 [label="var resolver = this.Resolver; 833683"];
5032 [label="var messageProvider = this.MessageProvider; 833684"];
5033 [label="var isSubmission = this.IsSubmission; 833685"];
5034 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 833686"];
5035 [label="param CSharpCompilation(Type? submissionReturnType) 833687"];
5036 [label="param CSharpCompilation(Type? hostObjectType) 833688"];
5037 [label="previousSubmission 833689"];
5038 [label="submissionReturnType 833690"];
5039 [label="hostObjectType 833691"];
5040 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 833692"];
5041 [label="param CSharpCompilation(Type? submissionReturnType) 833693"];
5042 [label="param CSharpCompilation(Type? hostObjectType) 833694"];
5043 [label="_compilation 833695"];
5044 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 833696"];
5045 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 833697"];
5046 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 833698"];
5047 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 833699"];
5048 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 833700"];
5049 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 833701"];
5050 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 833702"];
5051 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 833703"];
5052 [label="Debug.Assert(_lazyAssemblySymbol is null); 833704"];
5053 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 833705"];
5054 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 833706"];
5055 [label="IsNullableEnabled(compilation) 833707"];
5056 [label="compilation.SyntaxTrees 833708"];
5057 [label="_syntaxAndDeclarations.GetLazyState() 833709"];
5058 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 833710"];
5059 [label="param CreateState(CommonMessageProvider messageProvider) 833711"];
5060 [label="param AppendAllSyntaxTrees(SourceReferenceResolver resolver) 833712"];
5061 [label="param AppendAllSyntaxTrees(CommonMessageProvider messageProvider) 833713"];
5062 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, ImmutableArray<LoadDirective>> loadDirectiveMapBuilder) 833714"];
5063 [label="param AppendAllSyntaxTrees(IDictionary<string, SyntaxTree> loadedSyntaxTreeMapBuilder) 833715"];
5064 [label="var sourceCodeKind = tree.Options.Kind; 833716"];
5065 [label="if (sourceCodeKind == SourceCodeKind.Script)\n            {\n                AppendAllLoadedSyntaxTrees(treesBuilder, tree, scriptClassName, resolver, messageProvider, isSubmission, ordinalMapBuilder, loadDirectiveMapBuilder, loadedSyntaxTreeMapBuilder, declMapBuilder, ref declTable);\n            } 833717"];
5066 [label="OrdinalMap 833718"];
5067 [label="LoadDirectiveMap 833719"];
5068 [label="LoadedSyntaxTreeMap 833720"];
5069 [label="RootNamespaces 833721"];
5070 [label="DeclarationTable 833722"];
5071 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 833723"];
5072 [label="var options = (CSharpParseOptions)trees[0].Options; 833724"];
5073 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 833725"];
5074 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 833726"];
5075 [label="libComp.VerifyDiagnostics(); 833727"];
5076 [label="libComp.VerifyDiagnostics() 833728"];
5077 [label="param VerifyDiagnostics(params DiagnosticDescription[] expected) 833729"];
5078 [label="var diagnostics = c.GetDiagnostics(); 833730"];
5079 [label="c.GetDiagnostics() 833731"];
5080 [label="param GetDiagnostics(CancellationToken cancellationToken = default) 833732"];
5081 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 833733"];
5082 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 833734"];
5083 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 833735"];
5084 [label="GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken) 833736"];
5085 [label="param GetDiagnostics(CompilationStage stage) 833737"];
5086 [label="param GetDiagnostics(bool includeEarlierStages) 833738"];
5087 [label="param GetDiagnostics(CancellationToken cancellationToken) 833739"];
5088 [label="var diagnostics = DiagnosticBag.GetInstance(); 833740"];
5089 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 833741"];
5090 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 833742"];
5091 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 833743"];
5092 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 833744"];
5093 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 833745"];
5094 [label="param GetDiagnostics(CompilationStage stage) 833746"];
5095 [label="param GetDiagnostics(bool includeEarlierStages) 833747"];
5096 [label="param GetDiagnostics(DiagnosticBag diagnostics) 833748"];
5097 [label="param GetDiagnostics(CancellationToken cancellationToken = default) 833749"];
5098 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 833750"];
5099 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 833751"];
5100 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 833752"];
5101 [label="this.SyntaxTrees 833753"];
5102 [label="_syntaxAndDeclarations.GetLazyState() 833754"];
5103 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 833755"];
5104 [label="this.Options 833756"];
5105 [label="param AppendLoadDirectiveDiagnostics(DiagnosticBag builder) 833757"];
5106 [label="param AppendLoadDirectiveDiagnostics(Func<IEnumerable<Diagnostic>, IEnumerable<Diagnostic>>? locationFilterOpt = null) 833758"];
5107 [label="var parseOptionsReported = new HashSet<ParseOptions>(); 833759"];
5108 [label="if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    } 833760"];
5109 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 833761"];
5110 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 833762"];
5111 [label="CheckAssemblyName(builder); 833763"];
5112 [label="CheckAssemblyName(builder); 833764"];
5113 [label="Options 833765"];
5114 [label="Options 833766"];
5115 [label="get\n            {\n                return _options;\n            } 833767"];
5116 [label="return _options; 833768"];
5117 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 833769"];
5118 [label="GetBoundReferenceManager() 833770"];
5119 [label="Debug.Assert(_lazyAssemblySymbol is object); 833771"];
5120 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 833772"];
5121 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 833773"];
5122 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 833774"];
5123 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 833775"];
5124 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 833776"];
5125 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 833777"];
5126 [label="param GetSourceDeclarationDiagnostics(CancellationToken cancellationToken = default) 833778"];
5127 [label="GlobalImports 833779"];
5128 [label="_globalImports.Value 833780"];
5129 [label="Imports.FromGlobalUsings(this) 833781"];
5130 [label="GlobalImports.Complete(cancellationToken); 833782"];
5131 [label="SourceLocation? location = null; 833783"];
5132 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 833784"];
5133 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 833785"];
5134 [label="Assembly 833786"];
5135 [label="SourceAssembly 833787"];
5136 [label="GetBoundReferenceManager() 833788"];
5137 [label="param GetBoundReferenceManager(this) 833789"];
5138 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 833790"];
5139 [label="return _referenceManager; 833791"];
5140 [label="GetBoundReferenceManager(); 833792"];
5141 [label="Assembly.ForceComplete(location, cancellationToken); 833793"];
5142 [label="Assembly.ForceComplete(location, cancellationToken); 833794"];
5143 [label="Assembly.ForceComplete(location, cancellationToken); 833795"];
5144 [label="Declarations 833796"];
5145 [label="_syntaxAndDeclarations.GetLazyState() 833797"];
5146 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 833798"];
5147 [label="return Declarations.GetMergedRoot(this); 833799"];
5148 [label="_syntaxAndDeclarations.GetLazyState() 833800"];
5149 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 833801"];
5150 [label="SourceAssembly 833802"];
5151 [label="GetBoundReferenceManager() 833803"];
5152 [label="param GetBoundReferenceManager(this) 833804"];
5153 [label="GetBoundReferenceManager(); 833805"];
5154 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 833806"];
5155 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 833807"];
5156 [label="param SymbolDeclaredEvent(Symbol symbol) 833808"];
5157 [label="param SymbolDeclaredEvent(this) 833809"];
5158 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 833810"];
5159 [label="GetBoundReferenceManager() 833811"];
5160 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 833812"];
5161 [label="param GetBinderFactory(bool ignoreAccessibility = false) 833813"];
5162 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 833814"];
5163 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 833815"];
5164 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 833816"];
5165 [label="param GetBinderFactory(bool ignoreAccessibility) 833817"];
5166 [label="ignoreAccessibility 833818"];
5167 [label="GetSyntaxTreeOrdinal(syntaxTree) 833819"];
5168 [label="this.ContainsSyntaxTree(tree) 833820"];
5169 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 833821"];
5170 [label="_syntaxAndDeclarations.GetLazyState() 833822"];
5171 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 833823"];
5172 [label="_syntaxAndDeclarations.GetLazyState() 833824"];
5173 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 833825"];
5174 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 833826"];
5175 [label="BinderFactory? previousFactory; 833827"];
5176 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 833828"];
5177 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 833829"];
5178 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 833830"];
5179 [label="param AddNewFactory(bool ignoreAccessibility) 833831"];
5180 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 833832"];
5181 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 833833"];
5182 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 833834"];
5183 [label="BinderFactory? previousFactory; 833835"];
5184 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 833836"];
5185 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 833837"];
5186 [label="GetBoundReferenceManager() 833838"];
5187 [label="GetBoundReferenceManager(); 833839"];
5188 [label="Assembly 833840"];
5189 [label="SourceAssembly 833841"];
5190 [label="GetBoundReferenceManager() 833842"];
5191 [label="param GetBoundReferenceManager(this) 833843"];
5192 [label="GetBoundReferenceManager(); 833844"];
5193 [label="return Assembly.Modules[0]; 833845"];
5194 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 833846"];
5195 [label="Debug.Assert(symbol.IsDefinition); 833847"];
5196 [label="SourceModule 833848"];
5197 [label="Assembly 833849"];
5198 [label="SourceAssembly 833850"];
5199 [label="GetBoundReferenceManager() 833851"];
5200 [label="param GetBoundReferenceManager(this) 833852"];
5201 [label="GetBoundReferenceManager(); 833853"];
5202 [label="return Assembly.Modules[0]; 833854"];
5203 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 833855"];
5204 [label="EmitNullablePublicOnly 833856"];
5205 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 833857"];
5206 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 833858"];
5207 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 833859"];
5208 [label="_declarationDiagnosticsFrozen = true; 833860"];
5209 [label="_needsGeneratedAttributes_IsFrozen = true; 833861"];
5210 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 833862"];
5211 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 833863"];
5212 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 833864"];
5213 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 833865"];
5214 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 833866"];
5215 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 833867"];
5216 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 833868"];
5217 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 833869"];
5218 [label="param GetClsComplianceDiagnostics(CancellationToken cancellationToken) 833870"];
5219 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 833871"];
5220 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 833872"];
5221 [label="param CheckCompliance(DiagnosticBag diagnostics) 833873"];
5222 [label="GetBoundReferenceManager(); 833874"];
5223 [label="System.Diagnostics.Debug.Assert(symbol is SourceAssemblySymbol); 833875"];
5224 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 833876"];
5225 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 833877"];
5226 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 833878"];
5227 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 833879"];
5228 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 833880"];
5229 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 833881"];
5230 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 833882"];
5231 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 833883"];
5232 [label="param GetDeclaredCompliance(out Location attributeLocation) 833884"];
5233 [label="param GetDeclaredCompliance(this) 833885"];
5234 [label="attributeLocation = null; 833886"];
5235 [label="if (assemblyCompliance == Compliance.DeclaredFalse)\n            {\n                // Our interpretation of an assembly-level CLSCompliant attribute is as follows:\n                //   1) If true, then perform all CLS checks.\n                //   2) If false, then perform no CLS checks (dev11 still performs a few, mostly around\n                //      meaningless attributes).  Our interpretation is that the user ultimately wants\n                //      his code to be CLS-compliant, but is temporarily disabling the checks (e.g. during\n                //      refactoring/prototyping).\n                //   3) If absent, the perform all CLS checks.  Our interpretation is that - in the\n                //      absence of an assembly-level attribute - any CLS problems within the compilation\n                //      indicate that the user was trying to do something but didn't know how.  It would\n                //      be nice if the most common case (i.e. this one) was the cheapest, but we don't\n                //      want to confuse novice users.\n                return;\n            } 833887"];
5236 [label="bool assemblyComplianceValue = IsTrue(assemblyCompliance); 833888"];
5237 [label="IsTrue(assemblyCompliance) 833889"];
5238 [label="param IsTrue(Compliance compliance) 833890"];
5239 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 833891"];
5240 [label="return false; 833892"];
5241 [label="Location attributeLocation; 833893"];
5242 [label="param GetDeclaredCompliance(out Location attributeLocation) 833894"];
5243 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 833895"];
5244 [label="i == 0 833896"];
5245 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 833897"];
5246 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 833898"];
5247 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 833899"];
5248 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 833900"];
5249 [label="if (moduleDeclaredCompliance.HasValue)\n                {\n                    if (warningLocation != null)\n                    {\n                        if (!IsDeclared(assemblyCompliance))\n                        {\n                            // This is not useful on non-source modules, but dev11 reports it anyway.\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules, warningLocation);\n                        }\n                        else if (assemblyComplianceValue != moduleDeclaredCompliance.GetValueOrDefault())\n                        {\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules2, warningLocation);\n                        }\n                    }\n                }\n                else if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 833901"];
5250 [label="if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 833902"];
5251 [label="if (assemblyComplianceValue)\n            {\n                CheckForAttributeWithArrayArgument(symbol);\n            } 833903"];
5252 [label="System.Diagnostics.Debug.Assert(symbol.Kind != SymbolKind.Assembly); 833904"];
5253 [label="System.Diagnostics.Debug.Assert((object)containing != null); 833905"];
5254 [label="return compliance; 833906"];
5255 [label="IsTrue(GetInheritedCompliance(symbol)) 833907"];
5256 [label="param IsTrue(Compliance compliance) 833908"];
5257 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 833909"];
5258 [label="return false; 833910"];
5259 [label="IsTrue(GetDeclaredOrInheritedCompliance(sourceModule)) 833911"];
5260 [label="param IsTrue(Compliance compliance) 833912"];
5261 [label="if (DoNotVisit(symbol)) return; 833913"];
5262 [label="DoNotVisit(symbol) 833914"];
5263 [label="param DoNotVisit(Symbol symbol) 833915"];
5264 [label="param DoNotVisit(this) 833916"];
5265 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                return false;\n            } 833917"];
5266 [label="return false; 833918"];
5267 [label="IsTrue(GetDeclaredOrInheritedCompliance(symbol)) 833919"];
5268 [label="param IsTrue(Compliance compliance) 833920"];
5269 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 833921"];
5270 [label="return false; 833922"];
5271 [label="if (tasks == null)\n            {\n                return;\n            } 833923"];
5272 [label="checker.WaitForWorkers(); 833924"];
5273 [label="foreach (Diagnostic diag in queue)\n            {\n                diagnostics.Add(diag);\n            } 833925"];
5274 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 833926"];
5275 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 833927"];
5276 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 833928"];
5277 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 833929"];
5278 [label="var methodBodyDiagnostics = DiagnosticBag.GetInstance(); 833930"];
5279 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 833931"];
5280 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 833932"];
5281 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken) 833933"];
5282 [label="param GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics) 833934"];
5283 [label="param GetDiagnosticsForAllMethodBodies(CancellationToken cancellationToken) 833935"];
5284 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 833936"];
5285 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 833937"];
5286 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 833938"];
5287 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken) 833939"];
5288 [label="param CompileMethodBodies(PEModuleBuilder moduleBeingBuiltOpt) 833940"];
5289 [label="param CompileMethodBodies(bool emittingPdb) 833941"];
5290 [label="param CompileMethodBodies(bool emitTestCoverageData) 833942"];
5291 [label="param CompileMethodBodies(bool hasDeclarationErrors) 833943"];
5292 [label="param CompileMethodBodies(DiagnosticBag diagnostics) 833944"];
5293 [label="param CompileMethodBodies(Predicate<Symbol> filterOpt) 833945"];
5294 [label="param CompileMethodBodies(CancellationToken cancellationToken) 833946"];
5295 [label="Debug.Assert(compilation != null); 833947"];
5296 [label="Debug.Assert(compilation != null); 833948"];
5297 [label="Debug.Assert(diagnostics != null); 833949"];
5298 [label="Debug.Assert(diagnostics != null); 833950"];
5299 [label="compilation.PreviousSubmission 833951"];
5300 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 833952"];
5301 [label="ScriptCompilationInfo 833953"];
5302 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 833954"];
5303 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 833955"];
5304 [label="MethodSymbol entryPoint = null; 833956"];
5305 [label="if (filterOpt is null)\n            {\n                entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken);\n            } 833957"];
5306 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 833958"];
5307 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 833959"];
5308 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 833960"];
5309 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 833961"];
5310 [label="GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken) 833962"];
5311 [label="param GetEntryPoint(PEModuleBuilder moduleBeingBuilt) 833963"];
5312 [label="param GetEntryPoint(bool hasDeclarationErrors) 833964"];
5313 [label="param GetEntryPoint(DiagnosticBag diagnostics) 833965"];
5314 [label="param GetEntryPoint(CancellationToken cancellationToken) 833966"];
5315 [label="var entryPointAndDiagnostics = compilation.GetEntryPointAndDiagnostics(cancellationToken); 833967"];
5316 [label="compilation.GetEntryPointAndDiagnostics(cancellationToken) 833968"];
5317 [label="param GetEntryPointAndDiagnostics(CancellationToken cancellationToken) 833969"];
5318 [label="if (_lazyEntryPoint == null)\n            {\n                EntryPoint? entryPoint;\n                var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this);\n\n                if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                }\n\n                Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null);\n            } 833970"];
5319 [label="EntryPoint? entryPoint; 833971"];
5320 [label="Debug.Assert(!entryPointAndDiagnostics.Diagnostics.IsDefault); 833972"];
5321 [label="if ((object)entryPoint == null)\n            {\n                return null;\n            } 833973"];
5322 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 833974"];
5323 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 833975"];
5324 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 833976"];
5325 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 833977"];
5326 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 833978"];
5327 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 833979"];
5328 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 833980"];
5329 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 833981"];
5330 [label="new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken) 833982"];
5331 [label="param MethodCompiler(PEModuleBuilder moduleBeingBuiltOpt) 833983"];
5332 [label="param MethodCompiler(bool emittingPdb) 833984"];
5333 [label="param MethodCompiler(bool emitTestCoverageData) 833985"];
5334 [label="param MethodCompiler(bool hasDeclarationErrors) 833986"];
5335 [label="param MethodCompiler(DiagnosticBag diagnostics) 833987"];
5336 [label="param MethodCompiler(Predicate<Symbol> filterOpt) 833988"];
5337 [label="param MethodCompiler(CancellationToken cancellationToken) 833989"];
5338 [label="param MethodCompiler(this) 833990"];
5339 [label="param MethodCompiler(this) 833991"];
5340 [label="_compilation 833992"];
5341 [label="_emittingPdb 833993"];
5342 [label="_emitTestCoverageData 833994"];
5343 [label="_diagnostics 833995"];
5344 [label="_hasDeclarationErrors 833996"];
5345 [label="_moduleBeingBuiltOpt 833997"];
5346 [label="_filterOpt 833998"];
5347 [label="_debugDocumentProvider 833999"];
5348 [label="_entryPointOpt 834000"];
5349 [label="_compilerTasks 834001"];
5350 [label="_globalHasErrors 834002"];
5351 [label="Debug.Assert(compilation != null); 834003"];
5352 [label="Debug.Assert(compilation != null); 834004"];
5353 [label="Debug.Assert(diagnostics != null); 834005"];
5354 [label="Debug.Assert(diagnostics != null); 834006"];
5355 [label="_moduleBeingBuiltOpt 834007"];
5356 [label="_emittingPdb 834008"];
5357 [label="_cancellationToken 834009"];
5358 [label="_diagnostics 834010"];
5359 [label="_filterOpt 834011"];
5360 [label="_hasDeclarationErrors 834012"];
5361 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 834013"];
5362 [label="SetGlobalErrorIfTrue(hasDeclarationErrors) 834014"];
5363 [label="param SetGlobalErrorIfTrue(bool arg) 834015"];
5364 [label="param SetGlobalErrorIfTrue(this) 834016"];
5365 [label="if (arg)\n            {\n                _globalHasErrors = true;\n            } 834017"];
5366 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 834018"];
5367 [label="if (emittingPdb || emitTestCoverageData)\n            {\n                _debugDocumentProvider = (path, basePath) => moduleBeingBuiltOpt.DebugDocumentsBuilder.GetOrAddDebugDocument(path, basePath, CreateDebugDocumentForFile);\n            } 834019"];
5368 [label="_emitTestCoverageData 834020"];
5369 [label="compilation.Options 834021"];
5370 [label="compilation.SourceModule 834022"];
5371 [label="Assembly 834023"];
5372 [label="SourceAssembly 834024"];
5373 [label="GetBoundReferenceManager() 834025"];
5374 [label="param GetBoundReferenceManager(this) 834026"];
5375 [label="GetBoundReferenceManager(); 834027"];
5376 [label="return Assembly.Modules[0]; 834028"];
5377 [label="methodCompiler.CompileNamespace(compilation.SourceModule.GlobalNamespace) 834029"];
5378 [label="param CompileNamespace(this) 834030"];
5379 [label="param VisitNamedType(TypeCompilationState arg) 834031"];
5380 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 834032"];
5381 [label="PassesFilter(_filterOpt, symbol) 834033"];
5382 [label="param PassesFilter(Predicate<Symbol> filterOpt) 834034"];
5383 [label="param PassesFilter(Symbol symbol) 834035"];
5384 [label="return (filterOpt == null) || filterOpt(symbol); 834036"];
5385 [label="return (filterOpt == null) || filterOpt(symbol); 834037"];
5386 [label="arg = null; 834038"];
5387 [label="param CompileNamedTypeAsync(NamedTypeSymbol symbol) 834039"];
5388 [label="methodCompiler.CompileNamespace(compilation.SourceModule.GlobalNamespace); 834040"];
5389 [label="methodCompiler.WaitForWorkers() 834041"];
5390 [label="param WaitForWorkers(this) 834042"];
5391 [label="if (tasks == null)\n            {\n                return;\n            } 834043"];
5392 [label="if (tasks == null)\n            {\n                return;\n            } 834044"];
5393 [label="Task curTask; 834045"];
5394 [label="while (tasks.TryPop(out curTask))\n            {\n                curTask.GetAwaiter().GetResult();\n            } 834046"];
5395 [label="methodCompiler.WaitForWorkers(); 834047"];
5396 [label="if (moduleBeingBuiltOpt != null)\n            {\n                var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics);\n\n                var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics);\n\n                // By this time we have processed all types reachable from module's global namespace\n                compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics);\n                methodCompiler.WaitForWorkers();\n\n                var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass;\n                if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                }\n            } 834048"];
5397 [label="if (moduleBeingBuiltOpt != null)\n            {\n                var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics);\n\n                var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics);\n\n                // By this time we have processed all types reachable from module's global namespace\n                compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics);\n                methodCompiler.WaitForWorkers();\n\n                var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass;\n                if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                }\n            } 834049"];
5398 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 834050"];
5399 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 834051"];
5400 [label="compilation.AdditionalCodegenWarnings 834052"];
5401 [label="if (filterOpt == null)\n            {\n                WarnUnusedFields(compilation, diagnostics, cancellationToken);\n\n                if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                }\n            } 834053"];
5402 [label="if (filterOpt == null)\n            {\n                WarnUnusedFields(compilation, diagnostics, cancellationToken);\n\n                if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                }\n            } 834054"];
5403 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 834055"];
5404 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 834056"];
5405 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken) 834057"];
5406 [label="param WarnUnusedFields(DiagnosticBag diagnostics) 834058"];
5407 [label="param WarnUnusedFields(CancellationToken cancellationToken) 834059"];
5408 [label="compilation.Assembly 834060"];
5409 [label="SourceAssembly 834061"];
5410 [label="GetBoundReferenceManager() 834062"];
5411 [label="param GetBoundReferenceManager(this) 834063"];
5412 [label="GetBoundReferenceManager(); 834064"];
5413 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 834065"];
5414 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 834066"];
5415 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 834067"];
5416 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 834068"];
5417 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 834069"];
5418 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 834070"];
5419 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 834071"];
5420 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 834072"];
5421 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken) 834073"];
5422 [label="param WriteDocumentationCommentXml(string? assemblyName) 834074"];
5423 [label="param WriteDocumentationCommentXml(Stream? xmlDocStream) 834075"];
5424 [label="param WriteDocumentationCommentXml(DiagnosticBag diagnostics) 834076"];
5425 [label="param WriteDocumentationCommentXml(CancellationToken cancellationToken) 834077"];
5426 [label="param WriteDocumentationCommentXml(SyntaxTree? filterTree = null) 834078"];
5427 [label="param WriteDocumentationCommentXml(TextSpan? filterSpanWithinTree = null) 834079"];
5428 [label="StreamWriter writer = null; 834080"];
5429 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 834081"];
5430 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 834082"];
5431 [label="compilation.SourceAssembly 834083"];
5432 [label="GetBoundReferenceManager() 834084"];
5433 [label="param GetBoundReferenceManager(this) 834085"];
5434 [label="GetBoundReferenceManager(); 834086"];
5435 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 834087"];
5436 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 834088"];
5437 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 834089"];
5438 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 834090"];
5439 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 834091"];
5440 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 834092"];
5441 [label="new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken) 834093"];
5442 [label="param DocumentationCommentCompiler(TextWriter writer) 834094"];
5443 [label="param DocumentationCommentCompiler(SyntaxTree filterTree) 834095"];
5444 [label="param DocumentationCommentCompiler(TextSpan? filterSpanWithinTree) 834096"];
5445 [label="param DocumentationCommentCompiler(bool processIncludes) 834097"];
5446 [label="param DocumentationCommentCompiler(bool isForSingleSymbol) 834098"];
5447 [label="param DocumentationCommentCompiler(DiagnosticBag diagnostics) 834099"];
5448 [label="param DocumentationCommentCompiler(CancellationToken cancellationToken) 834100"];
5449 [label="param DocumentationCommentCompiler(this) 834101"];
5450 [label="param DocumentationCommentCompiler(this) 834102"];
5451 [label="_assemblyName 834103"];
5452 [label="_compilation 834104"];
5453 [label="_writer 834105"];
5454 [label="_filterTree 834106"];
5455 [label="_filterSpanWithinTree 834107"];
5456 [label="_processIncludes 834108"];
5457 [label="_isForSingleSymbol 834109"];
5458 [label="_diagnostics 834110"];
5459 [label="_lazyComparer 834111"];
5460 [label="_includedFileCache 834112"];
5461 [label="_indentDepth 834113"];
5462 [label="_temporaryStringBuilders 834114"];
5463 [label="_writer 834115"];
5464 [label="_filterTree 834116"];
5465 [label="_filterSpanWithinTree 834117"];
5466 [label="_processIncludes 834118"];
5467 [label="_isForSingleSymbol 834119"];
5468 [label="_diagnostics 834120"];
5469 [label="_cancellationToken 834121"];
5470 [label="compilation.SourceAssembly 834122"];
5471 [label="GetBoundReferenceManager() 834123"];
5472 [label="param GetBoundReferenceManager(this) 834124"];
5473 [label="GetBoundReferenceManager(); 834125"];
5474 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 834126"];
5475 [label="Debug.Assert(_assemblyName != null); 834127"];
5476 [label="WriteLine('<?xml version=\\'1.0\\'?>'); 834128"];
5477 [label="WriteLine('<?xml version=\\'1.0\\'?>') 834129"];
5478 [label="param WriteLine(string message) 834130"];
5479 [label="param WriteLine(this) 834131"];
5480 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834132"];
5481 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834133"];
5482 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834134"];
5483 [label="WriteLine('<doc>'); 834135"];
5484 [label="WriteLine('<doc>') 834136"];
5485 [label="param WriteLine(string message) 834137"];
5486 [label="param WriteLine(this) 834138"];
5487 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834139"];
5488 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834140"];
5489 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834141"];
5490 [label="Indent(); 834142"];
5491 [label="WriteLine('<assembly>'); 834143"];
5492 [label="WriteLine('<assembly>') 834144"];
5493 [label="param WriteLine(string message) 834145"];
5494 [label="param WriteLine(this) 834146"];
5495 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834147"];
5496 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834148"];
5497 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834149"];
5498 [label="Indent(); 834150"];
5499 [label="WriteLine('<name>{0}</name>', _assemblyName); 834151"];
5500 [label="WriteLine('<name>{0}</name>', _assemblyName) 834152"];
5501 [label="WriteLine('<name>{0}</name>', _assemblyName) 834153"];
5502 [label="param WriteLine(string format) 834154"];
5503 [label="param WriteLine(params object[] args) 834155"];
5504 [label="param WriteLine(this) 834156"];
5505 [label="WriteLine(string.Format(format, args)); 834157"];
5506 [label="WriteLine(string.Format(format, args)); 834158"];
5507 [label="WriteLine(string.Format(format, args)); 834159"];
5508 [label="WriteLine(string.Format(format, args)) 834160"];
5509 [label="param WriteLine(string message) 834161"];
5510 [label="param WriteLine(this) 834162"];
5511 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834163"];
5512 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834164"];
5513 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834165"];
5514 [label="WriteLine(string.Format(format, args)); 834166"];
5515 [label="Debug.Assert(_indentDepth >= 0); 834167"];
5516 [label="Unindent(); 834168"];
5517 [label="WriteLine('</assembly>'); 834169"];
5518 [label="WriteLine('</assembly>') 834170"];
5519 [label="param WriteLine(string message) 834171"];
5520 [label="param WriteLine(this) 834172"];
5521 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834173"];
5522 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834174"];
5523 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834175"];
5524 [label="WriteLine('<members>'); 834176"];
5525 [label="WriteLine('<members>') 834177"];
5526 [label="param WriteLine(string message) 834178"];
5527 [label="param WriteLine(this) 834179"];
5528 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834180"];
5529 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834181"];
5530 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834182"];
5531 [label="Indent(); 834183"];
5532 [label="Debug.Assert(!_isForSingleSymbol); 834184"];
5533 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 834185"];
5534 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 834186"];
5535 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 834187"];
5536 [label="ImmutableArray<DocumentationCommentTriviaSyntax> docCommentNodes; 834188"];
5537 [label="docCommentNodes 834189"];
5538 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 834190"];
5539 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 834191"];
5540 [label="maxDocumentationMode = DocumentationMode.None; 834192"];
5541 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 834193"];
5542 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 834194"];
5543 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 834195"];
5544 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 834196"];
5545 [label="currDocumentationMode > maxDocumentationMode 834197"];
5546 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 834198"];
5547 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 834199"];
5548 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 834200"];
5549 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 834201"];
5550 [label="return true; 834202"];
5551 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 834203"];
5552 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 834204"];
5553 [label="return; 834205"];
5554 [label="Unindent(); 834206"];
5555 [label="WriteLine('</members>'); 834207"];
5556 [label="WriteLine('</members>') 834208"];
5557 [label="param WriteLine(string message) 834209"];
5558 [label="param WriteLine(this) 834210"];
5559 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834211"];
5560 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834212"];
5561 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834213"];
5562 [label="Unindent(); 834214"];
5563 [label="WriteLine('</doc>'); 834215"];
5564 [label="WriteLine('</doc>') 834216"];
5565 [label="param WriteLine(string message) 834217"];
5566 [label="param WriteLine(this) 834218"];
5567 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834219"];
5568 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834220"];
5569 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 834221"];
5570 [label="Debug.Assert(compiler._indentDepth == 0); 834222"];
5571 [label="Debug.Assert(compiler._indentDepth == 0); 834223"];
5572 [label="writer?.Flush(); 834224"];
5573 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 834225"];
5574 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 834226"];
5575 [label="compilation.SyntaxTrees 834227"];
5576 [label="_syntaxAndDeclarations.GetLazyState() 834228"];
5577 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 834229"];
5578 [label="param ReportUnprocessed(TextSpan? filterSpanWithinTree) 834230"];
5579 [label="param ReportUnprocessed(DiagnosticBag diagnostics) 834231"];
5580 [label="param ReportUnprocessed(CancellationToken cancellationToken) 834232"];
5581 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 834233"];
5582 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 834234"];
5583 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 834235"];
5584 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken) 834236"];
5585 [label="param ReportUnusedImports(SyntaxTree? filterTree) 834237"];
5586 [label="param ReportUnusedImports(DiagnosticBag diagnostics) 834238"];
5587 [label="param ReportUnusedImports(CancellationToken cancellationToken) 834239"];
5588 [label="param ReportUnusedImports(this) 834240"];
5589 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 834241"];
5590 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 834242"];
5591 [label="CompleteTrees(filterTree); 834243"];
5592 [label="CompleteTrees(filterTree) 834244"];
5593 [label="param CompleteTrees(SyntaxTree? filterTree) 834245"];
5594 [label="param CompleteTrees(this) 834246"];
5595 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 834247"];
5596 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 834248"];
5597 [label="CompleteTrees(filterTree); 834249"];
5598 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 834250"];
5599 [label="builder.AddRangeAndFree(methodBodyDiagnostics); 834251"];
5600 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 834252"];
5601 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 834253"];
5602 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 834254"];
5603 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 834255"];
5604 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 834256"];
5605 [label="diagnostics.Verify(expected); 834257"];
5606 [label="diagnostics.Verify(expected) 834258"];
5607 [label="param Verify(params DiagnosticDescription[] expected) 834259"];
5608 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 834260"];
5609 [label="Verify((IEnumerable<Diagnostic>)actual, expected) 834261"];
5610 [label="param Verify(params DiagnosticDescription[] expected) 834262"];
5611 [label="Verify(actual, expected, errorCodeOnly: false); 834263"];
5612 [label="Verify(actual, expected, errorCodeOnly: false); 834264"];
5613 [label="Verify(actual, expected, errorCodeOnly: false) 834265"];
5614 [label="param Verify(DiagnosticDescription[] expected) 834266"];
5615 [label="param Verify(bool errorCodeOnly) 834267"];
5616 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 834268"];
5617 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 834269"];
5618 [label="var includeDefaultSeverity = expected.Any() && expected.All(e => e.DefaultSeverity != null); 834270"];
5619 [label="var includeEffectiveSeverity = expected.Any() && expected.All(e => e.EffectiveSeverity != null); 834271"];
5620 [label="var unmatched = actual.Select(d => new DiagnosticDescription(d, errorCodeOnly, includeDefaultSeverity, includeEffectiveSeverity))\n                                  .ToList(); 834272"];
5621 [label="foreach (var d in expected)\n            {\n                int index = unmatched.IndexOf(d);\n                if (index > -1)\n                {\n                    unmatched.RemoveAt(index);\n                }\n                else\n                {\n                    CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n                }\n            } 834273"];
5622 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 834274"];
5623 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 834275"];
5624 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 834276"];
5625 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 834277"];
5626 [label="DiagnosticDescription.GetAssertText(expected, actual) 834278"];
5627 [label="param GetAssertText(DiagnosticDescription[] expected) 834279"];
5628 [label="const int CSharp = 1; 834280"];
5629 [label="const int VisualBasic = 2; 834281"];
5630 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 834282"];
5631 [label="actual.Any() && actual.First() is CSDiagnostic 834283"];
5632 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 834284"];
5633 [label="var includeDiagnosticMessagesAsComments = (language == CSharp); 834285"];
5634 [label="int indentDepth = (language == CSharp) ? 4 : 1; 834286"];
5635 [label="(language == CSharp) 834287"];
5636 [label="var includeDefaultSeverity = expected.Any() && expected.All(d => d.DefaultSeverity != null); 834288"];
5637 [label="var includeEffectiveSeverity = expected.Any() && expected.All(d => d.EffectiveSeverity != null); 834289"];
5638 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 834290"];
5639 [label="IsSortedOrEmpty(expected) 834291"];
5640 [label="param IsSortedOrEmpty(DiagnosticDescription[] diagnostics) 834292"];
5641 [label="var comparer = LinePositionComparer.Instance; 834293"];
5642 [label="DiagnosticDescription last = null; 834294"];
5643 [label="foreach (var diagnostic in diagnostics)\n            {\n                if (diagnostic._startPosition == null)\n                {\n                    return false;\n                }\n                if (last != null && comparer.Compare(last._startPosition, diagnostic._startPosition) > 0)\n                {\n                    return false;\n                }\n                last = diagnostic;\n            } 834295"];
5644 [label="return true; 834296"];
5645 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 834297"];
5646 [label="Sort(actual) 834298"];
5647 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 834299"];
5648 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 834300"];
5649 [label="var assertText = new StringBuilder(); 834301"];
5650 [label="assertText.AppendLine(); 834302"];
5651 [label="int i; 834303"];
5652 [label="assertText.AppendLine('Expected:'); 834304"];
5653 [label="assertText.AppendLine('Expected:'); 834305"];
5654 [label="var expectedText = ArrayBuilder<string>.GetInstance(); 834306"];
5655 [label="foreach (var d in expected)\n            {\n                expectedText.Add(GetDiagnosticDescription(d, indentDepth));\n            } 834307"];
5656 [label="GetCommaSeparatedLines(assertText, expectedText); 834308"];
5657 [label="GetCommaSeparatedLines(assertText, expectedText); 834309"];
5658 [label="GetCommaSeparatedLines(assertText, expectedText) 834310"];
5659 [label="param GetCommaSeparatedLines(StringBuilder sb) 834311"];
5660 [label="param GetCommaSeparatedLines(ArrayBuilder<string> lines) 834312"];
5661 [label="int n = lines.Count; 834313"];
5662 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 834314"];
5663 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 834315"];
5664 [label="GetCommaSeparatedLines(assertText, expectedText); 834316"];
5665 [label="assertText.AppendLine('Actual:'); 834317"];
5666 [label="assertText.AppendLine('Actual:'); 834318"];
5667 [label="var actualText = ArrayBuilder<string>.GetInstance(); 834319"];
5668 [label="for (i = 0; e.MoveNext(); i++)\n            {\n                Diagnostic d = e.Current;\n                string message = d.ToString();\n                if (Regex.Match(message, @'{\\d+}').Success)\n                {\n                    Assert.True(false, 'Diagnostic messages should never contain unsubstituted placeholders.\\n    ' + message);\n                }\n\n                if (i > 0)\n                {\n                    assertText.AppendLine(',');\n                }\n\n                if (includeDiagnosticMessagesAsComments)\n                {\n                    Indent(assertText, indentDepth);\n                    assertText.Append('// ');\n                    assertText.AppendLine(d.ToString());\n                    var l = d.Location;\n                    if (l.IsInSource)\n                    {\n                        Indent(assertText, indentDepth);\n                        assertText.Append('// ');\n                        assertText.AppendLine(l.SourceTree.GetText().Lines.GetLineFromPosition(l.SourceSpan.Start).ToString());\n                    }\n                }\n\n                var description = new DiagnosticDescription(d, errorCodeOnly: false, includeDefaultSeverity, includeEffectiveSeverity);\n                var diffDescription = description;\n                var idx = Array.IndexOf(expected, description);\n                if (idx != -1)\n                {\n                    diffDescription = expected[idx];\n                }\n                assertText.Append(GetDiagnosticDescription(description, indentDepth));\n                actualText.Add(GetDiagnosticDescription(diffDescription, indentDepth));\n            } 834320"];
5669 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 834321"];
5670 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 834322"];
5671 [label="assertText.AppendLine('Diff:'); 834323"];
5672 [label="assertText.AppendLine('Diff:'); 834324"];
5673 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 834325"];
5674 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 834326"];
5675 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 834327"];
5676 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 834328"];
5677 [label="DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine) 834329"];
5678 [label="param DiffReport(IEnumerable<T> expected) 834330"];
5679 [label="param DiffReport(IEnumerable<T> actual) 834331"];
5680 [label="param DiffReport(string separator) 834332"];
5681 [label="param DiffReport(IEqualityComparer<T> comparer = null) 834333"];
5682 [label="param DiffReport(Func<T, string> toString = null) 834334"];
5683 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 834335"];
5684 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 834336"];
5685 [label="(comparer != null) 834337"];
5686 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 834338"];
5687 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 834339"];
5688 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 834340"];
5689 [label="IList<T> expectedList = expected as IList<T> ?? new List<T>(expected); 834341"];
5690 [label="IList<T> actualList = actual as IList<T> ?? new List<T>(actual); 834342"];
5691 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 834343"];
5692 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 834344"];
5693 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 834345"];
5694 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 834346"];
5695 [label="lcs.CalculateDiff(expectedList, actualList, toString) 834347"];
5696 [label="param CalculateDiff(IList<T> sequenceA) 834348"];
5697 [label="param CalculateDiff(IList<T> sequenceB) 834349"];
5698 [label="param CalculateDiff(Func<T, string> toString) 834350"];
5699 [label="param CalculateDiff(this) 834351"];
5700 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 834352"];
5701 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 834353"];
5702 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 834354"];
5703 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 834355"];
5704 [label="GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count) 834356"];
5705 [label="param GetEdits(TSequence sequenceA) 834357"];
5706 [label="param GetEdits(int lengthA) 834358"];
5707 [label="param GetEdits(TSequence sequenceB) 834359"];
5708 [label="param GetEdits(int lengthB) 834360"];
5709 [label="param GetEdits(this) 834361"];
5710 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 834362"];
5711 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 834363"];
5712 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 834364"];
5713 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 834365"];
5714 [label="ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB) 834366"];
5715 [label="param ComputeCostMatrix(TSequence sequenceA) 834367"];
5716 [label="param ComputeCostMatrix(int lengthA) 834368"];
5717 [label="param ComputeCostMatrix(TSequence sequenceB) 834369"];
5718 [label="param ComputeCostMatrix(int lengthB) 834370"];
5719 [label="param ComputeCostMatrix(this) 834371"];
5720 [label="var la = lengthA + 1; 834372"];
5721 [label="var la = lengthA + 1; 834373"];
5722 [label="var lb = lengthB + 1; 834374"];
5723 [label="var lb = lengthB + 1; 834375"];
5724 [label="var d = new int[la, lb]; 834376"];
5725 [label="d[0, 0] = 0; 834377"];
5726 [label="d[0, 0] 834378"];
5727 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 834379"];
5728 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 834380"];
5729 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 834381"];
5730 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 834382"];
5731 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 834383"];
5732 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 834384"];
5733 [label="return d; 834385"];
5734 [label="int i = lengthA; 834386"];
5735 [label="int j = lengthB; 834387"];
5736 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 834388"];
5737 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 834389"];
5738 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 834390"];
5739 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 834391"];
5740 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 834392"];
5741 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 834393"];
5742 [label="param GetEdits(this) 834394"];
5743 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 834395"];
5744 [label="param CalculateDiff(this) 834396"];
5745 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 834397"];
5746 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 834398"];
5747 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 834399"];
5748 [label="actualText.Free(); 834400"];
5749 [label="expectedText.Free(); 834401"];
5750 [label="return assertText.ToString(); 834402"];
5751 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 834403"];
5752 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 834404"];
5753 [label="diagnostics.Verify(expected); 834405"];
5754 [label="VerifyAssemblyIds(c, diagnostics); 834406"];
5755 [label="VerifyAssemblyIds(c, diagnostics); 834407"];
5756 [label="VerifyAssemblyIds(c, diagnostics) 834408"];
5757 [label="param VerifyAssemblyIds(TCompilation c) 834409"];
5758 [label="param VerifyAssemblyIds(ImmutableArray<Diagnostic> diagnostics) 834410"];
5759 [label="foreach (var diagnostic in diagnostics)\n            {\n                // If this is a diagnostic about a missing assembly, make sure that we can get back\n                // an AssemblyIdentity when we query the compiler.  If it's not a diagnostic about\n                // a missing assembly, make sure we get no results back.\n                if (c.IsUnreferencedAssemblyIdentityDiagnosticCode(diagnostic.Code))\n                {\n                    var assemblyIds = c.GetUnreferencedAssemblyIdentities(diagnostic);\n                    CustomAssert.False(assemblyIds.IsEmpty);\n\n                    var diagnosticMessage = diagnostic.GetMessage();\n                    foreach (var id in assemblyIds)\n                    {\n                        CustomAssert.Contains(id.GetDisplayName(), diagnosticMessage);\n                    }\n                }\n                else\n                {\n                    var assemblyIds = c.GetUnreferencedAssemblyIdentities(diagnostic);\n                    CustomAssert.True(assemblyIds.IsEmpty);\n                }\n            } 834411"];
5760 [label="VerifyAssemblyIds(c, diagnostics); 834412"];
5761 [label="var libImage = libComp.EmitToImageReference(emitOptions); 834413"];
5762 [label="libComp.EmitToImageReference(emitOptions) 834414"];
5763 [label="param EmitToImageReference(bool embedInteropTypes = false) 834415"];
5764 [label="param EmitToImageReference(ImmutableArray<string> aliases = default) 834416"];
5765 [label="param EmitToImageReference(DiagnosticDescription[] expectedWarnings = null) 834417"];
5766 [label="embedInteropTypes 834418"];
5767 [label="aliases 834419"];
5768 [label="expectedWarnings 834420"];
5769 [label="EmitToPortableExecutableReference(comp, options, embedInteropTypes, aliases, expectedWarnings) 834421"];
5770 [label="param EmitToPortableExecutableReference(bool embedInteropTypes = false) 834422"];
5771 [label="param EmitToPortableExecutableReference(ImmutableArray<string> aliases = default) 834423"];
5772 [label="param EmitToPortableExecutableReference(DiagnosticDescription[] expectedWarnings = null) 834424"];
5773 [label="var image = comp.EmitToArray(options, expectedWarnings: expectedWarnings); 834425"];
5774 [label="var image = comp.EmitToArray(options, expectedWarnings: expectedWarnings); 834426"];
5775 [label="comp.EmitToArray(options, expectedWarnings: expectedWarnings) 834427"];
5776 [label="param EmitToArray(CompilationTestData testData = null) 834428"];
5777 [label="param EmitToArray(DiagnosticDescription[] expectedWarnings = null) 834429"];
5778 [label="param EmitToArray(Stream pdbStream = null) 834430"];
5779 [label="param EmitToArray(IMethodSymbol debugEntryPoint = null) 834431"];
5780 [label="param EmitToArray(Stream sourceLinkStream = null) 834432"];
5781 [label="param EmitToArray(IEnumerable<EmbeddedText> embeddedTexts = null) 834433"];
5782 [label="param EmitToArray(IEnumerable<ResourceDescription> manifestResources = null) 834434"];
5783 [label="param EmitToArray(Stream metadataPEStream = null) 834435"];
5784 [label="var peStream = new MemoryStream(); 834436"];
5785 [label="if (pdbStream == null && compilation.Options.OptimizationLevel == OptimizationLevel.Debug && options?.DebugInformationFormat != DebugInformationFormat.Embedded)\n            {\n                if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                }\n\n                var discretePdb = (object)options != null && options.DebugInformationFormat != DebugInformationFormat.Embedded;\n                pdbStream = discretePdb ? new MemoryStream() : null;\n            } 834437"];
5786 [label="if (pdbStream == null && compilation.Options.OptimizationLevel == OptimizationLevel.Debug && options?.DebugInformationFormat != DebugInformationFormat.Embedded)\n            {\n                if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                }\n\n                var discretePdb = (object)options != null && options.DebugInformationFormat != DebugInformationFormat.Embedded;\n                pdbStream = discretePdb ? new MemoryStream() : null;\n            } 834438"];
5787 [label="compilation.Options 834439"];
5788 [label="MonoHelpers.IsRunningOnMono() 834440"];
5789 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 834441"];
5790 [label="if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                } 834442"];
5791 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 834443"];
5792 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 834444"];
5793 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 834445"];
5794 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 834446"];
5795 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 834447"];
5796 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 834448"];
5797 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 834449"];
5798 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 834450"];
5799 [label="param CreateModuleBuilder(IMethodSymbol? debugEntryPoint) 834451"];
5800 [label="param CreateModuleBuilder(IEnumerable<EmbeddedText>? embeddedTexts) 834452"];
5801 [label="param CreateModuleBuilder(CompilationTestData? testData) 834453"];
5802 [label="param CreateModuleBuilder(DiagnosticBag diagnostics) 834454"];
5803 [label="param CreateModuleBuilder(CancellationToken cancellationToken) 834455"];
5804 [label="Debug.Assert(!IsSubmission || HasCodeToEmit()); 834456"];
5805 [label="GetRuntimeMetadataVersion(emitOptions, diagnostics) 834457"];
5806 [label="param GetRuntimeMetadataVersion(EmitOptions emitOptions) 834458"];
5807 [label="param GetRuntimeMetadataVersion(DiagnosticBag diagnostics) 834459"];
5808 [label="GetRuntimeMetadataVersion(emitOptions) 834460"];
5809 [label="param GetRuntimeMetadataVersion(EmitOptions emitOptions) 834461"];
5810 [label="Assembly 834462"];
5811 [label="SourceAssembly 834463"];
5812 [label="GetBoundReferenceManager() 834464"];
5813 [label="GetBoundReferenceManager(); 834465"];
5814 [label="if (runtimeMDVersion != null)\n            {\n                return runtimeMDVersion;\n            } 834466"];
5815 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 834467"];
5816 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 834468"];
5817 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 834469"];
5818 [label="SourceAssembly 834470"];
5819 [label="GetBoundReferenceManager() 834471"];
5820 [label="GetBoundReferenceManager(); 834472"];
5821 [label="SourceAssembly.IsDelaySigned 834473"];
5822 [label="SourceAssembly 834474"];
5823 [label="GetBoundReferenceManager() 834475"];
5824 [label="GetBoundReferenceManager(); 834476"];
5825 [label="=> 0x30 834477"];
5826 [label="0x30 834478"];
5827 [label="if (manifestResources == null)\n            {\n                manifestResources = SpecializedCollections.EmptyEnumerable<ResourceDescription>();\n            } 834479"];
5828 [label="PEModuleBuilder moduleBeingBuilt; 834480"];
5829 [label="GetBoundReferenceManager(); 834481"];
5830 [label="get\n            {\n                return true;\n            } 834482"];
5831 [label="if (sourceModule.AnyReferencedAssembliesAreLinked)\n            {\n                _embeddedTypesManagerOpt = new NoPia.EmbeddedTypesManager(this);\n            } 834483"];
5832 [label="Debug.Assert(sourceAssembly is object); 834484"];
5833 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 834485"];
5834 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 834486"];
5835 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 834487"];
5836 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 834488"];
5837 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 834489"];
5838 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 834490"];
5839 [label="PooledHashSet<int>? excludeDiagnostics = null; 834491"];
5840 [label="if (emitMetadataOnly)\n            {\n                excludeDiagnostics = PooledHashSet<int>.GetInstance();\n                excludeDiagnostics.Add((int)ErrorCode.ERR_ConcreteMissingBody);\n            } 834492"];
5841 [label="excludeDiagnostics = PooledHashSet<int>.GetInstance(); 834493"];
5842 [label="excludeDiagnostics.Add((int)ErrorCode.ERR_ConcreteMissingBody); 834494"];
5843 [label="excludeDiagnostics.Add((int)ErrorCode.ERR_ConcreteMissingBody); 834495"];
5844 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 834496"];
5845 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 834497"];
5846 [label="GetDiagnostics(CompilationStage.Declare, true, cancellationToken) 834498"];
5847 [label="param GetDiagnostics(CompilationStage stage) 834499"];
5848 [label="param GetDiagnostics(bool includeEarlierStages) 834500"];
5849 [label="var diagnostics = DiagnosticBag.GetInstance(); 834501"];
5850 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 834502"];
5851 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 834503"];
5852 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 834504"];
5853 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 834505"];
5854 [label="param GetDiagnostics(CompilationStage stage) 834506"];
5855 [label="param GetDiagnostics(bool includeEarlierStages) 834507"];
5856 [label="param GetDiagnostics(DiagnosticBag diagnostics) 834508"];
5857 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 834509"];
5858 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 834510"];
5859 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 834511"];
5860 [label="this.SyntaxTrees 834512"];
5861 [label="_syntaxAndDeclarations.GetLazyState() 834513"];
5862 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 834514"];
5863 [label="this.Options 834515"];
5864 [label="param AppendLoadDirectiveDiagnostics(DiagnosticBag builder) 834516"];
5865 [label="param AppendLoadDirectiveDiagnostics(Func<IEnumerable<Diagnostic>, IEnumerable<Diagnostic>>? locationFilterOpt = null) 834517"];
5866 [label="var parseOptionsReported = new HashSet<ParseOptions>(); 834518"];
5867 [label="if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    } 834519"];
5868 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 834520"];
5869 [label="CheckAssemblyName(builder); 834521"];
5870 [label="CheckAssemblyName(builder); 834522"];
5871 [label="Options 834523"];
5872 [label="Options 834524"];
5873 [label="get\n            {\n                return _options;\n            } 834525"];
5874 [label="return _options; 834526"];
5875 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 834527"];
5876 [label="GetBoundReferenceManager() 834528"];
5877 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 834529"];
5878 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 834530"];
5879 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 834531"];
5880 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 834532"];
5881 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 834533"];
5882 [label="GlobalImports 834534"];
5883 [label="SourceLocation? location = null; 834535"];
5884 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 834536"];
5885 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 834537"];
5886 [label="Assembly 834538"];
5887 [label="SourceAssembly 834539"];
5888 [label="GetBoundReferenceManager() 834540"];
5889 [label="GetBoundReferenceManager(); 834541"];
5890 [label="Assembly.ForceComplete(location, cancellationToken); 834542"];
5891 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 834543"];
5892 [label="_declarationDiagnosticsFrozen = true; 834544"];
5893 [label="_needsGeneratedAttributes_IsFrozen = true; 834545"];
5894 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 834546"];
5895 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 834547"];
5896 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 834548"];
5897 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 834549"];
5898 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 834550"];
5899 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 834551"];
5900 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 834552"];
5901 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 834553"];
5902 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 834554"];
5903 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 834555"];
5904 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 834556"];
5905 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 834557"];
5906 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 834558"];
5907 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 834559"];
5908 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 834560"];
5909 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 834561"];
5910 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 834562"];
5911 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 834563"];
5912 [label="excludeDiagnostics?.Free(); 834564"];
5913 [label="if (hasDeclarationErrors)\n                {\n                    return false;\n                } 834565"];
5914 [label="if (moduleBeingBuilt.SourceModule.HasBadAttributes)\n                {\n                    // If there were errors but no declaration diagnostics, explicitly add a 'Failed to emit module' error.\n                    diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuilt).Name,\n                        new LocalizableResourceString(nameof(CodeAnalysisResources.ModuleHasInvalidAttributes), CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n\n                    return false;\n                } 834566"];
5915 [label="SynthesizedMetadataCompiler.ProcessSynthesizedMembers(this, moduleBeingBuilt, cancellationToken); 834567"];
5916 [label="SynthesizedMetadataCompiler.ProcessSynthesizedMembers(this, moduleBeingBuilt, cancellationToken) 834568"];
5917 [label="param ProcessSynthesizedMembers(CSharpCompilation compilation) 834569"];
5918 [label="param ProcessSynthesizedMembers(PEModuleBuilder moduleBeingBuilt) 834570"];
5919 [label="param ProcessSynthesizedMembers(CancellationToken cancellationToken) 834571"];
5920 [label="Debug.Assert(moduleBeingBuilt != null); 834572"];
5921 [label="Debug.Assert(moduleBeingBuilt != null); 834573"];
5922 [label="var compiler = new SynthesizedMetadataCompiler(moduleBeingBuilt, cancellationToken); 834574"];
5923 [label="var compiler = new SynthesizedMetadataCompiler(moduleBeingBuilt, cancellationToken); 834575"];
5924 [label="var compiler = new SynthesizedMetadataCompiler(moduleBeingBuilt, cancellationToken); 834576"];
5925 [label="new SynthesizedMetadataCompiler(moduleBeingBuilt, cancellationToken) 834577"];
5926 [label="param SynthesizedMetadataCompiler(PEModuleBuilder moduleBeingBuilt) 834578"];
5927 [label="param SynthesizedMetadataCompiler(CancellationToken cancellationToken) 834579"];
5928 [label="param SynthesizedMetadataCompiler(this) 834580"];
5929 [label="param SynthesizedMetadataCompiler(this) 834581"];
5930 [label="_moduleBeingBuilt 834582"];
5931 [label="Debug.Assert(moduleBeingBuilt != null); 834583"];
5932 [label="Debug.Assert(moduleBeingBuilt != null); 834584"];
5933 [label="_moduleBeingBuilt 834585"];
5934 [label="_cancellationToken 834586"];
5935 [label="compilation.SourceModule 834587"];
5936 [label="get\n            {\n                return Assembly.Modules[0];\n            } 834588"];
5937 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 834589"];
5938 [label="return _referenceManager; 834590"];
5939 [label="GetBoundReferenceManager(); 834591"];
5940 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 834592"];
5941 [label="compiler.Visit(compilation.SourceModule.GlobalNamespace); 834593"];
5942 [label="compiler.Visit(compilation.SourceModule.GlobalNamespace); 834594"];
5943 [label="compiler.Visit(compilation.SourceModule.GlobalNamespace); 834595"];
5944 [label="param VisitNamespace(NamespaceSymbol symbol) 834596"];
5945 [label="param VisitNamespace(this) 834597"];
5946 [label="_cancellationToken.ThrowIfCancellationRequested(); 834598"];
5947 [label="foreach (var s in symbol.GetMembers())\n            {\n                s.Accept(this);\n            } 834599"];
5948 [label="s.Accept(this); 834600"];
5949 [label="s.Accept(this); 834601"];
5950 [label="param VisitNamedType(NamedTypeSymbol symbol) 834602"];
5951 [label="param VisitNamedType(this) 834603"];
5952 [label="_cancellationToken.ThrowIfCancellationRequested(); 834604"];
5953 [label="var sourceTypeSymbol = symbol as SourceMemberContainerTypeSymbol; 834605"];
5954 [label="if ((object)sourceTypeSymbol != null)\n            {\n                if (_moduleBeingBuilt != null)\n                {\n                    // In some circumstances (e.g. implicit implementation of an interface method by a non-virtual method in a\n                    // base type from another assembly) it is necessary for the compiler to generate explicit implementations for\n                    // some interface methods.  They don't go in the symbol table, but if we are emitting metadata, then we should\n                    // generate MethodDef entries for them.\n                    foreach (var synthesizedExplicitImpl in sourceTypeSymbol.GetSynthesizedExplicitImplementations(_cancellationToken))\n                    {\n                        _moduleBeingBuilt.AddSynthesizedDefinition(symbol, synthesizedExplicitImpl.GetCciAdapter());\n                    }\n                }\n            } 834606"];
5955 [label="if ((object)sourceTypeSymbol != null)\n            {\n                if (_moduleBeingBuilt != null)\n                {\n                    // In some circumstances (e.g. implicit implementation of an interface method by a non-virtual method in a\n                    // base type from another assembly) it is necessary for the compiler to generate explicit implementations for\n                    // some interface methods.  They don't go in the symbol table, but if we are emitting metadata, then we should\n                    // generate MethodDef entries for them.\n                    foreach (var synthesizedExplicitImpl in sourceTypeSymbol.GetSynthesizedExplicitImplementations(_cancellationToken))\n                    {\n                        _moduleBeingBuilt.AddSynthesizedDefinition(symbol, synthesizedExplicitImpl.GetCciAdapter());\n                    }\n                }\n            } 834607"];
5956 [label="if (_moduleBeingBuilt != null)\n                {\n                    // In some circumstances (e.g. implicit implementation of an interface method by a non-virtual method in a\n                    // base type from another assembly) it is necessary for the compiler to generate explicit implementations for\n                    // some interface methods.  They don't go in the symbol table, but if we are emitting metadata, then we should\n                    // generate MethodDef entries for them.\n                    foreach (var synthesizedExplicitImpl in sourceTypeSymbol.GetSynthesizedExplicitImplementations(_cancellationToken))\n                    {\n                        _moduleBeingBuilt.AddSynthesizedDefinition(symbol, synthesizedExplicitImpl.GetCciAdapter());\n                    }\n                } 834608"];
5957 [label="if (_moduleBeingBuilt != null)\n                {\n                    // In some circumstances (e.g. implicit implementation of an interface method by a non-virtual method in a\n                    // base type from another assembly) it is necessary for the compiler to generate explicit implementations for\n                    // some interface methods.  They don't go in the symbol table, but if we are emitting metadata, then we should\n                    // generate MethodDef entries for them.\n                    foreach (var synthesizedExplicitImpl in sourceTypeSymbol.GetSynthesizedExplicitImplementations(_cancellationToken))\n                    {\n                        _moduleBeingBuilt.AddSynthesizedDefinition(symbol, synthesizedExplicitImpl.GetCciAdapter());\n                    }\n                } 834609"];
5958 [label="foreach (var synthesizedExplicitImpl in sourceTypeSymbol.GetSynthesizedExplicitImplementations(_cancellationToken))\n                    {\n                        _moduleBeingBuilt.AddSynthesizedDefinition(symbol, synthesizedExplicitImpl.GetCciAdapter());\n                    } 834610"];
5959 [label="foreach (Symbol member in symbol.GetMembers())\n            {\n                switch (member.Kind)\n                {\n                    case SymbolKind.Property:\n                    case SymbolKind.NamedType:\n                        member.Accept(this);\n                        break;\n                }\n            } 834611"];
5960 [label="return true; 834612"];
5961 [label="this.SourceModule 834613"];
5962 [label="Assembly 834614"];
5963 [label="SourceAssembly 834615"];
5964 [label="GetBoundReferenceManager() 834616"];
5965 [label="GetBoundReferenceManager(); 834617"];
5966 [label="return Assembly.Modules[0]; 834618"];
5967 [label="SourceAssembly 834619"];
5968 [label="GetBoundReferenceManager() 834620"];
5969 [label="GetBoundReferenceManager(); 834621"];
5970 [label="SourceAssembly.IsDelaySigned 834622"];
5971 [label="SourceAssembly 834623"];
5972 [label="GetBoundReferenceManager() 834624"];
5973 [label="GetBoundReferenceManager(); 834625"];
5974 [label="param GetCorLibraryReferenceToEmit(CodeAnalysis.Emit.EmitContext context) 834626"];
5975 [label="CorLibrary 834627"];
5976 [label="return Translate(corLibrary, context.Diagnostics); 834628"];
5977 [label="param Translate(DiagnosticBag diagnostics) 834629"];
5978 [label="if (ReferenceEquals(SourceModule.ContainingAssembly, assembly))\n            {\n                return (Cci.IAssemblyReference)this;\n            } 834630"];
5979 [label="_targetAssembly 834631"];
5980 [label="Debug.Assert((object)assemblySymbol != null); 834632"];
5981 [label="if (cachedAsmRef == asmRef)\n            {\n                ValidateReferencedAssembly(assembly, cachedAsmRef, diagnostics);\n            } 834633"];
5982 [label="ValidateReferencedAssembly(assembly, cachedAsmRef, diagnostics); 834634"];
5983 [label="ValidateReferencedAssembly(assembly, cachedAsmRef, diagnostics); 834635"];
5984 [label="ValidateReferencedAssembly(assembly, cachedAsmRef, diagnostics) 834636"];
5985 [label="param ValidateReferencedAssembly(AssemblySymbol assembly) 834637"];
5986 [label="param ValidateReferencedAssembly(AssemblyReference asmRef) 834638"];
5987 [label="param ValidateReferencedAssembly(DiagnosticBag diagnostics) 834639"];
5988 [label="param ValidateReferencedAssembly(this) 834640"];
5989 [label="AssemblyIdentity asmIdentity = SourceModule.ContainingAssembly.Identity; 834641"];
5990 [label="asmRef.Identity 834642"];
5991 [label="=> _targetAssembly.Identity 834643"];
5992 [label="AssemblyIdentity refIdentity = asmRef.Identity; 834644"];
5993 [label="if (asmIdentity.IsStrongName && !refIdentity.IsStrongName &&\n                asmRef.Identity.ContentType != AssemblyContentType.WindowsRuntime)\n            {\n                // Dev12 reported error, we have changed it to a warning to allow referencing libraries \n                // built for platforms that don't support strong names.\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName, assembly), NoLocation.Singleton);\n            } 834645"];
5994 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 834646"];
5995 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 834647"];
5996 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 834648"];
5997 [label="var refMachine = assembly.Machine; 834649"];
5998 [label="if ((object)assembly != (object)assembly.CorLibrary &&\n                !(refMachine == Machine.I386 && !assembly.Bit32Required))\n            {\n                var machine = SourceModule.Machine;\n\n                if (!(machine == Machine.I386 && !SourceModule.Bit32Required) &&\n                    machine != refMachine)\n                {\n                    // Different machine types, and neither is agnostic\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_ConflictingMachineAssembly, assembly), NoLocation.Singleton);\n                }\n            } 834650"];
5999 [label="if (_embeddedTypesManagerOpt != null && _embeddedTypesManagerOpt.IsFrozen)\n            {\n                _embeddedTypesManagerOpt.ReportIndirectReferencesToLinkedAssemblies(assembly, diagnostics);\n            } 834651"];
6000 [label="if (_embeddedTypesManagerOpt != null && _embeddedTypesManagerOpt.IsFrozen)\n            {\n                _embeddedTypesManagerOpt.ReportIndirectReferencesToLinkedAssemblies(assembly, diagnostics);\n            } 834652"];
6001 [label="ValidateReferencedAssembly(assembly, cachedAsmRef, diagnostics); 834653"];
6002 [label="param GetAssemblyReferencesFromAddedModules(DiagnosticBag diagnostics) 834654"];
6003 [label="ImmutableArray<ModuleSymbol> modules = SourceModule.ContainingAssembly.Modules; 834655"];
6004 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 834656"];
6005 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 834657"];
6006 [label="param GetAssemblyReferencesFromAddedModules(this) 834658"];
6007 [label="var modules = sourceAssSymbol.Modules; 834659"];
6008 [label="for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        } 834660"];
6009 [label="for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        } 834661"];
6010 [label="if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        } 834662"];
6011 [label="foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            } 834663"];
6012 [label="param GetAnonymousTypeDefinitions(EmitContext context) 834664"];
6013 [label="if (context.MetadataOnly)\n            {\n                return SpecializedCollections.EmptyEnumerable<Cci.INamespaceTypeDefinition>();\n            } 834665"];
6014 [label="return SpecializedCollections.EmptyEnumerable<Cci.INamespaceTypeDefinition>(); 834666"];
6015 [label="param GetAdditionalTopLevelTypeDefinitions(EmitContext context) 834667"];
6016 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 834668"];
6017 [label="GetAdditionalTopLevelTypes(context.Diagnostics) 834669"];
6018 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 834670"];
6019 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 834671"];
6020 [label="param GetEmbeddedTypeDefinitions(EmitContext context) 834672"];
6021 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 834673"];
6022 [label="GetEmbeddedTypes(context.Diagnostics) 834674"];
6023 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 834675"];
6024 [label="var builder = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 834676"];
6025 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 834677"];
6026 [label="CreateEmbeddedAttributesIfNeeded(diagnostics) 834678"];
6027 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 834679"];
6028 [label="GetNeedsGeneratedAttributes() 834680"];
6029 [label="_needsGeneratedAttributes_IsFrozen = true; 834681"];
6030 [label="GetNeedsGeneratedAttributesInternal() 834682"];
6031 [label="return GetNeedsGeneratedAttributesInternal(); 834683"];
6032 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 834684"];
6033 [label="ShouldEmitNullablePublicOnlyAttribute() 834685"];
6034 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 834686"];
6035 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 834687"];
6036 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 834688"];
6037 [label="return; 834689"];
6038 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 834690"];
6039 [label="builder.AddIfNotNull(_lazyEmbeddedAttribute); 834691"];
6040 [label="builder.AddIfNotNull(_lazyIsReadOnlyAttribute); 834692"];
6041 [label="builder.AddIfNotNull(_lazyIsUnmanagedAttribute); 834693"];
6042 [label="builder.AddIfNotNull(_lazyIsByRefLikeAttribute); 834694"];
6043 [label="builder.AddIfNotNull(_lazyNullableAttribute); 834695"];
6044 [label="builder.AddIfNotNull(_lazyNullableContextAttribute); 834696"];
6045 [label="builder.AddIfNotNull(_lazyNullablePublicOnlyAttribute); 834697"];
6046 [label="builder.AddIfNotNull(_lazyNativeIntegerAttribute); 834698"];
6047 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 834699"];
6048 [label="param GetTopLevelSourceTypeDefinitions(EmitContext context) 834700"];
6049 [label="var namespacesToProcess = new Stack<NamespaceSymbol>(); 834701"];
6050 [label="while (namespacesToProcess.Count > 0)\n            {\n                var ns = namespacesToProcess.Pop();\n                foreach (var member in ns.GetMembers())\n                {\n                    if (member.Kind == SymbolKind.Namespace)\n                    {\n                        namespacesToProcess.Push((NamespaceSymbol)member);\n                    }\n                    else\n                    {\n                        yield return ((NamedTypeSymbol)member).GetCciAdapter();\n                    }\n                }\n            } 834702"];
6051 [label="param GetSynthesizedNestedTypes(NamedTypeSymbol container) 834703"];
6052 [label="param GetSynthesizedNestedTypes(this) 834704"];
6053 [label="return null; 834705"];
6054 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 834706"];
6055 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 834707"];
6056 [label="NamedTypeSymbol result; 834708"];
6057 [label="GetBoundReferenceManager(); 834709"];
6058 [label="Debug.Assert(result.SpecialType == specialType); 834710"];
6059 [label="SourceAssembly 834711"];
6060 [label="GetBoundReferenceManager() 834712"];
6061 [label="GetBoundReferenceManager(); 834713"];
6062 [label="GetBoundReferenceManager() 834714"];
6063 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 834715"];
6064 [label="param Translate(SyntaxNode syntaxNodeOpt) 834716"];
6065 [label="param Translate(DiagnosticBag diagnostics) 834717"];
6066 [label="param Translate(bool needDeclaration = false) 834718"];
6067 [label="param Translate(this) 834719"];
6068 [label="Debug.Assert(optArgList == null || (methodSymbol.IsVararg && !needDeclaration)); 834720"];
6069 [label="Debug.Assert(optArgList == null || (methodSymbol.IsVararg && !needDeclaration)); 834721"];
6070 [label="Translate(methodSymbol, syntaxNodeOpt, diagnostics, needDeclaration) 834722"];
6071 [label="param Translate(SyntaxNode syntaxNodeOpt) 834723"];
6072 [label="param Translate(DiagnosticBag diagnostics) 834724"];
6073 [label="param Translate(bool needDeclaration) 834725"];
6074 [label="param Translate(this) 834726"];
6075 [label="object reference; 834727"];
6076 [label="Cci.IMethodReference methodRef; 834728"];
6077 [label="NamedTypeSymbol container = methodSymbol.ContainingType; 834729"];
6078 [label="if (container.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                methodSymbol = AnonymousTypeManager.TranslateAnonymousTypeMethodSymbol(methodSymbol);\n            } 834730"];
6079 [label="if (!methodSymbol.IsDefinition)\n            {\n                Debug.Assert(!needDeclaration);\n                Debug.Assert(!(methodSymbol.OriginalDefinition is NativeIntegerMethodSymbol));\n                Debug.Assert(!(methodSymbol.ConstructedFrom is NativeIntegerMethodSymbol));\n\n                return (Cci.IMethodReference)GetCciAdapter(methodSymbol);\n            }\n            else if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 834731"];
6080 [label="if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 834732"];
6081 [label="bool methodIsGeneric = methodSymbol.IsGenericMethod; 834733"];
6082 [label="bool typeIsGeneric = IsGenericType(container); 834734"];
6083 [label="IsGenericType(container) 834735"];
6084 [label="param IsGenericType(NamedTypeSymbol toCheck) 834736"];
6085 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834737"];
6086 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834738"];
6087 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 834739"];
6088 [label="toCheck = toCheck.ContainingType; 834740"];
6089 [label="return false; 834741"];
6090 [label="bool typeIsGeneric = IsGenericType(container); 834742"];
6091 [label="if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 834743"];
6092 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 834744"];
6093 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 834745"];
6094 [label="if (_embeddedTypesManagerOpt != null)\n            {\n                return _embeddedTypesManagerOpt.EmbedMethodIfNeedTo(methodSymbol.GetCciAdapter(), syntaxNodeOpt, diagnostics);\n            } 834746"];
6095 [label="if (_embeddedTypesManagerOpt != null)\n            {\n                return _embeddedTypesManagerOpt.EmbedMethodIfNeedTo(methodSymbol.GetCciAdapter(), syntaxNodeOpt, diagnostics);\n            } 834747"];
6096 [label="if (optArgList != null && optArgList.Arguments.Length > 0)\n            {\n                Cci.IParameterTypeInformation[] @params = new Cci.IParameterTypeInformation[optArgList.Arguments.Length];\n                int ordinal = methodSymbol.ParameterCount;\n\n                for (int i = 0; i < @params.Length; i++)\n                {\n                    @params[i] = new ArgListParameterTypeInformation(ordinal,\n                                                                    !optArgList.ArgumentRefKindsOpt.IsDefaultOrEmpty && optArgList.ArgumentRefKindsOpt[i] != RefKind.None,\n                                                                    Translate(optArgList.Arguments[i].Type, syntaxNodeOpt, diagnostics));\n                    ordinal++;\n                }\n\n                return new ExpandedVarargsMethodReference(unexpandedMethodRef, @params.AsImmutableOrNull());\n            }\n            else\n            {\n                return unexpandedMethodRef;\n            } 834748"];
6097 [label="param Translate(SyntaxNode syntaxNodeOpt) 834749"];
6098 [label="param Translate(DiagnosticBag diagnostics) 834750"];
6099 [label="Debug.Assert(diagnostics != null); 834751"];
6100 [label="Debug.Assert(diagnostics != null); 834752"];
6101 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 834753"];
6102 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 834754"];
6103 [label="param Translate(SyntaxNode syntaxNodeOpt) 834755"];
6104 [label="param Translate(DiagnosticBag diagnostics) 834756"];
6105 [label="param Translate(bool fromImplements = false) 834757"];
6106 [label="param Translate(bool needDeclaration = false) 834758"];
6107 [label="Debug.Assert(diagnostics != null); 834759"];
6108 [label="Debug.Assert(diagnostics != null); 834760"];
6109 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 834761"];
6110 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 834762"];
6111 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 834763"];
6112 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 834764"];
6113 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 834765"];
6114 [label="object reference; 834766"];
6115 [label="Cci.INamedTypeReference typeRef; 834767"];
6116 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 834768"];
6117 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 834769"];
6118 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 834770"];
6119 [label="IsGenericType(container) 834771"];
6120 [label="param IsGenericType(NamedTypeSymbol toCheck) 834772"];
6121 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834773"];
6122 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834774"];
6123 [label="return false; 834775"];
6124 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 834776"];
6125 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 834777"];
6126 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 834778"];
6127 [label="param Translate(SyntaxNode syntaxNodeOpt) 834779"];
6128 [label="param Translate(DiagnosticBag diagnostics) 834780"];
6129 [label="param Translate(bool fromImplements = false) 834781"];
6130 [label="param Translate(bool needDeclaration = false) 834782"];
6131 [label="Debug.Assert(diagnostics != null); 834783"];
6132 [label="Debug.Assert(diagnostics != null); 834784"];
6133 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 834785"];
6134 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 834786"];
6135 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 834787"];
6136 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 834788"];
6137 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 834789"];
6138 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 834790"];
6139 [label="param Translate(DiagnosticBag diagnostics) 834791"];
6140 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 834792"];
6141 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 834793"];
6142 [label="if ((object)module == null)\n            {\n                return null;\n            } 834794"];
6143 [label="if ((object)module == null)\n            {\n                return null;\n            } 834795"];
6144 [label="Cci.IModuleReference moduleRef; 834796"];
6145 [label="if (AssemblyOrModuleSymbolToModuleRefMap.TryGetValue(module, out moduleRef))\n            {\n                return moduleRef;\n            } 834797"];
6146 [label="param Translate(this) 834798"];
6147 [label="Debug.Assert(@params.All(p => p.IsDefinitionOrDistinct())); 834799"];
6148 [label="MustBeWrapped(@params.First()) 834800"];
6149 [label="param MustBeWrapped(ParameterSymbol param) 834801"];
6150 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 834802"];
6151 [label="var container = param.ContainingSymbol; 834803"];
6152 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 834804"];
6153 [label="ContainerIsGeneric(container) 834805"];
6154 [label="param ContainerIsGeneric(Symbol container) 834806"];
6155 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 834807"];
6156 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 834808"];
6157 [label="IsGenericType(container.ContainingType) 834809"];
6158 [label="param IsGenericType(NamedTypeSymbol toCheck) 834810"];
6159 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834811"];
6160 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834812"];
6161 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 834813"];
6162 [label="toCheck = toCheck.ContainingType; 834814"];
6163 [label="return false; 834815"];
6164 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 834816"];
6165 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 834817"];
6166 [label="return false; 834818"];
6167 [label="bool mustBeTranslated = @params.Any() && MustBeWrapped(@params.First()); 834819"];
6168 [label="Debug.Assert(@params.All(p => mustBeTranslated == MustBeWrapped(p)), 'either all or no parameters need translating'); 834820"];
6169 [label="param MustBeWrapped(ParameterSymbol param) 834821"];
6170 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 834822"];
6171 [label="var container = param.ContainingSymbol; 834823"];
6172 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 834824"];
6173 [label="ContainerIsGeneric(container) 834825"];
6174 [label="param ContainerIsGeneric(Symbol container) 834826"];
6175 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 834827"];
6176 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 834828"];
6177 [label="IsGenericType(container.ContainingType) 834829"];
6178 [label="param IsGenericType(NamedTypeSymbol toCheck) 834830"];
6179 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834831"];
6180 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834832"];
6181 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 834833"];
6182 [label="toCheck = toCheck.ContainingType; 834834"];
6183 [label="return false; 834835"];
6184 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 834836"];
6185 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 834837"];
6186 [label="return false; 834838"];
6187 [label="if ((object)namedType != null)\n            {\n                if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                }\n\n                return namedType.SpecialType == (SpecialType)platformType;\n            } 834839"];
6188 [label="NamedTypeSymbol container = methodSymbol.ContainingType; 834840"];
6189 [label="if (container.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                methodSymbol = AnonymousTypeManager.TranslateAnonymousTypeMethodSymbol(methodSymbol);\n            } 834841"];
6190 [label="Debug.Assert(methodSymbol.IsDefinitionOrDistinct()); 834842"];
6191 [label="if (!methodSymbol.IsDefinition)\n            {\n                Debug.Assert(!needDeclaration);\n                Debug.Assert(!(methodSymbol.OriginalDefinition is NativeIntegerMethodSymbol));\n                Debug.Assert(!(methodSymbol.ConstructedFrom is NativeIntegerMethodSymbol));\n\n                return (Cci.IMethodReference)GetCciAdapter(methodSymbol);\n            }\n            else if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 834843"];
6192 [label="if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 834844"];
6193 [label="bool methodIsGeneric = methodSymbol.IsGenericMethod; 834845"];
6194 [label="bool typeIsGeneric = IsGenericType(container); 834846"];
6195 [label="IsGenericType(container) 834847"];
6196 [label="param IsGenericType(NamedTypeSymbol toCheck) 834848"];
6197 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834849"];
6198 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834850"];
6199 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 834851"];
6200 [label="toCheck = toCheck.ContainingType; 834852"];
6201 [label="return false; 834853"];
6202 [label="bool typeIsGeneric = IsGenericType(container); 834854"];
6203 [label="if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 834855"];
6204 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 834856"];
6205 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 834857"];
6206 [label="if (_embeddedTypesManagerOpt != null)\n            {\n                return _embeddedTypesManagerOpt.EmbedMethodIfNeedTo(methodSymbol.GetCciAdapter(), syntaxNodeOpt, diagnostics);\n            } 834858"];
6207 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 834859"];
6208 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 834860"];
6209 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 834861"];
6210 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 834862"];
6211 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 834863"];
6212 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 834864"];
6213 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 834865"];
6214 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 834866"];
6215 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 834867"];
6216 [label="param Translate(SyntaxNode syntaxNodeOpt) 834868"];
6217 [label="param Translate(DiagnosticBag diagnostics) 834869"];
6218 [label="param Translate(bool fromImplements = false) 834870"];
6219 [label="param Translate(bool needDeclaration = false) 834871"];
6220 [label="Debug.Assert(diagnostics != null); 834872"];
6221 [label="Debug.Assert(diagnostics != null); 834873"];
6222 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 834874"];
6223 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 834875"];
6224 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 834876"];
6225 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 834877"];
6226 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 834878"];
6227 [label="object reference; 834879"];
6228 [label="Cci.INamedTypeReference typeRef; 834880"];
6229 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 834881"];
6230 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 834882"];
6231 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 834883"];
6232 [label="IsGenericType(container) 834884"];
6233 [label="param IsGenericType(NamedTypeSymbol toCheck) 834885"];
6234 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834886"];
6235 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834887"];
6236 [label="return false; 834888"];
6237 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 834889"];
6238 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 834890"];
6239 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 834891"];
6240 [label="NamedTypeSymbol container = methodSymbol.ContainingType; 834892"];
6241 [label="if (container.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                methodSymbol = AnonymousTypeManager.TranslateAnonymousTypeMethodSymbol(methodSymbol);\n            } 834893"];
6242 [label="bool typeIsGeneric = IsGenericType(container); 834894"];
6243 [label="param IsGenericType(NamedTypeSymbol toCheck) 834895"];
6244 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834896"];
6245 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 834897"];
6246 [label="toCheck = toCheck.ContainingType; 834898"];
6247 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 834899"];
6248 [label="toCheck = toCheck.ContainingType; 834900"];
6249 [label="param MustBeWrapped(ParameterSymbol param) 834901"];
6250 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 834902"];
6251 [label="var container = param.ContainingSymbol; 834903"];
6252 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 834904"];
6253 [label="ContainerIsGeneric(container) 834905"];
6254 [label="param ContainerIsGeneric(Symbol container) 834906"];
6255 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 834907"];
6256 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 834908"];
6257 [label="IsGenericType(container.ContainingType) 834909"];
6258 [label="param IsGenericType(NamedTypeSymbol toCheck) 834910"];
6259 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834911"];
6260 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834912"];
6261 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 834913"];
6262 [label="toCheck = toCheck.ContainingType; 834914"];
6263 [label="return false; 834915"];
6264 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 834916"];
6265 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 834917"];
6266 [label="param MustBeWrapped(ParameterSymbol param) 834918"];
6267 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 834919"];
6268 [label="var container = param.ContainingSymbol; 834920"];
6269 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 834921"];
6270 [label="ContainerIsGeneric(container) 834922"];
6271 [label="param ContainerIsGeneric(Symbol container) 834923"];
6272 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 834924"];
6273 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 834925"];
6274 [label="IsGenericType(container.ContainingType) 834926"];
6275 [label="param IsGenericType(NamedTypeSymbol toCheck) 834927"];
6276 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834928"];
6277 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 834929"];
6278 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 834930"];
6279 [label="toCheck = toCheck.ContainingType; 834931"];
6280 [label="return false; 834932"];
6281 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 834933"];
6282 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 834934"];
6283 [label="return SourceModule.ContainingSourceAssembly.GetSecurityAttributes(); 834935"];
6284 [label="return Translate(corLibrary, context.Diagnostics); 834936"];
6285 [label="param Translate(DiagnosticBag diagnostics) 834937"];
6286 [label="if (ReferenceEquals(SourceModule.ContainingAssembly, assembly))\n            {\n                return (Cci.IAssemblyReference)this;\n            } 834938"];
6287 [label="ImmutableArray<ModuleSymbol> modules = SourceModule.ContainingAssembly.Modules; 834939"];
6288 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 834940"];
6289 [label="return SourceModule.GetCustomAttributesToEmit(this); 834941"];
6290 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 834942"];
6291 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 834943"];
6292 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 834944"];
6293 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 834945"];
6294 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 834946"];
6295 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 834947"];
6296 [label="return GetNeedsGeneratedAttributesInternal(); 834948"];
6297 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 834949"];
6298 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 834950"];
6299 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 834951"];
6300 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 834952"];
6301 [label="return; 834953"];
6302 [label="Debug.Assert(symbol.IsDefinition); 834954"];
6303 [label="SourceModule 834955"];
6304 [label="Assembly 834956"];
6305 [label="SourceAssembly 834957"];
6306 [label="GetBoundReferenceManager() 834958"];
6307 [label="GetBoundReferenceManager(); 834959"];
6308 [label="return Assembly.Modules[0]; 834960"];
6309 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 834961"];
6310 [label="EmitNullablePublicOnly 834962"];
6311 [label="param SynthesizeNullableAttributeIfNecessary(this) 834963"];
6312 [label="param GetExportedTypes(DiagnosticBag diagnostics) 834964"];
6313 [label="Debug.Assert(HaveDeterminedTopLevelTypes); 834965"];
6314 [label="if (!OutputKind.IsNetModule())\n            {\n                var modules = sourceAssembly.Modules;\n                for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                }\n            } 834966"];
6315 [label="var modules = sourceAssembly.Modules; 834967"];
6316 [label="for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                } 834968"];
6317 [label="for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                } 834969"];
6318 [label="Debug.Assert(OutputKind.IsNetModule() == sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule()); 834970"];
6319 [label="sourceAssembly.DeclaringCompilation.Options 834971"];
6320 [label="Debug.Assert(OutputKind.IsNetModule() == sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule()); 834972"];
6321 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 834973"];
6322 [label="var seenTopLevelForwardedTypes = new HashSet<NamedTypeSymbol>(); 834974"];
6323 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder) 834975"];
6324 [label="param GetForwardedTypes(HashSet<NamedTypeSymbol> seenTopLevelTypes) 834976"];
6325 [label="param GetForwardedTypes(CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData) 834977"];
6326 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 834978"];
6327 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 834979"];
6328 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 834980"];
6329 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder); 834981"];
6330 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder) 834982"];
6331 [label="param GetForwardedTypes(HashSet<NamedTypeSymbol> seenTopLevelTypes) 834983"];
6332 [label="param GetForwardedTypes(CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData) 834984"];
6333 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 834985"];
6334 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 834986"];
6335 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 834987"];
6336 [label="return seenTopLevelForwardedTypes; 834988"];
6337 [label="if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                } 834989"];
6338 [label="if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                } 834990"];
6339 [label="param AddEmbeddedResourcesFromAddedModules(ArrayBuilder<Cci.ManagedResource> builder) 834991"];
6340 [label="param AddEmbeddedResourcesFromAddedModules(DiagnosticBag diagnostics) 834992"];
6341 [label="param AddEmbeddedResourcesFromAddedModules(this) 834993"];
6342 [label="var modules = _sourceAssembly.Modules; 834994"];
6343 [label="int count = modules.Length; 834995"];
6344 [label="for (int i = 1; i < count; i++)\n            {\n                var file = (Cci.IFileReference)Translate(modules[i], diagnostics);\n\n                try\n                {\n                    foreach (EmbeddedResource resource in ((Symbols.Metadata.PE.PEModuleSymbol)modules[i]).Module.GetEmbeddedResourcesOrThrow())\n                    {\n                        builder.Add(new Cci.ManagedResource(\n                            resource.Name,\n                            (resource.Attributes & ManifestResourceAttributes.Public) != 0,\n                            null,\n                            file,\n                            resource.Offset));\n                    }\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, modules[i]), NoLocation.Singleton);\n                }\n            } 834996"];
6345 [label="for (int i = 1; i < count; i++)\n            {\n                var file = (Cci.IFileReference)Translate(modules[i], diagnostics);\n\n                try\n                {\n                    foreach (EmbeddedResource resource in ((Symbols.Metadata.PE.PEModuleSymbol)modules[i]).Module.GetEmbeddedResourcesOrThrow())\n                    {\n                        builder.Add(new Cci.ManagedResource(\n                            resource.Name,\n                            (resource.Attributes & ManifestResourceAttributes.Public) != 0,\n                            null,\n                            file,\n                            resource.Offset));\n                    }\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, modules[i]), NoLocation.Singleton);\n                }\n            } 834997"];
6346 [label="=> ImmutableArray<Cci.UsedNamespaceOrType>.Empty 834998"];
6347 [label="ImmutableArray<Cci.UsedNamespaceOrType>.Empty 834999"];
6348 [label="Debug.Assert(HaveDeterminedTopLevelTypes); 835000"];
6349 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 835001"];
6350 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 835002"];
6351 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 835003"];
6352 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 835004"];
6353 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 835005"];
6354 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 835006"];
6355 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 835007"];
6356 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 835008"];
6357 [label="GetBoundReferenceManager(); 835009"];
6358 [label="Debug.Assert(result.SpecialType == specialType); 835010"];
6359 [label="NamedTypeSymbol container = methodSymbol.ContainingType; 835011"];
6360 [label="if (container.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                methodSymbol = AnonymousTypeManager.TranslateAnonymousTypeMethodSymbol(methodSymbol);\n            } 835012"];
6361 [label="if (!methodSymbol.IsDefinition)\n            {\n                Debug.Assert(!needDeclaration);\n                Debug.Assert(!(methodSymbol.OriginalDefinition is NativeIntegerMethodSymbol));\n                Debug.Assert(!(methodSymbol.ConstructedFrom is NativeIntegerMethodSymbol));\n\n                return (Cci.IMethodReference)GetCciAdapter(methodSymbol);\n            }\n            else if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 835013"];
6362 [label="if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 835014"];
6363 [label="bool methodIsGeneric = methodSymbol.IsGenericMethod; 835015"];
6364 [label="bool typeIsGeneric = IsGenericType(container); 835016"];
6365 [label="IsGenericType(container) 835017"];
6366 [label="param IsGenericType(NamedTypeSymbol toCheck) 835018"];
6367 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 835019"];
6368 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 835020"];
6369 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 835021"];
6370 [label="toCheck = toCheck.ContainingType; 835022"];
6371 [label="return false; 835023"];
6372 [label="bool typeIsGeneric = IsGenericType(container); 835024"];
6373 [label="if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 835025"];
6374 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 835026"];
6375 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 835027"];
6376 [label="if (_embeddedTypesManagerOpt != null)\n            {\n                return _embeddedTypesManagerOpt.EmbedMethodIfNeedTo(methodSymbol.GetCciAdapter(), syntaxNodeOpt, diagnostics);\n            } 835028"];
6377 [label="param MustBeWrapped(ParameterSymbol param) 835029"];
6378 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 835030"];
6379 [label="var container = param.ContainingSymbol; 835031"];
6380 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 835032"];
6381 [label="ContainerIsGeneric(container) 835033"];
6382 [label="param ContainerIsGeneric(Symbol container) 835034"];
6383 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 835035"];
6384 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 835036"];
6385 [label="IsGenericType(container.ContainingType) 835037"];
6386 [label="param IsGenericType(NamedTypeSymbol toCheck) 835038"];
6387 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 835039"];
6388 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 835040"];
6389 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 835041"];
6390 [label="toCheck = toCheck.ContainingType; 835042"];
6391 [label="return false; 835043"];
6392 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 835044"];
6393 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 835045"];
6394 [label="param MustBeWrapped(ParameterSymbol param) 835046"];
6395 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 835047"];
6396 [label="var container = param.ContainingSymbol; 835048"];
6397 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 835049"];
6398 [label="ContainerIsGeneric(container) 835050"];
6399 [label="param ContainerIsGeneric(Symbol container) 835051"];
6400 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 835052"];
6401 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 835053"];
6402 [label="IsGenericType(container.ContainingType) 835054"];
6403 [label="param IsGenericType(NamedTypeSymbol toCheck) 835055"];
6404 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 835056"];
6405 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 835057"];
6406 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 835058"];
6407 [label="toCheck = toCheck.ContainingType; 835059"];
6408 [label="return false; 835060"];
6409 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 835061"];
6410 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 835062"];
6411 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 835063"];
6412 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 835064"];
6413 [label="param Translate(SyntaxNode syntaxNodeOpt) 835065"];
6414 [label="param Translate(DiagnosticBag diagnostics) 835066"];
6415 [label="param Translate(bool fromImplements = false) 835067"];
6416 [label="param Translate(bool needDeclaration = false) 835068"];
6417 [label="Debug.Assert(diagnostics != null); 835069"];
6418 [label="Debug.Assert(diagnostics != null); 835070"];
6419 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 835071"];
6420 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 835072"];
6421 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 835073"];
6422 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 835074"];
6423 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 835075"];
6424 [label="object reference; 835076"];
6425 [label="Cci.INamedTypeReference typeRef; 835077"];
6426 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 835078"];
6427 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 835079"];
6428 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 835080"];
6429 [label="IsGenericType(container) 835081"];
6430 [label="param IsGenericType(NamedTypeSymbol toCheck) 835082"];
6431 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 835083"];
6432 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 835084"];
6433 [label="return false; 835085"];
6434 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 835086"];
6435 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 835087"];
6436 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 835088"];
6437 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 835089"];
6438 [label="toCheck = toCheck.ContainingType; 835090"];
6439 [label="Debug.Assert(symbol.IsDefinition); 835091"];
6440 [label="GetBoundReferenceManager(); 835092"];
6441 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 835093"];
6442 [label="var result = new MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation>(); 835094"];
6443 [label="var namespacesAndTypesToProcess = new Stack<NamespaceOrTypeSymbol>(); 835095"];
6444 [label="Location location = null; 835096"];
6445 [label="while (namespacesAndTypesToProcess.Count > 0)\n            {\n                NamespaceOrTypeSymbol symbol = namespacesAndTypesToProcess.Pop();\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Namespace:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n\n                        // filtering out synthesized symbols not having real source \n                        // locations such as anonymous types, etc...\n                        if (location != null)\n                        {\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    case SymbolKind.NamedType:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n                        if (location != null)\n                        {\n                            //  add this named type location\n                            AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n                }\n            } 835097"];
6446 [label="param GetSmallestSourceLocationOrNull(this) 835098"];
6447 [label="CSharpCompilation compilation = symbol.DeclaringCompilation; 835099"];
6448 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 835100"];
6449 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 835101"];
6450 [label="param AddSymbolLocation(MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation> result) 835102"];
6451 [label="param AddSymbolLocation(Cci.IDefinition definition) 835103"];
6452 [label="if (doc != null)\n            {\n                result.Add(doc,\n                           new Cci.DefinitionWithLocation(\n                               definition,\n                               span.StartLinePosition.Line,\n                               span.StartLinePosition.Character,\n                               span.EndLinePosition.Line,\n                               span.EndLinePosition.Character));\n            } 835104"];
6453 [label="foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            } 835105"];
6454 [label="return result; 835106"];
6455 [label="GetBoundReferenceManager(); 835107"];
6456 [label="CustomAssert.True(emitResult.Success, 'Diagnostics:\\r\\n' + string.Join('\\r\\n', emitResult.Diagnostics.Select(d => d.ToString()))); 835108"];
6457 [label="CustomAssert.True(emitResult.Success, 'Diagnostics:\\r\\n' + string.Join('\\r\\n', emitResult.Diagnostics.Select(d => d.ToString()))); 835109"];
6458 [label="if (expectedWarnings != null)\n            {\n                emitResult.Diagnostics.Verify(expectedWarnings);\n            } 835110"];
6459 [label="if (expectedWarnings != null)\n            {\n                emitResult.Diagnostics.Verify(expectedWarnings);\n            } 835111"];
6460 [label="return peStream.ToImmutable(); 835112"];
6461 [label="comp.Options 835113"];
6462 [label="var comp = CreateCompilation(source, references: new[] { libImage },\n                options: TestOptions.DebugDll.WithAllowUnsafe(true)); 835114"];
6463 [label="var comp = CreateCompilation(source, references: new[] { libImage },\n                options: TestOptions.DebugDll.WithAllowUnsafe(true)); 835115"];
6464 [label="CreateCompilation(source, references: new[] { libImage },\n                options: TestOptions.DebugDll.WithAllowUnsafe(true)) 835116"];
6465 [label="param operator(string source) 835117"];
6466 [label="source 835118"];
6467 [label="new CSharpTestSource(source) 835119"];
6468 [label="param CSharpTestSource(object value) 835120"];
6469 [label="param CSharpTestSource(this) 835121"];
6470 [label="Value 835122"];
6471 [label="var comp = CreateCompilation(source, references: new[] { libImage },\n                options: TestOptions.DebugDll.WithAllowUnsafe(true)); 835123"];
6472 [label="param CreateCompilation(CSharpTestSource source) 835124"];
6473 [label="param CreateCompilation(IEnumerable<MetadataReference> references = null) 835125"];
6474 [label="param CreateCompilation(CSharpParseOptions parseOptions = null) 835126"];
6475 [label="param CreateCompilation(TargetFramework targetFramework = TargetFramework.Standard) 835127"];
6476 [label="param CreateCompilation(string assemblyName = '') 835128"];
6477 [label="param CreateCompilation(string sourceFileName = '') 835129"];
6478 [label="param CreateCompilation(bool skipUsesIsNullable = false) 835130"];
6479 [label="source 835131"];
6480 [label="targetFramework 835132"];
6481 [label="references 835133"];
6482 [label="TargetFrameworkUtil.GetReferences(targetFramework, references) 835134"];
6483 [label="param GetReferences(TargetFramework tf) 835135"];
6484 [label="param GetReferences(IEnumerable<MetadataReference> additionalReferences) 835136"];
6485 [label="var references = GetReferences(tf); 835137"];
6486 [label="GetReferences(tf) 835138"];
6487 [label="param GetReferences(TargetFramework targetFramework) 835139"];
6488 [label="targetFramework switch\n        {\n            TargetFramework.Empty => ImmutableArray<MetadataReference>.Empty,\n            TargetFramework.Mscorlib40 => Mscorlib40References,\n            TargetFramework.Mscorlib40Extended => Mscorlib40ExtendedReferences,\n            TargetFramework.Mscorlib40AndSystemCore => Mscorlib40andSystemCoreReferences,\n            TargetFramework.Mscorlib40AndVBRuntime => Mscorlib40andVBRuntimeReferences,\n            TargetFramework.Mscorlib45 => Mscorlib45References,\n            TargetFramework.Mscorlib45Extended => Mscorlib45ExtendedReferences,\n            TargetFramework.Mscorlib45AndCSharp => Mscorlib45AndCSharpReferences,\n            TargetFramework.Mscorlib45AndVBRuntime => Mscorlib45AndVBRuntimeReferences,\n            TargetFramework.Mscorlib46 => Mscorlib46References,\n            TargetFramework.Mscorlib46Extended => Mscorlib46ExtendedReferences,\n            TargetFramework.Mscorlib461 => Mscorlib46References,\n            TargetFramework.Mscorlib461Extended => Mscorlib461ExtendedReferences,\n            TargetFramework.NetStandard20 => NetStandard20References,\n            TargetFramework.NetCoreApp => NetCoreAppReferences,\n            TargetFramework.WinRT => WinRTReferences,\n            TargetFramework.Standard => StandardReferences,\n            TargetFramework.StandardLatest => StandardLatestReferences,\n            TargetFramework.StandardAndCSharp => StandardAndCSharpReferences,\n            TargetFramework.StandardAndVBRuntime => StandardAndVBRuntimeReferences,\n            TargetFramework.StandardCompat => StandardCompatReferences,\n            TargetFramework.DefaultVb => DefaultVbReferences,\n            TargetFramework.Minimal => MinimalReferences,\n            TargetFramework.MinimalAsync => MinimalAsyncReferences,\n            _ => throw new InvalidOperationException($'Unexpected target framework {targetFramework}'),\n        } 835140"];
6489 [label="StandardReferences 835141"];
6490 [label="RuntimeUtilities.IsCoreClrRuntime 835142"];
6491 [label="NetStandard20References 835143"];
6492 [label="ImmutableArray.Create<MetadataReference>(NetStandard20.netstandard, NetStandard20.mscorlib, NetStandard20.SystemRuntime, NetStandard20.SystemCore, NetStandard20.SystemDynamicRuntime, NetStandard20.SystemLinq, NetStandard20.SystemLinqExpressions) 835144"];
6493 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 835145"];
6494 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 835146"];
6495 [label="checkForDuplicateReferences(references, additionalReferences); 835147"];
6496 [label="checkForDuplicateReferences(references, additionalReferences) 835148"];
6497 [label="void checkForDuplicateReferences(ImmutableArray<MetadataReference> refer, IEnumerable<MetadataReference> additRef)\n            {\n                var nameSet = new HashSet<string>(getNames(refer), StringComparer.OrdinalIgnoreCase);\n                foreach (var r in additRef)\n                {\n                    if (refer.Contains(r))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display}');\n                    }\n\n                    var name = getName(r);\n                    if (name != null && !nameSet.Add(name))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display} - {name}');\n                    }\n                }\n            } 835149"];
6498 [label="getNames(refer) 835150"];
6499 [label="if (name != null)\n                    {\n                        yield return name;\n                    } 835151"];
6500 [label="yield return name; 835152"];
6501 [label="yield return name; 835153"];
6502 [label="var nameSet = new HashSet<string>(getNames(refer), StringComparer.OrdinalIgnoreCase); 835154"];
6503 [label="foreach (var r in additRef)\n                {\n                    if (refer.Contains(r))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display}');\n                    }\n\n                    var name = getName(r);\n                    if (name != null && !nameSet.Add(name))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display} - {name}');\n                    }\n                } 835155"];
6504 [label="if (name != null && !nameSet.Add(name))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display} - {name}');\n                    } 835156"];
6505 [label="if (name != null && !nameSet.Add(name))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display} - {name}');\n                    } 835157"];
6506 [label="checkForDuplicateReferences(references, additionalReferences); 835158"];
6507 [label="return references.AddRange(additionalReferences); 835159"];
6508 [label="parseOptions 835160"];
6509 [label="assemblyName 835161"];
6510 [label="sourceFileName 835162"];
6511 [label="skipUsesIsNullable 835163"];
6512 [label="CreateEmptyCompilation(source, TargetFrameworkUtil.GetReferences(targetFramework, references), options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable) 835164"];
6513 [label="param CreateEmptyCompilation(CSharpTestSource source) 835165"];
6514 [label="param CreateEmptyCompilation(CSharpParseOptions parseOptions = null) 835166"];
6515 [label="param CreateEmptyCompilation(string assemblyName = '') 835167"];
6516 [label="param CreateEmptyCompilation(string sourceFileName = '') 835168"];
6517 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 835169"];
6518 [label="source 835170"];
6519 [label="parseOptions 835171"];
6520 [label="assemblyName 835172"];
6521 [label="sourceFileName 835173"];
6522 [label="skipUsesIsNullable 835174"];
6523 [label="null 835175"];
6524 [label="experimentalFeature: null 835176"];
6525 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 835177"];
6526 [label="param CreateCompilationCore(CSharpTestSource source) 835178"];
6527 [label="param CreateCompilationCore(CSharpParseOptions parseOptions) 835179"];
6528 [label="param CreateCompilationCore(string assemblyName) 835180"];
6529 [label="param CreateCompilationCore(string sourceFileName) 835181"];
6530 [label="param CreateCompilationCore(bool skipUsesIsNullable) 835182"];
6531 [label="param CreateCompilationCore(MessageID? experimentalFeature) 835183"];
6532 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 835184"];
6533 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 835185"];
6534 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 835186"];
6535 [label="param GetSyntaxTrees(CSharpParseOptions parseOptions) 835187"];
6536 [label="param GetSyntaxTrees(string sourceFileName = '') 835188"];
6537 [label="param GetSyntaxTrees(this) 835189"];
6538 [label="switch (Value)\n            {\n                case string source:\n                    return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) };\n                case string[] sources:\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return CSharpTestBase.Parse(parseOptions, sources);\n                case SyntaxTree tree:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return new[] { tree };\n                case SyntaxTree[] trees:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return trees;\n                case CSharpTestSource[] testSources:\n                    return testSources.SelectMany(s => s.GetSyntaxTrees(parseOptions, sourceFileName)).ToArray();\n                case null:\n                    return Array.Empty<SyntaxTree>();\n                default:\n                    throw new Exception($'Unexpected value: {Value}');\n            } 835190"];
6539 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 835191"];
6540 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 835192"];
6541 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 835193"];
6542 [label="CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) 835194"];
6543 [label="param Parse(string text) 835195"];
6544 [label="param Parse(string filename = '') 835196"];
6545 [label="param Parse(CSharpParseOptions options = null) 835197"];
6546 [label="param Parse(Encoding encoding = null) 835198"];
6547 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 835199"];
6548 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 835200"];
6549 [label="options = TestOptions.Regular; 835201"];
6550 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 835202"];
6551 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 835203"];
6552 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 835204"];
6553 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 835205"];
6554 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 835206"];
6555 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 835207"];
6556 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 835208"];
6557 [label="CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)) 835209"];
6558 [label="var stream = new MemoryStream(); 835210"];
6559 [label="var root = tree.GetRoot(); 835211"];
6560 [label="var root = tree.GetRoot(); 835212"];
6561 [label="root.SerializeTo(stream); 835213"];
6562 [label="root.SerializeTo(stream); 835214"];
6563 [label="root.SerializeTo(stream); 835215"];
6564 [label="stream.Position = 0; 835216"];
6565 [label="stream.Position 835217"];
6566 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 835218"];
6567 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 835219"];
6568 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 835220"];
6569 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 835221"];
6570 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 835222"];
6571 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 835223"];
6572 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 835224"];
6573 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 835225"];
6574 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 835226"];
6575 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 835227"];
6576 [label="param ValidateIOperations(Func<Compilation> createCompilation) 835228"];
6577 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 835229"];
6578 [label="return; 835230"];
6579 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 835231"];
6580 [label="var compilation = createCompilationLambda(); 835232"];
6581 [label="return Guid.NewGuid().ToString('D'); 835233"];
6582 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 835234"];
6583 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 835235"];
6584 [label="param Create(CSharpCompilation? previousSubmission) 835236"];
6585 [label="param Create(Type? returnType) 835237"];
6586 [label="param Create(Type? hostObjectType) 835238"];
6587 [label="param Create(bool isSubmission) 835239"];
6588 [label="RoslynDebug.Assert(options != null); 835240"];
6589 [label="RoslynDebug.Assert(options != null); 835241"];
6590 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 835242"];
6591 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 835243"];
6592 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 835244"];
6593 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 835245"];
6594 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 835246"];
6595 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 835247"];
6596 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 835248"];
6597 [label="new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null) 835249"];
6598 [label="param SyntaxAndDeclarationManager(ImmutableArray<SyntaxTree> externalSyntaxTrees) 835250"];
6599 [label="param SyntaxAndDeclarationManager(CommonMessageProvider messageProvider) 835251"];
6600 [label="param SyntaxAndDeclarationManager(bool isSubmission) 835252"];
6601 [label="param SyntaxAndDeclarationManager(State state) 835253"];
6602 [label="param SyntaxAndDeclarationManager(this) 835254"];
6603 [label="externalSyntaxTrees 835255"];
6604 [label="messageProvider 835256"];
6605 [label="isSubmission 835257"];
6606 [label="param SyntaxAndDeclarationManager(this) 835258"];
6607 [label="_lazyState 835259"];
6608 [label="_lazyState 835260"];
6609 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 835261"];
6610 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 835262"];
6611 [label="param CSharpCompilation(Type? submissionReturnType) 835263"];
6612 [label="param CSharpCompilation(Type? hostObjectType) 835264"];
6613 [label="param CSharpCompilation(bool isSubmission) 835265"];
6614 [label="param CSharpCompilation(ReferenceManager? referenceManager) 835266"];
6615 [label="param CSharpCompilation(bool reuseReferenceManager) 835267"];
6616 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 835268"];
6617 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 835269"];
6618 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 835270"];
6619 [label="param CSharpCompilation(this) 835271"];
6620 [label="previousSubmission 835272"];
6621 [label="submissionReturnType 835273"];
6622 [label="hostObjectType 835274"];
6623 [label="isSubmission 835275"];
6624 [label="referenceManager 835276"];
6625 [label="reuseReferenceManager 835277"];
6626 [label="syntaxAndDeclarations 835278"];
6627 [label="semanticModelProvider 835279"];
6628 [label="eventQueue 835280"];
6629 [label="param CSharpCompilation(this) 835281"];
6630 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 835282"];
6631 [label="param CSharpCompilation(Type? submissionReturnType) 835283"];
6632 [label="param CSharpCompilation(Type? hostObjectType) 835284"];
6633 [label="param CSharpCompilation(bool isSubmission) 835285"];
6634 [label="param CSharpCompilation(ReferenceManager? referenceManager) 835286"];
6635 [label="param CSharpCompilation(bool reuseReferenceManager) 835287"];
6636 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 835288"];
6637 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 835289"];
6638 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 835290"];
6639 [label="param CSharpCompilation(this) 835291"];
6640 [label="isSubmission 835292"];
6641 [label="semanticModelProvider 835293"];
6642 [label="eventQueue 835294"];
6643 [label="param CSharpCompilation(this) 835295"];
6644 [label="_options 835296"];
6645 [label="_globalImports 835297"];
6646 [label="_previousSubmissionImports 835298"];
6647 [label="_globalNamespaceAlias 835299"];
6648 [label="_scriptClass 835300"];
6649 [label="_lazyHostObjectTypeSymbol 835301"];
6650 [label="_lazyImportInfos 835302"];
6651 [label="_conversions 835303"];
6652 [label="_anonymousTypeManager 835304"];
6653 [label="_lazyGlobalNamespace 835305"];
6654 [label="builtInOperators 835306"];
6655 [label="_lazyAssemblySymbol 835307"];
6656 [label="_referenceManager 835308"];
6657 [label="_syntaxAndDeclarations 835309"];
6658 [label="_lazyEntryPoint 835310"];
6659 [label="_lazyEmitNullablePublicOnly 835311"];
6660 [label="_lazyCompilationUnitCompletedTrees 835312"];
6661 [label="NullableAnalysisData 835313"];
6662 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 835314"];
6663 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 835315"];
6664 [label="_externAliasTargets 835316"];
6665 [label="_moduleInitializerMethods 835317"];
6666 [label="_binderFactories 835318"];
6667 [label="_ignoreAccessibilityBinderFactories 835319"];
6668 [label="_lazyDeclarationDiagnostics 835320"];
6669 [label="_declarationDiagnosticsFrozen 835321"];
6670 [label="new DiagnosticBag() 835322"];
6671 [label="_additionalCodegenWarnings = new DiagnosticBag() 835323"];
6672 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 835324"];
6673 [label="this.builtInOperators = new BuiltInOperators(this); 835325"];
6674 [label="this.builtInOperators = new BuiltInOperators(this); 835326"];
6675 [label="new BuiltInOperators(this) 835327"];
6676 [label="param BuiltInOperators(CSharpCompilation compilation) 835328"];
6677 [label="param BuiltInOperators(this) 835329"];
6678 [label="_compilation 835330"];
6679 [label="_builtInUnaryOperators 835331"];
6680 [label="_builtInOperators 835332"];
6681 [label="_compilation 835333"];
6682 [label="this.builtInOperators 835334"];
6683 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 835335"];
6684 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 835336"];
6685 [label="LanguageVersion? result = null; 835337"];
6686 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 835338"];
6687 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 835339"];
6688 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 835340"];
6689 [label="this.LanguageVersion 835341"];
6690 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 835342"];
6691 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 835343"];
6692 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 835344"];
6693 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 835345"];
6694 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 835346"];
6695 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 835347"];
6696 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 835348"];
6697 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 835349"];
6698 [label="this.Options 835350"];
6699 [label="get\n            {\n                return _options;\n            } 835351"];
6700 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 835352"];
6701 [label="_syntaxAndDeclarations 835353"];
6702 [label="Debug.Assert(_lazyAssemblySymbol is null); 835354"];
6703 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 835355"];
6704 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 835356"];
6705 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 835357"];
6706 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 835358"];
6707 [label="int i = 0; 835359"];
6708 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 835360"];
6709 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 835361"];
6710 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 835362"];
6711 [label="i++; 835363"];
6712 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 835364"];
6713 [label="var scriptClassName = this.ScriptClassName; 835365"];
6714 [label="var resolver = this.Resolver; 835366"];
6715 [label="var messageProvider = this.MessageProvider; 835367"];
6716 [label="var isSubmission = this.IsSubmission; 835368"];
6717 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 835369"];
6718 [label="param CSharpCompilation(Type? submissionReturnType) 835370"];
6719 [label="param CSharpCompilation(Type? hostObjectType) 835371"];
6720 [label="previousSubmission 835372"];
6721 [label="submissionReturnType 835373"];
6722 [label="hostObjectType 835374"];
6723 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 835375"];
6724 [label="param CSharpCompilation(Type? submissionReturnType) 835376"];
6725 [label="param CSharpCompilation(Type? hostObjectType) 835377"];
6726 [label="_compilation 835378"];
6727 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 835379"];
6728 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 835380"];
6729 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 835381"];
6730 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 835382"];
6731 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 835383"];
6732 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 835384"];
6733 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 835385"];
6734 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 835386"];
6735 [label="Debug.Assert(_lazyAssemblySymbol is null); 835387"];
6736 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 835388"];
6737 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 835389"];
6738 [label="IsNullableEnabled(compilation) 835390"];
6739 [label="compilation.SyntaxTrees 835391"];
6740 [label="_syntaxAndDeclarations.GetLazyState() 835392"];
6741 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 835393"];
6742 [label="param AppendAllSyntaxTrees(SourceReferenceResolver resolver) 835394"];
6743 [label="param AppendAllSyntaxTrees(CommonMessageProvider messageProvider) 835395"];
6744 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, ImmutableArray<LoadDirective>> loadDirectiveMapBuilder) 835396"];
6745 [label="param AppendAllSyntaxTrees(IDictionary<string, SyntaxTree> loadedSyntaxTreeMapBuilder) 835397"];
6746 [label="var sourceCodeKind = tree.Options.Kind; 835398"];
6747 [label="if (sourceCodeKind == SourceCodeKind.Script)\n            {\n                AppendAllLoadedSyntaxTrees(treesBuilder, tree, scriptClassName, resolver, messageProvider, isSubmission, ordinalMapBuilder, loadDirectiveMapBuilder, loadedSyntaxTreeMapBuilder, declMapBuilder, ref declTable);\n            } 835399"];
6748 [label="OrdinalMap 835400"];
6749 [label="LoadDirectiveMap 835401"];
6750 [label="LoadedSyntaxTreeMap 835402"];
6751 [label="RootNamespaces 835403"];
6752 [label="DeclarationTable 835404"];
6753 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 835405"];
6754 [label="var options = (CSharpParseOptions)trees[0].Options; 835406"];
6755 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 835407"];
6756 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 835408"];
6757 [label="validator(comp); 835409"];
6758 [label="var diagnostics = c.GetDiagnostics(); 835410"];
6759 [label="c.GetDiagnostics() 835411"];
6760 [label="param GetDiagnostics(CancellationToken cancellationToken = default) 835412"];
6761 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 835413"];
6762 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 835414"];
6763 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 835415"];
6764 [label="GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken) 835416"];
6765 [label="param GetDiagnostics(CompilationStage stage) 835417"];
6766 [label="param GetDiagnostics(bool includeEarlierStages) 835418"];
6767 [label="param GetDiagnostics(CancellationToken cancellationToken) 835419"];
6768 [label="var diagnostics = DiagnosticBag.GetInstance(); 835420"];
6769 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 835421"];
6770 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 835422"];
6771 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 835423"];
6772 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 835424"];
6773 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 835425"];
6774 [label="param GetDiagnostics(CompilationStage stage) 835426"];
6775 [label="param GetDiagnostics(bool includeEarlierStages) 835427"];
6776 [label="param GetDiagnostics(DiagnosticBag diagnostics) 835428"];
6777 [label="param GetDiagnostics(CancellationToken cancellationToken = default) 835429"];
6778 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 835430"];
6779 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 835431"];
6780 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 835432"];
6781 [label="this.SyntaxTrees 835433"];
6782 [label="_syntaxAndDeclarations.GetLazyState() 835434"];
6783 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 835435"];
6784 [label="this.Options 835436"];
6785 [label="param AppendLoadDirectiveDiagnostics(DiagnosticBag builder) 835437"];
6786 [label="param AppendLoadDirectiveDiagnostics(Func<IEnumerable<Diagnostic>, IEnumerable<Diagnostic>>? locationFilterOpt = null) 835438"];
6787 [label="var parseOptionsReported = new HashSet<ParseOptions>(); 835439"];
6788 [label="if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    } 835440"];
6789 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 835441"];
6790 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 835442"];
6791 [label="CheckAssemblyName(builder); 835443"];
6792 [label="CheckAssemblyName(builder); 835444"];
6793 [label="Options 835445"];
6794 [label="Options 835446"];
6795 [label="get\n            {\n                return _options;\n            } 835447"];
6796 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 835448"];
6797 [label="GetBoundReferenceManager() 835449"];
6798 [label="Debug.Assert(_lazyAssemblySymbol is object); 835450"];
6799 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 835451"];
6800 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 835452"];
6801 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 835453"];
6802 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 835454"];
6803 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 835455"];
6804 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 835456"];
6805 [label="param GetSourceDeclarationDiagnostics(CancellationToken cancellationToken = default) 835457"];
6806 [label="GlobalImports 835458"];
6807 [label="_globalImports.Value 835459"];
6808 [label="Imports.FromGlobalUsings(this) 835460"];
6809 [label="GlobalImports.Complete(cancellationToken); 835461"];
6810 [label="SourceLocation? location = null; 835462"];
6811 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 835463"];
6812 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 835464"];
6813 [label="Assembly 835465"];
6814 [label="SourceAssembly 835466"];
6815 [label="GetBoundReferenceManager() 835467"];
6816 [label="GetBoundReferenceManager(); 835468"];
6817 [label="Assembly.ForceComplete(location, cancellationToken); 835469"];
6818 [label="Assembly.ForceComplete(location, cancellationToken); 835470"];
6819 [label="Assembly.ForceComplete(location, cancellationToken); 835471"];
6820 [label="Declarations 835472"];
6821 [label="_syntaxAndDeclarations.GetLazyState() 835473"];
6822 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 835474"];
6823 [label="return Declarations.GetMergedRoot(this); 835475"];
6824 [label="_syntaxAndDeclarations.GetLazyState() 835476"];
6825 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 835477"];
6826 [label="SourceAssembly 835478"];
6827 [label="GetBoundReferenceManager() 835479"];
6828 [label="GetBoundReferenceManager(); 835480"];
6829 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 835481"];
6830 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 835482"];
6831 [label="param SymbolDeclaredEvent(Symbol symbol) 835483"];
6832 [label="param SymbolDeclaredEvent(this) 835484"];
6833 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 835485"];
6834 [label="GetBoundReferenceManager() 835486"];
6835 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 835487"];
6836 [label="param Compare(this) 835488"];
6837 [label="int comparison; 835489"];
6838 [label="if (x == y)\n            {\n                return 0;\n            } 835490"];
6839 [label="var xSortKey = x.GetLexicalSortKey(); 835491"];
6840 [label="this.ContainsSyntaxTree(tree) 835492"];
6841 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 835493"];
6842 [label="_syntaxAndDeclarations.GetLazyState() 835494"];
6843 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 835495"];
6844 [label="_syntaxAndDeclarations.GetLazyState() 835496"];
6845 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 835497"];
6846 [label="var ySortKey = y.GetLexicalSortKey(); 835498"];
6847 [label="this.ContainsSyntaxTree(tree) 835499"];
6848 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 835500"];
6849 [label="_syntaxAndDeclarations.GetLazyState() 835501"];
6850 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 835502"];
6851 [label="_syntaxAndDeclarations.GetLazyState() 835503"];
6852 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 835504"];
6853 [label="Debug.Assert((object)x.DeclaringCompilation == y.DeclaringCompilation); 835505"];
6854 [label="if (comparison != 0)\n            {\n                return comparison;\n            } 835506"];
6855 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 835507"];
6856 [label="NamedTypeSymbol result; 835508"];
6857 [label="Debug.Assert(result.SpecialType == specialType); 835509"];
6858 [label="Debug.Assert(symbol.IsDefinition); 835510"];
6859 [label="SourceModule 835511"];
6860 [label="Assembly 835512"];
6861 [label="SourceAssembly 835513"];
6862 [label="GetBoundReferenceManager() 835514"];
6863 [label="GetBoundReferenceManager(); 835515"];
6864 [label="return Assembly.Modules[0]; 835516"];
6865 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 835517"];
6866 [label="EmitNullablePublicOnly 835518"];
6867 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 835519"];
6868 [label="_declarationDiagnosticsFrozen = true; 835520"];
6869 [label="_needsGeneratedAttributes_IsFrozen = true; 835521"];
6870 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 835522"];
6871 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 835523"];
6872 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 835524"];
6873 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 835525"];
6874 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 835526"];
6875 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 835527"];
6876 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 835528"];
6877 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 835529"];
6878 [label="param GetClsComplianceDiagnostics(CancellationToken cancellationToken) 835530"];
6879 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 835531"];
6880 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 835532"];
6881 [label="param CheckCompliance(DiagnosticBag diagnostics) 835533"];
6882 [label="System.Diagnostics.Debug.Assert(symbol is SourceAssemblySymbol); 835534"];
6883 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 835535"];
6884 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 835536"];
6885 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 835537"];
6886 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 835538"];
6887 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 835539"];
6888 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 835540"];
6889 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 835541"];
6890 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 835542"];
6891 [label="param GetDeclaredCompliance(out Location attributeLocation) 835543"];
6892 [label="param GetDeclaredCompliance(this) 835544"];
6893 [label="attributeLocation = null; 835545"];
6894 [label="if (assemblyCompliance == Compliance.DeclaredFalse)\n            {\n                // Our interpretation of an assembly-level CLSCompliant attribute is as follows:\n                //   1) If true, then perform all CLS checks.\n                //   2) If false, then perform no CLS checks (dev11 still performs a few, mostly around\n                //      meaningless attributes).  Our interpretation is that the user ultimately wants\n                //      his code to be CLS-compliant, but is temporarily disabling the checks (e.g. during\n                //      refactoring/prototyping).\n                //   3) If absent, the perform all CLS checks.  Our interpretation is that - in the\n                //      absence of an assembly-level attribute - any CLS problems within the compilation\n                //      indicate that the user was trying to do something but didn't know how.  It would\n                //      be nice if the most common case (i.e. this one) was the cheapest, but we don't\n                //      want to confuse novice users.\n                return;\n            } 835546"];
6895 [label="bool assemblyComplianceValue = IsTrue(assemblyCompliance); 835547"];
6896 [label="IsTrue(assemblyCompliance) 835548"];
6897 [label="param IsTrue(Compliance compliance) 835549"];
6898 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 835550"];
6899 [label="return false; 835551"];
6900 [label="Location attributeLocation; 835552"];
6901 [label="param GetDeclaredCompliance(out Location attributeLocation) 835553"];
6902 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 835554"];
6903 [label="i == 0 835555"];
6904 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 835556"];
6905 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 835557"];
6906 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 835558"];
6907 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 835559"];
6908 [label="if (moduleDeclaredCompliance.HasValue)\n                {\n                    if (warningLocation != null)\n                    {\n                        if (!IsDeclared(assemblyCompliance))\n                        {\n                            // This is not useful on non-source modules, but dev11 reports it anyway.\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules, warningLocation);\n                        }\n                        else if (assemblyComplianceValue != moduleDeclaredCompliance.GetValueOrDefault())\n                        {\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules2, warningLocation);\n                        }\n                    }\n                }\n                else if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 835560"];
6909 [label="if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 835561"];
6910 [label="if (assemblyComplianceValue)\n            {\n                CheckForAttributeWithArrayArgument(symbol);\n            } 835562"];
6911 [label="System.Diagnostics.Debug.Assert(symbol.Kind != SymbolKind.Assembly); 835563"];
6912 [label="System.Diagnostics.Debug.Assert((object)containing != null); 835564"];
6913 [label="return compliance; 835565"];
6914 [label="IsTrue(GetInheritedCompliance(symbol)) 835566"];
6915 [label="param IsTrue(Compliance compliance) 835567"];
6916 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 835568"];
6917 [label="return false; 835569"];
6918 [label="IsTrue(GetDeclaredOrInheritedCompliance(sourceModule)) 835570"];
6919 [label="param IsTrue(Compliance compliance) 835571"];
6920 [label="if (DoNotVisit(symbol)) return; 835572"];
6921 [label="DoNotVisit(symbol) 835573"];
6922 [label="param DoNotVisit(Symbol symbol) 835574"];
6923 [label="param DoNotVisit(this) 835575"];
6924 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                return false;\n            } 835576"];
6925 [label="return false; 835577"];
6926 [label="IsTrue(GetDeclaredOrInheritedCompliance(symbol)) 835578"];
6927 [label="param IsTrue(Compliance compliance) 835579"];
6928 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 835580"];
6929 [label="return false; 835581"];
6930 [label="if (tasks == null)\n            {\n                return;\n            } 835582"];
6931 [label="checker.WaitForWorkers(); 835583"];
6932 [label="foreach (Diagnostic diag in queue)\n            {\n                diagnostics.Add(diag);\n            } 835584"];
6933 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 835585"];
6934 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 835586"];
6935 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 835587"];
6936 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 835588"];
6937 [label="var methodBodyDiagnostics = DiagnosticBag.GetInstance(); 835589"];
6938 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 835590"];
6939 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 835591"];
6940 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken) 835592"];
6941 [label="param GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics) 835593"];
6942 [label="param GetDiagnosticsForAllMethodBodies(CancellationToken cancellationToken) 835594"];
6943 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 835595"];
6944 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 835596"];
6945 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 835597"];
6946 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken) 835598"];
6947 [label="param CompileMethodBodies(PEModuleBuilder moduleBeingBuiltOpt) 835599"];
6948 [label="param CompileMethodBodies(bool emittingPdb) 835600"];
6949 [label="param CompileMethodBodies(bool emitTestCoverageData) 835601"];
6950 [label="param CompileMethodBodies(bool hasDeclarationErrors) 835602"];
6951 [label="param CompileMethodBodies(DiagnosticBag diagnostics) 835603"];
6952 [label="param CompileMethodBodies(Predicate<Symbol> filterOpt) 835604"];
6953 [label="param CompileMethodBodies(CancellationToken cancellationToken) 835605"];
6954 [label="Debug.Assert(compilation != null); 835606"];
6955 [label="Debug.Assert(compilation != null); 835607"];
6956 [label="Debug.Assert(diagnostics != null); 835608"];
6957 [label="Debug.Assert(diagnostics != null); 835609"];
6958 [label="compilation.PreviousSubmission 835610"];
6959 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 835611"];
6960 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 835612"];
6961 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 835613"];
6962 [label="MethodSymbol entryPoint = null; 835614"];
6963 [label="if (filterOpt is null)\n            {\n                entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken);\n            } 835615"];
6964 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 835616"];
6965 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 835617"];
6966 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 835618"];
6967 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 835619"];
6968 [label="GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken) 835620"];
6969 [label="param GetEntryPoint(PEModuleBuilder moduleBeingBuilt) 835621"];
6970 [label="param GetEntryPoint(bool hasDeclarationErrors) 835622"];
6971 [label="param GetEntryPoint(DiagnosticBag diagnostics) 835623"];
6972 [label="param GetEntryPoint(CancellationToken cancellationToken) 835624"];
6973 [label="var entryPointAndDiagnostics = compilation.GetEntryPointAndDiagnostics(cancellationToken); 835625"];
6974 [label="compilation.GetEntryPointAndDiagnostics(cancellationToken) 835626"];
6975 [label="param GetEntryPointAndDiagnostics(CancellationToken cancellationToken) 835627"];
6976 [label="if (_lazyEntryPoint == null)\n            {\n                EntryPoint? entryPoint;\n                var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this);\n\n                if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                }\n\n                Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null);\n            } 835628"];
6977 [label="EntryPoint? entryPoint; 835629"];
6978 [label="Debug.Assert(!entryPointAndDiagnostics.Diagnostics.IsDefault); 835630"];
6979 [label="if ((object)entryPoint == null)\n            {\n                return null;\n            } 835631"];
6980 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 835632"];
6981 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 835633"];
6982 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 835634"];
6983 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 835635"];
6984 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 835636"];
6985 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 835637"];
6986 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 835638"];
6987 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 835639"];
6988 [label="new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken) 835640"];
6989 [label="param MethodCompiler(PEModuleBuilder moduleBeingBuiltOpt) 835641"];
6990 [label="param MethodCompiler(bool emittingPdb) 835642"];
6991 [label="param MethodCompiler(bool emitTestCoverageData) 835643"];
6992 [label="param MethodCompiler(bool hasDeclarationErrors) 835644"];
6993 [label="param MethodCompiler(DiagnosticBag diagnostics) 835645"];
6994 [label="param MethodCompiler(Predicate<Symbol> filterOpt) 835646"];
6995 [label="param MethodCompiler(CancellationToken cancellationToken) 835647"];
6996 [label="param MethodCompiler(this) 835648"];
6997 [label="param MethodCompiler(this) 835649"];
6998 [label="_compilation 835650"];
6999 [label="_emittingPdb 835651"];
7000 [label="_emitTestCoverageData 835652"];
7001 [label="_diagnostics 835653"];
7002 [label="_hasDeclarationErrors 835654"];
7003 [label="_moduleBeingBuiltOpt 835655"];
7004 [label="_filterOpt 835656"];
7005 [label="_debugDocumentProvider 835657"];
7006 [label="_entryPointOpt 835658"];
7007 [label="_compilerTasks 835659"];
7008 [label="_globalHasErrors 835660"];
7009 [label="Debug.Assert(compilation != null); 835661"];
7010 [label="Debug.Assert(compilation != null); 835662"];
7011 [label="Debug.Assert(diagnostics != null); 835663"];
7012 [label="Debug.Assert(diagnostics != null); 835664"];
7013 [label="_moduleBeingBuiltOpt 835665"];
7014 [label="_emittingPdb 835666"];
7015 [label="_cancellationToken 835667"];
7016 [label="_diagnostics 835668"];
7017 [label="_filterOpt 835669"];
7018 [label="_hasDeclarationErrors 835670"];
7019 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 835671"];
7020 [label="SetGlobalErrorIfTrue(hasDeclarationErrors) 835672"];
7021 [label="param SetGlobalErrorIfTrue(bool arg) 835673"];
7022 [label="param SetGlobalErrorIfTrue(this) 835674"];
7023 [label="if (arg)\n            {\n                _globalHasErrors = true;\n            } 835675"];
7024 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 835676"];
7025 [label="if (emittingPdb || emitTestCoverageData)\n            {\n                _debugDocumentProvider = (path, basePath) => moduleBeingBuiltOpt.DebugDocumentsBuilder.GetOrAddDebugDocument(path, basePath, CreateDebugDocumentForFile);\n            } 835677"];
7026 [label="_emitTestCoverageData 835678"];
7027 [label="compilation.Options 835679"];
7028 [label="compilation.SourceModule 835680"];
7029 [label="Assembly 835681"];
7030 [label="SourceAssembly 835682"];
7031 [label="GetBoundReferenceManager() 835683"];
7032 [label="GetBoundReferenceManager(); 835684"];
7033 [label="return Assembly.Modules[0]; 835685"];
7034 [label="methodCompiler.CompileNamespace(compilation.SourceModule.GlobalNamespace) 835686"];
7035 [label="param CompileNamespace(this) 835687"];
7036 [label="param VisitNamedType(TypeCompilationState arg) 835688"];
7037 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 835689"];
7038 [label="PassesFilter(_filterOpt, symbol) 835690"];
7039 [label="param PassesFilter(Predicate<Symbol> filterOpt) 835691"];
7040 [label="param PassesFilter(Symbol symbol) 835692"];
7041 [label="return (filterOpt == null) || filterOpt(symbol); 835693"];
7042 [label="return (filterOpt == null) || filterOpt(symbol); 835694"];
7043 [label="arg = null; 835695"];
7044 [label="param CompileNamedTypeAsync(NamedTypeSymbol symbol) 835696"];
7045 [label="methodCompiler.CompileNamespace(compilation.SourceModule.GlobalNamespace); 835697"];
7046 [label="methodCompiler.WaitForWorkers() 835698"];
7047 [label="param WaitForWorkers(this) 835699"];
7048 [label="if (tasks == null)\n            {\n                return;\n            } 835700"];
7049 [label="if (tasks == null)\n            {\n                return;\n            } 835701"];
7050 [label="Task curTask; 835702"];
7051 [label="while (tasks.TryPop(out curTask))\n            {\n                curTask.GetAwaiter().GetResult();\n            } 835703"];
7052 [label="methodCompiler.WaitForWorkers(); 835704"];
7053 [label="if (moduleBeingBuiltOpt != null)\n            {\n                var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics);\n\n                var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics);\n\n                // By this time we have processed all types reachable from module's global namespace\n                compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics);\n                methodCompiler.WaitForWorkers();\n\n                var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass;\n                if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                }\n            } 835705"];
7054 [label="if (moduleBeingBuiltOpt != null)\n            {\n                var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics);\n\n                var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics);\n\n                // By this time we have processed all types reachable from module's global namespace\n                compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics);\n                methodCompiler.WaitForWorkers();\n\n                var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass;\n                if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                }\n            } 835706"];
7055 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 835707"];
7056 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 835708"];
7057 [label="compilation.AdditionalCodegenWarnings 835709"];
7058 [label="if (filterOpt == null)\n            {\n                WarnUnusedFields(compilation, diagnostics, cancellationToken);\n\n                if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                }\n            } 835710"];
7059 [label="if (filterOpt == null)\n            {\n                WarnUnusedFields(compilation, diagnostics, cancellationToken);\n\n                if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                }\n            } 835711"];
7060 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 835712"];
7061 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 835713"];
7062 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken) 835714"];
7063 [label="param WarnUnusedFields(DiagnosticBag diagnostics) 835715"];
7064 [label="param WarnUnusedFields(CancellationToken cancellationToken) 835716"];
7065 [label="compilation.Assembly 835717"];
7066 [label="SourceAssembly 835718"];
7067 [label="GetBoundReferenceManager() 835719"];
7068 [label="GetBoundReferenceManager(); 835720"];
7069 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 835721"];
7070 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 835722"];
7071 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 835723"];
7072 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 835724"];
7073 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 835725"];
7074 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 835726"];
7075 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 835727"];
7076 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 835728"];
7077 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken) 835729"];
7078 [label="param WriteDocumentationCommentXml(string? assemblyName) 835730"];
7079 [label="param WriteDocumentationCommentXml(Stream? xmlDocStream) 835731"];
7080 [label="param WriteDocumentationCommentXml(DiagnosticBag diagnostics) 835732"];
7081 [label="param WriteDocumentationCommentXml(CancellationToken cancellationToken) 835733"];
7082 [label="param WriteDocumentationCommentXml(SyntaxTree? filterTree = null) 835734"];
7083 [label="param WriteDocumentationCommentXml(TextSpan? filterSpanWithinTree = null) 835735"];
7084 [label="StreamWriter writer = null; 835736"];
7085 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 835737"];
7086 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 835738"];
7087 [label="compilation.SourceAssembly 835739"];
7088 [label="GetBoundReferenceManager() 835740"];
7089 [label="GetBoundReferenceManager(); 835741"];
7090 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 835742"];
7091 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 835743"];
7092 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 835744"];
7093 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 835745"];
7094 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 835746"];
7095 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 835747"];
7096 [label="new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken) 835748"];
7097 [label="param DocumentationCommentCompiler(TextWriter writer) 835749"];
7098 [label="param DocumentationCommentCompiler(SyntaxTree filterTree) 835750"];
7099 [label="param DocumentationCommentCompiler(TextSpan? filterSpanWithinTree) 835751"];
7100 [label="param DocumentationCommentCompiler(bool processIncludes) 835752"];
7101 [label="param DocumentationCommentCompiler(bool isForSingleSymbol) 835753"];
7102 [label="param DocumentationCommentCompiler(DiagnosticBag diagnostics) 835754"];
7103 [label="param DocumentationCommentCompiler(CancellationToken cancellationToken) 835755"];
7104 [label="param DocumentationCommentCompiler(this) 835756"];
7105 [label="param DocumentationCommentCompiler(this) 835757"];
7106 [label="_assemblyName 835758"];
7107 [label="_compilation 835759"];
7108 [label="_writer 835760"];
7109 [label="_filterTree 835761"];
7110 [label="_filterSpanWithinTree 835762"];
7111 [label="_processIncludes 835763"];
7112 [label="_isForSingleSymbol 835764"];
7113 [label="_diagnostics 835765"];
7114 [label="_lazyComparer 835766"];
7115 [label="_includedFileCache 835767"];
7116 [label="_indentDepth 835768"];
7117 [label="_temporaryStringBuilders 835769"];
7118 [label="_writer 835770"];
7119 [label="_filterTree 835771"];
7120 [label="_filterSpanWithinTree 835772"];
7121 [label="_processIncludes 835773"];
7122 [label="_isForSingleSymbol 835774"];
7123 [label="_diagnostics 835775"];
7124 [label="_cancellationToken 835776"];
7125 [label="compilation.SourceAssembly 835777"];
7126 [label="GetBoundReferenceManager() 835778"];
7127 [label="GetBoundReferenceManager(); 835779"];
7128 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 835780"];
7129 [label="Debug.Assert(_assemblyName != null); 835781"];
7130 [label="WriteLine('<?xml version=\\'1.0\\'?>'); 835782"];
7131 [label="WriteLine('<?xml version=\\'1.0\\'?>') 835783"];
7132 [label="param WriteLine(string message) 835784"];
7133 [label="param WriteLine(this) 835785"];
7134 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835786"];
7135 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835787"];
7136 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835788"];
7137 [label="WriteLine('<doc>'); 835789"];
7138 [label="WriteLine('<doc>') 835790"];
7139 [label="param WriteLine(string message) 835791"];
7140 [label="param WriteLine(this) 835792"];
7141 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835793"];
7142 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835794"];
7143 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835795"];
7144 [label="Indent(); 835796"];
7145 [label="WriteLine('<assembly>'); 835797"];
7146 [label="WriteLine('<assembly>') 835798"];
7147 [label="param WriteLine(string message) 835799"];
7148 [label="param WriteLine(this) 835800"];
7149 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835801"];
7150 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835802"];
7151 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835803"];
7152 [label="Indent(); 835804"];
7153 [label="WriteLine('<name>{0}</name>', _assemblyName); 835805"];
7154 [label="WriteLine('<name>{0}</name>', _assemblyName) 835806"];
7155 [label="WriteLine('<name>{0}</name>', _assemblyName) 835807"];
7156 [label="param WriteLine(string format) 835808"];
7157 [label="param WriteLine(params object[] args) 835809"];
7158 [label="param WriteLine(this) 835810"];
7159 [label="WriteLine(string.Format(format, args)); 835811"];
7160 [label="WriteLine(string.Format(format, args)); 835812"];
7161 [label="WriteLine(string.Format(format, args)); 835813"];
7162 [label="WriteLine(string.Format(format, args)) 835814"];
7163 [label="param WriteLine(string message) 835815"];
7164 [label="param WriteLine(this) 835816"];
7165 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835817"];
7166 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835818"];
7167 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835819"];
7168 [label="WriteLine(string.Format(format, args)); 835820"];
7169 [label="Debug.Assert(_indentDepth >= 0); 835821"];
7170 [label="Unindent(); 835822"];
7171 [label="WriteLine('</assembly>'); 835823"];
7172 [label="WriteLine('</assembly>') 835824"];
7173 [label="param WriteLine(string message) 835825"];
7174 [label="param WriteLine(this) 835826"];
7175 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835827"];
7176 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835828"];
7177 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835829"];
7178 [label="WriteLine('<members>'); 835830"];
7179 [label="WriteLine('<members>') 835831"];
7180 [label="param WriteLine(string message) 835832"];
7181 [label="param WriteLine(this) 835833"];
7182 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835834"];
7183 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835835"];
7184 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835836"];
7185 [label="Indent(); 835837"];
7186 [label="Debug.Assert(!_isForSingleSymbol); 835838"];
7187 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 835839"];
7188 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 835840"];
7189 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 835841"];
7190 [label="ImmutableArray<DocumentationCommentTriviaSyntax> docCommentNodes; 835842"];
7191 [label="docCommentNodes 835843"];
7192 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 835844"];
7193 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 835845"];
7194 [label="maxDocumentationMode = DocumentationMode.None; 835846"];
7195 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 835847"];
7196 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 835848"];
7197 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 835849"];
7198 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 835850"];
7199 [label="currDocumentationMode > maxDocumentationMode 835851"];
7200 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 835852"];
7201 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 835853"];
7202 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 835854"];
7203 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 835855"];
7204 [label="return true; 835856"];
7205 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 835857"];
7206 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 835858"];
7207 [label="return; 835859"];
7208 [label="return; 835860"];
7209 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 835861"];
7210 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 835862"];
7211 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 835863"];
7212 [label="currDocumentationMode > maxDocumentationMode 835864"];
7213 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 835865"];
7214 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 835866"];
7215 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 835867"];
7216 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 835868"];
7217 [label="docCommentNodes 835869"];
7218 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 835870"];
7219 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 835871"];
7220 [label="maxDocumentationMode = DocumentationMode.None; 835872"];
7221 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 835873"];
7222 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 835874"];
7223 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 835875"];
7224 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 835876"];
7225 [label="currDocumentationMode > maxDocumentationMode 835877"];
7226 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 835878"];
7227 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 835879"];
7228 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 835880"];
7229 [label="return true; 835881"];
7230 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 835882"];
7231 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 835883"];
7232 [label="return; 835884"];
7233 [label="return; 835885"];
7234 [label="Debug.Assert(_indentDepth >= 0); 835886"];
7235 [label="Unindent(); 835887"];
7236 [label="WriteLine('</members>'); 835888"];
7237 [label="WriteLine('</members>') 835889"];
7238 [label="param WriteLine(string message) 835890"];
7239 [label="param WriteLine(this) 835891"];
7240 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835892"];
7241 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835893"];
7242 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835894"];
7243 [label="Unindent(); 835895"];
7244 [label="WriteLine('</doc>'); 835896"];
7245 [label="WriteLine('</doc>') 835897"];
7246 [label="param WriteLine(string message) 835898"];
7247 [label="param WriteLine(this) 835899"];
7248 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835900"];
7249 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835901"];
7250 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 835902"];
7251 [label="Debug.Assert(compiler._indentDepth == 0); 835903"];
7252 [label="Debug.Assert(compiler._indentDepth == 0); 835904"];
7253 [label="writer?.Flush(); 835905"];
7254 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 835906"];
7255 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 835907"];
7256 [label="compilation.SyntaxTrees 835908"];
7257 [label="_syntaxAndDeclarations.GetLazyState() 835909"];
7258 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 835910"];
7259 [label="param ReportUnprocessed(TextSpan? filterSpanWithinTree) 835911"];
7260 [label="param ReportUnprocessed(DiagnosticBag diagnostics) 835912"];
7261 [label="param ReportUnprocessed(CancellationToken cancellationToken) 835913"];
7262 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 835914"];
7263 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 835915"];
7264 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 835916"];
7265 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken) 835917"];
7266 [label="param ReportUnusedImports(SyntaxTree? filterTree) 835918"];
7267 [label="param ReportUnusedImports(DiagnosticBag diagnostics) 835919"];
7268 [label="param ReportUnusedImports(CancellationToken cancellationToken) 835920"];
7269 [label="param ReportUnusedImports(this) 835921"];
7270 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 835922"];
7271 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 835923"];
7272 [label="CompleteTrees(filterTree); 835924"];
7273 [label="CompleteTrees(filterTree) 835925"];
7274 [label="param CompleteTrees(SyntaxTree? filterTree) 835926"];
7275 [label="param CompleteTrees(this) 835927"];
7276 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 835928"];
7277 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 835929"];
7278 [label="CompleteTrees(filterTree); 835930"];
7279 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 835931"];
7280 [label="builder.AddRangeAndFree(methodBodyDiagnostics); 835932"];
7281 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 835933"];
7282 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 835934"];
7283 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 835935"];
7284 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 835936"];
7285 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 835937"];
7286 [label="diagnostics.Verify(expected) 835938"];
7287 [label="Verify((IEnumerable<Diagnostic>)actual, expected) 835939"];
7288 [label="Verify(actual, expected, errorCodeOnly: false); 835940"];
7289 [label="Verify(actual, expected, errorCodeOnly: false) 835941"];
7290 [label="param Verify(bool errorCodeOnly) 835942"];
7291 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 835943"];
7292 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 835944"];
7293 [label="foreach (var d in expected)\n            {\n                int index = unmatched.IndexOf(d);\n                if (index > -1)\n                {\n                    unmatched.RemoveAt(index);\n                }\n                else\n                {\n                    CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n                }\n            } 835945"];
7294 [label="foreach (var d in expected)\n            {\n                int index = unmatched.IndexOf(d);\n                if (index > -1)\n                {\n                    unmatched.RemoveAt(index);\n                }\n                else\n                {\n                    CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n                }\n            } 835946"];
7295 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 835947"];
7296 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 835948"];
7297 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 835949"];
7298 [label="DiagnosticDescription.GetAssertText(expected, actual) 835950"];
7299 [label="param GetAssertText(DiagnosticDescription[] expected) 835951"];
7300 [label="const int CSharp = 1; 835952"];
7301 [label="const int VisualBasic = 2; 835953"];
7302 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 835954"];
7303 [label="actual.Any() && actual.First() is CSDiagnostic 835955"];
7304 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 835956"];
7305 [label="var includeDiagnosticMessagesAsComments = (language == CSharp); 835957"];
7306 [label="int indentDepth = (language == CSharp) ? 4 : 1; 835958"];
7307 [label="(language == CSharp) 835959"];
7308 [label="var includeDefaultSeverity = expected.Any() && expected.All(d => d.DefaultSeverity != null); 835960"];
7309 [label="var includeDefaultSeverity = expected.Any() && expected.All(d => d.DefaultSeverity != null); 835961"];
7310 [label="var includeEffectiveSeverity = expected.Any() && expected.All(d => d.EffectiveSeverity != null); 835962"];
7311 [label="var includeEffectiveSeverity = expected.Any() && expected.All(d => d.EffectiveSeverity != null); 835963"];
7312 [label="IsSortedOrEmpty(expected) 835964"];
7313 [label="param IsSortedOrEmpty(DiagnosticDescription[] diagnostics) 835965"];
7314 [label="var comparer = LinePositionComparer.Instance; 835966"];
7315 [label="DiagnosticDescription last = null; 835967"];
7316 [label="foreach (var diagnostic in diagnostics)\n            {\n                if (diagnostic._startPosition == null)\n                {\n                    return false;\n                }\n                if (last != null && comparer.Compare(last._startPosition, diagnostic._startPosition) > 0)\n                {\n                    return false;\n                }\n                last = diagnostic;\n            } 835968"];
7317 [label="foreach (var diagnostic in diagnostics)\n            {\n                if (diagnostic._startPosition == null)\n                {\n                    return false;\n                }\n                if (last != null && comparer.Compare(last._startPosition, diagnostic._startPosition) > 0)\n                {\n                    return false;\n                }\n                last = diagnostic;\n            } 835969"];
7318 [label="return true; 835970"];
7319 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 835971"];
7320 [label="Sort(actual) 835972"];
7321 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 835973"];
7322 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 835974"];
7323 [label="var assertText = new StringBuilder(); 835975"];
7324 [label="assertText.AppendLine(); 835976"];
7325 [label="int i; 835977"];
7326 [label="assertText.AppendLine('Expected:'); 835978"];
7327 [label="assertText.AppendLine('Expected:'); 835979"];
7328 [label="var expectedText = ArrayBuilder<string>.GetInstance(); 835980"];
7329 [label="foreach (var d in expected)\n            {\n                expectedText.Add(GetDiagnosticDescription(d, indentDepth));\n            } 835981"];
7330 [label="foreach (var d in expected)\n            {\n                expectedText.Add(GetDiagnosticDescription(d, indentDepth));\n            } 835982"];
7331 [label="GetCommaSeparatedLines(assertText, expectedText); 835983"];
7332 [label="GetCommaSeparatedLines(assertText, expectedText); 835984"];
7333 [label="GetCommaSeparatedLines(assertText, expectedText) 835985"];
7334 [label="param GetCommaSeparatedLines(StringBuilder sb) 835986"];
7335 [label="param GetCommaSeparatedLines(ArrayBuilder<string> lines) 835987"];
7336 [label="int n = lines.Count; 835988"];
7337 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 835989"];
7338 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 835990"];
7339 [label="GetCommaSeparatedLines(assertText, expectedText); 835991"];
7340 [label="assertText.AppendLine('Actual:'); 835992"];
7341 [label="assertText.AppendLine('Actual:'); 835993"];
7342 [label="var actualText = ArrayBuilder<string>.GetInstance(); 835994"];
7343 [label="for (i = 0; e.MoveNext(); i++)\n            {\n                Diagnostic d = e.Current;\n                string message = d.ToString();\n                if (Regex.Match(message, @'{\\d+}').Success)\n                {\n                    Assert.True(false, 'Diagnostic messages should never contain unsubstituted placeholders.\\n    ' + message);\n                }\n\n                if (i > 0)\n                {\n                    assertText.AppendLine(',');\n                }\n\n                if (includeDiagnosticMessagesAsComments)\n                {\n                    Indent(assertText, indentDepth);\n                    assertText.Append('// ');\n                    assertText.AppendLine(d.ToString());\n                    var l = d.Location;\n                    if (l.IsInSource)\n                    {\n                        Indent(assertText, indentDepth);\n                        assertText.Append('// ');\n                        assertText.AppendLine(l.SourceTree.GetText().Lines.GetLineFromPosition(l.SourceSpan.Start).ToString());\n                    }\n                }\n\n                var description = new DiagnosticDescription(d, errorCodeOnly: false, includeDefaultSeverity, includeEffectiveSeverity);\n                var diffDescription = description;\n                var idx = Array.IndexOf(expected, description);\n                if (idx != -1)\n                {\n                    diffDescription = expected[idx];\n                }\n                assertText.Append(GetDiagnosticDescription(description, indentDepth));\n                actualText.Add(GetDiagnosticDescription(diffDescription, indentDepth));\n            } 835995"];
7344 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 835996"];
7345 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 835997"];
7346 [label="assertText.AppendLine('Diff:'); 835998"];
7347 [label="assertText.AppendLine('Diff:'); 835999"];
7348 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 836000"];
7349 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 836001"];
7350 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 836002"];
7351 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 836003"];
7352 [label="DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine) 836004"];
7353 [label="param DiffReport(IEnumerable<T> expected) 836005"];
7354 [label="param DiffReport(IEnumerable<T> actual) 836006"];
7355 [label="param DiffReport(string separator) 836007"];
7356 [label="param DiffReport(IEqualityComparer<T> comparer = null) 836008"];
7357 [label="param DiffReport(Func<T, string> toString = null) 836009"];
7358 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 836010"];
7359 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 836011"];
7360 [label="(comparer != null) 836012"];
7361 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 836013"];
7362 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 836014"];
7363 [label="IList<T> expectedList = expected as IList<T> ?? new List<T>(expected); 836015"];
7364 [label="IList<T> actualList = actual as IList<T> ?? new List<T>(actual); 836016"];
7365 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 836017"];
7366 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 836018"];
7367 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 836019"];
7368 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 836020"];
7369 [label="lcs.CalculateDiff(expectedList, actualList, toString) 836021"];
7370 [label="param CalculateDiff(IList<T> sequenceA) 836022"];
7371 [label="param CalculateDiff(IList<T> sequenceB) 836023"];
7372 [label="param CalculateDiff(Func<T, string> toString) 836024"];
7373 [label="param CalculateDiff(this) 836025"];
7374 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 836026"];
7375 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 836027"];
7376 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 836028"];
7377 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 836029"];
7378 [label="GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count) 836030"];
7379 [label="param GetEdits(TSequence sequenceA) 836031"];
7380 [label="param GetEdits(int lengthA) 836032"];
7381 [label="param GetEdits(TSequence sequenceB) 836033"];
7382 [label="param GetEdits(int lengthB) 836034"];
7383 [label="param GetEdits(this) 836035"];
7384 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 836036"];
7385 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 836037"];
7386 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 836038"];
7387 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 836039"];
7388 [label="ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB) 836040"];
7389 [label="param ComputeCostMatrix(TSequence sequenceA) 836041"];
7390 [label="param ComputeCostMatrix(int lengthA) 836042"];
7391 [label="param ComputeCostMatrix(TSequence sequenceB) 836043"];
7392 [label="param ComputeCostMatrix(int lengthB) 836044"];
7393 [label="param ComputeCostMatrix(this) 836045"];
7394 [label="var la = lengthA + 1; 836046"];
7395 [label="var la = lengthA + 1; 836047"];
7396 [label="var lb = lengthB + 1; 836048"];
7397 [label="var lb = lengthB + 1; 836049"];
7398 [label="var d = new int[la, lb]; 836050"];
7399 [label="d[0, 0] = 0; 836051"];
7400 [label="d[0, 0] 836052"];
7401 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 836053"];
7402 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 836054"];
7403 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 836055"];
7404 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 836056"];
7405 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 836057"];
7406 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 836058"];
7407 [label="return d; 836059"];
7408 [label="int i = lengthA; 836060"];
7409 [label="int j = lengthB; 836061"];
7410 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 836062"];
7411 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 836063"];
7412 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 836064"];
7413 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 836065"];
7414 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 836066"];
7415 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 836067"];
7416 [label="param GetEdits(this) 836068"];
7417 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 836069"];
7418 [label="param CalculateDiff(this) 836070"];
7419 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 836071"];
7420 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 836072"];
7421 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 836073"];
7422 [label="actualText.Free(); 836074"];
7423 [label="expectedText.Free(); 836075"];
7424 [label="return assertText.ToString(); 836076"];
7425 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 836077"];
7426 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 836078"];
7427 [label="diagnostics.Verify(expected); 836079"];
7428 [label="VerifyAssemblyIds(c, diagnostics); 836080"];
7429 [label="VerifyAssemblyIds(c, diagnostics); 836081"];
7430 [label="VerifyAssemblyIds(c, diagnostics) 836082"];
7431 [label="param VerifyAssemblyIds(TCompilation c) 836083"];
7432 [label="param VerifyAssemblyIds(ImmutableArray<Diagnostic> diagnostics) 836084"];
7433 [label="foreach (var diagnostic in diagnostics)\n            {\n                // If this is a diagnostic about a missing assembly, make sure that we can get back\n                // an AssemblyIdentity when we query the compiler.  If it's not a diagnostic about\n                // a missing assembly, make sure we get no results back.\n                if (c.IsUnreferencedAssemblyIdentityDiagnosticCode(diagnostic.Code))\n                {\n                    var assemblyIds = c.GetUnreferencedAssemblyIdentities(diagnostic);\n                    CustomAssert.False(assemblyIds.IsEmpty);\n\n                    var diagnosticMessage = diagnostic.GetMessage();\n                    foreach (var id in assemblyIds)\n                    {\n                        CustomAssert.Contains(id.GetDisplayName(), diagnosticMessage);\n                    }\n                }\n                else\n                {\n                    var assemblyIds = c.GetUnreferencedAssemblyIdentities(diagnostic);\n                    CustomAssert.True(assemblyIds.IsEmpty);\n                }\n            } 836085"];
7434 [label="VerifyAssemblyIds(c, diagnostics); 836086"];
7435 [label="if (debugFlag == -1 || debugFlag == 2)\n            {\n                VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(false));\n            } 836087"];
7436 [label="if (debugFlag == -1 || debugFlag == 2)\n            {\n                VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(false));\n            } 836088"];
7437 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(false)); 836089"];
7438 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(false)); 836090"];
7439 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(false)); 836091"];
7440 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(false)); 836092"];
7441 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(false)); 836093"];
7442 [label="VerifyRefAssemblyClient(lib_cs, client_cs, validator,\n                    EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(false)) 836094"];
7443 [label="param VerifyRefAssemblyClient(string lib_cs) 836095"];
7444 [label="param VerifyRefAssemblyClient(string source) 836096"];
7445 [label="param VerifyRefAssemblyClient(Action<CSharpCompilation> validator) 836097"];
7446 [label="param VerifyRefAssemblyClient(EmitOptions emitOptions) 836098"];
7447 [label="GetUniqueName() 836099"];
7448 [label="return Guid.NewGuid().ToString('D'); 836100"];
7449 [label="string name = GetUniqueName(); 836101"];
7450 [label="var libComp = CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name); 836102"];
7451 [label="var libComp = CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name); 836103"];
7452 [label="var libComp = CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name); 836104"];
7453 [label="var libComp = CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name); 836105"];
7454 [label="CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name) 836106"];
7455 [label="param operator(string source) 836107"];
7456 [label="source 836108"];
7457 [label="new CSharpTestSource(source) 836109"];
7458 [label="param CSharpTestSource(object value) 836110"];
7459 [label="param CSharpTestSource(this) 836111"];
7460 [label="Value 836112"];
7461 [label="var libComp = CreateCompilation(lib_cs,\n                options: TestOptions.DebugDll.WithDeterministic(true), assemblyName: name); 836113"];
7462 [label="param CreateCompilation(CSharpTestSource source) 836114"];
7463 [label="param CreateCompilation(IEnumerable<MetadataReference> references = null) 836115"];
7464 [label="param CreateCompilation(CSharpParseOptions parseOptions = null) 836116"];
7465 [label="param CreateCompilation(TargetFramework targetFramework = TargetFramework.Standard) 836117"];
7466 [label="param CreateCompilation(string assemblyName = '') 836118"];
7467 [label="param CreateCompilation(string sourceFileName = '') 836119"];
7468 [label="param CreateCompilation(bool skipUsesIsNullable = false) 836120"];
7469 [label="source 836121"];
7470 [label="targetFramework 836122"];
7471 [label="references 836123"];
7472 [label="TargetFrameworkUtil.GetReferences(targetFramework, references) 836124"];
7473 [label="param GetReferences(TargetFramework tf) 836125"];
7474 [label="param GetReferences(IEnumerable<MetadataReference> additionalReferences) 836126"];
7475 [label="var references = GetReferences(tf); 836127"];
7476 [label="GetReferences(tf) 836128"];
7477 [label="param GetReferences(TargetFramework targetFramework) 836129"];
7478 [label="targetFramework switch\n        {\n            TargetFramework.Empty => ImmutableArray<MetadataReference>.Empty,\n            TargetFramework.Mscorlib40 => Mscorlib40References,\n            TargetFramework.Mscorlib40Extended => Mscorlib40ExtendedReferences,\n            TargetFramework.Mscorlib40AndSystemCore => Mscorlib40andSystemCoreReferences,\n            TargetFramework.Mscorlib40AndVBRuntime => Mscorlib40andVBRuntimeReferences,\n            TargetFramework.Mscorlib45 => Mscorlib45References,\n            TargetFramework.Mscorlib45Extended => Mscorlib45ExtendedReferences,\n            TargetFramework.Mscorlib45AndCSharp => Mscorlib45AndCSharpReferences,\n            TargetFramework.Mscorlib45AndVBRuntime => Mscorlib45AndVBRuntimeReferences,\n            TargetFramework.Mscorlib46 => Mscorlib46References,\n            TargetFramework.Mscorlib46Extended => Mscorlib46ExtendedReferences,\n            TargetFramework.Mscorlib461 => Mscorlib46References,\n            TargetFramework.Mscorlib461Extended => Mscorlib461ExtendedReferences,\n            TargetFramework.NetStandard20 => NetStandard20References,\n            TargetFramework.NetCoreApp => NetCoreAppReferences,\n            TargetFramework.WinRT => WinRTReferences,\n            TargetFramework.Standard => StandardReferences,\n            TargetFramework.StandardLatest => StandardLatestReferences,\n            TargetFramework.StandardAndCSharp => StandardAndCSharpReferences,\n            TargetFramework.StandardAndVBRuntime => StandardAndVBRuntimeReferences,\n            TargetFramework.StandardCompat => StandardCompatReferences,\n            TargetFramework.DefaultVb => DefaultVbReferences,\n            TargetFramework.Minimal => MinimalReferences,\n            TargetFramework.MinimalAsync => MinimalAsyncReferences,\n            _ => throw new InvalidOperationException($'Unexpected target framework {targetFramework}'),\n        } 836130"];
7479 [label="StandardReferences 836131"];
7480 [label="RuntimeUtilities.IsCoreClrRuntime 836132"];
7481 [label="NetStandard20References 836133"];
7482 [label="ImmutableArray.Create<MetadataReference>(NetStandard20.netstandard, NetStandard20.mscorlib, NetStandard20.SystemRuntime, NetStandard20.SystemCore, NetStandard20.SystemDynamicRuntime, NetStandard20.SystemLinq, NetStandard20.SystemLinqExpressions) 836134"];
7483 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 836135"];
7484 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 836136"];
7485 [label="parseOptions 836137"];
7486 [label="assemblyName 836138"];
7487 [label="sourceFileName 836139"];
7488 [label="skipUsesIsNullable 836140"];
7489 [label="CreateEmptyCompilation(source, TargetFrameworkUtil.GetReferences(targetFramework, references), options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable) 836141"];
7490 [label="param CreateEmptyCompilation(CSharpTestSource source) 836142"];
7491 [label="param CreateEmptyCompilation(CSharpParseOptions parseOptions = null) 836143"];
7492 [label="param CreateEmptyCompilation(string assemblyName = '') 836144"];
7493 [label="param CreateEmptyCompilation(string sourceFileName = '') 836145"];
7494 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 836146"];
7495 [label="source 836147"];
7496 [label="parseOptions 836148"];
7497 [label="assemblyName 836149"];
7498 [label="sourceFileName 836150"];
7499 [label="skipUsesIsNullable 836151"];
7500 [label="null 836152"];
7501 [label="experimentalFeature: null 836153"];
7502 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 836154"];
7503 [label="param CreateCompilationCore(CSharpTestSource source) 836155"];
7504 [label="param CreateCompilationCore(CSharpParseOptions parseOptions) 836156"];
7505 [label="param CreateCompilationCore(string assemblyName) 836157"];
7506 [label="param CreateCompilationCore(string sourceFileName) 836158"];
7507 [label="param CreateCompilationCore(bool skipUsesIsNullable) 836159"];
7508 [label="param CreateCompilationCore(MessageID? experimentalFeature) 836160"];
7509 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 836161"];
7510 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 836162"];
7511 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 836163"];
7512 [label="param GetSyntaxTrees(CSharpParseOptions parseOptions) 836164"];
7513 [label="param GetSyntaxTrees(string sourceFileName = '') 836165"];
7514 [label="param GetSyntaxTrees(this) 836166"];
7515 [label="switch (Value)\n            {\n                case string source:\n                    return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) };\n                case string[] sources:\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return CSharpTestBase.Parse(parseOptions, sources);\n                case SyntaxTree tree:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return new[] { tree };\n                case SyntaxTree[] trees:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return trees;\n                case CSharpTestSource[] testSources:\n                    return testSources.SelectMany(s => s.GetSyntaxTrees(parseOptions, sourceFileName)).ToArray();\n                case null:\n                    return Array.Empty<SyntaxTree>();\n                default:\n                    throw new Exception($'Unexpected value: {Value}');\n            } 836167"];
7516 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 836168"];
7517 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 836169"];
7518 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 836170"];
7519 [label="CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) 836171"];
7520 [label="param Parse(string text) 836172"];
7521 [label="param Parse(string filename = '') 836173"];
7522 [label="param Parse(CSharpParseOptions options = null) 836174"];
7523 [label="param Parse(Encoding encoding = null) 836175"];
7524 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 836176"];
7525 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 836177"];
7526 [label="options = TestOptions.Regular; 836178"];
7527 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 836179"];
7528 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 836180"];
7529 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 836181"];
7530 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 836182"];
7531 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 836183"];
7532 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 836184"];
7533 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 836185"];
7534 [label="CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)) 836186"];
7535 [label="var stream = new MemoryStream(); 836187"];
7536 [label="var root = tree.GetRoot(); 836188"];
7537 [label="var root = tree.GetRoot(); 836189"];
7538 [label="root.SerializeTo(stream); 836190"];
7539 [label="root.SerializeTo(stream); 836191"];
7540 [label="root.SerializeTo(stream); 836192"];
7541 [label="stream.Position = 0; 836193"];
7542 [label="stream.Position 836194"];
7543 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 836195"];
7544 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 836196"];
7545 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 836197"];
7546 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 836198"];
7547 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 836199"];
7548 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 836200"];
7549 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 836201"];
7550 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 836202"];
7551 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 836203"];
7552 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 836204"];
7553 [label="param ValidateIOperations(Func<Compilation> createCompilation) 836205"];
7554 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 836206"];
7555 [label="return; 836207"];
7556 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 836208"];
7557 [label="var compilation = createCompilationLambda(); 836209"];
7558 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 836210"];
7559 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 836211"];
7560 [label="param Create(CSharpCompilation? previousSubmission) 836212"];
7561 [label="param Create(Type? returnType) 836213"];
7562 [label="param Create(Type? hostObjectType) 836214"];
7563 [label="param Create(bool isSubmission) 836215"];
7564 [label="RoslynDebug.Assert(options != null); 836216"];
7565 [label="RoslynDebug.Assert(options != null); 836217"];
7566 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 836218"];
7567 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 836219"];
7568 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 836220"];
7569 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 836221"];
7570 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 836222"];
7571 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 836223"];
7572 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 836224"];
7573 [label="new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null) 836225"];
7574 [label="param SyntaxAndDeclarationManager(ImmutableArray<SyntaxTree> externalSyntaxTrees) 836226"];
7575 [label="param SyntaxAndDeclarationManager(CommonMessageProvider messageProvider) 836227"];
7576 [label="param SyntaxAndDeclarationManager(bool isSubmission) 836228"];
7577 [label="param SyntaxAndDeclarationManager(State state) 836229"];
7578 [label="param SyntaxAndDeclarationManager(this) 836230"];
7579 [label="externalSyntaxTrees 836231"];
7580 [label="messageProvider 836232"];
7581 [label="isSubmission 836233"];
7582 [label="param SyntaxAndDeclarationManager(this) 836234"];
7583 [label="_lazyState 836235"];
7584 [label="_lazyState 836236"];
7585 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 836237"];
7586 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 836238"];
7587 [label="param CSharpCompilation(Type? submissionReturnType) 836239"];
7588 [label="param CSharpCompilation(Type? hostObjectType) 836240"];
7589 [label="param CSharpCompilation(bool isSubmission) 836241"];
7590 [label="param CSharpCompilation(ReferenceManager? referenceManager) 836242"];
7591 [label="param CSharpCompilation(bool reuseReferenceManager) 836243"];
7592 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 836244"];
7593 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 836245"];
7594 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 836246"];
7595 [label="param CSharpCompilation(this) 836247"];
7596 [label="previousSubmission 836248"];
7597 [label="submissionReturnType 836249"];
7598 [label="hostObjectType 836250"];
7599 [label="isSubmission 836251"];
7600 [label="referenceManager 836252"];
7601 [label="reuseReferenceManager 836253"];
7602 [label="syntaxAndDeclarations 836254"];
7603 [label="semanticModelProvider 836255"];
7604 [label="eventQueue 836256"];
7605 [label="param CSharpCompilation(this) 836257"];
7606 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 836258"];
7607 [label="param CSharpCompilation(Type? submissionReturnType) 836259"];
7608 [label="param CSharpCompilation(Type? hostObjectType) 836260"];
7609 [label="param CSharpCompilation(bool isSubmission) 836261"];
7610 [label="param CSharpCompilation(ReferenceManager? referenceManager) 836262"];
7611 [label="param CSharpCompilation(bool reuseReferenceManager) 836263"];
7612 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 836264"];
7613 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 836265"];
7614 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 836266"];
7615 [label="param CSharpCompilation(this) 836267"];
7616 [label="isSubmission 836268"];
7617 [label="semanticModelProvider 836269"];
7618 [label="eventQueue 836270"];
7619 [label="param CSharpCompilation(this) 836271"];
7620 [label="_options 836272"];
7621 [label="_globalImports 836273"];
7622 [label="_previousSubmissionImports 836274"];
7623 [label="_globalNamespaceAlias 836275"];
7624 [label="_scriptClass 836276"];
7625 [label="_lazyHostObjectTypeSymbol 836277"];
7626 [label="_lazyImportInfos 836278"];
7627 [label="_conversions 836279"];
7628 [label="_anonymousTypeManager 836280"];
7629 [label="_lazyGlobalNamespace 836281"];
7630 [label="builtInOperators 836282"];
7631 [label="_lazyAssemblySymbol 836283"];
7632 [label="_referenceManager 836284"];
7633 [label="_syntaxAndDeclarations 836285"];
7634 [label="_lazyEntryPoint 836286"];
7635 [label="_lazyEmitNullablePublicOnly 836287"];
7636 [label="_lazyCompilationUnitCompletedTrees 836288"];
7637 [label="NullableAnalysisData 836289"];
7638 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 836290"];
7639 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 836291"];
7640 [label="_externAliasTargets 836292"];
7641 [label="_moduleInitializerMethods 836293"];
7642 [label="_binderFactories 836294"];
7643 [label="_ignoreAccessibilityBinderFactories 836295"];
7644 [label="_lazyDeclarationDiagnostics 836296"];
7645 [label="_declarationDiagnosticsFrozen 836297"];
7646 [label="new DiagnosticBag() 836298"];
7647 [label="_additionalCodegenWarnings = new DiagnosticBag() 836299"];
7648 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 836300"];
7649 [label="this.builtInOperators = new BuiltInOperators(this); 836301"];
7650 [label="this.builtInOperators = new BuiltInOperators(this); 836302"];
7651 [label="new BuiltInOperators(this) 836303"];
7652 [label="param BuiltInOperators(CSharpCompilation compilation) 836304"];
7653 [label="param BuiltInOperators(this) 836305"];
7654 [label="_compilation 836306"];
7655 [label="_builtInUnaryOperators 836307"];
7656 [label="_builtInOperators 836308"];
7657 [label="_compilation 836309"];
7658 [label="this.builtInOperators 836310"];
7659 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 836311"];
7660 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 836312"];
7661 [label="LanguageVersion? result = null; 836313"];
7662 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 836314"];
7663 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 836315"];
7664 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 836316"];
7665 [label="this.LanguageVersion 836317"];
7666 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 836318"];
7667 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 836319"];
7668 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 836320"];
7669 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 836321"];
7670 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 836322"];
7671 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 836323"];
7672 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 836324"];
7673 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 836325"];
7674 [label="this.Options 836326"];
7675 [label="get\n            {\n                return _options;\n            } 836327"];
7676 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 836328"];
7677 [label="_syntaxAndDeclarations 836329"];
7678 [label="Debug.Assert(_lazyAssemblySymbol is null); 836330"];
7679 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 836331"];
7680 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 836332"];
7681 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 836333"];
7682 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 836334"];
7683 [label="int i = 0; 836335"];
7684 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 836336"];
7685 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 836337"];
7686 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 836338"];
7687 [label="i++; 836339"];
7688 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 836340"];
7689 [label="var scriptClassName = this.ScriptClassName; 836341"];
7690 [label="var resolver = this.Resolver; 836342"];
7691 [label="var messageProvider = this.MessageProvider; 836343"];
7692 [label="var isSubmission = this.IsSubmission; 836344"];
7693 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 836345"];
7694 [label="param CSharpCompilation(Type? submissionReturnType) 836346"];
7695 [label="param CSharpCompilation(Type? hostObjectType) 836347"];
7696 [label="previousSubmission 836348"];
7697 [label="submissionReturnType 836349"];
7698 [label="hostObjectType 836350"];
7699 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 836351"];
7700 [label="param CSharpCompilation(Type? submissionReturnType) 836352"];
7701 [label="param CSharpCompilation(Type? hostObjectType) 836353"];
7702 [label="_compilation 836354"];
7703 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 836355"];
7704 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 836356"];
7705 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 836357"];
7706 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 836358"];
7707 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 836359"];
7708 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 836360"];
7709 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 836361"];
7710 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 836362"];
7711 [label="Debug.Assert(_lazyAssemblySymbol is null); 836363"];
7712 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 836364"];
7713 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 836365"];
7714 [label="IsNullableEnabled(compilation) 836366"];
7715 [label="compilation.SyntaxTrees 836367"];
7716 [label="_syntaxAndDeclarations.GetLazyState() 836368"];
7717 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 836369"];
7718 [label="param AppendAllSyntaxTrees(SourceReferenceResolver resolver) 836370"];
7719 [label="param AppendAllSyntaxTrees(CommonMessageProvider messageProvider) 836371"];
7720 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, ImmutableArray<LoadDirective>> loadDirectiveMapBuilder) 836372"];
7721 [label="param AppendAllSyntaxTrees(IDictionary<string, SyntaxTree> loadedSyntaxTreeMapBuilder) 836373"];
7722 [label="var sourceCodeKind = tree.Options.Kind; 836374"];
7723 [label="if (sourceCodeKind == SourceCodeKind.Script)\n            {\n                AppendAllLoadedSyntaxTrees(treesBuilder, tree, scriptClassName, resolver, messageProvider, isSubmission, ordinalMapBuilder, loadDirectiveMapBuilder, loadedSyntaxTreeMapBuilder, declMapBuilder, ref declTable);\n            } 836375"];
7724 [label="OrdinalMap 836376"];
7725 [label="LoadDirectiveMap 836377"];
7726 [label="LoadedSyntaxTreeMap 836378"];
7727 [label="RootNamespaces 836379"];
7728 [label="DeclarationTable 836380"];
7729 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 836381"];
7730 [label="var options = (CSharpParseOptions)trees[0].Options; 836382"];
7731 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 836383"];
7732 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 836384"];
7733 [label="libComp.VerifyDiagnostics(); 836385"];
7734 [label="libComp.VerifyDiagnostics() 836386"];
7735 [label="param VerifyDiagnostics(params DiagnosticDescription[] expected) 836387"];
7736 [label="var diagnostics = c.GetDiagnostics(); 836388"];
7737 [label="c.GetDiagnostics() 836389"];
7738 [label="param GetDiagnostics(CancellationToken cancellationToken = default) 836390"];
7739 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 836391"];
7740 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 836392"];
7741 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 836393"];
7742 [label="GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken) 836394"];
7743 [label="param GetDiagnostics(CompilationStage stage) 836395"];
7744 [label="param GetDiagnostics(bool includeEarlierStages) 836396"];
7745 [label="param GetDiagnostics(CancellationToken cancellationToken) 836397"];
7746 [label="var diagnostics = DiagnosticBag.GetInstance(); 836398"];
7747 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 836399"];
7748 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 836400"];
7749 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 836401"];
7750 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 836402"];
7751 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 836403"];
7752 [label="param GetDiagnostics(CompilationStage stage) 836404"];
7753 [label="param GetDiagnostics(bool includeEarlierStages) 836405"];
7754 [label="param GetDiagnostics(DiagnosticBag diagnostics) 836406"];
7755 [label="param GetDiagnostics(CancellationToken cancellationToken = default) 836407"];
7756 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 836408"];
7757 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 836409"];
7758 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 836410"];
7759 [label="this.SyntaxTrees 836411"];
7760 [label="_syntaxAndDeclarations.GetLazyState() 836412"];
7761 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 836413"];
7762 [label="this.Options 836414"];
7763 [label="param AppendLoadDirectiveDiagnostics(DiagnosticBag builder) 836415"];
7764 [label="param AppendLoadDirectiveDiagnostics(Func<IEnumerable<Diagnostic>, IEnumerable<Diagnostic>>? locationFilterOpt = null) 836416"];
7765 [label="var parseOptionsReported = new HashSet<ParseOptions>(); 836417"];
7766 [label="if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    } 836418"];
7767 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 836419"];
7768 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 836420"];
7769 [label="CheckAssemblyName(builder); 836421"];
7770 [label="CheckAssemblyName(builder); 836422"];
7771 [label="Options 836423"];
7772 [label="Options 836424"];
7773 [label="get\n            {\n                return _options;\n            } 836425"];
7774 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 836426"];
7775 [label="GetBoundReferenceManager() 836427"];
7776 [label="Debug.Assert(_lazyAssemblySymbol is object); 836428"];
7777 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 836429"];
7778 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 836430"];
7779 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 836431"];
7780 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 836432"];
7781 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 836433"];
7782 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 836434"];
7783 [label="param GetSourceDeclarationDiagnostics(CancellationToken cancellationToken = default) 836435"];
7784 [label="GlobalImports 836436"];
7785 [label="_globalImports.Value 836437"];
7786 [label="Imports.FromGlobalUsings(this) 836438"];
7787 [label="GlobalImports.Complete(cancellationToken); 836439"];
7788 [label="SourceLocation? location = null; 836440"];
7789 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 836441"];
7790 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 836442"];
7791 [label="Assembly 836443"];
7792 [label="SourceAssembly 836444"];
7793 [label="GetBoundReferenceManager() 836445"];
7794 [label="GetBoundReferenceManager(); 836446"];
7795 [label="Assembly.ForceComplete(location, cancellationToken); 836447"];
7796 [label="Assembly.ForceComplete(location, cancellationToken); 836448"];
7797 [label="Assembly.ForceComplete(location, cancellationToken); 836449"];
7798 [label="Declarations 836450"];
7799 [label="_syntaxAndDeclarations.GetLazyState() 836451"];
7800 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 836452"];
7801 [label="return Declarations.GetMergedRoot(this); 836453"];
7802 [label="_syntaxAndDeclarations.GetLazyState() 836454"];
7803 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 836455"];
7804 [label="SourceAssembly 836456"];
7805 [label="GetBoundReferenceManager() 836457"];
7806 [label="GetBoundReferenceManager(); 836458"];
7807 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 836459"];
7808 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 836460"];
7809 [label="param SymbolDeclaredEvent(Symbol symbol) 836461"];
7810 [label="param SymbolDeclaredEvent(this) 836462"];
7811 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 836463"];
7812 [label="GetBoundReferenceManager() 836464"];
7813 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 836465"];
7814 [label="param GetBinderFactory(bool ignoreAccessibility = false) 836466"];
7815 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 836467"];
7816 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 836468"];
7817 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 836469"];
7818 [label="param GetBinderFactory(bool ignoreAccessibility) 836470"];
7819 [label="ignoreAccessibility 836471"];
7820 [label="GetSyntaxTreeOrdinal(syntaxTree) 836472"];
7821 [label="this.ContainsSyntaxTree(tree) 836473"];
7822 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 836474"];
7823 [label="_syntaxAndDeclarations.GetLazyState() 836475"];
7824 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 836476"];
7825 [label="_syntaxAndDeclarations.GetLazyState() 836477"];
7826 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 836478"];
7827 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 836479"];
7828 [label="BinderFactory? previousFactory; 836480"];
7829 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 836481"];
7830 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 836482"];
7831 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 836483"];
7832 [label="param AddNewFactory(bool ignoreAccessibility) 836484"];
7833 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 836485"];
7834 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 836486"];
7835 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 836487"];
7836 [label="BinderFactory? previousFactory; 836488"];
7837 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 836489"];
7838 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 836490"];
7839 [label="GetBoundReferenceManager(); 836491"];
7840 [label="Assembly 836492"];
7841 [label="SourceAssembly 836493"];
7842 [label="GetBoundReferenceManager() 836494"];
7843 [label="GetBoundReferenceManager(); 836495"];
7844 [label="return Assembly.Modules[0]; 836496"];
7845 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 836497"];
7846 [label="Debug.Assert(symbol.IsDefinition); 836498"];
7847 [label="SourceModule 836499"];
7848 [label="Assembly 836500"];
7849 [label="SourceAssembly 836501"];
7850 [label="GetBoundReferenceManager() 836502"];
7851 [label="GetBoundReferenceManager(); 836503"];
7852 [label="return Assembly.Modules[0]; 836504"];
7853 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 836505"];
7854 [label="EmitNullablePublicOnly 836506"];
7855 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 836507"];
7856 [label="_declarationDiagnosticsFrozen = true; 836508"];
7857 [label="_needsGeneratedAttributes_IsFrozen = true; 836509"];
7858 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 836510"];
7859 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 836511"];
7860 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 836512"];
7861 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 836513"];
7862 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 836514"];
7863 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 836515"];
7864 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 836516"];
7865 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 836517"];
7866 [label="param GetClsComplianceDiagnostics(CancellationToken cancellationToken) 836518"];
7867 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 836519"];
7868 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 836520"];
7869 [label="param CheckCompliance(DiagnosticBag diagnostics) 836521"];
7870 [label="System.Diagnostics.Debug.Assert(symbol is SourceAssemblySymbol); 836522"];
7871 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 836523"];
7872 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 836524"];
7873 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 836525"];
7874 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 836526"];
7875 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 836527"];
7876 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 836528"];
7877 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 836529"];
7878 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 836530"];
7879 [label="param GetDeclaredCompliance(out Location attributeLocation) 836531"];
7880 [label="param GetDeclaredCompliance(this) 836532"];
7881 [label="attributeLocation = null; 836533"];
7882 [label="if (assemblyCompliance == Compliance.DeclaredFalse)\n            {\n                // Our interpretation of an assembly-level CLSCompliant attribute is as follows:\n                //   1) If true, then perform all CLS checks.\n                //   2) If false, then perform no CLS checks (dev11 still performs a few, mostly around\n                //      meaningless attributes).  Our interpretation is that the user ultimately wants\n                //      his code to be CLS-compliant, but is temporarily disabling the checks (e.g. during\n                //      refactoring/prototyping).\n                //   3) If absent, the perform all CLS checks.  Our interpretation is that - in the\n                //      absence of an assembly-level attribute - any CLS problems within the compilation\n                //      indicate that the user was trying to do something but didn't know how.  It would\n                //      be nice if the most common case (i.e. this one) was the cheapest, but we don't\n                //      want to confuse novice users.\n                return;\n            } 836534"];
7883 [label="bool assemblyComplianceValue = IsTrue(assemblyCompliance); 836535"];
7884 [label="IsTrue(assemblyCompliance) 836536"];
7885 [label="param IsTrue(Compliance compliance) 836537"];
7886 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 836538"];
7887 [label="return false; 836539"];
7888 [label="Location attributeLocation; 836540"];
7889 [label="param GetDeclaredCompliance(out Location attributeLocation) 836541"];
7890 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 836542"];
7891 [label="i == 0 836543"];
7892 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 836544"];
7893 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 836545"];
7894 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 836546"];
7895 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 836547"];
7896 [label="if (moduleDeclaredCompliance.HasValue)\n                {\n                    if (warningLocation != null)\n                    {\n                        if (!IsDeclared(assemblyCompliance))\n                        {\n                            // This is not useful on non-source modules, but dev11 reports it anyway.\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules, warningLocation);\n                        }\n                        else if (assemblyComplianceValue != moduleDeclaredCompliance.GetValueOrDefault())\n                        {\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules2, warningLocation);\n                        }\n                    }\n                }\n                else if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 836548"];
7897 [label="if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 836549"];
7898 [label="if (assemblyComplianceValue)\n            {\n                CheckForAttributeWithArrayArgument(symbol);\n            } 836550"];
7899 [label="System.Diagnostics.Debug.Assert(symbol.Kind != SymbolKind.Assembly); 836551"];
7900 [label="System.Diagnostics.Debug.Assert((object)containing != null); 836552"];
7901 [label="return compliance; 836553"];
7902 [label="IsTrue(GetInheritedCompliance(symbol)) 836554"];
7903 [label="param IsTrue(Compliance compliance) 836555"];
7904 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 836556"];
7905 [label="return false; 836557"];
7906 [label="IsTrue(GetDeclaredOrInheritedCompliance(sourceModule)) 836558"];
7907 [label="param IsTrue(Compliance compliance) 836559"];
7908 [label="if (DoNotVisit(symbol)) return; 836560"];
7909 [label="DoNotVisit(symbol) 836561"];
7910 [label="param DoNotVisit(Symbol symbol) 836562"];
7911 [label="param DoNotVisit(this) 836563"];
7912 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                return false;\n            } 836564"];
7913 [label="return false; 836565"];
7914 [label="IsTrue(GetDeclaredOrInheritedCompliance(symbol)) 836566"];
7915 [label="param IsTrue(Compliance compliance) 836567"];
7916 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 836568"];
7917 [label="return false; 836569"];
7918 [label="if (tasks == null)\n            {\n                return;\n            } 836570"];
7919 [label="checker.WaitForWorkers(); 836571"];
7920 [label="foreach (Diagnostic diag in queue)\n            {\n                diagnostics.Add(diag);\n            } 836572"];
7921 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 836573"];
7922 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 836574"];
7923 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 836575"];
7924 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 836576"];
7925 [label="var methodBodyDiagnostics = DiagnosticBag.GetInstance(); 836577"];
7926 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 836578"];
7927 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 836579"];
7928 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken) 836580"];
7929 [label="param GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics) 836581"];
7930 [label="param GetDiagnosticsForAllMethodBodies(CancellationToken cancellationToken) 836582"];
7931 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 836583"];
7932 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 836584"];
7933 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 836585"];
7934 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken) 836586"];
7935 [label="param CompileMethodBodies(PEModuleBuilder moduleBeingBuiltOpt) 836587"];
7936 [label="param CompileMethodBodies(bool emittingPdb) 836588"];
7937 [label="param CompileMethodBodies(bool emitTestCoverageData) 836589"];
7938 [label="param CompileMethodBodies(bool hasDeclarationErrors) 836590"];
7939 [label="param CompileMethodBodies(DiagnosticBag diagnostics) 836591"];
7940 [label="param CompileMethodBodies(Predicate<Symbol> filterOpt) 836592"];
7941 [label="param CompileMethodBodies(CancellationToken cancellationToken) 836593"];
7942 [label="Debug.Assert(compilation != null); 836594"];
7943 [label="Debug.Assert(compilation != null); 836595"];
7944 [label="Debug.Assert(diagnostics != null); 836596"];
7945 [label="Debug.Assert(diagnostics != null); 836597"];
7946 [label="compilation.PreviousSubmission 836598"];
7947 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 836599"];
7948 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 836600"];
7949 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 836601"];
7950 [label="MethodSymbol entryPoint = null; 836602"];
7951 [label="if (filterOpt is null)\n            {\n                entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken);\n            } 836603"];
7952 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 836604"];
7953 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 836605"];
7954 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 836606"];
7955 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 836607"];
7956 [label="GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken) 836608"];
7957 [label="param GetEntryPoint(PEModuleBuilder moduleBeingBuilt) 836609"];
7958 [label="param GetEntryPoint(bool hasDeclarationErrors) 836610"];
7959 [label="param GetEntryPoint(DiagnosticBag diagnostics) 836611"];
7960 [label="param GetEntryPoint(CancellationToken cancellationToken) 836612"];
7961 [label="var entryPointAndDiagnostics = compilation.GetEntryPointAndDiagnostics(cancellationToken); 836613"];
7962 [label="compilation.GetEntryPointAndDiagnostics(cancellationToken) 836614"];
7963 [label="param GetEntryPointAndDiagnostics(CancellationToken cancellationToken) 836615"];
7964 [label="if (_lazyEntryPoint == null)\n            {\n                EntryPoint? entryPoint;\n                var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this);\n\n                if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                }\n\n                Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null);\n            } 836616"];
7965 [label="EntryPoint? entryPoint; 836617"];
7966 [label="Debug.Assert(!entryPointAndDiagnostics.Diagnostics.IsDefault); 836618"];
7967 [label="if ((object)entryPoint == null)\n            {\n                return null;\n            } 836619"];
7968 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 836620"];
7969 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 836621"];
7970 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 836622"];
7971 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 836623"];
7972 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 836624"];
7973 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 836625"];
7974 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 836626"];
7975 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 836627"];
7976 [label="new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken) 836628"];
7977 [label="param MethodCompiler(PEModuleBuilder moduleBeingBuiltOpt) 836629"];
7978 [label="param MethodCompiler(bool emittingPdb) 836630"];
7979 [label="param MethodCompiler(bool emitTestCoverageData) 836631"];
7980 [label="param MethodCompiler(bool hasDeclarationErrors) 836632"];
7981 [label="param MethodCompiler(DiagnosticBag diagnostics) 836633"];
7982 [label="param MethodCompiler(Predicate<Symbol> filterOpt) 836634"];
7983 [label="param MethodCompiler(CancellationToken cancellationToken) 836635"];
7984 [label="param MethodCompiler(this) 836636"];
7985 [label="param MethodCompiler(this) 836637"];
7986 [label="_compilation 836638"];
7987 [label="_emittingPdb 836639"];
7988 [label="_emitTestCoverageData 836640"];
7989 [label="_diagnostics 836641"];
7990 [label="_hasDeclarationErrors 836642"];
7991 [label="_moduleBeingBuiltOpt 836643"];
7992 [label="_filterOpt 836644"];
7993 [label="_debugDocumentProvider 836645"];
7994 [label="_entryPointOpt 836646"];
7995 [label="_compilerTasks 836647"];
7996 [label="_globalHasErrors 836648"];
7997 [label="Debug.Assert(compilation != null); 836649"];
7998 [label="Debug.Assert(compilation != null); 836650"];
7999 [label="Debug.Assert(diagnostics != null); 836651"];
8000 [label="Debug.Assert(diagnostics != null); 836652"];
8001 [label="_moduleBeingBuiltOpt 836653"];
8002 [label="_emittingPdb 836654"];
8003 [label="_cancellationToken 836655"];
8004 [label="_diagnostics 836656"];
8005 [label="_filterOpt 836657"];
8006 [label="_hasDeclarationErrors 836658"];
8007 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 836659"];
8008 [label="SetGlobalErrorIfTrue(hasDeclarationErrors) 836660"];
8009 [label="param SetGlobalErrorIfTrue(bool arg) 836661"];
8010 [label="param SetGlobalErrorIfTrue(this) 836662"];
8011 [label="if (arg)\n            {\n                _globalHasErrors = true;\n            } 836663"];
8012 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 836664"];
8013 [label="if (emittingPdb || emitTestCoverageData)\n            {\n                _debugDocumentProvider = (path, basePath) => moduleBeingBuiltOpt.DebugDocumentsBuilder.GetOrAddDebugDocument(path, basePath, CreateDebugDocumentForFile);\n            } 836665"];
8014 [label="_emitTestCoverageData 836666"];
8015 [label="compilation.Options 836667"];
8016 [label="compilation.SourceModule 836668"];
8017 [label="Assembly 836669"];
8018 [label="SourceAssembly 836670"];
8019 [label="GetBoundReferenceManager() 836671"];
8020 [label="GetBoundReferenceManager(); 836672"];
8021 [label="return Assembly.Modules[0]; 836673"];
8022 [label="methodCompiler.CompileNamespace(compilation.SourceModule.GlobalNamespace) 836674"];
8023 [label="param CompileNamespace(this) 836675"];
8024 [label="param VisitNamedType(TypeCompilationState arg) 836676"];
8025 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 836677"];
8026 [label="PassesFilter(_filterOpt, symbol) 836678"];
8027 [label="param PassesFilter(Predicate<Symbol> filterOpt) 836679"];
8028 [label="param PassesFilter(Symbol symbol) 836680"];
8029 [label="return (filterOpt == null) || filterOpt(symbol); 836681"];
8030 [label="return (filterOpt == null) || filterOpt(symbol); 836682"];
8031 [label="arg = null; 836683"];
8032 [label="param CompileNamedTypeAsync(NamedTypeSymbol symbol) 836684"];
8033 [label="methodCompiler.CompileNamespace(compilation.SourceModule.GlobalNamespace); 836685"];
8034 [label="methodCompiler.WaitForWorkers() 836686"];
8035 [label="param WaitForWorkers(this) 836687"];
8036 [label="if (tasks == null)\n            {\n                return;\n            } 836688"];
8037 [label="if (tasks == null)\n            {\n                return;\n            } 836689"];
8038 [label="Task curTask; 836690"];
8039 [label="while (tasks.TryPop(out curTask))\n            {\n                curTask.GetAwaiter().GetResult();\n            } 836691"];
8040 [label="methodCompiler.WaitForWorkers(); 836692"];
8041 [label="if (moduleBeingBuiltOpt != null)\n            {\n                var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics);\n\n                var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics);\n\n                // By this time we have processed all types reachable from module's global namespace\n                compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics);\n                methodCompiler.WaitForWorkers();\n\n                var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass;\n                if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                }\n            } 836693"];
8042 [label="if (moduleBeingBuiltOpt != null)\n            {\n                var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics);\n\n                var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics);\n\n                // By this time we have processed all types reachable from module's global namespace\n                compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics);\n                methodCompiler.WaitForWorkers();\n\n                var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass;\n                if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                }\n            } 836694"];
8043 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 836695"];
8044 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 836696"];
8045 [label="compilation.AdditionalCodegenWarnings 836697"];
8046 [label="if (filterOpt == null)\n            {\n                WarnUnusedFields(compilation, diagnostics, cancellationToken);\n\n                if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                }\n            } 836698"];
8047 [label="if (filterOpt == null)\n            {\n                WarnUnusedFields(compilation, diagnostics, cancellationToken);\n\n                if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                }\n            } 836699"];
8048 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 836700"];
8049 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 836701"];
8050 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken) 836702"];
8051 [label="param WarnUnusedFields(DiagnosticBag diagnostics) 836703"];
8052 [label="param WarnUnusedFields(CancellationToken cancellationToken) 836704"];
8053 [label="compilation.Assembly 836705"];
8054 [label="SourceAssembly 836706"];
8055 [label="GetBoundReferenceManager() 836707"];
8056 [label="GetBoundReferenceManager(); 836708"];
8057 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 836709"];
8058 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 836710"];
8059 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 836711"];
8060 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 836712"];
8061 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 836713"];
8062 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 836714"];
8063 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 836715"];
8064 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 836716"];
8065 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken) 836717"];
8066 [label="param WriteDocumentationCommentXml(string? assemblyName) 836718"];
8067 [label="param WriteDocumentationCommentXml(Stream? xmlDocStream) 836719"];
8068 [label="param WriteDocumentationCommentXml(DiagnosticBag diagnostics) 836720"];
8069 [label="param WriteDocumentationCommentXml(CancellationToken cancellationToken) 836721"];
8070 [label="param WriteDocumentationCommentXml(SyntaxTree? filterTree = null) 836722"];
8071 [label="param WriteDocumentationCommentXml(TextSpan? filterSpanWithinTree = null) 836723"];
8072 [label="StreamWriter writer = null; 836724"];
8073 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 836725"];
8074 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 836726"];
8075 [label="compilation.SourceAssembly 836727"];
8076 [label="GetBoundReferenceManager() 836728"];
8077 [label="GetBoundReferenceManager(); 836729"];
8078 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 836730"];
8079 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 836731"];
8080 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 836732"];
8081 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 836733"];
8082 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 836734"];
8083 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 836735"];
8084 [label="new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken) 836736"];
8085 [label="param DocumentationCommentCompiler(TextWriter writer) 836737"];
8086 [label="param DocumentationCommentCompiler(SyntaxTree filterTree) 836738"];
8087 [label="param DocumentationCommentCompiler(TextSpan? filterSpanWithinTree) 836739"];
8088 [label="param DocumentationCommentCompiler(bool processIncludes) 836740"];
8089 [label="param DocumentationCommentCompiler(bool isForSingleSymbol) 836741"];
8090 [label="param DocumentationCommentCompiler(DiagnosticBag diagnostics) 836742"];
8091 [label="param DocumentationCommentCompiler(CancellationToken cancellationToken) 836743"];
8092 [label="param DocumentationCommentCompiler(this) 836744"];
8093 [label="param DocumentationCommentCompiler(this) 836745"];
8094 [label="_assemblyName 836746"];
8095 [label="_compilation 836747"];
8096 [label="_writer 836748"];
8097 [label="_filterTree 836749"];
8098 [label="_filterSpanWithinTree 836750"];
8099 [label="_processIncludes 836751"];
8100 [label="_isForSingleSymbol 836752"];
8101 [label="_diagnostics 836753"];
8102 [label="_lazyComparer 836754"];
8103 [label="_includedFileCache 836755"];
8104 [label="_indentDepth 836756"];
8105 [label="_temporaryStringBuilders 836757"];
8106 [label="_writer 836758"];
8107 [label="_filterTree 836759"];
8108 [label="_filterSpanWithinTree 836760"];
8109 [label="_processIncludes 836761"];
8110 [label="_isForSingleSymbol 836762"];
8111 [label="_diagnostics 836763"];
8112 [label="_cancellationToken 836764"];
8113 [label="compilation.SourceAssembly 836765"];
8114 [label="GetBoundReferenceManager() 836766"];
8115 [label="GetBoundReferenceManager(); 836767"];
8116 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 836768"];
8117 [label="Debug.Assert(_assemblyName != null); 836769"];
8118 [label="WriteLine('<?xml version=\\'1.0\\'?>'); 836770"];
8119 [label="WriteLine('<?xml version=\\'1.0\\'?>') 836771"];
8120 [label="param WriteLine(string message) 836772"];
8121 [label="param WriteLine(this) 836773"];
8122 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836774"];
8123 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836775"];
8124 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836776"];
8125 [label="WriteLine('<doc>'); 836777"];
8126 [label="WriteLine('<doc>') 836778"];
8127 [label="param WriteLine(string message) 836779"];
8128 [label="param WriteLine(this) 836780"];
8129 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836781"];
8130 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836782"];
8131 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836783"];
8132 [label="Indent(); 836784"];
8133 [label="WriteLine('<assembly>'); 836785"];
8134 [label="WriteLine('<assembly>') 836786"];
8135 [label="param WriteLine(string message) 836787"];
8136 [label="param WriteLine(this) 836788"];
8137 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836789"];
8138 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836790"];
8139 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836791"];
8140 [label="Indent(); 836792"];
8141 [label="WriteLine('<name>{0}</name>', _assemblyName); 836793"];
8142 [label="WriteLine('<name>{0}</name>', _assemblyName) 836794"];
8143 [label="WriteLine('<name>{0}</name>', _assemblyName) 836795"];
8144 [label="param WriteLine(string format) 836796"];
8145 [label="param WriteLine(params object[] args) 836797"];
8146 [label="param WriteLine(this) 836798"];
8147 [label="WriteLine(string.Format(format, args)); 836799"];
8148 [label="WriteLine(string.Format(format, args)); 836800"];
8149 [label="WriteLine(string.Format(format, args)); 836801"];
8150 [label="WriteLine(string.Format(format, args)) 836802"];
8151 [label="param WriteLine(string message) 836803"];
8152 [label="param WriteLine(this) 836804"];
8153 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836805"];
8154 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836806"];
8155 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836807"];
8156 [label="WriteLine(string.Format(format, args)); 836808"];
8157 [label="Debug.Assert(_indentDepth >= 0); 836809"];
8158 [label="Unindent(); 836810"];
8159 [label="WriteLine('</assembly>'); 836811"];
8160 [label="WriteLine('</assembly>') 836812"];
8161 [label="param WriteLine(string message) 836813"];
8162 [label="param WriteLine(this) 836814"];
8163 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836815"];
8164 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836816"];
8165 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836817"];
8166 [label="WriteLine('<members>'); 836818"];
8167 [label="WriteLine('<members>') 836819"];
8168 [label="param WriteLine(string message) 836820"];
8169 [label="param WriteLine(this) 836821"];
8170 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836822"];
8171 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836823"];
8172 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836824"];
8173 [label="Indent(); 836825"];
8174 [label="Debug.Assert(!_isForSingleSymbol); 836826"];
8175 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 836827"];
8176 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 836828"];
8177 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 836829"];
8178 [label="docCommentNodes 836830"];
8179 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 836831"];
8180 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 836832"];
8181 [label="maxDocumentationMode = DocumentationMode.None; 836833"];
8182 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 836834"];
8183 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 836835"];
8184 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 836836"];
8185 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 836837"];
8186 [label="currDocumentationMode > maxDocumentationMode 836838"];
8187 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 836839"];
8188 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 836840"];
8189 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 836841"];
8190 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 836842"];
8191 [label="return true; 836843"];
8192 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 836844"];
8193 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 836845"];
8194 [label="return; 836846"];
8195 [label="Unindent(); 836847"];
8196 [label="WriteLine('</members>'); 836848"];
8197 [label="WriteLine('</members>') 836849"];
8198 [label="param WriteLine(string message) 836850"];
8199 [label="param WriteLine(this) 836851"];
8200 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836852"];
8201 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836853"];
8202 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836854"];
8203 [label="Unindent(); 836855"];
8204 [label="WriteLine('</doc>'); 836856"];
8205 [label="WriteLine('</doc>') 836857"];
8206 [label="param WriteLine(string message) 836858"];
8207 [label="param WriteLine(this) 836859"];
8208 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836860"];
8209 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836861"];
8210 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 836862"];
8211 [label="Debug.Assert(compiler._indentDepth == 0); 836863"];
8212 [label="Debug.Assert(compiler._indentDepth == 0); 836864"];
8213 [label="writer?.Flush(); 836865"];
8214 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 836866"];
8215 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 836867"];
8216 [label="compilation.SyntaxTrees 836868"];
8217 [label="_syntaxAndDeclarations.GetLazyState() 836869"];
8218 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 836870"];
8219 [label="param ReportUnprocessed(TextSpan? filterSpanWithinTree) 836871"];
8220 [label="param ReportUnprocessed(DiagnosticBag diagnostics) 836872"];
8221 [label="param ReportUnprocessed(CancellationToken cancellationToken) 836873"];
8222 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 836874"];
8223 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 836875"];
8224 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 836876"];
8225 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken) 836877"];
8226 [label="param ReportUnusedImports(SyntaxTree? filterTree) 836878"];
8227 [label="param ReportUnusedImports(DiagnosticBag diagnostics) 836879"];
8228 [label="param ReportUnusedImports(CancellationToken cancellationToken) 836880"];
8229 [label="param ReportUnusedImports(this) 836881"];
8230 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 836882"];
8231 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 836883"];
8232 [label="CompleteTrees(filterTree); 836884"];
8233 [label="CompleteTrees(filterTree) 836885"];
8234 [label="param CompleteTrees(SyntaxTree? filterTree) 836886"];
8235 [label="param CompleteTrees(this) 836887"];
8236 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 836888"];
8237 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 836889"];
8238 [label="CompleteTrees(filterTree); 836890"];
8239 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 836891"];
8240 [label="builder.AddRangeAndFree(methodBodyDiagnostics); 836892"];
8241 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 836893"];
8242 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 836894"];
8243 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 836895"];
8244 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 836896"];
8245 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 836897"];
8246 [label="diagnostics.Verify(expected); 836898"];
8247 [label="diagnostics.Verify(expected) 836899"];
8248 [label="param Verify(params DiagnosticDescription[] expected) 836900"];
8249 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 836901"];
8250 [label="Verify((IEnumerable<Diagnostic>)actual, expected) 836902"];
8251 [label="param Verify(params DiagnosticDescription[] expected) 836903"];
8252 [label="Verify(actual, expected, errorCodeOnly: false); 836904"];
8253 [label="Verify(actual, expected, errorCodeOnly: false); 836905"];
8254 [label="Verify(actual, expected, errorCodeOnly: false) 836906"];
8255 [label="param Verify(DiagnosticDescription[] expected) 836907"];
8256 [label="param Verify(bool errorCodeOnly) 836908"];
8257 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 836909"];
8258 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 836910"];
8259 [label="var includeDefaultSeverity = expected.Any() && expected.All(e => e.DefaultSeverity != null); 836911"];
8260 [label="var includeEffectiveSeverity = expected.Any() && expected.All(e => e.EffectiveSeverity != null); 836912"];
8261 [label="var unmatched = actual.Select(d => new DiagnosticDescription(d, errorCodeOnly, includeDefaultSeverity, includeEffectiveSeverity))\n                                  .ToList(); 836913"];
8262 [label="foreach (var d in expected)\n            {\n                int index = unmatched.IndexOf(d);\n                if (index > -1)\n                {\n                    unmatched.RemoveAt(index);\n                }\n                else\n                {\n                    CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n                }\n            } 836914"];
8263 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 836915"];
8264 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 836916"];
8265 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 836917"];
8266 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 836918"];
8267 [label="DiagnosticDescription.GetAssertText(expected, actual) 836919"];
8268 [label="param GetAssertText(DiagnosticDescription[] expected) 836920"];
8269 [label="const int CSharp = 1; 836921"];
8270 [label="const int VisualBasic = 2; 836922"];
8271 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 836923"];
8272 [label="actual.Any() && actual.First() is CSDiagnostic 836924"];
8273 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 836925"];
8274 [label="var includeDiagnosticMessagesAsComments = (language == CSharp); 836926"];
8275 [label="int indentDepth = (language == CSharp) ? 4 : 1; 836927"];
8276 [label="(language == CSharp) 836928"];
8277 [label="var includeDefaultSeverity = expected.Any() && expected.All(d => d.DefaultSeverity != null); 836929"];
8278 [label="var includeEffectiveSeverity = expected.Any() && expected.All(d => d.EffectiveSeverity != null); 836930"];
8279 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 836931"];
8280 [label="IsSortedOrEmpty(expected) 836932"];
8281 [label="param IsSortedOrEmpty(DiagnosticDescription[] diagnostics) 836933"];
8282 [label="var comparer = LinePositionComparer.Instance; 836934"];
8283 [label="DiagnosticDescription last = null; 836935"];
8284 [label="foreach (var diagnostic in diagnostics)\n            {\n                if (diagnostic._startPosition == null)\n                {\n                    return false;\n                }\n                if (last != null && comparer.Compare(last._startPosition, diagnostic._startPosition) > 0)\n                {\n                    return false;\n                }\n                last = diagnostic;\n            } 836936"];
8285 [label="return true; 836937"];
8286 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 836938"];
8287 [label="Sort(actual) 836939"];
8288 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 836940"];
8289 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 836941"];
8290 [label="var assertText = new StringBuilder(); 836942"];
8291 [label="assertText.AppendLine(); 836943"];
8292 [label="int i; 836944"];
8293 [label="assertText.AppendLine('Expected:'); 836945"];
8294 [label="assertText.AppendLine('Expected:'); 836946"];
8295 [label="var expectedText = ArrayBuilder<string>.GetInstance(); 836947"];
8296 [label="foreach (var d in expected)\n            {\n                expectedText.Add(GetDiagnosticDescription(d, indentDepth));\n            } 836948"];
8297 [label="GetCommaSeparatedLines(assertText, expectedText); 836949"];
8298 [label="GetCommaSeparatedLines(assertText, expectedText); 836950"];
8299 [label="GetCommaSeparatedLines(assertText, expectedText) 836951"];
8300 [label="param GetCommaSeparatedLines(StringBuilder sb) 836952"];
8301 [label="param GetCommaSeparatedLines(ArrayBuilder<string> lines) 836953"];
8302 [label="int n = lines.Count; 836954"];
8303 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 836955"];
8304 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 836956"];
8305 [label="GetCommaSeparatedLines(assertText, expectedText); 836957"];
8306 [label="assertText.AppendLine('Actual:'); 836958"];
8307 [label="assertText.AppendLine('Actual:'); 836959"];
8308 [label="var actualText = ArrayBuilder<string>.GetInstance(); 836960"];
8309 [label="for (i = 0; e.MoveNext(); i++)\n            {\n                Diagnostic d = e.Current;\n                string message = d.ToString();\n                if (Regex.Match(message, @'{\\d+}').Success)\n                {\n                    Assert.True(false, 'Diagnostic messages should never contain unsubstituted placeholders.\\n    ' + message);\n                }\n\n                if (i > 0)\n                {\n                    assertText.AppendLine(',');\n                }\n\n                if (includeDiagnosticMessagesAsComments)\n                {\n                    Indent(assertText, indentDepth);\n                    assertText.Append('// ');\n                    assertText.AppendLine(d.ToString());\n                    var l = d.Location;\n                    if (l.IsInSource)\n                    {\n                        Indent(assertText, indentDepth);\n                        assertText.Append('// ');\n                        assertText.AppendLine(l.SourceTree.GetText().Lines.GetLineFromPosition(l.SourceSpan.Start).ToString());\n                    }\n                }\n\n                var description = new DiagnosticDescription(d, errorCodeOnly: false, includeDefaultSeverity, includeEffectiveSeverity);\n                var diffDescription = description;\n                var idx = Array.IndexOf(expected, description);\n                if (idx != -1)\n                {\n                    diffDescription = expected[idx];\n                }\n                assertText.Append(GetDiagnosticDescription(description, indentDepth));\n                actualText.Add(GetDiagnosticDescription(diffDescription, indentDepth));\n            } 836961"];
8310 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 836962"];
8311 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 836963"];
8312 [label="assertText.AppendLine('Diff:'); 836964"];
8313 [label="assertText.AppendLine('Diff:'); 836965"];
8314 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 836966"];
8315 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 836967"];
8316 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 836968"];
8317 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 836969"];
8318 [label="DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine) 836970"];
8319 [label="param DiffReport(IEnumerable<T> expected) 836971"];
8320 [label="param DiffReport(IEnumerable<T> actual) 836972"];
8321 [label="param DiffReport(string separator) 836973"];
8322 [label="param DiffReport(IEqualityComparer<T> comparer = null) 836974"];
8323 [label="param DiffReport(Func<T, string> toString = null) 836975"];
8324 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 836976"];
8325 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 836977"];
8326 [label="(comparer != null) 836978"];
8327 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 836979"];
8328 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 836980"];
8329 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 836981"];
8330 [label="IList<T> expectedList = expected as IList<T> ?? new List<T>(expected); 836982"];
8331 [label="IList<T> actualList = actual as IList<T> ?? new List<T>(actual); 836983"];
8332 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 836984"];
8333 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 836985"];
8334 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 836986"];
8335 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 836987"];
8336 [label="lcs.CalculateDiff(expectedList, actualList, toString) 836988"];
8337 [label="param CalculateDiff(IList<T> sequenceA) 836989"];
8338 [label="param CalculateDiff(IList<T> sequenceB) 836990"];
8339 [label="param CalculateDiff(Func<T, string> toString) 836991"];
8340 [label="param CalculateDiff(this) 836992"];
8341 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 836993"];
8342 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 836994"];
8343 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 836995"];
8344 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 836996"];
8345 [label="GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count) 836997"];
8346 [label="param GetEdits(TSequence sequenceA) 836998"];
8347 [label="param GetEdits(int lengthA) 836999"];
8348 [label="param GetEdits(TSequence sequenceB) 837000"];
8349 [label="param GetEdits(int lengthB) 837001"];
8350 [label="param GetEdits(this) 837002"];
8351 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 837003"];
8352 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 837004"];
8353 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 837005"];
8354 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 837006"];
8355 [label="ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB) 837007"];
8356 [label="param ComputeCostMatrix(TSequence sequenceA) 837008"];
8357 [label="param ComputeCostMatrix(int lengthA) 837009"];
8358 [label="param ComputeCostMatrix(TSequence sequenceB) 837010"];
8359 [label="param ComputeCostMatrix(int lengthB) 837011"];
8360 [label="param ComputeCostMatrix(this) 837012"];
8361 [label="var la = lengthA + 1; 837013"];
8362 [label="var la = lengthA + 1; 837014"];
8363 [label="var lb = lengthB + 1; 837015"];
8364 [label="var lb = lengthB + 1; 837016"];
8365 [label="var d = new int[la, lb]; 837017"];
8366 [label="d[0, 0] = 0; 837018"];
8367 [label="d[0, 0] 837019"];
8368 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 837020"];
8369 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 837021"];
8370 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 837022"];
8371 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 837023"];
8372 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 837024"];
8373 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 837025"];
8374 [label="return d; 837026"];
8375 [label="int i = lengthA; 837027"];
8376 [label="int j = lengthB; 837028"];
8377 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 837029"];
8378 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 837030"];
8379 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 837031"];
8380 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 837032"];
8381 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 837033"];
8382 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 837034"];
8383 [label="param GetEdits(this) 837035"];
8384 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 837036"];
8385 [label="param CalculateDiff(this) 837037"];
8386 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 837038"];
8387 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 837039"];
8388 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 837040"];
8389 [label="actualText.Free(); 837041"];
8390 [label="expectedText.Free(); 837042"];
8391 [label="return assertText.ToString(); 837043"];
8392 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 837044"];
8393 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 837045"];
8394 [label="diagnostics.Verify(expected); 837046"];
8395 [label="VerifyAssemblyIds(c, diagnostics); 837047"];
8396 [label="VerifyAssemblyIds(c, diagnostics) 837048"];
8397 [label="param VerifyAssemblyIds(TCompilation c) 837049"];
8398 [label="param VerifyAssemblyIds(ImmutableArray<Diagnostic> diagnostics) 837050"];
8399 [label="foreach (var diagnostic in diagnostics)\n            {\n                // If this is a diagnostic about a missing assembly, make sure that we can get back\n                // an AssemblyIdentity when we query the compiler.  If it's not a diagnostic about\n                // a missing assembly, make sure we get no results back.\n                if (c.IsUnreferencedAssemblyIdentityDiagnosticCode(diagnostic.Code))\n                {\n                    var assemblyIds = c.GetUnreferencedAssemblyIdentities(diagnostic);\n                    CustomAssert.False(assemblyIds.IsEmpty);\n\n                    var diagnosticMessage = diagnostic.GetMessage();\n                    foreach (var id in assemblyIds)\n                    {\n                        CustomAssert.Contains(id.GetDisplayName(), diagnosticMessage);\n                    }\n                }\n                else\n                {\n                    var assemblyIds = c.GetUnreferencedAssemblyIdentities(diagnostic);\n                    CustomAssert.True(assemblyIds.IsEmpty);\n                }\n            } 837051"];
8400 [label="VerifyAssemblyIds(c, diagnostics); 837052"];
8401 [label="var libImage = libComp.EmitToImageReference(emitOptions); 837053"];
8402 [label="libComp.EmitToImageReference(emitOptions) 837054"];
8403 [label="param EmitToImageReference(bool embedInteropTypes = false) 837055"];
8404 [label="param EmitToImageReference(ImmutableArray<string> aliases = default) 837056"];
8405 [label="param EmitToImageReference(DiagnosticDescription[] expectedWarnings = null) 837057"];
8406 [label="embedInteropTypes 837058"];
8407 [label="aliases 837059"];
8408 [label="expectedWarnings 837060"];
8409 [label="EmitToPortableExecutableReference(comp, options, embedInteropTypes, aliases, expectedWarnings) 837061"];
8410 [label="param EmitToPortableExecutableReference(bool embedInteropTypes = false) 837062"];
8411 [label="param EmitToPortableExecutableReference(ImmutableArray<string> aliases = default) 837063"];
8412 [label="param EmitToPortableExecutableReference(DiagnosticDescription[] expectedWarnings = null) 837064"];
8413 [label="var image = comp.EmitToArray(options, expectedWarnings: expectedWarnings); 837065"];
8414 [label="var image = comp.EmitToArray(options, expectedWarnings: expectedWarnings); 837066"];
8415 [label="comp.EmitToArray(options, expectedWarnings: expectedWarnings) 837067"];
8416 [label="param EmitToArray(CompilationTestData testData = null) 837068"];
8417 [label="param EmitToArray(DiagnosticDescription[] expectedWarnings = null) 837069"];
8418 [label="param EmitToArray(Stream pdbStream = null) 837070"];
8419 [label="param EmitToArray(IMethodSymbol debugEntryPoint = null) 837071"];
8420 [label="param EmitToArray(Stream sourceLinkStream = null) 837072"];
8421 [label="param EmitToArray(IEnumerable<EmbeddedText> embeddedTexts = null) 837073"];
8422 [label="param EmitToArray(IEnumerable<ResourceDescription> manifestResources = null) 837074"];
8423 [label="param EmitToArray(Stream metadataPEStream = null) 837075"];
8424 [label="var peStream = new MemoryStream(); 837076"];
8425 [label="if (pdbStream == null && compilation.Options.OptimizationLevel == OptimizationLevel.Debug && options?.DebugInformationFormat != DebugInformationFormat.Embedded)\n            {\n                if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                }\n\n                var discretePdb = (object)options != null && options.DebugInformationFormat != DebugInformationFormat.Embedded;\n                pdbStream = discretePdb ? new MemoryStream() : null;\n            } 837077"];
8426 [label="if (pdbStream == null && compilation.Options.OptimizationLevel == OptimizationLevel.Debug && options?.DebugInformationFormat != DebugInformationFormat.Embedded)\n            {\n                if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                }\n\n                var discretePdb = (object)options != null && options.DebugInformationFormat != DebugInformationFormat.Embedded;\n                pdbStream = discretePdb ? new MemoryStream() : null;\n            } 837078"];
8427 [label="compilation.Options 837079"];
8428 [label="MonoHelpers.IsRunningOnMono() 837080"];
8429 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 837081"];
8430 [label="if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                } 837082"];
8431 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 837083"];
8432 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 837084"];
8433 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 837085"];
8434 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 837086"];
8435 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 837087"];
8436 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 837088"];
8437 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 837089"];
8438 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 837090"];
8439 [label="param CreateModuleBuilder(IMethodSymbol? debugEntryPoint) 837091"];
8440 [label="param CreateModuleBuilder(IEnumerable<EmbeddedText>? embeddedTexts) 837092"];
8441 [label="param CreateModuleBuilder(CompilationTestData? testData) 837093"];
8442 [label="param CreateModuleBuilder(DiagnosticBag diagnostics) 837094"];
8443 [label="param CreateModuleBuilder(CancellationToken cancellationToken) 837095"];
8444 [label="Debug.Assert(!IsSubmission || HasCodeToEmit()); 837096"];
8445 [label="GetRuntimeMetadataVersion(emitOptions, diagnostics) 837097"];
8446 [label="param GetRuntimeMetadataVersion(DiagnosticBag diagnostics) 837098"];
8447 [label="GetRuntimeMetadataVersion(emitOptions) 837099"];
8448 [label="param GetRuntimeMetadataVersion(EmitOptions emitOptions) 837100"];
8449 [label="Assembly 837101"];
8450 [label="SourceAssembly 837102"];
8451 [label="GetBoundReferenceManager() 837103"];
8452 [label="GetBoundReferenceManager(); 837104"];
8453 [label="if (runtimeMDVersion != null)\n            {\n                return runtimeMDVersion;\n            } 837105"];
8454 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 837106"];
8455 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 837107"];
8456 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 837108"];
8457 [label="SourceAssembly 837109"];
8458 [label="GetBoundReferenceManager() 837110"];
8459 [label="GetBoundReferenceManager(); 837111"];
8460 [label="SourceAssembly.IsDelaySigned 837112"];
8461 [label="SourceAssembly 837113"];
8462 [label="GetBoundReferenceManager() 837114"];
8463 [label="GetBoundReferenceManager(); 837115"];
8464 [label="=> 0x30 837116"];
8465 [label="0x30 837117"];
8466 [label="if (manifestResources == null)\n            {\n                manifestResources = SpecializedCollections.EmptyEnumerable<ResourceDescription>();\n            } 837118"];
8467 [label="PEModuleBuilder moduleBeingBuilt; 837119"];
8468 [label="GetBoundReferenceManager(); 837120"];
8469 [label="get\n            {\n                return true;\n            } 837121"];
8470 [label="if (sourceModule.AnyReferencedAssembliesAreLinked)\n            {\n                _embeddedTypesManagerOpt = new NoPia.EmbeddedTypesManager(this);\n            } 837122"];
8471 [label="Debug.Assert(sourceAssembly is object); 837123"];
8472 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 837124"];
8473 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 837125"];
8474 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 837126"];
8475 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 837127"];
8476 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 837128"];
8477 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 837129"];
8478 [label="PooledHashSet<int>? excludeDiagnostics = null; 837130"];
8479 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 837131"];
8480 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 837132"];
8481 [label="GetDiagnostics(CompilationStage.Declare, true, cancellationToken) 837133"];
8482 [label="param GetDiagnostics(CompilationStage stage) 837134"];
8483 [label="param GetDiagnostics(bool includeEarlierStages) 837135"];
8484 [label="var diagnostics = DiagnosticBag.GetInstance(); 837136"];
8485 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 837137"];
8486 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 837138"];
8487 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 837139"];
8488 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 837140"];
8489 [label="param GetDiagnostics(CompilationStage stage) 837141"];
8490 [label="param GetDiagnostics(bool includeEarlierStages) 837142"];
8491 [label="param GetDiagnostics(DiagnosticBag diagnostics) 837143"];
8492 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 837144"];
8493 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 837145"];
8494 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 837146"];
8495 [label="this.SyntaxTrees 837147"];
8496 [label="_syntaxAndDeclarations.GetLazyState() 837148"];
8497 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 837149"];
8498 [label="this.Options 837150"];
8499 [label="param AppendLoadDirectiveDiagnostics(DiagnosticBag builder) 837151"];
8500 [label="param AppendLoadDirectiveDiagnostics(Func<IEnumerable<Diagnostic>, IEnumerable<Diagnostic>>? locationFilterOpt = null) 837152"];
8501 [label="var parseOptionsReported = new HashSet<ParseOptions>(); 837153"];
8502 [label="if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    } 837154"];
8503 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 837155"];
8504 [label="CheckAssemblyName(builder); 837156"];
8505 [label="CheckAssemblyName(builder); 837157"];
8506 [label="Options 837158"];
8507 [label="Options 837159"];
8508 [label="get\n            {\n                return _options;\n            } 837160"];
8509 [label="return _options; 837161"];
8510 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 837162"];
8511 [label="GetBoundReferenceManager() 837163"];
8512 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 837164"];
8513 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 837165"];
8514 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 837166"];
8515 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 837167"];
8516 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 837168"];
8517 [label="GlobalImports 837169"];
8518 [label="SourceLocation? location = null; 837170"];
8519 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 837171"];
8520 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 837172"];
8521 [label="Assembly 837173"];
8522 [label="SourceAssembly 837174"];
8523 [label="GetBoundReferenceManager() 837175"];
8524 [label="GetBoundReferenceManager(); 837176"];
8525 [label="Assembly.ForceComplete(location, cancellationToken); 837177"];
8526 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 837178"];
8527 [label="_declarationDiagnosticsFrozen = true; 837179"];
8528 [label="_needsGeneratedAttributes_IsFrozen = true; 837180"];
8529 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 837181"];
8530 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 837182"];
8531 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 837183"];
8532 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 837184"];
8533 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 837185"];
8534 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 837186"];
8535 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 837187"];
8536 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 837188"];
8537 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 837189"];
8538 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 837190"];
8539 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 837191"];
8540 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 837192"];
8541 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 837193"];
8542 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 837194"];
8543 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 837195"];
8544 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 837196"];
8545 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 837197"];
8546 [label="if (hasDeclarationErrors)\n                {\n                    return false;\n                } 837198"];
8547 [label="if (moduleBeingBuilt.SourceModule.HasBadAttributes)\n                {\n                    // If there were errors but no declaration diagnostics, explicitly add a 'Failed to emit module' error.\n                    diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuilt).Name,\n                        new LocalizableResourceString(nameof(CodeAnalysisResources.ModuleHasInvalidAttributes), CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n\n                    return false;\n                } 837199"];
8548 [label="Debug.Assert(moduleBeingBuilt != null); 837200"];
8549 [label="Debug.Assert(moduleBeingBuilt != null); 837201"];
8550 [label="GetBoundReferenceManager(); 837202"];
8551 [label="return true; 837203"];
8552 [label="this.SourceModule 837204"];
8553 [label="Assembly 837205"];
8554 [label="SourceAssembly 837206"];
8555 [label="GetBoundReferenceManager() 837207"];
8556 [label="GetBoundReferenceManager(); 837208"];
8557 [label="return Assembly.Modules[0]; 837209"];
8558 [label="SourceAssembly 837210"];
8559 [label="GetBoundReferenceManager() 837211"];
8560 [label="GetBoundReferenceManager(); 837212"];
8561 [label="SourceAssembly.IsDelaySigned 837213"];
8562 [label="SourceAssembly 837214"];
8563 [label="GetBoundReferenceManager() 837215"];
8564 [label="GetBoundReferenceManager(); 837216"];
8565 [label="param GetCorLibraryReferenceToEmit(CodeAnalysis.Emit.EmitContext context) 837217"];
8566 [label="CorLibrary 837218"];
8567 [label="return Translate(corLibrary, context.Diagnostics); 837219"];
8568 [label="param Translate(DiagnosticBag diagnostics) 837220"];
8569 [label="if (ReferenceEquals(SourceModule.ContainingAssembly, assembly))\n            {\n                return (Cci.IAssemblyReference)this;\n            } 837221"];
8570 [label="_targetAssembly 837222"];
8571 [label="Debug.Assert((object)assemblySymbol != null); 837223"];
8572 [label="if (cachedAsmRef == asmRef)\n            {\n                ValidateReferencedAssembly(assembly, cachedAsmRef, diagnostics);\n            } 837224"];
8573 [label="ValidateReferencedAssembly(assembly, cachedAsmRef, diagnostics); 837225"];
8574 [label="ValidateReferencedAssembly(assembly, cachedAsmRef, diagnostics); 837226"];
8575 [label="ValidateReferencedAssembly(assembly, cachedAsmRef, diagnostics) 837227"];
8576 [label="param ValidateReferencedAssembly(AssemblySymbol assembly) 837228"];
8577 [label="param ValidateReferencedAssembly(AssemblyReference asmRef) 837229"];
8578 [label="param ValidateReferencedAssembly(DiagnosticBag diagnostics) 837230"];
8579 [label="param ValidateReferencedAssembly(this) 837231"];
8580 [label="AssemblyIdentity asmIdentity = SourceModule.ContainingAssembly.Identity; 837232"];
8581 [label="asmRef.Identity 837233"];
8582 [label="=> _targetAssembly.Identity 837234"];
8583 [label="AssemblyIdentity refIdentity = asmRef.Identity; 837235"];
8584 [label="if (asmIdentity.IsStrongName && !refIdentity.IsStrongName &&\n                asmRef.Identity.ContentType != AssemblyContentType.WindowsRuntime)\n            {\n                // Dev12 reported error, we have changed it to a warning to allow referencing libraries \n                // built for platforms that don't support strong names.\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName, assembly), NoLocation.Singleton);\n            } 837236"];
8585 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 837237"];
8586 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 837238"];
8587 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 837239"];
8588 [label="var refMachine = assembly.Machine; 837240"];
8589 [label="if ((object)assembly != (object)assembly.CorLibrary &&\n                !(refMachine == Machine.I386 && !assembly.Bit32Required))\n            {\n                var machine = SourceModule.Machine;\n\n                if (!(machine == Machine.I386 && !SourceModule.Bit32Required) &&\n                    machine != refMachine)\n                {\n                    // Different machine types, and neither is agnostic\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_ConflictingMachineAssembly, assembly), NoLocation.Singleton);\n                }\n            } 837241"];
8590 [label="if (_embeddedTypesManagerOpt != null && _embeddedTypesManagerOpt.IsFrozen)\n            {\n                _embeddedTypesManagerOpt.ReportIndirectReferencesToLinkedAssemblies(assembly, diagnostics);\n            } 837242"];
8591 [label="if (_embeddedTypesManagerOpt != null && _embeddedTypesManagerOpt.IsFrozen)\n            {\n                _embeddedTypesManagerOpt.ReportIndirectReferencesToLinkedAssemblies(assembly, diagnostics);\n            } 837243"];
8592 [label="ValidateReferencedAssembly(assembly, cachedAsmRef, diagnostics); 837244"];
8593 [label="param GetAssemblyReferencesFromAddedModules(DiagnosticBag diagnostics) 837245"];
8594 [label="ImmutableArray<ModuleSymbol> modules = SourceModule.ContainingAssembly.Modules; 837246"];
8595 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 837247"];
8596 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 837248"];
8597 [label="param GetAssemblyReferencesFromAddedModules(this) 837249"];
8598 [label="return getFiles(ref _lazyFilesWithoutManifestResources, context, _sourceAssembly); 837250"];
8599 [label="return getFiles(ref _lazyFilesWithoutManifestResources, context, _sourceAssembly); 837251"];
8600 [label="getFiles(ref _lazyFilesWithoutManifestResources, context, _sourceAssembly) 837252"];
8601 [label="ImmutableArray<Cci.IFileReference> getFiles(ref ImmutableArray<Cci.IFileReference> lazyFiles, EmitContext contxt, SourceAssemblySymbol sourceAssSymbol)\n            {\n                if (lazyFiles.IsDefault)\n                {\n                    var builder = ArrayBuilder<Cci.IFileReference>.GetInstance();\n                    try\n                    {\n                        var modules = sourceAssSymbol.Modules;\n                        for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        }\n\n                        if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        }\n\n                        // Dev12 compilers don't report ERR_CryptoHashFailed if there are no files to be hashed.\n                        if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        }\n                    }\n                    finally\n                    {\n                        builder.Free();\n                    }\n                }\n\n                return lazyFiles;\n            } 837253"];
8602 [label="ImmutableArray<Cci.IFileReference> getFiles(ref ImmutableArray<Cci.IFileReference> lazyFiles, EmitContext contxt, SourceAssemblySymbol sourceAssSymbol)\n            {\n                if (lazyFiles.IsDefault)\n                {\n                    var builder = ArrayBuilder<Cci.IFileReference>.GetInstance();\n                    try\n                    {\n                        var modules = sourceAssSymbol.Modules;\n                        for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        }\n\n                        if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        }\n\n                        // Dev12 compilers don't report ERR_CryptoHashFailed if there are no files to be hashed.\n                        if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        }\n                    }\n                    finally\n                    {\n                        builder.Free();\n                    }\n                }\n\n                return lazyFiles;\n            } 837254"];
8603 [label="ImmutableArray<Cci.IFileReference> getFiles(ref ImmutableArray<Cci.IFileReference> lazyFiles, EmitContext contxt, SourceAssemblySymbol sourceAssSymbol)\n            {\n                if (lazyFiles.IsDefault)\n                {\n                    var builder = ArrayBuilder<Cci.IFileReference>.GetInstance();\n                    try\n                    {\n                        var modules = sourceAssSymbol.Modules;\n                        for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        }\n\n                        if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        }\n\n                        // Dev12 compilers don't report ERR_CryptoHashFailed if there are no files to be hashed.\n                        if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        }\n                    }\n                    finally\n                    {\n                        builder.Free();\n                    }\n                }\n\n                return lazyFiles;\n            } 837255"];
8604 [label="var modules = sourceAssSymbol.Modules; 837256"];
8605 [label="for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        } 837257"];
8606 [label="for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        } 837258"];
8607 [label="if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        } 837259"];
8608 [label="param GetAdditionalTopLevelTypeDefinitions(EmitContext context) 837260"];
8609 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 837261"];
8610 [label="GetAdditionalTopLevelTypes(context.Diagnostics) 837262"];
8611 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 837263"];
8612 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 837264"];
8613 [label="param GetEmbeddedTypeDefinitions(EmitContext context) 837265"];
8614 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 837266"];
8615 [label="GetEmbeddedTypes(context.Diagnostics) 837267"];
8616 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 837268"];
8617 [label="var builder = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 837269"];
8618 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 837270"];
8619 [label="CreateEmbeddedAttributesIfNeeded(diagnostics) 837271"];
8620 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 837272"];
8621 [label="GetNeedsGeneratedAttributes() 837273"];
8622 [label="_needsGeneratedAttributes_IsFrozen = true; 837274"];
8623 [label="GetNeedsGeneratedAttributesInternal() 837275"];
8624 [label="return GetNeedsGeneratedAttributesInternal(); 837276"];
8625 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 837277"];
8626 [label="ShouldEmitNullablePublicOnlyAttribute() 837278"];
8627 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 837279"];
8628 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 837280"];
8629 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 837281"];
8630 [label="return; 837282"];
8631 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 837283"];
8632 [label="builder.AddIfNotNull(_lazyEmbeddedAttribute); 837284"];
8633 [label="builder.AddIfNotNull(_lazyIsReadOnlyAttribute); 837285"];
8634 [label="builder.AddIfNotNull(_lazyIsUnmanagedAttribute); 837286"];
8635 [label="builder.AddIfNotNull(_lazyIsByRefLikeAttribute); 837287"];
8636 [label="builder.AddIfNotNull(_lazyNullableAttribute); 837288"];
8637 [label="builder.AddIfNotNull(_lazyNullableContextAttribute); 837289"];
8638 [label="builder.AddIfNotNull(_lazyNullablePublicOnlyAttribute); 837290"];
8639 [label="builder.AddIfNotNull(_lazyNativeIntegerAttribute); 837291"];
8640 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 837292"];
8641 [label="param GetTopLevelSourceTypeDefinitions(EmitContext context) 837293"];
8642 [label="var namespacesToProcess = new Stack<NamespaceSymbol>(); 837294"];
8643 [label="while (namespacesToProcess.Count > 0)\n            {\n                var ns = namespacesToProcess.Pop();\n                foreach (var member in ns.GetMembers())\n                {\n                    if (member.Kind == SymbolKind.Namespace)\n                    {\n                        namespacesToProcess.Push((NamespaceSymbol)member);\n                    }\n                    else\n                    {\n                        yield return ((NamedTypeSymbol)member).GetCciAdapter();\n                    }\n                }\n            } 837295"];
8644 [label="param GetSynthesizedNestedTypes(NamedTypeSymbol container) 837296"];
8645 [label="param GetSynthesizedNestedTypes(this) 837297"];
8646 [label="return null; 837298"];
8647 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 837299"];
8648 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 837300"];
8649 [label="NamedTypeSymbol result; 837301"];
8650 [label="GetBoundReferenceManager(); 837302"];
8651 [label="Debug.Assert(result.SpecialType == specialType); 837303"];
8652 [label="SourceAssembly 837304"];
8653 [label="GetBoundReferenceManager() 837305"];
8654 [label="GetBoundReferenceManager(); 837306"];
8655 [label="GetBoundReferenceManager() 837307"];
8656 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 837308"];
8657 [label="param Translate(DiagnosticBag diagnostics) 837309"];
8658 [label="param Translate(bool needDeclaration = false) 837310"];
8659 [label="param Translate(this) 837311"];
8660 [label="Debug.Assert(optArgList == null || (methodSymbol.IsVararg && !needDeclaration)); 837312"];
8661 [label="Debug.Assert(optArgList == null || (methodSymbol.IsVararg && !needDeclaration)); 837313"];
8662 [label="Translate(methodSymbol, syntaxNodeOpt, diagnostics, needDeclaration) 837314"];
8663 [label="param Translate(SyntaxNode syntaxNodeOpt) 837315"];
8664 [label="param Translate(DiagnosticBag diagnostics) 837316"];
8665 [label="param Translate(bool needDeclaration) 837317"];
8666 [label="param Translate(this) 837318"];
8667 [label="object reference; 837319"];
8668 [label="Cci.IMethodReference methodRef; 837320"];
8669 [label="NamedTypeSymbol container = methodSymbol.ContainingType; 837321"];
8670 [label="if (container.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                methodSymbol = AnonymousTypeManager.TranslateAnonymousTypeMethodSymbol(methodSymbol);\n            } 837322"];
8671 [label="if (!methodSymbol.IsDefinition)\n            {\n                Debug.Assert(!needDeclaration);\n                Debug.Assert(!(methodSymbol.OriginalDefinition is NativeIntegerMethodSymbol));\n                Debug.Assert(!(methodSymbol.ConstructedFrom is NativeIntegerMethodSymbol));\n\n                return (Cci.IMethodReference)GetCciAdapter(methodSymbol);\n            }\n            else if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 837323"];
8672 [label="if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 837324"];
8673 [label="bool methodIsGeneric = methodSymbol.IsGenericMethod; 837325"];
8674 [label="bool typeIsGeneric = IsGenericType(container); 837326"];
8675 [label="IsGenericType(container) 837327"];
8676 [label="param IsGenericType(NamedTypeSymbol toCheck) 837328"];
8677 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837329"];
8678 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837330"];
8679 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 837331"];
8680 [label="toCheck = toCheck.ContainingType; 837332"];
8681 [label="return false; 837333"];
8682 [label="bool typeIsGeneric = IsGenericType(container); 837334"];
8683 [label="if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 837335"];
8684 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 837336"];
8685 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 837337"];
8686 [label="if (_embeddedTypesManagerOpt != null)\n            {\n                return _embeddedTypesManagerOpt.EmbedMethodIfNeedTo(methodSymbol.GetCciAdapter(), syntaxNodeOpt, diagnostics);\n            } 837338"];
8687 [label="if (_embeddedTypesManagerOpt != null)\n            {\n                return _embeddedTypesManagerOpt.EmbedMethodIfNeedTo(methodSymbol.GetCciAdapter(), syntaxNodeOpt, diagnostics);\n            } 837339"];
8688 [label="if (optArgList != null && optArgList.Arguments.Length > 0)\n            {\n                Cci.IParameterTypeInformation[] @params = new Cci.IParameterTypeInformation[optArgList.Arguments.Length];\n                int ordinal = methodSymbol.ParameterCount;\n\n                for (int i = 0; i < @params.Length; i++)\n                {\n                    @params[i] = new ArgListParameterTypeInformation(ordinal,\n                                                                    !optArgList.ArgumentRefKindsOpt.IsDefaultOrEmpty && optArgList.ArgumentRefKindsOpt[i] != RefKind.None,\n                                                                    Translate(optArgList.Arguments[i].Type, syntaxNodeOpt, diagnostics));\n                    ordinal++;\n                }\n\n                return new ExpandedVarargsMethodReference(unexpandedMethodRef, @params.AsImmutableOrNull());\n            }\n            else\n            {\n                return unexpandedMethodRef;\n            } 837340"];
8689 [label="param Translate(SyntaxNode syntaxNodeOpt) 837341"];
8690 [label="param Translate(DiagnosticBag diagnostics) 837342"];
8691 [label="Debug.Assert(diagnostics != null); 837343"];
8692 [label="Debug.Assert(diagnostics != null); 837344"];
8693 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 837345"];
8694 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 837346"];
8695 [label="param Translate(SyntaxNode syntaxNodeOpt) 837347"];
8696 [label="param Translate(DiagnosticBag diagnostics) 837348"];
8697 [label="param Translate(bool fromImplements = false) 837349"];
8698 [label="param Translate(bool needDeclaration = false) 837350"];
8699 [label="Debug.Assert(diagnostics != null); 837351"];
8700 [label="Debug.Assert(diagnostics != null); 837352"];
8701 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 837353"];
8702 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 837354"];
8703 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 837355"];
8704 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 837356"];
8705 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 837357"];
8706 [label="object reference; 837358"];
8707 [label="Cci.INamedTypeReference typeRef; 837359"];
8708 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 837360"];
8709 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 837361"];
8710 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 837362"];
8711 [label="IsGenericType(container) 837363"];
8712 [label="param IsGenericType(NamedTypeSymbol toCheck) 837364"];
8713 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837365"];
8714 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837366"];
8715 [label="return false; 837367"];
8716 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 837368"];
8717 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 837369"];
8718 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 837370"];
8719 [label="param Translate(SyntaxNode syntaxNodeOpt) 837371"];
8720 [label="param Translate(DiagnosticBag diagnostics) 837372"];
8721 [label="param Translate(bool fromImplements = false) 837373"];
8722 [label="param Translate(bool needDeclaration = false) 837374"];
8723 [label="Debug.Assert(diagnostics != null); 837375"];
8724 [label="Debug.Assert(diagnostics != null); 837376"];
8725 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 837377"];
8726 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 837378"];
8727 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 837379"];
8728 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 837380"];
8729 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 837381"];
8730 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 837382"];
8731 [label="param Translate(DiagnosticBag diagnostics) 837383"];
8732 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 837384"];
8733 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 837385"];
8734 [label="if ((object)module == null)\n            {\n                return null;\n            } 837386"];
8735 [label="if ((object)module == null)\n            {\n                return null;\n            } 837387"];
8736 [label="Cci.IModuleReference moduleRef; 837388"];
8737 [label="if (AssemblyOrModuleSymbolToModuleRefMap.TryGetValue(module, out moduleRef))\n            {\n                return moduleRef;\n            } 837389"];
8738 [label="param Translate(this) 837390"];
8739 [label="Debug.Assert(@params.All(p => p.IsDefinitionOrDistinct())); 837391"];
8740 [label="MustBeWrapped(@params.First()) 837392"];
8741 [label="param MustBeWrapped(ParameterSymbol param) 837393"];
8742 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 837394"];
8743 [label="var container = param.ContainingSymbol; 837395"];
8744 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 837396"];
8745 [label="ContainerIsGeneric(container) 837397"];
8746 [label="param ContainerIsGeneric(Symbol container) 837398"];
8747 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837399"];
8748 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837400"];
8749 [label="IsGenericType(container.ContainingType) 837401"];
8750 [label="param IsGenericType(NamedTypeSymbol toCheck) 837402"];
8751 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837403"];
8752 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837404"];
8753 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 837405"];
8754 [label="toCheck = toCheck.ContainingType; 837406"];
8755 [label="return false; 837407"];
8756 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837408"];
8757 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837409"];
8758 [label="return false; 837410"];
8759 [label="bool mustBeTranslated = @params.Any() && MustBeWrapped(@params.First()); 837411"];
8760 [label="Debug.Assert(@params.All(p => mustBeTranslated == MustBeWrapped(p)), 'either all or no parameters need translating'); 837412"];
8761 [label="param MustBeWrapped(ParameterSymbol param) 837413"];
8762 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 837414"];
8763 [label="var container = param.ContainingSymbol; 837415"];
8764 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 837416"];
8765 [label="ContainerIsGeneric(container) 837417"];
8766 [label="param ContainerIsGeneric(Symbol container) 837418"];
8767 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837419"];
8768 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837420"];
8769 [label="IsGenericType(container.ContainingType) 837421"];
8770 [label="param IsGenericType(NamedTypeSymbol toCheck) 837422"];
8771 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837423"];
8772 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837424"];
8773 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 837425"];
8774 [label="toCheck = toCheck.ContainingType; 837426"];
8775 [label="return false; 837427"];
8776 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837428"];
8777 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837429"];
8778 [label="return false; 837430"];
8779 [label="if ((object)namedType != null)\n            {\n                if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                }\n\n                return namedType.SpecialType == (SpecialType)platformType;\n            } 837431"];
8780 [label="param Translate(SyntaxNode syntaxNodeOpt) 837432"];
8781 [label="NamedTypeSymbol container = methodSymbol.ContainingType; 837433"];
8782 [label="if (container.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                methodSymbol = AnonymousTypeManager.TranslateAnonymousTypeMethodSymbol(methodSymbol);\n            } 837434"];
8783 [label="Debug.Assert(methodSymbol.IsDefinitionOrDistinct()); 837435"];
8784 [label="if (!methodSymbol.IsDefinition)\n            {\n                Debug.Assert(!needDeclaration);\n                Debug.Assert(!(methodSymbol.OriginalDefinition is NativeIntegerMethodSymbol));\n                Debug.Assert(!(methodSymbol.ConstructedFrom is NativeIntegerMethodSymbol));\n\n                return (Cci.IMethodReference)GetCciAdapter(methodSymbol);\n            }\n            else if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 837436"];
8785 [label="if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 837437"];
8786 [label="bool methodIsGeneric = methodSymbol.IsGenericMethod; 837438"];
8787 [label="bool typeIsGeneric = IsGenericType(container); 837439"];
8788 [label="IsGenericType(container) 837440"];
8789 [label="param IsGenericType(NamedTypeSymbol toCheck) 837441"];
8790 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837442"];
8791 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837443"];
8792 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 837444"];
8793 [label="toCheck = toCheck.ContainingType; 837445"];
8794 [label="return false; 837446"];
8795 [label="bool typeIsGeneric = IsGenericType(container); 837447"];
8796 [label="if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 837448"];
8797 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 837449"];
8798 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 837450"];
8799 [label="if (_embeddedTypesManagerOpt != null)\n            {\n                return _embeddedTypesManagerOpt.EmbedMethodIfNeedTo(methodSymbol.GetCciAdapter(), syntaxNodeOpt, diagnostics);\n            } 837451"];
8800 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 837452"];
8801 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 837453"];
8802 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 837454"];
8803 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 837455"];
8804 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 837456"];
8805 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 837457"];
8806 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 837458"];
8807 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 837459"];
8808 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 837460"];
8809 [label="param Translate(SyntaxNode syntaxNodeOpt) 837461"];
8810 [label="param Translate(DiagnosticBag diagnostics) 837462"];
8811 [label="param Translate(bool fromImplements = false) 837463"];
8812 [label="param Translate(bool needDeclaration = false) 837464"];
8813 [label="Debug.Assert(diagnostics != null); 837465"];
8814 [label="Debug.Assert(diagnostics != null); 837466"];
8815 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 837467"];
8816 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 837468"];
8817 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 837469"];
8818 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 837470"];
8819 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 837471"];
8820 [label="object reference; 837472"];
8821 [label="Cci.INamedTypeReference typeRef; 837473"];
8822 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 837474"];
8823 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 837475"];
8824 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 837476"];
8825 [label="IsGenericType(container) 837477"];
8826 [label="param IsGenericType(NamedTypeSymbol toCheck) 837478"];
8827 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837479"];
8828 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837480"];
8829 [label="return false; 837481"];
8830 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 837482"];
8831 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 837483"];
8832 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 837484"];
8833 [label="NamedTypeSymbol container = methodSymbol.ContainingType; 837485"];
8834 [label="if (container.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                methodSymbol = AnonymousTypeManager.TranslateAnonymousTypeMethodSymbol(methodSymbol);\n            } 837486"];
8835 [label="bool typeIsGeneric = IsGenericType(container); 837487"];
8836 [label="param IsGenericType(NamedTypeSymbol toCheck) 837488"];
8837 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837489"];
8838 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 837490"];
8839 [label="toCheck = toCheck.ContainingType; 837491"];
8840 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 837492"];
8841 [label="toCheck = toCheck.ContainingType; 837493"];
8842 [label="param MustBeWrapped(ParameterSymbol param) 837494"];
8843 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 837495"];
8844 [label="var container = param.ContainingSymbol; 837496"];
8845 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 837497"];
8846 [label="ContainerIsGeneric(container) 837498"];
8847 [label="param ContainerIsGeneric(Symbol container) 837499"];
8848 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837500"];
8849 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837501"];
8850 [label="IsGenericType(container.ContainingType) 837502"];
8851 [label="param IsGenericType(NamedTypeSymbol toCheck) 837503"];
8852 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837504"];
8853 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837505"];
8854 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 837506"];
8855 [label="toCheck = toCheck.ContainingType; 837507"];
8856 [label="return false; 837508"];
8857 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837509"];
8858 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837510"];
8859 [label="param MustBeWrapped(ParameterSymbol param) 837511"];
8860 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 837512"];
8861 [label="var container = param.ContainingSymbol; 837513"];
8862 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 837514"];
8863 [label="ContainerIsGeneric(container) 837515"];
8864 [label="param ContainerIsGeneric(Symbol container) 837516"];
8865 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837517"];
8866 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837518"];
8867 [label="IsGenericType(container.ContainingType) 837519"];
8868 [label="param IsGenericType(NamedTypeSymbol toCheck) 837520"];
8869 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837521"];
8870 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837522"];
8871 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 837523"];
8872 [label="toCheck = toCheck.ContainingType; 837524"];
8873 [label="return false; 837525"];
8874 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837526"];
8875 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837527"];
8876 [label="return SourceModule.ContainingSourceAssembly.GetSecurityAttributes(); 837528"];
8877 [label="return Translate(corLibrary, context.Diagnostics); 837529"];
8878 [label="param Translate(DiagnosticBag diagnostics) 837530"];
8879 [label="if (ReferenceEquals(SourceModule.ContainingAssembly, assembly))\n            {\n                return (Cci.IAssemblyReference)this;\n            } 837531"];
8880 [label="ImmutableArray<ModuleSymbol> modules = SourceModule.ContainingAssembly.Modules; 837532"];
8881 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 837533"];
8882 [label="return SourceModule.GetCustomAttributesToEmit(this); 837534"];
8883 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 837535"];
8884 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 837536"];
8885 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 837537"];
8886 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 837538"];
8887 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 837539"];
8888 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 837540"];
8889 [label="return GetNeedsGeneratedAttributesInternal(); 837541"];
8890 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 837542"];
8891 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 837543"];
8892 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 837544"];
8893 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 837545"];
8894 [label="return; 837546"];
8895 [label="Debug.Assert(symbol.IsDefinition); 837547"];
8896 [label="SourceModule 837548"];
8897 [label="Assembly 837549"];
8898 [label="SourceAssembly 837550"];
8899 [label="GetBoundReferenceManager() 837551"];
8900 [label="GetBoundReferenceManager(); 837552"];
8901 [label="return Assembly.Modules[0]; 837553"];
8902 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 837554"];
8903 [label="EmitNullablePublicOnly 837555"];
8904 [label="param SynthesizeNullableAttributeIfNecessary(this) 837556"];
8905 [label="param GetExportedTypes(DiagnosticBag diagnostics) 837557"];
8906 [label="Debug.Assert(HaveDeterminedTopLevelTypes); 837558"];
8907 [label="if (!OutputKind.IsNetModule())\n            {\n                var modules = sourceAssembly.Modules;\n                for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                }\n            } 837559"];
8908 [label="var modules = sourceAssembly.Modules; 837560"];
8909 [label="for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                } 837561"];
8910 [label="for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                } 837562"];
8911 [label="Debug.Assert(OutputKind.IsNetModule() == sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule()); 837563"];
8912 [label="sourceAssembly.DeclaringCompilation.Options 837564"];
8913 [label="Debug.Assert(OutputKind.IsNetModule() == sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule()); 837565"];
8914 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 837566"];
8915 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder) 837567"];
8916 [label="param GetForwardedTypes(HashSet<NamedTypeSymbol> seenTopLevelTypes) 837568"];
8917 [label="param GetForwardedTypes(CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData) 837569"];
8918 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 837570"];
8919 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 837571"];
8920 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 837572"];
8921 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder); 837573"];
8922 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder) 837574"];
8923 [label="param GetForwardedTypes(HashSet<NamedTypeSymbol> seenTopLevelTypes) 837575"];
8924 [label="param GetForwardedTypes(CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData) 837576"];
8925 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 837577"];
8926 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 837578"];
8927 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 837579"];
8928 [label="return seenTopLevelForwardedTypes; 837580"];
8929 [label="if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                } 837581"];
8930 [label="if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                } 837582"];
8931 [label="=> ImmutableArray<Cci.UsedNamespaceOrType>.Empty 837583"];
8932 [label="ImmutableArray<Cci.UsedNamespaceOrType>.Empty 837584"];
8933 [label="Debug.Assert(HaveDeterminedTopLevelTypes); 837585"];
8934 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 837586"];
8935 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 837587"];
8936 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 837588"];
8937 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 837589"];
8938 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 837590"];
8939 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 837591"];
8940 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 837592"];
8941 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 837593"];
8942 [label="GetBoundReferenceManager(); 837594"];
8943 [label="Debug.Assert(result.SpecialType == specialType); 837595"];
8944 [label="NamedTypeSymbol container = methodSymbol.ContainingType; 837596"];
8945 [label="if (container.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                methodSymbol = AnonymousTypeManager.TranslateAnonymousTypeMethodSymbol(methodSymbol);\n            } 837597"];
8946 [label="if (!methodSymbol.IsDefinition)\n            {\n                Debug.Assert(!needDeclaration);\n                Debug.Assert(!(methodSymbol.OriginalDefinition is NativeIntegerMethodSymbol));\n                Debug.Assert(!(methodSymbol.ConstructedFrom is NativeIntegerMethodSymbol));\n\n                return (Cci.IMethodReference)GetCciAdapter(methodSymbol);\n            }\n            else if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 837598"];
8947 [label="if (!needDeclaration)\n            {\n                bool methodIsGeneric = methodSymbol.IsGenericMethod;\n                bool typeIsGeneric = IsGenericType(container);\n\n                if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                }\n            } 837599"];
8948 [label="bool methodIsGeneric = methodSymbol.IsGenericMethod; 837600"];
8949 [label="bool typeIsGeneric = IsGenericType(container); 837601"];
8950 [label="IsGenericType(container) 837602"];
8951 [label="param IsGenericType(NamedTypeSymbol toCheck) 837603"];
8952 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837604"];
8953 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837605"];
8954 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 837606"];
8955 [label="toCheck = toCheck.ContainingType; 837607"];
8956 [label="return false; 837608"];
8957 [label="bool typeIsGeneric = IsGenericType(container); 837609"];
8958 [label="if (methodIsGeneric || typeIsGeneric)\n                {\n                    if (_genericInstanceMap.TryGetValue(methodSymbol, out reference))\n                    {\n                        return (Cci.IMethodReference)reference;\n                    }\n\n                    if (methodIsGeneric)\n                    {\n                        if (typeIsGeneric)\n                        {\n                            // Specialized and generic instance at the same time.\n                            methodRef = new SpecializedGenericMethodInstanceReference(methodSymbol);\n                        }\n                        else\n                        {\n                            methodRef = new GenericMethodInstanceReference(methodSymbol);\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(typeIsGeneric);\n                        methodRef = new SpecializedMethodReference(methodSymbol);\n                    }\n\n                    methodRef = (Cci.IMethodReference)_genericInstanceMap.GetOrAdd(methodSymbol, methodRef);\n\n                    return methodRef;\n                }\n                else if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 837610"];
8959 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 837611"];
8960 [label="if (methodSymbol is NativeIntegerMethodSymbol { UnderlyingMethod: MethodSymbol underlyingMethod })\n                {\n                    methodSymbol = underlyingMethod;\n                } 837612"];
8961 [label="if (_embeddedTypesManagerOpt != null)\n            {\n                return _embeddedTypesManagerOpt.EmbedMethodIfNeedTo(methodSymbol.GetCciAdapter(), syntaxNodeOpt, diagnostics);\n            } 837613"];
8962 [label="param MustBeWrapped(ParameterSymbol param) 837614"];
8963 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 837615"];
8964 [label="var container = param.ContainingSymbol; 837616"];
8965 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 837617"];
8966 [label="ContainerIsGeneric(container) 837618"];
8967 [label="param ContainerIsGeneric(Symbol container) 837619"];
8968 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837620"];
8969 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837621"];
8970 [label="IsGenericType(container.ContainingType) 837622"];
8971 [label="param IsGenericType(NamedTypeSymbol toCheck) 837623"];
8972 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837624"];
8973 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837625"];
8974 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 837626"];
8975 [label="toCheck = toCheck.ContainingType; 837627"];
8976 [label="return false; 837628"];
8977 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837629"];
8978 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837630"];
8979 [label="param MustBeWrapped(ParameterSymbol param) 837631"];
8980 [label="if (param.IsDefinition)\n            {\n                var container = param.ContainingSymbol;\n                if (ContainerIsGeneric(container))\n                {\n                    return true;\n                }\n            } 837632"];
8981 [label="var container = param.ContainingSymbol; 837633"];
8982 [label="if (ContainerIsGeneric(container))\n                {\n                    return true;\n                } 837634"];
8983 [label="ContainerIsGeneric(container) 837635"];
8984 [label="param ContainerIsGeneric(Symbol container) 837636"];
8985 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837637"];
8986 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837638"];
8987 [label="IsGenericType(container.ContainingType) 837639"];
8988 [label="param IsGenericType(NamedTypeSymbol toCheck) 837640"];
8989 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837641"];
8990 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837642"];
8991 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 837643"];
8992 [label="toCheck = toCheck.ContainingType; 837644"];
8993 [label="return false; 837645"];
8994 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837646"];
8995 [label="return container.Kind == SymbolKind.Method && ((MethodSymbol)container).IsGenericMethod ||\n                IsGenericType(container.ContainingType); 837647"];
8996 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 837648"];
8997 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 837649"];
8998 [label="param Translate(SyntaxNode syntaxNodeOpt) 837650"];
8999 [label="param Translate(DiagnosticBag diagnostics) 837651"];
9000 [label="param Translate(bool fromImplements = false) 837652"];
9001 [label="param Translate(bool needDeclaration = false) 837653"];
9002 [label="Debug.Assert(diagnostics != null); 837654"];
9003 [label="Debug.Assert(diagnostics != null); 837655"];
9004 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 837656"];
9005 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 837657"];
9006 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 837658"];
9007 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 837659"];
9008 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 837660"];
9009 [label="object reference; 837661"];
9010 [label="Cci.INamedTypeReference typeRef; 837662"];
9011 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 837663"];
9012 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 837664"];
9013 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 837665"];
9014 [label="IsGenericType(container) 837666"];
9015 [label="param IsGenericType(NamedTypeSymbol toCheck) 837667"];
9016 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837668"];
9017 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 837669"];
9018 [label="return false; 837670"];
9019 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 837671"];
9020 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 837672"];
9021 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 837673"];
9022 [label="if (toCheck.Arity > 0)\n                {\n                    return true;\n                } 837674"];
9023 [label="toCheck = toCheck.ContainingType; 837675"];
9024 [label="Debug.Assert(symbol.IsDefinition); 837676"];
9025 [label="GetBoundReferenceManager(); 837677"];
9026 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 837678"];
9027 [label="var result = new MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation>(); 837679"];
9028 [label="var namespacesAndTypesToProcess = new Stack<NamespaceOrTypeSymbol>(); 837680"];
9029 [label="Location location = null; 837681"];
9030 [label="while (namespacesAndTypesToProcess.Count > 0)\n            {\n                NamespaceOrTypeSymbol symbol = namespacesAndTypesToProcess.Pop();\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Namespace:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n\n                        // filtering out synthesized symbols not having real source \n                        // locations such as anonymous types, etc...\n                        if (location != null)\n                        {\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    case SymbolKind.NamedType:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n                        if (location != null)\n                        {\n                            //  add this named type location\n                            AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n                }\n            } 837682"];
9031 [label="param GetSmallestSourceLocationOrNull(this) 837683"];
9032 [label="CSharpCompilation compilation = symbol.DeclaringCompilation; 837684"];
9033 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 837685"];
9034 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 837686"];
9035 [label="param AddSymbolLocation(MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation> result) 837687"];
9036 [label="param AddSymbolLocation(Cci.IDefinition definition) 837688"];
9037 [label="if (doc != null)\n            {\n                result.Add(doc,\n                           new Cci.DefinitionWithLocation(\n                               definition,\n                               span.StartLinePosition.Line,\n                               span.StartLinePosition.Character,\n                               span.EndLinePosition.Line,\n                               span.EndLinePosition.Character));\n            } 837689"];
9038 [label="foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            } 837690"];
9039 [label="return result; 837691"];
9040 [label="GetBoundReferenceManager(); 837692"];
9041 [label="CustomAssert.True(emitResult.Success, 'Diagnostics:\\r\\n' + string.Join('\\r\\n', emitResult.Diagnostics.Select(d => d.ToString()))); 837693"];
9042 [label="CustomAssert.True(emitResult.Success, 'Diagnostics:\\r\\n' + string.Join('\\r\\n', emitResult.Diagnostics.Select(d => d.ToString()))); 837694"];
9043 [label="if (expectedWarnings != null)\n            {\n                emitResult.Diagnostics.Verify(expectedWarnings);\n            } 837695"];
9044 [label="if (expectedWarnings != null)\n            {\n                emitResult.Diagnostics.Verify(expectedWarnings);\n            } 837696"];
9045 [label="return peStream.ToImmutable(); 837697"];
9046 [label="comp.Options 837698"];
9047 [label="var comp = CreateCompilation(source, references: new[] { libImage },\n                options: TestOptions.DebugDll.WithAllowUnsafe(true)); 837699"];
9048 [label="var comp = CreateCompilation(source, references: new[] { libImage },\n                options: TestOptions.DebugDll.WithAllowUnsafe(true)); 837700"];
9049 [label="CreateCompilation(source, references: new[] { libImage },\n                options: TestOptions.DebugDll.WithAllowUnsafe(true)) 837701"];
9050 [label="param operator(string source) 837702"];
9051 [label="source 837703"];
9052 [label="new CSharpTestSource(source) 837704"];
9053 [label="param CSharpTestSource(object value) 837705"];
9054 [label="param CSharpTestSource(this) 837706"];
9055 [label="Value 837707"];
9056 [label="var comp = CreateCompilation(source, references: new[] { libImage },\n                options: TestOptions.DebugDll.WithAllowUnsafe(true)); 837708"];
9057 [label="param CreateCompilation(CSharpTestSource source) 837709"];
9058 [label="param CreateCompilation(IEnumerable<MetadataReference> references = null) 837710"];
9059 [label="param CreateCompilation(CSharpParseOptions parseOptions = null) 837711"];
9060 [label="param CreateCompilation(TargetFramework targetFramework = TargetFramework.Standard) 837712"];
9061 [label="param CreateCompilation(string assemblyName = '') 837713"];
9062 [label="param CreateCompilation(string sourceFileName = '') 837714"];
9063 [label="param CreateCompilation(bool skipUsesIsNullable = false) 837715"];
9064 [label="source 837716"];
9065 [label="targetFramework 837717"];
9066 [label="references 837718"];
9067 [label="TargetFrameworkUtil.GetReferences(targetFramework, references) 837719"];
9068 [label="param GetReferences(TargetFramework tf) 837720"];
9069 [label="param GetReferences(IEnumerable<MetadataReference> additionalReferences) 837721"];
9070 [label="var references = GetReferences(tf); 837722"];
9071 [label="GetReferences(tf) 837723"];
9072 [label="param GetReferences(TargetFramework targetFramework) 837724"];
9073 [label="targetFramework switch\n        {\n            TargetFramework.Empty => ImmutableArray<MetadataReference>.Empty,\n            TargetFramework.Mscorlib40 => Mscorlib40References,\n            TargetFramework.Mscorlib40Extended => Mscorlib40ExtendedReferences,\n            TargetFramework.Mscorlib40AndSystemCore => Mscorlib40andSystemCoreReferences,\n            TargetFramework.Mscorlib40AndVBRuntime => Mscorlib40andVBRuntimeReferences,\n            TargetFramework.Mscorlib45 => Mscorlib45References,\n            TargetFramework.Mscorlib45Extended => Mscorlib45ExtendedReferences,\n            TargetFramework.Mscorlib45AndCSharp => Mscorlib45AndCSharpReferences,\n            TargetFramework.Mscorlib45AndVBRuntime => Mscorlib45AndVBRuntimeReferences,\n            TargetFramework.Mscorlib46 => Mscorlib46References,\n            TargetFramework.Mscorlib46Extended => Mscorlib46ExtendedReferences,\n            TargetFramework.Mscorlib461 => Mscorlib46References,\n            TargetFramework.Mscorlib461Extended => Mscorlib461ExtendedReferences,\n            TargetFramework.NetStandard20 => NetStandard20References,\n            TargetFramework.NetCoreApp => NetCoreAppReferences,\n            TargetFramework.WinRT => WinRTReferences,\n            TargetFramework.Standard => StandardReferences,\n            TargetFramework.StandardLatest => StandardLatestReferences,\n            TargetFramework.StandardAndCSharp => StandardAndCSharpReferences,\n            TargetFramework.StandardAndVBRuntime => StandardAndVBRuntimeReferences,\n            TargetFramework.StandardCompat => StandardCompatReferences,\n            TargetFramework.DefaultVb => DefaultVbReferences,\n            TargetFramework.Minimal => MinimalReferences,\n            TargetFramework.MinimalAsync => MinimalAsyncReferences,\n            _ => throw new InvalidOperationException($'Unexpected target framework {targetFramework}'),\n        } 837725"];
9074 [label="StandardReferences 837726"];
9075 [label="RuntimeUtilities.IsCoreClrRuntime 837727"];
9076 [label="NetStandard20References 837728"];
9077 [label="ImmutableArray.Create<MetadataReference>(NetStandard20.netstandard, NetStandard20.mscorlib, NetStandard20.SystemRuntime, NetStandard20.SystemCore, NetStandard20.SystemDynamicRuntime, NetStandard20.SystemLinq, NetStandard20.SystemLinqExpressions) 837729"];
9078 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 837730"];
9079 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 837731"];
9080 [label="checkForDuplicateReferences(references, additionalReferences); 837732"];
9081 [label="checkForDuplicateReferences(references, additionalReferences) 837733"];
9082 [label="void checkForDuplicateReferences(ImmutableArray<MetadataReference> refer, IEnumerable<MetadataReference> additRef)\n            {\n                var nameSet = new HashSet<string>(getNames(refer), StringComparer.OrdinalIgnoreCase);\n                foreach (var r in additRef)\n                {\n                    if (refer.Contains(r))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display}');\n                    }\n\n                    var name = getName(r);\n                    if (name != null && !nameSet.Add(name))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display} - {name}');\n                    }\n                }\n            } 837734"];
9083 [label="getNames(refer) 837735"];
9084 [label="if (name != null)\n                    {\n                        yield return name;\n                    } 837736"];
9085 [label="yield return name; 837737"];
9086 [label="yield return name; 837738"];
9087 [label="var nameSet = new HashSet<string>(getNames(refer), StringComparer.OrdinalIgnoreCase); 837739"];
9088 [label="foreach (var r in additRef)\n                {\n                    if (refer.Contains(r))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display}');\n                    }\n\n                    var name = getName(r);\n                    if (name != null && !nameSet.Add(name))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display} - {name}');\n                    }\n                } 837740"];
9089 [label="if (name != null && !nameSet.Add(name))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display} - {name}');\n                    } 837741"];
9090 [label="if (name != null && !nameSet.Add(name))\n                    {\n                        throw new Exception($'Duplicate reference detected {r.Display} - {name}');\n                    } 837742"];
9091 [label="checkForDuplicateReferences(references, additionalReferences); 837743"];
9092 [label="return references.AddRange(additionalReferences); 837744"];
9093 [label="parseOptions 837745"];
9094 [label="assemblyName 837746"];
9095 [label="sourceFileName 837747"];
9096 [label="skipUsesIsNullable 837748"];
9097 [label="CreateEmptyCompilation(source, TargetFrameworkUtil.GetReferences(targetFramework, references), options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable) 837749"];
9098 [label="param CreateEmptyCompilation(CSharpTestSource source) 837750"];
9099 [label="param CreateEmptyCompilation(CSharpParseOptions parseOptions = null) 837751"];
9100 [label="param CreateEmptyCompilation(string assemblyName = '') 837752"];
9101 [label="param CreateEmptyCompilation(string sourceFileName = '') 837753"];
9102 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 837754"];
9103 [label="source 837755"];
9104 [label="parseOptions 837756"];
9105 [label="assemblyName 837757"];
9106 [label="sourceFileName 837758"];
9107 [label="skipUsesIsNullable 837759"];
9108 [label="null 837760"];
9109 [label="experimentalFeature: null 837761"];
9110 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 837762"];
9111 [label="param CreateCompilationCore(CSharpTestSource source) 837763"];
9112 [label="param CreateCompilationCore(CSharpParseOptions parseOptions) 837764"];
9113 [label="param CreateCompilationCore(string assemblyName) 837765"];
9114 [label="param CreateCompilationCore(string sourceFileName) 837766"];
9115 [label="param CreateCompilationCore(bool skipUsesIsNullable) 837767"];
9116 [label="param CreateCompilationCore(MessageID? experimentalFeature) 837768"];
9117 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 837769"];
9118 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 837770"];
9119 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 837771"];
9120 [label="param GetSyntaxTrees(CSharpParseOptions parseOptions) 837772"];
9121 [label="param GetSyntaxTrees(string sourceFileName = '') 837773"];
9122 [label="param GetSyntaxTrees(this) 837774"];
9123 [label="switch (Value)\n            {\n                case string source:\n                    return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) };\n                case string[] sources:\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return CSharpTestBase.Parse(parseOptions, sources);\n                case SyntaxTree tree:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return new[] { tree };\n                case SyntaxTree[] trees:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return trees;\n                case CSharpTestSource[] testSources:\n                    return testSources.SelectMany(s => s.GetSyntaxTrees(parseOptions, sourceFileName)).ToArray();\n                case null:\n                    return Array.Empty<SyntaxTree>();\n                default:\n                    throw new Exception($'Unexpected value: {Value}');\n            } 837775"];
9124 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 837776"];
9125 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 837777"];
9126 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 837778"];
9127 [label="CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) 837779"];
9128 [label="param Parse(string text) 837780"];
9129 [label="param Parse(string filename = '') 837781"];
9130 [label="param Parse(CSharpParseOptions options = null) 837782"];
9131 [label="param Parse(Encoding encoding = null) 837783"];
9132 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 837784"];
9133 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 837785"];
9134 [label="options = TestOptions.Regular; 837786"];
9135 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 837787"];
9136 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 837788"];
9137 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 837789"];
9138 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 837790"];
9139 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 837791"];
9140 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 837792"];
9141 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 837793"];
9142 [label="CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)) 837794"];
9143 [label="var stream = new MemoryStream(); 837795"];
9144 [label="var root = tree.GetRoot(); 837796"];
9145 [label="var root = tree.GetRoot(); 837797"];
9146 [label="root.SerializeTo(stream); 837798"];
9147 [label="root.SerializeTo(stream); 837799"];
9148 [label="root.SerializeTo(stream); 837800"];
9149 [label="stream.Position = 0; 837801"];
9150 [label="stream.Position 837802"];
9151 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 837803"];
9152 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 837804"];
9153 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 837805"];
9154 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 837806"];
9155 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 837807"];
9156 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 837808"];
9157 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 837809"];
9158 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 837810"];
9159 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 837811"];
9160 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 837812"];
9161 [label="param ValidateIOperations(Func<Compilation> createCompilation) 837813"];
9162 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 837814"];
9163 [label="return; 837815"];
9164 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 837816"];
9165 [label="var compilation = createCompilationLambda(); 837817"];
9166 [label="return Guid.NewGuid().ToString('D'); 837818"];
9167 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 837819"];
9168 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 837820"];
9169 [label="param Create(CSharpCompilation? previousSubmission) 837821"];
9170 [label="param Create(Type? returnType) 837822"];
9171 [label="param Create(Type? hostObjectType) 837823"];
9172 [label="param Create(bool isSubmission) 837824"];
9173 [label="RoslynDebug.Assert(options != null); 837825"];
9174 [label="RoslynDebug.Assert(options != null); 837826"];
9175 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 837827"];
9176 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 837828"];
9177 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 837829"];
9178 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 837830"];
9179 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 837831"];
9180 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 837832"];
9181 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 837833"];
9182 [label="new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null) 837834"];
9183 [label="param SyntaxAndDeclarationManager(ImmutableArray<SyntaxTree> externalSyntaxTrees) 837835"];
9184 [label="param SyntaxAndDeclarationManager(CommonMessageProvider messageProvider) 837836"];
9185 [label="param SyntaxAndDeclarationManager(bool isSubmission) 837837"];
9186 [label="param SyntaxAndDeclarationManager(State state) 837838"];
9187 [label="param SyntaxAndDeclarationManager(this) 837839"];
9188 [label="externalSyntaxTrees 837840"];
9189 [label="messageProvider 837841"];
9190 [label="isSubmission 837842"];
9191 [label="param SyntaxAndDeclarationManager(this) 837843"];
9192 [label="_lazyState 837844"];
9193 [label="_lazyState 837845"];
9194 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 837846"];
9195 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 837847"];
9196 [label="param CSharpCompilation(Type? submissionReturnType) 837848"];
9197 [label="param CSharpCompilation(Type? hostObjectType) 837849"];
9198 [label="param CSharpCompilation(bool isSubmission) 837850"];
9199 [label="param CSharpCompilation(ReferenceManager? referenceManager) 837851"];
9200 [label="param CSharpCompilation(bool reuseReferenceManager) 837852"];
9201 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 837853"];
9202 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 837854"];
9203 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 837855"];
9204 [label="param CSharpCompilation(this) 837856"];
9205 [label="previousSubmission 837857"];
9206 [label="submissionReturnType 837858"];
9207 [label="hostObjectType 837859"];
9208 [label="isSubmission 837860"];
9209 [label="referenceManager 837861"];
9210 [label="reuseReferenceManager 837862"];
9211 [label="syntaxAndDeclarations 837863"];
9212 [label="semanticModelProvider 837864"];
9213 [label="eventQueue 837865"];
9214 [label="param CSharpCompilation(this) 837866"];
9215 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 837867"];
9216 [label="param CSharpCompilation(Type? submissionReturnType) 837868"];
9217 [label="param CSharpCompilation(Type? hostObjectType) 837869"];
9218 [label="param CSharpCompilation(bool isSubmission) 837870"];
9219 [label="param CSharpCompilation(ReferenceManager? referenceManager) 837871"];
9220 [label="param CSharpCompilation(bool reuseReferenceManager) 837872"];
9221 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 837873"];
9222 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 837874"];
9223 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 837875"];
9224 [label="param CSharpCompilation(this) 837876"];
9225 [label="isSubmission 837877"];
9226 [label="semanticModelProvider 837878"];
9227 [label="eventQueue 837879"];
9228 [label="param CSharpCompilation(this) 837880"];
9229 [label="_options 837881"];
9230 [label="_globalImports 837882"];
9231 [label="_previousSubmissionImports 837883"];
9232 [label="_globalNamespaceAlias 837884"];
9233 [label="_scriptClass 837885"];
9234 [label="_lazyHostObjectTypeSymbol 837886"];
9235 [label="_lazyImportInfos 837887"];
9236 [label="_conversions 837888"];
9237 [label="_anonymousTypeManager 837889"];
9238 [label="_lazyGlobalNamespace 837890"];
9239 [label="builtInOperators 837891"];
9240 [label="_lazyAssemblySymbol 837892"];
9241 [label="_referenceManager 837893"];
9242 [label="_syntaxAndDeclarations 837894"];
9243 [label="_lazyEntryPoint 837895"];
9244 [label="_lazyEmitNullablePublicOnly 837896"];
9245 [label="_lazyCompilationUnitCompletedTrees 837897"];
9246 [label="NullableAnalysisData 837898"];
9247 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 837899"];
9248 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 837900"];
9249 [label="_externAliasTargets 837901"];
9250 [label="_moduleInitializerMethods 837902"];
9251 [label="_binderFactories 837903"];
9252 [label="_ignoreAccessibilityBinderFactories 837904"];
9253 [label="_lazyDeclarationDiagnostics 837905"];
9254 [label="_declarationDiagnosticsFrozen 837906"];
9255 [label="new DiagnosticBag() 837907"];
9256 [label="_additionalCodegenWarnings = new DiagnosticBag() 837908"];
9257 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 837909"];
9258 [label="this.builtInOperators = new BuiltInOperators(this); 837910"];
9259 [label="this.builtInOperators = new BuiltInOperators(this); 837911"];
9260 [label="new BuiltInOperators(this) 837912"];
9261 [label="param BuiltInOperators(CSharpCompilation compilation) 837913"];
9262 [label="param BuiltInOperators(this) 837914"];
9263 [label="_compilation 837915"];
9264 [label="_builtInUnaryOperators 837916"];
9265 [label="_builtInOperators 837917"];
9266 [label="_compilation 837918"];
9267 [label="this.builtInOperators 837919"];
9268 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 837920"];
9269 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 837921"];
9270 [label="LanguageVersion? result = null; 837922"];
9271 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 837923"];
9272 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 837924"];
9273 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 837925"];
9274 [label="this.LanguageVersion 837926"];
9275 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 837927"];
9276 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 837928"];
9277 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 837929"];
9278 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 837930"];
9279 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 837931"];
9280 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 837932"];
9281 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 837933"];
9282 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 837934"];
9283 [label="this.Options 837935"];
9284 [label="get\n            {\n                return _options;\n            } 837936"];
9285 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 837937"];
9286 [label="_syntaxAndDeclarations 837938"];
9287 [label="Debug.Assert(_lazyAssemblySymbol is null); 837939"];
9288 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 837940"];
9289 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 837941"];
9290 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 837942"];
9291 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 837943"];
9292 [label="int i = 0; 837944"];
9293 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 837945"];
9294 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 837946"];
9295 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 837947"];
9296 [label="i++; 837948"];
9297 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 837949"];
9298 [label="var scriptClassName = this.ScriptClassName; 837950"];
9299 [label="var resolver = this.Resolver; 837951"];
9300 [label="var messageProvider = this.MessageProvider; 837952"];
9301 [label="var isSubmission = this.IsSubmission; 837953"];
9302 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 837954"];
9303 [label="param CSharpCompilation(Type? submissionReturnType) 837955"];
9304 [label="param CSharpCompilation(Type? hostObjectType) 837956"];
9305 [label="previousSubmission 837957"];
9306 [label="submissionReturnType 837958"];
9307 [label="hostObjectType 837959"];
9308 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 837960"];
9309 [label="param CSharpCompilation(Type? submissionReturnType) 837961"];
9310 [label="param CSharpCompilation(Type? hostObjectType) 837962"];
9311 [label="_compilation 837963"];
9312 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 837964"];
9313 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 837965"];
9314 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 837966"];
9315 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 837967"];
9316 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 837968"];
9317 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 837969"];
9318 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 837970"];
9319 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 837971"];
9320 [label="Debug.Assert(_lazyAssemblySymbol is null); 837972"];
9321 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 837973"];
9322 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 837974"];
9323 [label="IsNullableEnabled(compilation) 837975"];
9324 [label="compilation.SyntaxTrees 837976"];
9325 [label="_syntaxAndDeclarations.GetLazyState() 837977"];
9326 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 837978"];
9327 [label="param AppendAllSyntaxTrees(SourceReferenceResolver resolver) 837979"];
9328 [label="param AppendAllSyntaxTrees(CommonMessageProvider messageProvider) 837980"];
9329 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, ImmutableArray<LoadDirective>> loadDirectiveMapBuilder) 837981"];
9330 [label="param AppendAllSyntaxTrees(IDictionary<string, SyntaxTree> loadedSyntaxTreeMapBuilder) 837982"];
9331 [label="var sourceCodeKind = tree.Options.Kind; 837983"];
9332 [label="if (sourceCodeKind == SourceCodeKind.Script)\n            {\n                AppendAllLoadedSyntaxTrees(treesBuilder, tree, scriptClassName, resolver, messageProvider, isSubmission, ordinalMapBuilder, loadDirectiveMapBuilder, loadedSyntaxTreeMapBuilder, declMapBuilder, ref declTable);\n            } 837984"];
9333 [label="OrdinalMap 837985"];
9334 [label="LoadDirectiveMap 837986"];
9335 [label="LoadedSyntaxTreeMap 837987"];
9336 [label="RootNamespaces 837988"];
9337 [label="DeclarationTable 837989"];
9338 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 837990"];
9339 [label="var options = (CSharpParseOptions)trees[0].Options; 837991"];
9340 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 837992"];
9341 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 837993"];
9342 [label="validator(comp); 837994"];
9343 [label="var diagnostics = c.GetDiagnostics(); 837995"];
9344 [label="c.GetDiagnostics() 837996"];
9345 [label="param GetDiagnostics(CancellationToken cancellationToken = default) 837997"];
9346 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 837998"];
9347 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 837999"];
9348 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 838000"];
9349 [label="GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken) 838001"];
9350 [label="param GetDiagnostics(CompilationStage stage) 838002"];
9351 [label="param GetDiagnostics(bool includeEarlierStages) 838003"];
9352 [label="param GetDiagnostics(CancellationToken cancellationToken) 838004"];
9353 [label="var diagnostics = DiagnosticBag.GetInstance(); 838005"];
9354 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 838006"];
9355 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 838007"];
9356 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 838008"];
9357 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 838009"];
9358 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 838010"];
9359 [label="param GetDiagnostics(CompilationStage stage) 838011"];
9360 [label="param GetDiagnostics(bool includeEarlierStages) 838012"];
9361 [label="param GetDiagnostics(DiagnosticBag diagnostics) 838013"];
9362 [label="param GetDiagnostics(CancellationToken cancellationToken = default) 838014"];
9363 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 838015"];
9364 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 838016"];
9365 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 838017"];
9366 [label="this.SyntaxTrees 838018"];
9367 [label="_syntaxAndDeclarations.GetLazyState() 838019"];
9368 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 838020"];
9369 [label="this.Options 838021"];
9370 [label="param AppendLoadDirectiveDiagnostics(DiagnosticBag builder) 838022"];
9371 [label="param AppendLoadDirectiveDiagnostics(Func<IEnumerable<Diagnostic>, IEnumerable<Diagnostic>>? locationFilterOpt = null) 838023"];
9372 [label="var parseOptionsReported = new HashSet<ParseOptions>(); 838024"];
9373 [label="if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    } 838025"];
9374 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 838026"];
9375 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 838027"];
9376 [label="CheckAssemblyName(builder); 838028"];
9377 [label="CheckAssemblyName(builder); 838029"];
9378 [label="Options 838030"];
9379 [label="Options 838031"];
9380 [label="get\n            {\n                return _options;\n            } 838032"];
9381 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 838033"];
9382 [label="GetBoundReferenceManager() 838034"];
9383 [label="Debug.Assert(_lazyAssemblySymbol is object); 838035"];
9384 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 838036"];
9385 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 838037"];
9386 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 838038"];
9387 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 838039"];
9388 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 838040"];
9389 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 838041"];
9390 [label="param GetSourceDeclarationDiagnostics(CancellationToken cancellationToken = default) 838042"];
9391 [label="GlobalImports 838043"];
9392 [label="_globalImports.Value 838044"];
9393 [label="Imports.FromGlobalUsings(this) 838045"];
9394 [label="GlobalImports.Complete(cancellationToken); 838046"];
9395 [label="SourceLocation? location = null; 838047"];
9396 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 838048"];
9397 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 838049"];
9398 [label="Assembly 838050"];
9399 [label="SourceAssembly 838051"];
9400 [label="GetBoundReferenceManager() 838052"];
9401 [label="GetBoundReferenceManager(); 838053"];
9402 [label="Assembly.ForceComplete(location, cancellationToken); 838054"];
9403 [label="Assembly.ForceComplete(location, cancellationToken); 838055"];
9404 [label="Assembly.ForceComplete(location, cancellationToken); 838056"];
9405 [label="Declarations 838057"];
9406 [label="_syntaxAndDeclarations.GetLazyState() 838058"];
9407 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 838059"];
9408 [label="return Declarations.GetMergedRoot(this); 838060"];
9409 [label="_syntaxAndDeclarations.GetLazyState() 838061"];
9410 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 838062"];
9411 [label="SourceAssembly 838063"];
9412 [label="GetBoundReferenceManager() 838064"];
9413 [label="GetBoundReferenceManager(); 838065"];
9414 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 838066"];
9415 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 838067"];
9416 [label="param SymbolDeclaredEvent(Symbol symbol) 838068"];
9417 [label="param SymbolDeclaredEvent(this) 838069"];
9418 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 838070"];
9419 [label="GetBoundReferenceManager() 838071"];
9420 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 838072"];
9421 [label="param Compare(this) 838073"];
9422 [label="int comparison; 838074"];
9423 [label="if (x == y)\n            {\n                return 0;\n            } 838075"];
9424 [label="var xSortKey = x.GetLexicalSortKey(); 838076"];
9425 [label="this.ContainsSyntaxTree(tree) 838077"];
9426 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 838078"];
9427 [label="_syntaxAndDeclarations.GetLazyState() 838079"];
9428 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 838080"];
9429 [label="_syntaxAndDeclarations.GetLazyState() 838081"];
9430 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 838082"];
9431 [label="var ySortKey = y.GetLexicalSortKey(); 838083"];
9432 [label="this.ContainsSyntaxTree(tree) 838084"];
9433 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 838085"];
9434 [label="_syntaxAndDeclarations.GetLazyState() 838086"];
9435 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 838087"];
9436 [label="_syntaxAndDeclarations.GetLazyState() 838088"];
9437 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 838089"];
9438 [label="Debug.Assert((object)x.DeclaringCompilation == y.DeclaringCompilation); 838090"];
9439 [label="if (comparison != 0)\n            {\n                return comparison;\n            } 838091"];
9440 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 838092"];
9441 [label="NamedTypeSymbol result; 838093"];
9442 [label="Debug.Assert(result.SpecialType == specialType); 838094"];
9443 [label="Debug.Assert(symbol.IsDefinition); 838095"];
9444 [label="SourceModule 838096"];
9445 [label="Assembly 838097"];
9446 [label="SourceAssembly 838098"];
9447 [label="GetBoundReferenceManager() 838099"];
9448 [label="GetBoundReferenceManager(); 838100"];
9449 [label="return Assembly.Modules[0]; 838101"];
9450 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 838102"];
9451 [label="EmitNullablePublicOnly 838103"];
9452 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 838104"];
9453 [label="_declarationDiagnosticsFrozen = true; 838105"];
9454 [label="_needsGeneratedAttributes_IsFrozen = true; 838106"];
9455 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 838107"];
9456 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 838108"];
9457 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 838109"];
9458 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 838110"];
9459 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 838111"];
9460 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 838112"];
9461 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 838113"];
9462 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 838114"];
9463 [label="param GetClsComplianceDiagnostics(CancellationToken cancellationToken) 838115"];
9464 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 838116"];
9465 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 838117"];
9466 [label="param CheckCompliance(DiagnosticBag diagnostics) 838118"];
9467 [label="System.Diagnostics.Debug.Assert(symbol is SourceAssemblySymbol); 838119"];
9468 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 838120"];
9469 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 838121"];
9470 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 838122"];
9471 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 838123"];
9472 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 838124"];
9473 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 838125"];
9474 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 838126"];
9475 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 838127"];
9476 [label="param GetDeclaredCompliance(out Location attributeLocation) 838128"];
9477 [label="param GetDeclaredCompliance(this) 838129"];
9478 [label="attributeLocation = null; 838130"];
9479 [label="if (assemblyCompliance == Compliance.DeclaredFalse)\n            {\n                // Our interpretation of an assembly-level CLSCompliant attribute is as follows:\n                //   1) If true, then perform all CLS checks.\n                //   2) If false, then perform no CLS checks (dev11 still performs a few, mostly around\n                //      meaningless attributes).  Our interpretation is that the user ultimately wants\n                //      his code to be CLS-compliant, but is temporarily disabling the checks (e.g. during\n                //      refactoring/prototyping).\n                //   3) If absent, the perform all CLS checks.  Our interpretation is that - in the\n                //      absence of an assembly-level attribute - any CLS problems within the compilation\n                //      indicate that the user was trying to do something but didn't know how.  It would\n                //      be nice if the most common case (i.e. this one) was the cheapest, but we don't\n                //      want to confuse novice users.\n                return;\n            } 838131"];
9480 [label="bool assemblyComplianceValue = IsTrue(assemblyCompliance); 838132"];
9481 [label="IsTrue(assemblyCompliance) 838133"];
9482 [label="param IsTrue(Compliance compliance) 838134"];
9483 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 838135"];
9484 [label="return false; 838136"];
9485 [label="Location attributeLocation; 838137"];
9486 [label="param GetDeclaredCompliance(out Location attributeLocation) 838138"];
9487 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 838139"];
9488 [label="i == 0 838140"];
9489 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 838141"];
9490 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 838142"];
9491 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 838143"];
9492 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 838144"];
9493 [label="if (moduleDeclaredCompliance.HasValue)\n                {\n                    if (warningLocation != null)\n                    {\n                        if (!IsDeclared(assemblyCompliance))\n                        {\n                            // This is not useful on non-source modules, but dev11 reports it anyway.\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules, warningLocation);\n                        }\n                        else if (assemblyComplianceValue != moduleDeclaredCompliance.GetValueOrDefault())\n                        {\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules2, warningLocation);\n                        }\n                    }\n                }\n                else if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 838145"];
9494 [label="if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 838146"];
9495 [label="if (assemblyComplianceValue)\n            {\n                CheckForAttributeWithArrayArgument(symbol);\n            } 838147"];
9496 [label="System.Diagnostics.Debug.Assert(symbol.Kind != SymbolKind.Assembly); 838148"];
9497 [label="System.Diagnostics.Debug.Assert((object)containing != null); 838149"];
9498 [label="return compliance; 838150"];
9499 [label="IsTrue(GetInheritedCompliance(symbol)) 838151"];
9500 [label="param IsTrue(Compliance compliance) 838152"];
9501 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 838153"];
9502 [label="return false; 838154"];
9503 [label="IsTrue(GetDeclaredOrInheritedCompliance(sourceModule)) 838155"];
9504 [label="param IsTrue(Compliance compliance) 838156"];
9505 [label="if (DoNotVisit(symbol)) return; 838157"];
9506 [label="DoNotVisit(symbol) 838158"];
9507 [label="param DoNotVisit(Symbol symbol) 838159"];
9508 [label="param DoNotVisit(this) 838160"];
9509 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                return false;\n            } 838161"];
9510 [label="return false; 838162"];
9511 [label="IsTrue(GetDeclaredOrInheritedCompliance(symbol)) 838163"];
9512 [label="param IsTrue(Compliance compliance) 838164"];
9513 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 838165"];
9514 [label="return false; 838166"];
9515 [label="if (tasks == null)\n            {\n                return;\n            } 838167"];
9516 [label="checker.WaitForWorkers(); 838168"];
9517 [label="foreach (Diagnostic diag in queue)\n            {\n                diagnostics.Add(diag);\n            } 838169"];
9518 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 838170"];
9519 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 838171"];
9520 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 838172"];
9521 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 838173"];
9522 [label="var methodBodyDiagnostics = DiagnosticBag.GetInstance(); 838174"];
9523 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 838175"];
9524 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 838176"];
9525 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken) 838177"];
9526 [label="param GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics) 838178"];
9527 [label="param GetDiagnosticsForAllMethodBodies(CancellationToken cancellationToken) 838179"];
9528 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 838180"];
9529 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 838181"];
9530 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 838182"];
9531 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken) 838183"];
9532 [label="param CompileMethodBodies(PEModuleBuilder moduleBeingBuiltOpt) 838184"];
9533 [label="param CompileMethodBodies(bool emittingPdb) 838185"];
9534 [label="param CompileMethodBodies(bool emitTestCoverageData) 838186"];
9535 [label="param CompileMethodBodies(bool hasDeclarationErrors) 838187"];
9536 [label="param CompileMethodBodies(DiagnosticBag diagnostics) 838188"];
9537 [label="param CompileMethodBodies(Predicate<Symbol> filterOpt) 838189"];
9538 [label="param CompileMethodBodies(CancellationToken cancellationToken) 838190"];
9539 [label="Debug.Assert(compilation != null); 838191"];
9540 [label="Debug.Assert(compilation != null); 838192"];
9541 [label="Debug.Assert(diagnostics != null); 838193"];
9542 [label="Debug.Assert(diagnostics != null); 838194"];
9543 [label="compilation.PreviousSubmission 838195"];
9544 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 838196"];
9545 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 838197"];
9546 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 838198"];
9547 [label="MethodSymbol entryPoint = null; 838199"];
9548 [label="if (filterOpt is null)\n            {\n                entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken);\n            } 838200"];
9549 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 838201"];
9550 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 838202"];
9551 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 838203"];
9552 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 838204"];
9553 [label="GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken) 838205"];
9554 [label="param GetEntryPoint(PEModuleBuilder moduleBeingBuilt) 838206"];
9555 [label="param GetEntryPoint(bool hasDeclarationErrors) 838207"];
9556 [label="param GetEntryPoint(DiagnosticBag diagnostics) 838208"];
9557 [label="param GetEntryPoint(CancellationToken cancellationToken) 838209"];
9558 [label="var entryPointAndDiagnostics = compilation.GetEntryPointAndDiagnostics(cancellationToken); 838210"];
9559 [label="compilation.GetEntryPointAndDiagnostics(cancellationToken) 838211"];
9560 [label="param GetEntryPointAndDiagnostics(CancellationToken cancellationToken) 838212"];
9561 [label="if (_lazyEntryPoint == null)\n            {\n                EntryPoint? entryPoint;\n                var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this);\n\n                if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                }\n\n                Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null);\n            } 838213"];
9562 [label="EntryPoint? entryPoint; 838214"];
9563 [label="Debug.Assert(!entryPointAndDiagnostics.Diagnostics.IsDefault); 838215"];
9564 [label="if ((object)entryPoint == null)\n            {\n                return null;\n            } 838216"];
9565 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 838217"];
9566 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 838218"];
9567 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 838219"];
9568 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 838220"];
9569 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 838221"];
9570 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 838222"];
9571 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 838223"];
9572 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 838224"];
9573 [label="new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken) 838225"];
9574 [label="param MethodCompiler(PEModuleBuilder moduleBeingBuiltOpt) 838226"];
9575 [label="param MethodCompiler(bool emittingPdb) 838227"];
9576 [label="param MethodCompiler(bool emitTestCoverageData) 838228"];
9577 [label="param MethodCompiler(bool hasDeclarationErrors) 838229"];
9578 [label="param MethodCompiler(DiagnosticBag diagnostics) 838230"];
9579 [label="param MethodCompiler(Predicate<Symbol> filterOpt) 838231"];
9580 [label="param MethodCompiler(CancellationToken cancellationToken) 838232"];
9581 [label="param MethodCompiler(this) 838233"];
9582 [label="param MethodCompiler(this) 838234"];
9583 [label="_compilation 838235"];
9584 [label="_emittingPdb 838236"];
9585 [label="_emitTestCoverageData 838237"];
9586 [label="_diagnostics 838238"];
9587 [label="_hasDeclarationErrors 838239"];
9588 [label="_moduleBeingBuiltOpt 838240"];
9589 [label="_filterOpt 838241"];
9590 [label="_debugDocumentProvider 838242"];
9591 [label="_entryPointOpt 838243"];
9592 [label="_compilerTasks 838244"];
9593 [label="_globalHasErrors 838245"];
9594 [label="Debug.Assert(compilation != null); 838246"];
9595 [label="Debug.Assert(compilation != null); 838247"];
9596 [label="Debug.Assert(diagnostics != null); 838248"];
9597 [label="Debug.Assert(diagnostics != null); 838249"];
9598 [label="_moduleBeingBuiltOpt 838250"];
9599 [label="_emittingPdb 838251"];
9600 [label="_cancellationToken 838252"];
9601 [label="_diagnostics 838253"];
9602 [label="_filterOpt 838254"];
9603 [label="_hasDeclarationErrors 838255"];
9604 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 838256"];
9605 [label="SetGlobalErrorIfTrue(hasDeclarationErrors) 838257"];
9606 [label="param SetGlobalErrorIfTrue(bool arg) 838258"];
9607 [label="param SetGlobalErrorIfTrue(this) 838259"];
9608 [label="if (arg)\n            {\n                _globalHasErrors = true;\n            } 838260"];
9609 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 838261"];
9610 [label="if (emittingPdb || emitTestCoverageData)\n            {\n                _debugDocumentProvider = (path, basePath) => moduleBeingBuiltOpt.DebugDocumentsBuilder.GetOrAddDebugDocument(path, basePath, CreateDebugDocumentForFile);\n            } 838262"];
9611 [label="_emitTestCoverageData 838263"];
9612 [label="compilation.Options 838264"];
9613 [label="compilation.SourceModule 838265"];
9614 [label="Assembly 838266"];
9615 [label="SourceAssembly 838267"];
9616 [label="GetBoundReferenceManager() 838268"];
9617 [label="GetBoundReferenceManager(); 838269"];
9618 [label="return Assembly.Modules[0]; 838270"];
9619 [label="methodCompiler.CompileNamespace(compilation.SourceModule.GlobalNamespace) 838271"];
9620 [label="param CompileNamespace(this) 838272"];
9621 [label="param VisitNamedType(TypeCompilationState arg) 838273"];
9622 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 838274"];
9623 [label="PassesFilter(_filterOpt, symbol) 838275"];
9624 [label="param PassesFilter(Predicate<Symbol> filterOpt) 838276"];
9625 [label="param PassesFilter(Symbol symbol) 838277"];
9626 [label="return (filterOpt == null) || filterOpt(symbol); 838278"];
9627 [label="return (filterOpt == null) || filterOpt(symbol); 838279"];
9628 [label="arg = null; 838280"];
9629 [label="param CompileNamedTypeAsync(NamedTypeSymbol symbol) 838281"];
9630 [label="methodCompiler.CompileNamespace(compilation.SourceModule.GlobalNamespace); 838282"];
9631 [label="methodCompiler.WaitForWorkers() 838283"];
9632 [label="param WaitForWorkers(this) 838284"];
9633 [label="if (tasks == null)\n            {\n                return;\n            } 838285"];
9634 [label="if (tasks == null)\n            {\n                return;\n            } 838286"];
9635 [label="Task curTask; 838287"];
9636 [label="while (tasks.TryPop(out curTask))\n            {\n                curTask.GetAwaiter().GetResult();\n            } 838288"];
9637 [label="methodCompiler.WaitForWorkers(); 838289"];
9638 [label="if (moduleBeingBuiltOpt != null)\n            {\n                var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics);\n\n                var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics);\n\n                // By this time we have processed all types reachable from module's global namespace\n                compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics);\n                methodCompiler.WaitForWorkers();\n\n                var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass;\n                if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                }\n            } 838290"];
9639 [label="if (moduleBeingBuiltOpt != null)\n            {\n                var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics);\n\n                var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics);\n\n                // By this time we have processed all types reachable from module's global namespace\n                compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics);\n                methodCompiler.WaitForWorkers();\n\n                var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass;\n                if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                }\n            } 838291"];
9640 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 838292"];
9641 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 838293"];
9642 [label="compilation.AdditionalCodegenWarnings 838294"];
9643 [label="if (filterOpt == null)\n            {\n                WarnUnusedFields(compilation, diagnostics, cancellationToken);\n\n                if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                }\n            } 838295"];
9644 [label="if (filterOpt == null)\n            {\n                WarnUnusedFields(compilation, diagnostics, cancellationToken);\n\n                if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                }\n            } 838296"];
9645 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 838297"];
9646 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 838298"];
9647 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken) 838299"];
9648 [label="param WarnUnusedFields(DiagnosticBag diagnostics) 838300"];
9649 [label="param WarnUnusedFields(CancellationToken cancellationToken) 838301"];
9650 [label="compilation.Assembly 838302"];
9651 [label="SourceAssembly 838303"];
9652 [label="GetBoundReferenceManager() 838304"];
9653 [label="GetBoundReferenceManager(); 838305"];
9654 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 838306"];
9655 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 838307"];
9656 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 838308"];
9657 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 838309"];
9658 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 838310"];
9659 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 838311"];
9660 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 838312"];
9661 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 838313"];
9662 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken) 838314"];
9663 [label="param WriteDocumentationCommentXml(string? assemblyName) 838315"];
9664 [label="param WriteDocumentationCommentXml(Stream? xmlDocStream) 838316"];
9665 [label="param WriteDocumentationCommentXml(DiagnosticBag diagnostics) 838317"];
9666 [label="param WriteDocumentationCommentXml(CancellationToken cancellationToken) 838318"];
9667 [label="param WriteDocumentationCommentXml(SyntaxTree? filterTree = null) 838319"];
9668 [label="param WriteDocumentationCommentXml(TextSpan? filterSpanWithinTree = null) 838320"];
9669 [label="StreamWriter writer = null; 838321"];
9670 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 838322"];
9671 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 838323"];
9672 [label="compilation.SourceAssembly 838324"];
9673 [label="GetBoundReferenceManager() 838325"];
9674 [label="GetBoundReferenceManager(); 838326"];
9675 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 838327"];
9676 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 838328"];
9677 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 838329"];
9678 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 838330"];
9679 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 838331"];
9680 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 838332"];
9681 [label="new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken) 838333"];
9682 [label="param DocumentationCommentCompiler(TextWriter writer) 838334"];
9683 [label="param DocumentationCommentCompiler(SyntaxTree filterTree) 838335"];
9684 [label="param DocumentationCommentCompiler(TextSpan? filterSpanWithinTree) 838336"];
9685 [label="param DocumentationCommentCompiler(bool processIncludes) 838337"];
9686 [label="param DocumentationCommentCompiler(bool isForSingleSymbol) 838338"];
9687 [label="param DocumentationCommentCompiler(DiagnosticBag diagnostics) 838339"];
9688 [label="param DocumentationCommentCompiler(CancellationToken cancellationToken) 838340"];
9689 [label="param DocumentationCommentCompiler(this) 838341"];
9690 [label="param DocumentationCommentCompiler(this) 838342"];
9691 [label="_assemblyName 838343"];
9692 [label="_compilation 838344"];
9693 [label="_writer 838345"];
9694 [label="_filterTree 838346"];
9695 [label="_filterSpanWithinTree 838347"];
9696 [label="_processIncludes 838348"];
9697 [label="_isForSingleSymbol 838349"];
9698 [label="_diagnostics 838350"];
9699 [label="_lazyComparer 838351"];
9700 [label="_includedFileCache 838352"];
9701 [label="_indentDepth 838353"];
9702 [label="_temporaryStringBuilders 838354"];
9703 [label="_writer 838355"];
9704 [label="_filterTree 838356"];
9705 [label="_filterSpanWithinTree 838357"];
9706 [label="_processIncludes 838358"];
9707 [label="_isForSingleSymbol 838359"];
9708 [label="_diagnostics 838360"];
9709 [label="_cancellationToken 838361"];
9710 [label="compilation.SourceAssembly 838362"];
9711 [label="GetBoundReferenceManager() 838363"];
9712 [label="GetBoundReferenceManager(); 838364"];
9713 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 838365"];
9714 [label="Debug.Assert(_assemblyName != null); 838366"];
9715 [label="WriteLine('<?xml version=\\'1.0\\'?>'); 838367"];
9716 [label="WriteLine('<?xml version=\\'1.0\\'?>') 838368"];
9717 [label="param WriteLine(string message) 838369"];
9718 [label="param WriteLine(this) 838370"];
9719 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838371"];
9720 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838372"];
9721 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838373"];
9722 [label="WriteLine('<doc>'); 838374"];
9723 [label="WriteLine('<doc>') 838375"];
9724 [label="param WriteLine(string message) 838376"];
9725 [label="param WriteLine(this) 838377"];
9726 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838378"];
9727 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838379"];
9728 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838380"];
9729 [label="Indent(); 838381"];
9730 [label="WriteLine('<assembly>'); 838382"];
9731 [label="WriteLine('<assembly>') 838383"];
9732 [label="param WriteLine(string message) 838384"];
9733 [label="param WriteLine(this) 838385"];
9734 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838386"];
9735 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838387"];
9736 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838388"];
9737 [label="Indent(); 838389"];
9738 [label="WriteLine('<name>{0}</name>', _assemblyName); 838390"];
9739 [label="WriteLine('<name>{0}</name>', _assemblyName) 838391"];
9740 [label="WriteLine('<name>{0}</name>', _assemblyName) 838392"];
9741 [label="param WriteLine(string format) 838393"];
9742 [label="param WriteLine(params object[] args) 838394"];
9743 [label="param WriteLine(this) 838395"];
9744 [label="WriteLine(string.Format(format, args)); 838396"];
9745 [label="WriteLine(string.Format(format, args)); 838397"];
9746 [label="WriteLine(string.Format(format, args)); 838398"];
9747 [label="WriteLine(string.Format(format, args)) 838399"];
9748 [label="param WriteLine(string message) 838400"];
9749 [label="param WriteLine(this) 838401"];
9750 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838402"];
9751 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838403"];
9752 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838404"];
9753 [label="WriteLine(string.Format(format, args)); 838405"];
9754 [label="Debug.Assert(_indentDepth >= 0); 838406"];
9755 [label="Unindent(); 838407"];
9756 [label="WriteLine('</assembly>'); 838408"];
9757 [label="WriteLine('</assembly>') 838409"];
9758 [label="param WriteLine(string message) 838410"];
9759 [label="param WriteLine(this) 838411"];
9760 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838412"];
9761 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838413"];
9762 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838414"];
9763 [label="WriteLine('<members>'); 838415"];
9764 [label="WriteLine('<members>') 838416"];
9765 [label="param WriteLine(string message) 838417"];
9766 [label="param WriteLine(this) 838418"];
9767 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838419"];
9768 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838420"];
9769 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838421"];
9770 [label="Indent(); 838422"];
9771 [label="Debug.Assert(!_isForSingleSymbol); 838423"];
9772 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 838424"];
9773 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 838425"];
9774 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 838426"];
9775 [label="docCommentNodes 838427"];
9776 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 838428"];
9777 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 838429"];
9778 [label="maxDocumentationMode = DocumentationMode.None; 838430"];
9779 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 838431"];
9780 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 838432"];
9781 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 838433"];
9782 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 838434"];
9783 [label="currDocumentationMode > maxDocumentationMode 838435"];
9784 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 838436"];
9785 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 838437"];
9786 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 838438"];
9787 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 838439"];
9788 [label="return true; 838440"];
9789 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 838441"];
9790 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 838442"];
9791 [label="return; 838443"];
9792 [label="return; 838444"];
9793 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 838445"];
9794 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 838446"];
9795 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 838447"];
9796 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 838448"];
9797 [label="currDocumentationMode > maxDocumentationMode 838449"];
9798 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 838450"];
9799 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 838451"];
9800 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 838452"];
9801 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 838453"];
9802 [label="docCommentNodes 838454"];
9803 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 838455"];
9804 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 838456"];
9805 [label="maxDocumentationMode = DocumentationMode.None; 838457"];
9806 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 838458"];
9807 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 838459"];
9808 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 838460"];
9809 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 838461"];
9810 [label="currDocumentationMode > maxDocumentationMode 838462"];
9811 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 838463"];
9812 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 838464"];
9813 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 838465"];
9814 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 838466"];
9815 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 838467"];
9816 [label="return; 838468"];
9817 [label="return; 838469"];
9818 [label="Debug.Assert(_indentDepth >= 0); 838470"];
9819 [label="Unindent(); 838471"];
9820 [label="WriteLine('</members>'); 838472"];
9821 [label="WriteLine('</members>') 838473"];
9822 [label="param WriteLine(string message) 838474"];
9823 [label="param WriteLine(this) 838475"];
9824 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838476"];
9825 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838477"];
9826 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838478"];
9827 [label="Unindent(); 838479"];
9828 [label="WriteLine('</doc>'); 838480"];
9829 [label="WriteLine('</doc>') 838481"];
9830 [label="param WriteLine(string message) 838482"];
9831 [label="param WriteLine(this) 838483"];
9832 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838484"];
9833 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838485"];
9834 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 838486"];
9835 [label="Debug.Assert(compiler._indentDepth == 0); 838487"];
9836 [label="Debug.Assert(compiler._indentDepth == 0); 838488"];
9837 [label="writer?.Flush(); 838489"];
9838 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 838490"];
9839 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 838491"];
9840 [label="compilation.SyntaxTrees 838492"];
9841 [label="_syntaxAndDeclarations.GetLazyState() 838493"];
9842 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 838494"];
9843 [label="param ReportUnprocessed(TextSpan? filterSpanWithinTree) 838495"];
9844 [label="param ReportUnprocessed(DiagnosticBag diagnostics) 838496"];
9845 [label="param ReportUnprocessed(CancellationToken cancellationToken) 838497"];
9846 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 838498"];
9847 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 838499"];
9848 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 838500"];
9849 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken) 838501"];
9850 [label="param ReportUnusedImports(SyntaxTree? filterTree) 838502"];
9851 [label="param ReportUnusedImports(DiagnosticBag diagnostics) 838503"];
9852 [label="param ReportUnusedImports(CancellationToken cancellationToken) 838504"];
9853 [label="param ReportUnusedImports(this) 838505"];
9854 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 838506"];
9855 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 838507"];
9856 [label="CompleteTrees(filterTree); 838508"];
9857 [label="CompleteTrees(filterTree) 838509"];
9858 [label="param CompleteTrees(SyntaxTree? filterTree) 838510"];
9859 [label="param CompleteTrees(this) 838511"];
9860 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 838512"];
9861 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 838513"];
9862 [label="CompleteTrees(filterTree); 838514"];
9863 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 838515"];
9864 [label="builder.AddRangeAndFree(methodBodyDiagnostics); 838516"];
9865 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 838517"];
9866 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 838518"];
9867 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 838519"];
9868 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 838520"];
9869 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 838521"];
9870 [label="diagnostics.Verify(expected) 838522"];
9871 [label="Verify((IEnumerable<Diagnostic>)actual, expected) 838523"];
9872 [label="Verify(actual, expected, errorCodeOnly: false); 838524"];
9873 [label="Verify(actual, expected, errorCodeOnly: false) 838525"];
9874 [label="param Verify(bool errorCodeOnly) 838526"];
9875 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 838527"];
9876 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 838528"];
9877 [label="foreach (var d in expected)\n            {\n                int index = unmatched.IndexOf(d);\n                if (index > -1)\n                {\n                    unmatched.RemoveAt(index);\n                }\n                else\n                {\n                    CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n                }\n            } 838529"];
9878 [label="foreach (var d in expected)\n            {\n                int index = unmatched.IndexOf(d);\n                if (index > -1)\n                {\n                    unmatched.RemoveAt(index);\n                }\n                else\n                {\n                    CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n                }\n            } 838530"];
9879 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 838531"];
9880 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 838532"];
9881 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 838533"];
9882 [label="DiagnosticDescription.GetAssertText(expected, actual) 838534"];
9883 [label="param GetAssertText(DiagnosticDescription[] expected) 838535"];
9884 [label="const int CSharp = 1; 838536"];
9885 [label="const int VisualBasic = 2; 838537"];
9886 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 838538"];
9887 [label="actual.Any() && actual.First() is CSDiagnostic 838539"];
9888 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 838540"];
9889 [label="var includeDiagnosticMessagesAsComments = (language == CSharp); 838541"];
9890 [label="int indentDepth = (language == CSharp) ? 4 : 1; 838542"];
9891 [label="(language == CSharp) 838543"];
9892 [label="var includeDefaultSeverity = expected.Any() && expected.All(d => d.DefaultSeverity != null); 838544"];
9893 [label="var includeDefaultSeverity = expected.Any() && expected.All(d => d.DefaultSeverity != null); 838545"];
9894 [label="var includeEffectiveSeverity = expected.Any() && expected.All(d => d.EffectiveSeverity != null); 838546"];
9895 [label="var includeEffectiveSeverity = expected.Any() && expected.All(d => d.EffectiveSeverity != null); 838547"];
9896 [label="IsSortedOrEmpty(expected) 838548"];
9897 [label="param IsSortedOrEmpty(DiagnosticDescription[] diagnostics) 838549"];
9898 [label="var comparer = LinePositionComparer.Instance; 838550"];
9899 [label="DiagnosticDescription last = null; 838551"];
9900 [label="foreach (var diagnostic in diagnostics)\n            {\n                if (diagnostic._startPosition == null)\n                {\n                    return false;\n                }\n                if (last != null && comparer.Compare(last._startPosition, diagnostic._startPosition) > 0)\n                {\n                    return false;\n                }\n                last = diagnostic;\n            } 838552"];
9901 [label="foreach (var diagnostic in diagnostics)\n            {\n                if (diagnostic._startPosition == null)\n                {\n                    return false;\n                }\n                if (last != null && comparer.Compare(last._startPosition, diagnostic._startPosition) > 0)\n                {\n                    return false;\n                }\n                last = diagnostic;\n            } 838553"];
9902 [label="return true; 838554"];
9903 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 838555"];
9904 [label="Sort(actual) 838556"];
9905 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 838557"];
9906 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 838558"];
9907 [label="var assertText = new StringBuilder(); 838559"];
9908 [label="assertText.AppendLine(); 838560"];
9909 [label="int i; 838561"];
9910 [label="assertText.AppendLine('Expected:'); 838562"];
9911 [label="assertText.AppendLine('Expected:'); 838563"];
9912 [label="var expectedText = ArrayBuilder<string>.GetInstance(); 838564"];
9913 [label="foreach (var d in expected)\n            {\n                expectedText.Add(GetDiagnosticDescription(d, indentDepth));\n            } 838565"];
9914 [label="foreach (var d in expected)\n            {\n                expectedText.Add(GetDiagnosticDescription(d, indentDepth));\n            } 838566"];
9915 [label="GetCommaSeparatedLines(assertText, expectedText); 838567"];
9916 [label="GetCommaSeparatedLines(assertText, expectedText); 838568"];
9917 [label="GetCommaSeparatedLines(assertText, expectedText) 838569"];
9918 [label="param GetCommaSeparatedLines(StringBuilder sb) 838570"];
9919 [label="param GetCommaSeparatedLines(ArrayBuilder<string> lines) 838571"];
9920 [label="int n = lines.Count; 838572"];
9921 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 838573"];
9922 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 838574"];
9923 [label="GetCommaSeparatedLines(assertText, expectedText); 838575"];
9924 [label="assertText.AppendLine('Actual:'); 838576"];
9925 [label="assertText.AppendLine('Actual:'); 838577"];
9926 [label="var actualText = ArrayBuilder<string>.GetInstance(); 838578"];
9927 [label="for (i = 0; e.MoveNext(); i++)\n            {\n                Diagnostic d = e.Current;\n                string message = d.ToString();\n                if (Regex.Match(message, @'{\\d+}').Success)\n                {\n                    Assert.True(false, 'Diagnostic messages should never contain unsubstituted placeholders.\\n    ' + message);\n                }\n\n                if (i > 0)\n                {\n                    assertText.AppendLine(',');\n                }\n\n                if (includeDiagnosticMessagesAsComments)\n                {\n                    Indent(assertText, indentDepth);\n                    assertText.Append('// ');\n                    assertText.AppendLine(d.ToString());\n                    var l = d.Location;\n                    if (l.IsInSource)\n                    {\n                        Indent(assertText, indentDepth);\n                        assertText.Append('// ');\n                        assertText.AppendLine(l.SourceTree.GetText().Lines.GetLineFromPosition(l.SourceSpan.Start).ToString());\n                    }\n                }\n\n                var description = new DiagnosticDescription(d, errorCodeOnly: false, includeDefaultSeverity, includeEffectiveSeverity);\n                var diffDescription = description;\n                var idx = Array.IndexOf(expected, description);\n                if (idx != -1)\n                {\n                    diffDescription = expected[idx];\n                }\n                assertText.Append(GetDiagnosticDescription(description, indentDepth));\n                actualText.Add(GetDiagnosticDescription(diffDescription, indentDepth));\n            } 838579"];
9928 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 838580"];
9929 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 838581"];
9930 [label="assertText.AppendLine('Diff:'); 838582"];
9931 [label="assertText.AppendLine('Diff:'); 838583"];
9932 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 838584"];
9933 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 838585"];
9934 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 838586"];
9935 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 838587"];
9936 [label="DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine) 838588"];
9937 [label="param DiffReport(IEnumerable<T> expected) 838589"];
9938 [label="param DiffReport(IEnumerable<T> actual) 838590"];
9939 [label="param DiffReport(string separator) 838591"];
9940 [label="param DiffReport(IEqualityComparer<T> comparer = null) 838592"];
9941 [label="param DiffReport(Func<T, string> toString = null) 838593"];
9942 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 838594"];
9943 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 838595"];
9944 [label="(comparer != null) 838596"];
9945 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 838597"];
9946 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 838598"];
9947 [label="IList<T> expectedList = expected as IList<T> ?? new List<T>(expected); 838599"];
9948 [label="IList<T> actualList = actual as IList<T> ?? new List<T>(actual); 838600"];
9949 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 838601"];
9950 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 838602"];
9951 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 838603"];
9952 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 838604"];
9953 [label="lcs.CalculateDiff(expectedList, actualList, toString) 838605"];
9954 [label="param CalculateDiff(IList<T> sequenceA) 838606"];
9955 [label="param CalculateDiff(IList<T> sequenceB) 838607"];
9956 [label="param CalculateDiff(Func<T, string> toString) 838608"];
9957 [label="param CalculateDiff(this) 838609"];
9958 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 838610"];
9959 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 838611"];
9960 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 838612"];
9961 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 838613"];
9962 [label="GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count) 838614"];
9963 [label="param GetEdits(TSequence sequenceA) 838615"];
9964 [label="param GetEdits(int lengthA) 838616"];
9965 [label="param GetEdits(TSequence sequenceB) 838617"];
9966 [label="param GetEdits(int lengthB) 838618"];
9967 [label="param GetEdits(this) 838619"];
9968 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 838620"];
9969 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 838621"];
9970 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 838622"];
9971 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 838623"];
9972 [label="ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB) 838624"];
9973 [label="param ComputeCostMatrix(TSequence sequenceA) 838625"];
9974 [label="param ComputeCostMatrix(int lengthA) 838626"];
9975 [label="param ComputeCostMatrix(TSequence sequenceB) 838627"];
9976 [label="param ComputeCostMatrix(int lengthB) 838628"];
9977 [label="param ComputeCostMatrix(this) 838629"];
9978 [label="var la = lengthA + 1; 838630"];
9979 [label="var la = lengthA + 1; 838631"];
9980 [label="var lb = lengthB + 1; 838632"];
9981 [label="var lb = lengthB + 1; 838633"];
9982 [label="var d = new int[la, lb]; 838634"];
9983 [label="d[0, 0] = 0; 838635"];
9984 [label="d[0, 0] 838636"];
9985 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 838637"];
9986 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 838638"];
9987 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 838639"];
9988 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 838640"];
9989 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 838641"];
9990 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 838642"];
9991 [label="return d; 838643"];
9992 [label="int i = lengthA; 838644"];
9993 [label="int j = lengthB; 838645"];
9994 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 838646"];
9995 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 838647"];
9996 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 838648"];
9997 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 838649"];
9998 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 838650"];
9999 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 838651"];
10000 [label="param GetEdits(this) 838652"];
10001 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 838653"];
10002 [label="param CalculateDiff(this) 838654"];
10003 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 838655"];
10004 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 838656"];
10005 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 838657"];
10006 [label="actualText.Free(); 838658"];
10007 [label="expectedText.Free(); 838659"];
10008 [label="return assertText.ToString(); 838660"];
10009 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 838661"];
10010 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 838662"];
10011 [label="diagnostics.Verify(expected); 838663"];
10012 [label="VerifyAssemblyIds(c, diagnostics); 838664"];
10013 [label="VerifyAssemblyIds(c, diagnostics); 838665"];
10014 [label="VerifyAssemblyIds(c, diagnostics) 838666"];
10015 [label="param VerifyAssemblyIds(TCompilation c) 838667"];
10016 [label="param VerifyAssemblyIds(ImmutableArray<Diagnostic> diagnostics) 838668"];
10017 [label="foreach (var diagnostic in diagnostics)\n            {\n                // If this is a diagnostic about a missing assembly, make sure that we can get back\n                // an AssemblyIdentity when we query the compiler.  If it's not a diagnostic about\n                // a missing assembly, make sure we get no results back.\n                if (c.IsUnreferencedAssemblyIdentityDiagnosticCode(diagnostic.Code))\n                {\n                    var assemblyIds = c.GetUnreferencedAssemblyIdentities(diagnostic);\n                    CustomAssert.False(assemblyIds.IsEmpty);\n\n                    var diagnosticMessage = diagnostic.GetMessage();\n                    foreach (var id in assemblyIds)\n                    {\n                        CustomAssert.Contains(id.GetDisplayName(), diagnosticMessage);\n                    }\n                }\n                else\n                {\n                    var assemblyIds = c.GetUnreferencedAssemblyIdentities(diagnostic);\n                    CustomAssert.True(assemblyIds.IsEmpty);\n                }\n            } 838669"];
10018 [label="VerifyAssemblyIds(c, diagnostics); 838670"];
2 -> 0;
2 -> 1;
3 -> 1;
4 -> 3;
5 -> 4;
6 -> 5;
7 -> 6;
8 -> 7;
8 -> 6;
9 -> 1;
9 -> 2;
9 -> 8;
10 -> 1;
11 -> 1;
12 -> 1;
13 -> 11;
13 -> 12;
14 -> 11;
14 -> 12;
15 -> 11;
15 -> 12;
16 -> 11;
16 -> 12;
17 -> 10;
17 -> 12;
18 -> 12;
19 -> 16;
19 -> 18;
19 -> 12;
20 -> 13;
20 -> 19;
21 -> 14;
21 -> 19;
22 -> 15;
22 -> 19;
23 -> 19;
24 -> 19;
25 -> 20;
25 -> 24;
26 -> 21;
26 -> 24;
27 -> 22;
27 -> 24;
28 -> 23;
28 -> 24;
29 -> 24;
30 -> 29;
31 -> 30;
31 -> 24;
32 -> 25;
32 -> 24;
33 -> 24;
34 -> 31;
34 -> 24;
35 -> 24;
36 -> 33;
36 -> 35;
37 -> 36;
37 -> 35;
38 -> 35;
39 -> 37;
39 -> 38;
40 -> 38;
41 -> 39;
41 -> 40;
41 -> 38;
42 -> 38;
42 -> 24;
43 -> 32;
43 -> 35;
44 -> 33;
44 -> 35;
45 -> 33;
45 -> 35;
46 -> 33;
46 -> 35;
47 -> 42;
47 -> 35;
48 -> 34;
48 -> 35;
49 -> 33;
49 -> 35;
50 -> 33;
50 -> 35;
51 -> 43;
51 -> 35;
52 -> 47;
52 -> 35;
53 -> 44;
53 -> 35;
54 -> 35;
55 -> 52;
55 -> 54;
56 -> 53;
56 -> 54;
57 -> 55;
57 -> 54;
58 -> 54;
59 -> 57;
59 -> 58;
60 -> 59;
60 -> 58;
61 -> 60;
62 -> 0;
62 -> 61;
63 -> 62;
64 -> 63;
65 -> 64;
65 -> 61;
66 -> 54;
67 -> 56;
67 -> 66;
67 -> 54;
68 -> 65;
68 -> 67;
69 -> 45;
69 -> 35;
70 -> 46;
70 -> 35;
71 -> 48;
71 -> 35;
72 -> 49;
72 -> 35;
73 -> 50;
73 -> 35;
74 -> 35;
75 -> 51;
75 -> 74;
76 -> 68;
76 -> 74;
77 -> 69;
77 -> 74;
78 -> 70;
78 -> 74;
79 -> 71;
79 -> 74;
80 -> 72;
80 -> 74;
81 -> 73;
81 -> 74;
82 -> 75;
82 -> 74;
83 -> 76;
83 -> 74;
84 -> 77;
84 -> 74;
85 -> 78;
85 -> 74;
86 -> 79;
86 -> 74;
87 -> 80;
87 -> 74;
88 -> 81;
88 -> 74;
89 -> 74;
90 -> 89;
90 -> 74;
91 -> 74;
92 -> 82;
92 -> 91;
93 -> 83;
93 -> 91;
94 -> 84;
94 -> 91;
95 -> 85;
95 -> 91;
96 -> 86;
96 -> 91;
97 -> 87;
97 -> 91;
98 -> 88;
98 -> 91;
99 -> 90;
99 -> 91;
100 -> 95;
100 -> 91;
101 -> 97;
101 -> 91;
102 -> 91;
103 -> 100;
103 -> 102;
104 -> 101;
104 -> 102;
105 -> 92;
105 -> 102;
106 -> 105;
106 -> 32;
106 -> 102;
107 -> 106;
108 -> 104;
108 -> 106;
109 -> 103;
109 -> 106;
110 -> 106;
111 -> 107;
111 -> 110;
112 -> 108;
112 -> 110;
113 -> 109;
113 -> 110;
114 -> 107;
114 -> 110;
115 -> 110;
116 -> 113;
116 -> 115;
116 -> 110;
117 -> 0;
117 -> 116;
118 -> 111;
118 -> 110;
119 -> 0;
119 -> 110;
120 -> 119;
120 -> 114;
120 -> 110;
121 -> 110;
122 -> 118;
122 -> 120;
122 -> 121;
122 -> 0;
122 -> 110;
123 -> 122;
123 -> 110;
124 -> 117;
124 -> 110;
125 -> 112;
125 -> 110;
126 -> 110;
127 -> 123;
127 -> 124;
127 -> 125;
127 -> 126;
127 -> 122;
127 -> 0;
127 -> 110;
128 -> 110;
129 -> 127;
129 -> 128;
130 -> 128;
131 -> 128;
132 -> 129;
132 -> 127;
132 -> 131;
132 -> 128;
133 -> 130;
133 -> 128;
134 -> 128;
135 -> 132;
135 -> 127;
135 -> 131;
135 -> 133;
135 -> 134;
135 -> 130;
135 -> 128;
136 -> 128;
137 -> 136;
137 -> 130;
137 -> 128;
138 -> 130;
138 -> 128;
139 -> 128;
140 -> 138;
140 -> 139;
140 -> 130;
140 -> 137;
140 -> 128;
141 -> 129;
141 -> 128;
142 -> 141;
142 -> 107;
142 -> 106;
143 -> 107;
143 -> 91;
144 -> 91;
145 -> 94;
145 -> 144;
145 -> 91;
146 -> 0;
146 -> 91;
147 -> 99;
147 -> 91;
148 -> 96;
148 -> 143;
148 -> 93;
148 -> 94;
148 -> 91;
149 -> 148;
149 -> 91;
150 -> 91;
151 -> 149;
151 -> 150;
152 -> 0;
152 -> 150;
153 -> 152;
154 -> 91;
155 -> 0;
157 -> 155;
157 -> 156;
158 -> 157;
159 -> 0;
161 -> 159;
161 -> 160;
163 -> 161;
163 -> 162;
164 -> 163;
165 -> 148;
165 -> 107;
165 -> 142;
165 -> 127;
165 -> 64;
165 -> 0;
165 -> 33;
165 -> 91;
166 -> 91;
167 -> 165;
167 -> 166;
168 -> 165;
168 -> 166;
169 -> 165;
169 -> 166;
170 -> 165;
170 -> 166;
171 -> 167;
171 -> 166;
172 -> 170;
172 -> 166;
173 -> 168;
173 -> 166;
174 -> 169;
174 -> 166;
175 -> 166;
176 -> 166;
177 -> 171;
177 -> 176;
178 -> 172;
178 -> 176;
179 -> 173;
179 -> 176;
180 -> 174;
180 -> 176;
181 -> 175;
181 -> 176;
182 -> 175;
182 -> 176;
183 -> 175;
183 -> 176;
184 -> 175;
184 -> 176;
185 -> 176;
186 -> 178;
186 -> 185;
186 -> 176;
187 -> 184;
187 -> 176;
188 -> 180;
188 -> 176;
189 -> 177;
189 -> 176;
190 -> 178;
190 -> 176;
191 -> 188;
191 -> 176;
192 -> 181;
192 -> 176;
193 -> 182;
193 -> 176;
194 -> 183;
194 -> 176;
195 -> 184;
195 -> 176;
196 -> 176;
197 -> 0;
197 -> 176;
198 -> 178;
198 -> 188;
198 -> 176;
199 -> 176;
200 -> 197;
200 -> 199;
201 -> 198;
201 -> 199;
202 -> 198;
202 -> 199;
203 -> 197;
203 -> 199;
204 -> 195;
204 -> 199;
205 -> 196;
205 -> 199;
206 -> 196;
206 -> 199;
207 -> 200;
207 -> 199;
208 -> 201;
208 -> 199;
209 -> 202;
209 -> 199;
210 -> 203;
210 -> 199;
211 -> 204;
211 -> 199;
212 -> 199;
213 -> 212;
213 -> 207;
213 -> 208;
213 -> 209;
213 -> 210;
213 -> 211;
213 -> 0;
213 -> 188;
213 -> 199;
214 -> 212;
214 -> 199;
215 -> 205;
215 -> 212;
215 -> 199;
216 -> 176;
217 -> 189;
217 -> 216;
218 -> 190;
218 -> 216;
219 -> 191;
219 -> 216;
220 -> 192;
220 -> 216;
221 -> 193;
221 -> 216;
222 -> 194;
222 -> 216;
223 -> 195;
223 -> 216;
224 -> 196;
224 -> 216;
225 -> 196;
225 -> 216;
226 -> 196;
226 -> 216;
227 -> 196;
227 -> 216;
228 -> 196;
228 -> 216;
229 -> 196;
229 -> 216;
230 -> 217;
230 -> 216;
231 -> 218;
231 -> 216;
232 -> 219;
232 -> 216;
233 -> 220;
233 -> 216;
234 -> 221;
234 -> 216;
235 -> 222;
235 -> 216;
236 -> 223;
236 -> 216;
237 -> 224;
237 -> 216;
238 -> 225;
238 -> 216;
239 -> 226;
239 -> 216;
240 -> 226;
240 -> 213;
240 -> 216;
241 -> 240;
241 -> 213;
241 -> 214;
241 -> 215;
241 -> 216;
242 -> 227;
242 -> 216;
243 -> 228;
243 -> 216;
244 -> 216;
245 -> 230;
245 -> 244;
246 -> 231;
246 -> 244;
247 -> 232;
247 -> 244;
248 -> 233;
248 -> 244;
249 -> 234;
249 -> 244;
250 -> 235;
250 -> 244;
251 -> 236;
251 -> 244;
252 -> 237;
252 -> 244;
253 -> 238;
253 -> 244;
254 -> 239;
254 -> 244;
255 -> 241;
255 -> 244;
256 -> 242;
256 -> 244;
257 -> 243;
257 -> 244;
258 -> 229;
258 -> 244;
259 -> 245;
259 -> 244;
260 -> 247;
260 -> 244;
261 -> 255;
261 -> 244;
262 -> 251;
262 -> 244;
263 -> 256;
263 -> 244;
264 -> 257;
264 -> 244;
265 -> 244;
266 -> 265;
266 -> 259;
266 -> 260;
266 -> 261;
266 -> 262;
266 -> 263;
266 -> 264;
266 -> 188;
266 -> 241;
266 -> 244;
267 -> 265;
267 -> 244;
268 -> 265;
268 -> 244;
269 -> 265;
269 -> 244;
270 -> 265;
270 -> 244;
271 -> 265;
271 -> 244;
272 -> 265;
272 -> 244;
273 -> 265;
273 -> 244;
274 -> 265;
274 -> 244;
275 -> 265;
275 -> 244;
276 -> 265;
276 -> 244;
277 -> 265;
277 -> 244;
278 -> 265;
278 -> 244;
279 -> 265;
279 -> 244;
280 -> 265;
280 -> 244;
281 -> 265;
281 -> 244;
282 -> 265;
282 -> 244;
283 -> 265;
283 -> 244;
284 -> 265;
284 -> 244;
285 -> 265;
285 -> 244;
286 -> 265;
286 -> 244;
287 -> 265;
287 -> 244;
288 -> 265;
288 -> 244;
289 -> 265;
289 -> 244;
290 -> 265;
290 -> 244;
291 -> 265;
291 -> 244;
292 -> 265;
292 -> 244;
293 -> 244;
294 -> 293;
294 -> 265;
294 -> 244;
295 -> 265;
295 -> 244;
296 -> 295;
296 -> 266;
296 -> 267;
296 -> 268;
296 -> 269;
296 -> 270;
296 -> 271;
296 -> 272;
296 -> 273;
296 -> 274;
296 -> 275;
296 -> 276;
296 -> 277;
296 -> 278;
296 -> 279;
296 -> 280;
296 -> 281;
296 -> 282;
296 -> 283;
296 -> 284;
296 -> 285;
296 -> 286;
296 -> 287;
296 -> 288;
296 -> 289;
296 -> 290;
296 -> 291;
296 -> 292;
296 -> 294;
296 -> 293;
296 -> 244;
297 -> 296;
297 -> 265;
297 -> 244;
298 -> 246;
298 -> 265;
298 -> 244;
299 -> 265;
299 -> 244;
300 -> 244;
301 -> 244;
302 -> 299;
302 -> 301;
303 -> 300;
303 -> 301;
304 -> 303;
304 -> 301;
305 -> 303;
305 -> 301;
306 -> 303;
306 -> 301;
307 -> 302;
307 -> 303;
307 -> 301;
308 -> 300;
308 -> 265;
308 -> 244;
309 -> 265;
309 -> 296;
309 -> 244;
310 -> 309;
310 -> 296;
310 -> 297;
310 -> 298;
310 -> 308;
310 -> 307;
310 -> 305;
310 -> 306;
310 -> 244;
311 -> 310;
311 -> 265;
311 -> 244;
312 -> 265;
312 -> 310;
312 -> 244;
313 -> 312;
313 -> 310;
313 -> 311;
313 -> 244;
314 -> 313;
314 -> 265;
314 -> 244;
315 -> 265;
315 -> 313;
315 -> 244;
316 -> 315;
316 -> 313;
316 -> 314;
316 -> 244;
317 -> 316;
317 -> 265;
317 -> 244;
318 -> 265;
318 -> 316;
318 -> 244;
319 -> 318;
319 -> 316;
319 -> 317;
319 -> 244;
320 -> 319;
320 -> 265;
320 -> 244;
321 -> 265;
321 -> 244;
322 -> 321;
322 -> 319;
322 -> 320;
322 -> 244;
323 -> 322;
323 -> 265;
323 -> 244;
324 -> 254;
324 -> 322;
324 -> 244;
325 -> 244;
326 -> 324;
326 -> 325;
327 -> 325;
328 -> 326;
328 -> 325;
329 -> 328;
329 -> 322;
329 -> 323;
329 -> 325;
330 -> 0;
330 -> 325;
331 -> 330;
331 -> 327;
331 -> 325;
332 -> 331;
332 -> 244;
333 -> 332;
333 -> 265;
333 -> 244;
334 -> 251;
334 -> 244;
335 -> 334;
336 -> 248;
336 -> 335;
336 -> 334;
337 -> 249;
337 -> 335;
337 -> 334;
338 -> 336;
338 -> 337;
338 -> 334;
339 -> 250;
339 -> 335;
339 -> 334;
340 -> 338;
340 -> 339;
340 -> 334;
341 -> 253;
341 -> 244;
342 -> 265;
342 -> 322;
342 -> 323;
342 -> 333;
342 -> 341;
343 -> 341;
344 -> 265;
344 -> 343;
345 -> 344;
345 -> 342;
345 -> 343;
346 -> 252;
346 -> 341;
347 -> 342;
347 -> 345;
347 -> 346;
347 -> 341;
348 -> 347;
348 -> 265;
348 -> 341;
349 -> 254;
349 -> 265;
349 -> 244;
350 -> 265;
350 -> 347;
350 -> 244;
351 -> 244;
352 -> 265;
352 -> 347;
352 -> 351;
352 -> 244;
353 -> 176;
354 -> 179;
354 -> 353;
354 -> 176;
355 -> 179;
355 -> 354;
356 -> 354;
357 -> 355;
357 -> 356;
358 -> 196;
358 -> 356;
359 -> 356;
360 -> 357;
360 -> 359;
360 -> 356;
361 -> 357;
361 -> 356;
362 -> 361;
362 -> 347;
362 -> 348;
362 -> 349;
362 -> 356;
363 -> 356;
364 -> 358;
364 -> 362;
364 -> 356;
365 -> 363;
365 -> 356;
366 -> 364;
366 -> 362;
366 -> 356;
367 -> 365;
367 -> 366;
367 -> 363;
367 -> 362;
367 -> 356;
368 -> 356;
369 -> 356;
370 -> 357;
370 -> 356;
371 -> 370;
371 -> 367;
371 -> 356;
372 -> 371;
373 -> 371;
374 -> 371;
375 -> 358;
375 -> 374;
375 -> 371;
376 -> 371;
377 -> 363;
377 -> 376;
377 -> 374;
377 -> 371;
378 -> 368;
378 -> 371;
378 -> 377;
379 -> 369;
379 -> 371;
380 -> 363;
380 -> 377;
380 -> 356;
381 -> 358;
381 -> 380;
381 -> 356;
382 -> 357;
382 -> 356;
383 -> 356;
384 -> 382;
384 -> 383;
385 -> 364;
385 -> 383;
386 -> 385;
386 -> 380;
386 -> 383;
387 -> 385;
387 -> 380;
387 -> 383;
388 -> 385;
388 -> 380;
388 -> 383;
389 -> 385;
389 -> 380;
389 -> 383;
390 -> 385;
390 -> 380;
390 -> 383;
391 -> 384;
391 -> 383;
392 -> 385;
392 -> 380;
392 -> 391;
392 -> 383;
393 -> 383;
394 -> 390;
394 -> 393;
394 -> 383;
395 -> 392;
395 -> 394;
396 -> 394;
397 -> 395;
397 -> 396;
398 -> 385;
398 -> 396;
399 -> 397;
399 -> 396;
400 -> 398;
400 -> 392;
400 -> 396;
401 -> 396;
402 -> 396;
403 -> 399;
403 -> 402;
404 -> 400;
404 -> 402;
405 -> 400;
405 -> 402;
406 -> 400;
406 -> 402;
407 -> 400;
407 -> 402;
408 -> 401;
408 -> 402;
409 -> 401;
409 -> 402;
410 -> 402;
410 -> 403;
410 -> 404;
410 -> 405;
410 -> 406;
410 -> 407;
410 -> 392;
411 -> 401;
411 -> 394;
412 -> 411;
412 -> 356;
413 -> 358;
413 -> 410;
413 -> 356;
414 -> 378;
414 -> 356;
415 -> 412;
415 -> 356;
416 -> 356;
417 -> 413;
417 -> 416;
418 -> 414;
418 -> 416;
419 -> 415;
419 -> 416;
420 -> 358;
420 -> 416;
421 -> 420;
421 -> 410;
421 -> 416;
422 -> 416;
423 -> 420;
423 -> 422;
424 -> 423;
424 -> 410;
424 -> 422;
425 -> 424;
425 -> 422;
426 -> 425;
426 -> 416;
427 -> 420;
427 -> 410;
427 -> 402;
427 -> 408;
427 -> 416;
428 -> 416;
429 -> 427;
429 -> 428;
430 -> 429;
430 -> 427;
430 -> 428;
431 -> 416;
432 -> 430;
432 -> 431;
433 -> 417;
433 -> 416;
434 -> 418;
434 -> 416;
435 -> 419;
435 -> 416;
436 -> 416;
437 -> 416;
438 -> 421;
438 -> 437;
439 -> 421;
439 -> 437;
440 -> 421;
440 -> 437;
441 -> 426;
441 -> 437;
442 -> 430;
442 -> 437;
443 -> 432;
443 -> 437;
444 -> 432;
444 -> 437;
445 -> 433;
445 -> 437;
446 -> 434;
446 -> 437;
447 -> 435;
447 -> 437;
448 -> 432;
448 -> 437;
449 -> 436;
449 -> 437;
450 -> 436;
450 -> 437;
451 -> 441;
451 -> 437;
452 -> 442;
452 -> 437;
453 -> 443;
453 -> 437;
454 -> 447;
454 -> 432;
454 -> 437;
455 -> 449;
455 -> 437;
456 -> 437;
457 -> 451;
457 -> 456;
458 -> 452;
458 -> 456;
459 -> 453;
459 -> 456;
460 -> 455;
460 -> 456;
461 -> 450;
461 -> 456;
462 -> 460;
462 -> 456;
463 -> 456;
464 -> 463;
464 -> 456;
465 -> 463;
465 -> 456;
466 -> 463;
466 -> 456;
467 -> 463;
467 -> 456;
468 -> 463;
468 -> 456;
469 -> 463;
469 -> 456;
470 -> 463;
470 -> 456;
471 -> 463;
471 -> 456;
472 -> 463;
472 -> 456;
473 -> 463;
473 -> 456;
474 -> 463;
474 -> 456;
475 -> 463;
475 -> 456;
476 -> 463;
476 -> 456;
477 -> 463;
477 -> 456;
478 -> 463;
478 -> 456;
479 -> 463;
479 -> 456;
480 -> 463;
480 -> 456;
481 -> 463;
481 -> 456;
482 -> 463;
482 -> 456;
483 -> 463;
483 -> 456;
484 -> 463;
484 -> 456;
485 -> 463;
485 -> 456;
486 -> 463;
486 -> 456;
487 -> 463;
487 -> 456;
488 -> 463;
488 -> 456;
489 -> 463;
489 -> 456;
490 -> 456;
491 -> 490;
491 -> 463;
491 -> 456;
492 -> 463;
492 -> 456;
493 -> 463;
493 -> 456;
494 -> 456;
495 -> 456;
496 -> 493;
496 -> 495;
497 -> 494;
497 -> 495;
498 -> 497;
498 -> 495;
499 -> 497;
499 -> 495;
500 -> 497;
500 -> 495;
501 -> 496;
501 -> 497;
501 -> 495;
502 -> 494;
502 -> 463;
502 -> 456;
503 -> 463;
503 -> 456;
504 -> 456;
505 -> 454;
505 -> 504;
506 -> 504;
507 -> 505;
507 -> 504;
508 -> 507;
508 -> 454;
509 -> 507;
510 -> 508;
510 -> 509;
511 -> 444;
511 -> 456;
512 -> 511;
513 -> 457;
513 -> 512;
513 -> 511;
514 -> 458;
514 -> 512;
514 -> 511;
515 -> 513;
515 -> 514;
515 -> 511;
516 -> 459;
516 -> 512;
516 -> 511;
517 -> 515;
517 -> 516;
517 -> 511;
518 -> 445;
518 -> 446;
519 -> 463;
519 -> 446;
520 -> 445;
520 -> 519;
520 -> 454;
520 -> 510;
520 -> 446;
521 -> 445;
521 -> 463;
521 -> 446;
522 -> 463;
522 -> 520;
522 -> 456;
523 -> 456;
524 -> 463;
524 -> 520;
524 -> 523;
524 -> 456;
525 -> 436;
525 -> 356;
526 -> 525;
526 -> 354;
527 -> 526;
527 -> 520;
527 -> 176;
528 -> 526;
528 -> 176;
529 -> 165;
529 -> 528;
529 -> 520;
529 -> 521;
529 -> 447;
529 -> 91;
530 -> 529;
530 -> 91;
531 -> 91;
532 -> 530;
532 -> 531;
533 -> 531;
534 -> 532;
534 -> 533;
535 -> 533;
536 -> 534;
536 -> 529;
536 -> 535;
537 -> 535;
538 -> 536;
538 -> 529;
538 -> 537;
538 -> 535;
539 -> 536;
539 -> 529;
539 -> 538;
540 -> 538;
541 -> 539;
541 -> 540;
542 -> 539;
542 -> 540;
543 -> 539;
543 -> 540;
544 -> 539;
544 -> 540;
545 -> 539;
545 -> 540;
546 -> 540;
547 -> 540;
548 -> 540;
549 -> 540;
550 -> 540;
551 -> 0;
551 -> 540;
552 -> 541;
552 -> 540;
553 -> 546;
553 -> 552;
554 -> 552;
555 -> 542;
555 -> 552;
556 -> 543;
556 -> 552;
557 -> 544;
557 -> 552;
558 -> 545;
558 -> 552;
559 -> 547;
559 -> 552;
560 -> 548;
560 -> 552;
561 -> 549;
561 -> 552;
562 -> 550;
562 -> 552;
563 -> 551;
563 -> 552;
564 -> 552;
565 -> 553;
565 -> 564;
566 -> 554;
566 -> 564;
567 -> 555;
567 -> 564;
568 -> 556;
568 -> 564;
569 -> 557;
569 -> 564;
570 -> 558;
570 -> 564;
571 -> 559;
571 -> 564;
572 -> 560;
572 -> 564;
573 -> 561;
573 -> 564;
574 -> 562;
574 -> 564;
575 -> 563;
575 -> 564;
576 -> 566;
576 -> 529;
576 -> 564;
577 -> 576;
577 -> 0;
577 -> 564;
578 -> 566;
578 -> 564;
579 -> 567;
579 -> 564;
580 -> 570;
580 -> 564;
581 -> 574;
581 -> 564;
582 -> 575;
582 -> 564;
583 -> 564;
584 -> 578;
584 -> 583;
585 -> 579;
585 -> 583;
586 -> 580;
586 -> 583;
587 -> 581;
587 -> 583;
588 -> 582;
588 -> 583;
589 -> 584;
589 -> 585;
589 -> 586;
589 -> 583;
590 -> 584;
590 -> 583;
591 -> 589;
591 -> 583;
592 -> 587;
592 -> 590;
592 -> 591;
592 -> 550;
592 -> 589;
592 -> 583;
593 -> 589;
593 -> 583;
594 -> 588;
594 -> 593;
594 -> 0;
594 -> 592;
594 -> 583;
595 -> 564;
596 -> 566;
596 -> 564;
597 -> 565;
597 -> 596;
597 -> 546;
597 -> 594;
597 -> 564;
598 -> 566;
598 -> 564;
599 -> 571;
599 -> 547;
599 -> 564;
600 -> 571;
600 -> 598;
600 -> 599;
600 -> 547;
600 -> 597;
600 -> 564;
601 -> 546;
601 -> 600;
601 -> 540;
602 -> 547;
602 -> 600;
602 -> 540;
603 -> 548;
603 -> 540;
604 -> 549;
604 -> 540;
605 -> 594;
605 -> 540;
606 -> 540;
607 -> 540;
608 -> 601;
608 -> 607;
609 -> 602;
609 -> 607;
610 -> 603;
610 -> 607;
611 -> 604;
611 -> 607;
612 -> 602;
612 -> 607;
613 -> 605;
613 -> 607;
614 -> 606;
614 -> 607;
615 -> 614;
615 -> 607;
616 -> 614;
616 -> 607;
617 -> 614;
617 -> 607;
618 -> 614;
618 -> 607;
619 -> 614;
619 -> 607;
620 -> 608;
620 -> 607;
621 -> 608;
621 -> 601;
621 -> 607;
622 -> 608;
622 -> 607;
623 -> 612;
623 -> 620;
623 -> 607;
624 -> 0;
624 -> 607;
625 -> 608;
625 -> 614;
625 -> 607;
626 -> 609;
626 -> 614;
626 -> 607;
627 -> 610;
627 -> 614;
627 -> 607;
628 -> 611;
628 -> 614;
628 -> 607;
629 -> 612;
629 -> 614;
629 -> 607;
630 -> 613;
630 -> 614;
630 -> 607;
631 -> 606;
631 -> 538;
632 -> 538;
633 -> 539;
633 -> 631;
633 -> 632;
633 -> 626;
633 -> 627;
633 -> 628;
633 -> 629;
633 -> 630;
633 -> 625;
633 -> 623;
633 -> 601;
633 -> 603;
633 -> 604;
633 -> 538;
634 -> 536;
634 -> 633;
634 -> 535;
635 -> 634;
635 -> 533;
636 -> 635;
636 -> 531;
637 -> 636;
637 -> 633;
637 -> 531;
638 -> 531;
639 -> 636;
639 -> 638;
639 -> 633;
639 -> 531;
640 -> 0;
640 -> 531;
641 -> 639;
641 -> 640;
641 -> 531;
642 -> 98;
642 -> 641;
642 -> 91;
643 -> 529;
643 -> 91;
644 -> 643;
644 -> 24;
645 -> 24;
646 -> 24;
647 -> 644;
647 -> 646;
648 -> 645;
648 -> 646;
649 -> 646;
650 -> 646;
651 -> 649;
651 -> 650;
652 -> 647;
652 -> 650;
653 -> 0;
653 -> 650;
654 -> 650;
655 -> 651;
655 -> 650;
656 -> 650;
657 -> 653;
657 -> 656;
658 -> 654;
658 -> 656;
659 -> 655;
659 -> 656;
660 -> 652;
660 -> 656;
661 -> 656;
662 -> 657;
662 -> 656;
663 -> 658;
663 -> 656;
664 -> 661;
664 -> 656;
665 -> 659;
665 -> 656;
666 -> 656;
667 -> 662;
667 -> 666;
668 -> 663;
668 -> 666;
669 -> 664;
669 -> 666;
670 -> 665;
670 -> 666;
671 -> 660;
671 -> 666;
672 -> 666;
673 -> 667;
673 -> 0;
673 -> 666;
674 -> 673;
674 -> 668;
674 -> 666;
675 -> 674;
676 -> 671;
676 -> 675;
677 -> 675;
678 -> 676;
678 -> 641;
678 -> 677;
679 -> 677;
680 -> 678;
680 -> 674;
681 -> 674;
682 -> 671;
682 -> 681;
683 -> 682;
683 -> 641;
683 -> 681;
684 -> 683;
684 -> 674;
685 -> 684;
686 -> 680;
686 -> 641;
686 -> 684;
687 -> 670;
687 -> 684;
688 -> 685;
688 -> 686;
688 -> 687;
688 -> 649;
688 -> 684;
689 -> 688;
689 -> 685;
690 -> 688;
690 -> 685;
691 -> 688;
691 -> 685;
692 -> 688;
692 -> 685;
693 -> 685;
694 -> 693;
694 -> 685;
695 -> 685;
696 -> 690;
696 -> 695;
697 -> 696;
697 -> 685;
698 -> 691;
698 -> 685;
699 -> 693;
699 -> 685;
700 -> 697;
700 -> 688;
700 -> 698;
700 -> 699;
700 -> 694;
700 -> 685;
701 -> 674;
702 -> 680;
702 -> 674;
703 -> 670;
703 -> 649;
703 -> 700;
703 -> 702;
704 -> 702;
704 -> 641;
705 -> 667;
705 -> 0;
705 -> 666;
706 -> 705;
706 -> 668;
706 -> 666;
707 -> 672;
707 -> 706;
708 -> 707;
708 -> 671;
708 -> 672;
708 -> 641;
708 -> 706;
709 -> 706;
710 -> 708;
710 -> 709;
711 -> 710;
711 -> 708;
711 -> 709;
712 -> 706;
713 -> 671;
713 -> 712;
714 -> 713;
714 -> 711;
714 -> 712;
715 -> 714;
715 -> 706;
716 -> 706;
717 -> 671;
717 -> 716;
718 -> 717;
718 -> 715;
718 -> 716;
719 -> 718;
719 -> 706;
720 -> 670;
720 -> 703;
720 -> 706;
721 -> 706;
722 -> 671;
722 -> 721;
723 -> 722;
723 -> 715;
723 -> 721;
724 -> 722;
724 -> 723;
725 -> 723;
726 -> 724;
726 -> 725;
727 -> 725;
728 -> 726;
728 -> 727;
729 -> 727;
730 -> 728;
730 -> 724;
730 -> 729;
731 -> 730;
731 -> 727;
732 -> 731;
732 -> 725;
733 -> 724;
733 -> 725;
734 -> 733;
734 -> 732;
734 -> 725;
735 -> 724;
735 -> 725;
736 -> 725;
737 -> 722;
737 -> 734;
737 -> 723;
738 -> 722;
738 -> 734;
738 -> 721;
739 -> 738;
739 -> 706;
740 -> 670;
740 -> 720;
740 -> 706;
741 -> 670;
741 -> 706;
742 -> 706;
743 -> 706;
744 -> 742;
744 -> 743;
745 -> 742;
745 -> 743;
746 -> 742;
746 -> 743;
747 -> 741;
747 -> 743;
748 -> 671;
748 -> 743;
749 -> 743;
750 -> 748;
750 -> 749;
751 -> 750;
751 -> 739;
751 -> 749;
752 -> 749;
753 -> 751;
753 -> 752;
754 -> 753;
754 -> 752;
755 -> 754;
755 -> 751;
755 -> 752;
756 -> 752;
757 -> 755;
757 -> 756;
758 -> 757;
758 -> 755;
758 -> 756;
759 -> 758;
759 -> 756;
760 -> 759;
760 -> 743;
761 -> 747;
761 -> 743;
762 -> 760;
762 -> 761;
762 -> 759;
762 -> 740;
762 -> 743;
763 -> 743;
764 -> 743;
765 -> 744;
765 -> 764;
765 -> 743;
766 -> 743;
767 -> 748;
767 -> 766;
768 -> 766;
769 -> 767;
769 -> 768;
770 -> 768;
771 -> 769;
771 -> 770;
772 -> 771;
772 -> 762;
772 -> 770;
773 -> 771;
773 -> 762;
773 -> 770;
774 -> 773;
774 -> 768;
775 -> 769;
775 -> 762;
775 -> 768;
776 -> 769;
776 -> 775;
776 -> 768;
777 -> 776;
777 -> 766;
778 -> 777;
778 -> 743;
779 -> 763;
779 -> 743;
780 -> 747;
780 -> 743;
781 -> 779;
781 -> 780;
781 -> 778;
781 -> 740;
781 -> 775;
781 -> 743;
782 -> 743;
783 -> 781;
783 -> 782;
784 -> 782;
785 -> 783;
785 -> 784;
786 -> 784;
787 -> 786;
788 -> 785;
788 -> 782;
789 -> 783;
789 -> 782;
790 -> 782;
791 -> 790;
792 -> 791;
793 -> 782;
794 -> 793;
795 -> 781;
795 -> 794;
796 -> 795;
796 -> 788;
796 -> 794;
797 -> 795;
797 -> 788;
797 -> 794;
798 -> 797;
798 -> 793;
799 -> 781;
799 -> 782;
800 -> 799;
800 -> 788;
800 -> 782;
801 -> 782;
802 -> 799;
802 -> 788;
802 -> 801;
802 -> 782;
803 -> 802;
804 -> 799;
804 -> 788;
804 -> 802;
805 -> 803;
805 -> 802;
806 -> 802;
807 -> 799;
807 -> 805;
807 -> 782;
808 -> 781;
808 -> 782;
809 -> 781;
809 -> 782;
810 -> 809;
810 -> 807;
810 -> 782;
811 -> 781;
811 -> 782;
812 -> 781;
812 -> 782;
813 -> 782;
814 -> 812;
814 -> 813;
815 -> 814;
815 -> 807;
815 -> 813;
816 -> 814;
816 -> 807;
816 -> 813;
817 -> 816;
817 -> 782;
818 -> 782;
819 -> 818;
819 -> 817;
819 -> 807;
819 -> 782;
820 -> 818;
820 -> 819;
821 -> 817;
821 -> 820;
821 -> 818;
822 -> 811;
822 -> 821;
822 -> 820;
823 -> 781;
823 -> 782;
824 -> 823;
824 -> 822;
824 -> 782;
825 -> 795;
825 -> 824;
825 -> 794;
826 -> 795;
826 -> 824;
826 -> 794;
827 -> 826;
827 -> 793;
828 -> 781;
828 -> 782;
829 -> 781;
829 -> 782;
830 -> 781;
830 -> 782;
831 -> 829;
831 -> 782;
832 -> 828;
832 -> 782;
833 -> 782;
834 -> 830;
834 -> 824;
834 -> 782;
835 -> 782;
836 -> 832;
836 -> 835;
837 -> 833;
837 -> 835;
838 -> 834;
838 -> 835;
839 -> 830;
839 -> 835;
840 -> 838;
840 -> 835;
841 -> 837;
841 -> 835;
842 -> 839;
842 -> 824;
842 -> 841;
843 -> 839;
843 -> 824;
843 -> 842;
843 -> 835;
844 -> 840;
844 -> 843;
844 -> 824;
844 -> 842;
844 -> 835;
845 -> 836;
845 -> 835;
846 -> 835;
847 -> 845;
847 -> 846;
848 -> 839;
848 -> 846;
849 -> 847;
849 -> 846;
850 -> 846;
851 -> 849;
851 -> 850;
852 -> 848;
852 -> 850;
853 -> 850;
854 -> 851;
854 -> 853;
854 -> 850;
855 -> 850;
856 -> 852;
856 -> 844;
856 -> 855;
857 -> 855;
858 -> 856;
858 -> 850;
859 -> 851;
859 -> 850;
860 -> 858;
860 -> 844;
860 -> 859;
860 -> 850;
861 -> 846;
862 -> 848;
862 -> 860;
862 -> 861;
863 -> 861;
864 -> 862;
864 -> 846;
865 -> 844;
865 -> 835;
866 -> 835;
867 -> 865;
867 -> 866;
867 -> 835;
868 -> 867;
869 -> 868;
869 -> 864;
870 -> 869;
870 -> 867;
871 -> 844;
871 -> 867;
872 -> 870;
872 -> 867;
873 -> 867;
874 -> 835;
875 -> 872;
875 -> 864;
875 -> 835;
876 -> 835;
877 -> 875;
877 -> 876;
877 -> 835;
878 -> 836;
878 -> 835;
879 -> 837;
879 -> 835;
880 -> 872;
880 -> 864;
880 -> 835;
881 -> 835;
882 -> 878;
882 -> 881;
883 -> 879;
883 -> 881;
884 -> 880;
884 -> 881;
885 -> 839;
885 -> 881;
886 -> 885;
886 -> 881;
887 -> 882;
887 -> 881;
888 -> 883;
888 -> 881;
889 -> 886;
889 -> 887;
889 -> 888;
889 -> 872;
889 -> 881;
890 -> 881;
891 -> 889;
891 -> 881;
892 -> 881;
893 -> 892;
894 -> 884;
894 -> 892;
895 -> 892;
896 -> 894;
896 -> 895;
896 -> 892;
897 -> 884;
897 -> 892;
898 -> 891;
898 -> 892;
899 -> 894;
899 -> 892;
900 -> 897;
900 -> 898;
900 -> 899;
900 -> 891;
900 -> 892;
901 -> 889;
901 -> 900;
902 -> 781;
902 -> 782;
903 -> 902;
903 -> 901;
903 -> 782;
904 -> 903;
905 -> 904;
905 -> 903;
906 -> 903;
907 -> 905;
907 -> 906;
908 -> 902;
908 -> 906;
909 -> 906;
910 -> 908;
910 -> 909;
911 -> 909;
912 -> 910;
912 -> 911;
913 -> 912;
913 -> 909;
914 -> 910;
914 -> 906;
915 -> 907;
915 -> 914;
915 -> 904;
915 -> 910;
915 -> 906;
916 -> 906;
917 -> 908;
917 -> 916;
918 -> 917;
918 -> 915;
918 -> 916;
919 -> 917;
919 -> 915;
919 -> 916;
920 -> 919;
920 -> 906;
921 -> 906;
922 -> 921;
922 -> 920;
922 -> 915;
922 -> 906;
923 -> 921;
923 -> 922;
924 -> 920;
924 -> 923;
924 -> 921;
925 -> 903;
926 -> 902;
926 -> 903;
927 -> 926;
927 -> 924;
927 -> 903;
928 -> 903;
929 -> 904;
929 -> 927;
929 -> 903;
930 -> 902;
930 -> 929;
930 -> 903;
931 -> 927;
931 -> 903;
932 -> 903;
933 -> 902;
933 -> 930;
933 -> 782;
934 -> 781;
934 -> 782;
935 -> 782;
936 -> 934;
936 -> 935;
937 -> 935;
938 -> 937;
939 -> 936;
939 -> 938;
940 -> 939;
940 -> 933;
940 -> 938;
941 -> 939;
941 -> 933;
941 -> 938;
942 -> 941;
942 -> 937;
943 -> 936;
943 -> 933;
943 -> 937;
944 -> 943;
944 -> 782;
945 -> 782;
946 -> 944;
946 -> 835;
947 -> 946;
947 -> 876;
947 -> 835;
948 -> 874;
948 -> 835;
949 -> 946;
949 -> 948;
949 -> 944;
949 -> 835;
950 -> 949;
951 -> 781;
951 -> 782;
952 -> 781;
952 -> 782;
953 -> 951;
953 -> 782;
954 -> 953;
954 -> 950;
954 -> 782;
955 -> 951;
955 -> 954;
955 -> 782;
956 -> 782;
957 -> 952;
957 -> 956;
958 -> 956;
959 -> 957;
959 -> 958;
960 -> 958;
961 -> 960;
962 -> 959;
962 -> 961;
963 -> 962;
963 -> 954;
963 -> 961;
964 -> 962;
964 -> 954;
964 -> 961;
965 -> 964;
965 -> 960;
966 -> 959;
966 -> 954;
966 -> 960;
967 -> 956;
968 -> 966;
968 -> 782;
969 -> 782;
970 -> 952;
970 -> 969;
971 -> 970;
971 -> 966;
971 -> 969;
972 -> 971;
973 -> 972;
973 -> 971;
974 -> 971;
975 -> 973;
975 -> 974;
975 -> 971;
976 -> 975;
976 -> 971;
977 -> 976;
977 -> 970;
977 -> 971;
978 -> 970;
978 -> 975;
978 -> 977;
978 -> 969;
979 -> 978;
979 -> 782;
980 -> 979;
981 -> 951;
981 -> 980;
981 -> 782;
982 -> 962;
982 -> 980;
982 -> 961;
983 -> 962;
983 -> 980;
983 -> 961;
984 -> 983;
984 -> 960;
985 -> 980;
985 -> 782;
986 -> 809;
986 -> 980;
986 -> 782;
987 -> 799;
987 -> 980;
987 -> 782;
988 -> 744;
988 -> 743;
989 -> 988;
990 -> 989;
990 -> 748;
990 -> 988;
991 -> 988;
992 -> 991;
992 -> 748;
992 -> 988;
993 -> 748;
993 -> 980;
993 -> 990;
993 -> 992;
993 -> 743;
994 -> 743;
995 -> 746;
995 -> 994;
995 -> 743;
996 -> 744;
996 -> 743;
997 -> 745;
997 -> 743;
998 -> 747;
998 -> 743;
999 -> 743;
1000 -> 996;
1000 -> 999;
1001 -> 997;
1001 -> 999;
1002 -> 998;
1002 -> 999;
1003 -> 748;
1003 -> 999;
1004 -> 999;
1005 -> 1000;
1005 -> 1004;
1005 -> 999;
1006 -> 1003;
1006 -> 993;
1006 -> 999;
1007 -> 1006;
1008 -> 1003;
1008 -> 1006;
1009 -> 1007;
1009 -> 1006;
1010 -> 1002;
1010 -> 1006;
1011 -> 1006;
1012 -> 1006;
1013 -> 1008;
1013 -> 1012;
1014 -> 1009;
1014 -> 1012;
1015 -> 1010;
1015 -> 1012;
1016 -> 1011;
1016 -> 1012;
1017 -> 1011;
1017 -> 1012;
1018 -> 1012;
1019 -> 1013;
1019 -> 1012;
1020 -> 1016;
1020 -> 1012;
1021 -> 1017;
1021 -> 1012;
1022 -> 1018;
1022 -> 1012;
1023 -> 1015;
1023 -> 1012;
1024 -> 1012;
1025 -> 1012;
1026 -> 1019;
1026 -> 1025;
1027 -> 1020;
1027 -> 1025;
1028 -> 1021;
1028 -> 1025;
1029 -> 1022;
1029 -> 1025;
1030 -> 1023;
1030 -> 1025;
1031 -> 1024;
1031 -> 1025;
1032 -> 1025;
1033 -> 1032;
1033 -> 1025;
1034 -> 1032;
1034 -> 1025;
1035 -> 1032;
1035 -> 1025;
1036 -> 1032;
1036 -> 1025;
1037 -> 1032;
1037 -> 1025;
1038 -> 1032;
1038 -> 1025;
1039 -> 1026;
1039 -> 1032;
1039 -> 1025;
1040 -> 1027;
1040 -> 1032;
1040 -> 1025;
1041 -> 1028;
1041 -> 1032;
1041 -> 1025;
1042 -> 1029;
1042 -> 1032;
1042 -> 1025;
1043 -> 1030;
1043 -> 1032;
1043 -> 1025;
1044 -> 0;
1044 -> 1025;
1045 -> 1044;
1045 -> 1032;
1045 -> 1025;
1046 -> 1025;
1047 -> 1032;
1047 -> 1046;
1048 -> 1046;
1049 -> 1047;
1049 -> 1032;
1049 -> 1034;
1049 -> 1040;
1049 -> 1048;
1049 -> 1046;
1050 -> 1046;
1051 -> 1047;
1051 -> 1032;
1051 -> 1033;
1051 -> 1039;
1051 -> 1050;
1052 -> 1049;
1052 -> 1051;
1052 -> 1032;
1052 -> 993;
1052 -> 1046;
1053 -> 1052;
1053 -> 1025;
1054 -> 1053;
1055 -> 1054;
1055 -> 1032;
1055 -> 1053;
1056 -> 1012;
1057 -> 1013;
1057 -> 1056;
1058 -> 1056;
1059 -> 1057;
1059 -> 1058;
1060 -> 1059;
1060 -> 1056;
1061 -> 1057;
1061 -> 1012;
1062 -> 1061;
1062 -> 1024;
1062 -> 1057;
1062 -> 1032;
1062 -> 1033;
1062 -> 1039;
1062 -> 1034;
1062 -> 1040;
1062 -> 1035;
1062 -> 1041;
1062 -> 1036;
1062 -> 1042;
1062 -> 1037;
1062 -> 1045;
1062 -> 1038;
1062 -> 1055;
1062 -> 1043;
1062 -> 1011;
1062 -> 1018;
1062 -> 740;
1062 -> 1044;
1062 -> 1054;
1062 -> 1012;
1063 -> 1012;
1064 -> 1062;
1064 -> 1063;
1065 -> 1062;
1065 -> 1063;
1066 -> 1065;
1066 -> 1062;
1066 -> 1063;
1067 -> 1064;
1067 -> 1063;
1068 -> 1064;
1068 -> 1063;
1069 -> 1063;
1070 -> 1068;
1070 -> 1069;
1071 -> 1065;
1071 -> 1069;
1072 -> 1070;
1072 -> 1066;
1072 -> 0;
1072 -> 1069;
1073 -> 1069;
1074 -> 1070;
1074 -> 1066;
1074 -> 0;
1074 -> 1069;
1075 -> 1070;
1075 -> 1066;
1075 -> 0;
1075 -> 1074;
1076 -> 1070;
1076 -> 1066;
1076 -> 0;
1076 -> 1069;
1077 -> 1070;
1077 -> 1066;
1077 -> 0;
1077 -> 1069;
1078 -> 1070;
1078 -> 1066;
1078 -> 0;
1078 -> 1069;
1079 -> 1070;
1079 -> 1066;
1079 -> 0;
1079 -> 1069;
1080 -> 1070;
1080 -> 1066;
1080 -> 0;
1080 -> 1069;
1081 -> 1069;
1082 -> 1070;
1082 -> 1069;
1083 -> 1081;
1083 -> 1069;
1084 -> 1071;
1084 -> 1066;
1084 -> 1082;
1084 -> 1083;
1084 -> 1069;
1085 -> 1069;
1086 -> 1070;
1086 -> 1069;
1087 -> 1085;
1087 -> 1069;
1088 -> 1069;
1089 -> 1086;
1089 -> 1088;
1090 -> 1087;
1090 -> 1088;
1091 -> 1071;
1091 -> 1088;
1092 -> 1088;
1093 -> 1089;
1093 -> 1084;
1093 -> 1088;
1094 -> 1088;
1095 -> 1094;
1095 -> 1069;
1096 -> 1095;
1096 -> 1069;
1097 -> 1070;
1097 -> 1093;
1097 -> 0;
1097 -> 1096;
1098 -> 0;
1098 -> 1097;
1099 -> 1070;
1099 -> 1093;
1099 -> 0;
1099 -> 1069;
1100 -> 1099;
1100 -> 1069;
1101 -> 1098;
1101 -> 1100;
1102 -> 1101;
1102 -> 0;
1102 -> 1063;
1103 -> 1101;
1103 -> 1063;
1104 -> 1063;
1105 -> 1103;
1105 -> 1104;
1106 -> 1105;
1106 -> 1104;
1107 -> 1106;
1108 -> 1063;
1109 -> 1108;
1109 -> 1064;
1109 -> 1101;
1109 -> 1063;
1110 -> 1064;
1110 -> 1101;
1110 -> 1108;
1110 -> 1109;
1111 -> 1109;
1112 -> 1110;
1112 -> 1109;
1113 -> 1111;
1113 -> 1109;
1114 -> 1109;
1115 -> 1112;
1115 -> 1114;
1116 -> 1113;
1116 -> 1114;
1117 -> 1065;
1117 -> 1114;
1118 -> 1114;
1119 -> 1114;
1119 -> 1109;
1120 -> 1109;
1121 -> 1120;
1121 -> 1109;
1122 -> 1118;
1122 -> 1121;
1123 -> 1109;
1124 -> 1122;
1124 -> 1123;
1124 -> 1109;
1125 -> 1124;
1125 -> 1119;
1125 -> 1109;
1126 -> 1119;
1126 -> 1109;
1127 -> 1107;
1127 -> 1126;
1128 -> 1107;
1128 -> 1063;
1129 -> 1063;
1130 -> 1064;
1130 -> 1115;
1130 -> 1129;
1130 -> 1063;
1131 -> 1130;
1131 -> 1063;
1132 -> 1063;
1133 -> 1131;
1133 -> 1132;
1134 -> 1065;
1134 -> 1132;
1135 -> 1133;
1135 -> 1130;
1135 -> 0;
1135 -> 1132;
1136 -> 1132;
1137 -> 1133;
1137 -> 1130;
1137 -> 0;
1137 -> 1132;
1138 -> 1133;
1138 -> 1130;
1138 -> 0;
1138 -> 1137;
1139 -> 1133;
1139 -> 1130;
1139 -> 0;
1139 -> 1132;
1140 -> 1133;
1140 -> 1130;
1140 -> 0;
1140 -> 1132;
1141 -> 1133;
1141 -> 1130;
1141 -> 0;
1141 -> 1132;
1142 -> 1133;
1142 -> 1130;
1142 -> 0;
1142 -> 1132;
1143 -> 1133;
1143 -> 1130;
1143 -> 0;
1143 -> 1132;
1144 -> 1132;
1145 -> 1144;
1145 -> 1132;
1146 -> 1132;
1147 -> 1146;
1147 -> 1132;
1148 -> 1132;
1149 -> 1147;
1149 -> 1148;
1150 -> 1134;
1150 -> 1148;
1151 -> 1148;
1152 -> 1148;
1153 -> 1152;
1153 -> 1132;
1154 -> 1153;
1154 -> 1132;
1155 -> 1133;
1156 -> 1133;
1157 -> 1155;
1157 -> 1156;
1158 -> 1134;
1158 -> 1156;
1159 -> 1157;
1159 -> 1133;
1159 -> 0;
1159 -> 1156;
1160 -> 1157;
1160 -> 1133;
1160 -> 1156;
1161 -> 1156;
1162 -> 1160;
1162 -> 1161;
1162 -> 1156;
1163 -> 1160;
1163 -> 1156;
1164 -> 1156;
1165 -> 1163;
1165 -> 1164;
1166 -> 1158;
1166 -> 1164;
1167 -> 1165;
1167 -> 1133;
1167 -> 0;
1167 -> 1164;
1168 -> 1164;
1169 -> 1165;
1169 -> 1133;
1169 -> 0;
1169 -> 1164;
1170 -> 1165;
1170 -> 1133;
1170 -> 0;
1170 -> 1169;
1171 -> 1165;
1171 -> 1133;
1171 -> 0;
1171 -> 1164;
1172 -> 1165;
1172 -> 1133;
1172 -> 0;
1172 -> 1164;
1173 -> 1165;
1173 -> 1133;
1173 -> 0;
1173 -> 1164;
1174 -> 1165;
1174 -> 1133;
1174 -> 0;
1174 -> 1164;
1175 -> 1165;
1175 -> 1133;
1175 -> 0;
1175 -> 1164;
1176 -> 1166;
1176 -> 1133;
1176 -> 1165;
1176 -> 1164;
1177 -> 1176;
1178 -> 1133;
1179 -> 1177;
1179 -> 1178;
1180 -> 1179;
1180 -> 1178;
1181 -> 1180;
1182 -> 1063;
1183 -> 1181;
1183 -> 1182;
1184 -> 1064;
1184 -> 1176;
1184 -> 1063;
1185 -> 1063;
1186 -> 1184;
1186 -> 1185;
1187 -> 1184;
1187 -> 1185;
1188 -> 1187;
1188 -> 1184;
1188 -> 1185;
1189 -> 1186;
1189 -> 1185;
1190 -> 1185;
1191 -> 1189;
1191 -> 1190;
1192 -> 1187;
1192 -> 1190;
1193 -> 1191;
1193 -> 1188;
1193 -> 0;
1193 -> 1190;
1194 -> 1193;
1195 -> 1186;
1195 -> 1185;
1196 -> 1185;
1197 -> 1195;
1197 -> 1196;
1198 -> 1187;
1198 -> 1196;
1199 -> 1197;
1199 -> 1188;
1199 -> 0;
1199 -> 1196;
1200 -> 1196;
1201 -> 1197;
1201 -> 1188;
1201 -> 0;
1201 -> 1196;
1202 -> 1197;
1202 -> 1188;
1202 -> 1201;
1203 -> 1201;
1204 -> 1202;
1204 -> 1203;
1205 -> 1204;
1205 -> 1188;
1205 -> 0;
1205 -> 1203;
1206 -> 1203;
1207 -> 1204;
1207 -> 1188;
1207 -> 0;
1208 -> 1204;
1208 -> 1188;
1208 -> 0;
1208 -> 1203;
1209 -> 1204;
1209 -> 1188;
1209 -> 0;
1209 -> 1203;
1210 -> 1204;
1210 -> 1188;
1210 -> 0;
1210 -> 1203;
1211 -> 1204;
1211 -> 1188;
1211 -> 0;
1211 -> 1203;
1212 -> 1204;
1212 -> 1188;
1212 -> 0;
1212 -> 1203;
1213 -> 1204;
1214 -> 1185;
1215 -> 1213;
1215 -> 1214;
1216 -> 1215;
1216 -> 1214;
1217 -> 1216;
1218 -> 1185;
1219 -> 1187;
1219 -> 1218;
1220 -> 1218;
1221 -> 1219;
1221 -> 1204;
1221 -> 1220;
1221 -> 1218;
1222 -> 1218;
1223 -> 1219;
1223 -> 1204;
1223 -> 1222;
1224 -> 1221;
1224 -> 1185;
1225 -> 1186;
1225 -> 1224;
1226 -> 1224;
1227 -> 1225;
1227 -> 1226;
1228 -> 1187;
1228 -> 1226;
1229 -> 1227;
1229 -> 1204;
1229 -> 1226;
1230 -> 1229;
1231 -> 1228;
1231 -> 1229;
1232 -> 1224;
1233 -> 1012;
1234 -> 1024;
1234 -> 1233;
1235 -> 1234;
1235 -> 1231;
1235 -> 1233;
1236 -> 1233;
1237 -> 1235;
1237 -> 1236;
1237 -> 1233;
1238 -> 1233;
1239 -> 1235;
1239 -> 1238;
1239 -> 1231;
1239 -> 1233;
1240 -> 1239;
1241 -> 1012;
1242 -> 1018;
1242 -> 1012;
1243 -> 1242;
1243 -> 1240;
1243 -> 1012;
1244 -> 1003;
1244 -> 1240;
1244 -> 1006;
1245 -> 1007;
1245 -> 1006;
1246 -> 1244;
1246 -> 1245;
1246 -> 1240;
1246 -> 1006;
1247 -> 1003;
1247 -> 1246;
1247 -> 999;
1248 -> 1003;
1248 -> 1246;
1248 -> 999;
1249 -> 993;
1249 -> 743;
1250 -> 1249;
1250 -> 1246;
1250 -> 743;
1251 -> 1248;
1251 -> 743;
1252 -> 706;
1253 -> 671;
1253 -> 1251;
1253 -> 1252;
1253 -> 706;
1254 -> 670;
1254 -> 1251;
1254 -> 666;
1255 -> 667;
1255 -> 0;
1255 -> 666;
1256 -> 1255;
1257 -> 1256;
1257 -> 1255;
1258 -> 670;
1258 -> 1255;
1259 -> 1255;
1260 -> 1257;
1260 -> 1259;
1261 -> 1258;
1261 -> 1259;
1262 -> 671;
1262 -> 1259;
1263 -> 1262;
1263 -> 1259;
1264 -> 1259;
1265 -> 1260;
1265 -> 1259;
1266 -> 1261;
1266 -> 1259;
1267 -> 1259;
1268 -> 1263;
1268 -> 1267;
1269 -> 1264;
1269 -> 1267;
1270 -> 1264;
1270 -> 1267;
1271 -> 1264;
1271 -> 1267;
1272 -> 1264;
1272 -> 1267;
1273 -> 1265;
1273 -> 1267;
1274 -> 1264;
1274 -> 1267;
1275 -> 1266;
1275 -> 1267;
1276 -> 1267;
1277 -> 1268;
1277 -> 1276;
1277 -> 1267;
1278 -> 1267;
1279 -> 1273;
1279 -> 1278;
1279 -> 1267;
1280 -> 1267;
1281 -> 1268;
1281 -> 1280;
1282 -> 1281;
1282 -> 1254;
1282 -> 1280;
1283 -> 1282;
1283 -> 1267;
1284 -> 1267;
1285 -> 1267;
1286 -> 1274;
1286 -> 1267;
1287 -> 1268;
1287 -> 1286;
1288 -> 1269;
1288 -> 1286;
1289 -> 1272;
1289 -> 1286;
1290 -> 1273;
1290 -> 1286;
1291 -> 1275;
1291 -> 1286;
1292 -> 1286;
1293 -> 1287;
1293 -> 1292;
1294 -> 1288;
1294 -> 1292;
1295 -> 1289;
1295 -> 1292;
1296 -> 1290;
1296 -> 1292;
1297 -> 1291;
1297 -> 1292;
1298 -> 1297;
1298 -> 1292;
1299 -> 1292;
1300 -> 1298;
1300 -> 1299;
1301 -> 1293;
1301 -> 1299;
1302 -> 1299;
1303 -> 1301;
1303 -> 1254;
1303 -> 1302;
1303 -> 1299;
1304 -> 1303;
1305 -> 1301;
1305 -> 1303;
1306 -> 1303;
1307 -> 1306;
1308 -> 1307;
1308 -> 1306;
1309 -> 1303;
1310 -> 1309;
1310 -> 1305;
1311 -> 1310;
1311 -> 1303;
1312 -> 1303;
1313 -> 1301;
1313 -> 1312;
1314 -> 1313;
1314 -> 1305;
1314 -> 1312;
1315 -> 1312;
1316 -> 1314;
1316 -> 1315;
1317 -> 1316;
1317 -> 1314;
1317 -> 1315;
1318 -> 1315;
1319 -> 1317;
1319 -> 1318;
1320 -> 1318;
1321 -> 1319;
1321 -> 1320;
1322 -> 1320;
1323 -> 1321;
1323 -> 1322;
1324 -> 1323;
1324 -> 1320;
1325 -> 1321;
1325 -> 1318;
1326 -> 1317;
1326 -> 1318;
1327 -> 1318;
1328 -> 1326;
1328 -> 1327;
1329 -> 1328;
1329 -> 1325;
1329 -> 1327;
1330 -> 1329;
1330 -> 1318;
1331 -> 1330;
1331 -> 1303;
1332 -> 1311;
1332 -> 1331;
1332 -> 1303;
1333 -> 1305;
1333 -> 1332;
1335 -> 0;
1337 -> 1334;
1337 -> 1336;
1338 -> 1335;
1338 -> 1336;
1339 -> 1336;
1340 -> 1339;
1340 -> 1336;
1341 -> 1337;
1341 -> 1339;
1341 -> 1336;
1342 -> 1338;
1342 -> 1339;
1342 -> 1336;
1343 -> 1336;
1344 -> 1343;
1344 -> 1333;
1345 -> 1301;
1345 -> 1330;
1345 -> 1303;
1346 -> 1344;
1346 -> 1303;
1347 -> 1303;
1348 -> 1345;
1348 -> 1346;
1348 -> 1347;
1348 -> 1341;
1348 -> 1342;
1348 -> 1330;
1348 -> 0;
1348 -> 1303;
1349 -> 1301;
1349 -> 1348;
1349 -> 1299;
1350 -> 1349;
1350 -> 1292;
1351 -> 1350;
1351 -> 1348;
1351 -> 1292;
1352 -> 1350;
1352 -> 1348;
1352 -> 1292;
1353 -> 1296;
1353 -> 1352;
1353 -> 1256;
1353 -> 1348;
1353 -> 1292;
1354 -> 1350;
1354 -> 1353;
1354 -> 1292;
1355 -> 1292;
1356 -> 1354;
1356 -> 1355;
1356 -> 1292;
1357 -> 1356;
1358 -> 1268;
1358 -> 1267;
1359 -> 1269;
1359 -> 1267;
1360 -> 1270;
1360 -> 1267;
1361 -> 1271;
1361 -> 1267;
1362 -> 1272;
1362 -> 1267;
1363 -> 1273;
1363 -> 1267;
1364 -> 1274;
1364 -> 1267;
1365 -> 1357;
1365 -> 1267;
1366 -> 1275;
1366 -> 1267;
1367 -> 1267;
1368 -> 1267;
1369 -> 1358;
1369 -> 1368;
1370 -> 1359;
1370 -> 1368;
1371 -> 1360;
1371 -> 1368;
1372 -> 1361;
1372 -> 1368;
1373 -> 1362;
1373 -> 1368;
1374 -> 1363;
1374 -> 1368;
1375 -> 1364;
1375 -> 1368;
1376 -> 1365;
1376 -> 1368;
1377 -> 1366;
1377 -> 1368;
1378 -> 1367;
1378 -> 1368;
1379 -> 1368;
1380 -> 1379;
1380 -> 1368;
1381 -> 1379;
1381 -> 1368;
1382 -> 1379;
1382 -> 1368;
1383 -> 1379;
1383 -> 1368;
1384 -> 1379;
1384 -> 1368;
1385 -> 1379;
1385 -> 1368;
1386 -> 1379;
1386 -> 1368;
1387 -> 1379;
1387 -> 1368;
1388 -> 1379;
1388 -> 1368;
1389 -> 1379;
1389 -> 1368;
1390 -> 1379;
1390 -> 1368;
1391 -> 1368;
1392 -> 1369;
1392 -> 1391;
1392 -> 1368;
1393 -> 1368;
1394 -> 1374;
1394 -> 1393;
1394 -> 1368;
1395 -> 1369;
1395 -> 1379;
1395 -> 1368;
1396 -> 1370;
1396 -> 1379;
1396 -> 1368;
1397 -> 1371;
1397 -> 1379;
1397 -> 1368;
1398 -> 1377;
1398 -> 1379;
1398 -> 1368;
1399 -> 1374;
1399 -> 1379;
1399 -> 1368;
1400 -> 1375;
1400 -> 1379;
1400 -> 1368;
1401 -> 1376;
1401 -> 1379;
1401 -> 1368;
1402 -> 1373;
1402 -> 1379;
1402 -> 1368;
1403 -> 1373;
1403 -> 1368;
1404 -> 1368;
1405 -> 1403;
1405 -> 1404;
1406 -> 1379;
1406 -> 1404;
1407 -> 1405;
1407 -> 1404;
1408 -> 1368;
1409 -> 1371;
1409 -> 1372;
1409 -> 1368;
1410 -> 1372;
1410 -> 1379;
1410 -> 1368;
1411 -> 1267;
1412 -> 1268;
1412 -> 1411;
1413 -> 1412;
1413 -> 1353;
1413 -> 1411;
1414 -> 1413;
1414 -> 1267;
1415 -> 1414;
1416 -> 1415;
1416 -> 1367;
1416 -> 1414;
1417 -> 1267;
1418 -> 1268;
1418 -> 1417;
1419 -> 1417;
1420 -> 1418;
1420 -> 1419;
1421 -> 1419;
1422 -> 1420;
1422 -> 1421;
1423 -> 1421;
1424 -> 1422;
1424 -> 1423;
1425 -> 1424;
1425 -> 1353;
1425 -> 1423;
1426 -> 1424;
1426 -> 1353;
1426 -> 1423;
1427 -> 1426;
1427 -> 1421;
1428 -> 1422;
1428 -> 1353;
1428 -> 1421;
1429 -> 1417;
1430 -> 1428;
1430 -> 1267;
1431 -> 1267;
1432 -> 1430;
1432 -> 1431;
1433 -> 1367;
1433 -> 1431;
1434 -> 1432;
1434 -> 1428;
1434 -> 1431;
1435 -> 1433;
1435 -> 1434;
1436 -> 1434;
1437 -> 1435;
1437 -> 1436;
1437 -> 1434;
1437 -> 1379;
1437 -> 1380;
1437 -> 1395;
1437 -> 1381;
1437 -> 1397;
1437 -> 1382;
1437 -> 1410;
1437 -> 1383;
1437 -> 1399;
1437 -> 1384;
1437 -> 1402;
1437 -> 1385;
1437 -> 1396;
1437 -> 1386;
1437 -> 1400;
1437 -> 1387;
1437 -> 1388;
1437 -> 1401;
1437 -> 1389;
1437 -> 1416;
1437 -> 1390;
1437 -> 1398;
1437 -> 1254;
1437 -> 1415;
1438 -> 1437;
1438 -> 1436;
1439 -> 1437;
1439 -> 1436;
1440 -> 1437;
1440 -> 1436;
1441 -> 1440;
1441 -> 1437;
1441 -> 1436;
1442 -> 1438;
1442 -> 1436;
1443 -> 1436;
1444 -> 1441;
1444 -> 1443;
1445 -> 1442;
1445 -> 1443;
1446 -> 1443;
1447 -> 1444;
1447 -> 1446;
1447 -> 1443;
1448 -> 1436;
1449 -> 1440;
1449 -> 1437;
1449 -> 1436;
1450 -> 1436;
1451 -> 1440;
1451 -> 1449;
1451 -> 1450;
1452 -> 1451;
1452 -> 1436;
1453 -> 1438;
1453 -> 1452;
1454 -> 1452;
1455 -> 1453;
1455 -> 1454;
1456 -> 1440;
1456 -> 1454;
1457 -> 1454;
1458 -> 1456;
1458 -> 1449;
1458 -> 1454;
1459 -> 1458;
1459 -> 1452;
1460 -> 1459;
1460 -> 1452;
1461 -> 1436;
1462 -> 1437;
1462 -> 1461;
1462 -> 1460;
1462 -> 1434;
1463 -> 1267;
1464 -> 1267;
1465 -> 1367;
1465 -> 1464;
1466 -> 1465;
1466 -> 1462;
1466 -> 1464;
1467 -> 1464;
1468 -> 1466;
1468 -> 1467;
1468 -> 1464;
1469 -> 1464;
1470 -> 1469;
1470 -> 1464;
1471 -> 1466;
1471 -> 1470;
1471 -> 1462;
1471 -> 1464;
1472 -> 1471;
1473 -> 1267;
1474 -> 1267;
1475 -> 1269;
1475 -> 1474;
1475 -> 1267;
1476 -> 1267;
1477 -> 1269;
1477 -> 1476;
1477 -> 1267;
1478 -> 1267;
1479 -> 1268;
1479 -> 1478;
1480 -> 1479;
1480 -> 1472;
1480 -> 1478;
1481 -> 1480;
1481 -> 1267;
1482 -> 1267;
1483 -> 1274;
1483 -> 1482;
1483 -> 1267;
1484 -> 1268;
1484 -> 1483;
1485 -> 1273;
1485 -> 1483;
1486 -> 1275;
1486 -> 1483;
1487 -> 1483;
1488 -> 1484;
1488 -> 1487;
1489 -> 1485;
1489 -> 1487;
1490 -> 1486;
1490 -> 1487;
1491 -> 1487;
1492 -> 1488;
1492 -> 1491;
1493 -> 1491;
1494 -> 1492;
1494 -> 1493;
1495 -> 1493;
1496 -> 1494;
1496 -> 1495;
1497 -> 1496;
1497 -> 1481;
1497 -> 1495;
1498 -> 1496;
1498 -> 1481;
1498 -> 1495;
1499 -> 1498;
1499 -> 1493;
1500 -> 1494;
1500 -> 1481;
1500 -> 1493;
1501 -> 1500;
1501 -> 1487;
1502 -> 1490;
1502 -> 1487;
1503 -> 1502;
1503 -> 1501;
1503 -> 1254;
1503 -> 1500;
1503 -> 1487;
1504 -> 1487;
1505 -> 1489;
1505 -> 1503;
1505 -> 1487;
1506 -> 1483;
1507 -> 1483;
1508 -> 1269;
1508 -> 1507;
1508 -> 1483;
1513 -> 1510;
1513 -> 1509;
1514 -> 1511;
1514 -> 1509;
1515 -> 1512;
1515 -> 1509;
1516 -> 1509;
1517 -> 1262;
1517 -> 1259;
1518 -> 1259;
1519 -> 1260;
1519 -> 1259;
1520 -> 1261;
1520 -> 1259;
1521 -> 1259;
1522 -> 1517;
1522 -> 1521;
1523 -> 1518;
1523 -> 1521;
1524 -> 1518;
1524 -> 1521;
1525 -> 1519;
1525 -> 1521;
1526 -> 1520;
1526 -> 1521;
1527 -> 1518;
1527 -> 1521;
1528 -> 1518;
1528 -> 1521;
1529 -> 1521;
1530 -> 1521;
1531 -> 1524;
1531 -> 1530;
1531 -> 1521;
1532 -> 1521;
1533 -> 1522;
1533 -> 1532;
1534 -> 1532;
1535 -> 1533;
1535 -> 1534;
1536 -> 1535;
1536 -> 1505;
1536 -> 1534;
1537 -> 1535;
1537 -> 1505;
1537 -> 1534;
1538 -> 1537;
1538 -> 1532;
1539 -> 1533;
1539 -> 1505;
1539 -> 1532;
1540 -> 1539;
1540 -> 1521;
1541 -> 1540;
1541 -> 1523;
1541 -> 1521;
1542 -> 1522;
1542 -> 1521;
1543 -> 1529;
1543 -> 1521;
1544 -> 1527;
1544 -> 1521;
1545 -> 1528;
1545 -> 1521;
1546 -> 1521;
1547 -> 1525;
1547 -> 1521;
1548 -> 1526;
1548 -> 1521;
1549 -> 1521;
1550 -> 1541;
1550 -> 1549;
1551 -> 1542;
1551 -> 1549;
1552 -> 1543;
1552 -> 1549;
1553 -> 1544;
1553 -> 1549;
1554 -> 1545;
1554 -> 1549;
1555 -> 1546;
1555 -> 1549;
1556 -> 1546;
1556 -> 1549;
1557 -> 1547;
1557 -> 1549;
1558 -> 1548;
1558 -> 1549;
1559 -> 1546;
1559 -> 1549;
1560 -> 1549;
1561 -> 1560;
1561 -> 1549;
1562 -> 1560;
1562 -> 1549;
1563 -> 1560;
1563 -> 1549;
1564 -> 1560;
1564 -> 1549;
1565 -> 1560;
1565 -> 1549;
1566 -> 1560;
1566 -> 1549;
1567 -> 1560;
1567 -> 1549;
1568 -> 1560;
1568 -> 1549;
1569 -> 1560;
1569 -> 1549;
1570 -> 1560;
1570 -> 1549;
1571 -> 1560;
1571 -> 1549;
1572 -> 1560;
1572 -> 1549;
1573 -> 1550;
1573 -> 1560;
1573 -> 1549;
1574 -> 1551;
1574 -> 1560;
1574 -> 1549;
1575 -> 1552;
1575 -> 1560;
1575 -> 1549;
1576 -> 1553;
1576 -> 1560;
1576 -> 1549;
1577 -> 1554;
1577 -> 1560;
1577 -> 1549;
1578 -> 1555;
1578 -> 1560;
1578 -> 1549;
1579 -> 1556;
1579 -> 1560;
1579 -> 1549;
1580 -> 1557;
1580 -> 1560;
1580 -> 1549;
1581 -> 1558;
1581 -> 1560;
1581 -> 1549;
1582 -> 1521;
1583 -> 1522;
1583 -> 1582;
1584 -> 1582;
1585 -> 1583;
1585 -> 1584;
1586 -> 1585;
1586 -> 1539;
1586 -> 1584;
1587 -> 1585;
1587 -> 1539;
1587 -> 1584;
1588 -> 1587;
1588 -> 1582;
1589 -> 1583;
1589 -> 1539;
1589 -> 1582;
1590 -> 1589;
1590 -> 1521;
1591 -> 1590;
1591 -> 1546;
1591 -> 1589;
1591 -> 1560;
1591 -> 1561;
1591 -> 1573;
1591 -> 1562;
1591 -> 1574;
1591 -> 1563;
1591 -> 1575;
1591 -> 1564;
1591 -> 1576;
1591 -> 1565;
1591 -> 1577;
1591 -> 1566;
1591 -> 1578;
1591 -> 1567;
1591 -> 1579;
1591 -> 1568;
1591 -> 1580;
1591 -> 1569;
1591 -> 1570;
1591 -> 1571;
1591 -> 1572;
1591 -> 1581;
1591 -> 1518;
1591 -> 1254;
1591 -> 1521;
1592 -> 1521;
1593 -> 1591;
1593 -> 1592;
1594 -> 1591;
1594 -> 1592;
1595 -> 1594;
1595 -> 1591;
1595 -> 1592;
1596 -> 1593;
1596 -> 1595;
1596 -> 1592;
1597 -> 1596;
1598 -> 1596;
1599 -> 1596;
1600 -> 1598;
1600 -> 1599;
1601 -> 1594;
1601 -> 1599;
1602 -> 1601;
1602 -> 1595;
1602 -> 1599;
1603 -> 1599;
1604 -> 1602;
1605 -> 1596;
1606 -> 1596;
1607 -> 1605;
1607 -> 1606;
1608 -> 1594;
1608 -> 1606;
1609 -> 1608;
1609 -> 1595;
1609 -> 1606;
1610 -> 1606;
1611 -> 1609;
1612 -> 1596;
1613 -> 1594;
1613 -> 1612;
1614 -> 1613;
1614 -> 1595;
1614 -> 1612;
1615 -> 1596;
1616 -> 1596;
1617 -> 1616;
1617 -> 1596;
1618 -> 1617;
1619 -> 1617;
1620 -> 1618;
1620 -> 1619;
1621 -> 1594;
1621 -> 1619;
1622 -> 1621;
1622 -> 1595;
1622 -> 1619;
1623 -> 1619;
1624 -> 1622;
1625 -> 1617;
1626 -> 1594;
1626 -> 1625;
1627 -> 1626;
1627 -> 1595;
1627 -> 1614;
1627 -> 1625;
1628 -> 1617;
1629 -> 1617;
1630 -> 1594;
1630 -> 1595;
1630 -> 1629;
1630 -> 1617;
1631 -> 1617;
1632 -> 1629;
1632 -> 1631;
1633 -> 1629;
1633 -> 1631;
1634 -> 1594;
1634 -> 1631;
1635 -> 1632;
1635 -> 1631;
1636 -> 1633;
1636 -> 1631;
1637 -> 1635;
1637 -> 1636;
1637 -> 1631;
1638 -> 1631;
1639 -> 1637;
1639 -> 1638;
1640 -> 1634;
1640 -> 1638;
1641 -> 1640;
1641 -> 1595;
1641 -> 1638;
1642 -> 1638;
1643 -> 1641;
1644 -> 1631;
1645 -> 1617;
1646 -> 1594;
1646 -> 1645;
1647 -> 1646;
1647 -> 1595;
1647 -> 1614;
1647 -> 1627;
1647 -> 1645;
1648 -> 1645;
1649 -> 1646;
1649 -> 1595;
1649 -> 1614;
1649 -> 1627;
1649 -> 1647;
1649 -> 1648;
1649 -> 1645;
1650 -> 1617;
1651 -> 1617;
1652 -> 1617;
1653 -> 1651;
1653 -> 1652;
1654 -> 1594;
1654 -> 1652;
1655 -> 1654;
1655 -> 1595;
1655 -> 1652;
1656 -> 1652;
1657 -> 1655;
1658 -> 1596;
1659 -> 1596;
1660 -> 1658;
1660 -> 1659;
1661 -> 1594;
1661 -> 1659;
1662 -> 1661;
1662 -> 1595;
1662 -> 1659;
1663 -> 1659;
1664 -> 1662;
1665 -> 1596;
1666 -> 1594;
1666 -> 1665;
1667 -> 1666;
1667 -> 1595;
1667 -> 1614;
1667 -> 1627;
1667 -> 1647;
1667 -> 1665;
1668 -> 1596;
1669 -> 1594;
1669 -> 1595;
1669 -> 1592;
1670 -> 1593;
1670 -> 1595;
1670 -> 1614;
1670 -> 1627;
1670 -> 1647;
1670 -> 1667;
1670 -> 1592;
1671 -> 1594;
1671 -> 1595;
1671 -> 1614;
1671 -> 1627;
1671 -> 1647;
1671 -> 1667;
1671 -> 1670;
1672 -> 1594;
1672 -> 1670;
1673 -> 1672;
1673 -> 1670;
1673 -> 1671;
1673 -> 1595;
1673 -> 1614;
1673 -> 1627;
1673 -> 1647;
1673 -> 1667;
1674 -> 1670;
1675 -> 1673;
1675 -> 1674;
1676 -> 1673;
1676 -> 1674;
1677 -> 1676;
1677 -> 1673;
1677 -> 1674;
1678 -> 1674;
1679 -> 1676;
1679 -> 1677;
1679 -> 1678;
1679 -> 1674;
1680 -> 1675;
1680 -> 1674;
1681 -> 1674;
1682 -> 1680;
1682 -> 1681;
1683 -> 1676;
1683 -> 1681;
1684 -> 1683;
1684 -> 1677;
1684 -> 1681;
1685 -> 1682;
1685 -> 1681;
1686 -> 1681;
1687 -> 1685;
1687 -> 1686;
1688 -> 1687;
1688 -> 1686;
1689 -> 1688;
1689 -> 1684;
1689 -> 1686;
1690 -> 1681;
1691 -> 1683;
1691 -> 1689;
1691 -> 1690;
1691 -> 1681;
1692 -> 1682;
1692 -> 1681;
1693 -> 1692;
1693 -> 1689;
1693 -> 1681;
1694 -> 1693;
1694 -> 1681;
1695 -> 1681;
1696 -> 1681;
1697 -> 1696;
1697 -> 1681;
1698 -> 1682;
1698 -> 1681;
1699 -> 1695;
1699 -> 1681;
1700 -> 1696;
1700 -> 1681;
1701 -> 1681;
1702 -> 1698;
1702 -> 1701;
1703 -> 1699;
1703 -> 1701;
1704 -> 1700;
1704 -> 1701;
1705 -> 1683;
1705 -> 1701;
1706 -> 0;
1706 -> 1701;
1707 -> 1701;
1708 -> 1701;
1709 -> 1702;
1709 -> 1693;
1709 -> 1701;
1710 -> 1709;
1710 -> 1693;
1711 -> 1710;
1711 -> 1706;
1711 -> 1709;
1712 -> 1711;
1712 -> 1709;
1713 -> 1709;
1714 -> 1705;
1714 -> 1713;
1714 -> 1709;
1715 -> 1714;
1715 -> 1709;
1716 -> 1701;
1717 -> 1708;
1717 -> 1716;
1717 -> 1701;
1718 -> 0;
1718 -> 1717;
1719 -> 1701;
1720 -> 1719;
1720 -> 1681;
1721 -> 1718;
1721 -> 0;
1721 -> 1681;
1722 -> 1712;
1722 -> 0;
1722 -> 1721;
1723 -> 1721;
1724 -> 1674;
1725 -> 1676;
1725 -> 1714;
1725 -> 1674;
1726 -> 1675;
1726 -> 1714;
1726 -> 1725;
1727 -> 1593;
1727 -> 1726;
1727 -> 1592;
1728 -> 1727;
1729 -> 1728;
1730 -> 1727;
1731 -> 1727;
1732 -> 1727;
1733 -> 1731;
1733 -> 1732;
1734 -> 1594;
1734 -> 1732;
1735 -> 1734;
1735 -> 1726;
1735 -> 1732;
1736 -> 1732;
1737 -> 1735;
1738 -> 1727;
1739 -> 1738;
1739 -> 1726;
1739 -> 1728;
1740 -> 1738;
1741 -> 1738;
1741 -> 1726;
1741 -> 1728;
1741 -> 1739;
1741 -> 1740;
1742 -> 1727;
1743 -> 1727;
1744 -> 1727;
1745 -> 1743;
1745 -> 1744;
1746 -> 1594;
1746 -> 1744;
1747 -> 1746;
1747 -> 1726;
1747 -> 1744;
1748 -> 1744;
1749 -> 1747;
1750 -> 1521;
1751 -> 1546;
1751 -> 1739;
1751 -> 1750;
1751 -> 1521;
1752 -> 1529;
1752 -> 1521;
1753 -> 1521;
1754 -> 1527;
1754 -> 1753;
1754 -> 1521;
1755 -> 1754;
1756 -> 1522;
1756 -> 1755;
1757 -> 1755;
1758 -> 1756;
1758 -> 1739;
1758 -> 1757;
1759 -> 1757;
1760 -> 1758;
1760 -> 1754;
1761 -> 1760;
1762 -> 1525;
1762 -> 1760;
1763 -> 1526;
1763 -> 1760;
1764 -> 1760;
1765 -> 1761;
1765 -> 1764;
1766 -> 1761;
1766 -> 1764;
1767 -> 1762;
1767 -> 1764;
1768 -> 1763;
1768 -> 1764;
1769 -> 1765;
1769 -> 1764;
1770 -> 1259;
1771 -> 1260;
1771 -> 1259;
1772 -> 1261;
1772 -> 1259;
1773 -> 1259;
1774 -> 1770;
1774 -> 1773;
1775 -> 1771;
1775 -> 1773;
1776 -> 1772;
1776 -> 1773;
1777 -> 1262;
1777 -> 1773;
1778 -> 1773;
1779 -> 1777;
1779 -> 1769;
1779 -> 1778;
1779 -> 1773;
1780 -> 1774;
1780 -> 1773;
1781 -> 1773;
1782 -> 1780;
1782 -> 1781;
1783 -> 1777;
1783 -> 1781;
1784 -> 1781;
1785 -> 1783;
1785 -> 1769;
1785 -> 1784;
1785 -> 1781;
1786 -> 1773;
1787 -> 1255;
1788 -> 1256;
1788 -> 1255;
1789 -> 672;
1789 -> 1788;
1789 -> 1769;
1789 -> 1255;
1790 -> 669;
1790 -> 666;
1791 -> 672;
1791 -> 666;
1792 -> 670;
1792 -> 666;
1793 -> 1790;
1793 -> 1791;
1793 -> 1792;
1793 -> 671;
1793 -> 661;
1793 -> 1789;
1793 -> 666;
1794 -> 666;
1795 -> 656;
1796 -> 661;
1796 -> 1793;
1796 -> 656;
1797 -> 1796;
1797 -> 646;
1798 -> 648;
1798 -> 646;
1799 -> 646;
1800 -> 1797;
1800 -> 1799;
1801 -> 1798;
1801 -> 1799;
1802 -> 1800;
1802 -> 1799;
1803 -> 1801;
1803 -> 1799;
1804 -> 1799;
1805 -> 1802;
1805 -> 1804;
1806 -> 1803;
1806 -> 1804;
1807 -> 1805;
1807 -> 1804;
1808 -> 1806;
1808 -> 1804;
1809 -> 1804;
1810 -> 1804;
1811 -> 1807;
1811 -> 1810;
1812 -> 1808;
1812 -> 1810;
1813 -> 1809;
1813 -> 1810;
1814 -> 1810;
1815 -> 1812;
1815 -> 1814;
1815 -> 1810;
1816 -> 1812;
1816 -> 1810;
1817 -> 1812;
1817 -> 1810;
1818 -> 1811;
1818 -> 1810;
1819 -> 1813;
1819 -> 1816;
1819 -> 1817;
1819 -> 1810;
1820 -> 1818;
1820 -> 1819;
1820 -> 1810;
1821 -> 1812;
1821 -> 1810;
1822 -> 1810;
1823 -> 1820;
1823 -> 1822;
1823 -> 1810;
1824 -> 1810;
1826 -> 1825;
1828 -> 1827;
1829 -> 1812;
1829 -> 1810;
1830 -> 1811;
1830 -> 1810;
1831 -> 1810;
1832 -> 1829;
1832 -> 1831;
1833 -> 1830;
1833 -> 1831;
1834 -> 1831;
1835 -> 1831;
1836 -> 1833;
1836 -> 1831;
1837 -> 1836;
1837 -> 1820;
1837 -> 1831;
1838 -> 1837;
1838 -> 1831;
1839 -> 1835;
1839 -> 1838;
1840 -> 1839;
1840 -> 1834;
1840 -> 1831;
1841 -> 1839;
1841 -> 1834;
1841 -> 1831;
1842 -> 1841;
1842 -> 1831;
1843 -> 1832;
1843 -> 1831;
1844 -> 1832;
1844 -> 1831;
1845 -> 1832;
1845 -> 1831;
1846 -> 1831;
1847 -> 1845;
1847 -> 1846;
1849 -> 1848;
1850 -> 1848;
1851 -> 1850;
1851 -> 1846;
1852 -> 1846;
1853 -> 1847;
1853 -> 1846;
1854 -> 1846;
1855 -> 1854;
1855 -> 1831;
1856 -> 1833;
1856 -> 1855;
1857 -> 1855;
1858 -> 1856;
1858 -> 1857;
1859 -> 1858;
1859 -> 1857;
1860 -> 1857;
1861 -> 1850;
1861 -> 1857;
1862 -> 1859;
1862 -> 1860;
1862 -> 1861;
1862 -> 1820;
1862 -> 1857;
1863 -> 1831;
1864 -> 1863;
1864 -> 1831;
1865 -> 1831;
1866 -> 1831;
1867 -> 1863;
1867 -> 1866;
1867 -> 1864;
1867 -> 1831;
1868 -> 1831;
1869 -> 1832;
1869 -> 1831;
1870 -> 1863;
1870 -> 1831;
1871 -> 1868;
1871 -> 1831;
1872 -> 1831;
1873 -> 1870;
1873 -> 1872;
1874 -> 1871;
1874 -> 1872;
1875 -> 1874;
1875 -> 1868;
1875 -> 1872;
1876 -> 1872;
1877 -> 1876;
1877 -> 1875;
1877 -> 1872;
1878 -> 1831;
1879 -> 1831;
1880 -> 1863;
1880 -> 1879;
1880 -> 1867;
1880 -> 1831;
1881 -> 1831;
1882 -> 1862;
1882 -> 1831;
1883 -> 1831;
1884 -> 1882;
1884 -> 1831;
1885 -> 1831;
1886 -> 1883;
1886 -> 1885;
1886 -> 1831;
1887 -> 1831;
1888 -> 1863;
1888 -> 1887;
1888 -> 1880;
1888 -> 1831;
1889 -> 1868;
1889 -> 1831;
1890 -> 1881;
1890 -> 1831;
1894 -> 1892;
1894 -> 1891;
1895 -> 1893;
1895 -> 1891;
1896 -> 1891;
1897 -> 0;
1897 -> 1831;
1898 -> 1831;
1899 -> 1831;
1900 -> 1889;
1900 -> 1899;
1901 -> 1890;
1901 -> 1899;
1902 -> 1897;
1902 -> 1899;
1903 -> 1898;
1903 -> 1899;
1904 -> 1898;
1904 -> 1899;
1905 -> 1899;
1906 -> 1903;
1906 -> 1905;
1906 -> 1899;
1907 -> 1906;
1907 -> 1899;
1908 -> 0;
1910 -> 1908;
1910 -> 1909;
1911 -> 1909;
1913 -> 1912;
1915 -> 1914;
1917 -> 1916;
1918 -> 1911;
1919 -> 1911;
1919 -> 1909;
1920 -> 1910;
1920 -> 1911;
1920 -> 1909;
1921 -> 1909;
1922 -> 1899;
1923 -> 1922;
1923 -> 1904;
1923 -> 1899;
1924 -> 1900;
1924 -> 1899;
1925 -> 1901;
1925 -> 1899;
1926 -> 1902;
1926 -> 1899;
1927 -> 1924;
1927 -> 1899;
1928 -> 1925;
1928 -> 1899;
1929 -> 1923;
1929 -> 1899;
1930 -> 1899;
1931 -> 1927;
1931 -> 1930;
1932 -> 1928;
1932 -> 1930;
1933 -> 1929;
1933 -> 1930;
1934 -> 1907;
1934 -> 1930;
1935 -> 1931;
1935 -> 1930;
1936 -> 1931;
1936 -> 1924;
1936 -> 1930;
1937 -> 1932;
1937 -> 1930;
1938 -> 1932;
1938 -> 1925;
1938 -> 1930;
1939 -> 1930;
1940 -> 1935;
1940 -> 1939;
1941 -> 1936;
1941 -> 1939;
1942 -> 1937;
1942 -> 1939;
1943 -> 1938;
1943 -> 1939;
1944 -> 1934;
1944 -> 1939;
1945 -> 1940;
1945 -> 1939;
1946 -> 1941;
1946 -> 1939;
1947 -> 1942;
1947 -> 1939;
1948 -> 1943;
1948 -> 1939;
1949 -> 1939;
1950 -> 1945;
1950 -> 1949;
1951 -> 1946;
1951 -> 1949;
1952 -> 1947;
1952 -> 1949;
1953 -> 1948;
1953 -> 1949;
1954 -> 1944;
1954 -> 1949;
1955 -> 1949;
1956 -> 1951;
1956 -> 1955;
1956 -> 1949;
1957 -> 1949;
1958 -> 1953;
1958 -> 1957;
1958 -> 1949;
1959 -> 1956;
1959 -> 1958;
1959 -> 1949;
1960 -> 1949;
1961 -> 1960;
1961 -> 1959;
1961 -> 1949;
1962 -> 1949;
1963 -> 1962;
1963 -> 1951;
1963 -> 1949;
1964 -> 1949;
1965 -> 1964;
1965 -> 1953;
1965 -> 1949;
1966 -> 1949;
1967 -> 1966;
1967 -> 1951;
1967 -> 1949;
1968 -> 1959;
1968 -> 1949;
1969 -> 1941;
1969 -> 1939;
1970 -> 1943;
1970 -> 1939;
1971 -> 1939;
1972 -> 1969;
1972 -> 1971;
1972 -> 1939;
1973 -> 1939;
1974 -> 1969;
1974 -> 1973;
1974 -> 1939;
1975 -> 1939;
1976 -> 1970;
1976 -> 1975;
1976 -> 1939;
1977 -> 1939;
1978 -> 1977;
1978 -> 1930;
1979 -> 1930;
1980 -> 1979;
1980 -> 1899;
1981 -> 1926;
1981 -> 1980;
1981 -> 1899;
1982 -> 1863;
1982 -> 1981;
1982 -> 1888;
1982 -> 1831;
1983 -> 1881;
1983 -> 1831;
1984 -> 1868;
1984 -> 1831;
1985 -> 1863;
1985 -> 1982;
1985 -> 1831;
1986 -> 1985;
1986 -> 1810;
1987 -> 1799;
1988 -> 646;
1989 -> 647;
1989 -> 646;
1990 -> 1796;
1990 -> 646;
1991 -> 646;
1992 -> 1989;
1992 -> 1991;
1993 -> 1990;
1993 -> 1991;
1994 -> 1993;
1994 -> 1991;
1995 -> 646;
1996 -> 647;
1996 -> 646;
1997 -> 643;
1997 -> 24;
1998 -> 28;
1998 -> 24;
1999 -> 24;
2000 -> 24;
2001 -> 1997;
2001 -> 2000;
2002 -> 1998;
2002 -> 2000;
2003 -> 1999;
2003 -> 2000;
2004 -> 1999;
2004 -> 2000;
2005 -> 1999;
2005 -> 2000;
2006 -> 2001;
2006 -> 2000;
2007 -> 2002;
2007 -> 2000;
2008 -> 2003;
2008 -> 2000;
2009 -> 2004;
2009 -> 2000;
2010 -> 2005;
2010 -> 2000;
2011 -> 2000;
2012 -> 2006;
2012 -> 2011;
2013 -> 2007;
2013 -> 2011;
2014 -> 2008;
2014 -> 2011;
2015 -> 2009;
2015 -> 2011;
2016 -> 2010;
2016 -> 2011;
2017 -> 2012;
2017 -> 2011;
2018 -> 2013;
2018 -> 2011;
2019 -> 2016;
2019 -> 2011;
2020 -> 2011;
2021 -> 2011;
2022 -> 2017;
2022 -> 2021;
2023 -> 2018;
2023 -> 2021;
2024 -> 2020;
2024 -> 2021;
2025 -> 2019;
2025 -> 2021;
2026 -> 2020;
2026 -> 2021;
2027 -> 2020;
2027 -> 2021;
2028 -> 2020;
2028 -> 2021;
2029 -> 2020;
2029 -> 2021;
2030 -> 2020;
2030 -> 2021;
2031 -> 2020;
2031 -> 2021;
2032 -> 2021;
2033 -> 2021;
2034 -> 2026;
2034 -> 2033;
2034 -> 2021;
2035 -> 2022;
2035 -> 1884;
2035 -> 2021;
2036 -> 2021;
2037 -> 2035;
2037 -> 2036;
2038 -> 2034;
2038 -> 2037;
2038 -> 2021;
2039 -> 2023;
2039 -> 23;
2039 -> 0;
2039 -> 2021;
2040 -> 2038;
2040 -> 2039;
2040 -> 2021;
2041 -> 2040;
2042 -> 0;
2042 -> 2041;
2043 -> 2042;
2043 -> 2040;
2044 -> 2040;
2045 -> 2023;
2045 -> 23;
2045 -> 0;
2045 -> 2040;
2046 -> 2044;
2046 -> 2040;
2047 -> 2046;
2048 -> 2032;
2048 -> 2021;
2049 -> 2031;
2049 -> 2021;
2050 -> 2047;
2050 -> 2021;
2051 -> 2021;
2052 -> 2030;
2052 -> 2021;
2053 -> 2023;
2053 -> 2021;
2054 -> 2027;
2054 -> 2021;
2055 -> 2028;
2055 -> 2021;
2056 -> 2029;
2056 -> 2021;
2057 -> 2024;
2057 -> 2021;
2058 -> 2048;
2058 -> 2049;
2058 -> 2050;
2058 -> 2051;
2058 -> 2052;
2058 -> 2053;
2058 -> 2054;
2058 -> 2055;
2058 -> 2056;
2058 -> 2057;
2058 -> 2022;
2058 -> 2032;
2058 -> 2047;
2058 -> 23;
2058 -> 2037;
2058 -> 2021;
2059 -> 2058;
2059 -> 2051;
2060 -> 2058;
2060 -> 2051;
2061 -> 2058;
2061 -> 2051;
2062 -> 2058;
2062 -> 2051;
2063 -> 2058;
2063 -> 2051;
2064 -> 2058;
2064 -> 2051;
2065 -> 2058;
2065 -> 2051;
2066 -> 2058;
2066 -> 2051;
2067 -> 2058;
2067 -> 2051;
2068 -> 2067;
2068 -> 2058;
2068 -> 2051;
2069 -> 2059;
2069 -> 2051;
2070 -> 2065;
2070 -> 2051;
2071 -> 2051;
2072 -> 2069;
2072 -> 2071;
2073 -> 2070;
2073 -> 2071;
2074 -> 2067;
2074 -> 2071;
2075 -> 2072;
2075 -> 2071;
2076 -> 2071;
2077 -> 2075;
2077 -> 2076;
2078 -> 2074;
2078 -> 2076;
2079 -> 2076;
2080 -> 2078;
2080 -> 2079;
2081 -> 2079;
2082 -> 2081;
2083 -> 2080;
2083 -> 2082;
2084 -> 2083;
2084 -> 2081;
2085 -> 2080;
2085 -> 2076;
2086 -> 2085;
2086 -> 2076;
2087 -> 2085;
2087 -> 2080;
2087 -> 2086;
2088 -> 2087;
2088 -> 2071;
2089 -> 2071;
2090 -> 2088;
2090 -> 2089;
2090 -> 2071;
2091 -> 2088;
2091 -> 2090;
2092 -> 2091;
2092 -> 2051;
2093 -> 2051;
2094 -> 2092;
2094 -> 2093;
2094 -> 2051;
2095 -> 2059;
2095 -> 2051;
2096 -> 2092;
2096 -> 2051;
2097 -> 2051;
2098 -> 2095;
2098 -> 2096;
2098 -> 2097;
2098 -> 2067;
2098 -> 2080;
2098 -> 2051;
2099 -> 2098;
2099 -> 2097;
2100 -> 2097;
2101 -> 2099;
2101 -> 2100;
2102 -> 2100;
2103 -> 2101;
2103 -> 2102;
2104 -> 2103;
2104 -> 2100;
2105 -> 2101;
2105 -> 2097;
2106 -> 2097;
2107 -> 2105;
2107 -> 2106;
2108 -> 2098;
2108 -> 2097;
2109 -> 2097;
2110 -> 2108;
2110 -> 2109;
2111 -> 2109;
2112 -> 2110;
2112 -> 2111;
2113 -> 2112;
2113 -> 2107;
2113 -> 2111;
2114 -> 2112;
2114 -> 2107;
2114 -> 2111;
2115 -> 2114;
2115 -> 2109;
2116 -> 2110;
2116 -> 2107;
2116 -> 2109;
2117 -> 2116;
2117 -> 2097;
2118 -> 2098;
2118 -> 2097;
2119 -> 2097;
2120 -> 2098;
2120 -> 2119;
2120 -> 2117;
2120 -> 2051;
2121 -> 2051;
2122 -> 2063;
2122 -> 2121;
2122 -> 2051;
2123 -> 2122;
2124 -> 2051;
2125 -> 2067;
2125 -> 2120;
2125 -> 2051;
2126 -> 2067;
2126 -> 2120;
2126 -> 2125;
2127 -> 2126;
2127 -> 2125;
2128 -> 2067;
2128 -> 2120;
2128 -> 2127;
2129 -> 2125;
2130 -> 2129;
2131 -> 2130;
2131 -> 2129;
2132 -> 2129;
2132 -> 2120;
2132 -> 2128;
2133 -> 2132;
2133 -> 2125;
2134 -> 2059;
2134 -> 2125;
2135 -> 2128;
2135 -> 2125;
2136 -> 2120;
2136 -> 2125;
2137 -> 2123;
2137 -> 2125;
2138 -> 2125;
2139 -> 2125;
2140 -> 2133;
2140 -> 2139;
2141 -> 2134;
2141 -> 2139;
2142 -> 2135;
2142 -> 2139;
2143 -> 2136;
2143 -> 2139;
2144 -> 2137;
2144 -> 2139;
2145 -> 2138;
2145 -> 2139;
2146 -> 2140;
2146 -> 2139;
2147 -> 2141;
2147 -> 2139;
2148 -> 2142;
2148 -> 2139;
2149 -> 2143;
2149 -> 2139;
2150 -> 2144;
2150 -> 2139;
2151 -> 0;
2151 -> 2139;
2152 -> 2139;
2153 -> 2146;
2153 -> 2152;
2154 -> 2147;
2154 -> 2152;
2155 -> 2148;
2155 -> 2152;
2156 -> 2149;
2156 -> 2152;
2157 -> 2150;
2157 -> 2152;
2158 -> 2151;
2158 -> 2152;
2159 -> 2145;
2159 -> 2152;
2160 -> 2152;
2161 -> 2153;
2161 -> 2132;
2161 -> 2160;
2161 -> 2152;
2162 -> 2154;
2162 -> 2152;
2163 -> 2155;
2163 -> 2152;
2164 -> 2156;
2164 -> 2152;
2165 -> 2157;
2165 -> 2152;
2166 -> 2152;
2167 -> 2161;
2167 -> 2166;
2168 -> 2162;
2168 -> 2166;
2169 -> 2163;
2169 -> 2166;
2170 -> 2164;
2170 -> 2166;
2171 -> 2165;
2171 -> 2166;
2172 -> 2159;
2172 -> 2166;
2173 -> 2167;
2173 -> 2161;
2173 -> 2166;
2174 -> 2167;
2174 -> 2166;
2175 -> 2170;
2175 -> 2166;
2176 -> 2171;
2176 -> 2166;
2177 -> 2169;
2177 -> 2166;
2178 -> 2168;
2178 -> 2166;
2179 -> 2166;
2180 -> 2179;
2181 -> 2166;
2182 -> 2181;
2182 -> 2173;
2182 -> 2174;
2182 -> 2175;
2182 -> 2176;
2182 -> 2177;
2182 -> 2178;
2182 -> 2179;
2182 -> 2161;
2182 -> 2123;
2182 -> 2180;
2182 -> 2166;
2183 -> 2182;
2183 -> 2181;
2184 -> 2181;
2185 -> 2182;
2185 -> 2184;
2185 -> 2166;
2186 -> 2166;
2187 -> 2186;
2187 -> 2181;
2187 -> 2166;
2188 -> 0;
2188 -> 2166;
2189 -> 2188;
2189 -> 2185;
2189 -> 2187;
2189 -> 2186;
2189 -> 2166;
2190 -> 2189;
2190 -> 2181;
2190 -> 2166;
2191 -> 2166;
2192 -> 2191;
2192 -> 2181;
2192 -> 2166;
2193 -> 2181;
2193 -> 2166;
2194 -> 2181;
2194 -> 2166;
2195 -> 2181;
2195 -> 2166;
2196 -> 2181;
2196 -> 2166;
2197 -> 2181;
2197 -> 2166;
2198 -> 2167;
2198 -> 2189;
2198 -> 2166;
2199 -> 2198;
2199 -> 0;
2199 -> 2166;
2200 -> 2199;
2200 -> 2166;
2201 -> 2200;
2201 -> 2181;
2201 -> 2166;
2202 -> 2181;
2202 -> 2189;
2202 -> 2166;
2203 -> 2167;
2203 -> 2166;
2204 -> 2181;
2204 -> 2166;
2205 -> 2202;
2205 -> 2203;
2205 -> 2204;
2205 -> 2189;
2205 -> 2190;
2205 -> 2192;
2205 -> 2193;
2205 -> 2194;
2205 -> 2201;
2205 -> 2195;
2205 -> 2196;
2205 -> 2197;
2205 -> 2191;
2205 -> 2166;
2206 -> 2167;
2206 -> 2205;
2206 -> 2166;
2207 -> 2159;
2207 -> 2152;
2208 -> 2159;
2208 -> 2152;
2209 -> 2159;
2209 -> 2152;
2210 -> 2159;
2210 -> 2152;
2211 -> 2159;
2211 -> 2152;
2212 -> 2159;
2212 -> 2152;
2213 -> 2159;
2213 -> 2152;
2214 -> 2159;
2214 -> 2152;
2215 -> 2159;
2215 -> 2152;
2216 -> 2159;
2216 -> 2152;
2217 -> 2153;
2217 -> 2152;
2218 -> 2153;
2218 -> 2159;
2218 -> 2152;
2219 -> 2158;
2219 -> 2152;
2220 -> 2219;
2220 -> 2159;
2220 -> 2152;
2221 -> 2152;
2222 -> 2154;
2222 -> 2205;
2222 -> 2221;
2222 -> 2152;
2223 -> 2222;
2223 -> 2152;
2224 -> 2153;
2224 -> 2205;
2224 -> 2223;
2225 -> 2153;
2225 -> 2205;
2225 -> 2224;
2225 -> 2159;
2225 -> 2152;
2226 -> 2159;
2226 -> 2205;
2226 -> 2152;
2227 -> 2153;
2227 -> 2152;
2228 -> 2159;
2228 -> 2152;
2229 -> 2226;
2229 -> 2227;
2229 -> 2228;
2229 -> 2205;
2229 -> 2207;
2229 -> 2218;
2229 -> 2208;
2229 -> 2209;
2229 -> 2210;
2229 -> 2211;
2229 -> 2212;
2229 -> 2213;
2229 -> 2214;
2229 -> 2215;
2229 -> 2216;
2229 -> 2225;
2229 -> 2220;
2229 -> 2224;
2229 -> 2219;
2229 -> 2152;
2230 -> 2051;
2231 -> 2060;
2231 -> 2230;
2231 -> 2051;
2232 -> 2061;
2232 -> 2138;
2232 -> 2051;
2233 -> 2051;
2234 -> 2062;
2234 -> 2233;
2234 -> 2051;
2235 -> 2051;
2236 -> 2064;
2236 -> 2235;
2236 -> 2051;
2237 -> 2138;
2237 -> 2051;
2238 -> 2058;
2238 -> 2237;
2238 -> 2229;
2238 -> 2232;
2238 -> 2021;
2239 -> 2058;
2239 -> 2051;
2240 -> 2058;
2240 -> 2051;
2241 -> 2058;
2241 -> 2051;
2242 -> 2058;
2242 -> 2051;
2243 -> 2058;
2243 -> 2051;
2244 -> 2058;
2244 -> 2051;
2245 -> 2058;
2245 -> 2051;
2246 -> 2058;
2246 -> 2051;
2247 -> 2051;
2248 -> 2241;
2248 -> 2051;
2249 -> 2243;
2249 -> 2051;
2250 -> 0;
2250 -> 2051;
2251 -> 2051;
2252 -> 2245;
2252 -> 2051;
2253 -> 2051;
2254 -> 2250;
2254 -> 2253;
2255 -> 2251;
2255 -> 2253;
2256 -> 2252;
2256 -> 2253;
2257 -> 2246;
2257 -> 2253;
2258 -> 2253;
2259 -> 2254;
2259 -> 2253;
2260 -> 2255;
2260 -> 2253;
2261 -> 2258;
2261 -> 2253;
2262 -> 2253;
2263 -> 2259;
2263 -> 2262;
2264 -> 2260;
2264 -> 2262;
2265 -> 2261;
2265 -> 2262;
2266 -> 2262;
2267 -> 2263;
2267 -> 0;
2267 -> 2262;
2268 -> 2267;
2268 -> 2264;
2268 -> 2262;
2269 -> 2268;
2270 -> 2257;
2270 -> 2269;
2271 -> 2269;
2272 -> 2270;
2272 -> 2238;
2272 -> 2271;
2273 -> 2271;
2274 -> 2268;
2275 -> 2257;
2275 -> 2274;
2276 -> 2275;
2276 -> 2238;
2276 -> 2274;
2277 -> 2256;
2277 -> 2276;
2278 -> 2277;
2278 -> 2276;
2279 -> 2277;
2279 -> 2276;
2280 -> 2268;
2281 -> 2272;
2281 -> 2238;
2281 -> 2277;
2282 -> 2263;
2282 -> 0;
2282 -> 2262;
2283 -> 2266;
2283 -> 2282;
2284 -> 2282;
2285 -> 2282;
2286 -> 2257;
2286 -> 2285;
2287 -> 2282;
2288 -> 2257;
2288 -> 2287;
2289 -> 2288;
2289 -> 2277;
2289 -> 2287;
2290 -> 2289;
2290 -> 2282;
2291 -> 2282;
2292 -> 2257;
2292 -> 2291;
2293 -> 2282;
2294 -> 2282;
2295 -> 2293;
2295 -> 2294;
2296 -> 2293;
2296 -> 2294;
2297 -> 2293;
2297 -> 2294;
2298 -> 2257;
2298 -> 2294;
2299 -> 2294;
2300 -> 2294;
2301 -> 2294;
2302 -> 2295;
2302 -> 2301;
2302 -> 2294;
2303 -> 2294;
2304 -> 2303;
2305 -> 2304;
2306 -> 2298;
2306 -> 2305;
2307 -> 2306;
2307 -> 2277;
2307 -> 2305;
2308 -> 2306;
2308 -> 2277;
2308 -> 2305;
2309 -> 2308;
2309 -> 2304;
2310 -> 2300;
2310 -> 2294;
2311 -> 2295;
2311 -> 2294;
2312 -> 2311;
2313 -> 2311;
2314 -> 2294;
2315 -> 2297;
2315 -> 2314;
2315 -> 2294;
2316 -> 2295;
2316 -> 2294;
2317 -> 2296;
2317 -> 2294;
2318 -> 2294;
2319 -> 2316;
2319 -> 2318;
2320 -> 2317;
2320 -> 2318;
2321 -> 2318;
2322 -> 2319;
2322 -> 2321;
2322 -> 2318;
2323 -> 2298;
2323 -> 2277;
2323 -> 2318;
2324 -> 2282;
2325 -> 2257;
2325 -> 2277;
2325 -> 2324;
2325 -> 2282;
2326 -> 2263;
2326 -> 0;
2326 -> 2262;
2327 -> 2265;
2327 -> 2262;
2328 -> 2266;
2328 -> 2262;
2329 -> 2262;
2330 -> 2253;
2331 -> 2247;
2331 -> 2051;
2332 -> 2249;
2332 -> 2277;
2332 -> 2331;
2332 -> 2252;
2332 -> 2246;
2332 -> 2238;
2332 -> 2051;
2333 -> 2247;
2333 -> 2051;
2334 -> 2239;
2334 -> 2051;
2335 -> 2241;
2335 -> 2051;
2336 -> 2240;
2336 -> 2335;
2337 -> 2334;
2337 -> 2332;
2337 -> 2335;
2338 -> 2243;
2338 -> 2335;
2339 -> 2335;
2340 -> 2337;
2340 -> 2339;
2341 -> 2337;
2341 -> 2339;
2342 -> 2337;
2342 -> 2339;
2343 -> 2337;
2343 -> 2339;
2344 -> 2339;
2345 -> 2341;
2345 -> 2337;
2345 -> 2344;
2345 -> 2339;
2346 -> 0;
2346 -> 2339;
2347 -> 2345;
2347 -> 2339;
2348 -> 2336;
2348 -> 2345;
2348 -> 2335;
2349 -> 2335;
2350 -> 2246;
2350 -> 2335;
2351 -> 2334;
2351 -> 2335;
2352 -> 2240;
2352 -> 2335;
2353 -> 2242;
2353 -> 2335;
2354 -> 2332;
2354 -> 2335;
2355 -> 2349;
2355 -> 2335;
2356 -> 2244;
2356 -> 2335;
2357 -> 2245;
2357 -> 2335;
2358 -> 2335;
2359 -> 2350;
2359 -> 2358;
2360 -> 2351;
2360 -> 2358;
2361 -> 2352;
2361 -> 2358;
2362 -> 2353;
2362 -> 2358;
2363 -> 2354;
2363 -> 2358;
2364 -> 2355;
2364 -> 2358;
2365 -> 2356;
2365 -> 2358;
2366 -> 2357;
2366 -> 2358;
2367 -> 2358;
2368 -> 2359;
2368 -> 2367;
2368 -> 2358;
2369 -> 2358;
2370 -> 2364;
2370 -> 2369;
2370 -> 2358;
2371 -> 2358;
2372 -> 2359;
2372 -> 2371;
2373 -> 2372;
2373 -> 2345;
2373 -> 2371;
2374 -> 2373;
2374 -> 2358;
2375 -> 2358;
2376 -> 2358;
2377 -> 2359;
2377 -> 2365;
2378 -> 2360;
2378 -> 2365;
2379 -> 2363;
2379 -> 2365;
2380 -> 2364;
2380 -> 2365;
2381 -> 2366;
2381 -> 2365;
2382 -> 2378;
2382 -> 2365;
2383 -> 2379;
2383 -> 2365;
2384 -> 2381;
2384 -> 2365;
2385 -> 2384;
2385 -> 2365;
2386 -> 2377;
2386 -> 2345;
2386 -> 2365;
2387 -> 2377;
2387 -> 2345;
2387 -> 2365;
2388 -> 2387;
2388 -> 2345;
2388 -> 2365;
2389 -> 2380;
2389 -> 2387;
2389 -> 2349;
2389 -> 2345;
2389 -> 2365;
2390 -> 2358;
2391 -> 2359;
2391 -> 2390;
2391 -> 2358;
2392 -> 2358;
2393 -> 2364;
2393 -> 2392;
2393 -> 2358;
2394 -> 2363;
2394 -> 2358;
2395 -> 2358;
2396 -> 2394;
2396 -> 2395;
2397 -> 2358;
2397 -> 2395;
2398 -> 2396;
2398 -> 2395;
2399 -> 2358;
2400 -> 2361;
2400 -> 2358;
2401 -> 2360;
2401 -> 2389;
2401 -> 2400;
2402 -> 2401;
2402 -> 2358;
2402 -> 2400;
2403 -> 2358;
2404 -> 2359;
2404 -> 2403;
2405 -> 2404;
2405 -> 2389;
2405 -> 2403;
2406 -> 2404;
2406 -> 2389;
2406 -> 2403;
2407 -> 2406;
2407 -> 2358;
2408 -> 2389;
2408 -> 2358;
2408 -> 2359;
2408 -> 2361;
2408 -> 2362;
2408 -> 2364;
2408 -> 2363;
2408 -> 2360;
2408 -> 2365;
2408 -> 2402;
2408 -> 2366;
2408 -> 2238;
2408 -> 2401;
2409 -> 2408;
2409 -> 2389;
2410 -> 2408;
2410 -> 2389;
2411 -> 2408;
2411 -> 2389;
2412 -> 2409;
2412 -> 2389;
2413 -> 2389;
2414 -> 2411;
2414 -> 2413;
2415 -> 2412;
2415 -> 2413;
2416 -> 2413;
2417 -> 2414;
2417 -> 2416;
2417 -> 2413;
2418 -> 2389;
2419 -> 2409;
2419 -> 2408;
2420 -> 2358;
2421 -> 2408;
2421 -> 2420;
2421 -> 2358;
2422 -> 2358;
2423 -> 2358;
2424 -> 2360;
2424 -> 2423;
2424 -> 2358;
2425 -> 2364;
2425 -> 2424;
2426 -> 2424;
2427 -> 2425;
2427 -> 2426;
2428 -> 2360;
2428 -> 2426;
2429 -> 2428;
2429 -> 2408;
2429 -> 2426;
2430 -> 2429;
2430 -> 2424;
2431 -> 2430;
2431 -> 2424;
2432 -> 2364;
2432 -> 2424;
2433 -> 2424;
2434 -> 2431;
2434 -> 2433;
2435 -> 2432;
2435 -> 2433;
2436 -> 2358;
2436 -> 2433;
2437 -> 2434;
2437 -> 2433;
2438 -> 2424;
2439 -> 2364;
2439 -> 2424;
2440 -> 2424;
2441 -> 2439;
2441 -> 2440;
2442 -> 2360;
2442 -> 2440;
2443 -> 2440;
2444 -> 2441;
2444 -> 2440;
2445 -> 2440;
2446 -> 2444;
2446 -> 2445;
2447 -> 2442;
2447 -> 2445;
2448 -> 2445;
2449 -> 2447;
2449 -> 2448;
2450 -> 2448;
2451 -> 2450;
2451 -> 2449;
2451 -> 2448;
2452 -> 2448;
2453 -> 2449;
2453 -> 2452;
2454 -> 2453;
2454 -> 2408;
2454 -> 2451;
2454 -> 2452;
2455 -> 2454;
2455 -> 2448;
2456 -> 2455;
2456 -> 2445;
2457 -> 2445;
2458 -> 2447;
2458 -> 2457;
2459 -> 2458;
2459 -> 2454;
2459 -> 2457;
2460 -> 2459;
2460 -> 2445;
2461 -> 2460;
2462 -> 2456;
2462 -> 2461;
2462 -> 2460;
2463 -> 2462;
2464 -> 2440;
2465 -> 2443;
2465 -> 2440;
2466 -> 2442;
2466 -> 2459;
2466 -> 2440;
2467 -> 2465;
2467 -> 2466;
2467 -> 2443;
2467 -> 2459;
2467 -> 2440;
2468 -> 2443;
2468 -> 2440;
2469 -> 2442;
2469 -> 2467;
2469 -> 2440;
2470 -> 2443;
2470 -> 2440;
2471 -> 2442;
2471 -> 2469;
2471 -> 2440;
2472 -> 2443;
2472 -> 2440;
2473 -> 2442;
2473 -> 2471;
2473 -> 2440;
2474 -> 2443;
2474 -> 2440;
2475 -> 2442;
2475 -> 2473;
2475 -> 2440;
2476 -> 2443;
2476 -> 2440;
2477 -> 2442;
2477 -> 2475;
2477 -> 2440;
2478 -> 2443;
2478 -> 2440;
2479 -> 2442;
2479 -> 2477;
2479 -> 2440;
2480 -> 2443;
2480 -> 2440;
2481 -> 2442;
2481 -> 2479;
2481 -> 2440;
2482 -> 2443;
2482 -> 2481;
2482 -> 2440;
2483 -> 2482;
2483 -> 2424;
2484 -> 2483;
2484 -> 2424;
2485 -> 2364;
2485 -> 2424;
2486 -> 2424;
2487 -> 2484;
2487 -> 2486;
2488 -> 2485;
2488 -> 2486;
2489 -> 2358;
2489 -> 2486;
2490 -> 2487;
2490 -> 2486;
2491 -> 2424;
2492 -> 2424;
2493 -> 2359;
2493 -> 2492;
2494 -> 2493;
2494 -> 2481;
2494 -> 2492;
2495 -> 2494;
2495 -> 2424;
2496 -> 2358;
2496 -> 2424;
2497 -> 2360;
2497 -> 2424;
2498 -> 2364;
2498 -> 2424;
2499 -> 2424;
2500 -> 2495;
2500 -> 2499;
2501 -> 0;
2501 -> 2499;
2502 -> 2495;
2502 -> 2501;
2502 -> 0;
2502 -> 2424;
2503 -> 2495;
2503 -> 2499;
2504 -> 2499;
2505 -> 2495;
2505 -> 2504;
2505 -> 2502;
2505 -> 2424;
2506 -> 2424;
2507 -> 2506;
2507 -> 2505;
2508 -> 2506;
2509 -> 2507;
2509 -> 2508;
2509 -> 2506;
2510 -> 2424;
2511 -> 2360;
2511 -> 2507;
2511 -> 2424;
2512 -> 2424;
2513 -> 2511;
2513 -> 2512;
2513 -> 2424;
2514 -> 2358;
2515 -> 2360;
2515 -> 2514;
2515 -> 2358;
2516 -> 2358;
2516 -> 2507;
2516 -> 2360;
2517 -> 2359;
2517 -> 2365;
2518 -> 2364;
2518 -> 2365;
2519 -> 2366;
2519 -> 2365;
2520 -> 2365;
2521 -> 2517;
2521 -> 2520;
2522 -> 2521;
2522 -> 2507;
2522 -> 2520;
2523 -> 2521;
2523 -> 2507;
2523 -> 2520;
2524 -> 2523;
2524 -> 2365;
2525 -> 2365;
2526 -> 2360;
2526 -> 2525;
2526 -> 2365;
2527 -> 2389;
2527 -> 2525;
2527 -> 2365;
2528 -> 2335;
2529 -> 2349;
2529 -> 2335;
2530 -> 2529;
2530 -> 2507;
2530 -> 2335;
2531 -> 2334;
2531 -> 2530;
2532 -> 2349;
2532 -> 2530;
2533 -> 2530;
2534 -> 2531;
2534 -> 2533;
2535 -> 2532;
2535 -> 2533;
2536 -> 2246;
2536 -> 2533;
2537 -> 2536;
2537 -> 2530;
2537 -> 2533;
2538 -> 2536;
2538 -> 2530;
2538 -> 2533;
2539 -> 2530;
2540 -> 2243;
2540 -> 2335;
2541 -> 2349;
2541 -> 2335;
2542 -> 2245;
2542 -> 2335;
2543 -> 2540;
2543 -> 2541;
2543 -> 2542;
2543 -> 2246;
2543 -> 2530;
2543 -> 2238;
2543 -> 2335;
2544 -> 2335;
2545 -> 2332;
2545 -> 2543;
2545 -> 2335;
2546 -> 2051;
2547 -> 2058;
2547 -> 2546;
2547 -> 2543;
2547 -> 2021;
2548 -> 2058;
2548 -> 2051;
2549 -> 2058;
2549 -> 2051;
2550 -> 2058;
2550 -> 2051;
2551 -> 2058;
2551 -> 2051;
2552 -> 2058;
2552 -> 2051;
2553 -> 2058;
2553 -> 2051;
2554 -> 2058;
2554 -> 2051;
2555 -> 2051;
2556 -> 2548;
2556 -> 2051;
2557 -> 2550;
2557 -> 2051;
2558 -> 2555;
2558 -> 2051;
2559 -> 2554;
2559 -> 2556;
2559 -> 2557;
2559 -> 2558;
2559 -> 2547;
2559 -> 2555;
2559 -> 2051;
2560 -> 2548;
2560 -> 2559;
2560 -> 2051;
2561 -> 2051;
2562 -> 2554;
2562 -> 2561;
2563 -> 2561;
2564 -> 2562;
2564 -> 2563;
2565 -> 2564;
2565 -> 2559;
2565 -> 2563;
2566 -> 2564;
2566 -> 2559;
2566 -> 2563;
2567 -> 2566;
2567 -> 2561;
2568 -> 2562;
2568 -> 2559;
2568 -> 2561;
2569 -> 2568;
2569 -> 2051;
2570 -> 2051;
2571 -> 2555;
2571 -> 2051;
2572 -> 2051;
2573 -> 2571;
2573 -> 2572;
2574 -> 2554;
2574 -> 2572;
2575 -> 2572;
2576 -> 2574;
2576 -> 2575;
2577 -> 2575;
2578 -> 2576;
2578 -> 2577;
2579 -> 2578;
2579 -> 2569;
2579 -> 2577;
2580 -> 2578;
2580 -> 2569;
2580 -> 2577;
2581 -> 2580;
2581 -> 2575;
2582 -> 2576;
2582 -> 2569;
2582 -> 2575;
2583 -> 2582;
2583 -> 2572;
2584 -> 2572;
2585 -> 2584;
2585 -> 2583;
2585 -> 2582;
2585 -> 2572;
2586 -> 2572;
2587 -> 2586;
2587 -> 2051;
2588 -> 2552;
2588 -> 2051;
2589 -> 2555;
2589 -> 2051;
2590 -> 2553;
2590 -> 2051;
2591 -> 2588;
2591 -> 2589;
2591 -> 2590;
2591 -> 2554;
2591 -> 2582;
2591 -> 2547;
2591 -> 2051;
2592 -> 2051;
2593 -> 2553;
2593 -> 2547;
2593 -> 2591;
2593 -> 2051;
2594 -> 2051;
2595 -> 2551;
2595 -> 2051;
2596 -> 2051;
2597 -> 2554;
2597 -> 2051;
2598 -> 2595;
2598 -> 2051;
2599 -> 2549;
2599 -> 2051;
2600 -> 2594;
2600 -> 2051;
2601 -> 2553;
2601 -> 2051;
2602 -> 2051;
2603 -> 2051;
2604 -> 2597;
2604 -> 2603;
2605 -> 2598;
2605 -> 2603;
2606 -> 2599;
2606 -> 2603;
2607 -> 2600;
2607 -> 2603;
2608 -> 2601;
2608 -> 2603;
2609 -> 2602;
2609 -> 2603;
2610 -> 2602;
2610 -> 2603;
2611 -> 2603;
2612 -> 2603;
2613 -> 2606;
2613 -> 2612;
2613 -> 2603;
2614 -> 2603;
2615 -> 2614;
2616 -> 2604;
2616 -> 2615;
2617 -> 2616;
2617 -> 2593;
2617 -> 2615;
2618 -> 2616;
2618 -> 2593;
2618 -> 2615;
2619 -> 2618;
2619 -> 2614;
2620 -> 2604;
2620 -> 2593;
2620 -> 2614;
2621 -> 2620;
2621 -> 2605;
2621 -> 2603;
2622 -> 2611;
2622 -> 2603;
2623 -> 2609;
2623 -> 2603;
2624 -> 2610;
2624 -> 2603;
2625 -> 2603;
2626 -> 2607;
2626 -> 2603;
2627 -> 2603;
2628 -> 2622;
2628 -> 2627;
2629 -> 2623;
2629 -> 2627;
2630 -> 2624;
2630 -> 2627;
2631 -> 2625;
2631 -> 2627;
2632 -> 2625;
2632 -> 2627;
2633 -> 2626;
2633 -> 2627;
2634 -> 2625;
2634 -> 2627;
2635 -> 2627;
2636 -> 2635;
2636 -> 2627;
2637 -> 2635;
2637 -> 2627;
2638 -> 2635;
2638 -> 2627;
2639 -> 2635;
2639 -> 2627;
2640 -> 2635;
2640 -> 2627;
2641 -> 2635;
2641 -> 2627;
2642 -> 2635;
2642 -> 2627;
2643 -> 2635;
2643 -> 2627;
2644 -> 2635;
2644 -> 2627;
2645 -> 2635;
2645 -> 2627;
2646 -> 2635;
2646 -> 2627;
2647 -> 2635;
2647 -> 2627;
2648 -> 2628;
2648 -> 2635;
2648 -> 2627;
2649 -> 2629;
2649 -> 2635;
2649 -> 2627;
2650 -> 2630;
2650 -> 2635;
2650 -> 2627;
2651 -> 2631;
2651 -> 2635;
2651 -> 2627;
2652 -> 2632;
2652 -> 2635;
2652 -> 2627;
2653 -> 2633;
2653 -> 2635;
2653 -> 2627;
2654 -> 2603;
2655 -> 2654;
2656 -> 2604;
2656 -> 2655;
2657 -> 2656;
2657 -> 2620;
2657 -> 2655;
2658 -> 2656;
2658 -> 2620;
2658 -> 2655;
2659 -> 2658;
2659 -> 2654;
2660 -> 2620;
2660 -> 2625;
2660 -> 2635;
2660 -> 2636;
2660 -> 2621;
2660 -> 2637;
2660 -> 2604;
2660 -> 2638;
2660 -> 2648;
2660 -> 2639;
2660 -> 2649;
2660 -> 2640;
2660 -> 2650;
2660 -> 2641;
2660 -> 2651;
2660 -> 2642;
2660 -> 2652;
2660 -> 2643;
2660 -> 2653;
2660 -> 2644;
2660 -> 2645;
2660 -> 2646;
2660 -> 2647;
2660 -> 2608;
2660 -> 2602;
2660 -> 2594;
2660 -> 2593;
2660 -> 2603;
2661 -> 2603;
2662 -> 2660;
2663 -> 2660;
2664 -> 2660;
2665 -> 2663;
2665 -> 2664;
2666 -> 2660;
2666 -> 2664;
2667 -> 2666;
2667 -> 2660;
2667 -> 2664;
2668 -> 2664;
2669 -> 2667;
2670 -> 2660;
2671 -> 2660;
2672 -> 2670;
2672 -> 2671;
2673 -> 2660;
2673 -> 2671;
2674 -> 2673;
2674 -> 2660;
2674 -> 2671;
2675 -> 2671;
2676 -> 2674;
2677 -> 2660;
2678 -> 2660;
2679 -> 2660;
2680 -> 2678;
2680 -> 2679;
2681 -> 2660;
2681 -> 2679;
2682 -> 2681;
2682 -> 2660;
2682 -> 2679;
2683 -> 2679;
2684 -> 2682;
2685 -> 2660;
2686 -> 2660;
2687 -> 2660;
2687 -> 2686;
2688 -> 2660;
2689 -> 2686;
2689 -> 2688;
2690 -> 2686;
2690 -> 2688;
2691 -> 2660;
2691 -> 2688;
2692 -> 2689;
2692 -> 2688;
2693 -> 2690;
2693 -> 2688;
2694 -> 2692;
2694 -> 2693;
2694 -> 2688;
2695 -> 2688;
2696 -> 2694;
2696 -> 2695;
2697 -> 2691;
2697 -> 2695;
2698 -> 2697;
2698 -> 2660;
2698 -> 2695;
2699 -> 2695;
2700 -> 2698;
2701 -> 2688;
2702 -> 2660;
2703 -> 2660;
2704 -> 2660;
2705 -> 2660;
2706 -> 2704;
2706 -> 2705;
2707 -> 2660;
2707 -> 2705;
2708 -> 2707;
2708 -> 2660;
2708 -> 2705;
2709 -> 2705;
2710 -> 2708;
2711 -> 2660;
2712 -> 2660;
2713 -> 2711;
2713 -> 2712;
2714 -> 2660;
2714 -> 2712;
2715 -> 2714;
2715 -> 2660;
2715 -> 2712;
2716 -> 2712;
2717 -> 2715;
2718 -> 2660;
2719 -> 2660;
2719 -> 2661;
2720 -> 2660;
2721 -> 2660;
2722 -> 2660;
2723 -> 2660;
2724 -> 2660;
2725 -> 2724;
2725 -> 2660;
2726 -> 2723;
2726 -> 2660;
2727 -> 2724;
2727 -> 2660;
2728 -> 0;
2728 -> 2660;
2729 -> 2660;
2730 -> 2660;
2731 -> 2660;
2732 -> 2731;
2732 -> 2728;
2732 -> 2660;
2733 -> 2732;
2733 -> 2660;
2734 -> 2660;
2735 -> 2660;
2736 -> 2730;
2736 -> 2735;
2736 -> 2660;
2737 -> 0;
2737 -> 2736;
2738 -> 2660;
2739 -> 2737;
2739 -> 0;
2739 -> 2660;
2740 -> 2733;
2740 -> 0;
2740 -> 2739;
2741 -> 2739;
2742 -> 2660;
2743 -> 2660;
2744 -> 2660;
2745 -> 2743;
2745 -> 2744;
2746 -> 2660;
2746 -> 2744;
2747 -> 2746;
2747 -> 2660;
2747 -> 2744;
2748 -> 2744;
2749 -> 2747;
2750 -> 2660;
2751 -> 2660;
2752 -> 2660;
2753 -> 2751;
2753 -> 2752;
2754 -> 2660;
2754 -> 2752;
2755 -> 2754;
2755 -> 2660;
2755 -> 2752;
2756 -> 2752;
2757 -> 2755;
2758 -> 2603;
2759 -> 2625;
2759 -> 2660;
2759 -> 2758;
2759 -> 2603;
2760 -> 2611;
2760 -> 2603;
2761 -> 2603;
2762 -> 2609;
2762 -> 2761;
2762 -> 2603;
2763 -> 2762;
2764 -> 2763;
2765 -> 2764;
2766 -> 2660;
2767 -> 2660;
2768 -> 2660;
2769 -> 2552;
2769 -> 2051;
2770 -> 2594;
2770 -> 2051;
2771 -> 2553;
2771 -> 2051;
2772 -> 2769;
2772 -> 2770;
2772 -> 2771;
2772 -> 2554;
2772 -> 2660;
2772 -> 2051;
2773 -> 2051;
2774 -> 2058;
2774 -> 2051;
2775 -> 2058;
2775 -> 2051;
2776 -> 2058;
2776 -> 2051;
2777 -> 2058;
2777 -> 2051;
2778 -> 2051;
2779 -> 2777;
2779 -> 2772;
2779 -> 2778;
2779 -> 2051;
2780 -> 2774;
2780 -> 2051;
2781 -> 2051;
2782 -> 2780;
2782 -> 2781;
2783 -> 2777;
2783 -> 2781;
2784 -> 2781;
2785 -> 2783;
2785 -> 2772;
2785 -> 2784;
2785 -> 2781;
2786 -> 2051;
2787 -> 2051;
2788 -> 2787;
2789 -> 2788;
2790 -> 2789;
2791 -> 2058;
2791 -> 2790;
2792 -> 2791;
2792 -> 2772;
2792 -> 2790;
2793 -> 2791;
2793 -> 2772;
2793 -> 2790;
2794 -> 2793;
2794 -> 2789;
2795 -> 2787;
2796 -> 2058;
2796 -> 2051;
2797 -> 2051;
2798 -> 2796;
2798 -> 2797;
2799 -> 2797;
2800 -> 2798;
2800 -> 2799;
2801 -> 2800;
2801 -> 2772;
2801 -> 2799;
2802 -> 2800;
2802 -> 2772;
2802 -> 2799;
2803 -> 2802;
2803 -> 2797;
2804 -> 2051;
2805 -> 2058;
2805 -> 2051;
2806 -> 2051;
2807 -> 2805;
2807 -> 2806;
2808 -> 2806;
2809 -> 2807;
2809 -> 2808;
2810 -> 2809;
2810 -> 2772;
2810 -> 2808;
2811 -> 2809;
2811 -> 2772;
2811 -> 2808;
2812 -> 2811;
2812 -> 2806;
2813 -> 2058;
2813 -> 2051;
2814 -> 2058;
2814 -> 2051;
2815 -> 2051;
2816 -> 2814;
2816 -> 2815;
2817 -> 2816;
2817 -> 2772;
2817 -> 2815;
2818 -> 2817;
2818 -> 2051;
2819 -> 2818;
2819 -> 2772;
2819 -> 2051;
2820 -> 2818;
2820 -> 2051;
2821 -> 2814;
2821 -> 2772;
2821 -> 2051;
2822 -> 2818;
2822 -> 2819;
2823 -> 2813;
2823 -> 2772;
2823 -> 2819;
2824 -> 2819;
2825 -> 2822;
2825 -> 2824;
2826 -> 2823;
2826 -> 2824;
2827 -> 2814;
2827 -> 2824;
2828 -> 2827;
2828 -> 2772;
2828 -> 2824;
2829 -> 2825;
2829 -> 2824;
2830 -> 2828;
2830 -> 2829;
2830 -> 2824;
2831 -> 2824;
2832 -> 2825;
2832 -> 2824;
2833 -> 2831;
2833 -> 2824;
2834 -> 2827;
2834 -> 2772;
2834 -> 2832;
2834 -> 2833;
2834 -> 2824;
2835 -> 2825;
2835 -> 2824;
2836 -> 2824;
2837 -> 2824;
2838 -> 2835;
2838 -> 2837;
2839 -> 2836;
2839 -> 2837;
2840 -> 2839;
2840 -> 2837;
2841 -> 2837;
2842 -> 2838;
2842 -> 2841;
2842 -> 2837;
2843 -> 2838;
2843 -> 2839;
2843 -> 2837;
2844 -> 2825;
2844 -> 2824;
2845 -> 2836;
2845 -> 2824;
2846 -> 2827;
2846 -> 2834;
2846 -> 2844;
2846 -> 2845;
2846 -> 2843;
2846 -> 2824;
2847 -> 2846;
2847 -> 2836;
2847 -> 2824;
2848 -> 2825;
2848 -> 2847;
2849 -> 2846;
2849 -> 2847;
2850 -> 2826;
2850 -> 2847;
2851 -> 2847;
2852 -> 2848;
2852 -> 2851;
2853 -> 2849;
2853 -> 2851;
2854 -> 2850;
2854 -> 2851;
2855 -> 2827;
2855 -> 2851;
2856 -> 2855;
2856 -> 2846;
2856 -> 2851;
2857 -> 2851;
2858 -> 2853;
2858 -> 2857;
2859 -> 2858;
2859 -> 2846;
2859 -> 2857;
2860 -> 2859;
2860 -> 2851;
2861 -> 2856;
2861 -> 2846;
2861 -> 2851;
2862 -> 2855;
2862 -> 2846;
2862 -> 0;
2862 -> 2851;
2863 -> 2860;
2863 -> 2846;
2863 -> 2851;
2864 -> 2862;
2864 -> 2863;
2864 -> 2851;
2865 -> 2852;
2865 -> 2846;
2865 -> 2851;
2866 -> 2852;
2866 -> 2846;
2866 -> 2851;
2867 -> 2851;
2868 -> 2855;
2868 -> 2846;
2868 -> 2867;
2868 -> 2851;
2869 -> 2847;
2870 -> 2824;
2871 -> 2825;
2871 -> 2846;
2871 -> 2870;
2871 -> 2824;
2872 -> 2846;
2872 -> 2824;
2873 -> 2846;
2873 -> 2824;
2874 -> 2058;
2874 -> 2873;
2874 -> 2871;
2874 -> 2021;
2875 -> 2058;
2875 -> 2051;
2876 -> 2875;
2876 -> 2874;
2876 -> 2051;
2877 -> 2058;
2877 -> 2051;
2878 -> 2058;
2878 -> 2051;
2879 -> 2878;
2879 -> 2876;
2879 -> 2051;
2880 -> 2051;
2881 -> 2880;
2881 -> 2879;
2881 -> 2876;
2881 -> 2051;
2882 -> 2051;
2883 -> 2058;
2883 -> 2882;
2883 -> 2876;
2883 -> 2021;
2884 -> 2058;
2884 -> 2051;
2885 -> 2058;
2885 -> 2051;
2886 -> 2884;
2886 -> 2883;
2886 -> 2051;
2887 -> 2885;
2887 -> 2883;
2887 -> 2886;
2888 -> 2884;
2888 -> 2886;
2889 -> 2886;
2890 -> 2887;
2890 -> 2889;
2891 -> 2888;
2891 -> 2889;
2892 -> 2885;
2892 -> 2889;
2893 -> 2890;
2893 -> 2883;
2893 -> 2889;
2894 -> 2893;
2895 -> 2890;
2895 -> 2883;
2895 -> 2893;
2896 -> 2893;
2897 -> 2896;
2897 -> 2895;
2897 -> 2883;
2897 -> 2893;
2898 -> 2891;
2898 -> 2883;
2898 -> 2893;
2899 -> 2892;
2899 -> 2883;
2899 -> 2898;
2900 -> 2890;
2900 -> 2893;
2901 -> 2894;
2901 -> 2893;
2902 -> 2893;
2903 -> 2894;
2903 -> 2901;
2903 -> 2893;
2904 -> 2901;
2904 -> 2889;
2905 -> 2058;
2905 -> 2904;
2905 -> 2903;
2905 -> 2901;
2905 -> 2021;
2906 -> 2058;
2906 -> 2051;
2907 -> 2906;
2907 -> 2905;
2907 -> 2051;
2908 -> 2058;
2908 -> 2051;
2909 -> 2058;
2909 -> 2051;
2910 -> 2908;
2910 -> 2907;
2910 -> 2051;
2911 -> 2051;
2912 -> 2909;
2912 -> 2907;
2912 -> 2911;
2913 -> 2912;
2913 -> 2051;
2914 -> 2051;
2915 -> 2058;
2915 -> 2051;
2916 -> 2058;
2916 -> 2051;
2917 -> 2915;
2917 -> 2913;
2917 -> 2051;
2918 -> 2051;
2919 -> 2917;
2919 -> 2918;
2920 -> 2916;
2920 -> 2918;
2921 -> 2920;
2921 -> 2913;
2921 -> 2918;
2922 -> 2921;
2922 -> 2051;
2923 -> 2051;
2924 -> 2058;
2924 -> 2051;
2925 -> 2058;
2925 -> 2051;
2926 -> 2924;
2926 -> 2922;
2926 -> 2051;
2927 -> 2051;
2928 -> 2926;
2928 -> 2927;
2929 -> 2925;
2929 -> 2927;
2930 -> 2927;
2931 -> 2928;
2931 -> 2927;
2932 -> 2927;
2933 -> 2931;
2933 -> 2932;
2934 -> 2929;
2934 -> 2932;
2935 -> 2932;
2936 -> 2934;
2936 -> 2935;
2937 -> 2935;
2938 -> 2937;
2938 -> 2936;
2938 -> 2935;
2939 -> 2935;
2940 -> 2936;
2940 -> 2939;
2941 -> 2940;
2941 -> 2922;
2941 -> 2938;
2941 -> 2939;
2942 -> 2941;
2942 -> 2935;
2943 -> 2942;
2943 -> 2932;
2944 -> 2932;
2945 -> 2934;
2945 -> 2944;
2946 -> 2941;
2946 -> 2932;
2947 -> 2946;
2948 -> 2943;
2948 -> 2947;
2948 -> 2946;
2949 -> 2948;
2950 -> 2927;
2951 -> 2930;
2951 -> 2927;
2952 -> 2930;
2952 -> 2927;
2953 -> 2930;
2953 -> 2927;
2954 -> 2930;
2954 -> 2927;
2955 -> 2930;
2955 -> 2927;
2956 -> 2930;
2956 -> 2927;
2957 -> 2930;
2957 -> 2927;
2958 -> 2930;
2958 -> 2927;
2959 -> 2930;
2959 -> 2941;
2959 -> 2927;
2960 -> 2959;
2960 -> 2051;
2961 -> 2051;
2962 -> 2058;
2962 -> 2051;
2963 -> 2058;
2963 -> 2051;
2964 -> 2051;
2965 -> 2963;
2965 -> 2960;
2965 -> 2051;
2966 -> 2964;
2966 -> 2965;
2966 -> 2960;
2966 -> 2051;
2967 -> 2051;
2968 -> 2964;
2968 -> 2966;
2968 -> 2967;
2968 -> 2051;
2969 -> 2964;
2969 -> 2966;
2969 -> 2968;
2970 -> 2969;
2970 -> 2968;
2971 -> 2970;
2971 -> 2969;
2971 -> 0;
2972 -> 2971;
2973 -> 2970;
2973 -> 2969;
2973 -> 2971;
2975 -> 2974;
2976 -> 2974;
2977 -> 2058;
2977 -> 2051;
2978 -> 2058;
2978 -> 2051;
2979 -> 2051;
2980 -> 2058;
2980 -> 2979;
2980 -> 2972;
2980 -> 2021;
2981 -> 2058;
2981 -> 2051;
2982 -> 2058;
2982 -> 2051;
2983 -> 2982;
2983 -> 2051;
2984 -> 2981;
2984 -> 2051;
2985 -> 2982;
2985 -> 2980;
2985 -> 2051;
2986 -> 2983;
2986 -> 2984;
2986 -> 2985;
2986 -> 2982;
2986 -> 2980;
2986 -> 2051;
2987 -> 2051;
2988 -> 2986;
2988 -> 2987;
2989 -> 2986;
2989 -> 2987;
2990 -> 2988;
2990 -> 0;
2990 -> 2987;
2991 -> 2987;
2992 -> 2988;
2992 -> 2987;
2993 -> 2989;
2993 -> 2992;
2993 -> 2986;
2993 -> 2987;
2994 -> 2993;
2995 -> 2994;
2996 -> 2995;
2996 -> 2994;
2997 -> 2994;
2997 -> 2993;
2998 -> 2988;
2998 -> 2993;
2999 -> 2997;
2999 -> 2988;
2999 -> 2987;
3000 -> 2997;
3000 -> 2987;
3001 -> 3000;
3002 -> 3001;
3002 -> 3000;
3003 -> 3000;
3003 -> 2988;
3003 -> 2987;
3004 -> 2987;
3005 -> 3004;
3006 -> 2986;
3006 -> 3005;
3007 -> 3006;
3007 -> 3000;
3007 -> 3005;
3008 -> 3006;
3008 -> 3000;
3008 -> 3005;
3009 -> 3008;
3009 -> 3004;
3010 -> 2987;
3011 -> 2987;
3012 -> 2058;
3012 -> 2051;
3013 -> 2058;
3013 -> 2051;
3014 -> 2058;
3014 -> 2051;
3015 -> 2058;
3015 -> 2051;
3016 -> 2058;
3016 -> 2051;
3017 -> 2058;
3017 -> 2051;
3018 -> 3012;
3018 -> 2051;
3019 -> 3018;
3019 -> 3000;
3019 -> 2051;
3020 -> 2051;
3021 -> 3015;
3021 -> 3020;
3021 -> 2051;
3022 -> 3012;
3022 -> 2051;
3023 -> 3013;
3023 -> 2051;
3024 -> 3014;
3024 -> 2051;
3025 -> 3016;
3025 -> 2051;
3026 -> 2051;
3027 -> 3022;
3027 -> 3026;
3028 -> 3023;
3028 -> 3026;
3029 -> 3024;
3029 -> 3026;
3030 -> 3025;
3030 -> 3026;
3031 -> 3017;
3031 -> 3026;
3032 -> 3026;
3033 -> 3026;
3034 -> 3027;
3034 -> 3019;
3034 -> 3026;
3035 -> 3034;
3035 -> 3019;
3035 -> 3026;
3036 -> 3027;
3036 -> 3019;
3036 -> 3026;
3037 -> 3027;
3037 -> 3036;
3037 -> 3026;
3038 -> 3030;
3038 -> 3037;
3039 -> 3027;
3039 -> 3036;
3039 -> 3038;
3040 -> 3034;
3040 -> 3038;
3041 -> 3038;
3042 -> 3040;
3042 -> 3041;
3043 -> 3041;
3044 -> 3042;
3044 -> 3043;
3044 -> 3041;
3045 -> 3044;
3046 -> 3042;
3046 -> 3036;
3046 -> 3044;
3047 -> 3041;
3048 -> 3047;
3048 -> 3038;
3049 -> 3039;
3049 -> 3048;
3049 -> 3038;
3050 -> 3027;
3050 -> 3049;
3051 -> 3027;
3051 -> 3036;
3051 -> 3049;
3052 -> 3026;
3053 -> 3031;
3053 -> 3036;
3053 -> 3052;
3053 -> 3026;
3054 -> 3027;
3054 -> 3036;
3054 -> 3026;
3055 -> 2051;
3056 -> 3015;
3056 -> 3055;
3056 -> 2051;
3057 -> 3054;
3057 -> 3056;
3058 -> 2058;
3058 -> 2051;
3059 -> 2058;
3059 -> 2051;
3060 -> 2058;
3060 -> 2051;
3061 -> 2058;
3061 -> 2051;
3062 -> 2051;
3063 -> 3060;
3063 -> 3062;
3063 -> 2051;
3064 -> 3058;
3064 -> 3057;
3064 -> 2051;
3065 -> 3058;
3065 -> 3064;
3066 -> 3059;
3066 -> 3064;
3067 -> 3060;
3067 -> 3064;
3068 -> 3064;
3069 -> 3064;
3070 -> 3065;
3070 -> 3069;
3071 -> 3066;
3071 -> 3069;
3072 -> 3067;
3072 -> 3069;
3073 -> 3068;
3073 -> 3069;
3074 -> 3068;
3074 -> 3069;
3075 -> 3061;
3075 -> 3069;
3076 -> 3070;
3076 -> 3057;
3076 -> 3069;
3077 -> 3069;
3078 -> 3072;
3078 -> 3077;
3078 -> 3069;
3079 -> 3070;
3079 -> 3076;
3079 -> 3069;
3080 -> 3070;
3080 -> 3076;
3080 -> 3079;
3081 -> 3070;
3081 -> 3076;
3081 -> 0;
3081 -> 3069;
3082 -> 3070;
3082 -> 3076;
3082 -> 3069;
3083 -> 3074;
3083 -> 3082;
3084 -> 3083;
3085 -> 3083;
3086 -> 3070;
3086 -> 3076;
3086 -> 3083;
3087 -> 3083;
3088 -> 3086;
3088 -> 3087;
3089 -> 3087;
3090 -> 3088;
3090 -> 3089;
3091 -> 3089;
3092 -> 3090;
3092 -> 3091;
3092 -> 3089;
3093 -> 3089;
3094 -> 3093;
3094 -> 3087;
3095 -> 3070;
3095 -> 3076;
3095 -> 3094;
3096 -> 3070;
3096 -> 3076;
3096 -> 3069;
3097 -> 3075;
3097 -> 3076;
3097 -> 3069;
3098 -> 3070;
3098 -> 3076;
3098 -> 3069;
3099 -> 2058;
3099 -> 2051;
3100 -> 2058;
3100 -> 2051;
3101 -> 2058;
3101 -> 2051;
3102 -> 2058;
3102 -> 2051;
3103 -> 2058;
3103 -> 2051;
3104 -> 2058;
3104 -> 2051;
3105 -> 2051;
3106 -> 3101;
3106 -> 3105;
3106 -> 2051;
3107 -> 3099;
3107 -> 3097;
3107 -> 2051;
3108 -> 3099;
3108 -> 3097;
3108 -> 3107;
3109 -> 3099;
3109 -> 3097;
3109 -> 0;
3109 -> 2051;
3110 -> 3099;
3110 -> 3097;
3110 -> 2051;
3111 -> 3103;
3111 -> 3110;
3112 -> 3099;
3112 -> 3097;
3112 -> 2051;
3113 -> 2058;
3113 -> 2051;
3114 -> 2058;
3114 -> 2051;
3115 -> 2058;
3115 -> 2051;
3116 -> 3115;
3116 -> 3097;
3116 -> 2051;
3117 -> 3113;
3117 -> 2051;
3118 -> 3116;
3118 -> 3117;
3118 -> 2051;
3119 -> 2051;
3120 -> 3113;
3120 -> 3119;
3120 -> 2051;
3121 -> 2051;
3122 -> 3113;
3122 -> 2051;
3123 -> 3121;
3123 -> 2051;
3124 -> 3115;
3124 -> 3097;
3124 -> 3122;
3124 -> 3123;
3124 -> 2051;
3125 -> 3124;
3126 -> 3099;
3126 -> 3125;
3126 -> 2051;
3127 -> 3099;
3127 -> 3125;
3127 -> 3126;
3128 -> 3099;
3128 -> 3125;
3128 -> 0;
3128 -> 2051;
3129 -> 3099;
3129 -> 3125;
3129 -> 2051;
3130 -> 3103;
3130 -> 3129;
3131 -> 3099;
3131 -> 3125;
3131 -> 2051;
3132 -> 2058;
3132 -> 2051;
3133 -> 2058;
3133 -> 2051;
3134 -> 3132;
3134 -> 2051;
3135 -> 2051;
3136 -> 3134;
3136 -> 3135;
3136 -> 3125;
3136 -> 2051;
3137 -> 3132;
3137 -> 2051;
3138 -> 3137;
3138 -> 3125;
3138 -> 3136;
3138 -> 2051;
3139 -> 2051;
3140 -> 3138;
3140 -> 3139;
3141 -> 3140;
3141 -> 3138;
3141 -> 3139;
3142 -> 3140;
3142 -> 3138;
3142 -> 3141;
3143 -> 3142;
3143 -> 3141;
3144 -> 3141;
3145 -> 3143;
3145 -> 3144;
3146 -> 3145;
3146 -> 3138;
3146 -> 0;
3146 -> 3144;
3147 -> 3145;
3147 -> 3138;
3147 -> 3144;
3148 -> 3144;
3149 -> 3147;
3149 -> 3148;
3150 -> 3148;
3151 -> 3149;
3151 -> 3150;
3151 -> 3148;
3152 -> 3151;
3153 -> 3149;
3153 -> 3138;
3153 -> 3151;
3154 -> 3148;
3155 -> 3154;
3155 -> 3144;
3156 -> 3146;
3156 -> 3155;
3156 -> 3144;
3157 -> 3139;
3158 -> 3157;
3158 -> 2051;
3159 -> 3138;
3159 -> 3158;
3159 -> 2051;
3160 -> 3132;
3160 -> 2051;
3161 -> 3159;
3161 -> 2051;
3162 -> 2051;
3163 -> 3161;
3163 -> 3162;
3164 -> 3163;
3164 -> 3161;
3164 -> 3162;
3165 -> 3163;
3165 -> 3161;
3165 -> 3164;
3166 -> 3165;
3166 -> 3164;
3167 -> 3164;
3168 -> 3166;
3168 -> 3167;
3169 -> 3168;
3169 -> 3161;
3169 -> 0;
3169 -> 3167;
3170 -> 3168;
3170 -> 3161;
3170 -> 3167;
3171 -> 3167;
3172 -> 3170;
3172 -> 3171;
3173 -> 3171;
3174 -> 3172;
3174 -> 3173;
3174 -> 3171;
3175 -> 3174;
3176 -> 3172;
3176 -> 3161;
3176 -> 3174;
3177 -> 3171;
3178 -> 3177;
3178 -> 3167;
3179 -> 3169;
3179 -> 3178;
3179 -> 3167;
3180 -> 3162;
3181 -> 3159;
3181 -> 2051;
3182 -> 3132;
3182 -> 3181;
3183 -> 3181;
3184 -> 3182;
3184 -> 3183;
3184 -> 3125;
3184 -> 3161;
3184 -> 3181;
3185 -> 3059;
3185 -> 3184;
3186 -> 3060;
3186 -> 3184;
3187 -> 3185;
3187 -> 3184;
3188 -> 3186;
3188 -> 3184;
3189 -> 3184;
3190 -> 3184;
3191 -> 3184;
3192 -> 3188;
3192 -> 3191;
3192 -> 3184;
3193 -> 3184;
3194 -> 3184;
3194 -> 3193;
3195 -> 3184;
3195 -> 0;
3196 -> 3184;
3197 -> 3190;
3197 -> 3196;
3198 -> 3197;
3199 -> 3197;
3200 -> 3184;
3200 -> 3197;
3201 -> 3197;
3202 -> 3200;
3202 -> 3201;
3203 -> 3201;
3204 -> 3202;
3204 -> 3203;
3205 -> 3203;
3206 -> 3204;
3206 -> 3205;
3206 -> 3203;
3207 -> 3203;
3208 -> 3207;
3208 -> 3201;
3209 -> 3184;
3209 -> 3208;
3210 -> 3184;
3211 -> 2058;
3211 -> 2051;
3212 -> 2058;
3212 -> 2051;
3213 -> 2058;
3213 -> 2051;
3214 -> 3211;
3214 -> 3184;
3214 -> 2051;
3215 -> 2051;
3216 -> 3214;
3216 -> 3215;
3216 -> 2051;
3217 -> 3212;
3217 -> 0;
3217 -> 3216;
3218 -> 3214;
3218 -> 3212;
3218 -> 3216;
3219 -> 3212;
3219 -> 0;
3219 -> 3218;
3220 -> 3059;
3220 -> 3218;
3221 -> 3060;
3221 -> 3218;
3222 -> 3220;
3222 -> 3218;
3223 -> 3221;
3223 -> 3218;
3224 -> 3218;
3225 -> 3218;
3226 -> 3218;
3227 -> 3223;
3227 -> 3226;
3227 -> 3218;
3228 -> 3218;
3229 -> 3218;
3229 -> 3228;
3230 -> 3218;
3230 -> 0;
3231 -> 3218;
3232 -> 3225;
3232 -> 3231;
3233 -> 3232;
3234 -> 3232;
3235 -> 3218;
3235 -> 3232;
3236 -> 3232;
3237 -> 3235;
3237 -> 3236;
3238 -> 3236;
3239 -> 3237;
3239 -> 3238;
3240 -> 3238;
3241 -> 3239;
3241 -> 3240;
3241 -> 3238;
3242 -> 3238;
3243 -> 3242;
3243 -> 3236;
3244 -> 3218;
3244 -> 3243;
3245 -> 3218;
3246 -> 3099;
3246 -> 3218;
3246 -> 2051;
3247 -> 3099;
3247 -> 3218;
3247 -> 3246;
3248 -> 3099;
3248 -> 3218;
3248 -> 0;
3248 -> 2051;
3249 -> 3099;
3249 -> 3218;
3249 -> 2051;
3250 -> 3103;
3250 -> 3249;
3251 -> 3099;
3251 -> 3218;
3251 -> 2051;
3252 -> 3115;
3252 -> 3218;
3252 -> 2051;
3253 -> 3218;
3253 -> 3139;
3254 -> 3253;
3254 -> 3218;
3254 -> 3139;
3255 -> 3253;
3255 -> 3218;
3255 -> 3254;
3256 -> 3255;
3256 -> 3254;
3257 -> 3254;
3258 -> 3256;
3258 -> 3257;
3259 -> 3258;
3259 -> 3218;
3259 -> 0;
3259 -> 3257;
3260 -> 3258;
3260 -> 3218;
3260 -> 3257;
3261 -> 3257;
3262 -> 3260;
3262 -> 3261;
3263 -> 3261;
3264 -> 3262;
3264 -> 3263;
3264 -> 3261;
3265 -> 3264;
3266 -> 3262;
3266 -> 3218;
3266 -> 3264;
3267 -> 3261;
3268 -> 3267;
3268 -> 3257;
3269 -> 3259;
3269 -> 3268;
3269 -> 3257;
3270 -> 3218;
3270 -> 3162;
3271 -> 3270;
3271 -> 3218;
3271 -> 3162;
3272 -> 3270;
3272 -> 3218;
3272 -> 3271;
3273 -> 3272;
3273 -> 3271;
3274 -> 3271;
3275 -> 3273;
3275 -> 3274;
3276 -> 3275;
3276 -> 3218;
3276 -> 0;
3276 -> 3274;
3277 -> 3275;
3277 -> 3218;
3277 -> 3274;
3278 -> 3274;
3279 -> 3277;
3279 -> 3278;
3280 -> 3278;
3281 -> 3279;
3281 -> 3280;
3281 -> 3278;
3282 -> 3281;
3283 -> 3279;
3283 -> 3218;
3283 -> 3281;
3284 -> 3278;
3285 -> 3284;
3285 -> 3274;
3286 -> 3276;
3286 -> 3285;
3286 -> 3274;
3287 -> 3027;
3287 -> 3218;
3287 -> 3026;
3288 -> 3287;
3288 -> 3218;
3288 -> 3026;
3289 -> 3027;
3289 -> 3218;
3289 -> 3026;
3290 -> 3030;
3290 -> 3289;
3291 -> 3027;
3291 -> 3218;
3291 -> 3290;
3292 -> 3287;
3292 -> 3290;
3293 -> 3290;
3294 -> 3292;
3294 -> 3293;
3295 -> 3293;
3296 -> 3294;
3296 -> 3295;
3296 -> 3293;
3297 -> 3296;
3298 -> 3294;
3298 -> 3218;
3298 -> 3296;
3299 -> 3293;
3300 -> 3299;
3300 -> 3290;
3301 -> 3291;
3301 -> 3300;
3301 -> 3290;
3302 -> 3027;
3302 -> 3301;
3303 -> 3027;
3303 -> 3218;
3303 -> 3301;
3304 -> 3031;
3304 -> 3218;
3304 -> 3052;
3304 -> 3026;
3305 -> 3241;
3306 -> 3239;
3306 -> 3218;
3306 -> 3241;
3307 -> 2058;
3307 -> 2051;
3308 -> 3307;
3308 -> 3218;
3308 -> 2051;
3309 -> 2051;
3310 -> 2813;
3310 -> 3308;
3311 -> 3310;
3311 -> 3308;
3312 -> 3308;
3313 -> 3308;
3314 -> 2878;
3314 -> 3313;
3314 -> 2051;
3315 -> 2880;
3315 -> 3314;
3315 -> 3313;
3315 -> 2051;
3316 -> 2058;
3316 -> 2051;
3317 -> 3316;
3317 -> 2051;
3318 -> 3317;
3318 -> 3316;
3318 -> 3313;
3318 -> 2051;
3319 -> 2051;
3320 -> 2908;
3320 -> 3318;
3320 -> 2051;
3321 -> 2915;
3321 -> 3318;
3321 -> 2051;
3322 -> 3321;
3322 -> 2918;
3323 -> 2924;
3323 -> 3318;
3323 -> 2051;
3324 -> 3323;
3324 -> 2927;
3325 -> 3324;
3325 -> 2927;
3326 -> 3325;
3326 -> 2932;
3327 -> 3318;
3327 -> 2935;
3328 -> 3327;
3328 -> 2932;
3329 -> 3318;
3329 -> 2932;
3330 -> 3329;
3331 -> 3328;
3331 -> 3330;
3331 -> 3329;
3332 -> 3331;
3333 -> 2058;
3333 -> 3318;
3333 -> 2051;
3334 -> 2051;
3335 -> 3334;
3336 -> 3335;
3337 -> 3336;
3338 -> 2058;
3338 -> 3337;
3339 -> 3338;
3339 -> 3318;
3339 -> 3337;
3340 -> 3338;
3340 -> 3318;
3340 -> 3337;
3341 -> 3340;
3341 -> 3336;
3342 -> 3334;
3343 -> 3318;
3343 -> 2051;
3344 -> 2051;
3345 -> 2058;
3345 -> 2051;
3346 -> 2058;
3346 -> 2051;
3347 -> 2058;
3347 -> 2051;
3348 -> 3346;
3348 -> 3345;
3348 -> 2051;
3349 -> 3348;
3350 -> 2058;
3350 -> 3349;
3350 -> 3318;
3350 -> 2021;
3351 -> 2058;
3351 -> 2051;
3352 -> 2058;
3352 -> 2051;
3353 -> 3352;
3353 -> 3350;
3353 -> 2051;
3354 -> 3352;
3354 -> 3350;
3354 -> 2051;
3355 -> 3354;
3356 -> 3352;
3356 -> 3355;
3357 -> 3356;
3357 -> 3350;
3357 -> 3355;
3358 -> 3355;
3359 -> 3356;
3359 -> 3350;
3359 -> 3355;
3360 -> 3357;
3360 -> 3350;
3360 -> 3359;
3361 -> 3359;
3362 -> 3361;
3362 -> 3360;
3362 -> 3350;
3362 -> 3359;
3363 -> 3356;
3363 -> 3350;
3363 -> 3355;
3364 -> 3355;
3365 -> 3357;
3365 -> 3350;
3365 -> 3364;
3366 -> 3365;
3366 -> 3355;
3367 -> 3357;
3367 -> 3355;
3368 -> 3358;
3368 -> 3355;
3369 -> 3355;
3370 -> 3367;
3370 -> 3369;
3371 -> 3368;
3371 -> 3369;
3372 -> 3369;
3373 -> 3372;
3373 -> 3369;
3374 -> 3370;
3374 -> 3350;
3374 -> 3369;
3375 -> 3371;
3375 -> 3369;
3376 -> 3369;
3377 -> 3373;
3377 -> 3376;
3378 -> 3374;
3378 -> 3376;
3379 -> 3375;
3379 -> 3376;
3380 -> 3376;
3381 -> 3378;
3381 -> 3380;
3381 -> 3376;
3382 -> 3369;
3383 -> 3369;
3384 -> 3370;
3384 -> 3374;
3384 -> 3383;
3385 -> 3384;
3385 -> 3369;
3386 -> 3372;
3386 -> 3385;
3387 -> 3370;
3387 -> 3374;
3387 -> 3385;
3388 -> 3371;
3388 -> 3385;
3389 -> 3385;
3390 -> 3386;
3390 -> 3389;
3391 -> 3387;
3391 -> 3389;
3392 -> 3388;
3392 -> 3389;
3393 -> 3389;
3394 -> 3391;
3394 -> 3393;
3394 -> 3389;
3395 -> 3385;
3396 -> 3372;
3396 -> 3369;
3397 -> 3396;
3397 -> 3355;
3398 -> 3358;
3398 -> 3355;
3399 -> 3398;
3399 -> 3354;
3400 -> 3399;
3400 -> 3352;
3400 -> 3354;
3401 -> 3354;
3402 -> 3352;
3402 -> 3387;
3402 -> 3400;
3402 -> 3398;
3402 -> 3401;
3402 -> 3354;
3403 -> 3352;
3403 -> 3387;
3403 -> 3400;
3403 -> 2051;
3404 -> 2058;
3404 -> 2051;
3405 -> 2058;
3405 -> 2051;
3406 -> 2058;
3406 -> 2051;
3407 -> 3406;
3407 -> 3403;
3407 -> 2051;
3408 -> 3407;
3408 -> 3403;
3408 -> 2051;
3409 -> 2051;
3410 -> 3409;
3410 -> 3408;
3410 -> 2051;
3411 -> 2058;
3411 -> 2051;
3412 -> 0;
3412 -> 2051;
3413 -> 2058;
3413 -> 3412;
3413 -> 3403;
3413 -> 0;
3413 -> 2021;
3414 -> 2058;
3414 -> 2051;
3415 -> 3414;
3415 -> 3413;
3415 -> 2051;
3416 -> 2058;
3416 -> 2051;
3417 -> 3416;
3417 -> 3415;
3417 -> 2051;
3418 -> 3352;
3418 -> 3417;
3418 -> 2051;
3419 -> 3099;
3419 -> 3417;
3419 -> 2051;
3420 -> 3099;
3420 -> 3417;
3420 -> 3419;
3421 -> 3099;
3421 -> 3417;
3421 -> 0;
3421 -> 2051;
3422 -> 3099;
3422 -> 3417;
3422 -> 2051;
3423 -> 3103;
3423 -> 3422;
3424 -> 3099;
3424 -> 3417;
3424 -> 2051;
3425 -> 2058;
3425 -> 2051;
3426 -> 3425;
3426 -> 3417;
3426 -> 2051;
3427 -> 2058;
3427 -> 2051;
3428 -> 3427;
3428 -> 3426;
3428 -> 2051;
3429 -> 0;
3429 -> 3428;
3430 -> 3115;
3430 -> 3429;
3430 -> 2051;
3431 -> 3099;
3431 -> 3429;
3431 -> 2051;
3432 -> 3099;
3432 -> 3429;
3432 -> 3431;
3433 -> 3099;
3433 -> 3429;
3433 -> 0;
3433 -> 2051;
3434 -> 3099;
3434 -> 3429;
3434 -> 2051;
3435 -> 3103;
3435 -> 3434;
3436 -> 3099;
3436 -> 3429;
3436 -> 2051;
3437 -> 3429;
3437 -> 0;
3437 -> 2987;
3438 -> 3429;
3439 -> 3438;
3439 -> 3429;
3440 -> 3429;
3440 -> 2987;
3441 -> 3027;
3441 -> 3429;
3441 -> 3026;
3442 -> 3441;
3442 -> 3429;
3442 -> 3026;
3443 -> 3027;
3443 -> 3429;
3443 -> 3026;
3444 -> 3030;
3444 -> 3443;
3445 -> 3027;
3445 -> 3429;
3445 -> 3444;
3446 -> 3441;
3446 -> 3444;
3447 -> 3444;
3448 -> 3446;
3448 -> 3447;
3449 -> 3447;
3450 -> 3448;
3450 -> 3449;
3450 -> 3447;
3451 -> 3450;
3452 -> 3448;
3452 -> 3429;
3452 -> 3450;
3453 -> 3447;
3454 -> 3453;
3454 -> 3444;
3455 -> 3445;
3455 -> 3454;
3455 -> 3444;
3456 -> 3027;
3456 -> 3455;
3457 -> 3027;
3457 -> 3429;
3457 -> 3455;
3458 -> 3031;
3458 -> 3429;
3458 -> 3052;
3458 -> 3026;
3459 -> 3429;
3459 -> 3139;
3460 -> 3459;
3460 -> 3429;
3460 -> 3139;
3461 -> 3459;
3461 -> 3429;
3461 -> 3460;
3462 -> 3461;
3462 -> 3460;
3463 -> 3460;
3464 -> 3462;
3464 -> 3463;
3465 -> 3464;
3465 -> 3429;
3465 -> 0;
3465 -> 3463;
3466 -> 3464;
3466 -> 3429;
3466 -> 3463;
3467 -> 3463;
3468 -> 3466;
3468 -> 3467;
3469 -> 3467;
3470 -> 3468;
3470 -> 3469;
3470 -> 3467;
3471 -> 3470;
3472 -> 3468;
3472 -> 3429;
3472 -> 3470;
3473 -> 3467;
3474 -> 3473;
3474 -> 3463;
3475 -> 3465;
3475 -> 3474;
3475 -> 3463;
3476 -> 3429;
3476 -> 3162;
3477 -> 3476;
3477 -> 3429;
3477 -> 3162;
3478 -> 3476;
3478 -> 3429;
3478 -> 3477;
3479 -> 3478;
3479 -> 3477;
3480 -> 3477;
3481 -> 3479;
3481 -> 3480;
3482 -> 3481;
3482 -> 3429;
3482 -> 0;
3482 -> 3480;
3483 -> 3481;
3483 -> 3429;
3483 -> 3480;
3484 -> 3480;
3485 -> 3483;
3485 -> 3484;
3486 -> 3484;
3487 -> 3485;
3487 -> 3486;
3487 -> 3484;
3488 -> 3487;
3489 -> 3485;
3489 -> 3429;
3489 -> 3487;
3490 -> 3484;
3491 -> 3490;
3491 -> 3480;
3492 -> 3482;
3492 -> 3491;
3492 -> 3480;
3493 -> 3059;
3493 -> 3429;
3494 -> 3060;
3494 -> 3429;
3495 -> 3493;
3495 -> 3429;
3496 -> 3494;
3496 -> 3429;
3497 -> 3429;
3498 -> 3429;
3499 -> 3429;
3500 -> 3496;
3500 -> 3499;
3500 -> 3429;
3501 -> 3429;
3502 -> 3429;
3502 -> 3501;
3503 -> 3429;
3503 -> 0;
3504 -> 3429;
3505 -> 3498;
3505 -> 3504;
3506 -> 3505;
3507 -> 3505;
3508 -> 3429;
3508 -> 3505;
3509 -> 3505;
3510 -> 3508;
3510 -> 3509;
3511 -> 3509;
3512 -> 3510;
3512 -> 3511;
3513 -> 3511;
3514 -> 3512;
3514 -> 3513;
3514 -> 3511;
3515 -> 3511;
3516 -> 3515;
3516 -> 3509;
3517 -> 3429;
3517 -> 3516;
3518 -> 3429;
3519 -> 3212;
3519 -> 0;
3519 -> 3429;
3520 -> 0;
3520 -> 3519;
3521 -> 3520;
3521 -> 3213;
3521 -> 3429;
3521 -> 3519;
3522 -> 3519;
3523 -> 3522;
3524 -> 3521;
3524 -> 3523;
3525 -> 3524;
3525 -> 3522;
3526 -> 3027;
3526 -> 3521;
3526 -> 3026;
3527 -> 3526;
3527 -> 3521;
3527 -> 3026;
3528 -> 3027;
3528 -> 3521;
3528 -> 3026;
3529 -> 3030;
3529 -> 3528;
3530 -> 3027;
3530 -> 3521;
3530 -> 3529;
3531 -> 3526;
3531 -> 3529;
3532 -> 3529;
3533 -> 3531;
3533 -> 3532;
3534 -> 3532;
3535 -> 3533;
3535 -> 3534;
3535 -> 3532;
3536 -> 3535;
3537 -> 3533;
3537 -> 3521;
3537 -> 3535;
3538 -> 3532;
3539 -> 3538;
3539 -> 3529;
3540 -> 3530;
3540 -> 3539;
3540 -> 3529;
3541 -> 3027;
3541 -> 3540;
3542 -> 3027;
3542 -> 3521;
3542 -> 3540;
3543 -> 3031;
3543 -> 3521;
3543 -> 3052;
3543 -> 3026;
3544 -> 3099;
3544 -> 3521;
3544 -> 2051;
3545 -> 3099;
3545 -> 3521;
3545 -> 3544;
3546 -> 3099;
3546 -> 3521;
3546 -> 0;
3546 -> 2051;
3547 -> 3099;
3547 -> 3521;
3547 -> 2051;
3548 -> 3103;
3548 -> 3547;
3549 -> 3099;
3549 -> 3521;
3549 -> 2051;
3550 -> 3115;
3550 -> 3521;
3550 -> 2051;
3551 -> 3059;
3551 -> 3521;
3552 -> 3060;
3552 -> 3521;
3553 -> 3551;
3553 -> 3521;
3554 -> 3552;
3554 -> 3521;
3555 -> 3521;
3556 -> 3521;
3557 -> 3521;
3558 -> 3554;
3558 -> 3557;
3558 -> 3521;
3559 -> 3521;
3560 -> 3521;
3560 -> 3559;
3561 -> 3521;
3561 -> 0;
3562 -> 3521;
3563 -> 3556;
3563 -> 3562;
3564 -> 3563;
3565 -> 3563;
3566 -> 3521;
3566 -> 3563;
3567 -> 3563;
3568 -> 3566;
3568 -> 3567;
3569 -> 3567;
3570 -> 3568;
3570 -> 3569;
3571 -> 3569;
3572 -> 3570;
3572 -> 3571;
3572 -> 3569;
3573 -> 3569;
3574 -> 3573;
3574 -> 3567;
3575 -> 3521;
3575 -> 3574;
3576 -> 3521;
3577 -> 3521;
3577 -> 3139;
3578 -> 3577;
3578 -> 3521;
3578 -> 3139;
3579 -> 3577;
3579 -> 3521;
3579 -> 3578;
3580 -> 3579;
3580 -> 3578;
3581 -> 3578;
3582 -> 3580;
3582 -> 3581;
3583 -> 3582;
3583 -> 3521;
3583 -> 0;
3583 -> 3581;
3584 -> 3582;
3584 -> 3521;
3584 -> 3581;
3585 -> 3581;
3586 -> 3584;
3586 -> 3585;
3587 -> 3585;
3588 -> 3586;
3588 -> 3587;
3588 -> 3585;
3589 -> 3588;
3590 -> 3586;
3590 -> 3521;
3590 -> 3588;
3591 -> 3585;
3592 -> 3591;
3592 -> 3581;
3593 -> 3583;
3593 -> 3592;
3593 -> 3581;
3594 -> 3521;
3594 -> 3162;
3595 -> 3594;
3595 -> 3521;
3595 -> 3162;
3596 -> 3594;
3596 -> 3521;
3596 -> 3595;
3597 -> 3596;
3597 -> 3595;
3598 -> 3595;
3599 -> 3597;
3599 -> 3598;
3600 -> 3599;
3600 -> 3521;
3600 -> 0;
3600 -> 3598;
3601 -> 3599;
3601 -> 3521;
3601 -> 3598;
3602 -> 3598;
3603 -> 3601;
3603 -> 3602;
3604 -> 3602;
3605 -> 3603;
3605 -> 3604;
3605 -> 3602;
3606 -> 3605;
3607 -> 3603;
3607 -> 3521;
3607 -> 3605;
3608 -> 3602;
3609 -> 3608;
3609 -> 3598;
3610 -> 3600;
3610 -> 3609;
3610 -> 3598;
3611 -> 3572;
3612 -> 3570;
3612 -> 3521;
3612 -> 3572;
3613 -> 2058;
3613 -> 3521;
3613 -> 2051;
3614 -> 3338;
3614 -> 3521;
3614 -> 3337;
3615 -> 3338;
3615 -> 3521;
3615 -> 3337;
3616 -> 3615;
3616 -> 3336;
3617 -> 3521;
3617 -> 2051;
3618 -> 2058;
3618 -> 2051;
3619 -> 2051;
3620 -> 2051;
3621 -> 3618;
3621 -> 3521;
3621 -> 2051;
3622 -> 3620;
3622 -> 3621;
3622 -> 3521;
3622 -> 2051;
3623 -> 2051;
3624 -> 2051;
3625 -> 3620;
3625 -> 3622;
3625 -> 3624;
3625 -> 2051;
3626 -> 3620;
3626 -> 3622;
3626 -> 3625;
3627 -> 3626;
3627 -> 3625;
3628 -> 3626;
3628 -> 3627;
3629 -> 3627;
3630 -> 3628;
3630 -> 3629;
3631 -> 3618;
3631 -> 3629;
3632 -> 3630;
3632 -> 3626;
3632 -> 3629;
3633 -> 3631;
3633 -> 3626;
3633 -> 3632;
3633 -> 3629;
3634 -> 3629;
3635 -> 3629;
3636 -> 3630;
3636 -> 3626;
3636 -> 3629;
3637 -> 3636;
3638 -> 3635;
3638 -> 3637;
3638 -> 3636;
3639 -> 3636;
3639 -> 3638;
3640 -> 3639;
3640 -> 3629;
3641 -> 3627;
3642 -> 3640;
3642 -> 3641;
3642 -> 3627;
3643 -> 3626;
3643 -> 3642;
3644 -> 3643;
3644 -> 3626;
3645 -> 3643;
3645 -> 3644;
3646 -> 3645;
3647 -> 3645;
3648 -> 3646;
3648 -> 3647;
3649 -> 3618;
3649 -> 3647;
3650 -> 3648;
3650 -> 3645;
3650 -> 3647;
3651 -> 3649;
3651 -> 3645;
3651 -> 3650;
3651 -> 3647;
3652 -> 3647;
3653 -> 3645;
3654 -> 3648;
3654 -> 3653;
3654 -> 3645;
3655 -> 3619;
3655 -> 3654;
3656 -> 3648;
3656 -> 3654;
3657 -> 3645;
3657 -> 3654;
3658 -> 3654;
3659 -> 3655;
3659 -> 3658;
3660 -> 3656;
3660 -> 3658;
3661 -> 3657;
3661 -> 3658;
3662 -> 3618;
3662 -> 3658;
3663 -> 3660;
3663 -> 3657;
3663 -> 3658;
3664 -> 3663;
3664 -> 3658;
3665 -> 3660;
3665 -> 3663;
3665 -> 3658;
3666 -> 3662;
3666 -> 3663;
3666 -> 3664;
3666 -> 3665;
3666 -> 3658;
3667 -> 3658;
3668 -> 3666;
3668 -> 3667;
3668 -> 3658;
3669 -> 3654;
3670 -> 3645;
3670 -> 3666;
3670 -> 3654;
3671 -> 3619;
3671 -> 2051;
3672 -> 2058;
3672 -> 3671;
3672 -> 3666;
3672 -> 3619;
3672 -> 2021;
3673 -> 2809;
3673 -> 3672;
3673 -> 2808;
3674 -> 2809;
3674 -> 3672;
3674 -> 2808;
3675 -> 3674;
3675 -> 2806;
3676 -> 3672;
3676 -> 2021;
3677 -> 2021;
3678 -> 2021;
3679 -> 2025;
3679 -> 3678;
3679 -> 2021;
3680 -> 2032;
3680 -> 2021;
3681 -> 3680;
3681 -> 3672;
3681 -> 2021;
3682 -> 2012;
3682 -> 3681;
3682 -> 2011;
3683 -> 2011;
3684 -> 3682;
3684 -> 3683;
3685 -> 3681;
3685 -> 3684;
3686 -> 2015;
3686 -> 3684;
3687 -> 2014;
3687 -> 3684;
3688 -> 3684;
3689 -> 3685;
3689 -> 3688;
3689 -> 3686;
3689 -> 3687;
3689 -> 1999;
3689 -> 3684;
3690 -> 26;
3690 -> 24;
3691 -> 24;
3692 -> 3689;
3692 -> 3691;
3692 -> 24;
3693 -> 0;
3693 -> 3689;
3693 -> 3691;
3693 -> 24;
3694 -> 24;
3695 -> 3691;
3695 -> 3694;
3696 -> 3695;
3696 -> 3694;
3697 -> 3694;
3698 -> 3696;
3698 -> 3697;
3699 -> 3697;
3700 -> 3698;
3700 -> 3699;
3700 -> 3697;
3701 -> 3697;
3701 -> 24;
3702 -> 3690;
3702 -> 3694;
3703 -> 3691;
3703 -> 3694;
3704 -> 3693;
3704 -> 3694;
3705 -> 3691;
3705 -> 3694;
3706 -> 3701;
3706 -> 3694;
3707 -> 3691;
3707 -> 3694;
3708 -> 3691;
3708 -> 3694;
3709 -> 3691;
3709 -> 3694;
3710 -> 3702;
3710 -> 3694;
3711 -> 3706;
3711 -> 3694;
3712 -> 3703;
3712 -> 3694;
3713 -> 3694;
3714 -> 3711;
3714 -> 3713;
3715 -> 3712;
3715 -> 3713;
3716 -> 3714;
3716 -> 3713;
3717 -> 3713;
3718 -> 3716;
3718 -> 3717;
3719 -> 3718;
3719 -> 3717;
3720 -> 3719;
3721 -> 0;
3721 -> 3720;
3722 -> 3721;
3723 -> 3722;
3724 -> 3723;
3724 -> 3689;
3724 -> 3722;
3725 -> 3713;
3726 -> 3715;
3726 -> 3725;
3726 -> 3713;
3727 -> 3724;
3727 -> 3713;
3728 -> 3715;
3728 -> 3713;
3729 -> 3713;
3730 -> 3727;
3730 -> 3729;
3731 -> 3728;
3731 -> 3729;
3732 -> 3730;
3732 -> 3729;
3733 -> 3729;
3734 -> 3732;
3734 -> 3733;
3735 -> 3734;
3735 -> 3733;
3736 -> 3735;
3737 -> 3735;
3738 -> 3736;
3738 -> 3737;
3739 -> 3738;
3739 -> 3737;
3740 -> 3739;
3741 -> 3740;
3741 -> 3739;
3742 -> 3735;
3743 -> 3741;
3743 -> 3742;
3743 -> 3735;
3744 -> 3743;
3745 -> 3741;
3745 -> 3743;
3746 -> 3740;
3747 -> 3740;
3748 -> 3746;
3748 -> 3747;
3748 -> 3740;
3749 -> 3746;
3749 -> 3748;
3750 -> 3746;
3751 -> 3746;
3751 -> 3750;
3752 -> 0;
3752 -> 3729;
3753 -> 3731;
3753 -> 3729;
3754 -> 3753;
3754 -> 3691;
3754 -> 3692;
3754 -> 3729;
3755 -> 3754;
3756 -> 3730;
3756 -> 3755;
3756 -> 3689;
3756 -> 3691;
3756 -> 3692;
3756 -> 3746;
3756 -> 3724;
3756 -> 3754;
3757 -> 3754;
3758 -> 3754;
3759 -> 3757;
3759 -> 3758;
3760 -> 3759;
3760 -> 3758;
3761 -> 3760;
3761 -> 3756;
3761 -> 3758;
3762 -> 3754;
3763 -> 3761;
3763 -> 3762;
3763 -> 3754;
3764 -> 3761;
3764 -> 3754;
3765 -> 3744;
3765 -> 3764;
3765 -> 3745;
3765 -> 3749;
3765 -> 3751;
3765 -> 0;
3765 -> 3754;
3766 -> 3713;
3767 -> 3715;
3767 -> 3713;
3768 -> 3724;
3768 -> 3767;
3768 -> 3689;
3768 -> 3761;
3768 -> 3713;
3769 -> 3705;
3769 -> 3694;
3770 -> 3707;
3770 -> 3694;
3771 -> 3708;
3771 -> 3694;
3772 -> 3709;
3772 -> 3694;
3773 -> 3694;
3774 -> 3710;
3774 -> 3773;
3775 -> 3769;
3775 -> 3773;
3776 -> 3770;
3776 -> 3773;
3777 -> 3771;
3777 -> 3773;
3778 -> 3772;
3778 -> 3773;
3779 -> 3774;
3779 -> 3773;
3780 -> 3775;
3780 -> 3773;
3781 -> 3776;
3781 -> 3773;
3782 -> 3777;
3782 -> 3773;
3783 -> 3778;
3783 -> 3773;
3784 -> 3773;
3785 -> 3784;
3785 -> 3773;
3786 -> 3773;
3787 -> 3779;
3787 -> 3786;
3788 -> 3780;
3788 -> 3786;
3789 -> 3781;
3789 -> 3786;
3790 -> 3782;
3790 -> 3786;
3791 -> 3783;
3791 -> 3786;
3792 -> 3785;
3792 -> 3786;
3793 -> 3788;
3793 -> 3786;
3794 -> 3790;
3794 -> 3786;
3795 -> 3786;
3796 -> 3793;
3796 -> 3795;
3797 -> 3794;
3797 -> 3795;
3798 -> 3787;
3798 -> 3795;
3799 -> 3798;
3799 -> 3690;
3799 -> 3795;
3800 -> 3799;
3801 -> 3797;
3801 -> 3799;
3802 -> 3796;
3802 -> 3799;
3803 -> 3799;
3804 -> 3800;
3804 -> 3803;
3805 -> 3801;
3805 -> 3803;
3806 -> 3802;
3806 -> 3803;
3807 -> 3800;
3807 -> 3803;
3808 -> 3803;
3809 -> 3806;
3809 -> 3808;
3809 -> 3803;
3810 -> 0;
3810 -> 3809;
3811 -> 3804;
3811 -> 3803;
3812 -> 0;
3812 -> 3803;
3813 -> 3812;
3813 -> 3807;
3813 -> 3803;
3814 -> 3803;
3815 -> 3811;
3815 -> 3813;
3815 -> 3814;
3815 -> 3768;
3815 -> 3803;
3816 -> 3810;
3816 -> 3803;
3817 -> 3805;
3817 -> 3803;
3818 -> 3803;
3819 -> 3803;
3820 -> 3819;
3821 -> 3819;
3822 -> 3815;
3822 -> 3821;
3822 -> 3819;
3823 -> 3820;
3823 -> 3819;
3824 -> 3819;
3825 -> 3822;
3825 -> 3815;
3825 -> 3821;
3825 -> 3823;
3825 -> 3824;
3825 -> 3820;
3825 -> 3819;
3826 -> 3819;
3827 -> 3826;
3827 -> 3820;
3827 -> 3819;
3828 -> 3820;
3828 -> 3819;
3829 -> 3819;
3830 -> 3828;
3830 -> 3829;
3830 -> 3820;
3830 -> 3827;
3830 -> 3819;
3831 -> 3800;
3831 -> 3786;
3832 -> 3786;
3833 -> 3704;
3833 -> 3832;
3833 -> 3786;
3834 -> 0;
3834 -> 3786;
3835 -> 3792;
3835 -> 3786;
3836 -> 3789;
3836 -> 3831;
3836 -> 3768;
3836 -> 3704;
3836 -> 3786;
3837 -> 3836;
3837 -> 3786;
3838 -> 3786;
3839 -> 3837;
3839 -> 3838;
3840 -> 0;
3840 -> 3838;
3841 -> 3840;
3842 -> 3786;
3843 -> 3786;
3844 -> 3843;
3845 -> 3843;
3846 -> 3843;
3847 -> 3845;
3847 -> 3846;
3848 -> 3845;
3848 -> 3846;
3849 -> 3845;
3849 -> 3846;
3850 -> 3845;
3850 -> 3846;
3851 -> 3846;
3852 -> 3836;
3852 -> 3851;
3852 -> 3846;
3853 -> 3850;
3853 -> 3846;
3854 -> 3847;
3854 -> 3846;
3855 -> 3848;
3855 -> 3846;
3856 -> 3849;
3856 -> 3846;
3857 -> 3850;
3857 -> 3846;
3858 -> 3846;
3859 -> 0;
3859 -> 3846;
3860 -> 3846;
3861 -> 3859;
3861 -> 3860;
3862 -> 3859;
3862 -> 3860;
3863 -> 3857;
3863 -> 3860;
3864 -> 3858;
3864 -> 3860;
3865 -> 3858;
3865 -> 3860;
3866 -> 3861;
3866 -> 3860;
3867 -> 3862;
3867 -> 3860;
3868 -> 3863;
3868 -> 3860;
3869 -> 3860;
3870 -> 3869;
3870 -> 3860;
3871 -> 3864;
3871 -> 3869;
3871 -> 3860;
3872 -> 3846;
3873 -> 3854;
3873 -> 3872;
3874 -> 3855;
3874 -> 3872;
3875 -> 3856;
3875 -> 3872;
3876 -> 3857;
3876 -> 3872;
3877 -> 3858;
3877 -> 3872;
3878 -> 3858;
3878 -> 3872;
3879 -> 3858;
3879 -> 3872;
3880 -> 3858;
3880 -> 3872;
3881 -> 3858;
3881 -> 3872;
3882 -> 3858;
3882 -> 3872;
3883 -> 3873;
3883 -> 3872;
3884 -> 3874;
3884 -> 3872;
3885 -> 3875;
3885 -> 3872;
3886 -> 3876;
3886 -> 3872;
3887 -> 3877;
3887 -> 3872;
3888 -> 3878;
3888 -> 3872;
3889 -> 3879;
3889 -> 3872;
3890 -> 3880;
3890 -> 3872;
3891 -> 3881;
3891 -> 3872;
3892 -> 3872;
3893 -> 3883;
3893 -> 3892;
3894 -> 3884;
3894 -> 3892;
3895 -> 3885;
3895 -> 3892;
3896 -> 3886;
3896 -> 3892;
3897 -> 3887;
3897 -> 3892;
3898 -> 3888;
3898 -> 3892;
3899 -> 3889;
3899 -> 3892;
3900 -> 3890;
3900 -> 3892;
3901 -> 3891;
3901 -> 3892;
3902 -> 3882;
3902 -> 3892;
3903 -> 3896;
3903 -> 3892;
3904 -> 3900;
3904 -> 3892;
3905 -> 3901;
3905 -> 3892;
3906 -> 3892;
3907 -> 3906;
3907 -> 3892;
3908 -> 3906;
3908 -> 3892;
3909 -> 3906;
3909 -> 3892;
3910 -> 3906;
3910 -> 3892;
3911 -> 3906;
3911 -> 3892;
3912 -> 3906;
3912 -> 3892;
3913 -> 3906;
3913 -> 3892;
3914 -> 3906;
3914 -> 3892;
3915 -> 3906;
3915 -> 3892;
3916 -> 3906;
3916 -> 3892;
3917 -> 3906;
3917 -> 3892;
3918 -> 3906;
3918 -> 3892;
3919 -> 3906;
3919 -> 3892;
3920 -> 3906;
3920 -> 3892;
3921 -> 3906;
3921 -> 3892;
3922 -> 3906;
3922 -> 3892;
3923 -> 3906;
3923 -> 3892;
3924 -> 3906;
3924 -> 3892;
3925 -> 3906;
3925 -> 3892;
3926 -> 3906;
3926 -> 3892;
3927 -> 3906;
3927 -> 3892;
3928 -> 3906;
3928 -> 3892;
3929 -> 3906;
3929 -> 3892;
3930 -> 3906;
3930 -> 3892;
3931 -> 3906;
3931 -> 3892;
3932 -> 3906;
3932 -> 3892;
3933 -> 3892;
3934 -> 3933;
3934 -> 3906;
3934 -> 3892;
3935 -> 3906;
3935 -> 3892;
3936 -> 3906;
3936 -> 3892;
3937 -> 3892;
3938 -> 3892;
3939 -> 3936;
3939 -> 3938;
3940 -> 3937;
3940 -> 3938;
3941 -> 3940;
3941 -> 3938;
3942 -> 3940;
3942 -> 3938;
3943 -> 3940;
3943 -> 3938;
3944 -> 3939;
3944 -> 3940;
3944 -> 3938;
3945 -> 3937;
3945 -> 3906;
3945 -> 3892;
3946 -> 3906;
3946 -> 3892;
3947 -> 3892;
3948 -> 3947;
3949 -> 0;
3949 -> 3947;
3950 -> 3949;
3950 -> 3948;
3950 -> 3947;
3951 -> 3950;
3951 -> 3892;
3952 -> 3951;
3952 -> 3906;
3952 -> 3892;
3953 -> 3896;
3953 -> 3892;
3954 -> 3953;
3955 -> 3893;
3955 -> 3954;
3955 -> 3953;
3956 -> 3894;
3956 -> 3954;
3956 -> 3953;
3957 -> 3955;
3957 -> 3956;
3957 -> 3953;
3958 -> 3895;
3958 -> 3954;
3958 -> 3953;
3959 -> 3957;
3959 -> 3958;
3959 -> 3953;
3960 -> 3898;
3960 -> 3892;
3961 -> 3960;
3962 -> 3906;
3962 -> 3961;
3963 -> 3897;
3963 -> 3960;
3964 -> 3899;
3964 -> 3906;
3964 -> 3892;
3965 -> 3906;
3965 -> 3836;
3965 -> 3892;
3966 -> 3892;
3967 -> 3906;
3967 -> 3836;
3967 -> 3966;
3967 -> 3892;
3968 -> 3846;
3969 -> 3836;
3970 -> 3836;
3971 -> 3836;
3972 -> 3836;
3973 -> 3836;
3974 -> 3970;
3974 -> 3836;
3975 -> 3836;
3976 -> 3836;
3977 -> 3836;
3978 -> 3836;
3979 -> 3836;
3980 -> 3836;
3981 -> 3980;
3981 -> 3836;
3982 -> 3980;
3982 -> 3836;
3983 -> 3980;
3983 -> 3836;
3984 -> 3981;
3984 -> 3836;
3985 -> 3982;
3985 -> 3836;
3986 -> 3983;
3986 -> 3836;
3987 -> 3984;
3987 -> 3980;
3988 -> 3985;
3988 -> 3980;
3989 -> 3986;
3989 -> 3980;
3990 -> 3980;
3991 -> 3980;
3992 -> 3991;
3993 -> 3987;
3993 -> 3992;
3993 -> 3991;
3994 -> 3988;
3994 -> 3992;
3994 -> 3991;
3995 -> 3993;
3995 -> 3994;
3995 -> 3991;
3996 -> 3989;
3996 -> 3992;
3996 -> 3991;
3997 -> 3995;
3997 -> 3996;
3997 -> 3991;
3998 -> 3980;
3999 -> 3980;
4000 -> 3980;
4001 -> 3980;
4001 -> 3846;
4002 -> 3786;
4003 -> 4002;
4004 -> 4003;
4005 -> 4004;
4006 -> 3980;
4007 -> 3980;
4008 -> 4006;
4008 -> 3980;
4009 -> 4007;
4009 -> 3980;
4010 -> 4006;
4010 -> 3980;
4011 -> 4006;
4011 -> 3980;
4012 -> 3980;
4013 -> 4012;
4013 -> 0;
4013 -> 3980;
4014 -> 4006;
4014 -> 3980;
4015 -> 4006;
4015 -> 3980;
4016 -> 4006;
4016 -> 3980;
4017 -> 4006;
4017 -> 3980;
4018 -> 4006;
4018 -> 3980;
4019 -> 4006;
4019 -> 4002;
4020 -> 4002;
4021 -> 0;
4021 -> 4002;
4022 -> 3791;
4022 -> 4006;
4022 -> 3786;
4023 -> 3980;
4023 -> 24;
4024 -> 4023;
4024 -> 27;
4024 -> 4006;
4024 -> 11;
4024 -> 24;
4025 -> 24;
4026 -> 4025;
4027 -> 4025;
4028 -> 4026;
4028 -> 4027;
4029 -> 0;
4029 -> 4027;
4030 -> 4027;
4031 -> 4028;
4031 -> 4027;
4032 -> 4027;
4033 -> 4029;
4033 -> 4032;
4034 -> 4030;
4034 -> 4032;
4035 -> 4031;
4035 -> 4032;
4036 -> 4032;
4037 -> 4033;
4037 -> 4032;
4038 -> 4034;
4038 -> 4032;
4039 -> 4036;
4039 -> 4032;
4040 -> 4035;
4040 -> 4032;
4041 -> 4032;
4042 -> 4037;
4042 -> 4041;
4043 -> 4038;
4043 -> 4041;
4044 -> 4039;
4044 -> 4041;
4045 -> 4040;
4045 -> 4041;
4046 -> 4041;
4047 -> 4042;
4047 -> 0;
4047 -> 4041;
4048 -> 4047;
4048 -> 4043;
4048 -> 4041;
4049 -> 4048;
4050 -> 4049;
4051 -> 4050;
4052 -> 4048;
4053 -> 4024;
4054 -> 4024;
4055 -> 4048;
4056 -> 4024;
4057 -> 4042;
4057 -> 0;
4057 -> 4041;
4058 -> 4057;
4058 -> 4043;
4058 -> 4041;
4059 -> 4046;
4059 -> 4058;
4060 -> 4058;
4061 -> 4058;
4062 -> 4058;
4063 -> 4024;
4063 -> 4062;
4064 -> 4063;
4064 -> 4058;
4065 -> 4058;
4066 -> 4024;
4067 -> 4045;
4067 -> 4058;
4068 -> 4058;
4069 -> 4058;
4070 -> 4068;
4070 -> 4069;
4071 -> 4068;
4071 -> 4069;
4072 -> 4068;
4072 -> 4069;
4073 -> 4067;
4073 -> 4069;
4074 -> 4069;
4075 -> 4074;
4076 -> 4075;
4077 -> 4073;
4077 -> 4069;
4078 -> 4069;
4079 -> 4069;
4080 -> 4070;
4080 -> 4079;
4080 -> 4069;
4081 -> 4069;
4082 -> 4081;
4083 -> 4082;
4084 -> 4024;
4084 -> 4083;
4085 -> 4084;
4085 -> 4082;
4086 -> 4078;
4086 -> 4069;
4087 -> 4073;
4087 -> 4069;
4088 -> 4069;
4089 -> 4088;
4090 -> 4089;
4091 -> 4090;
4092 -> 4088;
4093 -> 4092;
4094 -> 4093;
4095 -> 4088;
4096 -> 4095;
4097 -> 4024;
4097 -> 4096;
4098 -> 4097;
4098 -> 4095;
4099 -> 4024;
4099 -> 4088;
4100 -> 4088;
4101 -> 4024;
4101 -> 4088;
4102 -> 4024;
4102 -> 4088;
4103 -> 4102;
4103 -> 4024;
4103 -> 4088;
4104 -> 4088;
4105 -> 4088;
4106 -> 4024;
4106 -> 4088;
4107 -> 4024;
4107 -> 4088;
4108 -> 4024;
4108 -> 4088;
4109 -> 4088;
4110 -> 4106;
4110 -> 4107;
4110 -> 4088;
4111 -> 4106;
4111 -> 4024;
4111 -> 4088;
4112 -> 4088;
4113 -> 4112;
4114 -> 4113;
4115 -> 4113;
4116 -> 4115;
4117 -> 4112;
4118 -> 4117;
4119 -> 4107;
4119 -> 4111;
4119 -> 4088;
4120 -> 4088;
4121 -> 4120;
4122 -> 4121;
4123 -> 4121;
4124 -> 4123;
4125 -> 4120;
4126 -> 4125;
4127 -> 4106;
4127 -> 4119;
4127 -> 4107;
4127 -> 4088;
4128 -> 4111;
4128 -> 4088;
4129 -> 4119;
4129 -> 4088;
4130 -> 4088;
4131 -> 4129;
4131 -> 4130;
4131 -> 4088;
4132 -> 4129;
4132 -> 4131;
4133 -> 4106;
4133 -> 4132;
4133 -> 4107;
4133 -> 4088;
4134 -> 4024;
4134 -> 0;
4134 -> 4088;
4135 -> 4088;
4136 -> 4132;
4137 -> 4136;
4137 -> 4132;
4138 -> 4132;
4138 -> 4024;
4138 -> 4088;
4139 -> 4024;
4139 -> 4132;
4139 -> 4088;
4140 -> 4088;
4141 -> 4140;
4142 -> 4141;
4143 -> 4142;
4144 -> 4024;
4144 -> 4143;
4145 -> 4144;
4145 -> 4132;
4145 -> 4143;
4146 -> 4144;
4146 -> 4132;
4146 -> 4143;
4147 -> 4146;
4147 -> 4142;
4148 -> 4140;
4149 -> 4132;
4149 -> 4088;
4150 -> 4088;
4151 -> 4102;
4151 -> 4132;
4151 -> 4088;
4152 -> 4024;
4152 -> 4132;
4152 -> 4088;
4153 -> 4070;
4153 -> 4069;
4154 -> 4153;
4155 -> 4153;
4156 -> 4069;
4157 -> 4072;
4157 -> 4156;
4157 -> 4069;
4158 -> 4070;
4158 -> 4069;
4159 -> 4071;
4159 -> 4069;
4160 -> 4073;
4160 -> 4069;
4161 -> 4069;
4162 -> 4158;
4162 -> 4161;
4163 -> 4159;
4163 -> 4161;
4164 -> 4160;
4164 -> 4161;
4165 -> 4161;
4166 -> 4162;
4166 -> 4165;
4166 -> 4161;
4167 -> 4132;
4168 -> 4132;
4169 -> 4132;
4169 -> 0;
4170 -> 4132;
4171 -> 4132;
4171 -> 0;
4172 -> 4132;
4172 -> 0;
4173 -> 4132;
4173 -> 0;
4174 -> 4132;
4174 -> 0;
4175 -> 4132;
4175 -> 0;
4176 -> 4132;
4176 -> 0;
4177 -> 4132;
4178 -> 4177;
4178 -> 4132;
4179 -> 4132;
4180 -> 4132;
4181 -> 4177;
4181 -> 0;
4181 -> 4132;
4182 -> 4177;
4182 -> 4132;
4183 -> 4132;
4184 -> 4182;
4184 -> 4183;
4185 -> 4184;
4185 -> 4183;
4186 -> 4185;
4187 -> 4177;
4188 -> 4187;
4188 -> 4177;
4189 -> 4132;
4189 -> 4177;
4190 -> 4177;
4191 -> 4177;
4192 -> 4191;
4192 -> 4177;
4193 -> 4190;
4193 -> 4192;
4194 -> 4177;
4195 -> 4193;
4195 -> 4194;
4195 -> 4177;
4196 -> 4195;
4196 -> 4187;
4196 -> 4177;
4197 -> 4187;
4197 -> 4177;
4198 -> 4186;
4198 -> 4197;
4199 -> 4186;
4199 -> 4132;
4200 -> 4177;
4200 -> 0;
4200 -> 4132;
4201 -> 4177;
4201 -> 0;
4202 -> 4177;
4202 -> 0;
4202 -> 4132;
4203 -> 4177;
4203 -> 0;
4203 -> 4132;
4204 -> 4177;
4204 -> 0;
4204 -> 4132;
4205 -> 4177;
4205 -> 0;
4205 -> 4132;
4206 -> 4177;
4206 -> 0;
4206 -> 4132;
4207 -> 4177;
4207 -> 0;
4208 -> 4177;
4209 -> 4177;
4209 -> 0;
4210 -> 4177;
4211 -> 4177;
4211 -> 0;
4212 -> 4177;
4212 -> 0;
4213 -> 4177;
4213 -> 0;
4214 -> 4177;
4214 -> 0;
4215 -> 4177;
4215 -> 0;
4216 -> 4177;
4217 -> 4177;
4218 -> 4216;
4218 -> 4217;
4219 -> 4218;
4219 -> 4217;
4220 -> 4219;
4221 -> 4132;
4222 -> 4220;
4222 -> 4221;
4223 -> 4177;
4224 -> 4177;
4225 -> 4223;
4225 -> 4224;
4226 -> 4177;
4226 -> 4224;
4227 -> 4225;
4227 -> 4177;
4227 -> 0;
4227 -> 4224;
4228 -> 4227;
4229 -> 4177;
4230 -> 4216;
4230 -> 4229;
4231 -> 4230;
4231 -> 4229;
4232 -> 4231;
4233 -> 4132;
4234 -> 4177;
4234 -> 4233;
4234 -> 4132;
4235 -> 4132;
4236 -> 4132;
4237 -> 4236;
4237 -> 4177;
4237 -> 4132;
4238 -> 4024;
4238 -> 4177;
4238 -> 4161;
4239 -> 4058;
4240 -> 4024;
4240 -> 4177;
4240 -> 4239;
4240 -> 4058;
4241 -> 4042;
4241 -> 0;
4241 -> 4041;
4242 -> 4241;
4243 -> 4242;
4243 -> 4241;
4244 -> 4045;
4244 -> 4241;
4245 -> 4241;
4246 -> 4243;
4246 -> 4245;
4247 -> 4244;
4247 -> 4245;
4248 -> 4245;
4249 -> 4246;
4249 -> 4245;
4250 -> 4247;
4250 -> 4245;
4251 -> 4245;
4252 -> 4248;
4252 -> 4251;
4253 -> 4248;
4253 -> 4251;
4254 -> 4248;
4254 -> 4251;
4255 -> 4248;
4255 -> 4251;
4256 -> 4249;
4256 -> 4251;
4257 -> 4248;
4257 -> 4251;
4258 -> 4250;
4258 -> 4251;
4259 -> 4251;
4260 -> 4024;
4260 -> 4259;
4260 -> 4251;
4261 -> 4251;
4262 -> 4256;
4262 -> 4261;
4262 -> 4251;
4263 -> 4251;
4264 -> 4024;
4264 -> 4263;
4265 -> 4264;
4265 -> 4177;
4265 -> 4263;
4266 -> 4265;
4266 -> 4251;
4267 -> 4251;
4268 -> 4251;
4269 -> 4257;
4269 -> 4251;
4270 -> 4252;
4270 -> 4269;
4271 -> 4255;
4271 -> 4269;
4272 -> 4256;
4272 -> 4269;
4273 -> 4258;
4273 -> 4269;
4274 -> 4269;
4275 -> 4270;
4275 -> 4274;
4276 -> 4271;
4276 -> 4274;
4277 -> 4272;
4277 -> 4274;
4278 -> 4273;
4278 -> 4274;
4279 -> 4278;
4279 -> 4274;
4280 -> 4274;
4281 -> 4279;
4281 -> 4280;
4282 -> 4280;
4283 -> 4177;
4284 -> 4177;
4285 -> 4284;
4285 -> 4177;
4286 -> 4177;
4286 -> 4274;
4287 -> 4274;
4288 -> 4252;
4288 -> 4251;
4289 -> 4253;
4289 -> 4251;
4290 -> 4254;
4290 -> 4251;
4291 -> 4255;
4291 -> 4251;
4292 -> 4256;
4292 -> 4251;
4293 -> 4257;
4293 -> 4251;
4294 -> 4258;
4294 -> 4251;
4295 -> 4251;
4296 -> 4251;
4297 -> 4288;
4297 -> 4296;
4298 -> 4289;
4298 -> 4296;
4299 -> 4290;
4299 -> 4296;
4300 -> 4291;
4300 -> 4296;
4301 -> 4292;
4301 -> 4296;
4302 -> 4293;
4302 -> 4296;
4303 -> 4294;
4303 -> 4296;
4304 -> 4295;
4304 -> 4296;
4305 -> 4296;
4306 -> 4305;
4306 -> 4296;
4307 -> 4305;
4307 -> 4296;
4308 -> 4305;
4308 -> 4296;
4309 -> 4305;
4309 -> 4296;
4310 -> 4305;
4310 -> 4296;
4311 -> 4305;
4311 -> 4296;
4312 -> 4305;
4312 -> 4296;
4313 -> 4305;
4313 -> 4296;
4314 -> 4305;
4314 -> 4296;
4315 -> 4305;
4315 -> 4296;
4316 -> 4305;
4316 -> 4296;
4317 -> 4296;
4318 -> 4024;
4318 -> 4317;
4318 -> 4296;
4319 -> 4296;
4320 -> 4301;
4320 -> 4319;
4320 -> 4296;
4321 -> 4297;
4321 -> 4305;
4321 -> 4296;
4322 -> 4298;
4322 -> 4305;
4322 -> 4296;
4323 -> 4303;
4323 -> 4305;
4323 -> 4296;
4324 -> 4301;
4324 -> 4305;
4324 -> 4296;
4325 -> 4302;
4325 -> 4305;
4325 -> 4296;
4326 -> 4300;
4326 -> 4305;
4326 -> 4296;
4327 -> 4300;
4327 -> 4296;
4328 -> 4296;
4329 -> 4327;
4329 -> 4328;
4330 -> 4305;
4330 -> 4328;
4331 -> 4329;
4331 -> 4328;
4332 -> 4296;
4333 -> 4298;
4333 -> 4299;
4333 -> 4296;
4334 -> 4299;
4334 -> 4305;
4334 -> 4296;
4335 -> 4251;
4336 -> 4251;
4337 -> 4336;
4338 -> 4337;
4339 -> 4338;
4340 -> 4024;
4340 -> 4339;
4341 -> 4340;
4341 -> 4177;
4341 -> 4339;
4342 -> 4340;
4342 -> 4177;
4342 -> 4339;
4343 -> 4342;
4343 -> 4338;
4344 -> 4336;
4345 -> 4251;
4346 -> 4295;
4346 -> 4345;
4347 -> 4177;
4348 -> 4177;
4349 -> 4177;
4350 -> 4347;
4350 -> 4177;
4351 -> 4177;
4352 -> 4349;
4352 -> 4351;
4353 -> 4350;
4353 -> 4351;
4354 -> 4351;
4355 -> 4352;
4355 -> 4354;
4355 -> 4351;
4356 -> 4177;
4357 -> 4347;
4357 -> 4177;
4358 -> 4347;
4359 -> 4347;
4360 -> 4347;
4361 -> 4359;
4361 -> 4360;
4362 -> 4359;
4362 -> 4360;
4363 -> 4360;
4364 -> 4361;
4364 -> 4363;
4364 -> 4360;
4365 -> 4347;
4366 -> 4347;
4367 -> 4251;
4368 -> 4251;
4369 -> 4295;
4369 -> 4368;
4370 -> 4368;
4371 -> 4347;
4371 -> 4370;
4371 -> 4368;
4372 -> 4368;
4373 -> 4372;
4373 -> 4368;
4374 -> 4251;
4375 -> 4251;
4376 -> 4252;
4376 -> 4375;
4376 -> 4251;
4377 -> 4251;
4378 -> 4252;
4378 -> 4377;
4378 -> 4251;
4379 -> 4251;
4380 -> 4251;
4381 -> 4257;
4381 -> 4380;
4381 -> 4251;
4382 -> 4256;
4382 -> 4381;
4383 -> 4258;
4383 -> 4381;
4384 -> 4381;
4385 -> 4382;
4385 -> 4384;
4386 -> 4383;
4386 -> 4384;
4387 -> 4384;
4388 -> 4387;
4389 -> 4388;
4390 -> 4024;
4390 -> 4389;
4391 -> 4390;
4391 -> 4347;
4391 -> 4389;
4392 -> 4390;
4392 -> 4347;
4392 -> 4389;
4393 -> 4392;
4393 -> 4388;
4394 -> 4386;
4394 -> 4384;
4395 -> 4384;
4396 -> 4381;
4397 -> 4381;
4398 -> 4252;
4398 -> 4397;
4398 -> 4381;
4399 -> 4245;
4400 -> 4246;
4400 -> 4245;
4401 -> 4247;
4401 -> 4245;
4402 -> 4245;
4403 -> 4399;
4403 -> 4402;
4404 -> 4399;
4404 -> 4402;
4405 -> 4400;
4405 -> 4402;
4406 -> 4401;
4406 -> 4402;
4407 -> 4399;
4407 -> 4402;
4408 -> 4399;
4408 -> 4402;
4409 -> 4402;
4410 -> 4402;
4411 -> 4404;
4411 -> 4410;
4411 -> 4402;
4412 -> 4402;
4413 -> 4412;
4414 -> 4024;
4414 -> 4413;
4415 -> 4414;
4415 -> 4347;
4415 -> 4413;
4416 -> 4414;
4416 -> 4347;
4416 -> 4413;
4417 -> 4416;
4417 -> 4412;
4418 -> 4409;
4418 -> 4402;
4419 -> 4407;
4419 -> 4402;
4420 -> 4408;
4420 -> 4402;
4421 -> 4402;
4422 -> 4405;
4422 -> 4402;
4423 -> 4406;
4423 -> 4402;
4424 -> 4402;
4425 -> 4418;
4425 -> 4424;
4426 -> 4419;
4426 -> 4424;
4427 -> 4420;
4427 -> 4424;
4428 -> 4421;
4428 -> 4424;
4429 -> 4421;
4429 -> 4424;
4430 -> 4422;
4430 -> 4424;
4431 -> 4423;
4431 -> 4424;
4432 -> 4421;
4432 -> 4424;
4433 -> 4424;
4434 -> 4433;
4434 -> 4424;
4435 -> 4433;
4435 -> 4424;
4436 -> 4433;
4436 -> 4424;
4437 -> 4433;
4437 -> 4424;
4438 -> 4433;
4438 -> 4424;
4439 -> 4433;
4439 -> 4424;
4440 -> 4433;
4440 -> 4424;
4441 -> 4433;
4441 -> 4424;
4442 -> 4433;
4442 -> 4424;
4443 -> 4433;
4443 -> 4424;
4444 -> 4433;
4444 -> 4424;
4445 -> 4433;
4445 -> 4424;
4446 -> 4425;
4446 -> 4433;
4446 -> 4424;
4447 -> 4426;
4447 -> 4433;
4447 -> 4424;
4448 -> 4427;
4448 -> 4433;
4448 -> 4424;
4449 -> 4428;
4449 -> 4433;
4449 -> 4424;
4450 -> 4429;
4450 -> 4433;
4450 -> 4424;
4451 -> 4430;
4451 -> 4433;
4451 -> 4424;
4452 -> 4431;
4452 -> 4433;
4452 -> 4424;
4453 -> 4402;
4454 -> 4453;
4455 -> 4024;
4455 -> 4454;
4456 -> 4455;
4456 -> 4347;
4456 -> 4454;
4457 -> 4455;
4457 -> 4347;
4457 -> 4454;
4458 -> 4457;
4458 -> 4453;
4459 -> 4402;
4460 -> 4347;
4461 -> 4347;
4462 -> 4347;
4463 -> 4461;
4463 -> 4462;
4464 -> 4347;
4464 -> 4462;
4465 -> 4464;
4465 -> 4347;
4465 -> 4462;
4466 -> 4462;
4467 -> 4465;
4468 -> 4347;
4469 -> 4347;
4470 -> 4468;
4470 -> 4469;
4471 -> 4347;
4471 -> 4469;
4472 -> 4471;
4472 -> 4347;
4472 -> 4469;
4473 -> 4469;
4474 -> 4472;
4475 -> 4347;
4476 -> 4347;
4477 -> 4347;
4478 -> 4476;
4478 -> 4477;
4479 -> 4347;
4479 -> 4477;
4480 -> 4479;
4480 -> 4347;
4480 -> 4477;
4481 -> 4477;
4482 -> 4480;
4483 -> 4347;
4484 -> 4347;
4485 -> 4347;
4485 -> 4484;
4486 -> 4347;
4487 -> 4484;
4487 -> 4486;
4488 -> 4484;
4488 -> 4486;
4489 -> 4347;
4489 -> 4486;
4490 -> 4487;
4490 -> 4486;
4491 -> 4488;
4491 -> 4486;
4492 -> 4490;
4492 -> 4491;
4492 -> 4486;
4493 -> 4486;
4494 -> 4492;
4494 -> 4493;
4495 -> 4489;
4495 -> 4493;
4496 -> 4495;
4496 -> 4347;
4496 -> 4493;
4497 -> 4493;
4498 -> 4496;
4499 -> 4486;
4500 -> 4347;
4501 -> 4347;
4502 -> 4347;
4503 -> 4347;
4504 -> 4502;
4504 -> 4503;
4505 -> 4347;
4505 -> 4503;
4506 -> 4505;
4506 -> 4347;
4506 -> 4503;
4507 -> 4503;
4508 -> 4506;
4509 -> 4347;
4510 -> 4347;
4511 -> 4509;
4511 -> 4510;
4512 -> 4347;
4512 -> 4510;
4513 -> 4512;
4513 -> 4347;
4513 -> 4510;
4514 -> 4510;
4515 -> 4513;
4516 -> 4347;
4517 -> 4347;
4517 -> 4459;
4518 -> 4347;
4519 -> 4347;
4520 -> 4347;
4521 -> 4347;
4522 -> 4347;
4523 -> 4522;
4523 -> 4347;
4524 -> 4521;
4524 -> 4347;
4525 -> 4522;
4525 -> 4347;
4526 -> 0;
4526 -> 4347;
4527 -> 4347;
4528 -> 4347;
4529 -> 4347;
4530 -> 4529;
4530 -> 4526;
4530 -> 4347;
4531 -> 4530;
4531 -> 4347;
4532 -> 4347;
4533 -> 4347;
4534 -> 4528;
4534 -> 4533;
4534 -> 4347;
4535 -> 0;
4535 -> 4534;
4536 -> 4347;
4537 -> 4535;
4537 -> 0;
4537 -> 4347;
4538 -> 4531;
4538 -> 0;
4538 -> 4537;
4539 -> 4537;
4540 -> 4347;
4541 -> 4347;
4542 -> 4541;
4542 -> 4347;
4542 -> 4540;
4543 -> 4542;
4544 -> 4542;
4545 -> 4542;
4546 -> 4542;
4547 -> 4542;
4548 -> 4542;
4549 -> 4548;
4549 -> 4542;
4550 -> 4547;
4550 -> 4542;
4551 -> 4548;
4551 -> 4542;
4552 -> 0;
4552 -> 4542;
4553 -> 4542;
4554 -> 4542;
4555 -> 4542;
4556 -> 4555;
4556 -> 4552;
4556 -> 4542;
4557 -> 4556;
4557 -> 4542;
4558 -> 4542;
4559 -> 4542;
4560 -> 4554;
4560 -> 4559;
4560 -> 4542;
4561 -> 0;
4561 -> 4560;
4562 -> 4542;
4563 -> 4561;
4563 -> 0;
4563 -> 4542;
4564 -> 4557;
4564 -> 0;
4564 -> 4563;
4565 -> 4563;
4566 -> 4547;
4566 -> 4542;
4567 -> 4566;
4567 -> 4552;
4567 -> 4547;
4568 -> 4567;
4568 -> 4547;
4569 -> 4547;
4570 -> 4568;
4570 -> 0;
4570 -> 4563;
4571 -> 4547;
4572 -> 4547;
4573 -> 4547;
4574 -> 4547;
4575 -> 4547;
4576 -> 4574;
4576 -> 4575;
4577 -> 4347;
4577 -> 4575;
4578 -> 4577;
4578 -> 4547;
4578 -> 4575;
4579 -> 4575;
4580 -> 4578;
4581 -> 4547;
4582 -> 4547;
4583 -> 4547;
4584 -> 4582;
4584 -> 4583;
4585 -> 4347;
4585 -> 4583;
4586 -> 4585;
4586 -> 4547;
4586 -> 4583;
4587 -> 4583;
4588 -> 4586;
4589 -> 4402;
4590 -> 4421;
4590 -> 4547;
4590 -> 4589;
4590 -> 4402;
4591 -> 4409;
4591 -> 4402;
4592 -> 4402;
4593 -> 4407;
4593 -> 4592;
4593 -> 4402;
4594 -> 4593;
4595 -> 4594;
4596 -> 4595;
4597 -> 4547;
4598 -> 4547;
4599 -> 4547;
4600 -> 4245;
4601 -> 4246;
4601 -> 4245;
4602 -> 4247;
4602 -> 4245;
4603 -> 4245;
4604 -> 4600;
4604 -> 4603;
4605 -> 4601;
4605 -> 4603;
4606 -> 4602;
4606 -> 4603;
4607 -> 4024;
4607 -> 4603;
4608 -> 4603;
4609 -> 4607;
4609 -> 4547;
4609 -> 4608;
4609 -> 4603;
4610 -> 4604;
4610 -> 4603;
4611 -> 4603;
4612 -> 4610;
4612 -> 4611;
4613 -> 4607;
4613 -> 4611;
4614 -> 4611;
4615 -> 4613;
4615 -> 4547;
4615 -> 4614;
4615 -> 4611;
4616 -> 4603;
4617 -> 4241;
4618 -> 4242;
4618 -> 4241;
4619 -> 4044;
4619 -> 4041;
4620 -> 4046;
4620 -> 4041;
4621 -> 4045;
4621 -> 4041;
4622 -> 4041;
4623 -> 4032;
4624 -> 4025;
4625 -> 4624;
4626 -> 4625;
4627 -> 4625;
4628 -> 4626;
4628 -> 4627;
4629 -> 4627;
4630 -> 4024;
4630 -> 4629;
4630 -> 4627;
4631 -> 4024;
4631 -> 4627;
4632 -> 4631;
4632 -> 4547;
4632 -> 4627;
4633 -> 4627;
4634 -> 4547;
4634 -> 4633;
4634 -> 4627;
4635 -> 4627;
4636 -> 4627;
4637 -> 4024;
4637 -> 4636;
4638 -> 4636;
4639 -> 4636;
4640 -> 4547;
4640 -> 4636;
4641 -> 4640;
4641 -> 4636;
4642 -> 4639;
4642 -> 4641;
4643 -> 4642;
4643 -> 4638;
4643 -> 4636;
4644 -> 4642;
4644 -> 4638;
4644 -> 4636;
4645 -> 4644;
4645 -> 4636;
4646 -> 4637;
4646 -> 4636;
4647 -> 4646;
4647 -> 4547;
4647 -> 4636;
4648 -> 4637;
4648 -> 4636;
4649 -> 4648;
4649 -> 4547;
4649 -> 4636;
4650 -> 4636;
4651 -> 4637;
4651 -> 4650;
4652 -> 1850;
4652 -> 4650;
4653 -> 4650;
4654 -> 4651;
4654 -> 4650;
4655 -> 4654;
4655 -> 4547;
4655 -> 4650;
4656 -> 4650;
4657 -> 4656;
4657 -> 4636;
4658 -> 4657;
4659 -> 4658;
4660 -> 1850;
4660 -> 4658;
4661 -> 4636;
4662 -> 4661;
4662 -> 4636;
4663 -> 4636;
4664 -> 4636;
4665 -> 4661;
4665 -> 4664;
4665 -> 4662;
4665 -> 4636;
4666 -> 4636;
4667 -> 4637;
4667 -> 4636;
4668 -> 4667;
4668 -> 4547;
4668 -> 4636;
4669 -> 4661;
4669 -> 4636;
4670 -> 4666;
4670 -> 4636;
4671 -> 4636;
4672 -> 4669;
4672 -> 4671;
4673 -> 4670;
4673 -> 4671;
4674 -> 4673;
4674 -> 4666;
4674 -> 4671;
4675 -> 4671;
4676 -> 4675;
4676 -> 4674;
4676 -> 4671;
4677 -> 4636;
4678 -> 4636;
4679 -> 4661;
4679 -> 4678;
4679 -> 4665;
4679 -> 4636;
4680 -> 4636;
4681 -> 4636;
4682 -> 4636;
4683 -> 4681;
4683 -> 4682;
4683 -> 4636;
4684 -> 4636;
4685 -> 4661;
4685 -> 4684;
4685 -> 4679;
4685 -> 4636;
4686 -> 4666;
4686 -> 4636;
4687 -> 4680;
4687 -> 4636;
4688 -> 0;
4688 -> 4636;
4689 -> 4636;
4690 -> 4636;
4691 -> 4686;
4691 -> 4690;
4692 -> 4687;
4692 -> 4690;
4693 -> 4688;
4693 -> 4690;
4694 -> 4689;
4694 -> 4690;
4695 -> 4689;
4695 -> 4690;
4696 -> 4690;
4697 -> 4694;
4697 -> 4696;
4697 -> 4690;
4698 -> 4697;
4698 -> 4690;
4699 -> 1907;
4699 -> 4698;
4700 -> 4690;
4701 -> 4700;
4701 -> 4695;
4701 -> 4690;
4702 -> 4691;
4702 -> 4690;
4703 -> 4692;
4703 -> 4690;
4704 -> 4693;
4704 -> 4690;
4705 -> 4702;
4705 -> 4690;
4706 -> 4703;
4706 -> 4690;
4707 -> 4701;
4707 -> 4690;
4708 -> 4690;
4709 -> 4705;
4709 -> 4708;
4710 -> 4706;
4710 -> 4708;
4711 -> 4707;
4711 -> 4708;
4712 -> 4699;
4712 -> 4708;
4713 -> 4709;
4713 -> 4708;
4714 -> 4709;
4714 -> 4702;
4714 -> 4708;
4715 -> 4710;
4715 -> 4708;
4716 -> 4710;
4716 -> 4703;
4716 -> 4708;
4717 -> 4708;
4718 -> 4713;
4718 -> 4717;
4719 -> 4714;
4719 -> 4717;
4720 -> 4715;
4720 -> 4717;
4721 -> 4716;
4721 -> 4717;
4722 -> 4712;
4722 -> 4717;
4723 -> 4718;
4723 -> 4717;
4724 -> 4719;
4724 -> 4717;
4725 -> 4720;
4725 -> 4717;
4726 -> 4721;
4726 -> 4717;
4727 -> 4717;
4728 -> 4723;
4728 -> 4727;
4729 -> 4724;
4729 -> 4727;
4730 -> 4725;
4730 -> 4727;
4731 -> 4726;
4731 -> 4727;
4732 -> 4722;
4732 -> 4727;
4733 -> 4727;
4734 -> 4729;
4734 -> 4733;
4734 -> 4727;
4735 -> 4727;
4736 -> 4731;
4736 -> 4735;
4736 -> 4727;
4737 -> 4734;
4737 -> 4736;
4737 -> 4727;
4738 -> 4727;
4739 -> 4738;
4739 -> 4737;
4739 -> 4727;
4740 -> 4727;
4741 -> 4740;
4741 -> 4729;
4741 -> 4727;
4742 -> 4727;
4743 -> 4742;
4743 -> 4731;
4743 -> 4727;
4744 -> 4727;
4745 -> 4744;
4745 -> 4729;
4745 -> 4727;
4746 -> 4737;
4746 -> 4727;
4747 -> 4719;
4747 -> 4717;
4748 -> 4721;
4748 -> 4717;
4749 -> 4717;
4750 -> 4747;
4750 -> 4749;
4750 -> 4717;
4751 -> 4717;
4752 -> 4747;
4752 -> 4751;
4752 -> 4717;
4753 -> 4717;
4754 -> 4748;
4754 -> 4753;
4754 -> 4717;
4755 -> 4717;
4756 -> 4755;
4756 -> 4708;
4757 -> 4708;
4758 -> 4757;
4758 -> 4690;
4759 -> 4704;
4759 -> 4758;
4759 -> 4690;
4760 -> 4661;
4760 -> 4759;
4760 -> 4685;
4760 -> 4636;
4761 -> 4680;
4761 -> 4636;
4762 -> 4666;
4762 -> 4636;
4763 -> 4661;
4763 -> 4760;
4763 -> 4636;
4764 -> 4763;
4764 -> 4627;
4765 -> 4624;
4766 -> 4025;
4767 -> 4024;
4767 -> 4025;
4768 -> 4547;
4768 -> 4025;
4769 -> 4025;
4770 -> 4767;
4770 -> 4769;
4771 -> 4768;
4771 -> 4769;
4772 -> 4771;
4772 -> 4769;
4773 -> 4025;
4774 -> 4024;
4774 -> 4025;
4775 -> 4024;
4775 -> 4774;
4775 -> 4547;
4775 -> 24;
4776 -> 12;
4777 -> 16;
4777 -> 4776;
4777 -> 12;
4778 -> 13;
4778 -> 4777;
4779 -> 14;
4779 -> 4777;
4780 -> 15;
4780 -> 4777;
4781 -> 4777;
4782 -> 0;
4782 -> 4781;
4782 -> 4775;
4782 -> 4777;
4783 -> 4777;
4784 -> 4778;
4784 -> 4783;
4785 -> 4779;
4785 -> 4783;
4786 -> 4780;
4786 -> 4783;
4787 -> 4782;
4787 -> 4783;
4788 -> 4783;
4789 -> 4788;
4790 -> 4789;
4790 -> 4783;
4791 -> 4784;
4791 -> 4783;
4792 -> 4783;
4793 -> 0;
4793 -> 4792;
4793 -> 4782;
4793 -> 4783;
4794 -> 4790;
4794 -> 4783;
4795 -> 4783;
4796 -> 4792;
4796 -> 4795;
4797 -> 4796;
4797 -> 4795;
4798 -> 4795;
4799 -> 4797;
4799 -> 4798;
4800 -> 4798;
4801 -> 4799;
4801 -> 4800;
4801 -> 4798;
4802 -> 4798;
4802 -> 4783;
4803 -> 4791;
4803 -> 4795;
4804 -> 4792;
4804 -> 4795;
4805 -> 4792;
4805 -> 4795;
4806 -> 4802;
4806 -> 4795;
4807 -> 4794;
4807 -> 4795;
4808 -> 4792;
4808 -> 4795;
4809 -> 4792;
4809 -> 4795;
4810 -> 4803;
4810 -> 4795;
4811 -> 4806;
4811 -> 4795;
4812 -> 4804;
4812 -> 4795;
4813 -> 4795;
4814 -> 4811;
4814 -> 4813;
4815 -> 4812;
4815 -> 4813;
4816 -> 4814;
4816 -> 4813;
4817 -> 4813;
4818 -> 4816;
4818 -> 4817;
4819 -> 4818;
4819 -> 4817;
4820 -> 4819;
4821 -> 0;
4821 -> 4820;
4822 -> 4821;
4823 -> 4822;
4824 -> 4813;
4825 -> 4815;
4825 -> 4824;
4825 -> 4813;
4826 -> 4805;
4826 -> 4795;
4827 -> 4807;
4827 -> 4795;
4828 -> 4808;
4828 -> 4795;
4829 -> 4809;
4829 -> 4795;
4830 -> 4795;
4831 -> 4810;
4831 -> 4830;
4832 -> 4826;
4832 -> 4830;
4833 -> 4827;
4833 -> 4830;
4834 -> 4828;
4834 -> 4830;
4835 -> 4829;
4835 -> 4830;
4836 -> 4831;
4836 -> 4830;
4837 -> 4832;
4837 -> 4830;
4838 -> 4833;
4838 -> 4830;
4839 -> 4834;
4839 -> 4830;
4840 -> 4835;
4840 -> 4830;
4841 -> 4830;
4842 -> 4841;
4842 -> 4830;
4843 -> 4830;
4844 -> 4836;
4844 -> 4843;
4845 -> 4837;
4845 -> 4843;
4846 -> 4838;
4846 -> 4843;
4847 -> 4839;
4847 -> 4843;
4848 -> 4840;
4848 -> 4843;
4849 -> 4842;
4849 -> 4843;
4850 -> 4845;
4850 -> 4843;
4851 -> 4847;
4851 -> 4843;
4852 -> 4843;
4853 -> 4850;
4853 -> 4852;
4854 -> 4851;
4854 -> 4852;
4855 -> 4844;
4855 -> 4852;
4856 -> 4855;
4856 -> 4791;
4856 -> 4852;
4857 -> 4856;
4858 -> 4854;
4858 -> 4856;
4859 -> 4853;
4859 -> 4856;
4860 -> 4856;
4861 -> 4857;
4861 -> 4860;
4862 -> 4858;
4862 -> 4860;
4863 -> 4859;
4863 -> 4860;
4864 -> 4857;
4864 -> 4860;
4865 -> 4860;
4866 -> 4863;
4866 -> 4865;
4866 -> 4860;
4867 -> 0;
4867 -> 4866;
4868 -> 4861;
4868 -> 4860;
4869 -> 0;
4869 -> 4860;
4870 -> 4869;
4870 -> 4864;
4870 -> 4860;
4871 -> 4860;
4872 -> 4867;
4872 -> 4860;
4873 -> 4862;
4873 -> 4860;
4874 -> 4860;
4875 -> 4860;
4876 -> 4875;
4877 -> 4875;
4878 -> 4793;
4878 -> 4877;
4878 -> 4875;
4879 -> 4876;
4879 -> 4875;
4880 -> 4875;
4881 -> 4878;
4881 -> 4793;
4881 -> 4877;
4881 -> 4879;
4881 -> 4880;
4881 -> 4876;
4881 -> 4875;
4882 -> 4875;
4883 -> 4882;
4883 -> 4876;
4883 -> 4875;
4884 -> 4876;
4884 -> 4875;
4885 -> 4875;
4886 -> 4884;
4886 -> 4885;
4886 -> 4876;
4886 -> 4883;
4886 -> 4875;
4887 -> 4857;
4887 -> 4843;
4888 -> 4843;
4889 -> 4793;
4889 -> 4888;
4889 -> 4843;
4890 -> 0;
4890 -> 4843;
4891 -> 4849;
4891 -> 4843;
4892 -> 4793;
4892 -> 4843;
4893 -> 4843;
4894 -> 4892;
4894 -> 4893;
4895 -> 0;
4895 -> 4893;
4896 -> 4895;
4897 -> 4843;
4898 -> 4843;
4899 -> 4898;
4900 -> 4898;
4901 -> 4899;
4901 -> 4900;
4902 -> 4899;
4902 -> 4900;
4903 -> 4899;
4903 -> 4900;
4904 -> 4899;
4904 -> 4900;
4905 -> 4900;
4906 -> 4793;
4906 -> 4905;
4906 -> 4900;
4907 -> 4904;
4907 -> 4900;
4908 -> 4901;
4908 -> 4900;
4909 -> 4902;
4909 -> 4900;
4910 -> 4903;
4910 -> 4900;
4911 -> 4904;
4911 -> 4900;
4912 -> 4900;
4913 -> 0;
4913 -> 4900;
4914 -> 4900;
4915 -> 4913;
4915 -> 4914;
4916 -> 4913;
4916 -> 4914;
4917 -> 4911;
4917 -> 4914;
4918 -> 4912;
4918 -> 4914;
4919 -> 4912;
4919 -> 4914;
4920 -> 4915;
4920 -> 4914;
4921 -> 4916;
4921 -> 4914;
4922 -> 4917;
4922 -> 4914;
4923 -> 4914;
4924 -> 4923;
4924 -> 4914;
4925 -> 4918;
4925 -> 4923;
4925 -> 4914;
4926 -> 4900;
4927 -> 4908;
4927 -> 4926;
4928 -> 4909;
4928 -> 4926;
4929 -> 4910;
4929 -> 4926;
4930 -> 4911;
4930 -> 4926;
4931 -> 4912;
4931 -> 4926;
4932 -> 4912;
4932 -> 4926;
4933 -> 4912;
4933 -> 4926;
4934 -> 4912;
4934 -> 4926;
4935 -> 4912;
4935 -> 4926;
4936 -> 4912;
4936 -> 4926;
4937 -> 4927;
4937 -> 4926;
4938 -> 4928;
4938 -> 4926;
4939 -> 4929;
4939 -> 4926;
4940 -> 4930;
4940 -> 4926;
4941 -> 4931;
4941 -> 4926;
4942 -> 4932;
4942 -> 4926;
4943 -> 4933;
4943 -> 4926;
4944 -> 4934;
4944 -> 4926;
4945 -> 4935;
4945 -> 4926;
4946 -> 4926;
4947 -> 4937;
4947 -> 4946;
4948 -> 4938;
4948 -> 4946;
4949 -> 4939;
4949 -> 4946;
4950 -> 4940;
4950 -> 4946;
4951 -> 4941;
4951 -> 4946;
4952 -> 4942;
4952 -> 4946;
4953 -> 4943;
4953 -> 4946;
4954 -> 4944;
4954 -> 4946;
4955 -> 4945;
4955 -> 4946;
4956 -> 4936;
4956 -> 4946;
4957 -> 4950;
4957 -> 4946;
4958 -> 4954;
4958 -> 4946;
4959 -> 4955;
4959 -> 4946;
4960 -> 4946;
4961 -> 4960;
4961 -> 4946;
4962 -> 4960;
4962 -> 4946;
4963 -> 4960;
4963 -> 4946;
4964 -> 4960;
4964 -> 4946;
4965 -> 4960;
4965 -> 4946;
4966 -> 4960;
4966 -> 4946;
4967 -> 4960;
4967 -> 4946;
4968 -> 4960;
4968 -> 4946;
4969 -> 4960;
4969 -> 4946;
4970 -> 4960;
4970 -> 4946;
4971 -> 4960;
4971 -> 4946;
4972 -> 4960;
4972 -> 4946;
4973 -> 4960;
4973 -> 4946;
4974 -> 4960;
4974 -> 4946;
4975 -> 4960;
4975 -> 4946;
4976 -> 4960;
4976 -> 4946;
4977 -> 4960;
4977 -> 4946;
4978 -> 4960;
4978 -> 4946;
4979 -> 4960;
4979 -> 4946;
4980 -> 4960;
4980 -> 4946;
4981 -> 4960;
4981 -> 4946;
4982 -> 4960;
4982 -> 4946;
4983 -> 4960;
4983 -> 4946;
4984 -> 4960;
4984 -> 4946;
4985 -> 4960;
4985 -> 4946;
4986 -> 4960;
4986 -> 4946;
4987 -> 4946;
4988 -> 4987;
4988 -> 4960;
4988 -> 4946;
4989 -> 4960;
4989 -> 4946;
4990 -> 4960;
4990 -> 4946;
4991 -> 4946;
4992 -> 4946;
4993 -> 4990;
4993 -> 4992;
4994 -> 4991;
4994 -> 4992;
4995 -> 4994;
4995 -> 4992;
4996 -> 4994;
4996 -> 4992;
4997 -> 4994;
4997 -> 4992;
4998 -> 4993;
4998 -> 4994;
4998 -> 4992;
4999 -> 4991;
4999 -> 4960;
4999 -> 4946;
5000 -> 4960;
5000 -> 4946;
5001 -> 4946;
5002 -> 5001;
5003 -> 0;
5003 -> 5001;
5004 -> 5003;
5004 -> 5002;
5004 -> 5001;
5005 -> 5004;
5005 -> 4946;
5006 -> 5005;
5006 -> 4960;
5006 -> 4946;
5007 -> 4950;
5007 -> 4946;
5008 -> 5007;
5009 -> 4947;
5009 -> 5008;
5009 -> 5007;
5010 -> 4948;
5010 -> 5008;
5010 -> 5007;
5011 -> 5009;
5011 -> 5010;
5011 -> 5007;
5012 -> 4949;
5012 -> 5008;
5012 -> 5007;
5013 -> 5011;
5013 -> 5012;
5013 -> 5007;
5014 -> 4952;
5014 -> 4946;
5015 -> 5014;
5016 -> 4960;
5016 -> 5015;
5017 -> 4951;
5017 -> 5014;
5018 -> 4953;
5018 -> 4960;
5018 -> 4946;
5019 -> 4960;
5019 -> 4793;
5019 -> 4946;
5020 -> 4946;
5021 -> 4960;
5021 -> 4793;
5021 -> 5020;
5021 -> 4946;
5022 -> 4900;
5023 -> 4793;
5024 -> 4793;
5025 -> 4793;
5026 -> 4793;
5027 -> 4793;
5028 -> 5024;
5028 -> 4793;
5029 -> 4793;
5030 -> 4793;
5031 -> 4793;
5032 -> 4793;
5033 -> 4793;
5034 -> 4793;
5035 -> 4793;
5036 -> 4793;
5037 -> 5034;
5037 -> 4793;
5038 -> 5035;
5038 -> 4793;
5039 -> 5036;
5039 -> 4793;
5040 -> 5037;
5040 -> 4793;
5041 -> 5038;
5041 -> 4793;
5042 -> 5039;
5042 -> 4793;
5043 -> 4793;
5044 -> 4793;
5045 -> 5044;
5046 -> 5040;
5046 -> 5045;
5046 -> 5044;
5047 -> 5041;
5047 -> 5045;
5047 -> 5044;
5048 -> 5046;
5048 -> 5047;
5048 -> 5044;
5049 -> 5042;
5049 -> 5045;
5049 -> 5044;
5050 -> 5048;
5050 -> 5049;
5050 -> 5044;
5051 -> 4793;
5052 -> 4793;
5053 -> 4793;
5054 -> 4793;
5054 -> 4900;
5055 -> 4843;
5056 -> 5055;
5057 -> 5056;
5058 -> 5057;
5059 -> 4793;
5060 -> 4793;
5061 -> 5059;
5061 -> 4793;
5062 -> 5059;
5062 -> 4793;
5063 -> 5059;
5063 -> 4793;
5064 -> 4793;
5065 -> 5064;
5065 -> 0;
5065 -> 4793;
5066 -> 5059;
5066 -> 4793;
5067 -> 5059;
5067 -> 4793;
5068 -> 5059;
5068 -> 4793;
5069 -> 5059;
5069 -> 4793;
5070 -> 5059;
5070 -> 4793;
5071 -> 5059;
5071 -> 5055;
5072 -> 5055;
5073 -> 0;
5073 -> 5055;
5074 -> 4848;
5074 -> 5059;
5074 -> 4843;
5075 -> 4783;
5076 -> 4783;
5077 -> 5075;
5077 -> 5076;
5078 -> 5076;
5079 -> 5076;
5080 -> 5078;
5080 -> 5079;
5081 -> 0;
5081 -> 5079;
5082 -> 5079;
5083 -> 5080;
5083 -> 5079;
5084 -> 5079;
5085 -> 5081;
5085 -> 5084;
5086 -> 5082;
5086 -> 5084;
5087 -> 5083;
5087 -> 5084;
5088 -> 5084;
5089 -> 5085;
5089 -> 5084;
5090 -> 5086;
5090 -> 5084;
5091 -> 5088;
5091 -> 5084;
5092 -> 5087;
5092 -> 5084;
5093 -> 5084;
5094 -> 5089;
5094 -> 5093;
5095 -> 5090;
5095 -> 5093;
5096 -> 5091;
5096 -> 5093;
5097 -> 5092;
5097 -> 5093;
5098 -> 5093;
5099 -> 5094;
5099 -> 0;
5099 -> 5093;
5100 -> 5099;
5100 -> 5095;
5100 -> 5093;
5101 -> 5100;
5102 -> 5101;
5103 -> 5102;
5104 -> 5100;
5105 -> 5059;
5106 -> 5059;
5107 -> 5100;
5108 -> 5059;
5109 -> 5094;
5109 -> 0;
5109 -> 5093;
5110 -> 5109;
5110 -> 5095;
5110 -> 5093;
5111 -> 5098;
5111 -> 5110;
5112 -> 5110;
5113 -> 5110;
5114 -> 5110;
5115 -> 4793;
5115 -> 5114;
5116 -> 5115;
5116 -> 5059;
5116 -> 5114;
5117 -> 5116;
5117 -> 5110;
5118 -> 5110;
5119 -> 4793;
5119 -> 5059;
5120 -> 5097;
5120 -> 5110;
5121 -> 5110;
5122 -> 5110;
5123 -> 5121;
5123 -> 5122;
5124 -> 5121;
5124 -> 5122;
5125 -> 5121;
5125 -> 5122;
5126 -> 5120;
5126 -> 5122;
5127 -> 5122;
5128 -> 5127;
5129 -> 5128;
5130 -> 5126;
5130 -> 5122;
5131 -> 5122;
5132 -> 5122;
5133 -> 5123;
5133 -> 5132;
5133 -> 5122;
5134 -> 5122;
5135 -> 5134;
5136 -> 5135;
5137 -> 4793;
5137 -> 5136;
5138 -> 5137;
5138 -> 5059;
5138 -> 5136;
5139 -> 5137;
5139 -> 5059;
5139 -> 5136;
5140 -> 5139;
5140 -> 5135;
5141 -> 5131;
5141 -> 5122;
5142 -> 5126;
5142 -> 5122;
5143 -> 5122;
5144 -> 5143;
5145 -> 5144;
5146 -> 5145;
5147 -> 5143;
5148 -> 5147;
5149 -> 5148;
5150 -> 5143;
5151 -> 5150;
5152 -> 5059;
5152 -> 5151;
5153 -> 5152;
5153 -> 5150;
5154 -> 5059;
5154 -> 5143;
5155 -> 5143;
5156 -> 5059;
5156 -> 5143;
5157 -> 5059;
5157 -> 5143;
5158 -> 5157;
5158 -> 5059;
5158 -> 5143;
5159 -> 5143;
5160 -> 5143;
5161 -> 5059;
5161 -> 5143;
5162 -> 5161;
5162 -> 5143;
5163 -> 5143;
5164 -> 5143;
5165 -> 5163;
5165 -> 5164;
5166 -> 5165;
5166 -> 5164;
5167 -> 5164;
5168 -> 5167;
5169 -> 5168;
5170 -> 5168;
5171 -> 5170;
5172 -> 5167;
5173 -> 5172;
5174 -> 5164;
5175 -> 5164;
5176 -> 5164;
5177 -> 5165;
5177 -> 5164;
5178 -> 5164;
5179 -> 5177;
5179 -> 5178;
5180 -> 5179;
5180 -> 5178;
5181 -> 5178;
5182 -> 5178;
5183 -> 5182;
5184 -> 5182;
5185 -> 5059;
5185 -> 5184;
5185 -> 5182;
5186 -> 5059;
5187 -> 5186;
5187 -> 5059;
5188 -> 5143;
5189 -> 5188;
5190 -> 5189;
5191 -> 5059;
5191 -> 5190;
5192 -> 5191;
5192 -> 5189;
5193 -> 5143;
5194 -> 5175;
5194 -> 5164;
5195 -> 5059;
5195 -> 5186;
5195 -> 5143;
5196 -> 5143;
5197 -> 5196;
5198 -> 5197;
5199 -> 5198;
5200 -> 5059;
5200 -> 5199;
5201 -> 5200;
5201 -> 5198;
5202 -> 5196;
5203 -> 5186;
5203 -> 5143;
5204 -> 5143;
5205 -> 5157;
5205 -> 5186;
5205 -> 5143;
5206 -> 5059;
5206 -> 5186;
5206 -> 5143;
5207 -> 5123;
5207 -> 5122;
5208 -> 5207;
5209 -> 5207;
5210 -> 5122;
5211 -> 5125;
5211 -> 5210;
5211 -> 5122;
5212 -> 5123;
5212 -> 5122;
5213 -> 5124;
5213 -> 5122;
5214 -> 5126;
5214 -> 5122;
5215 -> 5122;
5216 -> 5212;
5216 -> 5215;
5217 -> 5213;
5217 -> 5215;
5218 -> 5214;
5218 -> 5215;
5219 -> 5215;
5220 -> 5216;
5220 -> 5219;
5220 -> 5215;
5221 -> 5186;
5222 -> 5186;
5223 -> 5186;
5224 -> 5186;
5224 -> 0;
5225 -> 5186;
5226 -> 5186;
5226 -> 0;
5227 -> 5186;
5227 -> 0;
5228 -> 5186;
5228 -> 0;
5229 -> 5186;
5229 -> 0;
5230 -> 5186;
5230 -> 0;
5231 -> 5186;
5231 -> 0;
5232 -> 5186;
5233 -> 5186;
5234 -> 5186;
5235 -> 5186;
5235 -> 0;
5236 -> 5186;
5237 -> 5186;
5238 -> 5236;
5238 -> 5237;
5239 -> 5238;
5239 -> 5237;
5240 -> 5239;
5241 -> 5186;
5242 -> 5241;
5242 -> 5186;
5243 -> 5186;
5244 -> 5243;
5244 -> 5186;
5245 -> 5234;
5245 -> 5244;
5246 -> 5186;
5247 -> 5245;
5247 -> 5246;
5247 -> 5186;
5248 -> 5247;
5248 -> 5241;
5248 -> 5186;
5249 -> 5241;
5249 -> 5186;
5250 -> 5240;
5250 -> 5249;
5251 -> 5240;
5251 -> 5186;
5252 -> 5186;
5252 -> 0;
5253 -> 5186;
5254 -> 5186;
5255 -> 5186;
5256 -> 5254;
5256 -> 5255;
5257 -> 5256;
5257 -> 5255;
5258 -> 5257;
5259 -> 5186;
5260 -> 5258;
5260 -> 5259;
5261 -> 5186;
5262 -> 5186;
5263 -> 5261;
5263 -> 5262;
5264 -> 5186;
5264 -> 5262;
5265 -> 5263;
5265 -> 5186;
5265 -> 0;
5265 -> 5262;
5266 -> 5265;
5267 -> 5186;
5268 -> 5254;
5268 -> 5267;
5269 -> 5268;
5269 -> 5267;
5270 -> 5269;
5271 -> 5186;
5272 -> 5186;
5273 -> 5186;
5274 -> 4793;
5274 -> 5186;
5274 -> 5215;
5275 -> 5110;
5276 -> 4793;
5276 -> 5186;
5276 -> 5275;
5276 -> 5110;
5277 -> 5094;
5277 -> 0;
5277 -> 5093;
5278 -> 5277;
5279 -> 5278;
5279 -> 5277;
5280 -> 5097;
5280 -> 5277;
5281 -> 5277;
5282 -> 5279;
5282 -> 5281;
5283 -> 5280;
5283 -> 5281;
5284 -> 5281;
5285 -> 5282;
5285 -> 5281;
5286 -> 5283;
5286 -> 5281;
5287 -> 5281;
5288 -> 5284;
5288 -> 5287;
5289 -> 5284;
5289 -> 5287;
5290 -> 5284;
5290 -> 5287;
5291 -> 5284;
5291 -> 5287;
5292 -> 5285;
5292 -> 5287;
5293 -> 5284;
5293 -> 5287;
5294 -> 5286;
5294 -> 5287;
5295 -> 5287;
5296 -> 4793;
5296 -> 5295;
5296 -> 5287;
5297 -> 5287;
5298 -> 5292;
5298 -> 5297;
5298 -> 5287;
5299 -> 5287;
5300 -> 4793;
5300 -> 5299;
5301 -> 5300;
5301 -> 5186;
5301 -> 5299;
5302 -> 5301;
5302 -> 5287;
5303 -> 5287;
5304 -> 5287;
5305 -> 5293;
5305 -> 5287;
5306 -> 5288;
5306 -> 5305;
5307 -> 5291;
5307 -> 5305;
5308 -> 5292;
5308 -> 5305;
5309 -> 5294;
5309 -> 5305;
5310 -> 5305;
5311 -> 5306;
5311 -> 5310;
5312 -> 5307;
5312 -> 5310;
5313 -> 5308;
5313 -> 5310;
5314 -> 5309;
5314 -> 5310;
5315 -> 5314;
5315 -> 5310;
5316 -> 5310;
5317 -> 5315;
5317 -> 5316;
5318 -> 5316;
5319 -> 5186;
5320 -> 5186;
5320 -> 5310;
5321 -> 5310;
5322 -> 5288;
5322 -> 5287;
5323 -> 5289;
5323 -> 5287;
5324 -> 5290;
5324 -> 5287;
5325 -> 5291;
5325 -> 5287;
5326 -> 5292;
5326 -> 5287;
5327 -> 5293;
5327 -> 5287;
5328 -> 5294;
5328 -> 5287;
5329 -> 5287;
5330 -> 5287;
5331 -> 5322;
5331 -> 5330;
5332 -> 5323;
5332 -> 5330;
5333 -> 5324;
5333 -> 5330;
5334 -> 5325;
5334 -> 5330;
5335 -> 5326;
5335 -> 5330;
5336 -> 5327;
5336 -> 5330;
5337 -> 5328;
5337 -> 5330;
5338 -> 5329;
5338 -> 5330;
5339 -> 5330;
5340 -> 5339;
5340 -> 5330;
5341 -> 5339;
5341 -> 5330;
5342 -> 5339;
5342 -> 5330;
5343 -> 5339;
5343 -> 5330;
5344 -> 5339;
5344 -> 5330;
5345 -> 5339;
5345 -> 5330;
5346 -> 5339;
5346 -> 5330;
5347 -> 5339;
5347 -> 5330;
5348 -> 5339;
5348 -> 5330;
5349 -> 5339;
5349 -> 5330;
5350 -> 5339;
5350 -> 5330;
5351 -> 5330;
5352 -> 4793;
5352 -> 5351;
5352 -> 5330;
5353 -> 5330;
5354 -> 5335;
5354 -> 5353;
5354 -> 5330;
5355 -> 5331;
5355 -> 5339;
5355 -> 5330;
5356 -> 5332;
5356 -> 5339;
5356 -> 5330;
5357 -> 5337;
5357 -> 5339;
5357 -> 5330;
5358 -> 5335;
5358 -> 5339;
5358 -> 5330;
5359 -> 5336;
5359 -> 5339;
5359 -> 5330;
5360 -> 5334;
5360 -> 5339;
5360 -> 5330;
5361 -> 5334;
5361 -> 5330;
5362 -> 5330;
5363 -> 5361;
5363 -> 5362;
5364 -> 5339;
5364 -> 5362;
5365 -> 5363;
5365 -> 5362;
5366 -> 5330;
5367 -> 5332;
5367 -> 5333;
5367 -> 5330;
5368 -> 5333;
5368 -> 5339;
5368 -> 5330;
5369 -> 5287;
5370 -> 5287;
5371 -> 5370;
5372 -> 5371;
5373 -> 5372;
5374 -> 4793;
5374 -> 5373;
5375 -> 5186;
5375 -> 5372;
5376 -> 5370;
5377 -> 5287;
5378 -> 5329;
5378 -> 5377;
5379 -> 5186;
5380 -> 5186;
5381 -> 5186;
5382 -> 5380;
5382 -> 5381;
5383 -> 5380;
5383 -> 5381;
5384 -> 5381;
5385 -> 5382;
5385 -> 5384;
5385 -> 5381;
5386 -> 5186;
5387 -> 5186;
5388 -> 5287;
5389 -> 5287;
5390 -> 5329;
5390 -> 5389;
5391 -> 5389;
5392 -> 5186;
5392 -> 5391;
5392 -> 5389;
5393 -> 5389;
5394 -> 5393;
5394 -> 5389;
5395 -> 5287;
5396 -> 5287;
5397 -> 5288;
5397 -> 5396;
5397 -> 5287;
5398 -> 5287;
5399 -> 5288;
5399 -> 5398;
5399 -> 5287;
5400 -> 5287;
5401 -> 5287;
5402 -> 5293;
5402 -> 5401;
5402 -> 5287;
5403 -> 5292;
5403 -> 5402;
5404 -> 5294;
5404 -> 5402;
5405 -> 5402;
5406 -> 5403;
5406 -> 5405;
5407 -> 5404;
5407 -> 5405;
5408 -> 5405;
5409 -> 5408;
5410 -> 5409;
5411 -> 4793;
5411 -> 5410;
5412 -> 5186;
5412 -> 5409;
5413 -> 5407;
5413 -> 5405;
5414 -> 5405;
5415 -> 5402;
5416 -> 5402;
5417 -> 5288;
5417 -> 5416;
5417 -> 5402;
5418 -> 5281;
5419 -> 5282;
5419 -> 5281;
5420 -> 5283;
5420 -> 5281;
5421 -> 5281;
5422 -> 5418;
5422 -> 5421;
5423 -> 5418;
5423 -> 5421;
5424 -> 5419;
5424 -> 5421;
5425 -> 5420;
5425 -> 5421;
5426 -> 5418;
5426 -> 5421;
5427 -> 5418;
5427 -> 5421;
5428 -> 5421;
5429 -> 5421;
5430 -> 5423;
5430 -> 5429;
5430 -> 5421;
5431 -> 5421;
5432 -> 5431;
5433 -> 4793;
5433 -> 5432;
5434 -> 5186;
5434 -> 5431;
5435 -> 5428;
5435 -> 5421;
5436 -> 5426;
5436 -> 5421;
5437 -> 5427;
5437 -> 5421;
5438 -> 5421;
5439 -> 5424;
5439 -> 5421;
5440 -> 5425;
5440 -> 5421;
5441 -> 5421;
5442 -> 5435;
5442 -> 5441;
5443 -> 5436;
5443 -> 5441;
5444 -> 5437;
5444 -> 5441;
5445 -> 5438;
5445 -> 5441;
5446 -> 5438;
5446 -> 5441;
5447 -> 5439;
5447 -> 5441;
5448 -> 5440;
5448 -> 5441;
5449 -> 5438;
5449 -> 5441;
5450 -> 5441;
5451 -> 5450;
5451 -> 5441;
5452 -> 5450;
5452 -> 5441;
5453 -> 5450;
5453 -> 5441;
5454 -> 5450;
5454 -> 5441;
5455 -> 5450;
5455 -> 5441;
5456 -> 5450;
5456 -> 5441;
5457 -> 5450;
5457 -> 5441;
5458 -> 5450;
5458 -> 5441;
5459 -> 5450;
5459 -> 5441;
5460 -> 5450;
5460 -> 5441;
5461 -> 5450;
5461 -> 5441;
5462 -> 5450;
5462 -> 5441;
5463 -> 5442;
5463 -> 5450;
5463 -> 5441;
5464 -> 5443;
5464 -> 5450;
5464 -> 5441;
5465 -> 5444;
5465 -> 5450;
5465 -> 5441;
5466 -> 5445;
5466 -> 5450;
5466 -> 5441;
5467 -> 5446;
5467 -> 5450;
5467 -> 5441;
5468 -> 5447;
5468 -> 5450;
5468 -> 5441;
5469 -> 5448;
5469 -> 5450;
5469 -> 5441;
5470 -> 5421;
5471 -> 5470;
5472 -> 4793;
5472 -> 5471;
5473 -> 5186;
5473 -> 5470;
5474 -> 5421;
5475 -> 5186;
5476 -> 5186;
5477 -> 5186;
5478 -> 5476;
5478 -> 5477;
5479 -> 5186;
5479 -> 5477;
5480 -> 5479;
5480 -> 5186;
5480 -> 5477;
5481 -> 5477;
5482 -> 5480;
5483 -> 5186;
5484 -> 5186;
5485 -> 5483;
5485 -> 5484;
5486 -> 5186;
5486 -> 5484;
5487 -> 5486;
5487 -> 5186;
5487 -> 5484;
5488 -> 5484;
5489 -> 5487;
5490 -> 5186;
5491 -> 5186;
5492 -> 5186;
5493 -> 5491;
5493 -> 5492;
5494 -> 5186;
5494 -> 5492;
5495 -> 5494;
5495 -> 5186;
5495 -> 5492;
5496 -> 5492;
5497 -> 5495;
5498 -> 5186;
5499 -> 5186;
5500 -> 5186;
5500 -> 5499;
5501 -> 5186;
5502 -> 5499;
5502 -> 5501;
5503 -> 5499;
5503 -> 5501;
5504 -> 5186;
5504 -> 5501;
5505 -> 5502;
5505 -> 5501;
5506 -> 5503;
5506 -> 5501;
5507 -> 5505;
5507 -> 5506;
5507 -> 5501;
5508 -> 5501;
5509 -> 5507;
5509 -> 5508;
5510 -> 5504;
5510 -> 5508;
5511 -> 5510;
5511 -> 5186;
5511 -> 5508;
5512 -> 5508;
5513 -> 5511;
5514 -> 5501;
5515 -> 5186;
5516 -> 5186;
5517 -> 5186;
5518 -> 5186;
5519 -> 5517;
5519 -> 5518;
5520 -> 5186;
5520 -> 5518;
5521 -> 5520;
5521 -> 5186;
5521 -> 5518;
5522 -> 5518;
5523 -> 5521;
5524 -> 5186;
5525 -> 5186;
5526 -> 5524;
5526 -> 5525;
5527 -> 5186;
5527 -> 5525;
5528 -> 5527;
5528 -> 5186;
5528 -> 5525;
5529 -> 5525;
5530 -> 5528;
5531 -> 5186;
5532 -> 5186;
5532 -> 5474;
5533 -> 5186;
5534 -> 5186;
5535 -> 5186;
5536 -> 5186;
5537 -> 5536;
5537 -> 5186;
5538 -> 5186;
5539 -> 5536;
5539 -> 5186;
5540 -> 0;
5540 -> 5186;
5541 -> 5186;
5542 -> 5186;
5543 -> 5186;
5544 -> 5543;
5544 -> 5540;
5544 -> 5186;
5545 -> 5544;
5545 -> 5186;
5546 -> 5186;
5547 -> 5186;
5548 -> 5542;
5548 -> 5547;
5548 -> 5186;
5549 -> 0;
5549 -> 5548;
5550 -> 5186;
5551 -> 5549;
5551 -> 0;
5551 -> 5186;
5552 -> 5545;
5552 -> 0;
5552 -> 5551;
5553 -> 5551;
5554 -> 5186;
5555 -> 5186;
5556 -> 5186;
5557 -> 5555;
5557 -> 5556;
5558 -> 5186;
5558 -> 5556;
5559 -> 5558;
5559 -> 5186;
5559 -> 5556;
5560 -> 5556;
5561 -> 5559;
5562 -> 5186;
5563 -> 5186;
5564 -> 5186;
5565 -> 5563;
5565 -> 5564;
5566 -> 5186;
5566 -> 5564;
5567 -> 5566;
5567 -> 5186;
5567 -> 5564;
5568 -> 5564;
5569 -> 5567;
5570 -> 5421;
5571 -> 5438;
5571 -> 5186;
5571 -> 5570;
5571 -> 5421;
5572 -> 5428;
5572 -> 5421;
5573 -> 5421;
5574 -> 5426;
5574 -> 5573;
5574 -> 5421;
5575 -> 5574;
5576 -> 5575;
5577 -> 5576;
5578 -> 5186;
5579 -> 5186;
5580 -> 5186;
5581 -> 5281;
5582 -> 5282;
5582 -> 5281;
5583 -> 5283;
5583 -> 5281;
5584 -> 5281;
5585 -> 5581;
5585 -> 5584;
5586 -> 5582;
5586 -> 5584;
5587 -> 5583;
5587 -> 5584;
5588 -> 4793;
5588 -> 5584;
5589 -> 5584;
5590 -> 5588;
5590 -> 5186;
5590 -> 5589;
5590 -> 5584;
5591 -> 5585;
5591 -> 5584;
5592 -> 5584;
5593 -> 5591;
5593 -> 5592;
5594 -> 5588;
5594 -> 5592;
5595 -> 5592;
5596 -> 5594;
5596 -> 5186;
5596 -> 5595;
5596 -> 5592;
5597 -> 5584;
5598 -> 5277;
5599 -> 5278;
5599 -> 5277;
5600 -> 5096;
5600 -> 5093;
5601 -> 5098;
5601 -> 5093;
5602 -> 5097;
5602 -> 5093;
5603 -> 5093;
5604 -> 5084;
5605 -> 5077;
5605 -> 5076;
5606 -> 5076;
5607 -> 5605;
5607 -> 5606;
5608 -> 5607;
5608 -> 5606;
5609 -> 5606;
5610 -> 5608;
5610 -> 5609;
5611 -> 5610;
5611 -> 5609;
5612 -> 5609;
5613 -> 5609;
5614 -> 5611;
5614 -> 5613;
5615 -> 5612;
5615 -> 5613;
5616 -> 5613;
5617 -> 5614;
5617 -> 5616;
5617 -> 5613;
5618 -> 5614;
5618 -> 5613;
5619 -> 5614;
5619 -> 5613;
5620 -> 5615;
5620 -> 5618;
5620 -> 5619;
5620 -> 5613;
5621 -> 5614;
5621 -> 5613;
5622 -> 5613;
5623 -> 5186;
5623 -> 5622;
5623 -> 5613;
5624 -> 5613;
5625 -> 5614;
5625 -> 5613;
5626 -> 5613;
5627 -> 5625;
5627 -> 5626;
5628 -> 5626;
5629 -> 5626;
5630 -> 5186;
5630 -> 5626;
5631 -> 5630;
5631 -> 5626;
5632 -> 5629;
5632 -> 5631;
5633 -> 5632;
5633 -> 5628;
5633 -> 5626;
5634 -> 5632;
5634 -> 5628;
5634 -> 5626;
5635 -> 5634;
5635 -> 5626;
5636 -> 5627;
5636 -> 5626;
5637 -> 5627;
5637 -> 5626;
5638 -> 5627;
5638 -> 5626;
5639 -> 5626;
5640 -> 5638;
5640 -> 5639;
5641 -> 1850;
5641 -> 5639;
5642 -> 5639;
5643 -> 5640;
5643 -> 5639;
5644 -> 5639;
5645 -> 5644;
5645 -> 5626;
5646 -> 5645;
5647 -> 5646;
5648 -> 1850;
5648 -> 5646;
5649 -> 5626;
5650 -> 5649;
5650 -> 5626;
5651 -> 5626;
5652 -> 5626;
5653 -> 5649;
5653 -> 5652;
5653 -> 5650;
5653 -> 5626;
5654 -> 5626;
5655 -> 5627;
5655 -> 5626;
5656 -> 5649;
5656 -> 5626;
5657 -> 5654;
5657 -> 5626;
5658 -> 5626;
5659 -> 5656;
5659 -> 5658;
5660 -> 5657;
5660 -> 5658;
5661 -> 5660;
5661 -> 5654;
5661 -> 5658;
5662 -> 5658;
5663 -> 5662;
5663 -> 5661;
5663 -> 5658;
5664 -> 5626;
5665 -> 5626;
5666 -> 5649;
5666 -> 5665;
5666 -> 5653;
5666 -> 5626;
5667 -> 5626;
5668 -> 5626;
5669 -> 5626;
5670 -> 5668;
5670 -> 5669;
5670 -> 5626;
5671 -> 5626;
5672 -> 5649;
5672 -> 5671;
5672 -> 5666;
5672 -> 5626;
5673 -> 5654;
5673 -> 5626;
5674 -> 5667;
5674 -> 5626;
5675 -> 0;
5675 -> 5626;
5676 -> 5626;
5677 -> 5626;
5678 -> 5673;
5678 -> 5677;
5679 -> 5674;
5679 -> 5677;
5680 -> 5675;
5680 -> 5677;
5681 -> 5676;
5681 -> 5677;
5682 -> 5676;
5682 -> 5677;
5683 -> 5677;
5684 -> 5681;
5684 -> 5683;
5684 -> 5677;
5685 -> 5684;
5685 -> 5677;
5686 -> 4699;
5686 -> 5685;
5687 -> 5677;
5688 -> 5687;
5688 -> 5682;
5688 -> 5677;
5689 -> 5678;
5689 -> 5677;
5690 -> 5679;
5690 -> 5677;
5691 -> 5680;
5691 -> 5677;
5692 -> 5689;
5692 -> 5677;
5693 -> 5690;
5693 -> 5677;
5694 -> 5688;
5694 -> 5677;
5695 -> 5677;
5696 -> 5692;
5696 -> 5695;
5697 -> 5693;
5697 -> 5695;
5698 -> 5694;
5698 -> 5695;
5699 -> 5686;
5699 -> 5695;
5700 -> 5696;
5700 -> 5695;
5701 -> 5696;
5701 -> 5689;
5701 -> 5695;
5702 -> 5697;
5702 -> 5695;
5703 -> 5697;
5703 -> 5690;
5703 -> 5695;
5704 -> 5695;
5705 -> 5700;
5705 -> 5704;
5706 -> 5701;
5706 -> 5704;
5707 -> 5702;
5707 -> 5704;
5708 -> 5703;
5708 -> 5704;
5709 -> 5699;
5709 -> 5704;
5710 -> 5705;
5710 -> 5704;
5711 -> 5706;
5711 -> 5704;
5712 -> 5707;
5712 -> 5704;
5713 -> 5708;
5713 -> 5704;
5714 -> 5704;
5715 -> 5710;
5715 -> 5714;
5716 -> 5711;
5716 -> 5714;
5717 -> 5712;
5717 -> 5714;
5718 -> 5713;
5718 -> 5714;
5719 -> 5709;
5719 -> 5714;
5720 -> 5714;
5721 -> 5716;
5721 -> 5720;
5721 -> 5714;
5722 -> 5714;
5723 -> 5718;
5723 -> 5722;
5723 -> 5714;
5724 -> 5721;
5724 -> 5723;
5724 -> 5714;
5725 -> 5714;
5726 -> 5725;
5726 -> 5724;
5726 -> 5714;
5727 -> 5714;
5728 -> 5727;
5728 -> 5716;
5728 -> 5714;
5729 -> 5714;
5730 -> 5729;
5730 -> 5718;
5730 -> 5714;
5731 -> 5714;
5732 -> 5731;
5732 -> 5716;
5732 -> 5714;
5733 -> 5724;
5733 -> 5714;
5734 -> 5706;
5734 -> 5704;
5735 -> 5708;
5735 -> 5704;
5736 -> 5704;
5737 -> 5734;
5737 -> 5736;
5737 -> 5704;
5738 -> 5704;
5739 -> 5734;
5739 -> 5738;
5739 -> 5704;
5740 -> 5704;
5741 -> 5735;
5741 -> 5740;
5741 -> 5704;
5742 -> 5704;
5743 -> 5742;
5743 -> 5695;
5744 -> 5695;
5745 -> 5744;
5745 -> 5677;
5746 -> 5691;
5746 -> 5745;
5746 -> 5677;
5747 -> 5649;
5747 -> 5746;
5747 -> 5672;
5747 -> 5626;
5748 -> 5667;
5748 -> 5626;
5749 -> 5654;
5749 -> 5626;
5750 -> 5649;
5750 -> 5747;
5750 -> 5626;
5751 -> 5750;
5751 -> 5613;
5752 -> 5606;
5753 -> 5076;
5754 -> 4793;
5754 -> 5076;
5755 -> 5186;
5755 -> 5076;
5756 -> 5076;
5757 -> 5754;
5757 -> 5756;
5758 -> 5755;
5758 -> 5756;
5759 -> 5758;
5759 -> 5756;
5760 -> 5076;
5761 -> 4783;
5762 -> 4783;
5763 -> 5761;
5763 -> 5762;
5764 -> 5761;
5764 -> 5762;
5765 -> 5761;
5765 -> 5762;
5766 -> 5763;
5766 -> 5762;
5767 -> 5764;
5767 -> 5762;
5768 -> 5765;
5768 -> 5762;
5769 -> 5762;
5770 -> 5766;
5770 -> 5769;
5771 -> 5767;
5771 -> 5769;
5772 -> 5768;
5772 -> 5769;
5773 -> 5772;
5773 -> 5769;
5774 -> 5769;
5775 -> 5769;
5776 -> 5774;
5776 -> 5775;
5777 -> 5773;
5777 -> 5775;
5778 -> 5774;
5778 -> 5775;
5779 -> 5774;
5779 -> 5775;
5780 -> 5774;
5780 -> 5775;
5781 -> 5774;
5781 -> 5775;
5782 -> 5774;
5782 -> 5775;
5783 -> 5774;
5783 -> 5775;
5784 -> 5775;
5785 -> 5775;
5786 -> 5778;
5786 -> 5785;
5786 -> 5775;
5787 -> 5775;
5788 -> 5186;
5789 -> 0;
5789 -> 5788;
5790 -> 5789;
5790 -> 5186;
5791 -> 5784;
5791 -> 5775;
5792 -> 5783;
5792 -> 5775;
5793 -> 5775;
5794 -> 5782;
5794 -> 5775;
5795 -> 5779;
5795 -> 5775;
5796 -> 5780;
5796 -> 5775;
5797 -> 5781;
5797 -> 5775;
5798 -> 5776;
5798 -> 5775;
5799 -> 5186;
5799 -> 5793;
5800 -> 5186;
5800 -> 5793;
5801 -> 5186;
5801 -> 5793;
5802 -> 5186;
5802 -> 5793;
5803 -> 5186;
5803 -> 5793;
5804 -> 5186;
5804 -> 5793;
5805 -> 5793;
5806 -> 5186;
5806 -> 5805;
5807 -> 5802;
5807 -> 5805;
5808 -> 5805;
5809 -> 5806;
5809 -> 5808;
5810 -> 5808;
5811 -> 5810;
5812 -> 5811;
5813 -> 5186;
5813 -> 5811;
5814 -> 5805;
5815 -> 5793;
5816 -> 5806;
5816 -> 5815;
5816 -> 5793;
5817 -> 5793;
5818 -> 5817;
5819 -> 5818;
5820 -> 5806;
5820 -> 5818;
5821 -> 5817;
5822 -> 5817;
5823 -> 5822;
5824 -> 5806;
5824 -> 5822;
5825 -> 5806;
5825 -> 5817;
5826 -> 5817;
5827 -> 5793;
5828 -> 5793;
5829 -> 5806;
5830 -> 5806;
5831 -> 5806;
5832 -> 5806;
5833 -> 5793;
5834 -> 5799;
5834 -> 5833;
5834 -> 5793;
5835 -> 5793;
5836 -> 5800;
5836 -> 5835;
5836 -> 5793;
5837 -> 5793;
5838 -> 5801;
5838 -> 5837;
5838 -> 5793;
5839 -> 5793;
5840 -> 5186;
5840 -> 5793;
5841 -> 5840;
5842 -> 0;
5842 -> 5840;
5843 -> 5841;
5843 -> 5842;
5843 -> 5840;
5844 -> 0;
5844 -> 5793;
5845 -> 5793;
5846 -> 5793;
5847 -> 5844;
5847 -> 5846;
5848 -> 5845;
5848 -> 5846;
5849 -> 5846;
5850 -> 5847;
5850 -> 5846;
5851 -> 5848;
5851 -> 5846;
5852 -> 5849;
5852 -> 5846;
5853 -> 5846;
5854 -> 5850;
5854 -> 5853;
5855 -> 5851;
5855 -> 5853;
5856 -> 5852;
5856 -> 5853;
5857 -> 5853;
5858 -> 5854;
5858 -> 0;
5858 -> 5853;
5859 -> 5858;
5859 -> 5855;
5859 -> 5853;
5860 -> 5859;
5861 -> 5860;
5862 -> 5861;
5863 -> 5859;
5864 -> 5806;
5865 -> 5806;
5866 -> 5859;
5867 -> 5806;
5868 -> 5854;
5868 -> 0;
5868 -> 5853;
5869 -> 5857;
5869 -> 5868;
5870 -> 5868;
5871 -> 5868;
5872 -> 5868;
5873 -> 5186;
5873 -> 5872;
5874 -> 5873;
5874 -> 5806;
5874 -> 5872;
5875 -> 5874;
5875 -> 5868;
5876 -> 5868;
5877 -> 5868;
5878 -> 5868;
5879 -> 5877;
5879 -> 5878;
5880 -> 5877;
5880 -> 5878;
5881 -> 5877;
5881 -> 5878;
5882 -> 5878;
5883 -> 5878;
5884 -> 5878;
5885 -> 5879;
5885 -> 5884;
5885 -> 5878;
5886 -> 5878;
5887 -> 5886;
5888 -> 5887;
5889 -> 5806;
5889 -> 5887;
5890 -> 5883;
5890 -> 5878;
5891 -> 5879;
5891 -> 5878;
5892 -> 5891;
5893 -> 5891;
5894 -> 5878;
5895 -> 5881;
5895 -> 5894;
5895 -> 5878;
5896 -> 5879;
5896 -> 5878;
5897 -> 5880;
5897 -> 5878;
5898 -> 5878;
5899 -> 5896;
5899 -> 5898;
5900 -> 5897;
5900 -> 5898;
5901 -> 5898;
5902 -> 5899;
5902 -> 5901;
5902 -> 5898;
5903 -> 5186;
5903 -> 5806;
5903 -> 5898;
5904 -> 5868;
5905 -> 5186;
5905 -> 5806;
5905 -> 5904;
5905 -> 5868;
5906 -> 5854;
5906 -> 0;
5906 -> 5853;
5907 -> 5856;
5907 -> 5853;
5908 -> 5857;
5908 -> 5853;
5909 -> 5853;
5910 -> 5846;
5911 -> 5186;
5911 -> 5806;
5911 -> 5841;
5911 -> 5843;
5911 -> 5793;
5912 -> 5841;
5912 -> 5911;
5912 -> 5793;
5913 -> 5911;
5913 -> 5186;
5914 -> 5186;
5914 -> 5912;
5915 -> 5186;
5916 -> 5186;
5917 -> 5915;
5917 -> 5916;
5918 -> 5915;
5918 -> 5916;
5919 -> 5915;
5919 -> 5916;
5920 -> 5916;
5921 -> 5918;
5921 -> 5920;
5921 -> 5916;
5922 -> 5918;
5922 -> 5916;
5923 -> 5919;
5923 -> 5916;
5924 -> 5916;
5925 -> 5916;
5926 -> 5922;
5926 -> 5925;
5927 -> 5923;
5927 -> 5925;
5928 -> 5924;
5928 -> 5925;
5929 -> 5925;
5930 -> 5929;
5930 -> 5925;
5931 -> 5925;
5932 -> 5926;
5932 -> 5931;
5932 -> 5925;
5933 -> 5926;
5933 -> 5929;
5933 -> 5925;
5934 -> 5927;
5934 -> 5929;
5934 -> 5925;
5935 -> 5916;
5936 -> 5917;
5936 -> 5935;
5937 -> 5936;
5937 -> 5912;
5937 -> 5935;
5938 -> 5936;
5938 -> 5912;
5938 -> 5935;
5939 -> 5938;
5939 -> 5935;
5940 -> 5936;
5940 -> 5912;
5940 -> 5935;
5941 -> 5940;
5941 -> 5916;
5942 -> 5941;
5942 -> 5924;
5942 -> 5940;
5942 -> 5929;
5942 -> 5930;
5942 -> 5933;
5942 -> 5934;
5942 -> 5806;
5942 -> 5916;
5943 -> 5916;
5944 -> 5942;
5944 -> 5943;
5945 -> 5942;
5945 -> 5943;
5946 -> 5945;
5946 -> 5942;
5946 -> 5943;
5947 -> 5944;
5947 -> 5946;
5947 -> 5943;
5948 -> 5945;
5948 -> 5947;
5949 -> 5947;
5950 -> 5948;
5950 -> 5949;
5951 -> 5948;
5951 -> 5949;
5952 -> 5951;
5952 -> 5948;
5952 -> 5949;
5953 -> 5950;
5953 -> 5949;
5954 -> 5949;
5955 -> 5953;
5955 -> 5954;
5955 -> 5949;
5956 -> 5955;
5957 -> 5951;
5957 -> 5952;
5957 -> 5956;
5957 -> 5955;
5958 -> 5951;
5958 -> 5952;
5958 -> 5957;
5959 -> 5950;
5959 -> 5958;
5959 -> 5949;
5960 -> 5793;
5961 -> 5793;
5962 -> 5961;
5963 -> 5962;
5964 -> 5963;
5965 -> 5959;
5965 -> 5963;
5966 -> 5961;
5967 -> 5793;
5968 -> 5967;
5969 -> 5959;
5969 -> 5967;
5970 -> 5793;
5971 -> 5793;
5972 -> 5971;
5973 -> 5959;
5973 -> 5971;
5974 -> 5186;
5974 -> 5793;
5975 -> 5793;
5976 -> 5974;
5976 -> 5959;
5977 -> 5976;
5977 -> 5959;
5978 -> 5959;
5979 -> 5959;
5980 -> 5959;
5981 -> 5959;
5982 -> 5959;
5982 -> 5981;
5983 -> 5977;
5983 -> 5981;
5984 -> 5981;
5985 -> 5982;
5985 -> 5984;
5986 -> 5982;
5986 -> 5984;
5987 -> 5983;
5987 -> 5984;
5988 -> 5959;
5988 -> 5984;
5989 -> 5988;
5989 -> 5959;
5989 -> 5984;
5990 -> 5984;
5991 -> 5986;
5991 -> 5990;
5992 -> 5991;
5992 -> 5984;
5993 -> 5989;
5993 -> 5959;
5993 -> 5984;
5994 -> 5988;
5994 -> 5959;
5994 -> 0;
5994 -> 5984;
5995 -> 5992;
5995 -> 5959;
5995 -> 5984;
5996 -> 5994;
5996 -> 5995;
5996 -> 5984;
5997 -> 5985;
5997 -> 5959;
5997 -> 5984;
5998 -> 5985;
5998 -> 5959;
5998 -> 5984;
5999 -> 5984;
6000 -> 5988;
6000 -> 5959;
6000 -> 5999;
6000 -> 5984;
6001 -> 5981;
6002 -> 5186;
6002 -> 5793;
6003 -> 5186;
6003 -> 5959;
6003 -> 5793;
6004 -> 5793;
6005 -> 6004;
6005 -> 6003;
6005 -> 5959;
6005 -> 5793;
6006 -> 5793;
6007 -> 5959;
6008 -> 5959;
6009 -> 6008;
6009 -> 6007;
6009 -> 5959;
6010 -> 5959;
6011 -> 5959;
6011 -> 6010;
6012 -> 5186;
6012 -> 5793;
6013 -> 6012;
6013 -> 5959;
6013 -> 5793;
6014 -> 6013;
6015 -> 5186;
6015 -> 5793;
6016 -> 6015;
6016 -> 6014;
6016 -> 5793;
6017 -> 5793;
6018 -> 6016;
6018 -> 6017;
6019 -> 5793;
6020 -> 5186;
6020 -> 5793;
6021 -> 6020;
6021 -> 6014;
6021 -> 5793;
6022 -> 5793;
6023 -> 6021;
6023 -> 6022;
6024 -> 6022;
6025 -> 6023;
6025 -> 6022;
6026 -> 6022;
6027 -> 6025;
6027 -> 6026;
6028 -> 6026;
6029 -> 6028;
6030 -> 6028;
6031 -> 6014;
6031 -> 6028;
6032 -> 6031;
6032 -> 6026;
6033 -> 6026;
6034 -> 6014;
6034 -> 6026;
6035 -> 6034;
6036 -> 6032;
6036 -> 6035;
6036 -> 6034;
6037 -> 6036;
6038 -> 6022;
6039 -> 6024;
6039 -> 6022;
6040 -> 6024;
6040 -> 6022;
6041 -> 6024;
6041 -> 6022;
6042 -> 6024;
6042 -> 6022;
6043 -> 6024;
6043 -> 6022;
6044 -> 6024;
6044 -> 6022;
6045 -> 6024;
6045 -> 6022;
6046 -> 6024;
6046 -> 6022;
6047 -> 5793;
6048 -> 5186;
6048 -> 5793;
6049 -> 5793;
6050 -> 5793;
6051 -> 5186;
6051 -> 5793;
6052 -> 5186;
6052 -> 5793;
6053 -> 5793;
6054 -> 5793;
6055 -> 6014;
6055 -> 0;
6055 -> 6054;
6056 -> 6054;
6057 -> 6014;
6058 -> 6014;
6058 -> 6054;
6059 -> 6054;
6060 -> 6059;
6061 -> 6014;
6061 -> 6059;
6062 -> 6054;
6063 -> 6054;
6064 -> 5186;
6064 -> 5793;
6065 -> 5186;
6065 -> 5793;
6066 -> 5186;
6066 -> 5793;
6067 -> 5186;
6067 -> 5793;
6068 -> 5793;
6069 -> 5186;
6069 -> 6068;
6069 -> 5793;
6070 -> 5793;
6071 -> 6064;
6071 -> 6070;
6072 -> 6065;
6072 -> 6070;
6073 -> 6066;
6073 -> 6070;
6074 -> 6067;
6074 -> 6070;
6075 -> 6070;
6076 -> 6070;
6077 -> 5186;
6077 -> 6014;
6077 -> 6070;
6078 -> 6077;
6078 -> 6014;
6078 -> 6070;
6079 -> 5186;
6079 -> 6014;
6079 -> 6070;
6080 -> 6073;
6080 -> 6079;
6081 -> 5186;
6081 -> 6014;
6081 -> 6080;
6082 -> 6077;
6082 -> 6080;
6083 -> 6080;
6084 -> 6082;
6084 -> 6083;
6085 -> 6083;
6086 -> 6084;
6086 -> 6085;
6086 -> 6083;
6087 -> 6086;
6088 -> 6084;
6088 -> 6014;
6088 -> 6086;
6089 -> 6083;
6090 -> 6089;
6090 -> 6080;
6091 -> 6081;
6091 -> 6090;
6091 -> 6080;
6092 -> 5186;
6092 -> 6091;
6093 -> 5186;
6093 -> 6014;
6093 -> 6091;
6094 -> 6070;
6095 -> 6074;
6095 -> 6014;
6095 -> 6094;
6095 -> 6070;
6096 -> 5793;
6097 -> 5186;
6097 -> 5793;
6098 -> 5186;
6098 -> 5793;
6099 -> 5793;
6100 -> 6098;
6100 -> 6099;
6100 -> 5793;
6101 -> 6097;
6101 -> 6014;
6102 -> 6098;
6102 -> 6014;
6103 -> 6101;
6103 -> 6014;
6104 -> 6102;
6104 -> 6014;
6105 -> 6014;
6106 -> 6014;
6107 -> 6014;
6108 -> 6104;
6108 -> 6107;
6108 -> 6014;
6109 -> 6014;
6110 -> 6014;
6110 -> 6109;
6111 -> 6014;
6111 -> 0;
6112 -> 6014;
6113 -> 6106;
6113 -> 6112;
6114 -> 6113;
6115 -> 6113;
6116 -> 6014;
6116 -> 6113;
6117 -> 6113;
6118 -> 6116;
6118 -> 6117;
6119 -> 6117;
6120 -> 6118;
6120 -> 6119;
6121 -> 6119;
6122 -> 6120;
6122 -> 6121;
6122 -> 6119;
6123 -> 6119;
6124 -> 6123;
6124 -> 6117;
6125 -> 6014;
6125 -> 6124;
6126 -> 6014;
6127 -> 5186;
6127 -> 5793;
6128 -> 5186;
6128 -> 5793;
6129 -> 5186;
6129 -> 5793;
6130 -> 5186;
6130 -> 5793;
6131 -> 5793;
6132 -> 6128;
6132 -> 6131;
6132 -> 5793;
6133 -> 5186;
6133 -> 6014;
6133 -> 5793;
6134 -> 5186;
6134 -> 6014;
6134 -> 6133;
6135 -> 5186;
6135 -> 6014;
6135 -> 0;
6135 -> 5793;
6136 -> 5186;
6136 -> 6014;
6136 -> 5793;
6137 -> 6130;
6137 -> 6136;
6138 -> 5186;
6138 -> 6014;
6138 -> 5793;
6139 -> 5186;
6139 -> 5793;
6140 -> 5186;
6140 -> 6014;
6140 -> 5793;
6141 -> 5186;
6141 -> 5793;
6142 -> 5793;
6143 -> 5186;
6143 -> 6142;
6143 -> 5793;
6144 -> 5793;
6145 -> 6144;
6145 -> 5793;
6146 -> 5186;
6146 -> 5793;
6147 -> 5793;
6148 -> 5793;
6149 -> 6014;
6149 -> 6148;
6150 -> 6149;
6150 -> 6014;
6150 -> 6148;
6151 -> 6149;
6151 -> 6014;
6151 -> 6150;
6152 -> 6151;
6152 -> 6150;
6153 -> 6150;
6154 -> 6152;
6154 -> 6153;
6155 -> 6154;
6155 -> 6014;
6155 -> 0;
6155 -> 6153;
6156 -> 6154;
6156 -> 6014;
6156 -> 6153;
6157 -> 6153;
6158 -> 6156;
6158 -> 6157;
6159 -> 6157;
6160 -> 6158;
6160 -> 6159;
6160 -> 6157;
6161 -> 6160;
6162 -> 6158;
6162 -> 6014;
6162 -> 6160;
6163 -> 6157;
6164 -> 6163;
6164 -> 6153;
6165 -> 6155;
6165 -> 6164;
6165 -> 6153;
6166 -> 6148;
6167 -> 6166;
6167 -> 5793;
6168 -> 5793;
6169 -> 6014;
6169 -> 6168;
6170 -> 6169;
6170 -> 6014;
6170 -> 6168;
6171 -> 6169;
6171 -> 6014;
6171 -> 6170;
6172 -> 6171;
6172 -> 6170;
6173 -> 6170;
6174 -> 6172;
6174 -> 6173;
6175 -> 6174;
6175 -> 6014;
6175 -> 0;
6175 -> 6173;
6176 -> 6174;
6176 -> 6014;
6176 -> 6173;
6177 -> 6173;
6178 -> 6176;
6178 -> 6177;
6179 -> 6177;
6180 -> 6178;
6180 -> 6179;
6180 -> 6177;
6181 -> 6180;
6182 -> 6178;
6182 -> 6014;
6182 -> 6180;
6183 -> 6177;
6184 -> 6183;
6184 -> 6173;
6185 -> 6175;
6185 -> 6184;
6185 -> 6173;
6186 -> 6168;
6187 -> 5793;
6188 -> 6064;
6188 -> 6014;
6188 -> 6070;
6189 -> 6188;
6189 -> 6014;
6189 -> 6070;
6190 -> 6064;
6190 -> 6014;
6190 -> 6070;
6191 -> 6064;
6191 -> 6190;
6191 -> 6070;
6192 -> 6073;
6192 -> 6191;
6193 -> 6064;
6193 -> 6190;
6193 -> 6192;
6194 -> 6188;
6194 -> 6192;
6195 -> 6192;
6196 -> 6194;
6196 -> 6195;
6197 -> 6195;
6198 -> 6196;
6198 -> 6197;
6198 -> 6195;
6199 -> 6198;
6200 -> 6196;
6200 -> 6190;
6200 -> 6198;
6201 -> 6195;
6202 -> 6201;
6202 -> 6192;
6203 -> 6193;
6203 -> 6202;
6203 -> 6192;
6204 -> 6064;
6204 -> 6203;
6205 -> 6064;
6205 -> 6190;
6205 -> 6203;
6206 -> 6074;
6206 -> 6190;
6206 -> 6094;
6206 -> 6070;
6207 -> 5186;
6207 -> 6190;
6207 -> 5793;
6208 -> 5186;
6208 -> 6190;
6208 -> 6207;
6209 -> 5186;
6209 -> 6190;
6209 -> 0;
6209 -> 5793;
6210 -> 5186;
6210 -> 6190;
6210 -> 5793;
6211 -> 6130;
6211 -> 6210;
6212 -> 5186;
6212 -> 6190;
6212 -> 5793;
6213 -> 5186;
6213 -> 6190;
6213 -> 5793;
6214 -> 6097;
6214 -> 6190;
6215 -> 6098;
6215 -> 6190;
6216 -> 6214;
6216 -> 6190;
6217 -> 6215;
6217 -> 6190;
6218 -> 6190;
6219 -> 6190;
6220 -> 6190;
6221 -> 6217;
6221 -> 6220;
6221 -> 6190;
6222 -> 6190;
6223 -> 6190;
6223 -> 6222;
6224 -> 6190;
6224 -> 0;
6225 -> 6190;
6226 -> 6219;
6226 -> 6225;
6227 -> 6226;
6228 -> 6226;
6229 -> 6190;
6229 -> 6226;
6230 -> 6226;
6231 -> 6229;
6231 -> 6230;
6232 -> 6230;
6233 -> 6231;
6233 -> 6232;
6234 -> 6232;
6235 -> 6233;
6235 -> 6234;
6235 -> 6232;
6236 -> 6232;
6237 -> 6236;
6237 -> 6230;
6238 -> 6190;
6238 -> 6237;
6239 -> 6190;
6240 -> 6064;
6240 -> 6190;
6240 -> 6070;
6241 -> 6240;
6241 -> 6190;
6241 -> 6070;
6242 -> 6240;
6242 -> 6192;
6243 -> 6242;
6243 -> 6195;
6244 -> 6243;
6244 -> 6197;
6244 -> 6195;
6245 -> 6244;
6246 -> 6243;
6246 -> 6190;
6246 -> 6244;
6247 -> 6235;
6248 -> 6233;
6248 -> 6190;
6248 -> 6235;
6249 -> 6190;
6249 -> 6148;
6250 -> 6249;
6250 -> 6190;
6250 -> 6148;
6251 -> 6249;
6251 -> 6190;
6251 -> 6250;
6252 -> 6251;
6252 -> 6250;
6253 -> 6250;
6254 -> 6252;
6254 -> 6253;
6255 -> 6254;
6255 -> 6190;
6255 -> 0;
6255 -> 6253;
6256 -> 6254;
6256 -> 6190;
6256 -> 6253;
6257 -> 6253;
6258 -> 6256;
6258 -> 6257;
6259 -> 6257;
6260 -> 6258;
6260 -> 6259;
6260 -> 6257;
6261 -> 6260;
6262 -> 6258;
6262 -> 6190;
6262 -> 6260;
6263 -> 6257;
6264 -> 6263;
6264 -> 6253;
6265 -> 6255;
6265 -> 6264;
6265 -> 6253;
6266 -> 6190;
6266 -> 6168;
6267 -> 6266;
6267 -> 6190;
6267 -> 6168;
6268 -> 6266;
6268 -> 6190;
6268 -> 6267;
6269 -> 6268;
6269 -> 6267;
6270 -> 6267;
6271 -> 6269;
6271 -> 6270;
6272 -> 6271;
6272 -> 6190;
6272 -> 0;
6272 -> 6270;
6273 -> 6271;
6273 -> 6190;
6273 -> 6270;
6274 -> 6270;
6275 -> 6273;
6275 -> 6274;
6276 -> 6274;
6277 -> 6275;
6277 -> 6276;
6277 -> 6274;
6278 -> 6277;
6279 -> 6275;
6279 -> 6190;
6279 -> 6277;
6280 -> 6274;
6281 -> 6280;
6281 -> 6270;
6282 -> 6272;
6282 -> 6281;
6282 -> 6270;
6283 -> 5793;
6284 -> 5974;
6284 -> 6190;
6285 -> 6284;
6285 -> 6190;
6286 -> 6190;
6287 -> 5186;
6287 -> 6190;
6287 -> 5793;
6288 -> 6004;
6288 -> 6287;
6288 -> 6190;
6288 -> 5793;
6289 -> 5793;
6290 -> 6015;
6290 -> 6190;
6290 -> 5793;
6291 -> 6290;
6291 -> 6017;
6292 -> 6020;
6292 -> 6190;
6292 -> 5793;
6293 -> 6292;
6293 -> 6022;
6294 -> 6293;
6294 -> 6022;
6295 -> 6294;
6295 -> 6026;
6296 -> 6190;
6296 -> 6028;
6297 -> 6296;
6297 -> 6026;
6298 -> 6190;
6298 -> 6026;
6299 -> 6298;
6300 -> 6297;
6300 -> 6299;
6300 -> 6298;
6301 -> 6300;
6302 -> 5186;
6302 -> 6190;
6302 -> 5793;
6303 -> 5793;
6304 -> 6303;
6305 -> 6304;
6306 -> 6305;
6307 -> 6190;
6307 -> 6305;
6308 -> 6303;
6309 -> 6190;
6309 -> 5793;
6310 -> 5793;
6311 -> 5186;
6311 -> 5793;
6312 -> 5186;
6312 -> 5793;
6313 -> 5186;
6313 -> 6190;
6313 -> 5793;
6314 -> 6190;
6315 -> 6190;
6315 -> 6314;
6316 -> 6314;
6317 -> 6316;
6317 -> 6315;
6317 -> 6190;
6317 -> 6314;
6318 -> 6190;
6319 -> 6190;
6320 -> 6319;
6320 -> 6190;
6321 -> 6190;
6322 -> 6190;
6323 -> 6190;
6324 -> 6322;
6324 -> 6323;
6325 -> 6322;
6325 -> 6323;
6326 -> 6321;
6326 -> 6323;
6327 -> 6323;
6328 -> 6325;
6328 -> 6327;
6328 -> 6323;
6329 -> 6321;
6329 -> 6322;
6330 -> 6322;
6331 -> 6322;
6331 -> 6330;
6332 -> 6322;
6332 -> 6330;
6333 -> 6329;
6333 -> 6330;
6334 -> 6330;
6335 -> 6332;
6335 -> 6334;
6335 -> 6330;
6336 -> 6322;
6336 -> 6190;
6337 -> 6190;
6338 -> 5186;
6338 -> 6322;
6338 -> 6190;
6338 -> 6337;
6339 -> 5186;
6339 -> 5793;
6340 -> 5186;
6340 -> 5793;
6341 -> 5186;
6341 -> 5793;
6342 -> 6341;
6342 -> 6322;
6342 -> 5793;
6343 -> 6342;
6343 -> 6322;
6343 -> 5793;
6344 -> 5793;
6345 -> 6344;
6345 -> 6343;
6345 -> 5793;
6346 -> 5186;
6346 -> 5793;
6347 -> 0;
6347 -> 5793;
6348 -> 5186;
6348 -> 6322;
6348 -> 5793;
6349 -> 5186;
6349 -> 6322;
6349 -> 5793;
6350 -> 5186;
6350 -> 6322;
6350 -> 6349;
6351 -> 5186;
6351 -> 6322;
6351 -> 0;
6351 -> 5793;
6352 -> 5186;
6352 -> 6322;
6352 -> 5793;
6353 -> 6130;
6353 -> 6352;
6354 -> 5186;
6354 -> 6322;
6354 -> 5793;
6355 -> 5186;
6355 -> 6322;
6355 -> 5793;
6356 -> 6322;
6356 -> 0;
6356 -> 6054;
6357 -> 6322;
6358 -> 6322;
6358 -> 6054;
6359 -> 6064;
6359 -> 6322;
6359 -> 6070;
6360 -> 6359;
6360 -> 6322;
6360 -> 6070;
6361 -> 6064;
6361 -> 6322;
6361 -> 6070;
6362 -> 6073;
6362 -> 6361;
6363 -> 6064;
6363 -> 6322;
6363 -> 6362;
6364 -> 6359;
6364 -> 6362;
6365 -> 6362;
6366 -> 6364;
6366 -> 6365;
6367 -> 6365;
6368 -> 6366;
6368 -> 6367;
6368 -> 6365;
6369 -> 6368;
6370 -> 6366;
6370 -> 6322;
6370 -> 6368;
6371 -> 6365;
6372 -> 6371;
6372 -> 6362;
6373 -> 6363;
6373 -> 6372;
6373 -> 6362;
6374 -> 6064;
6374 -> 6373;
6375 -> 6064;
6375 -> 6322;
6375 -> 6373;
6376 -> 6074;
6376 -> 6322;
6376 -> 6094;
6376 -> 6070;
6377 -> 6322;
6377 -> 6148;
6378 -> 6377;
6378 -> 6322;
6378 -> 6148;
6379 -> 6377;
6379 -> 6322;
6379 -> 6378;
6380 -> 6379;
6380 -> 6378;
6381 -> 6378;
6382 -> 6380;
6382 -> 6381;
6383 -> 6382;
6383 -> 6322;
6383 -> 0;
6383 -> 6381;
6384 -> 6382;
6384 -> 6322;
6384 -> 6381;
6385 -> 6381;
6386 -> 6384;
6386 -> 6385;
6387 -> 6385;
6388 -> 6386;
6388 -> 6387;
6388 -> 6385;
6389 -> 6388;
6390 -> 6386;
6390 -> 6322;
6390 -> 6388;
6391 -> 6385;
6392 -> 6391;
6392 -> 6381;
6393 -> 6383;
6393 -> 6392;
6393 -> 6381;
6394 -> 6322;
6394 -> 6168;
6395 -> 6394;
6395 -> 6322;
6395 -> 6168;
6396 -> 6394;
6396 -> 6322;
6396 -> 6395;
6397 -> 6396;
6397 -> 6395;
6398 -> 6395;
6399 -> 6397;
6399 -> 6398;
6400 -> 6399;
6400 -> 6322;
6400 -> 0;
6400 -> 6398;
6401 -> 6399;
6401 -> 6322;
6401 -> 6398;
6402 -> 6398;
6403 -> 6401;
6403 -> 6402;
6404 -> 6402;
6405 -> 6403;
6405 -> 6404;
6405 -> 6402;
6406 -> 6405;
6407 -> 6403;
6407 -> 6322;
6407 -> 6405;
6408 -> 6402;
6409 -> 6408;
6409 -> 6398;
6410 -> 6400;
6410 -> 6409;
6410 -> 6398;
6411 -> 6097;
6411 -> 6322;
6412 -> 6098;
6412 -> 6322;
6413 -> 6411;
6413 -> 6322;
6414 -> 6412;
6414 -> 6322;
6415 -> 6322;
6416 -> 6322;
6417 -> 6322;
6418 -> 6414;
6418 -> 6417;
6418 -> 6322;
6419 -> 6322;
6420 -> 6322;
6420 -> 6419;
6421 -> 6322;
6421 -> 0;
6422 -> 6322;
6423 -> 6416;
6423 -> 6422;
6424 -> 6423;
6425 -> 6423;
6426 -> 6322;
6426 -> 6423;
6427 -> 6423;
6428 -> 6426;
6428 -> 6427;
6429 -> 6427;
6430 -> 6428;
6430 -> 6429;
6431 -> 6429;
6432 -> 6430;
6432 -> 6431;
6432 -> 6429;
6433 -> 6429;
6434 -> 6433;
6434 -> 6427;
6435 -> 6322;
6435 -> 6434;
6436 -> 6322;
6437 -> 6432;
6438 -> 6430;
6438 -> 6322;
6438 -> 6432;
6439 -> 5186;
6439 -> 6322;
6439 -> 5793;
6440 -> 6322;
6440 -> 6305;
6441 -> 6322;
6441 -> 5793;
6442 -> 5793;
6443 -> 5793;
6444 -> 5793;
6445 -> 5793;
6446 -> 5186;
6446 -> 6322;
6447 -> 6322;
6448 -> 6446;
6448 -> 6322;
6448 -> 6447;
6449 -> 6322;
6450 -> 6322;
6451 -> 6322;
6452 -> 6322;
6453 -> 6322;
6454 -> 6442;
6454 -> 5793;
6455 -> 6322;
6455 -> 5971;
6456 -> 6322;
6456 -> 5775;
6457 -> 5775;
6458 -> 5775;
6459 -> 5777;
6459 -> 6458;
6459 -> 5775;
6460 -> 5784;
6460 -> 5775;
6461 -> 5769;
6462 -> 4785;
6462 -> 4783;
6463 -> 4783;
6464 -> 4783;
6465 -> 6463;
6465 -> 6464;
6466 -> 6465;
6466 -> 6464;
6467 -> 6464;
6468 -> 6466;
6468 -> 6467;
6469 -> 6467;
6470 -> 6468;
6470 -> 6469;
6470 -> 6467;
6471 -> 6467;
6471 -> 4783;
6472 -> 6462;
6472 -> 6464;
6473 -> 6463;
6473 -> 6464;
6474 -> 6463;
6474 -> 6464;
6475 -> 6471;
6475 -> 6464;
6476 -> 6463;
6476 -> 6464;
6477 -> 6463;
6477 -> 6464;
6478 -> 6463;
6478 -> 6464;
6479 -> 6472;
6479 -> 6464;
6480 -> 6475;
6480 -> 6464;
6481 -> 6473;
6481 -> 6464;
6482 -> 6464;
6483 -> 6480;
6483 -> 6482;
6484 -> 6481;
6484 -> 6482;
6485 -> 6483;
6485 -> 6482;
6486 -> 6482;
6487 -> 6485;
6487 -> 6486;
6488 -> 6487;
6488 -> 6486;
6489 -> 6488;
6490 -> 0;
6490 -> 6489;
6491 -> 6490;
6492 -> 6491;
6493 -> 6482;
6494 -> 6484;
6494 -> 6493;
6494 -> 6482;
6495 -> 6484;
6495 -> 6482;
6496 -> 6482;
6497 -> 6495;
6497 -> 6496;
6498 -> 6496;
6499 -> 6322;
6500 -> 6499;
6501 -> 6322;
6501 -> 6499;
6502 -> 0;
6502 -> 6496;
6503 -> 6497;
6503 -> 6496;
6504 -> 6322;
6505 -> 6500;
6505 -> 6504;
6505 -> 6501;
6505 -> 3765;
6505 -> 6322;
6506 -> 6482;
6507 -> 6484;
6507 -> 6482;
6508 -> 6474;
6508 -> 6464;
6509 -> 6476;
6509 -> 6464;
6510 -> 6477;
6510 -> 6464;
6511 -> 6478;
6511 -> 6464;
6512 -> 6464;
6513 -> 6479;
6513 -> 6512;
6514 -> 6508;
6514 -> 6512;
6515 -> 6509;
6515 -> 6512;
6516 -> 6510;
6516 -> 6512;
6517 -> 6511;
6517 -> 6512;
6518 -> 6513;
6518 -> 6512;
6519 -> 6514;
6519 -> 6512;
6520 -> 6515;
6520 -> 6512;
6521 -> 6516;
6521 -> 6512;
6522 -> 6517;
6522 -> 6512;
6523 -> 6512;
6524 -> 6523;
6524 -> 6512;
6525 -> 6512;
6526 -> 6518;
6526 -> 6525;
6527 -> 6519;
6527 -> 6525;
6528 -> 6520;
6528 -> 6525;
6529 -> 6521;
6529 -> 6525;
6530 -> 6522;
6530 -> 6525;
6531 -> 6524;
6531 -> 6525;
6532 -> 6527;
6532 -> 6525;
6533 -> 6529;
6533 -> 6525;
6534 -> 6525;
6535 -> 6532;
6535 -> 6534;
6536 -> 6533;
6536 -> 6534;
6537 -> 6526;
6537 -> 6534;
6538 -> 6537;
6538 -> 6462;
6538 -> 6534;
6539 -> 6538;
6540 -> 6536;
6540 -> 6538;
6541 -> 6535;
6541 -> 6538;
6542 -> 6538;
6543 -> 6539;
6543 -> 6542;
6544 -> 6540;
6544 -> 6542;
6545 -> 6541;
6545 -> 6542;
6546 -> 6539;
6546 -> 6542;
6547 -> 6542;
6548 -> 6545;
6548 -> 6547;
6548 -> 6542;
6549 -> 0;
6549 -> 6548;
6550 -> 6543;
6550 -> 6542;
6551 -> 0;
6551 -> 6542;
6552 -> 6551;
6552 -> 6546;
6552 -> 6542;
6553 -> 6542;
6554 -> 6549;
6554 -> 6542;
6555 -> 6544;
6555 -> 6542;
6556 -> 6542;
6557 -> 6542;
6558 -> 6557;
6559 -> 6557;
6560 -> 6322;
6560 -> 6559;
6560 -> 6557;
6561 -> 6558;
6561 -> 6557;
6562 -> 6557;
6563 -> 6560;
6563 -> 6322;
6563 -> 6559;
6563 -> 6561;
6563 -> 6562;
6563 -> 6558;
6563 -> 6557;
6564 -> 6557;
6565 -> 6564;
6565 -> 6558;
6565 -> 6557;
6566 -> 6558;
6566 -> 6557;
6567 -> 6557;
6568 -> 6566;
6568 -> 6567;
6568 -> 6558;
6568 -> 6565;
6568 -> 6557;
6569 -> 6539;
6569 -> 6525;
6570 -> 6525;
6571 -> 6322;
6571 -> 6570;
6571 -> 6525;
6572 -> 0;
6572 -> 6525;
6573 -> 6531;
6573 -> 6525;
6574 -> 6322;
6574 -> 6525;
6575 -> 6525;
6576 -> 6574;
6576 -> 6575;
6577 -> 0;
6577 -> 6575;
6578 -> 6577;
6579 -> 6525;
6580 -> 6525;
6581 -> 6580;
6582 -> 6580;
6583 -> 6580;
6584 -> 6582;
6584 -> 6583;
6585 -> 6582;
6585 -> 6583;
6586 -> 6582;
6586 -> 6583;
6587 -> 6582;
6587 -> 6583;
6588 -> 6583;
6589 -> 6322;
6589 -> 6588;
6589 -> 6583;
6590 -> 6587;
6590 -> 6583;
6591 -> 6584;
6591 -> 6583;
6592 -> 6585;
6592 -> 6583;
6593 -> 6586;
6593 -> 6583;
6594 -> 6587;
6594 -> 6583;
6595 -> 6583;
6596 -> 0;
6596 -> 6583;
6597 -> 6583;
6598 -> 6596;
6598 -> 6597;
6599 -> 6596;
6599 -> 6597;
6600 -> 6594;
6600 -> 6597;
6601 -> 6595;
6601 -> 6597;
6602 -> 6595;
6602 -> 6597;
6603 -> 6598;
6603 -> 6597;
6604 -> 6599;
6604 -> 6597;
6605 -> 6600;
6605 -> 6597;
6606 -> 6597;
6607 -> 6606;
6607 -> 6597;
6608 -> 6601;
6608 -> 6606;
6608 -> 6597;
6609 -> 6583;
6610 -> 6591;
6610 -> 6609;
6611 -> 6592;
6611 -> 6609;
6612 -> 6593;
6612 -> 6609;
6613 -> 6594;
6613 -> 6609;
6614 -> 6595;
6614 -> 6609;
6615 -> 6595;
6615 -> 6609;
6616 -> 6595;
6616 -> 6609;
6617 -> 6595;
6617 -> 6609;
6618 -> 6595;
6618 -> 6609;
6619 -> 6595;
6619 -> 6609;
6620 -> 6610;
6620 -> 6609;
6621 -> 6611;
6621 -> 6609;
6622 -> 6612;
6622 -> 6609;
6623 -> 6613;
6623 -> 6609;
6624 -> 6614;
6624 -> 6609;
6625 -> 6615;
6625 -> 6609;
6626 -> 6616;
6626 -> 6609;
6627 -> 6617;
6627 -> 6609;
6628 -> 6618;
6628 -> 6609;
6629 -> 6609;
6630 -> 6620;
6630 -> 6629;
6631 -> 6621;
6631 -> 6629;
6632 -> 6622;
6632 -> 6629;
6633 -> 6623;
6633 -> 6629;
6634 -> 6624;
6634 -> 6629;
6635 -> 6625;
6635 -> 6629;
6636 -> 6626;
6636 -> 6629;
6637 -> 6627;
6637 -> 6629;
6638 -> 6628;
6638 -> 6629;
6639 -> 6619;
6639 -> 6629;
6640 -> 6633;
6640 -> 6629;
6641 -> 6637;
6641 -> 6629;
6642 -> 6638;
6642 -> 6629;
6643 -> 6629;
6644 -> 6643;
6644 -> 6629;
6645 -> 6643;
6645 -> 6629;
6646 -> 6643;
6646 -> 6629;
6647 -> 6643;
6647 -> 6629;
6648 -> 6643;
6648 -> 6629;
6649 -> 6643;
6649 -> 6629;
6650 -> 6643;
6650 -> 6629;
6651 -> 6643;
6651 -> 6629;
6652 -> 6643;
6652 -> 6629;
6653 -> 6643;
6653 -> 6629;
6654 -> 6643;
6654 -> 6629;
6655 -> 6643;
6655 -> 6629;
6656 -> 6643;
6656 -> 6629;
6657 -> 6643;
6657 -> 6629;
6658 -> 6643;
6658 -> 6629;
6659 -> 6643;
6659 -> 6629;
6660 -> 6643;
6660 -> 6629;
6661 -> 6643;
6661 -> 6629;
6662 -> 6643;
6662 -> 6629;
6663 -> 6643;
6663 -> 6629;
6664 -> 6643;
6664 -> 6629;
6665 -> 6643;
6665 -> 6629;
6666 -> 6643;
6666 -> 6629;
6667 -> 6643;
6667 -> 6629;
6668 -> 6643;
6668 -> 6629;
6669 -> 6643;
6669 -> 6629;
6670 -> 6629;
6671 -> 6670;
6671 -> 6643;
6671 -> 6629;
6672 -> 6643;
6672 -> 6629;
6673 -> 6643;
6673 -> 6629;
6674 -> 6629;
6675 -> 6629;
6676 -> 6673;
6676 -> 6675;
6677 -> 6674;
6677 -> 6675;
6678 -> 6677;
6678 -> 6675;
6679 -> 6677;
6679 -> 6675;
6680 -> 6677;
6680 -> 6675;
6681 -> 6676;
6681 -> 6677;
6681 -> 6675;
6682 -> 6674;
6682 -> 6643;
6682 -> 6629;
6683 -> 6643;
6683 -> 6629;
6684 -> 6629;
6685 -> 6684;
6686 -> 0;
6686 -> 6684;
6687 -> 6686;
6687 -> 6685;
6687 -> 6684;
6688 -> 6687;
6688 -> 6629;
6689 -> 6688;
6689 -> 6643;
6689 -> 6629;
6690 -> 6633;
6690 -> 6629;
6691 -> 6690;
6692 -> 6630;
6692 -> 6691;
6692 -> 6690;
6693 -> 6631;
6693 -> 6691;
6693 -> 6690;
6694 -> 6692;
6694 -> 6693;
6694 -> 6690;
6695 -> 6632;
6695 -> 6691;
6695 -> 6690;
6696 -> 6694;
6696 -> 6695;
6696 -> 6690;
6697 -> 6635;
6697 -> 6629;
6698 -> 6697;
6699 -> 6643;
6699 -> 6698;
6700 -> 6634;
6700 -> 6697;
6701 -> 6636;
6701 -> 6643;
6701 -> 6629;
6702 -> 6643;
6702 -> 6322;
6702 -> 6629;
6703 -> 6629;
6704 -> 6643;
6704 -> 6322;
6704 -> 6703;
6704 -> 6629;
6705 -> 6583;
6706 -> 6322;
6707 -> 6322;
6708 -> 6322;
6709 -> 6322;
6710 -> 6322;
6711 -> 6707;
6711 -> 6322;
6712 -> 6322;
6713 -> 6322;
6714 -> 6322;
6715 -> 6322;
6716 -> 6322;
6717 -> 6322;
6718 -> 6322;
6719 -> 6322;
6720 -> 6717;
6720 -> 6322;
6721 -> 6718;
6721 -> 6322;
6722 -> 6719;
6722 -> 6322;
6723 -> 6720;
6723 -> 6322;
6724 -> 6721;
6724 -> 6322;
6725 -> 6722;
6725 -> 6322;
6726 -> 6322;
6727 -> 6322;
6728 -> 6727;
6729 -> 6723;
6729 -> 6728;
6729 -> 6727;
6730 -> 6724;
6730 -> 6728;
6730 -> 6727;
6731 -> 6729;
6731 -> 6730;
6731 -> 6727;
6732 -> 6725;
6732 -> 6728;
6732 -> 6727;
6733 -> 6731;
6733 -> 6732;
6733 -> 6727;
6734 -> 6322;
6735 -> 6322;
6736 -> 6322;
6737 -> 6322;
6737 -> 6583;
6738 -> 6525;
6739 -> 6738;
6740 -> 6739;
6741 -> 6740;
6742 -> 6322;
6743 -> 6322;
6744 -> 6322;
6745 -> 6322;
6746 -> 6322;
6747 -> 6746;
6747 -> 0;
6747 -> 6322;
6748 -> 6322;
6749 -> 6322;
6750 -> 6322;
6751 -> 6322;
6752 -> 6322;
6753 -> 6322;
6753 -> 6738;
6754 -> 6738;
6755 -> 0;
6755 -> 6738;
6756 -> 6530;
6756 -> 6322;
6756 -> 6525;
6757 -> 4783;
6758 -> 6757;
6759 -> 6757;
6760 -> 6758;
6760 -> 6759;
6761 -> 0;
6761 -> 6759;
6762 -> 6759;
6763 -> 6760;
6763 -> 6759;
6764 -> 6759;
6765 -> 6761;
6765 -> 6764;
6766 -> 6762;
6766 -> 6764;
6767 -> 6763;
6767 -> 6764;
6768 -> 6764;
6769 -> 6765;
6769 -> 6764;
6770 -> 6766;
6770 -> 6764;
6771 -> 6768;
6771 -> 6764;
6772 -> 6767;
6772 -> 6764;
6773 -> 6764;
6774 -> 6769;
6774 -> 6773;
6775 -> 6770;
6775 -> 6773;
6776 -> 6771;
6776 -> 6773;
6777 -> 6772;
6777 -> 6773;
6778 -> 6773;
6779 -> 6774;
6779 -> 0;
6779 -> 6773;
6780 -> 6779;
6780 -> 6775;
6780 -> 6773;
6781 -> 6780;
6782 -> 6781;
6783 -> 6782;
6784 -> 6780;
6785 -> 6322;
6786 -> 6322;
6787 -> 6780;
6788 -> 6322;
6789 -> 6774;
6789 -> 0;
6789 -> 6773;
6790 -> 6789;
6790 -> 6775;
6790 -> 6773;
6791 -> 6778;
6791 -> 6790;
6792 -> 6790;
6793 -> 6790;
6794 -> 6790;
6795 -> 6322;
6795 -> 6794;
6796 -> 6795;
6796 -> 6790;
6797 -> 6790;
6798 -> 6322;
6799 -> 6777;
6799 -> 6790;
6800 -> 6790;
6801 -> 6790;
6802 -> 6800;
6802 -> 6801;
6803 -> 6800;
6803 -> 6801;
6804 -> 6800;
6804 -> 6801;
6805 -> 6799;
6805 -> 6801;
6806 -> 6801;
6807 -> 6806;
6808 -> 6807;
6809 -> 6805;
6809 -> 6801;
6810 -> 6801;
6811 -> 6801;
6812 -> 6802;
6812 -> 6811;
6812 -> 6801;
6813 -> 6801;
6814 -> 6813;
6815 -> 6814;
6816 -> 6322;
6816 -> 6814;
6817 -> 6810;
6817 -> 6801;
6818 -> 6805;
6818 -> 6801;
6819 -> 6801;
6820 -> 6819;
6821 -> 6820;
6822 -> 6821;
6823 -> 6819;
6824 -> 6823;
6825 -> 6824;
6826 -> 6819;
6827 -> 6826;
6828 -> 6322;
6828 -> 6826;
6829 -> 6322;
6829 -> 6819;
6830 -> 6819;
6831 -> 6322;
6831 -> 6819;
6832 -> 6322;
6832 -> 6819;
6833 -> 6832;
6833 -> 6322;
6833 -> 6819;
6834 -> 6819;
6835 -> 6819;
6836 -> 6322;
6836 -> 6819;
6837 -> 6819;
6838 -> 6322;
6838 -> 6819;
6839 -> 6819;
6840 -> 6839;
6841 -> 6840;
6842 -> 6840;
6843 -> 6842;
6844 -> 6839;
6845 -> 6844;
6846 -> 6819;
6847 -> 6846;
6848 -> 6847;
6849 -> 6847;
6850 -> 6849;
6851 -> 6846;
6852 -> 6851;
6853 -> 6322;
6853 -> 6819;
6854 -> 6819;
6855 -> 6322;
6855 -> 0;
6855 -> 6819;
6856 -> 6819;
6857 -> 6322;
6857 -> 6819;
6858 -> 6322;
6858 -> 6819;
6859 -> 6819;
6860 -> 6859;
6861 -> 6860;
6862 -> 6861;
6863 -> 6322;
6863 -> 6861;
6864 -> 6859;
6865 -> 6322;
6865 -> 6819;
6866 -> 6819;
6867 -> 6802;
6867 -> 6801;
6868 -> 6867;
6869 -> 6867;
6870 -> 6801;
6871 -> 6804;
6871 -> 6870;
6871 -> 6801;
6872 -> 6802;
6872 -> 6801;
6873 -> 6803;
6873 -> 6801;
6874 -> 6805;
6874 -> 6801;
6875 -> 6801;
6876 -> 6872;
6876 -> 6875;
6877 -> 6873;
6877 -> 6875;
6878 -> 6874;
6878 -> 6875;
6879 -> 6875;
6880 -> 6876;
6880 -> 6879;
6880 -> 6875;
6881 -> 6322;
6882 -> 6322;
6883 -> 6322;
6883 -> 0;
6884 -> 6322;
6885 -> 6322;
6885 -> 0;
6886 -> 6322;
6886 -> 0;
6887 -> 6322;
6887 -> 0;
6888 -> 6322;
6888 -> 0;
6889 -> 6322;
6889 -> 0;
6890 -> 6322;
6890 -> 0;
6891 -> 6322;
6892 -> 6322;
6893 -> 6322;
6894 -> 6322;
6894 -> 0;
6895 -> 6322;
6896 -> 6322;
6897 -> 6895;
6897 -> 6896;
6898 -> 6897;
6898 -> 6896;
6899 -> 6898;
6900 -> 6322;
6901 -> 6900;
6901 -> 6322;
6902 -> 6322;
6903 -> 6902;
6903 -> 6322;
6904 -> 6893;
6904 -> 6903;
6905 -> 6322;
6906 -> 6904;
6906 -> 6905;
6906 -> 6322;
6907 -> 6906;
6907 -> 6900;
6907 -> 6322;
6908 -> 6900;
6908 -> 6322;
6909 -> 6899;
6909 -> 6908;
6910 -> 6899;
6910 -> 6322;
6911 -> 6322;
6911 -> 0;
6912 -> 6322;
6913 -> 6322;
6914 -> 6322;
6915 -> 6913;
6915 -> 6914;
6916 -> 6915;
6916 -> 6914;
6917 -> 6916;
6918 -> 6322;
6919 -> 6917;
6919 -> 6918;
6920 -> 6322;
6921 -> 6322;
6922 -> 6920;
6922 -> 6921;
6923 -> 6322;
6923 -> 6921;
6924 -> 6922;
6924 -> 6322;
6924 -> 0;
6924 -> 6921;
6925 -> 6924;
6926 -> 6322;
6927 -> 6913;
6927 -> 6926;
6928 -> 6927;
6928 -> 6926;
6929 -> 6928;
6930 -> 6322;
6931 -> 6322;
6932 -> 6322;
6933 -> 6322;
6933 -> 6875;
6934 -> 6790;
6935 -> 6322;
6935 -> 6934;
6935 -> 6790;
6936 -> 6774;
6936 -> 0;
6936 -> 6773;
6937 -> 6936;
6938 -> 6937;
6938 -> 6936;
6939 -> 6777;
6939 -> 6936;
6940 -> 6936;
6941 -> 6938;
6941 -> 6940;
6942 -> 6939;
6942 -> 6940;
6943 -> 6940;
6944 -> 6941;
6944 -> 6940;
6945 -> 6942;
6945 -> 6940;
6946 -> 6940;
6947 -> 6943;
6947 -> 6946;
6948 -> 6943;
6948 -> 6946;
6949 -> 6943;
6949 -> 6946;
6950 -> 6943;
6950 -> 6946;
6951 -> 6944;
6951 -> 6946;
6952 -> 6943;
6952 -> 6946;
6953 -> 6945;
6953 -> 6946;
6954 -> 6946;
6955 -> 6322;
6955 -> 6954;
6955 -> 6946;
6956 -> 6946;
6957 -> 6951;
6957 -> 6956;
6957 -> 6946;
6958 -> 6946;
6959 -> 6322;
6959 -> 6958;
6960 -> 6959;
6960 -> 6946;
6961 -> 6946;
6962 -> 6946;
6963 -> 6952;
6963 -> 6946;
6964 -> 6947;
6964 -> 6963;
6965 -> 6950;
6965 -> 6963;
6966 -> 6951;
6966 -> 6963;
6967 -> 6953;
6967 -> 6963;
6968 -> 6963;
6969 -> 6964;
6969 -> 6968;
6970 -> 6965;
6970 -> 6968;
6971 -> 6966;
6971 -> 6968;
6972 -> 6967;
6972 -> 6968;
6973 -> 6972;
6973 -> 6968;
6974 -> 6968;
6975 -> 6973;
6975 -> 6974;
6976 -> 6974;
6977 -> 6322;
6978 -> 6322;
6978 -> 6968;
6979 -> 6968;
6980 -> 6947;
6980 -> 6946;
6981 -> 6948;
6981 -> 6946;
6982 -> 6949;
6982 -> 6946;
6983 -> 6950;
6983 -> 6946;
6984 -> 6951;
6984 -> 6946;
6985 -> 6952;
6985 -> 6946;
6986 -> 6953;
6986 -> 6946;
6987 -> 6946;
6988 -> 6946;
6989 -> 6980;
6989 -> 6988;
6990 -> 6981;
6990 -> 6988;
6991 -> 6982;
6991 -> 6988;
6992 -> 6983;
6992 -> 6988;
6993 -> 6984;
6993 -> 6988;
6994 -> 6985;
6994 -> 6988;
6995 -> 6986;
6995 -> 6988;
6996 -> 6987;
6996 -> 6988;
6997 -> 6988;
6998 -> 6997;
6998 -> 6988;
6999 -> 6997;
6999 -> 6988;
7000 -> 6997;
7000 -> 6988;
7001 -> 6997;
7001 -> 6988;
7002 -> 6997;
7002 -> 6988;
7003 -> 6997;
7003 -> 6988;
7004 -> 6997;
7004 -> 6988;
7005 -> 6997;
7005 -> 6988;
7006 -> 6997;
7006 -> 6988;
7007 -> 6997;
7007 -> 6988;
7008 -> 6997;
7008 -> 6988;
7009 -> 6988;
7010 -> 6322;
7010 -> 7009;
7010 -> 6988;
7011 -> 6988;
7012 -> 6993;
7012 -> 7011;
7012 -> 6988;
7013 -> 6989;
7013 -> 6997;
7013 -> 6988;
7014 -> 6990;
7014 -> 6997;
7014 -> 6988;
7015 -> 6995;
7015 -> 6997;
7015 -> 6988;
7016 -> 6993;
7016 -> 6997;
7016 -> 6988;
7017 -> 6994;
7017 -> 6997;
7017 -> 6988;
7018 -> 6992;
7018 -> 6997;
7018 -> 6988;
7019 -> 6992;
7019 -> 6988;
7020 -> 6988;
7021 -> 7019;
7021 -> 7020;
7022 -> 6997;
7022 -> 7020;
7023 -> 7021;
7023 -> 7020;
7024 -> 6988;
7025 -> 6990;
7025 -> 6991;
7025 -> 6988;
7026 -> 6991;
7026 -> 6997;
7026 -> 6988;
7027 -> 6946;
7028 -> 6946;
7029 -> 7028;
7030 -> 7029;
7031 -> 7030;
7032 -> 6322;
7032 -> 7030;
7033 -> 7028;
7034 -> 6946;
7035 -> 6987;
7035 -> 7034;
7036 -> 6322;
7037 -> 6322;
7038 -> 6322;
7039 -> 7037;
7039 -> 7038;
7040 -> 7037;
7040 -> 7038;
7041 -> 7038;
7042 -> 7039;
7042 -> 7041;
7042 -> 7038;
7043 -> 6322;
7044 -> 6322;
7045 -> 6946;
7046 -> 6946;
7047 -> 6987;
7047 -> 7046;
7048 -> 7046;
7049 -> 6322;
7049 -> 7048;
7049 -> 7046;
7050 -> 7046;
7051 -> 7050;
7051 -> 7046;
7052 -> 6946;
7053 -> 6946;
7054 -> 6947;
7054 -> 7053;
7054 -> 6946;
7055 -> 6946;
7056 -> 6947;
7056 -> 7055;
7056 -> 6946;
7057 -> 6946;
7058 -> 6946;
7059 -> 6952;
7059 -> 7058;
7059 -> 6946;
7060 -> 6951;
7060 -> 7059;
7061 -> 6953;
7061 -> 7059;
7062 -> 7059;
7063 -> 7060;
7063 -> 7062;
7064 -> 7061;
7064 -> 7062;
7065 -> 7062;
7066 -> 7065;
7067 -> 7066;
7068 -> 6322;
7068 -> 7066;
7069 -> 7064;
7069 -> 7062;
7070 -> 7062;
7071 -> 7059;
7072 -> 7059;
7073 -> 6947;
7073 -> 7072;
7073 -> 7059;
7074 -> 6940;
7075 -> 6941;
7075 -> 6940;
7076 -> 6942;
7076 -> 6940;
7077 -> 6940;
7078 -> 7074;
7078 -> 7077;
7079 -> 7074;
7079 -> 7077;
7080 -> 7075;
7080 -> 7077;
7081 -> 7076;
7081 -> 7077;
7082 -> 7074;
7082 -> 7077;
7083 -> 7074;
7083 -> 7077;
7084 -> 7077;
7085 -> 7077;
7086 -> 7079;
7086 -> 7085;
7086 -> 7077;
7087 -> 7077;
7088 -> 7087;
7089 -> 6322;
7089 -> 7087;
7090 -> 7084;
7090 -> 7077;
7091 -> 7082;
7091 -> 7077;
7092 -> 7083;
7092 -> 7077;
7093 -> 7077;
7094 -> 7080;
7094 -> 7077;
7095 -> 7081;
7095 -> 7077;
7096 -> 7077;
7097 -> 7090;
7097 -> 7096;
7098 -> 7091;
7098 -> 7096;
7099 -> 7092;
7099 -> 7096;
7100 -> 7093;
7100 -> 7096;
7101 -> 7093;
7101 -> 7096;
7102 -> 7094;
7102 -> 7096;
7103 -> 7095;
7103 -> 7096;
7104 -> 7093;
7104 -> 7096;
7105 -> 7096;
7106 -> 7105;
7106 -> 7096;
7107 -> 7105;
7107 -> 7096;
7108 -> 7105;
7108 -> 7096;
7109 -> 7105;
7109 -> 7096;
7110 -> 7105;
7110 -> 7096;
7111 -> 7105;
7111 -> 7096;
7112 -> 7105;
7112 -> 7096;
7113 -> 7105;
7113 -> 7096;
7114 -> 7105;
7114 -> 7096;
7115 -> 7105;
7115 -> 7096;
7116 -> 7105;
7116 -> 7096;
7117 -> 7105;
7117 -> 7096;
7118 -> 7097;
7118 -> 7105;
7118 -> 7096;
7119 -> 7098;
7119 -> 7105;
7119 -> 7096;
7120 -> 7099;
7120 -> 7105;
7120 -> 7096;
7121 -> 7100;
7121 -> 7105;
7121 -> 7096;
7122 -> 7101;
7122 -> 7105;
7122 -> 7096;
7123 -> 7102;
7123 -> 7105;
7123 -> 7096;
7124 -> 7103;
7124 -> 7105;
7124 -> 7096;
7125 -> 7077;
7126 -> 7125;
7127 -> 6322;
7127 -> 7125;
7128 -> 7077;
7129 -> 6322;
7130 -> 6322;
7131 -> 6322;
7132 -> 7130;
7132 -> 7131;
7133 -> 6322;
7133 -> 7131;
7134 -> 7133;
7134 -> 6322;
7134 -> 7131;
7135 -> 7131;
7136 -> 7134;
7137 -> 6322;
7138 -> 6322;
7139 -> 7137;
7139 -> 7138;
7140 -> 6322;
7140 -> 7138;
7141 -> 7140;
7141 -> 6322;
7141 -> 7138;
7142 -> 7138;
7143 -> 7141;
7144 -> 6322;
7145 -> 6322;
7146 -> 6322;
7147 -> 7145;
7147 -> 7146;
7148 -> 6322;
7148 -> 7146;
7149 -> 7148;
7149 -> 6322;
7149 -> 7146;
7150 -> 7146;
7151 -> 7149;
7152 -> 6322;
7153 -> 6322;
7154 -> 6322;
7154 -> 7153;
7155 -> 6322;
7156 -> 7153;
7156 -> 7155;
7157 -> 7153;
7157 -> 7155;
7158 -> 6322;
7158 -> 7155;
7159 -> 7156;
7159 -> 7155;
7160 -> 7157;
7160 -> 7155;
7161 -> 7159;
7161 -> 7160;
7161 -> 7155;
7162 -> 7155;
7163 -> 7161;
7163 -> 7162;
7164 -> 7158;
7164 -> 7162;
7165 -> 7164;
7165 -> 6322;
7165 -> 7162;
7166 -> 7162;
7167 -> 7165;
7168 -> 7155;
7169 -> 6322;
7170 -> 6322;
7171 -> 6322;
7172 -> 6322;
7173 -> 7171;
7173 -> 7172;
7174 -> 6322;
7174 -> 7172;
7175 -> 7174;
7175 -> 6322;
7175 -> 7172;
7176 -> 7172;
7177 -> 7175;
7178 -> 6322;
7179 -> 6322;
7180 -> 7178;
7180 -> 7179;
7181 -> 6322;
7181 -> 7179;
7182 -> 7181;
7182 -> 6322;
7182 -> 7179;
7183 -> 7179;
7184 -> 7182;
7185 -> 6322;
7186 -> 6322;
7186 -> 7128;
7187 -> 6322;
7188 -> 6322;
7189 -> 6322;
7190 -> 6322;
7191 -> 7190;
7191 -> 6322;
7192 -> 6322;
7193 -> 7190;
7193 -> 6322;
7194 -> 0;
7194 -> 6322;
7195 -> 6322;
7196 -> 6322;
7197 -> 6322;
7198 -> 7197;
7198 -> 7194;
7198 -> 6322;
7199 -> 7198;
7199 -> 6322;
7200 -> 6322;
7201 -> 6322;
7202 -> 7196;
7202 -> 7201;
7202 -> 6322;
7203 -> 0;
7203 -> 7202;
7204 -> 6322;
7205 -> 7203;
7205 -> 0;
7205 -> 6322;
7206 -> 7199;
7206 -> 0;
7206 -> 7205;
7207 -> 7205;
7208 -> 6322;
7209 -> 7190;
7209 -> 6322;
7210 -> 7190;
7210 -> 6322;
7211 -> 7210;
7211 -> 7194;
7211 -> 7190;
7212 -> 7211;
7212 -> 7190;
7213 -> 7190;
7214 -> 7212;
7214 -> 0;
7214 -> 7205;
7215 -> 7190;
7216 -> 7190;
7217 -> 7190;
7218 -> 7190;
7219 -> 7190;
7220 -> 0;
7220 -> 7190;
7221 -> 7190;
7222 -> 7190;
7223 -> 7190;
7224 -> 7223;
7224 -> 7220;
7224 -> 7190;
7225 -> 7224;
7225 -> 7190;
7226 -> 7190;
7227 -> 7222;
7227 -> 7226;
7227 -> 7190;
7228 -> 0;
7228 -> 7227;
7229 -> 7190;
7230 -> 7228;
7230 -> 0;
7230 -> 7190;
7231 -> 7225;
7231 -> 0;
7231 -> 7230;
7232 -> 7230;
7233 -> 7190;
7234 -> 7190;
7235 -> 7190;
7236 -> 7190;
7237 -> 7190;
7238 -> 7236;
7238 -> 7237;
7239 -> 6322;
7239 -> 7237;
7240 -> 7239;
7240 -> 7190;
7240 -> 7237;
7241 -> 7237;
7242 -> 7240;
7243 -> 7190;
7244 -> 7190;
7245 -> 7190;
7246 -> 7244;
7246 -> 7245;
7247 -> 6322;
7247 -> 7245;
7248 -> 7247;
7248 -> 7190;
7248 -> 7245;
7249 -> 7245;
7250 -> 7248;
7251 -> 7077;
7252 -> 7093;
7252 -> 7190;
7252 -> 7251;
7252 -> 7077;
7253 -> 7084;
7253 -> 7077;
7254 -> 7077;
7255 -> 7082;
7255 -> 7254;
7255 -> 7077;
7256 -> 7255;
7257 -> 7256;
7258 -> 7257;
7259 -> 7190;
7260 -> 7190;
7261 -> 7190;
7262 -> 6940;
7263 -> 6941;
7263 -> 6940;
7264 -> 6942;
7264 -> 6940;
7265 -> 6940;
7266 -> 7262;
7266 -> 7265;
7267 -> 7263;
7267 -> 7265;
7268 -> 7264;
7268 -> 7265;
7269 -> 6322;
7269 -> 7265;
7270 -> 7265;
7271 -> 7269;
7271 -> 7190;
7271 -> 7270;
7271 -> 7265;
7272 -> 7266;
7272 -> 7265;
7273 -> 7265;
7274 -> 7272;
7274 -> 7273;
7275 -> 7269;
7275 -> 7273;
7276 -> 7273;
7277 -> 7275;
7277 -> 7190;
7277 -> 7276;
7277 -> 7273;
7278 -> 7265;
7279 -> 6936;
7280 -> 6937;
7280 -> 6936;
7281 -> 6776;
7281 -> 6773;
7282 -> 6778;
7282 -> 6773;
7283 -> 6777;
7283 -> 6773;
7284 -> 6773;
7285 -> 6764;
7286 -> 6757;
7287 -> 7286;
7288 -> 7287;
7289 -> 7287;
7290 -> 7288;
7290 -> 7289;
7291 -> 7289;
7292 -> 6322;
7292 -> 7291;
7292 -> 7289;
7293 -> 6322;
7293 -> 7289;
7294 -> 7293;
7294 -> 7190;
7294 -> 7289;
7295 -> 7289;
7296 -> 7190;
7296 -> 7295;
7296 -> 7289;
7297 -> 7289;
7298 -> 7289;
7299 -> 6322;
7299 -> 7298;
7300 -> 7298;
7301 -> 7298;
7302 -> 7190;
7302 -> 7298;
7303 -> 7302;
7303 -> 7298;
7304 -> 7301;
7304 -> 7303;
7305 -> 7304;
7305 -> 7300;
7305 -> 7298;
7306 -> 7304;
7306 -> 7300;
7306 -> 7298;
7307 -> 7306;
7307 -> 7298;
7308 -> 7299;
7308 -> 7298;
7309 -> 7308;
7309 -> 7190;
7309 -> 7298;
7310 -> 7299;
7310 -> 7298;
7311 -> 7310;
7311 -> 7190;
7311 -> 7298;
7312 -> 7298;
7313 -> 7299;
7313 -> 7312;
7314 -> 1850;
7314 -> 7312;
7315 -> 7312;
7316 -> 7313;
7316 -> 7312;
7317 -> 7316;
7317 -> 7190;
7317 -> 7312;
7318 -> 7312;
7319 -> 7318;
7319 -> 7298;
7320 -> 7319;
7321 -> 7320;
7322 -> 1850;
7322 -> 7320;
7323 -> 7298;
7324 -> 7323;
7324 -> 7298;
7325 -> 7298;
7326 -> 7298;
7327 -> 7323;
7327 -> 7326;
7327 -> 7324;
7327 -> 7298;
7328 -> 7298;
7329 -> 7299;
7329 -> 7298;
7330 -> 7329;
7330 -> 7190;
7330 -> 7298;
7331 -> 7323;
7331 -> 7298;
7332 -> 7328;
7332 -> 7298;
7333 -> 7298;
7334 -> 7331;
7334 -> 7333;
7335 -> 7332;
7335 -> 7333;
7336 -> 7335;
7336 -> 7328;
7336 -> 7333;
7337 -> 7333;
7338 -> 7337;
7338 -> 7336;
7338 -> 7333;
7339 -> 7298;
7340 -> 7298;
7341 -> 7323;
7341 -> 7340;
7341 -> 7327;
7341 -> 7298;
7342 -> 7298;
7343 -> 7298;
7344 -> 7298;
7345 -> 7343;
7345 -> 7344;
7345 -> 7298;
7346 -> 7298;
7347 -> 7323;
7347 -> 7346;
7347 -> 7341;
7347 -> 7298;
7348 -> 7328;
7348 -> 7298;
7349 -> 7342;
7349 -> 7298;
7350 -> 0;
7350 -> 7298;
7351 -> 7298;
7352 -> 7298;
7353 -> 7348;
7353 -> 7352;
7354 -> 7349;
7354 -> 7352;
7355 -> 7350;
7355 -> 7352;
7356 -> 7351;
7356 -> 7352;
7357 -> 7351;
7357 -> 7352;
7358 -> 7352;
7359 -> 7356;
7359 -> 7358;
7359 -> 7352;
7360 -> 7359;
7360 -> 7352;
7361 -> 7352;
7362 -> 7361;
7362 -> 7357;
7362 -> 7352;
7363 -> 7353;
7363 -> 7352;
7364 -> 7354;
7364 -> 7352;
7365 -> 7355;
7365 -> 7352;
7366 -> 7363;
7366 -> 7352;
7367 -> 7364;
7367 -> 7352;
7368 -> 7362;
7368 -> 7352;
7369 -> 7352;
7370 -> 7366;
7370 -> 7369;
7371 -> 7367;
7371 -> 7369;
7372 -> 7368;
7372 -> 7369;
7373 -> 5686;
7373 -> 7369;
7374 -> 7370;
7374 -> 7369;
7375 -> 7370;
7375 -> 7363;
7375 -> 7369;
7376 -> 7371;
7376 -> 7369;
7377 -> 7371;
7377 -> 7364;
7377 -> 7369;
7378 -> 7369;
7379 -> 7374;
7379 -> 7378;
7380 -> 7375;
7380 -> 7378;
7381 -> 7376;
7381 -> 7378;
7382 -> 7377;
7382 -> 7378;
7383 -> 7373;
7383 -> 7378;
7384 -> 7379;
7384 -> 7378;
7385 -> 7380;
7385 -> 7378;
7386 -> 7381;
7386 -> 7378;
7387 -> 7382;
7387 -> 7378;
7388 -> 7378;
7389 -> 7384;
7389 -> 7388;
7390 -> 7385;
7390 -> 7388;
7391 -> 7386;
7391 -> 7388;
7392 -> 7387;
7392 -> 7388;
7393 -> 7383;
7393 -> 7388;
7394 -> 7388;
7395 -> 7390;
7395 -> 7394;
7395 -> 7388;
7396 -> 7388;
7397 -> 7392;
7397 -> 7396;
7397 -> 7388;
7398 -> 7395;
7398 -> 7397;
7398 -> 7388;
7399 -> 7388;
7400 -> 7399;
7400 -> 7398;
7400 -> 7388;
7401 -> 7388;
7402 -> 7401;
7402 -> 7390;
7402 -> 7388;
7403 -> 7388;
7404 -> 7403;
7404 -> 7392;
7404 -> 7388;
7405 -> 7388;
7406 -> 7405;
7406 -> 7390;
7406 -> 7388;
7407 -> 7398;
7407 -> 7388;
7408 -> 7380;
7408 -> 7378;
7409 -> 7382;
7409 -> 7378;
7410 -> 7378;
7411 -> 7408;
7411 -> 7410;
7411 -> 7378;
7412 -> 7378;
7413 -> 7408;
7413 -> 7412;
7413 -> 7378;
7414 -> 7378;
7415 -> 7409;
7415 -> 7414;
7415 -> 7378;
7416 -> 7378;
7417 -> 7416;
7417 -> 7369;
7418 -> 7369;
7419 -> 7418;
7419 -> 7352;
7420 -> 7365;
7420 -> 7419;
7420 -> 7352;
7421 -> 7323;
7421 -> 7420;
7421 -> 7347;
7421 -> 7298;
7422 -> 7342;
7422 -> 7298;
7423 -> 7328;
7423 -> 7298;
7424 -> 7323;
7424 -> 7421;
7424 -> 7298;
7425 -> 7424;
7425 -> 7289;
7426 -> 7286;
7427 -> 6757;
7428 -> 6322;
7428 -> 6757;
7429 -> 7190;
7429 -> 6757;
7430 -> 6757;
7431 -> 7428;
7431 -> 7430;
7432 -> 7429;
7432 -> 7430;
7433 -> 7432;
7433 -> 7430;
7434 -> 6757;
7435 -> 12;
7436 -> 16;
7436 -> 7435;
7436 -> 12;
7437 -> 13;
7437 -> 7436;
7438 -> 14;
7438 -> 7436;
7439 -> 15;
7439 -> 7436;
7440 -> 7436;
7441 -> 0;
7441 -> 7440;
7441 -> 7190;
7441 -> 7436;
7442 -> 7436;
7443 -> 7437;
7443 -> 7442;
7444 -> 7438;
7444 -> 7442;
7445 -> 7439;
7445 -> 7442;
7446 -> 7441;
7446 -> 7442;
7447 -> 7442;
7448 -> 7447;
7449 -> 7448;
7449 -> 7442;
7450 -> 7443;
7450 -> 7442;
7451 -> 7442;
7452 -> 0;
7452 -> 7451;
7452 -> 7441;
7452 -> 7442;
7453 -> 7449;
7453 -> 7442;
7454 -> 7442;
7455 -> 7451;
7455 -> 7454;
7456 -> 7455;
7456 -> 7454;
7457 -> 7454;
7458 -> 7456;
7458 -> 7457;
7459 -> 7457;
7460 -> 7458;
7460 -> 7459;
7460 -> 7457;
7461 -> 7457;
7461 -> 7442;
7462 -> 7450;
7462 -> 7454;
7463 -> 7451;
7463 -> 7454;
7464 -> 7451;
7464 -> 7454;
7465 -> 7461;
7465 -> 7454;
7466 -> 7453;
7466 -> 7454;
7467 -> 7451;
7467 -> 7454;
7468 -> 7451;
7468 -> 7454;
7469 -> 7462;
7469 -> 7454;
7470 -> 7465;
7470 -> 7454;
7471 -> 7463;
7471 -> 7454;
7472 -> 7454;
7473 -> 7470;
7473 -> 7472;
7474 -> 7471;
7474 -> 7472;
7475 -> 7473;
7475 -> 7472;
7476 -> 7472;
7477 -> 7475;
7477 -> 7476;
7478 -> 7477;
7478 -> 7476;
7479 -> 7478;
7480 -> 0;
7480 -> 7479;
7481 -> 7480;
7482 -> 7481;
7483 -> 7472;
7484 -> 7474;
7484 -> 7483;
7484 -> 7472;
7485 -> 7464;
7485 -> 7454;
7486 -> 7466;
7486 -> 7454;
7487 -> 7467;
7487 -> 7454;
7488 -> 7468;
7488 -> 7454;
7489 -> 7454;
7490 -> 7469;
7490 -> 7489;
7491 -> 7485;
7491 -> 7489;
7492 -> 7486;
7492 -> 7489;
7493 -> 7487;
7493 -> 7489;
7494 -> 7488;
7494 -> 7489;
7495 -> 7490;
7495 -> 7489;
7496 -> 7491;
7496 -> 7489;
7497 -> 7492;
7497 -> 7489;
7498 -> 7493;
7498 -> 7489;
7499 -> 7494;
7499 -> 7489;
7500 -> 7489;
7501 -> 7500;
7501 -> 7489;
7502 -> 7489;
7503 -> 7495;
7503 -> 7502;
7504 -> 7496;
7504 -> 7502;
7505 -> 7497;
7505 -> 7502;
7506 -> 7498;
7506 -> 7502;
7507 -> 7499;
7507 -> 7502;
7508 -> 7501;
7508 -> 7502;
7509 -> 7504;
7509 -> 7502;
7510 -> 7506;
7510 -> 7502;
7511 -> 7502;
7512 -> 7509;
7512 -> 7511;
7513 -> 7510;
7513 -> 7511;
7514 -> 7503;
7514 -> 7511;
7515 -> 7514;
7515 -> 7450;
7515 -> 7511;
7516 -> 7515;
7517 -> 7513;
7517 -> 7515;
7518 -> 7512;
7518 -> 7515;
7519 -> 7515;
7520 -> 7516;
7520 -> 7519;
7521 -> 7517;
7521 -> 7519;
7522 -> 7518;
7522 -> 7519;
7523 -> 7516;
7523 -> 7519;
7524 -> 7519;
7525 -> 7522;
7525 -> 7524;
7525 -> 7519;
7526 -> 0;
7526 -> 7525;
7527 -> 7520;
7527 -> 7519;
7528 -> 0;
7528 -> 7519;
7529 -> 7528;
7529 -> 7523;
7529 -> 7519;
7530 -> 7519;
7531 -> 7526;
7531 -> 7519;
7532 -> 7521;
7532 -> 7519;
7533 -> 7519;
7534 -> 7519;
7535 -> 7534;
7536 -> 7534;
7537 -> 7452;
7537 -> 7536;
7537 -> 7534;
7538 -> 7535;
7538 -> 7534;
7539 -> 7534;
7540 -> 7537;
7540 -> 7452;
7540 -> 7536;
7540 -> 7538;
7540 -> 7539;
7540 -> 7535;
7540 -> 7534;
7541 -> 7534;
7542 -> 7541;
7542 -> 7535;
7542 -> 7534;
7543 -> 7535;
7543 -> 7534;
7544 -> 7534;
7545 -> 7543;
7545 -> 7544;
7545 -> 7535;
7545 -> 7542;
7545 -> 7534;
7546 -> 7516;
7546 -> 7502;
7547 -> 7502;
7548 -> 7452;
7548 -> 7547;
7548 -> 7502;
7549 -> 0;
7549 -> 7502;
7550 -> 7508;
7550 -> 7502;
7551 -> 7452;
7551 -> 7502;
7552 -> 7502;
7553 -> 7551;
7553 -> 7552;
7554 -> 0;
7554 -> 7552;
7555 -> 7554;
7556 -> 7502;
7557 -> 7502;
7558 -> 7557;
7559 -> 7557;
7560 -> 7558;
7560 -> 7559;
7561 -> 7558;
7561 -> 7559;
7562 -> 7558;
7562 -> 7559;
7563 -> 7558;
7563 -> 7559;
7564 -> 7559;
7565 -> 7452;
7565 -> 7564;
7565 -> 7559;
7566 -> 7563;
7566 -> 7559;
7567 -> 7560;
7567 -> 7559;
7568 -> 7561;
7568 -> 7559;
7569 -> 7562;
7569 -> 7559;
7570 -> 7563;
7570 -> 7559;
7571 -> 7559;
7572 -> 0;
7572 -> 7559;
7573 -> 7559;
7574 -> 7572;
7574 -> 7573;
7575 -> 7572;
7575 -> 7573;
7576 -> 7570;
7576 -> 7573;
7577 -> 7571;
7577 -> 7573;
7578 -> 7571;
7578 -> 7573;
7579 -> 7574;
7579 -> 7573;
7580 -> 7575;
7580 -> 7573;
7581 -> 7576;
7581 -> 7573;
7582 -> 7573;
7583 -> 7582;
7583 -> 7573;
7584 -> 7577;
7584 -> 7582;
7584 -> 7573;
7585 -> 7559;
7586 -> 7567;
7586 -> 7585;
7587 -> 7568;
7587 -> 7585;
7588 -> 7569;
7588 -> 7585;
7589 -> 7570;
7589 -> 7585;
7590 -> 7571;
7590 -> 7585;
7591 -> 7571;
7591 -> 7585;
7592 -> 7571;
7592 -> 7585;
7593 -> 7571;
7593 -> 7585;
7594 -> 7571;
7594 -> 7585;
7595 -> 7571;
7595 -> 7585;
7596 -> 7586;
7596 -> 7585;
7597 -> 7587;
7597 -> 7585;
7598 -> 7588;
7598 -> 7585;
7599 -> 7589;
7599 -> 7585;
7600 -> 7590;
7600 -> 7585;
7601 -> 7591;
7601 -> 7585;
7602 -> 7592;
7602 -> 7585;
7603 -> 7593;
7603 -> 7585;
7604 -> 7594;
7604 -> 7585;
7605 -> 7585;
7606 -> 7596;
7606 -> 7605;
7607 -> 7597;
7607 -> 7605;
7608 -> 7598;
7608 -> 7605;
7609 -> 7599;
7609 -> 7605;
7610 -> 7600;
7610 -> 7605;
7611 -> 7601;
7611 -> 7605;
7612 -> 7602;
7612 -> 7605;
7613 -> 7603;
7613 -> 7605;
7614 -> 7604;
7614 -> 7605;
7615 -> 7595;
7615 -> 7605;
7616 -> 7609;
7616 -> 7605;
7617 -> 7613;
7617 -> 7605;
7618 -> 7614;
7618 -> 7605;
7619 -> 7605;
7620 -> 7619;
7620 -> 7605;
7621 -> 7619;
7621 -> 7605;
7622 -> 7619;
7622 -> 7605;
7623 -> 7619;
7623 -> 7605;
7624 -> 7619;
7624 -> 7605;
7625 -> 7619;
7625 -> 7605;
7626 -> 7619;
7626 -> 7605;
7627 -> 7619;
7627 -> 7605;
7628 -> 7619;
7628 -> 7605;
7629 -> 7619;
7629 -> 7605;
7630 -> 7619;
7630 -> 7605;
7631 -> 7619;
7631 -> 7605;
7632 -> 7619;
7632 -> 7605;
7633 -> 7619;
7633 -> 7605;
7634 -> 7619;
7634 -> 7605;
7635 -> 7619;
7635 -> 7605;
7636 -> 7619;
7636 -> 7605;
7637 -> 7619;
7637 -> 7605;
7638 -> 7619;
7638 -> 7605;
7639 -> 7619;
7639 -> 7605;
7640 -> 7619;
7640 -> 7605;
7641 -> 7619;
7641 -> 7605;
7642 -> 7619;
7642 -> 7605;
7643 -> 7619;
7643 -> 7605;
7644 -> 7619;
7644 -> 7605;
7645 -> 7619;
7645 -> 7605;
7646 -> 7605;
7647 -> 7646;
7647 -> 7619;
7647 -> 7605;
7648 -> 7619;
7648 -> 7605;
7649 -> 7619;
7649 -> 7605;
7650 -> 7605;
7651 -> 7605;
7652 -> 7649;
7652 -> 7651;
7653 -> 7650;
7653 -> 7651;
7654 -> 7653;
7654 -> 7651;
7655 -> 7653;
7655 -> 7651;
7656 -> 7653;
7656 -> 7651;
7657 -> 7652;
7657 -> 7653;
7657 -> 7651;
7658 -> 7650;
7658 -> 7619;
7658 -> 7605;
7659 -> 7619;
7659 -> 7605;
7660 -> 7605;
7661 -> 7660;
7662 -> 0;
7662 -> 7660;
7663 -> 7662;
7663 -> 7661;
7663 -> 7660;
7664 -> 7663;
7664 -> 7605;
7665 -> 7664;
7665 -> 7619;
7665 -> 7605;
7666 -> 7609;
7666 -> 7605;
7667 -> 7666;
7668 -> 7606;
7668 -> 7667;
7668 -> 7666;
7669 -> 7607;
7669 -> 7667;
7669 -> 7666;
7670 -> 7668;
7670 -> 7669;
7670 -> 7666;
7671 -> 7608;
7671 -> 7667;
7671 -> 7666;
7672 -> 7670;
7672 -> 7671;
7672 -> 7666;
7673 -> 7611;
7673 -> 7605;
7674 -> 7673;
7675 -> 7619;
7675 -> 7674;
7676 -> 7610;
7676 -> 7673;
7677 -> 7612;
7677 -> 7619;
7677 -> 7605;
7678 -> 7619;
7678 -> 7452;
7678 -> 7605;
7679 -> 7605;
7680 -> 7619;
7680 -> 7452;
7680 -> 7679;
7680 -> 7605;
7681 -> 7559;
7682 -> 7452;
7683 -> 7452;
7684 -> 7452;
7685 -> 7452;
7686 -> 7452;
7687 -> 7683;
7687 -> 7452;
7688 -> 7452;
7689 -> 7452;
7690 -> 7452;
7691 -> 7452;
7692 -> 7452;
7693 -> 7452;
7694 -> 7452;
7695 -> 7452;
7696 -> 7693;
7696 -> 7452;
7697 -> 7694;
7697 -> 7452;
7698 -> 7695;
7698 -> 7452;
7699 -> 7696;
7699 -> 7452;
7700 -> 7697;
7700 -> 7452;
7701 -> 7698;
7701 -> 7452;
7702 -> 7452;
7703 -> 7452;
7704 -> 7703;
7705 -> 7699;
7705 -> 7704;
7705 -> 7703;
7706 -> 7700;
7706 -> 7704;
7706 -> 7703;
7707 -> 7705;
7707 -> 7706;
7707 -> 7703;
7708 -> 7701;
7708 -> 7704;
7708 -> 7703;
7709 -> 7707;
7709 -> 7708;
7709 -> 7703;
7710 -> 7452;
7711 -> 7452;
7712 -> 7452;
7713 -> 7452;
7713 -> 7559;
7714 -> 7502;
7715 -> 7714;
7716 -> 7715;
7717 -> 7716;
7718 -> 7452;
7719 -> 7452;
7720 -> 7452;
7721 -> 7452;
7722 -> 7452;
7723 -> 7722;
7723 -> 0;
7723 -> 7452;
7724 -> 7452;
7725 -> 7452;
7726 -> 7452;
7727 -> 7452;
7728 -> 7452;
7729 -> 7452;
7729 -> 7714;
7730 -> 7714;
7731 -> 0;
7731 -> 7714;
7732 -> 7507;
7732 -> 7452;
7732 -> 7502;
7733 -> 7442;
7734 -> 7442;
7735 -> 7733;
7735 -> 7734;
7736 -> 7734;
7737 -> 7734;
7738 -> 7736;
7738 -> 7737;
7739 -> 0;
7739 -> 7737;
7740 -> 7737;
7741 -> 7738;
7741 -> 7737;
7742 -> 7737;
7743 -> 7739;
7743 -> 7742;
7744 -> 7740;
7744 -> 7742;
7745 -> 7741;
7745 -> 7742;
7746 -> 7742;
7747 -> 7743;
7747 -> 7742;
7748 -> 7744;
7748 -> 7742;
7749 -> 7746;
7749 -> 7742;
7750 -> 7745;
7750 -> 7742;
7751 -> 7742;
7752 -> 7747;
7752 -> 7751;
7753 -> 7748;
7753 -> 7751;
7754 -> 7749;
7754 -> 7751;
7755 -> 7750;
7755 -> 7751;
7756 -> 7751;
7757 -> 7752;
7757 -> 0;
7757 -> 7751;
7758 -> 7757;
7758 -> 7753;
7758 -> 7751;
7759 -> 7758;
7760 -> 7759;
7761 -> 7760;
7762 -> 7758;
7763 -> 7452;
7764 -> 7452;
7765 -> 7758;
7766 -> 7452;
7767 -> 7752;
7767 -> 0;
7767 -> 7751;
7768 -> 7767;
7768 -> 7753;
7768 -> 7751;
7769 -> 7756;
7769 -> 7768;
7770 -> 7768;
7771 -> 7768;
7772 -> 7768;
7773 -> 7452;
7773 -> 7772;
7774 -> 7773;
7774 -> 7768;
7775 -> 7768;
7776 -> 7452;
7777 -> 7755;
7777 -> 7768;
7778 -> 7768;
7779 -> 7768;
7780 -> 7778;
7780 -> 7779;
7781 -> 7778;
7781 -> 7779;
7782 -> 7778;
7782 -> 7779;
7783 -> 7777;
7783 -> 7779;
7784 -> 7779;
7785 -> 7784;
7786 -> 7785;
7787 -> 7783;
7787 -> 7779;
7788 -> 7779;
7789 -> 7779;
7790 -> 7780;
7790 -> 7789;
7790 -> 7779;
7791 -> 7779;
7792 -> 7791;
7793 -> 7792;
7794 -> 7452;
7794 -> 7792;
7795 -> 7788;
7795 -> 7779;
7796 -> 7783;
7796 -> 7779;
7797 -> 7779;
7798 -> 7797;
7799 -> 7798;
7800 -> 7799;
7801 -> 7797;
7802 -> 7801;
7803 -> 7802;
7804 -> 7797;
7805 -> 7804;
7806 -> 7452;
7806 -> 7804;
7807 -> 7452;
7807 -> 7797;
7808 -> 7797;
7809 -> 7452;
7809 -> 7797;
7810 -> 7452;
7810 -> 7797;
7811 -> 7810;
7811 -> 7452;
7811 -> 7797;
7812 -> 7797;
7813 -> 7797;
7814 -> 7452;
7814 -> 7797;
7815 -> 7814;
7815 -> 7797;
7816 -> 7797;
7817 -> 7797;
7818 -> 7816;
7818 -> 7817;
7819 -> 7818;
7819 -> 7817;
7820 -> 7817;
7821 -> 7820;
7822 -> 7821;
7823 -> 7821;
7824 -> 7823;
7825 -> 7820;
7826 -> 7825;
7827 -> 7817;
7828 -> 7817;
7829 -> 7817;
7830 -> 7818;
7830 -> 7817;
7831 -> 7817;
7832 -> 7830;
7832 -> 7831;
7833 -> 7832;
7833 -> 7831;
7834 -> 7831;
7835 -> 7831;
7836 -> 7835;
7837 -> 7835;
7838 -> 7452;
7838 -> 7837;
7838 -> 7835;
7839 -> 7452;
7840 -> 7797;
7841 -> 7840;
7842 -> 7841;
7843 -> 7452;
7843 -> 7841;
7844 -> 7797;
7845 -> 7828;
7845 -> 7817;
7846 -> 7452;
7846 -> 7797;
7847 -> 7797;
7848 -> 7847;
7849 -> 7848;
7850 -> 7849;
7851 -> 7452;
7851 -> 7849;
7852 -> 7847;
7853 -> 7452;
7853 -> 7797;
7854 -> 7797;
7855 -> 7780;
7855 -> 7779;
7856 -> 7855;
7857 -> 7855;
7858 -> 7779;
7859 -> 7782;
7859 -> 7858;
7859 -> 7779;
7860 -> 7780;
7860 -> 7779;
7861 -> 7781;
7861 -> 7779;
7862 -> 7783;
7862 -> 7779;
7863 -> 7779;
7864 -> 7860;
7864 -> 7863;
7865 -> 7861;
7865 -> 7863;
7866 -> 7862;
7866 -> 7863;
7867 -> 7863;
7868 -> 7864;
7868 -> 7867;
7868 -> 7863;
7869 -> 7452;
7870 -> 7452;
7871 -> 7452;
7871 -> 0;
7872 -> 7452;
7873 -> 7452;
7873 -> 0;
7874 -> 7452;
7874 -> 0;
7875 -> 7452;
7875 -> 0;
7876 -> 7452;
7876 -> 0;
7877 -> 7452;
7877 -> 0;
7878 -> 7452;
7878 -> 0;
7879 -> 7452;
7880 -> 7452;
7881 -> 7452;
7882 -> 7452;
7882 -> 0;
7883 -> 7452;
7884 -> 7452;
7885 -> 7883;
7885 -> 7884;
7886 -> 7885;
7886 -> 7884;
7887 -> 7886;
7888 -> 7452;
7889 -> 7888;
7889 -> 7452;
7890 -> 7452;
7891 -> 7890;
7891 -> 7452;
7892 -> 7881;
7892 -> 7891;
7893 -> 7452;
7894 -> 7892;
7894 -> 7893;
7894 -> 7452;
7895 -> 7894;
7895 -> 7888;
7895 -> 7452;
7896 -> 7888;
7896 -> 7452;
7897 -> 7887;
7897 -> 7896;
7898 -> 7887;
7898 -> 7452;
7899 -> 7452;
7899 -> 0;
7900 -> 7452;
7901 -> 7452;
7902 -> 7452;
7903 -> 7901;
7903 -> 7902;
7904 -> 7903;
7904 -> 7902;
7905 -> 7904;
7906 -> 7452;
7907 -> 7905;
7907 -> 7906;
7908 -> 7452;
7909 -> 7452;
7910 -> 7908;
7910 -> 7909;
7911 -> 7452;
7911 -> 7909;
7912 -> 7910;
7912 -> 7452;
7912 -> 0;
7912 -> 7909;
7913 -> 7912;
7914 -> 7452;
7915 -> 7901;
7915 -> 7914;
7916 -> 7915;
7916 -> 7914;
7917 -> 7916;
7918 -> 7452;
7919 -> 7452;
7920 -> 7452;
7921 -> 7452;
7921 -> 7863;
7922 -> 7768;
7923 -> 7452;
7923 -> 7922;
7923 -> 7768;
7924 -> 7752;
7924 -> 0;
7924 -> 7751;
7925 -> 7924;
7926 -> 7925;
7926 -> 7924;
7927 -> 7755;
7927 -> 7924;
7928 -> 7924;
7929 -> 7926;
7929 -> 7928;
7930 -> 7927;
7930 -> 7928;
7931 -> 7928;
7932 -> 7929;
7932 -> 7928;
7933 -> 7930;
7933 -> 7928;
7934 -> 7928;
7935 -> 7931;
7935 -> 7934;
7936 -> 7931;
7936 -> 7934;
7937 -> 7931;
7937 -> 7934;
7938 -> 7931;
7938 -> 7934;
7939 -> 7932;
7939 -> 7934;
7940 -> 7931;
7940 -> 7934;
7941 -> 7933;
7941 -> 7934;
7942 -> 7934;
7943 -> 7452;
7943 -> 7942;
7943 -> 7934;
7944 -> 7934;
7945 -> 7939;
7945 -> 7944;
7945 -> 7934;
7946 -> 7934;
7947 -> 7452;
7947 -> 7946;
7948 -> 7947;
7948 -> 7934;
7949 -> 7934;
7950 -> 7934;
7951 -> 7940;
7951 -> 7934;
7952 -> 7935;
7952 -> 7951;
7953 -> 7938;
7953 -> 7951;
7954 -> 7939;
7954 -> 7951;
7955 -> 7941;
7955 -> 7951;
7956 -> 7951;
7957 -> 7952;
7957 -> 7956;
7958 -> 7953;
7958 -> 7956;
7959 -> 7954;
7959 -> 7956;
7960 -> 7955;
7960 -> 7956;
7961 -> 7960;
7961 -> 7956;
7962 -> 7956;
7963 -> 7961;
7963 -> 7962;
7964 -> 7962;
7965 -> 7452;
7966 -> 7452;
7966 -> 7956;
7967 -> 7956;
7968 -> 7935;
7968 -> 7934;
7969 -> 7936;
7969 -> 7934;
7970 -> 7937;
7970 -> 7934;
7971 -> 7938;
7971 -> 7934;
7972 -> 7939;
7972 -> 7934;
7973 -> 7940;
7973 -> 7934;
7974 -> 7941;
7974 -> 7934;
7975 -> 7934;
7976 -> 7934;
7977 -> 7968;
7977 -> 7976;
7978 -> 7969;
7978 -> 7976;
7979 -> 7970;
7979 -> 7976;
7980 -> 7971;
7980 -> 7976;
7981 -> 7972;
7981 -> 7976;
7982 -> 7973;
7982 -> 7976;
7983 -> 7974;
7983 -> 7976;
7984 -> 7975;
7984 -> 7976;
7985 -> 7976;
7986 -> 7985;
7986 -> 7976;
7987 -> 7985;
7987 -> 7976;
7988 -> 7985;
7988 -> 7976;
7989 -> 7985;
7989 -> 7976;
7990 -> 7985;
7990 -> 7976;
7991 -> 7985;
7991 -> 7976;
7992 -> 7985;
7992 -> 7976;
7993 -> 7985;
7993 -> 7976;
7994 -> 7985;
7994 -> 7976;
7995 -> 7985;
7995 -> 7976;
7996 -> 7985;
7996 -> 7976;
7997 -> 7976;
7998 -> 7452;
7998 -> 7997;
7998 -> 7976;
7999 -> 7976;
8000 -> 7981;
8000 -> 7999;
8000 -> 7976;
8001 -> 7977;
8001 -> 7985;
8001 -> 7976;
8002 -> 7978;
8002 -> 7985;
8002 -> 7976;
8003 -> 7983;
8003 -> 7985;
8003 -> 7976;
8004 -> 7981;
8004 -> 7985;
8004 -> 7976;
8005 -> 7982;
8005 -> 7985;
8005 -> 7976;
8006 -> 7980;
8006 -> 7985;
8006 -> 7976;
8007 -> 7980;
8007 -> 7976;
8008 -> 7976;
8009 -> 8007;
8009 -> 8008;
8010 -> 7985;
8010 -> 8008;
8011 -> 8009;
8011 -> 8008;
8012 -> 7976;
8013 -> 7978;
8013 -> 7979;
8013 -> 7976;
8014 -> 7979;
8014 -> 7985;
8014 -> 7976;
8015 -> 7934;
8016 -> 7934;
8017 -> 8016;
8018 -> 8017;
8019 -> 8018;
8020 -> 7452;
8020 -> 8018;
8021 -> 8016;
8022 -> 7934;
8023 -> 7975;
8023 -> 8022;
8024 -> 7452;
8025 -> 7452;
8026 -> 7452;
8027 -> 8025;
8027 -> 8026;
8028 -> 8025;
8028 -> 8026;
8029 -> 8026;
8030 -> 8027;
8030 -> 8029;
8030 -> 8026;
8031 -> 7452;
8032 -> 7452;
8033 -> 7934;
8034 -> 7934;
8035 -> 7975;
8035 -> 8034;
8036 -> 8034;
8037 -> 7452;
8037 -> 8036;
8037 -> 8034;
8038 -> 8034;
8039 -> 8038;
8039 -> 8034;
8040 -> 7934;
8041 -> 7934;
8042 -> 7935;
8042 -> 8041;
8042 -> 7934;
8043 -> 7934;
8044 -> 7935;
8044 -> 8043;
8044 -> 7934;
8045 -> 7934;
8046 -> 7934;
8047 -> 7940;
8047 -> 8046;
8047 -> 7934;
8048 -> 7939;
8048 -> 8047;
8049 -> 7941;
8049 -> 8047;
8050 -> 8047;
8051 -> 8048;
8051 -> 8050;
8052 -> 8049;
8052 -> 8050;
8053 -> 8050;
8054 -> 8053;
8055 -> 8054;
8056 -> 7452;
8056 -> 8054;
8057 -> 8052;
8057 -> 8050;
8058 -> 8050;
8059 -> 8047;
8060 -> 8047;
8061 -> 7935;
8061 -> 8060;
8061 -> 8047;
8062 -> 7928;
8063 -> 7929;
8063 -> 7928;
8064 -> 7930;
8064 -> 7928;
8065 -> 7928;
8066 -> 8062;
8066 -> 8065;
8067 -> 8062;
8067 -> 8065;
8068 -> 8063;
8068 -> 8065;
8069 -> 8064;
8069 -> 8065;
8070 -> 8062;
8070 -> 8065;
8071 -> 8062;
8071 -> 8065;
8072 -> 8065;
8073 -> 8065;
8074 -> 8067;
8074 -> 8073;
8074 -> 8065;
8075 -> 8065;
8076 -> 8075;
8077 -> 7452;
8077 -> 8075;
8078 -> 8072;
8078 -> 8065;
8079 -> 8070;
8079 -> 8065;
8080 -> 8071;
8080 -> 8065;
8081 -> 8065;
8082 -> 8068;
8082 -> 8065;
8083 -> 8069;
8083 -> 8065;
8084 -> 8065;
8085 -> 8078;
8085 -> 8084;
8086 -> 8079;
8086 -> 8084;
8087 -> 8080;
8087 -> 8084;
8088 -> 8081;
8088 -> 8084;
8089 -> 8081;
8089 -> 8084;
8090 -> 8082;
8090 -> 8084;
8091 -> 8083;
8091 -> 8084;
8092 -> 8081;
8092 -> 8084;
8093 -> 8084;
8094 -> 8093;
8094 -> 8084;
8095 -> 8093;
8095 -> 8084;
8096 -> 8093;
8096 -> 8084;
8097 -> 8093;
8097 -> 8084;
8098 -> 8093;
8098 -> 8084;
8099 -> 8093;
8099 -> 8084;
8100 -> 8093;
8100 -> 8084;
8101 -> 8093;
8101 -> 8084;
8102 -> 8093;
8102 -> 8084;
8103 -> 8093;
8103 -> 8084;
8104 -> 8093;
8104 -> 8084;
8105 -> 8093;
8105 -> 8084;
8106 -> 8085;
8106 -> 8093;
8106 -> 8084;
8107 -> 8086;
8107 -> 8093;
8107 -> 8084;
8108 -> 8087;
8108 -> 8093;
8108 -> 8084;
8109 -> 8088;
8109 -> 8093;
8109 -> 8084;
8110 -> 8089;
8110 -> 8093;
8110 -> 8084;
8111 -> 8090;
8111 -> 8093;
8111 -> 8084;
8112 -> 8091;
8112 -> 8093;
8112 -> 8084;
8113 -> 8065;
8114 -> 8113;
8115 -> 7452;
8115 -> 8113;
8116 -> 8065;
8117 -> 7452;
8118 -> 7452;
8119 -> 7452;
8120 -> 8118;
8120 -> 8119;
8121 -> 7452;
8121 -> 8119;
8122 -> 8121;
8122 -> 7452;
8122 -> 8119;
8123 -> 8119;
8124 -> 8122;
8125 -> 7452;
8126 -> 7452;
8127 -> 8125;
8127 -> 8126;
8128 -> 7452;
8128 -> 8126;
8129 -> 8128;
8129 -> 7452;
8129 -> 8126;
8130 -> 8126;
8131 -> 8129;
8132 -> 7452;
8133 -> 7452;
8134 -> 7452;
8135 -> 8133;
8135 -> 8134;
8136 -> 7452;
8136 -> 8134;
8137 -> 8136;
8137 -> 7452;
8137 -> 8134;
8138 -> 8134;
8139 -> 8137;
8140 -> 7452;
8141 -> 7452;
8142 -> 7452;
8142 -> 8141;
8143 -> 7452;
8144 -> 8141;
8144 -> 8143;
8145 -> 8141;
8145 -> 8143;
8146 -> 7452;
8146 -> 8143;
8147 -> 8144;
8147 -> 8143;
8148 -> 8145;
8148 -> 8143;
8149 -> 8147;
8149 -> 8148;
8149 -> 8143;
8150 -> 8143;
8151 -> 8149;
8151 -> 8150;
8152 -> 8146;
8152 -> 8150;
8153 -> 8152;
8153 -> 7452;
8153 -> 8150;
8154 -> 8150;
8155 -> 8153;
8156 -> 8143;
8157 -> 7452;
8158 -> 7452;
8159 -> 7452;
8160 -> 7452;
8161 -> 8159;
8161 -> 8160;
8162 -> 7452;
8162 -> 8160;
8163 -> 8162;
8163 -> 7452;
8163 -> 8160;
8164 -> 8160;
8165 -> 8163;
8166 -> 7452;
8167 -> 7452;
8168 -> 8166;
8168 -> 8167;
8169 -> 7452;
8169 -> 8167;
8170 -> 8169;
8170 -> 7452;
8170 -> 8167;
8171 -> 8167;
8172 -> 8170;
8173 -> 7452;
8174 -> 7452;
8174 -> 8116;
8175 -> 7452;
8176 -> 7452;
8177 -> 7452;
8178 -> 7452;
8179 -> 7452;
8180 -> 7452;
8181 -> 0;
8181 -> 7452;
8182 -> 7452;
8183 -> 7452;
8184 -> 7452;
8185 -> 8184;
8185 -> 8181;
8185 -> 7452;
8186 -> 8185;
8186 -> 7452;
8187 -> 7452;
8188 -> 7452;
8189 -> 8183;
8189 -> 8188;
8189 -> 7452;
8190 -> 0;
8190 -> 8189;
8191 -> 7452;
8192 -> 8190;
8192 -> 0;
8192 -> 7452;
8193 -> 8186;
8193 -> 0;
8193 -> 8192;
8194 -> 8192;
8195 -> 7452;
8196 -> 7452;
8197 -> 7452;
8198 -> 8196;
8198 -> 8197;
8199 -> 7452;
8199 -> 8197;
8200 -> 8199;
8200 -> 7452;
8200 -> 8197;
8201 -> 8197;
8202 -> 8200;
8203 -> 7452;
8204 -> 7452;
8205 -> 7452;
8206 -> 8204;
8206 -> 8205;
8207 -> 7452;
8207 -> 8205;
8208 -> 8207;
8208 -> 7452;
8208 -> 8205;
8209 -> 8205;
8210 -> 8208;
8211 -> 8065;
8212 -> 8081;
8212 -> 7452;
8212 -> 8211;
8212 -> 8065;
8213 -> 8072;
8213 -> 8065;
8214 -> 8065;
8215 -> 8070;
8215 -> 8214;
8215 -> 8065;
8216 -> 8215;
8217 -> 8216;
8218 -> 8217;
8219 -> 7452;
8220 -> 7452;
8221 -> 7452;
8222 -> 7928;
8223 -> 7929;
8223 -> 7928;
8224 -> 7930;
8224 -> 7928;
8225 -> 7928;
8226 -> 8222;
8226 -> 8225;
8227 -> 8223;
8227 -> 8225;
8228 -> 8224;
8228 -> 8225;
8229 -> 7452;
8229 -> 8225;
8230 -> 8225;
8231 -> 8229;
8231 -> 7452;
8231 -> 8230;
8231 -> 8225;
8232 -> 8226;
8232 -> 8225;
8233 -> 8225;
8234 -> 8232;
8234 -> 8233;
8235 -> 8229;
8235 -> 8233;
8236 -> 8233;
8237 -> 8235;
8237 -> 7452;
8237 -> 8236;
8237 -> 8233;
8238 -> 8225;
8239 -> 7924;
8240 -> 7925;
8240 -> 7924;
8241 -> 7754;
8241 -> 7751;
8242 -> 7756;
8242 -> 7751;
8243 -> 7755;
8243 -> 7751;
8244 -> 7751;
8245 -> 7742;
8246 -> 7735;
8246 -> 7734;
8247 -> 7734;
8248 -> 8246;
8248 -> 8247;
8249 -> 8248;
8249 -> 8247;
8250 -> 8247;
8251 -> 8249;
8251 -> 8250;
8252 -> 8251;
8252 -> 8250;
8253 -> 8250;
8254 -> 8250;
8255 -> 8252;
8255 -> 8254;
8256 -> 8253;
8256 -> 8254;
8257 -> 8254;
8258 -> 8255;
8258 -> 8257;
8258 -> 8254;
8259 -> 8255;
8259 -> 8254;
8260 -> 8255;
8260 -> 8254;
8261 -> 8256;
8261 -> 8259;
8261 -> 8260;
8261 -> 8254;
8262 -> 8255;
8262 -> 8254;
8263 -> 8254;
8264 -> 7452;
8264 -> 8263;
8264 -> 8254;
8265 -> 8254;
8266 -> 8255;
8266 -> 8254;
8267 -> 8254;
8268 -> 8266;
8268 -> 8267;
8269 -> 8267;
8270 -> 8267;
8271 -> 7452;
8271 -> 8267;
8272 -> 8271;
8272 -> 8267;
8273 -> 8270;
8273 -> 8272;
8274 -> 8273;
8274 -> 8269;
8274 -> 8267;
8275 -> 8273;
8275 -> 8269;
8275 -> 8267;
8276 -> 8275;
8276 -> 8267;
8277 -> 8268;
8277 -> 8267;
8278 -> 8268;
8278 -> 8267;
8279 -> 8268;
8279 -> 8267;
8280 -> 8267;
8281 -> 8279;
8281 -> 8280;
8282 -> 1850;
8282 -> 8280;
8283 -> 8280;
8284 -> 8281;
8284 -> 8280;
8285 -> 8280;
8286 -> 8285;
8286 -> 8267;
8287 -> 8286;
8288 -> 8287;
8289 -> 1850;
8289 -> 8287;
8290 -> 8267;
8291 -> 8290;
8291 -> 8267;
8292 -> 8267;
8293 -> 8267;
8294 -> 8290;
8294 -> 8293;
8294 -> 8291;
8294 -> 8267;
8295 -> 8267;
8296 -> 8268;
8296 -> 8267;
8297 -> 8290;
8297 -> 8267;
8298 -> 8295;
8298 -> 8267;
8299 -> 8267;
8300 -> 8297;
8300 -> 8299;
8301 -> 8298;
8301 -> 8299;
8302 -> 8301;
8302 -> 8295;
8302 -> 8299;
8303 -> 8299;
8304 -> 8303;
8304 -> 8302;
8304 -> 8299;
8305 -> 8267;
8306 -> 8267;
8307 -> 8290;
8307 -> 8306;
8307 -> 8294;
8307 -> 8267;
8308 -> 8267;
8309 -> 8267;
8310 -> 8267;
8311 -> 8309;
8311 -> 8310;
8311 -> 8267;
8312 -> 8267;
8313 -> 8290;
8313 -> 8312;
8313 -> 8307;
8313 -> 8267;
8314 -> 8295;
8314 -> 8267;
8315 -> 8308;
8315 -> 8267;
8316 -> 0;
8316 -> 8267;
8317 -> 8267;
8318 -> 8267;
8319 -> 8314;
8319 -> 8318;
8320 -> 8315;
8320 -> 8318;
8321 -> 8316;
8321 -> 8318;
8322 -> 8317;
8322 -> 8318;
8323 -> 8317;
8323 -> 8318;
8324 -> 8318;
8325 -> 8322;
8325 -> 8324;
8325 -> 8318;
8326 -> 8325;
8326 -> 8318;
8327 -> 5686;
8327 -> 8326;
8328 -> 8318;
8329 -> 8328;
8329 -> 8323;
8329 -> 8318;
8330 -> 8319;
8330 -> 8318;
8331 -> 8320;
8331 -> 8318;
8332 -> 8321;
8332 -> 8318;
8333 -> 8330;
8333 -> 8318;
8334 -> 8331;
8334 -> 8318;
8335 -> 8329;
8335 -> 8318;
8336 -> 8318;
8337 -> 8333;
8337 -> 8336;
8338 -> 8334;
8338 -> 8336;
8339 -> 8335;
8339 -> 8336;
8340 -> 8327;
8340 -> 8336;
8341 -> 8337;
8341 -> 8336;
8342 -> 8337;
8342 -> 8330;
8342 -> 8336;
8343 -> 8338;
8343 -> 8336;
8344 -> 8338;
8344 -> 8331;
8344 -> 8336;
8345 -> 8336;
8346 -> 8341;
8346 -> 8345;
8347 -> 8342;
8347 -> 8345;
8348 -> 8343;
8348 -> 8345;
8349 -> 8344;
8349 -> 8345;
8350 -> 8340;
8350 -> 8345;
8351 -> 8346;
8351 -> 8345;
8352 -> 8347;
8352 -> 8345;
8353 -> 8348;
8353 -> 8345;
8354 -> 8349;
8354 -> 8345;
8355 -> 8345;
8356 -> 8351;
8356 -> 8355;
8357 -> 8352;
8357 -> 8355;
8358 -> 8353;
8358 -> 8355;
8359 -> 8354;
8359 -> 8355;
8360 -> 8350;
8360 -> 8355;
8361 -> 8355;
8362 -> 8357;
8362 -> 8361;
8362 -> 8355;
8363 -> 8355;
8364 -> 8359;
8364 -> 8363;
8364 -> 8355;
8365 -> 8362;
8365 -> 8364;
8365 -> 8355;
8366 -> 8355;
8367 -> 8366;
8367 -> 8365;
8367 -> 8355;
8368 -> 8355;
8369 -> 8368;
8369 -> 8357;
8369 -> 8355;
8370 -> 8355;
8371 -> 8370;
8371 -> 8359;
8371 -> 8355;
8372 -> 8355;
8373 -> 8372;
8373 -> 8357;
8373 -> 8355;
8374 -> 8365;
8374 -> 8355;
8375 -> 8347;
8375 -> 8345;
8376 -> 8349;
8376 -> 8345;
8377 -> 8345;
8378 -> 8375;
8378 -> 8377;
8378 -> 8345;
8379 -> 8345;
8380 -> 8375;
8380 -> 8379;
8380 -> 8345;
8381 -> 8345;
8382 -> 8376;
8382 -> 8381;
8382 -> 8345;
8383 -> 8345;
8384 -> 8383;
8384 -> 8336;
8385 -> 8336;
8386 -> 8385;
8386 -> 8318;
8387 -> 8332;
8387 -> 8386;
8387 -> 8318;
8388 -> 8290;
8388 -> 8387;
8388 -> 8313;
8388 -> 8267;
8389 -> 8308;
8389 -> 8267;
8390 -> 8295;
8390 -> 8267;
8391 -> 8290;
8391 -> 8388;
8391 -> 8267;
8392 -> 8391;
8392 -> 8254;
8393 -> 8247;
8394 -> 7734;
8395 -> 7452;
8395 -> 7734;
8396 -> 7734;
8397 -> 8395;
8397 -> 8396;
8398 -> 8395;
8398 -> 8396;
8399 -> 8398;
8399 -> 8396;
8400 -> 7734;
8401 -> 7442;
8402 -> 7442;
8403 -> 8401;
8403 -> 8402;
8404 -> 8401;
8404 -> 8402;
8405 -> 8401;
8405 -> 8402;
8406 -> 8403;
8406 -> 8402;
8407 -> 8404;
8407 -> 8402;
8408 -> 8405;
8408 -> 8402;
8409 -> 8402;
8410 -> 8406;
8410 -> 8409;
8411 -> 8407;
8411 -> 8409;
8412 -> 8408;
8412 -> 8409;
8413 -> 8412;
8413 -> 8409;
8414 -> 8409;
8415 -> 8409;
8416 -> 8414;
8416 -> 8415;
8417 -> 8413;
8417 -> 8415;
8418 -> 8414;
8418 -> 8415;
8419 -> 8414;
8419 -> 8415;
8420 -> 8414;
8420 -> 8415;
8421 -> 8414;
8421 -> 8415;
8422 -> 8414;
8422 -> 8415;
8423 -> 8414;
8423 -> 8415;
8424 -> 8415;
8425 -> 8415;
8426 -> 8418;
8426 -> 8425;
8426 -> 8415;
8427 -> 8415;
8428 -> 7452;
8429 -> 0;
8429 -> 8428;
8430 -> 8429;
8430 -> 7452;
8431 -> 8424;
8431 -> 8415;
8432 -> 8423;
8432 -> 8415;
8433 -> 8415;
8434 -> 8422;
8434 -> 8415;
8435 -> 8419;
8435 -> 8415;
8436 -> 8420;
8436 -> 8415;
8437 -> 8421;
8437 -> 8415;
8438 -> 8416;
8438 -> 8415;
8439 -> 7446;
8439 -> 8433;
8440 -> 7446;
8440 -> 8433;
8441 -> 7446;
8441 -> 8433;
8442 -> 7446;
8442 -> 8433;
8443 -> 7446;
8443 -> 8433;
8444 -> 7446;
8444 -> 8433;
8445 -> 8433;
8446 -> 8442;
8446 -> 8445;
8447 -> 8445;
8448 -> 7446;
8448 -> 8447;
8449 -> 8447;
8450 -> 8449;
8451 -> 8450;
8452 -> 7446;
8452 -> 8450;
8453 -> 8445;
8454 -> 8433;
8455 -> 8442;
8455 -> 8454;
8455 -> 8433;
8456 -> 8433;
8457 -> 8456;
8458 -> 8457;
8459 -> 8442;
8459 -> 8457;
8460 -> 8456;
8461 -> 8456;
8462 -> 8461;
8463 -> 8442;
8463 -> 8461;
8464 -> 8442;
8464 -> 8456;
8465 -> 8456;
8466 -> 8433;
8467 -> 8433;
8468 -> 8442;
8469 -> 8442;
8470 -> 8442;
8471 -> 8442;
8472 -> 8433;
8473 -> 8439;
8473 -> 8472;
8473 -> 8433;
8474 -> 8433;
8475 -> 8440;
8475 -> 8474;
8475 -> 8433;
8476 -> 8433;
8477 -> 8441;
8477 -> 8476;
8477 -> 8433;
8478 -> 8433;
8479 -> 0;
8479 -> 8433;
8480 -> 8433;
8481 -> 8433;
8482 -> 8479;
8482 -> 8481;
8483 -> 8480;
8483 -> 8481;
8484 -> 8481;
8485 -> 8482;
8485 -> 8481;
8486 -> 8483;
8486 -> 8481;
8487 -> 8484;
8487 -> 8481;
8488 -> 8481;
8489 -> 8485;
8489 -> 8488;
8490 -> 8486;
8490 -> 8488;
8491 -> 8487;
8491 -> 8488;
8492 -> 8488;
8493 -> 8489;
8493 -> 0;
8493 -> 8488;
8494 -> 8493;
8494 -> 8490;
8494 -> 8488;
8495 -> 8494;
8496 -> 8495;
8497 -> 8496;
8498 -> 8494;
8499 -> 8442;
8500 -> 8442;
8501 -> 8494;
8502 -> 8442;
8503 -> 8489;
8503 -> 0;
8503 -> 8488;
8504 -> 8492;
8504 -> 8503;
8505 -> 8503;
8506 -> 8503;
8507 -> 8503;
8508 -> 7446;
8508 -> 8507;
8509 -> 8508;
8509 -> 8442;
8509 -> 8507;
8510 -> 8509;
8510 -> 8503;
8511 -> 8503;
8512 -> 8503;
8513 -> 8503;
8514 -> 8512;
8514 -> 8513;
8515 -> 8512;
8515 -> 8513;
8516 -> 8512;
8516 -> 8513;
8517 -> 8513;
8518 -> 8513;
8519 -> 8513;
8520 -> 8514;
8520 -> 8519;
8520 -> 8513;
8521 -> 8513;
8522 -> 8521;
8523 -> 8522;
8524 -> 8442;
8524 -> 8522;
8525 -> 8518;
8525 -> 8513;
8526 -> 8514;
8526 -> 8513;
8527 -> 8526;
8528 -> 8526;
8529 -> 8513;
8530 -> 8516;
8530 -> 8529;
8530 -> 8513;
8531 -> 8514;
8531 -> 8513;
8532 -> 8515;
8532 -> 8513;
8533 -> 8513;
8534 -> 8531;
8534 -> 8533;
8535 -> 8532;
8535 -> 8533;
8536 -> 8533;
8537 -> 8534;
8537 -> 8536;
8537 -> 8533;
8538 -> 7446;
8538 -> 8442;
8538 -> 8533;
8539 -> 8503;
8540 -> 7446;
8540 -> 8442;
8540 -> 8539;
8540 -> 8503;
8541 -> 8489;
8541 -> 0;
8541 -> 8488;
8542 -> 8491;
8542 -> 8488;
8543 -> 8492;
8543 -> 8488;
8544 -> 8488;
8545 -> 8481;
8546 -> 8442;
8546 -> 7446;
8547 -> 7446;
8547 -> 8442;
8548 -> 7446;
8549 -> 7446;
8550 -> 8442;
8550 -> 7446;
8551 -> 8433;
8552 -> 8433;
8553 -> 8552;
8554 -> 8553;
8555 -> 8554;
8556 -> 8442;
8556 -> 8554;
8557 -> 8552;
8558 -> 8433;
8559 -> 8558;
8560 -> 8442;
8560 -> 8558;
8561 -> 8433;
8562 -> 8433;
8563 -> 8562;
8564 -> 8442;
8564 -> 8562;
8565 -> 7446;
8565 -> 8433;
8566 -> 8433;
8567 -> 8565;
8567 -> 8442;
8568 -> 8567;
8568 -> 8442;
8569 -> 8442;
8570 -> 8442;
8571 -> 8442;
8572 -> 8442;
8573 -> 8442;
8573 -> 8572;
8574 -> 8568;
8574 -> 8572;
8575 -> 8572;
8576 -> 8573;
8576 -> 8575;
8577 -> 8573;
8577 -> 8575;
8578 -> 8574;
8578 -> 8575;
8579 -> 8442;
8579 -> 8575;
8580 -> 8579;
8580 -> 8442;
8580 -> 8575;
8581 -> 8575;
8582 -> 8577;
8582 -> 8581;
8583 -> 8582;
8583 -> 8575;
8584 -> 8580;
8584 -> 8442;
8584 -> 8575;
8585 -> 8579;
8585 -> 8442;
8585 -> 0;
8585 -> 8575;
8586 -> 8583;
8586 -> 8442;
8586 -> 8575;
8587 -> 8585;
8587 -> 8586;
8587 -> 8575;
8588 -> 8576;
8588 -> 8442;
8588 -> 8575;
8589 -> 8576;
8589 -> 8442;
8589 -> 8575;
8590 -> 8575;
8591 -> 8579;
8591 -> 8442;
8591 -> 8590;
8591 -> 8575;
8592 -> 8572;
8593 -> 7446;
8593 -> 8433;
8594 -> 7446;
8594 -> 8442;
8594 -> 8433;
8595 -> 8433;
8596 -> 8595;
8596 -> 8594;
8596 -> 8442;
8596 -> 8433;
8597 -> 8433;
8598 -> 7446;
8598 -> 8442;
8598 -> 8433;
8599 -> 7446;
8599 -> 8433;
8600 -> 8433;
8601 -> 8598;
8601 -> 8600;
8602 -> 8599;
8602 -> 8600;
8603 -> 7446;
8603 -> 8600;
8604 -> 8601;
8604 -> 8442;
8605 -> 8601;
8606 -> 8605;
8606 -> 8604;
8606 -> 8442;
8606 -> 8601;
8607 -> 8602;
8607 -> 8442;
8607 -> 8601;
8608 -> 7446;
8608 -> 8433;
8609 -> 8608;
8609 -> 8601;
8609 -> 8433;
8610 -> 8433;
8611 -> 8609;
8611 -> 8610;
8612 -> 8433;
8613 -> 7446;
8613 -> 8433;
8614 -> 8613;
8614 -> 8601;
8614 -> 8433;
8615 -> 8433;
8616 -> 8614;
8616 -> 8615;
8617 -> 8615;
8618 -> 8616;
8618 -> 8615;
8619 -> 8615;
8620 -> 8618;
8620 -> 8619;
8621 -> 8619;
8622 -> 8621;
8623 -> 8621;
8624 -> 8601;
8624 -> 8621;
8625 -> 8624;
8625 -> 8619;
8626 -> 8619;
8627 -> 8601;
8627 -> 8619;
8628 -> 8627;
8629 -> 8625;
8629 -> 8628;
8629 -> 8627;
8630 -> 8629;
8631 -> 8615;
8632 -> 8617;
8632 -> 8615;
8633 -> 8617;
8633 -> 8615;
8634 -> 8617;
8634 -> 8615;
8635 -> 8617;
8635 -> 8615;
8636 -> 8617;
8636 -> 8615;
8637 -> 8617;
8637 -> 8615;
8638 -> 8617;
8638 -> 8615;
8639 -> 8617;
8639 -> 8615;
8640 -> 8433;
8641 -> 7446;
8641 -> 8433;
8642 -> 8433;
8643 -> 8433;
8644 -> 7446;
8644 -> 8433;
8645 -> 7446;
8645 -> 8433;
8646 -> 8433;
8647 -> 8433;
8648 -> 8601;
8648 -> 0;
8648 -> 8647;
8649 -> 8647;
8650 -> 8601;
8651 -> 8601;
8651 -> 8647;
8652 -> 8647;
8653 -> 8652;
8654 -> 8601;
8654 -> 8652;
8655 -> 8647;
8656 -> 8647;
8657 -> 7446;
8657 -> 8433;
8658 -> 7446;
8658 -> 8433;
8659 -> 7446;
8659 -> 8433;
8660 -> 8433;
8661 -> 7446;
8661 -> 8660;
8661 -> 8433;
8662 -> 8433;
8663 -> 7446;
8663 -> 8662;
8664 -> 8657;
8664 -> 8662;
8665 -> 8658;
8665 -> 8662;
8666 -> 8659;
8666 -> 8662;
8667 -> 8662;
8668 -> 8662;
8669 -> 7446;
8669 -> 8601;
8669 -> 8662;
8670 -> 8669;
8670 -> 8601;
8670 -> 8662;
8671 -> 7446;
8671 -> 8601;
8671 -> 8662;
8672 -> 8665;
8672 -> 8671;
8673 -> 7446;
8673 -> 8601;
8673 -> 8672;
8674 -> 8669;
8674 -> 8672;
8675 -> 8672;
8676 -> 8674;
8676 -> 8675;
8677 -> 8675;
8678 -> 8676;
8678 -> 8677;
8678 -> 8675;
8679 -> 8678;
8680 -> 8676;
8680 -> 8601;
8680 -> 8678;
8681 -> 8675;
8682 -> 8681;
8682 -> 8672;
8683 -> 8673;
8683 -> 8682;
8683 -> 8672;
8684 -> 7446;
8684 -> 8683;
8685 -> 7446;
8685 -> 8601;
8685 -> 8683;
8686 -> 8662;
8687 -> 8666;
8687 -> 8601;
8687 -> 8686;
8687 -> 8662;
8688 -> 8433;
8689 -> 7446;
8689 -> 8433;
8690 -> 7446;
8690 -> 8433;
8691 -> 8433;
8692 -> 8690;
8692 -> 8691;
8692 -> 8433;
8693 -> 8689;
8693 -> 8601;
8694 -> 8690;
8694 -> 8601;
8695 -> 8693;
8695 -> 8601;
8696 -> 8694;
8696 -> 8601;
8697 -> 8601;
8698 -> 8601;
8699 -> 8601;
8700 -> 8696;
8700 -> 8699;
8700 -> 8601;
8701 -> 8601;
8702 -> 8601;
8702 -> 8701;
8703 -> 8601;
8703 -> 0;
8704 -> 8601;
8705 -> 8698;
8705 -> 8704;
8706 -> 8705;
8707 -> 8705;
8708 -> 8601;
8708 -> 8705;
8709 -> 8705;
8710 -> 8708;
8710 -> 8709;
8711 -> 8709;
8712 -> 8710;
8712 -> 8711;
8713 -> 8711;
8714 -> 8712;
8714 -> 8713;
8714 -> 8711;
8715 -> 8711;
8716 -> 8715;
8716 -> 8709;
8717 -> 8601;
8717 -> 8716;
8718 -> 8601;
8719 -> 7446;
8719 -> 8433;
8720 -> 7446;
8720 -> 8433;
8721 -> 7446;
8721 -> 8433;
8722 -> 7446;
8722 -> 8433;
8723 -> 8433;
8724 -> 8720;
8724 -> 8723;
8724 -> 8433;
8725 -> 7446;
8725 -> 8601;
8725 -> 8433;
8726 -> 7446;
8726 -> 8601;
8726 -> 8725;
8727 -> 7446;
8727 -> 8601;
8727 -> 0;
8727 -> 8433;
8728 -> 7446;
8728 -> 8601;
8728 -> 8433;
8729 -> 8722;
8729 -> 8728;
8730 -> 7446;
8730 -> 8601;
8730 -> 8433;
8731 -> 7446;
8731 -> 8433;
8732 -> 7446;
8732 -> 8601;
8732 -> 8433;
8733 -> 7446;
8733 -> 8433;
8734 -> 8433;
8735 -> 7446;
8735 -> 8734;
8735 -> 8433;
8736 -> 8433;
8737 -> 8736;
8737 -> 8433;
8738 -> 7446;
8738 -> 8433;
8739 -> 8433;
8740 -> 8433;
8741 -> 8601;
8741 -> 8740;
8742 -> 8741;
8742 -> 8601;
8742 -> 8740;
8743 -> 8741;
8743 -> 8601;
8743 -> 8742;
8744 -> 8743;
8744 -> 8742;
8745 -> 8742;
8746 -> 8744;
8746 -> 8745;
8747 -> 8746;
8747 -> 8601;
8747 -> 0;
8747 -> 8745;
8748 -> 8746;
8748 -> 8601;
8748 -> 8745;
8749 -> 8745;
8750 -> 8748;
8750 -> 8749;
8751 -> 8749;
8752 -> 8750;
8752 -> 8751;
8752 -> 8749;
8753 -> 8752;
8754 -> 8750;
8754 -> 8601;
8754 -> 8752;
8755 -> 8749;
8756 -> 8755;
8756 -> 8745;
8757 -> 8747;
8757 -> 8756;
8757 -> 8745;
8758 -> 8740;
8759 -> 8758;
8759 -> 8433;
8760 -> 8433;
8761 -> 8601;
8761 -> 8760;
8762 -> 8761;
8762 -> 8601;
8762 -> 8760;
8763 -> 8761;
8763 -> 8601;
8763 -> 8762;
8764 -> 8763;
8764 -> 8762;
8765 -> 8762;
8766 -> 8764;
8766 -> 8765;
8767 -> 8766;
8767 -> 8601;
8767 -> 0;
8767 -> 8765;
8768 -> 8766;
8768 -> 8601;
8768 -> 8765;
8769 -> 8765;
8770 -> 8768;
8770 -> 8769;
8771 -> 8769;
8772 -> 8770;
8772 -> 8771;
8772 -> 8769;
8773 -> 8772;
8774 -> 8770;
8774 -> 8601;
8774 -> 8772;
8775 -> 8769;
8776 -> 8775;
8776 -> 8765;
8777 -> 8767;
8777 -> 8776;
8777 -> 8765;
8778 -> 8760;
8779 -> 8433;
8780 -> 8657;
8780 -> 8662;
8781 -> 8657;
8781 -> 8601;
8781 -> 8662;
8782 -> 8781;
8782 -> 8601;
8782 -> 8662;
8783 -> 8657;
8783 -> 8601;
8783 -> 8662;
8784 -> 8657;
8784 -> 8783;
8784 -> 8662;
8785 -> 8665;
8785 -> 8784;
8786 -> 8657;
8786 -> 8783;
8786 -> 8785;
8787 -> 8781;
8787 -> 8785;
8788 -> 8785;
8789 -> 8787;
8789 -> 8788;
8790 -> 8788;
8791 -> 8789;
8791 -> 8790;
8791 -> 8788;
8792 -> 8791;
8793 -> 8789;
8793 -> 8783;
8793 -> 8791;
8794 -> 8788;
8795 -> 8794;
8795 -> 8785;
8796 -> 8786;
8796 -> 8795;
8796 -> 8785;
8797 -> 8657;
8797 -> 8796;
8798 -> 8657;
8798 -> 8783;
8798 -> 8796;
8799 -> 8666;
8799 -> 8783;
8799 -> 8686;
8799 -> 8662;
8800 -> 7446;
8800 -> 8783;
8800 -> 8433;
8801 -> 7446;
8801 -> 8783;
8801 -> 8800;
8802 -> 7446;
8802 -> 8783;
8802 -> 0;
8802 -> 8433;
8803 -> 7446;
8803 -> 8783;
8803 -> 8433;
8804 -> 8722;
8804 -> 8803;
8805 -> 7446;
8805 -> 8783;
8805 -> 8433;
8806 -> 7446;
8806 -> 8783;
8806 -> 8433;
8807 -> 8689;
8807 -> 8783;
8808 -> 8690;
8808 -> 8783;
8809 -> 8807;
8809 -> 8783;
8810 -> 8808;
8810 -> 8783;
8811 -> 8783;
8812 -> 8783;
8813 -> 8783;
8814 -> 8810;
8814 -> 8813;
8814 -> 8783;
8815 -> 8783;
8816 -> 8783;
8816 -> 8815;
8817 -> 8783;
8817 -> 0;
8818 -> 8783;
8819 -> 8812;
8819 -> 8818;
8820 -> 8819;
8821 -> 8819;
8822 -> 8783;
8822 -> 8819;
8823 -> 8819;
8824 -> 8822;
8824 -> 8823;
8825 -> 8823;
8826 -> 8824;
8826 -> 8825;
8827 -> 8825;
8828 -> 8826;
8828 -> 8827;
8828 -> 8825;
8829 -> 8825;
8830 -> 8829;
8830 -> 8823;
8831 -> 8783;
8831 -> 8830;
8832 -> 8783;
8833 -> 8657;
8833 -> 8783;
8833 -> 8662;
8834 -> 8833;
8834 -> 8783;
8834 -> 8662;
8835 -> 8833;
8835 -> 8785;
8836 -> 8835;
8836 -> 8788;
8837 -> 8836;
8837 -> 8790;
8837 -> 8788;
8838 -> 8837;
8839 -> 8836;
8839 -> 8783;
8839 -> 8837;
8840 -> 8828;
8841 -> 8826;
8841 -> 8783;
8841 -> 8828;
8842 -> 8783;
8842 -> 8740;
8843 -> 8842;
8843 -> 8783;
8843 -> 8740;
8844 -> 8842;
8844 -> 8783;
8844 -> 8843;
8845 -> 8844;
8845 -> 8843;
8846 -> 8843;
8847 -> 8845;
8847 -> 8846;
8848 -> 8847;
8848 -> 8783;
8848 -> 0;
8848 -> 8846;
8849 -> 8847;
8849 -> 8783;
8849 -> 8846;
8850 -> 8846;
8851 -> 8849;
8851 -> 8850;
8852 -> 8850;
8853 -> 8851;
8853 -> 8852;
8853 -> 8850;
8854 -> 8853;
8855 -> 8851;
8855 -> 8783;
8855 -> 8853;
8856 -> 8850;
8857 -> 8856;
8857 -> 8846;
8858 -> 8848;
8858 -> 8857;
8858 -> 8846;
8859 -> 8783;
8859 -> 8760;
8860 -> 8859;
8860 -> 8783;
8860 -> 8760;
8861 -> 8859;
8861 -> 8783;
8861 -> 8860;
8862 -> 8861;
8862 -> 8860;
8863 -> 8860;
8864 -> 8862;
8864 -> 8863;
8865 -> 8864;
8865 -> 8783;
8865 -> 0;
8865 -> 8863;
8866 -> 8864;
8866 -> 8783;
8866 -> 8863;
8867 -> 8863;
8868 -> 8866;
8868 -> 8867;
8869 -> 8867;
8870 -> 8868;
8870 -> 8869;
8870 -> 8867;
8871 -> 8870;
8872 -> 8868;
8872 -> 8783;
8872 -> 8870;
8873 -> 8867;
8874 -> 8873;
8874 -> 8863;
8875 -> 8865;
8875 -> 8874;
8875 -> 8863;
8876 -> 8433;
8877 -> 8565;
8877 -> 8783;
8878 -> 8877;
8878 -> 8783;
8879 -> 8783;
8880 -> 7446;
8880 -> 8783;
8880 -> 8433;
8881 -> 8595;
8881 -> 8880;
8881 -> 8783;
8881 -> 8433;
8882 -> 8433;
8883 -> 8608;
8883 -> 8783;
8883 -> 8433;
8884 -> 8883;
8884 -> 8610;
8885 -> 8613;
8885 -> 8783;
8885 -> 8433;
8886 -> 8885;
8886 -> 8615;
8887 -> 8886;
8887 -> 8615;
8888 -> 8887;
8888 -> 8619;
8889 -> 8783;
8889 -> 8621;
8890 -> 8889;
8890 -> 8619;
8891 -> 8783;
8891 -> 8619;
8892 -> 8891;
8893 -> 8890;
8893 -> 8892;
8893 -> 8891;
8894 -> 8893;
8895 -> 7446;
8895 -> 8783;
8895 -> 8433;
8896 -> 8433;
8897 -> 8896;
8898 -> 8897;
8899 -> 8898;
8900 -> 8783;
8900 -> 8898;
8901 -> 8896;
8902 -> 8783;
8902 -> 8433;
8903 -> 8433;
8904 -> 7446;
8904 -> 8433;
8905 -> 7446;
8905 -> 8433;
8906 -> 7446;
8906 -> 8783;
8906 -> 8433;
8907 -> 8783;
8908 -> 8783;
8908 -> 8907;
8909 -> 8907;
8910 -> 8909;
8910 -> 8908;
8910 -> 8783;
8910 -> 8907;
8911 -> 8783;
8912 -> 8783;
8913 -> 8912;
8913 -> 8783;
8914 -> 8783;
8915 -> 8783;
8916 -> 8783;
8916 -> 8915;
8917 -> 8783;
8917 -> 8915;
8918 -> 8914;
8918 -> 8915;
8919 -> 8915;
8920 -> 8917;
8920 -> 8919;
8920 -> 8915;
8921 -> 8914;
8921 -> 8912;
8922 -> 8912;
8923 -> 8912;
8923 -> 8922;
8924 -> 8912;
8924 -> 8922;
8925 -> 8921;
8925 -> 8922;
8926 -> 8922;
8927 -> 8924;
8927 -> 8926;
8927 -> 8922;
8928 -> 8783;
8929 -> 8783;
8930 -> 7446;
8930 -> 8912;
8930 -> 8783;
8930 -> 8929;
8931 -> 7446;
8931 -> 8433;
8932 -> 0;
8932 -> 8433;
8933 -> 7446;
8933 -> 8912;
8933 -> 8433;
8934 -> 7446;
8934 -> 8912;
8934 -> 8433;
8935 -> 7446;
8935 -> 8912;
8935 -> 8934;
8936 -> 7446;
8936 -> 8912;
8936 -> 0;
8936 -> 8433;
8937 -> 7446;
8937 -> 8912;
8937 -> 8433;
8938 -> 8722;
8938 -> 8937;
8939 -> 7446;
8939 -> 8912;
8939 -> 8433;
8940 -> 7446;
8940 -> 8912;
8940 -> 8433;
8941 -> 8912;
8941 -> 0;
8941 -> 8647;
8942 -> 8912;
8943 -> 8912;
8943 -> 8647;
8944 -> 8657;
8944 -> 8912;
8944 -> 8662;
8945 -> 8944;
8945 -> 8912;
8945 -> 8662;
8946 -> 8657;
8946 -> 8912;
8946 -> 8662;
8947 -> 8665;
8947 -> 8946;
8948 -> 8657;
8948 -> 8912;
8948 -> 8947;
8949 -> 8944;
8949 -> 8947;
8950 -> 8947;
8951 -> 8949;
8951 -> 8950;
8952 -> 8950;
8953 -> 8951;
8953 -> 8952;
8953 -> 8950;
8954 -> 8953;
8955 -> 8951;
8955 -> 8912;
8955 -> 8953;
8956 -> 8950;
8957 -> 8956;
8957 -> 8947;
8958 -> 8948;
8958 -> 8957;
8958 -> 8947;
8959 -> 8657;
8959 -> 8958;
8960 -> 8657;
8960 -> 8912;
8960 -> 8958;
8961 -> 8666;
8961 -> 8912;
8961 -> 8686;
8961 -> 8662;
8962 -> 8912;
8962 -> 8740;
8963 -> 8962;
8963 -> 8912;
8963 -> 8740;
8964 -> 8962;
8964 -> 8912;
8964 -> 8963;
8965 -> 8964;
8965 -> 8963;
8966 -> 8963;
8967 -> 8965;
8967 -> 8966;
8968 -> 8967;
8968 -> 8912;
8968 -> 0;
8968 -> 8966;
8969 -> 8967;
8969 -> 8912;
8969 -> 8966;
8970 -> 8966;
8971 -> 8969;
8971 -> 8970;
8972 -> 8970;
8973 -> 8971;
8973 -> 8972;
8973 -> 8970;
8974 -> 8973;
8975 -> 8971;
8975 -> 8912;
8975 -> 8973;
8976 -> 8970;
8977 -> 8976;
8977 -> 8966;
8978 -> 8968;
8978 -> 8977;
8978 -> 8966;
8979 -> 8912;
8979 -> 8760;
8980 -> 8979;
8980 -> 8912;
8980 -> 8760;
8981 -> 8979;
8981 -> 8912;
8981 -> 8980;
8982 -> 8981;
8982 -> 8980;
8983 -> 8980;
8984 -> 8982;
8984 -> 8983;
8985 -> 8984;
8985 -> 8912;
8985 -> 0;
8985 -> 8983;
8986 -> 8984;
8986 -> 8912;
8986 -> 8983;
8987 -> 8983;
8988 -> 8986;
8988 -> 8987;
8989 -> 8987;
8990 -> 8988;
8990 -> 8989;
8990 -> 8987;
8991 -> 8990;
8992 -> 8988;
8992 -> 8912;
8992 -> 8990;
8993 -> 8987;
8994 -> 8993;
8994 -> 8983;
8995 -> 8985;
8995 -> 8994;
8995 -> 8983;
8996 -> 8689;
8996 -> 8912;
8997 -> 8690;
8997 -> 8912;
8998 -> 8996;
8998 -> 8912;
8999 -> 8997;
8999 -> 8912;
9000 -> 8912;
9001 -> 8912;
9002 -> 8912;
9003 -> 8999;
9003 -> 9002;
9003 -> 8912;
9004 -> 8912;
9005 -> 8912;
9005 -> 9004;
9006 -> 8912;
9006 -> 0;
9007 -> 8912;
9008 -> 9001;
9008 -> 9007;
9009 -> 9008;
9010 -> 9008;
9011 -> 8912;
9011 -> 9008;
9012 -> 9008;
9013 -> 9011;
9013 -> 9012;
9014 -> 9012;
9015 -> 9013;
9015 -> 9014;
9016 -> 9014;
9017 -> 9015;
9017 -> 9016;
9017 -> 9014;
9018 -> 9014;
9019 -> 9018;
9019 -> 9012;
9020 -> 8912;
9020 -> 9019;
9021 -> 8912;
9022 -> 9017;
9023 -> 9015;
9023 -> 8912;
9023 -> 9017;
9024 -> 7446;
9024 -> 8912;
9024 -> 8433;
9025 -> 8912;
9025 -> 8898;
9026 -> 8912;
9026 -> 8433;
9027 -> 8433;
9028 -> 8433;
9029 -> 8433;
9030 -> 8433;
9031 -> 7446;
9031 -> 8912;
9032 -> 8912;
9033 -> 9031;
9033 -> 8912;
9033 -> 9032;
9034 -> 8912;
9035 -> 8912;
9036 -> 8912;
9037 -> 8912;
9038 -> 8912;
9039 -> 9027;
9039 -> 8433;
9040 -> 8912;
9040 -> 8562;
9041 -> 8912;
9041 -> 8415;
9042 -> 8415;
9043 -> 8415;
9044 -> 8417;
9044 -> 9043;
9044 -> 8415;
9045 -> 8424;
9045 -> 8415;
9046 -> 8409;
9047 -> 7444;
9047 -> 7442;
9048 -> 7442;
9049 -> 7442;
9050 -> 9048;
9050 -> 9049;
9051 -> 9050;
9051 -> 9049;
9052 -> 9049;
9053 -> 9051;
9053 -> 9052;
9054 -> 9052;
9055 -> 9053;
9055 -> 9054;
9055 -> 9052;
9056 -> 9052;
9056 -> 7442;
9057 -> 9047;
9057 -> 9049;
9058 -> 9048;
9058 -> 9049;
9059 -> 9048;
9059 -> 9049;
9060 -> 9056;
9060 -> 9049;
9061 -> 9048;
9061 -> 9049;
9062 -> 9048;
9062 -> 9049;
9063 -> 9048;
9063 -> 9049;
9064 -> 9057;
9064 -> 9049;
9065 -> 9060;
9065 -> 9049;
9066 -> 9058;
9066 -> 9049;
9067 -> 9049;
9068 -> 9065;
9068 -> 9067;
9069 -> 9066;
9069 -> 9067;
9070 -> 9068;
9070 -> 9067;
9071 -> 9067;
9072 -> 9070;
9072 -> 9071;
9073 -> 9072;
9073 -> 9071;
9074 -> 9073;
9075 -> 0;
9075 -> 9074;
9076 -> 9075;
9077 -> 9076;
9078 -> 9067;
9079 -> 9069;
9079 -> 9078;
9079 -> 9067;
9080 -> 9069;
9080 -> 9067;
9081 -> 9067;
9082 -> 9080;
9082 -> 9081;
9083 -> 9081;
9084 -> 8912;
9085 -> 9084;
9086 -> 8912;
9086 -> 9084;
9087 -> 0;
9087 -> 9081;
9088 -> 9082;
9088 -> 9081;
9089 -> 8912;
9090 -> 9085;
9090 -> 9089;
9090 -> 9086;
9090 -> 6505;
9090 -> 8912;
9091 -> 9067;
9092 -> 9069;
9092 -> 9067;
9093 -> 9059;
9093 -> 9049;
9094 -> 9061;
9094 -> 9049;
9095 -> 9062;
9095 -> 9049;
9096 -> 9063;
9096 -> 9049;
9097 -> 9049;
9098 -> 9064;
9098 -> 9097;
9099 -> 9093;
9099 -> 9097;
9100 -> 9094;
9100 -> 9097;
9101 -> 9095;
9101 -> 9097;
9102 -> 9096;
9102 -> 9097;
9103 -> 9098;
9103 -> 9097;
9104 -> 9099;
9104 -> 9097;
9105 -> 9100;
9105 -> 9097;
9106 -> 9101;
9106 -> 9097;
9107 -> 9102;
9107 -> 9097;
9108 -> 9097;
9109 -> 9108;
9109 -> 9097;
9110 -> 9097;
9111 -> 9103;
9111 -> 9110;
9112 -> 9104;
9112 -> 9110;
9113 -> 9105;
9113 -> 9110;
9114 -> 9106;
9114 -> 9110;
9115 -> 9107;
9115 -> 9110;
9116 -> 9109;
9116 -> 9110;
9117 -> 9112;
9117 -> 9110;
9118 -> 9114;
9118 -> 9110;
9119 -> 9110;
9120 -> 9117;
9120 -> 9119;
9121 -> 9118;
9121 -> 9119;
9122 -> 9111;
9122 -> 9119;
9123 -> 9122;
9123 -> 9047;
9123 -> 9119;
9124 -> 9123;
9125 -> 9121;
9125 -> 9123;
9126 -> 9120;
9126 -> 9123;
9127 -> 9123;
9128 -> 9124;
9128 -> 9127;
9129 -> 9125;
9129 -> 9127;
9130 -> 9126;
9130 -> 9127;
9131 -> 9124;
9131 -> 9127;
9132 -> 9127;
9133 -> 9130;
9133 -> 9132;
9133 -> 9127;
9134 -> 0;
9134 -> 9133;
9135 -> 9128;
9135 -> 9127;
9136 -> 0;
9136 -> 9127;
9137 -> 9136;
9137 -> 9131;
9137 -> 9127;
9138 -> 9127;
9139 -> 9134;
9139 -> 9127;
9140 -> 9129;
9140 -> 9127;
9141 -> 9127;
9142 -> 9127;
9143 -> 9142;
9144 -> 9142;
9145 -> 8912;
9145 -> 9144;
9145 -> 9142;
9146 -> 9143;
9146 -> 9142;
9147 -> 9142;
9148 -> 9145;
9148 -> 8912;
9148 -> 9144;
9148 -> 9146;
9148 -> 9147;
9148 -> 9143;
9148 -> 9142;
9149 -> 9142;
9150 -> 9149;
9150 -> 9143;
9150 -> 9142;
9151 -> 9143;
9151 -> 9142;
9152 -> 9142;
9153 -> 9151;
9153 -> 9152;
9153 -> 9143;
9153 -> 9150;
9153 -> 9142;
9154 -> 9124;
9154 -> 9110;
9155 -> 9110;
9156 -> 8912;
9156 -> 9155;
9156 -> 9110;
9157 -> 0;
9157 -> 9110;
9158 -> 9116;
9158 -> 9110;
9159 -> 8912;
9159 -> 9110;
9160 -> 9110;
9161 -> 9159;
9161 -> 9160;
9162 -> 0;
9162 -> 9160;
9163 -> 9162;
9164 -> 9110;
9165 -> 9110;
9166 -> 9165;
9167 -> 9165;
9168 -> 9165;
9169 -> 9167;
9169 -> 9168;
9170 -> 9167;
9170 -> 9168;
9171 -> 9167;
9171 -> 9168;
9172 -> 9167;
9172 -> 9168;
9173 -> 9168;
9174 -> 8912;
9174 -> 9173;
9174 -> 9168;
9175 -> 9172;
9175 -> 9168;
9176 -> 9169;
9176 -> 9168;
9177 -> 9170;
9177 -> 9168;
9178 -> 9171;
9178 -> 9168;
9179 -> 9172;
9179 -> 9168;
9180 -> 9168;
9181 -> 0;
9181 -> 9168;
9182 -> 9168;
9183 -> 9181;
9183 -> 9182;
9184 -> 9181;
9184 -> 9182;
9185 -> 9179;
9185 -> 9182;
9186 -> 9180;
9186 -> 9182;
9187 -> 9180;
9187 -> 9182;
9188 -> 9183;
9188 -> 9182;
9189 -> 9184;
9189 -> 9182;
9190 -> 9185;
9190 -> 9182;
9191 -> 9182;
9192 -> 9191;
9192 -> 9182;
9193 -> 9186;
9193 -> 9191;
9193 -> 9182;
9194 -> 9168;
9195 -> 9176;
9195 -> 9194;
9196 -> 9177;
9196 -> 9194;
9197 -> 9178;
9197 -> 9194;
9198 -> 9179;
9198 -> 9194;
9199 -> 9180;
9199 -> 9194;
9200 -> 9180;
9200 -> 9194;
9201 -> 9180;
9201 -> 9194;
9202 -> 9180;
9202 -> 9194;
9203 -> 9180;
9203 -> 9194;
9204 -> 9180;
9204 -> 9194;
9205 -> 9195;
9205 -> 9194;
9206 -> 9196;
9206 -> 9194;
9207 -> 9197;
9207 -> 9194;
9208 -> 9198;
9208 -> 9194;
9209 -> 9199;
9209 -> 9194;
9210 -> 9200;
9210 -> 9194;
9211 -> 9201;
9211 -> 9194;
9212 -> 9202;
9212 -> 9194;
9213 -> 9203;
9213 -> 9194;
9214 -> 9194;
9215 -> 9205;
9215 -> 9214;
9216 -> 9206;
9216 -> 9214;
9217 -> 9207;
9217 -> 9214;
9218 -> 9208;
9218 -> 9214;
9219 -> 9209;
9219 -> 9214;
9220 -> 9210;
9220 -> 9214;
9221 -> 9211;
9221 -> 9214;
9222 -> 9212;
9222 -> 9214;
9223 -> 9213;
9223 -> 9214;
9224 -> 9204;
9224 -> 9214;
9225 -> 9218;
9225 -> 9214;
9226 -> 9222;
9226 -> 9214;
9227 -> 9223;
9227 -> 9214;
9228 -> 9214;
9229 -> 9228;
9229 -> 9214;
9230 -> 9228;
9230 -> 9214;
9231 -> 9228;
9231 -> 9214;
9232 -> 9228;
9232 -> 9214;
9233 -> 9228;
9233 -> 9214;
9234 -> 9228;
9234 -> 9214;
9235 -> 9228;
9235 -> 9214;
9236 -> 9228;
9236 -> 9214;
9237 -> 9228;
9237 -> 9214;
9238 -> 9228;
9238 -> 9214;
9239 -> 9228;
9239 -> 9214;
9240 -> 9228;
9240 -> 9214;
9241 -> 9228;
9241 -> 9214;
9242 -> 9228;
9242 -> 9214;
9243 -> 9228;
9243 -> 9214;
9244 -> 9228;
9244 -> 9214;
9245 -> 9228;
9245 -> 9214;
9246 -> 9228;
9246 -> 9214;
9247 -> 9228;
9247 -> 9214;
9248 -> 9228;
9248 -> 9214;
9249 -> 9228;
9249 -> 9214;
9250 -> 9228;
9250 -> 9214;
9251 -> 9228;
9251 -> 9214;
9252 -> 9228;
9252 -> 9214;
9253 -> 9228;
9253 -> 9214;
9254 -> 9228;
9254 -> 9214;
9255 -> 9214;
9256 -> 9255;
9256 -> 9228;
9256 -> 9214;
9257 -> 9228;
9257 -> 9214;
9258 -> 9228;
9258 -> 9214;
9259 -> 9214;
9260 -> 9214;
9261 -> 9258;
9261 -> 9260;
9262 -> 9259;
9262 -> 9260;
9263 -> 9262;
9263 -> 9260;
9264 -> 9262;
9264 -> 9260;
9265 -> 9262;
9265 -> 9260;
9266 -> 9261;
9266 -> 9262;
9266 -> 9260;
9267 -> 9259;
9267 -> 9228;
9267 -> 9214;
9268 -> 9228;
9268 -> 9214;
9269 -> 9214;
9270 -> 9269;
9271 -> 0;
9271 -> 9269;
9272 -> 9271;
9272 -> 9270;
9272 -> 9269;
9273 -> 9272;
9273 -> 9214;
9274 -> 9273;
9274 -> 9228;
9274 -> 9214;
9275 -> 9218;
9275 -> 9214;
9276 -> 9275;
9277 -> 9215;
9277 -> 9276;
9277 -> 9275;
9278 -> 9216;
9278 -> 9276;
9278 -> 9275;
9279 -> 9277;
9279 -> 9278;
9279 -> 9275;
9280 -> 9217;
9280 -> 9276;
9280 -> 9275;
9281 -> 9279;
9281 -> 9280;
9281 -> 9275;
9282 -> 9220;
9282 -> 9214;
9283 -> 9282;
9284 -> 9228;
9284 -> 9283;
9285 -> 9219;
9285 -> 9282;
9286 -> 9221;
9286 -> 9228;
9286 -> 9214;
9287 -> 9228;
9287 -> 8912;
9287 -> 9214;
9288 -> 9214;
9289 -> 9228;
9289 -> 8912;
9289 -> 9288;
9289 -> 9214;
9290 -> 9168;
9291 -> 8912;
9292 -> 8912;
9293 -> 8912;
9294 -> 8912;
9295 -> 8912;
9296 -> 9292;
9296 -> 8912;
9297 -> 8912;
9298 -> 8912;
9299 -> 8912;
9300 -> 8912;
9301 -> 8912;
9302 -> 8912;
9303 -> 8912;
9304 -> 8912;
9305 -> 9302;
9305 -> 8912;
9306 -> 9303;
9306 -> 8912;
9307 -> 9304;
9307 -> 8912;
9308 -> 9305;
9308 -> 8912;
9309 -> 9306;
9309 -> 8912;
9310 -> 9307;
9310 -> 8912;
9311 -> 8912;
9312 -> 8912;
9313 -> 9312;
9314 -> 9308;
9314 -> 9313;
9314 -> 9312;
9315 -> 9309;
9315 -> 9313;
9315 -> 9312;
9316 -> 9314;
9316 -> 9315;
9316 -> 9312;
9317 -> 9310;
9317 -> 9313;
9317 -> 9312;
9318 -> 9316;
9318 -> 9317;
9318 -> 9312;
9319 -> 8912;
9320 -> 8912;
9321 -> 8912;
9322 -> 8912;
9322 -> 9168;
9323 -> 9110;
9324 -> 9323;
9325 -> 9324;
9326 -> 9325;
9327 -> 8912;
9328 -> 8912;
9329 -> 8912;
9330 -> 8912;
9331 -> 8912;
9332 -> 9331;
9332 -> 0;
9332 -> 8912;
9333 -> 8912;
9334 -> 8912;
9335 -> 8912;
9336 -> 8912;
9337 -> 8912;
9338 -> 8912;
9338 -> 9323;
9339 -> 9323;
9340 -> 0;
9340 -> 9323;
9341 -> 9115;
9341 -> 8912;
9341 -> 9110;
9342 -> 7442;
9343 -> 9342;
9344 -> 9342;
9345 -> 9343;
9345 -> 9344;
9346 -> 0;
9346 -> 9344;
9347 -> 9344;
9348 -> 9345;
9348 -> 9344;
9349 -> 9344;
9350 -> 9346;
9350 -> 9349;
9351 -> 9347;
9351 -> 9349;
9352 -> 9348;
9352 -> 9349;
9353 -> 9349;
9354 -> 9350;
9354 -> 9349;
9355 -> 9351;
9355 -> 9349;
9356 -> 9353;
9356 -> 9349;
9357 -> 9352;
9357 -> 9349;
9358 -> 9349;
9359 -> 9354;
9359 -> 9358;
9360 -> 9355;
9360 -> 9358;
9361 -> 9356;
9361 -> 9358;
9362 -> 9357;
9362 -> 9358;
9363 -> 9358;
9364 -> 9359;
9364 -> 0;
9364 -> 9358;
9365 -> 9364;
9365 -> 9360;
9365 -> 9358;
9366 -> 9365;
9367 -> 9366;
9368 -> 9367;
9369 -> 9365;
9370 -> 8912;
9371 -> 8912;
9372 -> 9365;
9373 -> 8912;
9374 -> 9359;
9374 -> 0;
9374 -> 9358;
9375 -> 9374;
9375 -> 9360;
9375 -> 9358;
9376 -> 9363;
9376 -> 9375;
9377 -> 9375;
9378 -> 9375;
9379 -> 9375;
9380 -> 8912;
9380 -> 9379;
9381 -> 9380;
9381 -> 9375;
9382 -> 9375;
9383 -> 8912;
9384 -> 9362;
9384 -> 9375;
9385 -> 9375;
9386 -> 9375;
9387 -> 9385;
9387 -> 9386;
9388 -> 9385;
9388 -> 9386;
9389 -> 9385;
9389 -> 9386;
9390 -> 9384;
9390 -> 9386;
9391 -> 9386;
9392 -> 9391;
9393 -> 9392;
9394 -> 9390;
9394 -> 9386;
9395 -> 9386;
9396 -> 9386;
9397 -> 9387;
9397 -> 9396;
9397 -> 9386;
9398 -> 9386;
9399 -> 9398;
9400 -> 9399;
9401 -> 8912;
9401 -> 9399;
9402 -> 9395;
9402 -> 9386;
9403 -> 9390;
9403 -> 9386;
9404 -> 9386;
9405 -> 9404;
9406 -> 9405;
9407 -> 9406;
9408 -> 9404;
9409 -> 9408;
9410 -> 9409;
9411 -> 9404;
9412 -> 9411;
9413 -> 8912;
9413 -> 9411;
9414 -> 8912;
9414 -> 9404;
9415 -> 9404;
9416 -> 8912;
9416 -> 9404;
9417 -> 8912;
9417 -> 9404;
9418 -> 9417;
9418 -> 8912;
9418 -> 9404;
9419 -> 9404;
9420 -> 9404;
9421 -> 8912;
9421 -> 9404;
9422 -> 9404;
9423 -> 8912;
9423 -> 9404;
9424 -> 9404;
9425 -> 9424;
9426 -> 9425;
9427 -> 9425;
9428 -> 9427;
9429 -> 9424;
9430 -> 9429;
9431 -> 9404;
9432 -> 9431;
9433 -> 9432;
9434 -> 9432;
9435 -> 9434;
9436 -> 9431;
9437 -> 9436;
9438 -> 8912;
9438 -> 9404;
9439 -> 9404;
9440 -> 8912;
9440 -> 0;
9440 -> 9404;
9441 -> 9404;
9442 -> 8912;
9442 -> 9404;
9443 -> 8912;
9443 -> 9404;
9444 -> 9404;
9445 -> 9444;
9446 -> 9445;
9447 -> 9446;
9448 -> 8912;
9448 -> 9446;
9449 -> 9444;
9450 -> 8912;
9450 -> 9404;
9451 -> 9404;
9452 -> 9387;
9452 -> 9386;
9453 -> 9452;
9454 -> 9452;
9455 -> 9386;
9456 -> 9389;
9456 -> 9455;
9456 -> 9386;
9457 -> 9387;
9457 -> 9386;
9458 -> 9388;
9458 -> 9386;
9459 -> 9390;
9459 -> 9386;
9460 -> 9386;
9461 -> 9457;
9461 -> 9460;
9462 -> 9458;
9462 -> 9460;
9463 -> 9459;
9463 -> 9460;
9464 -> 9460;
9465 -> 9461;
9465 -> 9464;
9465 -> 9460;
9466 -> 8912;
9467 -> 8912;
9468 -> 8912;
9468 -> 0;
9469 -> 8912;
9470 -> 8912;
9470 -> 0;
9471 -> 8912;
9471 -> 0;
9472 -> 8912;
9472 -> 0;
9473 -> 8912;
9473 -> 0;
9474 -> 8912;
9474 -> 0;
9475 -> 8912;
9475 -> 0;
9476 -> 8912;
9477 -> 8912;
9478 -> 8912;
9479 -> 8912;
9479 -> 0;
9480 -> 8912;
9481 -> 8912;
9482 -> 9480;
9482 -> 9481;
9483 -> 9482;
9483 -> 9481;
9484 -> 9483;
9485 -> 8912;
9486 -> 9485;
9486 -> 8912;
9487 -> 8912;
9488 -> 9487;
9488 -> 8912;
9489 -> 9478;
9489 -> 9488;
9490 -> 8912;
9491 -> 9489;
9491 -> 9490;
9491 -> 8912;
9492 -> 9491;
9492 -> 9485;
9492 -> 8912;
9493 -> 9485;
9493 -> 8912;
9494 -> 9484;
9494 -> 9493;
9495 -> 9484;
9495 -> 8912;
9496 -> 8912;
9496 -> 0;
9497 -> 8912;
9498 -> 8912;
9499 -> 8912;
9500 -> 9498;
9500 -> 9499;
9501 -> 9500;
9501 -> 9499;
9502 -> 9501;
9503 -> 8912;
9504 -> 9502;
9504 -> 9503;
9505 -> 8912;
9506 -> 8912;
9507 -> 9505;
9507 -> 9506;
9508 -> 8912;
9508 -> 9506;
9509 -> 9507;
9509 -> 8912;
9509 -> 0;
9509 -> 9506;
9510 -> 9509;
9511 -> 8912;
9512 -> 9498;
9512 -> 9511;
9513 -> 9512;
9513 -> 9511;
9514 -> 9513;
9515 -> 8912;
9516 -> 8912;
9517 -> 8912;
9518 -> 8912;
9518 -> 9460;
9519 -> 9375;
9520 -> 8912;
9520 -> 9519;
9520 -> 9375;
9521 -> 9359;
9521 -> 0;
9521 -> 9358;
9522 -> 9521;
9523 -> 9522;
9523 -> 9521;
9524 -> 9362;
9524 -> 9521;
9525 -> 9521;
9526 -> 9523;
9526 -> 9525;
9527 -> 9524;
9527 -> 9525;
9528 -> 9525;
9529 -> 9526;
9529 -> 9525;
9530 -> 9527;
9530 -> 9525;
9531 -> 9525;
9532 -> 9528;
9532 -> 9531;
9533 -> 9528;
9533 -> 9531;
9534 -> 9528;
9534 -> 9531;
9535 -> 9528;
9535 -> 9531;
9536 -> 9529;
9536 -> 9531;
9537 -> 9528;
9537 -> 9531;
9538 -> 9530;
9538 -> 9531;
9539 -> 9531;
9540 -> 8912;
9540 -> 9539;
9540 -> 9531;
9541 -> 9531;
9542 -> 9536;
9542 -> 9541;
9542 -> 9531;
9543 -> 9531;
9544 -> 8912;
9544 -> 9543;
9545 -> 9544;
9545 -> 9531;
9546 -> 9531;
9547 -> 9531;
9548 -> 9537;
9548 -> 9531;
9549 -> 9532;
9549 -> 9548;
9550 -> 9535;
9550 -> 9548;
9551 -> 9536;
9551 -> 9548;
9552 -> 9538;
9552 -> 9548;
9553 -> 9548;
9554 -> 9549;
9554 -> 9553;
9555 -> 9550;
9555 -> 9553;
9556 -> 9551;
9556 -> 9553;
9557 -> 9552;
9557 -> 9553;
9558 -> 9557;
9558 -> 9553;
9559 -> 9553;
9560 -> 9558;
9560 -> 9559;
9561 -> 9559;
9562 -> 8912;
9563 -> 8912;
9563 -> 9553;
9564 -> 9553;
9565 -> 9532;
9565 -> 9531;
9566 -> 9533;
9566 -> 9531;
9567 -> 9534;
9567 -> 9531;
9568 -> 9535;
9568 -> 9531;
9569 -> 9536;
9569 -> 9531;
9570 -> 9537;
9570 -> 9531;
9571 -> 9538;
9571 -> 9531;
9572 -> 9531;
9573 -> 9531;
9574 -> 9565;
9574 -> 9573;
9575 -> 9566;
9575 -> 9573;
9576 -> 9567;
9576 -> 9573;
9577 -> 9568;
9577 -> 9573;
9578 -> 9569;
9578 -> 9573;
9579 -> 9570;
9579 -> 9573;
9580 -> 9571;
9580 -> 9573;
9581 -> 9572;
9581 -> 9573;
9582 -> 9573;
9583 -> 9582;
9583 -> 9573;
9584 -> 9582;
9584 -> 9573;
9585 -> 9582;
9585 -> 9573;
9586 -> 9582;
9586 -> 9573;
9587 -> 9582;
9587 -> 9573;
9588 -> 9582;
9588 -> 9573;
9589 -> 9582;
9589 -> 9573;
9590 -> 9582;
9590 -> 9573;
9591 -> 9582;
9591 -> 9573;
9592 -> 9582;
9592 -> 9573;
9593 -> 9582;
9593 -> 9573;
9594 -> 9573;
9595 -> 8912;
9595 -> 9594;
9595 -> 9573;
9596 -> 9573;
9597 -> 9578;
9597 -> 9596;
9597 -> 9573;
9598 -> 9574;
9598 -> 9582;
9598 -> 9573;
9599 -> 9575;
9599 -> 9582;
9599 -> 9573;
9600 -> 9580;
9600 -> 9582;
9600 -> 9573;
9601 -> 9578;
9601 -> 9582;
9601 -> 9573;
9602 -> 9579;
9602 -> 9582;
9602 -> 9573;
9603 -> 9577;
9603 -> 9582;
9603 -> 9573;
9604 -> 9577;
9604 -> 9573;
9605 -> 9573;
9606 -> 9604;
9606 -> 9605;
9607 -> 9582;
9607 -> 9605;
9608 -> 9606;
9608 -> 9605;
9609 -> 9573;
9610 -> 9575;
9610 -> 9576;
9610 -> 9573;
9611 -> 9576;
9611 -> 9582;
9611 -> 9573;
9612 -> 9531;
9613 -> 9531;
9614 -> 9613;
9615 -> 9614;
9616 -> 9615;
9617 -> 8912;
9617 -> 9615;
9618 -> 9613;
9619 -> 9531;
9620 -> 9572;
9620 -> 9619;
9621 -> 8912;
9622 -> 8912;
9623 -> 8912;
9624 -> 9622;
9624 -> 9623;
9625 -> 9622;
9625 -> 9623;
9626 -> 9623;
9627 -> 9624;
9627 -> 9626;
9627 -> 9623;
9628 -> 8912;
9629 -> 8912;
9630 -> 9531;
9631 -> 9531;
9632 -> 9572;
9632 -> 9631;
9633 -> 9631;
9634 -> 8912;
9634 -> 9633;
9634 -> 9631;
9635 -> 9631;
9636 -> 9635;
9636 -> 9631;
9637 -> 9531;
9638 -> 9531;
9639 -> 9532;
9639 -> 9638;
9639 -> 9531;
9640 -> 9531;
9641 -> 9532;
9641 -> 9640;
9641 -> 9531;
9642 -> 9531;
9643 -> 9531;
9644 -> 9537;
9644 -> 9643;
9644 -> 9531;
9645 -> 9536;
9645 -> 9644;
9646 -> 9538;
9646 -> 9644;
9647 -> 9644;
9648 -> 9645;
9648 -> 9647;
9649 -> 9646;
9649 -> 9647;
9650 -> 9647;
9651 -> 9650;
9652 -> 9651;
9653 -> 8912;
9653 -> 9651;
9654 -> 9649;
9654 -> 9647;
9655 -> 9647;
9656 -> 9644;
9657 -> 9644;
9658 -> 9532;
9658 -> 9657;
9658 -> 9644;
9659 -> 9525;
9660 -> 9526;
9660 -> 9525;
9661 -> 9527;
9661 -> 9525;
9662 -> 9525;
9663 -> 9659;
9663 -> 9662;
9664 -> 9659;
9664 -> 9662;
9665 -> 9660;
9665 -> 9662;
9666 -> 9661;
9666 -> 9662;
9667 -> 9659;
9667 -> 9662;
9668 -> 9659;
9668 -> 9662;
9669 -> 9662;
9670 -> 9662;
9671 -> 9664;
9671 -> 9670;
9671 -> 9662;
9672 -> 9662;
9673 -> 9672;
9674 -> 8912;
9674 -> 9672;
9675 -> 9669;
9675 -> 9662;
9676 -> 9667;
9676 -> 9662;
9677 -> 9668;
9677 -> 9662;
9678 -> 9662;
9679 -> 9665;
9679 -> 9662;
9680 -> 9666;
9680 -> 9662;
9681 -> 9662;
9682 -> 9675;
9682 -> 9681;
9683 -> 9676;
9683 -> 9681;
9684 -> 9677;
9684 -> 9681;
9685 -> 9678;
9685 -> 9681;
9686 -> 9678;
9686 -> 9681;
9687 -> 9679;
9687 -> 9681;
9688 -> 9680;
9688 -> 9681;
9689 -> 9678;
9689 -> 9681;
9690 -> 9681;
9691 -> 9690;
9691 -> 9681;
9692 -> 9690;
9692 -> 9681;
9693 -> 9690;
9693 -> 9681;
9694 -> 9690;
9694 -> 9681;
9695 -> 9690;
9695 -> 9681;
9696 -> 9690;
9696 -> 9681;
9697 -> 9690;
9697 -> 9681;
9698 -> 9690;
9698 -> 9681;
9699 -> 9690;
9699 -> 9681;
9700 -> 9690;
9700 -> 9681;
9701 -> 9690;
9701 -> 9681;
9702 -> 9690;
9702 -> 9681;
9703 -> 9682;
9703 -> 9690;
9703 -> 9681;
9704 -> 9683;
9704 -> 9690;
9704 -> 9681;
9705 -> 9684;
9705 -> 9690;
9705 -> 9681;
9706 -> 9685;
9706 -> 9690;
9706 -> 9681;
9707 -> 9686;
9707 -> 9690;
9707 -> 9681;
9708 -> 9687;
9708 -> 9690;
9708 -> 9681;
9709 -> 9688;
9709 -> 9690;
9709 -> 9681;
9710 -> 9662;
9711 -> 9710;
9712 -> 8912;
9712 -> 9710;
9713 -> 9662;
9714 -> 8912;
9715 -> 8912;
9716 -> 8912;
9717 -> 9715;
9717 -> 9716;
9718 -> 8912;
9718 -> 9716;
9719 -> 9718;
9719 -> 8912;
9719 -> 9716;
9720 -> 9716;
9721 -> 9719;
9722 -> 8912;
9723 -> 8912;
9724 -> 9722;
9724 -> 9723;
9725 -> 8912;
9725 -> 9723;
9726 -> 9725;
9726 -> 8912;
9726 -> 9723;
9727 -> 9723;
9728 -> 9726;
9729 -> 8912;
9730 -> 8912;
9731 -> 8912;
9732 -> 9730;
9732 -> 9731;
9733 -> 8912;
9733 -> 9731;
9734 -> 9733;
9734 -> 8912;
9734 -> 9731;
9735 -> 9731;
9736 -> 9734;
9737 -> 8912;
9738 -> 8912;
9739 -> 8912;
9739 -> 9738;
9740 -> 8912;
9741 -> 9738;
9741 -> 9740;
9742 -> 9738;
9742 -> 9740;
9743 -> 8912;
9743 -> 9740;
9744 -> 9741;
9744 -> 9740;
9745 -> 9742;
9745 -> 9740;
9746 -> 9744;
9746 -> 9745;
9746 -> 9740;
9747 -> 9740;
9748 -> 9746;
9748 -> 9747;
9749 -> 9743;
9749 -> 9747;
9750 -> 9749;
9750 -> 8912;
9750 -> 9747;
9751 -> 9747;
9752 -> 9750;
9753 -> 9740;
9754 -> 8912;
9755 -> 8912;
9756 -> 8912;
9757 -> 8912;
9758 -> 9756;
9758 -> 9757;
9759 -> 8912;
9759 -> 9757;
9760 -> 9759;
9760 -> 8912;
9760 -> 9757;
9761 -> 9757;
9762 -> 9760;
9763 -> 8912;
9764 -> 8912;
9765 -> 9763;
9765 -> 9764;
9766 -> 8912;
9766 -> 9764;
9767 -> 9766;
9767 -> 8912;
9767 -> 9764;
9768 -> 9764;
9769 -> 9767;
9770 -> 8912;
9771 -> 8912;
9771 -> 9713;
9772 -> 8912;
9773 -> 8912;
9774 -> 8912;
9775 -> 8912;
9776 -> 8912;
9777 -> 8912;
9778 -> 0;
9778 -> 8912;
9779 -> 8912;
9780 -> 8912;
9781 -> 8912;
9782 -> 9781;
9782 -> 9778;
9782 -> 8912;
9783 -> 9782;
9783 -> 8912;
9784 -> 8912;
9785 -> 8912;
9786 -> 9780;
9786 -> 9785;
9786 -> 8912;
9787 -> 0;
9787 -> 9786;
9788 -> 8912;
9789 -> 9787;
9789 -> 0;
9789 -> 8912;
9790 -> 9783;
9790 -> 0;
9790 -> 9789;
9791 -> 9789;
9792 -> 8912;
9793 -> 9788;
9793 -> 8912;
9794 -> 9788;
9794 -> 8912;
9795 -> 9788;
9795 -> 8912;
9796 -> 9795;
9796 -> 9778;
9796 -> 9788;
9797 -> 9796;
9797 -> 9788;
9798 -> 9788;
9799 -> 9797;
9799 -> 0;
9799 -> 9789;
9800 -> 9788;
9801 -> 9788;
9802 -> 9788;
9803 -> 9788;
9804 -> 9788;
9805 -> 0;
9805 -> 9788;
9806 -> 9788;
9807 -> 9788;
9808 -> 9788;
9809 -> 9808;
9809 -> 9805;
9809 -> 9788;
9810 -> 9809;
9810 -> 9788;
9811 -> 9788;
9812 -> 9807;
9812 -> 9811;
9812 -> 9788;
9813 -> 0;
9813 -> 9812;
9814 -> 9813;
9814 -> 0;
9814 -> 9788;
9815 -> 9810;
9815 -> 0;
9815 -> 9814;
9816 -> 9814;
9817 -> 9788;
9818 -> 9788;
9819 -> 9788;
9820 -> 9788;
9821 -> 9788;
9822 -> 9820;
9822 -> 9821;
9823 -> 8912;
9823 -> 9821;
9824 -> 9823;
9824 -> 9788;
9824 -> 9821;
9825 -> 9821;
9826 -> 9824;
9827 -> 9788;
9828 -> 9788;
9829 -> 9788;
9830 -> 9828;
9830 -> 9829;
9831 -> 8912;
9831 -> 9829;
9832 -> 9831;
9832 -> 9788;
9832 -> 9829;
9833 -> 9829;
9834 -> 9832;
9835 -> 9662;
9836 -> 9678;
9836 -> 9788;
9836 -> 9835;
9836 -> 9662;
9837 -> 9669;
9837 -> 9662;
9838 -> 9662;
9839 -> 9667;
9839 -> 9838;
9839 -> 9662;
9840 -> 9839;
9841 -> 9840;
9842 -> 9841;
9843 -> 9788;
9844 -> 9788;
9845 -> 9788;
9846 -> 9525;
9847 -> 9526;
9847 -> 9525;
9848 -> 9527;
9848 -> 9525;
9849 -> 9525;
9850 -> 9846;
9850 -> 9849;
9851 -> 9847;
9851 -> 9849;
9852 -> 9848;
9852 -> 9849;
9853 -> 8912;
9853 -> 9849;
9854 -> 9849;
9855 -> 9853;
9855 -> 9788;
9855 -> 9854;
9855 -> 9849;
9856 -> 9850;
9856 -> 9849;
9857 -> 9849;
9858 -> 9856;
9858 -> 9857;
9859 -> 9853;
9859 -> 9857;
9860 -> 9857;
9861 -> 9859;
9861 -> 9788;
9861 -> 9860;
9861 -> 9857;
9862 -> 9849;
9863 -> 9521;
9864 -> 9522;
9864 -> 9521;
9865 -> 9361;
9865 -> 9358;
9866 -> 9363;
9866 -> 9358;
9867 -> 9362;
9867 -> 9358;
9868 -> 9358;
9869 -> 9349;
9870 -> 9342;
9871 -> 9870;
9872 -> 9871;
9873 -> 9871;
9874 -> 9872;
9874 -> 9873;
9875 -> 9873;
9876 -> 8912;
9876 -> 9875;
9876 -> 9873;
9877 -> 8912;
9877 -> 9873;
9878 -> 9877;
9878 -> 9788;
9878 -> 9873;
9879 -> 9873;
9880 -> 9788;
9880 -> 9879;
9880 -> 9873;
9881 -> 9873;
9882 -> 9873;
9883 -> 8912;
9883 -> 9882;
9884 -> 9882;
9885 -> 9882;
9886 -> 9788;
9886 -> 9882;
9887 -> 9886;
9887 -> 9882;
9888 -> 9885;
9888 -> 9887;
9889 -> 9888;
9889 -> 9884;
9889 -> 9882;
9890 -> 9888;
9890 -> 9884;
9890 -> 9882;
9891 -> 9890;
9891 -> 9882;
9892 -> 9883;
9892 -> 9882;
9893 -> 9892;
9893 -> 9788;
9893 -> 9882;
9894 -> 9883;
9894 -> 9882;
9895 -> 9894;
9895 -> 9788;
9895 -> 9882;
9896 -> 9882;
9897 -> 9883;
9897 -> 9896;
9898 -> 1850;
9898 -> 9896;
9899 -> 9896;
9900 -> 9897;
9900 -> 9896;
9901 -> 9900;
9901 -> 9788;
9901 -> 9896;
9902 -> 9896;
9903 -> 9902;
9903 -> 9882;
9904 -> 9903;
9905 -> 9904;
9906 -> 1850;
9906 -> 9904;
9907 -> 9882;
9908 -> 9907;
9908 -> 9882;
9909 -> 9882;
9910 -> 9882;
9911 -> 9907;
9911 -> 9910;
9911 -> 9908;
9911 -> 9882;
9912 -> 9882;
9913 -> 9883;
9913 -> 9882;
9914 -> 9913;
9914 -> 9788;
9914 -> 9882;
9915 -> 9907;
9915 -> 9882;
9916 -> 9912;
9916 -> 9882;
9917 -> 9882;
9918 -> 9915;
9918 -> 9917;
9919 -> 9916;
9919 -> 9917;
9920 -> 9919;
9920 -> 9912;
9920 -> 9917;
9921 -> 9917;
9922 -> 9921;
9922 -> 9920;
9922 -> 9917;
9923 -> 9882;
9924 -> 9882;
9925 -> 9907;
9925 -> 9924;
9925 -> 9911;
9925 -> 9882;
9926 -> 9882;
9927 -> 9882;
9928 -> 9882;
9929 -> 9927;
9929 -> 9928;
9929 -> 9882;
9930 -> 9882;
9931 -> 9907;
9931 -> 9930;
9931 -> 9925;
9931 -> 9882;
9932 -> 9912;
9932 -> 9882;
9933 -> 9926;
9933 -> 9882;
9934 -> 0;
9934 -> 9882;
9935 -> 9882;
9936 -> 9882;
9937 -> 9932;
9937 -> 9936;
9938 -> 9933;
9938 -> 9936;
9939 -> 9934;
9939 -> 9936;
9940 -> 9935;
9940 -> 9936;
9941 -> 9935;
9941 -> 9936;
9942 -> 9936;
9943 -> 9940;
9943 -> 9942;
9943 -> 9936;
9944 -> 9943;
9944 -> 9936;
9945 -> 9936;
9946 -> 9945;
9946 -> 9941;
9946 -> 9936;
9947 -> 9937;
9947 -> 9936;
9948 -> 9938;
9948 -> 9936;
9949 -> 9939;
9949 -> 9936;
9950 -> 9947;
9950 -> 9936;
9951 -> 9948;
9951 -> 9936;
9952 -> 9946;
9952 -> 9936;
9953 -> 9936;
9954 -> 9950;
9954 -> 9953;
9955 -> 9951;
9955 -> 9953;
9956 -> 9952;
9956 -> 9953;
9957 -> 8327;
9957 -> 9953;
9958 -> 9954;
9958 -> 9953;
9959 -> 9954;
9959 -> 9947;
9959 -> 9953;
9960 -> 9955;
9960 -> 9953;
9961 -> 9955;
9961 -> 9948;
9961 -> 9953;
9962 -> 9953;
9963 -> 9958;
9963 -> 9962;
9964 -> 9959;
9964 -> 9962;
9965 -> 9960;
9965 -> 9962;
9966 -> 9961;
9966 -> 9962;
9967 -> 9957;
9967 -> 9962;
9968 -> 9963;
9968 -> 9962;
9969 -> 9964;
9969 -> 9962;
9970 -> 9965;
9970 -> 9962;
9971 -> 9966;
9971 -> 9962;
9972 -> 9962;
9973 -> 9968;
9973 -> 9972;
9974 -> 9969;
9974 -> 9972;
9975 -> 9970;
9975 -> 9972;
9976 -> 9971;
9976 -> 9972;
9977 -> 9967;
9977 -> 9972;
9978 -> 9972;
9979 -> 9974;
9979 -> 9978;
9979 -> 9972;
9980 -> 9972;
9981 -> 9976;
9981 -> 9980;
9981 -> 9972;
9982 -> 9979;
9982 -> 9981;
9982 -> 9972;
9983 -> 9972;
9984 -> 9983;
9984 -> 9982;
9984 -> 9972;
9985 -> 9972;
9986 -> 9985;
9986 -> 9974;
9986 -> 9972;
9987 -> 9972;
9988 -> 9987;
9988 -> 9976;
9988 -> 9972;
9989 -> 9972;
9990 -> 9989;
9990 -> 9974;
9990 -> 9972;
9991 -> 9982;
9991 -> 9972;
9992 -> 9964;
9992 -> 9962;
9993 -> 9966;
9993 -> 9962;
9994 -> 9962;
9995 -> 9992;
9995 -> 9994;
9995 -> 9962;
9996 -> 9962;
9997 -> 9992;
9997 -> 9996;
9997 -> 9962;
9998 -> 9962;
9999 -> 9993;
9999 -> 9998;
9999 -> 9962;
10000 -> 9962;
10001 -> 10000;
10001 -> 9953;
10002 -> 9953;
10003 -> 10002;
10003 -> 9936;
10004 -> 9949;
10004 -> 10003;
10004 -> 9936;
10005 -> 9907;
10005 -> 10004;
10005 -> 9931;
10005 -> 9882;
10006 -> 9926;
10006 -> 9882;
10007 -> 9912;
10007 -> 9882;
10008 -> 9907;
10008 -> 10005;
10008 -> 9882;
10009 -> 10008;
10009 -> 9873;
10010 -> 9870;
10011 -> 9342;
10012 -> 8912;
10012 -> 9342;
10013 -> 9788;
10013 -> 9342;
10014 -> 9342;
10015 -> 10012;
10015 -> 10014;
10016 -> 10013;
10016 -> 10014;
10017 -> 10016;
10017 -> 10014;
10018 -> 9342;
}