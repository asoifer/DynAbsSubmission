digraph G {
0 [label="EXTERNAL"];
1 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 222127"];
2 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 222128"];
3 [label="param TypeTests(this) 222129"];
4 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 222130"];
5 [label="NullableAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 222131"];
6 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 222132"];
7 [label="NullableContextAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 222133"];
8 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 222134"];
9 [label="NullablePublicOnlyAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 222135"];
10 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 222136"];
11 [label="AllowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 222137"];
12 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 222138"];
13 [label="DisallowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 222139"];
14 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 222140"];
15 [label="MaybeNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 222141"];
16 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 222142"];
17 [label="MaybeNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 222143"];
18 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 222144"];
19 [label="NotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 222145"];
20 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 222146"];
21 [label="NotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 222147"];
22 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 222148"];
23 [label="MemberNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 222149"];
24 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 222150"];
25 [label="MemberNotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 222151"];
26 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 222152"];
27 [label="DoesNotReturnIfAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 222153"];
28 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 222154"];
29 [label="DoesNotReturnAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 222155"];
30 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 222156"];
31 [label="NotNullIfNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 222157"];
32 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 222158"];
33 [label="IsExternalInitTypeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 222159"];
34 [label="@'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 222160"];
35 [label="IAsyncDisposableDefinition = @'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 222161"];
36 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 222162"];
37 [label="AsyncStreamsTypes = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 222163"];
38 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 222164"];
39 [label="EnumeratorCancellationAttributeType = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 222165"];
40 [label="@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 222166"];
41 [label="NativeIntegerAttributeDefinition =\n@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 222167"];
42 [label="() => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic } 222168"];
43 [label="LazyThreadSafetyMode.PublicationOnly 222169"];
44 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 222170"];
45 [label="s_lazyDefaultVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 222171"];
46 [label="() => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic } 222172"];
47 [label="LazyThreadSafetyMode.PublicationOnly 222173"];
48 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 222174"];
49 [label="s_lazyLatestVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 222175"];
50 [label="RuntimeUtilities.IsCoreClrRuntime 222176"];
51 [label="'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 222177"];
52 [label="new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 222178"];
53 [label="RuntimeCorLibName = RuntimeUtilities.IsCoreClrRuntime\n            ? new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51')\n            : new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 222179"];
54 [label="() =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            } 222180"];
55 [label="LazyThreadSafetyMode.PublicationOnly 222181"];
56 [label="new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 222182"];
57 [label="s_winRtRefs = new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 222183"];
58 [label="() => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref } 222184"];
59 [label="LazyThreadSafetyMode.PublicationOnly 222185"];
60 [label="new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 222186"];
61 [label="s_portableRefsMinimal = new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 222187"];
62 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll') 222188"];
63 [label="LazyThreadSafetyMode.PublicationOnly 222189"];
64 [label="new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 222190"];
65 [label="s_systemCoreRef =\n            new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 222191"];
66 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll') 222192"];
67 [label="LazyThreadSafetyMode.PublicationOnly 222193"];
68 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222194"];
69 [label="s_systemCoreRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222195"];
70 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll') 222196"];
71 [label="LazyThreadSafetyMode.PublicationOnly 222197"];
72 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222198"];
73 [label="s_systemCoreRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222199"];
74 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll') 222200"];
75 [label="LazyThreadSafetyMode.PublicationOnly 222201"];
76 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222202"];
77 [label="s_systemWindowsFormsRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222203"];
78 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll') 222204"];
79 [label="LazyThreadSafetyMode.PublicationOnly 222205"];
80 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222206"];
81 [label="s_systemDrawingRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222207"];
82 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll') 222208"];
83 [label="LazyThreadSafetyMode.PublicationOnly 222209"];
84 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222210"];
85 [label="s_systemDataRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222211"];
86 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll') 222212"];
87 [label="LazyThreadSafetyMode.PublicationOnly 222213"];
88 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222214"];
89 [label="s_mscorlibRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222215"];
90 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll') 222216"];
91 [label="LazyThreadSafetyMode.PublicationOnly 222217"];
92 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222218"];
93 [label="s_mscorlibRefPortable = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222219"];
94 [label="() =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            } 222220"];
95 [label="LazyThreadSafetyMode.PublicationOnly 222221"];
96 [label="new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 222222"];
97 [label="s_aacorlibRef = new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 222223"];
98 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri') 222224"];
99 [label="LazyThreadSafetyMode.PublicationOnly 222225"];
100 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 222226"];
101 [label="s_mscorlibRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 222227"];
102 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll') 222228"];
103 [label="LazyThreadSafetyMode.PublicationOnly 222229"];
104 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222230"];
105 [label="s_mscorlibRef_silverlight = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222231"];
106 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll') 222232"];
107 [label="LazyThreadSafetyMode.PublicationOnly 222233"];
108 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222234"];
109 [label="s_desktopCSharpRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222235"];
110 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll') 222236"];
111 [label="LazyThreadSafetyMode.PublicationOnly 222237"];
112 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222238"];
113 [label="s_std20Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222239"];
114 [label="() => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll') 222240"];
115 [label="LazyThreadSafetyMode.PublicationOnly 222241"];
116 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222242"];
117 [label="s_46NetStandardFacade = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222243"];
118 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)') 222244"];
119 [label="LazyThreadSafetyMode.PublicationOnly 222245"];
120 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 222246"];
121 [label="s_systemDynamicRuntimeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 222247"];
122 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll') 222248"];
123 [label="LazyThreadSafetyMode.PublicationOnly 222249"];
124 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222250"];
125 [label="s_systemRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222251"];
126 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll') 222252"];
127 [label="LazyThreadSafetyMode.PublicationOnly 222253"];
128 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222254"];
129 [label="s_systemRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222255"];
130 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll') 222256"];
131 [label="LazyThreadSafetyMode.PublicationOnly 222257"];
132 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222258"];
133 [label="s_systemRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222259"];
134 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll') 222260"];
135 [label="LazyThreadSafetyMode.PublicationOnly 222261"];
136 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222262"];
137 [label="s_systemRef_v20 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222263"];
138 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll') 222264"];
139 [label="LazyThreadSafetyMode.PublicationOnly 222265"];
140 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222266"];
141 [label="s_systemXmlRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222267"];
142 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll') 222268"];
143 [label="LazyThreadSafetyMode.PublicationOnly 222269"];
144 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222270"];
145 [label="s_systemXmlLinqRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222271"];
146 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll') 222272"];
147 [label="LazyThreadSafetyMode.PublicationOnly 222273"];
148 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222274"];
149 [label="s_mscorlibFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222275"];
150 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll') 222276"];
151 [label="LazyThreadSafetyMode.PublicationOnly 222277"];
152 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222278"];
153 [label="s_systemRuntimeFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222279"];
154 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll') 222280"];
155 [label="LazyThreadSafetyMode.PublicationOnly 222281"];
156 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222282"];
157 [label="s_systemThreadingFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222283"];
158 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll') 222284"];
159 [label="LazyThreadSafetyMode.PublicationOnly 222285"];
160 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222286"];
161 [label="s_systemThreadingTasksFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222287"];
162 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll') 222288"];
163 [label="LazyThreadSafetyMode.PublicationOnly 222289"];
164 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222290"];
165 [label="s_mscorlibPP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222291"];
166 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll') 222292"];
167 [label="LazyThreadSafetyMode.PublicationOnly 222293"];
168 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222294"];
169 [label="s_systemRuntimePP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222295"];
170 [label="() => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll') 222296"];
171 [label="LazyThreadSafetyMode.PublicationOnly 222297"];
172 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222298"];
173 [label="s_FSharpTestLibraryRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 222299"];
174 [label="@'R:\\Invalid.dll' 222300"];
175 [label="fullPath: @'R:\\Invalid.dll' 222301"];
176 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 222302"];
177 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 222303"];
178 [label="InvalidRef = new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 222304"];
179 [label="MscorlibRef_v4_0_30316_17626 222305"];
180 [label="Net451.mscorlib 222306"];
181 [label="ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 222307"];
182 [label="s_scriptRefs = ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 222308"];
183 [label="'/*<bind>*/' 222309"];
184 [label="StartString = '/*<bind>*/' 222310"];
185 [label="'/*</bind>*/' 222311"];
186 [label="EndString = '/*</bind>*/' 222312"];
187 [label="@'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 222313"];
188 [label="SpanSource = @'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 222314"];
189 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 222315"];
190 [label="s_IAsyncEnumerable = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 222316"];
191 [label="param CSharpTestBase(this) 222317"];
192 [label="param CommonTestBase(this) 222318"];
193 [label="param TestBase(this) 222319"];
194 [label="_temp 222320"];
195 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 222321"];
196 [label="param ArrayTypeGetHashCode(this) 222322"];
197 [label="var text = @'public class A {\n    public uint[] AryField1;\n    static string[][] AryField2;\n    private sbyte[,,] AryField3;\n    A(){}\n'; 222323"];
198 [label="var compilation = CreateCompilation(text); 222324"];
199 [label="text 222325"];
200 [label="param operator(string source) 222326"];
201 [label="source 222327"];
202 [label="new CSharpTestSource(source) 222328"];
203 [label="param CSharpTestSource(object value) 222329"];
204 [label="param CSharpTestSource(this) 222330"];
205 [label="Value 222331"];
206 [label="var compilation = CreateCompilation(text); 222332"];
207 [label="var compilation = CreateCompilation(text); 222333"];
208 [label="CreateCompilation(text) 222334"];
209 [label="param CreateCompilation(CSharpTestSource source) 222335"];
210 [label="param CreateCompilation(IEnumerable<MetadataReference> references = null) 222336"];
211 [label="param CreateCompilation(CSharpCompilationOptions options = null) 222337"];
212 [label="param CreateCompilation(CSharpParseOptions parseOptions = null) 222338"];
213 [label="param CreateCompilation(TargetFramework targetFramework = TargetFramework.Standard) 222339"];
214 [label="param CreateCompilation(string assemblyName = '') 222340"];
215 [label="param CreateCompilation(string sourceFileName = '') 222341"];
216 [label="param CreateCompilation(bool skipUsesIsNullable = false) 222342"];
217 [label="source 222343"];
218 [label="targetFramework 222344"];
219 [label="references 222345"];
220 [label="TargetFrameworkUtil.GetReferences(targetFramework, references) 222346"];
221 [label="param GetReferences(TargetFramework tf) 222347"];
222 [label="param GetReferences(IEnumerable<MetadataReference> additionalReferences) 222348"];
223 [label="var references = GetReferences(tf); 222349"];
224 [label="GetReferences(tf) 222350"];
225 [label="param GetReferences(TargetFramework targetFramework) 222351"];
226 [label="targetFramework switch\n        {\n            TargetFramework.Empty => ImmutableArray<MetadataReference>.Empty,\n            TargetFramework.Mscorlib40 => Mscorlib40References,\n            TargetFramework.Mscorlib40Extended => Mscorlib40ExtendedReferences,\n            TargetFramework.Mscorlib40AndSystemCore => Mscorlib40andSystemCoreReferences,\n            TargetFramework.Mscorlib40AndVBRuntime => Mscorlib40andVBRuntimeReferences,\n            TargetFramework.Mscorlib45 => Mscorlib45References,\n            TargetFramework.Mscorlib45Extended => Mscorlib45ExtendedReferences,\n            TargetFramework.Mscorlib45AndCSharp => Mscorlib45AndCSharpReferences,\n            TargetFramework.Mscorlib45AndVBRuntime => Mscorlib45AndVBRuntimeReferences,\n            TargetFramework.Mscorlib46 => Mscorlib46References,\n            TargetFramework.Mscorlib46Extended => Mscorlib46ExtendedReferences,\n            TargetFramework.Mscorlib461 => Mscorlib46References,\n            TargetFramework.Mscorlib461Extended => Mscorlib461ExtendedReferences,\n            TargetFramework.NetStandard20 => NetStandard20References,\n            TargetFramework.NetCoreApp => NetCoreAppReferences,\n            TargetFramework.WinRT => WinRTReferences,\n            TargetFramework.Standard => StandardReferences,\n            TargetFramework.StandardLatest => StandardLatestReferences,\n            TargetFramework.StandardAndCSharp => StandardAndCSharpReferences,\n            TargetFramework.StandardAndVBRuntime => StandardAndVBRuntimeReferences,\n            TargetFramework.StandardCompat => StandardCompatReferences,\n            TargetFramework.DefaultVb => DefaultVbReferences,\n            TargetFramework.Minimal => MinimalReferences,\n            TargetFramework.MinimalAsync => MinimalAsyncReferences,\n            _ => throw new InvalidOperationException($'Unexpected target framework {targetFramework}'),\n        } 222352"];
227 [label="StandardReferences 222353"];
228 [label="RuntimeUtilities.IsCoreClrRuntime 222354"];
229 [label="Mscorlib46ExtendedReferences 222355"];
230 [label="ImmutableArray.Create<MetadataReference>(Net461.mscorlib, Net461.System, TestMetadata.Net461.SystemCore, TestBase.ValueTupleRef, Net461.SystemRuntime) 222356"];
231 [label="TestBase.ValueTupleRef 222357"];
232 [label="TestReferences.NetFx.ValueTuple.tuplelib 222358"];
233 [label="ImmutableArray.Create<MetadataReference>(Net461.mscorlib, Net461.System, TestMetadata.Net461.SystemCore, TestBase.ValueTupleRef, Net461.SystemRuntime) 222359"];
234 [label="RuntimeUtilities.IsCoreClrRuntime ? NetStandard20References : Mscorlib46ExtendedReferences 222360"];
235 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 222361"];
236 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 222362"];
237 [label="return references; 222363"];
238 [label="options 222364"];
239 [label="parseOptions 222365"];
240 [label="assemblyName 222366"];
241 [label="sourceFileName 222367"];
242 [label="skipUsesIsNullable 222368"];
243 [label="CreateEmptyCompilation(source, TargetFrameworkUtil.GetReferences(targetFramework, references), options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable) 222369"];
244 [label="param CreateEmptyCompilation(CSharpTestSource source) 222370"];
245 [label="param CreateEmptyCompilation(IEnumerable<MetadataReference> references = null) 222371"];
246 [label="param CreateEmptyCompilation(CSharpCompilationOptions options = null) 222372"];
247 [label="param CreateEmptyCompilation(CSharpParseOptions parseOptions = null) 222373"];
248 [label="param CreateEmptyCompilation(string assemblyName = '') 222374"];
249 [label="param CreateEmptyCompilation(string sourceFileName = '') 222375"];
250 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 222376"];
251 [label="source 222377"];
252 [label="references 222378"];
253 [label="options 222379"];
254 [label="parseOptions 222380"];
255 [label="assemblyName 222381"];
256 [label="sourceFileName 222382"];
257 [label="skipUsesIsNullable 222383"];
258 [label="null 222384"];
259 [label="experimentalFeature: null 222385"];
260 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 222386"];
261 [label="param CreateCompilationCore(CSharpTestSource source) 222387"];
262 [label="param CreateCompilationCore(IEnumerable<MetadataReference> references) 222388"];
263 [label="param CreateCompilationCore(CSharpCompilationOptions options) 222389"];
264 [label="param CreateCompilationCore(CSharpParseOptions parseOptions) 222390"];
265 [label="param CreateCompilationCore(string assemblyName) 222391"];
266 [label="param CreateCompilationCore(string sourceFileName) 222392"];
267 [label="param CreateCompilationCore(bool skipUsesIsNullable) 222393"];
268 [label="param CreateCompilationCore(MessageID? experimentalFeature) 222394"];
269 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 222395"];
270 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 222396"];
271 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 222397"];
272 [label="param GetSyntaxTrees(CSharpParseOptions parseOptions) 222398"];
273 [label="param GetSyntaxTrees(string sourceFileName = '') 222399"];
274 [label="param GetSyntaxTrees(this) 222400"];
275 [label="switch (Value)\n            {\n                case string source:\n                    return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) };\n                case string[] sources:\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return CSharpTestBase.Parse(parseOptions, sources);\n                case SyntaxTree tree:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return new[] { tree };\n                case SyntaxTree[] trees:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return trees;\n                case CSharpTestSource[] testSources:\n                    return testSources.SelectMany(s => s.GetSyntaxTrees(parseOptions, sourceFileName)).ToArray();\n                case null:\n                    return Array.Empty<SyntaxTree>();\n                default:\n                    throw new Exception($'Unexpected value: {Value}');\n            } 222401"];
276 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 222402"];
277 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 222403"];
278 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 222404"];
279 [label="CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) 222405"];
280 [label="param Parse(string text) 222406"];
281 [label="param Parse(string filename = '') 222407"];
282 [label="param Parse(CSharpParseOptions options = null) 222408"];
283 [label="param Parse(Encoding encoding = null) 222409"];
284 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 222410"];
285 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 222411"];
286 [label="kind: SourceCodeKind.Regular 222412"];
287 [label="documentationMode: DocumentationMode.Parse 222413"];
288 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 222414"];
289 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 222415"];
290 [label="Regular = new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 222416"];
291 [label="SourceCodeKind.Script 222417"];
292 [label="Regular.WithKind(SourceCodeKind.Script) 222418"];
293 [label="Script = Regular.WithKind(SourceCodeKind.Script) 222419"];
294 [label="LanguageVersion.CSharp6 222420"];
295 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp6) 222421"];
296 [label="Regular6 = Regular.WithLanguageVersion(LanguageVersion.CSharp6) 222422"];
297 [label="LanguageVersion.CSharp7 222423"];
298 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7) 222424"];
299 [label="Regular7 = Regular.WithLanguageVersion(LanguageVersion.CSharp7) 222425"];
300 [label="LanguageVersion.CSharp7_1 222426"];
301 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_1) 222427"];
302 [label="Regular7_1 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_1) 222428"];
303 [label="LanguageVersion.CSharp7_2 222429"];
304 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_2) 222430"];
305 [label="Regular7_2 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_2) 222431"];
306 [label="LanguageVersion.CSharp7_3 222432"];
307 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_3) 222433"];
308 [label="Regular7_3 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_3) 222434"];
309 [label="LanguageVersion.Default 222435"];
310 [label="Regular.WithLanguageVersion(LanguageVersion.Default) 222436"];
311 [label="RegularDefault = Regular.WithLanguageVersion(LanguageVersion.Default) 222437"];
312 [label="LanguageVersion.Preview 222438"];
313 [label="Regular.WithLanguageVersion(LanguageVersion.Preview) 222439"];
314 [label="RegularPreview = Regular.WithLanguageVersion(LanguageVersion.Preview) 222440"];
315 [label="LanguageVersion.CSharp8 222441"];
316 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp8) 222442"];
317 [label="Regular8 = Regular.WithLanguageVersion(LanguageVersion.CSharp8) 222443"];
318 [label="LanguageVersion.CSharp9 222444"];
319 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp9) 222445"];
320 [label="Regular9 = Regular.WithLanguageVersion(LanguageVersion.CSharp9) 222446"];
321 [label="DocumentationMode.Diagnose 222447"];
322 [label="Regular.WithDocumentationMode(DocumentationMode.Diagnose) 222448"];
323 [label="RegularWithDocumentationComments = Regular.WithDocumentationMode(DocumentationMode.Diagnose) 222449"];
324 [label="Regular 222450"];
325 [label="'UseLegacyStrongNameProvider' 222451"];
326 [label="Regular.WithFeature('UseLegacyStrongNameProvider') 222452"];
327 [label="param WithFeature(this CSharpParseOptions options) 222453"];
328 [label="param WithFeature(string feature) 222454"];
329 [label="param WithFeature(string value = 'true') 222455"];
330 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 222456"];
331 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 222457"];
332 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 222458"];
333 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 222459"];
334 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 222460"];
335 [label="new[] { new KeyValuePair<string, string>(feature, value) } 222461"];
336 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 222462"];
337 [label="RegularWithLegacyStrongName = Regular.WithFeature('UseLegacyStrongNameProvider') 222463"];
338 [label="MessageID.IDS_FeatureImprovedOverloadCandidates 222464"];
339 [label="MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() 222465"];
340 [label="1 222466"];
341 [label="MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1 222467"];
342 [label="Regular.WithLanguageVersion(MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1) 222468"];
343 [label="WithoutImprovedOverloadCandidates = Regular.WithLanguageVersion(MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1) 222469"];
344 [label="MessageID.IDS_FeatureCovariantReturnsForOverrides 222470"];
345 [label="MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion() 222471"];
346 [label="Regular.WithLanguageVersion(MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion()) 222472"];
347 [label="WithCovariantReturns = Regular.WithLanguageVersion(MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion()) 222473"];
348 [label="LanguageVersion.CSharp8 222474"];
349 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp8) 222475"];
350 [label="WithoutCovariantReturns = Regular.WithLanguageVersion(LanguageVersion.CSharp8) 222476"];
351 [label="RegularWithExtendedPartialMethods = RegularPreview 222477"];
352 [label="new SmallDictionary<string, string> { } 222478"];
353 [label="s_experimentalFeatures = new SmallDictionary<string, string> { } 222479"];
354 [label="kind: SourceCodeKind.Regular 222480"];
355 [label="documentationMode: DocumentationMode.None 222481"];
356 [label="languageVersion: LanguageVersion.Preview 222482"];
357 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview) 222483"];
358 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview) 222484"];
359 [label="s_experimentalFeatures 222485"];
360 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview).WithFeatures(s_experimentalFeatures) 222486"];
361 [label="ExperimentalParseOptions =\n            new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview).WithFeatures(s_experimentalFeatures) 222487"];
362 [label="new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } } 222488"];
363 [label="'testV7SwitchBinder' 222489"];
364 [label="'true' 222490"];
365 [label="new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } } 222491"];
366 [label="Regular6.WithFeatures(new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } }) 222492"];
367 [label="Regular6WithV7SwitchBinder = Regular6.WithFeatures(new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } }) 222493"];
368 [label="RegularWithoutRecursivePatterns = Regular7_3 222494"];
369 [label="RegularWithRecursivePatterns = Regular8 222495"];
370 [label="RegularWithoutPatternCombinators = Regular8 222496"];
371 [label="RegularWithPatternCombinators = RegularPreview 222497"];
372 [label="OutputKind.DynamicallyLinkedLibrary 222498"];
373 [label="OptimizationLevel.Release 222499"];
374 [label="CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Release) 222500"];
375 [label="param CreateTestOptions(OutputKind outputKind) 222501"];
376 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 222502"];
377 [label="param CreateTestOptions(bool allowUnsafe = false) 222503"];
378 [label="outputKind 222504"];
379 [label="optimizationLevel: optimizationLevel 222505"];
380 [label="warningLevel: Diagnostic.MaxWarningLevel 222506"];
381 [label="allowUnsafe: allowUnsafe 222507"];
382 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 222508"];
383 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 222509"];
384 [label="ReleaseDll = CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Release) 222510"];
385 [label="OutputKind.ConsoleApplication 222511"];
386 [label="OptimizationLevel.Release 222512"];
387 [label="CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Release) 222513"];
388 [label="param CreateTestOptions(OutputKind outputKind) 222514"];
389 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 222515"];
390 [label="param CreateTestOptions(bool allowUnsafe = false) 222516"];
391 [label="outputKind 222517"];
392 [label="optimizationLevel: optimizationLevel 222518"];
393 [label="warningLevel: Diagnostic.MaxWarningLevel 222519"];
394 [label="allowUnsafe: allowUnsafe 222520"];
395 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 222521"];
396 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 222522"];
397 [label="ReleaseExe = CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Release) 222523"];
398 [label="true 222524"];
399 [label="ReleaseDll.WithDebugPlusMode(true) 222525"];
400 [label="ReleaseDebugDll = ReleaseDll.WithDebugPlusMode(true) 222526"];
401 [label="true 222527"];
402 [label="ReleaseExe.WithDebugPlusMode(true) 222528"];
403 [label="ReleaseDebugExe = ReleaseExe.WithDebugPlusMode(true) 222529"];
404 [label="OutputKind.DynamicallyLinkedLibrary 222530"];
405 [label="OptimizationLevel.Debug 222531"];
406 [label="CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Debug) 222532"];
407 [label="param CreateTestOptions(OutputKind outputKind) 222533"];
408 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 222534"];
409 [label="param CreateTestOptions(bool allowUnsafe = false) 222535"];
410 [label="outputKind 222536"];
411 [label="optimizationLevel: optimizationLevel 222537"];
412 [label="warningLevel: Diagnostic.MaxWarningLevel 222538"];
413 [label="allowUnsafe: allowUnsafe 222539"];
414 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 222540"];
415 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 222541"];
416 [label="DebugDll = CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Debug) 222542"];
417 [label="OutputKind.ConsoleApplication 222543"];
418 [label="OptimizationLevel.Debug 222544"];
419 [label="CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Debug) 222545"];
420 [label="param CreateTestOptions(OutputKind outputKind) 222546"];
421 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 222547"];
422 [label="param CreateTestOptions(bool allowUnsafe = false) 222548"];
423 [label="outputKind 222549"];
424 [label="optimizationLevel: optimizationLevel 222550"];
425 [label="warningLevel: Diagnostic.MaxWarningLevel 222551"];
426 [label="allowUnsafe: allowUnsafe 222552"];
427 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 222553"];
428 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 222554"];
429 [label="DebugExe = CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Debug) 222555"];
430 [label="OutputKind.WindowsRuntimeMetadata 222556"];
431 [label="OptimizationLevel.Release 222557"];
432 [label="CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Release) 222558"];
433 [label="param CreateTestOptions(OutputKind outputKind) 222559"];
434 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 222560"];
435 [label="param CreateTestOptions(bool allowUnsafe = false) 222561"];
436 [label="outputKind 222562"];
437 [label="optimizationLevel: optimizationLevel 222563"];
438 [label="warningLevel: Diagnostic.MaxWarningLevel 222564"];
439 [label="allowUnsafe: allowUnsafe 222565"];
440 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 222566"];
441 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 222567"];
442 [label="ReleaseWinMD = CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Release) 222568"];
443 [label="OutputKind.WindowsRuntimeMetadata 222569"];
444 [label="OptimizationLevel.Debug 222570"];
445 [label="CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Debug) 222571"];
446 [label="param CreateTestOptions(OutputKind outputKind) 222572"];
447 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 222573"];
448 [label="param CreateTestOptions(bool allowUnsafe = false) 222574"];
449 [label="outputKind 222575"];
450 [label="optimizationLevel: optimizationLevel 222576"];
451 [label="warningLevel: Diagnostic.MaxWarningLevel 222577"];
452 [label="allowUnsafe: allowUnsafe 222578"];
453 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 222579"];
454 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 222580"];
455 [label="DebugWinMD = CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Debug) 222581"];
456 [label="OutputKind.NetModule 222582"];
457 [label="OptimizationLevel.Release 222583"];
458 [label="CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Release) 222584"];
459 [label="param CreateTestOptions(OutputKind outputKind) 222585"];
460 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 222586"];
461 [label="param CreateTestOptions(bool allowUnsafe = false) 222587"];
462 [label="outputKind 222588"];
463 [label="optimizationLevel: optimizationLevel 222589"];
464 [label="warningLevel: Diagnostic.MaxWarningLevel 222590"];
465 [label="allowUnsafe: allowUnsafe 222591"];
466 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 222592"];
467 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 222593"];
468 [label="ReleaseModule = CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Release) 222594"];
469 [label="OutputKind.NetModule 222595"];
470 [label="OptimizationLevel.Debug 222596"];
471 [label="CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Debug) 222597"];
472 [label="param CreateTestOptions(OutputKind outputKind) 222598"];
473 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 222599"];
474 [label="param CreateTestOptions(bool allowUnsafe = false) 222600"];
475 [label="outputKind 222601"];
476 [label="optimizationLevel: optimizationLevel 222602"];
477 [label="warningLevel: Diagnostic.MaxWarningLevel 222603"];
478 [label="allowUnsafe: allowUnsafe 222604"];
479 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 222605"];
480 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 222606"];
481 [label="DebugModule = CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Debug) 222607"];
482 [label="true 222608"];
483 [label="ReleaseDll.WithAllowUnsafe(true) 222609"];
484 [label="UnsafeReleaseDll = ReleaseDll.WithAllowUnsafe(true) 222610"];
485 [label="true 222611"];
486 [label="ReleaseExe.WithAllowUnsafe(true) 222612"];
487 [label="UnsafeReleaseExe = ReleaseExe.WithAllowUnsafe(true) 222613"];
488 [label="true 222614"];
489 [label="DebugDll.WithAllowUnsafe(true) 222615"];
490 [label="UnsafeDebugDll = DebugDll.WithAllowUnsafe(true) 222616"];
491 [label="true 222617"];
492 [label="DebugExe.WithAllowUnsafe(true) 222618"];
493 [label="UnsafeDebugExe = DebugExe.WithAllowUnsafe(true) 222619"];
494 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 222620"];
495 [label="ReleaseDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 222621"];
496 [label="SigningReleaseDll = ReleaseDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 222622"];
497 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 222623"];
498 [label="ReleaseExe.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 222624"];
499 [label="SigningReleaseExe = ReleaseExe.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 222625"];
500 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 222626"];
501 [label="ReleaseModule.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 222627"];
502 [label="SigningReleaseModule = ReleaseModule.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 222628"];
503 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 222629"];
504 [label="DebugDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 222630"];
505 [label="SigningDebugDll = DebugDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 222631"];
506 [label="DebugInformationFormat.Pdb 222632"];
507 [label="EmitOptions.Default.WithDebugInformationFormat(DebugInformationFormat.Pdb) 222633"];
508 [label="NativePdbEmit = EmitOptions.Default.WithDebugInformationFormat(DebugInformationFormat.Pdb) 222634"];
509 [label="options = TestOptions.Regular; 222635"];
510 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 222636"];
511 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 222637"];
512 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 222638"];
513 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 222639"];
514 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 222640"];
515 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 222641"];
516 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 222642"];
517 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 222643"];
518 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 222644"];
519 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 222645"];
520 [label="CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)) 222646"];
521 [label="param CheckSerializable(SyntaxTree tree) 222647"];
522 [label="var stream = new MemoryStream(); 222648"];
523 [label="var root = tree.GetRoot(); 222649"];
524 [label="var root = tree.GetRoot(); 222650"];
525 [label="root.SerializeTo(stream); 222651"];
526 [label="root.SerializeTo(stream); 222652"];
527 [label="root.SerializeTo(stream); 222653"];
528 [label="stream.Position = 0; 222654"];
529 [label="stream.Position 222655"];
530 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 222656"];
531 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 222657"];
532 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 222658"];
533 [label="return tree; 222659"];
534 [label="new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) } 222660"];
535 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 222661"];
536 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 222662"];
537 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 222663"];
538 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 222664"];
539 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 222665"];
540 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 222666"];
541 [label="hasTopLevelStatements 222667"];
542 [label="options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll; 222668"];
543 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 222669"];
544 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 222670"];
545 [label="Func<CSharpCompilation> createCompilationLambda = () => CSharpCompilation.Create(\n                assemblyName == '' ? GetUniqueName() : assemblyName,\n                syntaxTrees,\n                references,\n                options); 222671"];
546 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 222672"];
547 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 222673"];
548 [label="param ValidateIOperations(Func<Compilation> createCompilation) 222674"];
549 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 222675"];
550 [label="return; 222676"];
551 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 222677"];
552 [label="var compilation = createCompilationLambda(); 222678"];
553 [label="var compilation = createCompilationLambda(); 222679"];
554 [label="return Guid.NewGuid().ToString('D'); 222680"];
555 [label="var compilation = createCompilationLambda(); 222681"];
556 [label="OutputKind.ConsoleApplication 222682"];
557 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 222683"];
558 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 222684"];
559 [label="s_defaultOptions = new CSharpCompilationOptions(OutputKind.ConsoleApplication) 222685"];
560 [label="OutputKind.DynamicallyLinkedLibrary 222686"];
561 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 222687"];
562 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 222688"];
563 [label="true 222689"];
564 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 222690"];
565 [label="s_defaultSubmissionOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 222691"];
566 [label="param Create(string? assemblyName) 222692"];
567 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees = null) 222693"];
568 [label="param Create(IEnumerable<MetadataReference>? references = null) 222694"];
569 [label="param Create(CSharpCompilationOptions? options = null) 222695"];
570 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 222696"];
571 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 222697"];
572 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 222698"];
573 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 222699"];
574 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 222700"];
575 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 222701"];
576 [label="param Create(string? assemblyName) 222702"];
577 [label="param Create(CSharpCompilationOptions options) 222703"];
578 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees) 222704"];
579 [label="param Create(IEnumerable<MetadataReference>? references) 222705"];
580 [label="param Create(CSharpCompilation? previousSubmission) 222706"];
581 [label="param Create(Type? returnType) 222707"];
582 [label="param Create(Type? hostObjectType) 222708"];
583 [label="param Create(bool isSubmission) 222709"];
584 [label="RoslynDebug.Assert(options != null); 222710"];
585 [label="RoslynDebug.Assert(options != null); 222711"];
586 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 222712"];
587 [label="var validatedReferences = ValidateReferences<CSharpCompilationReference>(references); 222713"];
588 [label="var validatedReferences = ValidateReferences<CSharpCompilationReference>(references); 222714"];
589 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 222715"];
590 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 222716"];
591 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 222717"];
592 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 222718"];
593 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 222719"];
594 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 222720"];
595 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 222721"];
596 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 222722"];
597 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 222723"];
598 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 222724"];
599 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 222725"];
600 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 222726"];
601 [label="param CSharpCompilation(string? assemblyName) 222727"];
602 [label="param CSharpCompilation(CSharpCompilationOptions options) 222728"];
603 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 222729"];
604 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 222730"];
605 [label="param CSharpCompilation(Type? submissionReturnType) 222731"];
606 [label="param CSharpCompilation(Type? hostObjectType) 222732"];
607 [label="param CSharpCompilation(bool isSubmission) 222733"];
608 [label="param CSharpCompilation(ReferenceManager? referenceManager) 222734"];
609 [label="param CSharpCompilation(bool reuseReferenceManager) 222735"];
610 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 222736"];
611 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 222737"];
612 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 222738"];
613 [label="param CSharpCompilation(this) 222739"];
614 [label="assemblyName 222740"];
615 [label="options 222741"];
616 [label="references 222742"];
617 [label="previousSubmission 222743"];
618 [label="submissionReturnType 222744"];
619 [label="hostObjectType 222745"];
620 [label="isSubmission 222746"];
621 [label="referenceManager 222747"];
622 [label="reuseReferenceManager 222748"];
623 [label="syntaxAndDeclarations 222749"];
624 [label="syntaxAndDeclarations.ExternalSyntaxTrees 222750"];
625 [label="SyntaxTreeCommonFeatures(syntaxAndDeclarations.ExternalSyntaxTrees) 222751"];
626 [label="semanticModelProvider 222752"];
627 [label="eventQueue 222753"];
628 [label="param CSharpCompilation(this) 222754"];
629 [label="param CSharpCompilation(string? assemblyName) 222755"];
630 [label="param CSharpCompilation(CSharpCompilationOptions options) 222756"];
631 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 222757"];
632 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 222758"];
633 [label="param CSharpCompilation(Type? submissionReturnType) 222759"];
634 [label="param CSharpCompilation(Type? hostObjectType) 222760"];
635 [label="param CSharpCompilation(bool isSubmission) 222761"];
636 [label="param CSharpCompilation(ReferenceManager? referenceManager) 222762"];
637 [label="param CSharpCompilation(bool reuseReferenceManager) 222763"];
638 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 222764"];
639 [label="param CSharpCompilation(IReadOnlyDictionary<string, string> features) 222765"];
640 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 222766"];
641 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 222767"];
642 [label="param CSharpCompilation(this) 222768"];
643 [label="assemblyName 222769"];
644 [label="references 222770"];
645 [label="features 222771"];
646 [label="isSubmission 222772"];
647 [label="semanticModelProvider 222773"];
648 [label="eventQueue 222774"];
649 [label="param CSharpCompilation(this) 222775"];
650 [label="param CSharpCompilation(this) 222776"];
651 [label="_options 222777"];
652 [label="_globalImports 222778"];
653 [label="_previousSubmissionImports 222779"];
654 [label="_globalNamespaceAlias 222780"];
655 [label="_scriptClass 222781"];
656 [label="_lazyHostObjectTypeSymbol 222782"];
657 [label="_lazyImportInfos 222783"];
658 [label="_conversions 222784"];
659 [label="_anonymousTypeManager 222785"];
660 [label="_lazyGlobalNamespace 222786"];
661 [label="builtInOperators 222787"];
662 [label="_lazyAssemblySymbol 222788"];
663 [label="_referenceManager 222789"];
664 [label="_syntaxAndDeclarations 222790"];
665 [label="_lazyEntryPoint 222791"];
666 [label="_lazyEmitNullablePublicOnly 222792"];
667 [label="_lazyCompilationUnitCompletedTrees 222793"];
668 [label="NullableAnalysisData 222794"];
669 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 222795"];
670 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 222796"];
671 [label="_externAliasTargets 222797"];
672 [label="_moduleInitializerMethods 222798"];
673 [label="_binderFactories 222799"];
674 [label="_ignoreAccessibilityBinderFactories 222800"];
675 [label="_lazyDeclarationDiagnostics 222801"];
676 [label="_declarationDiagnosticsFrozen 222802"];
677 [label="new DiagnosticBag() 222803"];
678 [label="_additionalCodegenWarnings = new DiagnosticBag() 222804"];
679 [label="WellKnownMemberSignatureComparer 222805"];
680 [label="_lazyWellKnownTypes 222806"];
681 [label="_lazyWellKnownTypeMembers 222807"];
682 [label="_usesNullableAttributes 222808"];
683 [label="_needsGeneratedAttributes 222809"];
684 [label="_needsGeneratedAttributes_IsFrozen 222810"];
685 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 222811"];
686 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 222812"];
687 [label="new WellKnownMembersSignatureComparer(this) 222813"];
688 [label="param WellKnownMembersSignatureComparer(CSharpCompilation compilation) 222814"];
689 [label="param WellKnownMembersSignatureComparer(this) 222815"];
690 [label="new SpecialMembersSignatureComparer() 222816"];
691 [label="param SpecialMembersSignatureComparer(this) 222817"];
692 [label="Instance = new SpecialMembersSignatureComparer() 222818"];
693 [label="param WellKnownMembersSignatureComparer(this) 222819"];
694 [label="param SpecialMembersSignatureComparer(this) 222820"];
695 [label="param SpecialMembersSignatureComparer(this) 222821"];
696 [label="_compilation 222822"];
697 [label="_compilation 222823"];
698 [label="WellKnownMemberSignatureComparer 222824"];
699 [label="_options 222825"];
700 [label="this.builtInOperators = new BuiltInOperators(this); 222826"];
701 [label="this.builtInOperators = new BuiltInOperators(this); 222827"];
702 [label="this.builtInOperators 222828"];
703 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 222829"];
704 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 222830"];
705 [label="_scriptClass 222831"];
706 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 222832"];
707 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 222833"];
708 [label="_globalImports 222834"];
709 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 222835"];
710 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 222836"];
711 [label="_previousSubmissionImports 222837"];
712 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 222838"];
713 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 222839"];
714 [label="_globalNamespaceAlias 222840"];
715 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 222841"];
716 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 222842"];
717 [label="new AnonymousTypeManager(this) 222843"];
718 [label="param AnonymousTypeManager(CSharpCompilation compilation) 222844"];
719 [label="param AnonymousTypeManager(this) 222845"];
720 [label="param AnonymousTypeManager(this) 222846"];
721 [label="public CSharpCompilation Compilation { get; } 222847"];
722 [label="_lazyAnonymousTypeTemplates 222848"];
723 [label="_lazySynthesizedDelegates 222849"];
724 [label="new ConcurrentDictionary<Location, bool>() 222850"];
725 [label="_sourceLocationsSeen = new ConcurrentDictionary<Location, bool>() 222851"];
726 [label="Debug.Assert(compilation != null); 222852"];
727 [label="Debug.Assert(compilation != null); 222853"];
728 [label="this.Compilation 222854"];
729 [label="_anonymousTypeManager 222855"];
730 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 222856"];
731 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 222857"];
732 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 222858"];
733 [label="LanguageVersion? result = null; 222859"];
734 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 222860"];
735 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 222861"];
736 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 222862"];
737 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 222863"];
738 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 222864"];
739 [label="this.LanguageVersion 222865"];
740 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 222866"];
741 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 222867"];
742 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 222868"];
743 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 222869"];
744 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 222870"];
745 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 222871"];
746 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 222872"];
747 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 222873"];
748 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 222874"];
749 [label="this.Options 222875"];
750 [label="get\n            {\n                return _options;\n            } 222876"];
751 [label="return _options; 222877"];
752 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 222878"];
753 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 222879"];
754 [label="new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata) 222880"];
755 [label="param ReferenceManager(string simpleAssemblyName) 222881"];
756 [label="param ReferenceManager(AssemblyIdentityComparer identityComparer) 222882"];
757 [label="param ReferenceManager(Dictionary<MetadataReference, MetadataOrDiagnostic>? observedMetadata) 222883"];
758 [label="param ReferenceManager(this) 222884"];
759 [label="simpleAssemblyName 222885"];
760 [label="identityComparer 222886"];
761 [label="observedMetadata 222887"];
762 [label="param ReferenceManager(this) 222888"];
763 [label="param ReferenceManager(this) 222889"];
764 [label="_referenceManager 222890"];
765 [label="_syntaxAndDeclarations 222891"];
766 [label="Debug.Assert(_lazyAssemblySymbol is null); 222892"];
767 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 222893"];
768 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 222894"];
769 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 222895"];
770 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 222896"];
771 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 222897"];
772 [label="compilation.AddSyntaxTrees(syntaxTrees) 222898"];
773 [label="param AddSyntaxTrees(IEnumerable<SyntaxTree> trees) 222899"];
774 [label="param AddSyntaxTrees(this) 222900"];
775 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 222901"];
776 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 222902"];
777 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 222903"];
778 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 222904"];
779 [label="var externalSyntaxTrees = PooledHashSet<SyntaxTree>.GetInstance(); 222905"];
780 [label="var syntaxAndDeclarations = _syntaxAndDeclarations; 222906"];
781 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 222907"];
782 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 222908"];
783 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 222909"];
784 [label="bool reuseReferenceManager = true; 222910"];
785 [label="int i = 0; 222911"];
786 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 222912"];
787 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 222913"];
788 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 222914"];
789 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 222915"];
790 [label="if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                } 222916"];
791 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 222917"];
792 [label="externalSyntaxTrees.Add(tree); 222918"];
793 [label="externalSyntaxTrees.Add(tree); 222919"];
794 [label="reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives; 222920"];
795 [label="i++; 222921"];
796 [label="externalSyntaxTrees.Free(); 222922"];
797 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 222923"];
798 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 222924"];
799 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 222925"];
800 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 222926"];
801 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 222927"];
802 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 222928"];
803 [label="Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations) 222929"];
804 [label="param Update(ReferenceManager referenceManager) 222930"];
805 [label="param Update(bool reuseReferenceManager) 222931"];
806 [label="param Update(SyntaxAndDeclarationManager syntaxAndDeclarations) 222932"];
807 [label="param Update(this) 222933"];
808 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 222934"];
809 [label="this.PreviousSubmission 222935"];
810 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 222936"];
811 [label="ScriptCompilationInfo 222937"];
812 [label="ScriptCompilationInfo?.PreviousScriptCompilation 222938"];
813 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 222939"];
814 [label="this.SubmissionReturnType 222940"];
815 [label="=> ScriptCompilationInfo 222941"];
816 [label="ScriptCompilationInfo 222942"];
817 [label="this.HostObjectType 222943"];
818 [label="=> ScriptCompilationInfo 222944"];
819 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 222945"];
820 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 222946"];
821 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 222947"];
822 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 222948"];
823 [label="new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider) 222949"];
824 [label="param CSharpCompilation(string? assemblyName) 222950"];
825 [label="param CSharpCompilation(CSharpCompilationOptions options) 222951"];
826 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 222952"];
827 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 222953"];
828 [label="param CSharpCompilation(Type? submissionReturnType) 222954"];
829 [label="param CSharpCompilation(Type? hostObjectType) 222955"];
830 [label="param CSharpCompilation(bool isSubmission) 222956"];
831 [label="param CSharpCompilation(ReferenceManager? referenceManager) 222957"];
832 [label="param CSharpCompilation(bool reuseReferenceManager) 222958"];
833 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 222959"];
834 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 222960"];
835 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 222961"];
836 [label="param CSharpCompilation(this) 222962"];
837 [label="previousSubmission 222963"];
838 [label="submissionReturnType 222964"];
839 [label="hostObjectType 222965"];
840 [label="syntaxAndDeclarations.ExternalSyntaxTrees 222966"];
841 [label="eventQueue 222967"];
842 [label="param CSharpCompilation(this) 222968"];
843 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 222969"];
844 [label="param CSharpCompilation(Type? submissionReturnType) 222970"];
845 [label="param CSharpCompilation(Type? hostObjectType) 222971"];
846 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 222972"];
847 [label="param CSharpCompilation(this) 222973"];
848 [label="eventQueue 222974"];
849 [label="param CSharpCompilation(this) 222975"];
850 [label="_options 222976"];
851 [label="_globalImports 222977"];
852 [label="_previousSubmissionImports 222978"];
853 [label="_globalNamespaceAlias 222979"];
854 [label="_scriptClass 222980"];
855 [label="_lazyHostObjectTypeSymbol 222981"];
856 [label="_lazyImportInfos 222982"];
857 [label="_conversions 222983"];
858 [label="_anonymousTypeManager 222984"];
859 [label="_lazyGlobalNamespace 222985"];
860 [label="builtInOperators 222986"];
861 [label="_lazyAssemblySymbol 222987"];
862 [label="_referenceManager 222988"];
863 [label="_syntaxAndDeclarations 222989"];
864 [label="_lazyEntryPoint 222990"];
865 [label="_lazyEmitNullablePublicOnly 222991"];
866 [label="_lazyCompilationUnitCompletedTrees 222992"];
867 [label="NullableAnalysisData 222993"];
868 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 222994"];
869 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 222995"];
870 [label="_externAliasTargets 222996"];
871 [label="_moduleInitializerMethods 222997"];
872 [label="_binderFactories 222998"];
873 [label="_ignoreAccessibilityBinderFactories 222999"];
874 [label="_lazyDeclarationDiagnostics 223000"];
875 [label="_declarationDiagnosticsFrozen 223001"];
876 [label="new DiagnosticBag() 223002"];
877 [label="_additionalCodegenWarnings = new DiagnosticBag() 223003"];
878 [label="WellKnownMemberSignatureComparer 223004"];
879 [label="_lazyWellKnownTypes 223005"];
880 [label="_lazyWellKnownTypeMembers 223006"];
881 [label="_usesNullableAttributes 223007"];
882 [label="_needsGeneratedAttributes 223008"];
883 [label="_needsGeneratedAttributes_IsFrozen 223009"];
884 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 223010"];
885 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 223011"];
886 [label="new WellKnownMembersSignatureComparer(this) 223012"];
887 [label="param WellKnownMembersSignatureComparer(CSharpCompilation compilation) 223013"];
888 [label="param WellKnownMembersSignatureComparer(this) 223014"];
889 [label="param WellKnownMembersSignatureComparer(this) 223015"];
890 [label="param SpecialMembersSignatureComparer(this) 223016"];
891 [label="param SpecialMembersSignatureComparer(this) 223017"];
892 [label="_compilation 223018"];
893 [label="_compilation 223019"];
894 [label="WellKnownMemberSignatureComparer 223020"];
895 [label="this.builtInOperators = new BuiltInOperators(this); 223021"];
896 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 223022"];
897 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 223023"];
898 [label="new AnonymousTypeManager(this) 223024"];
899 [label="param AnonymousTypeManager(CSharpCompilation compilation) 223025"];
900 [label="param AnonymousTypeManager(this) 223026"];
901 [label="param AnonymousTypeManager(this) 223027"];
902 [label="public CSharpCompilation Compilation { get; } 223028"];
903 [label="_lazyAnonymousTypeTemplates 223029"];
904 [label="_lazySynthesizedDelegates 223030"];
905 [label="new ConcurrentDictionary<Location, bool>() 223031"];
906 [label="_sourceLocationsSeen = new ConcurrentDictionary<Location, bool>() 223032"];
907 [label="Debug.Assert(compilation != null); 223033"];
908 [label="Debug.Assert(compilation != null); 223034"];
909 [label="this.Compilation 223035"];
910 [label="_anonymousTypeManager 223036"];
911 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 223037"];
912 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 223038"];
913 [label="LanguageVersion? result = null; 223039"];
914 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 223040"];
915 [label="var version = ((CSharpParseOptions)tree.Options).LanguageVersion; 223041"];
916 [label="if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                } 223042"];
917 [label="result = version; 223043"];
918 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 223044"];
919 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 223045"];
920 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 223046"];
921 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 223047"];
922 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 223048"];
923 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 223049"];
924 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 223050"];
925 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 223051"];
926 [label="referenceManager.AssertCanReuseForCompilation(this); 223052"];
927 [label="referenceManager.AssertCanReuseForCompilation(this); 223053"];
928 [label="_referenceManager 223054"];
929 [label="Debug.Assert(_lazyAssemblySymbol is null); 223055"];
930 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 223056"];
931 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 223057"];
932 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 223058"];
933 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 223059"];
934 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 223060"];
935 [label="return compilation; 223061"];
936 [label="var compilation = createCompilationLambda(); 223062"];
937 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 223063"];
938 [label="IsNullableEnabled(compilation) 223064"];
939 [label="param IsNullableEnabled(CSharpCompilation compilation) 223065"];
940 [label="compilation.SyntaxTrees 223066"];
941 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 223067"];
942 [label="return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; 223068"];
943 [label="var trees = compilation.SyntaxTrees; 223069"];
944 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 223070"];
945 [label="var options = (CSharpParseOptions)trees[0].Options; 223071"];
946 [label="var options = (CSharpParseOptions)trees[0].Options; 223072"];
947 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 223073"];
948 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 223074"];
949 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 223075"];
950 [label="return compilation; 223076"];
951 [label="compilation.SourceModule 223077"];
952 [label="get\n            {\n                return Assembly.Modules[0];\n            } 223078"];
953 [label="Assembly 223079"];
954 [label="get\n            {\n                return SourceAssembly;\n            } 223080"];
955 [label="SourceAssembly 223081"];
956 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 223082"];
957 [label="GetBoundReferenceManager() 223083"];
958 [label="param GetBoundReferenceManager(this) 223084"];
959 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 223085"];
960 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 223086"];
961 [label="_referenceManager.CreateSourceAssemblyForCompilation(this) 223087"];
962 [label="param CreateSourceAssemblyForCompilation(CSharpCompilation compilation) 223088"];
963 [label="param CreateSourceAssemblyForCompilation(this) 223089"];
964 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 223090"];
965 [label="CreateAndSetSourceAssemblyFullBind(compilation) 223091"];
966 [label="param CreateAndSetSourceAssemblyFullBind(CSharpCompilation compilation) 223092"];
967 [label="param CreateAndSetSourceAssemblyFullBind(this) 223093"];
968 [label="var resolutionDiagnostics = DiagnosticBag.GetInstance(); 223094"];
969 [label="var assemblyReferencesBySimpleName = PooledDictionary<string, List<ReferencedAssemblyIdentity>>.GetInstance(); 223095"];
970 [label="compilation.Options 223096"];
971 [label="get\n            {\n                return _options;\n            } 223097"];
972 [label="bool supersedeLowerVersions = compilation.Options.ReferencesSupersedeLowerVersions; 223098"];
973 [label="IDictionary<(string, string), MetadataReference>? boundReferenceDirectiveMap; 223099"];
974 [label="ImmutableArray<MetadataReference> boundReferenceDirectives; 223100"];
975 [label="boundReferenceDirectives 223101"];
976 [label="ImmutableArray<AssemblyData> referencedAssemblies; 223102"];
977 [label="referencedAssemblies 223103"];
978 [label="ImmutableArray<PEModule> modules; 223104"];
979 [label="modules 223105"];
980 [label="ImmutableArray<MetadataReference> explicitReferences; 223106"];
981 [label="explicitReferences 223107"];
982 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 223108"];
983 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 223109"];
984 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 223110"];
985 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 223111"];
986 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 223112"];
987 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 223113"];
988 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 223114"];
989 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 223115"];
990 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 223116"];
991 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 223117"];
992 [label="get { return this.Declarations.ReferenceDirectives; } 223118"];
993 [label="this.Declarations 223119"];
994 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 223120"];
995 [label="return _syntaxAndDeclarations.GetLazyState().DeclarationTable; 223121"];
996 [label="return this.Declarations.ReferenceDirectives; 223122"];
997 [label="SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 223123"];
998 [label="SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 223124"];
999 [label="SymbolDisplayCompilerInternalOptions.None 223125"];
1000 [label="SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier)\n                .WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.None) 223126"];
1001 [label="s_debuggerDisplayFormat =\n            SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier)\n                .WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.None) 223127"];
1002 [label="this.Declarations.ReferenceDirectives 223128"];
1003 [label="param ReportErrorIfHasConstraints(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) 223129"];
1004 [label="param ReportErrorIfHasConstraints(DiagnosticBag diagnostics) 223130"];
1005 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 223131"];
1006 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 223132"];
1007 [label="param ToDeclarationModifiers(this SyntaxTokenList modifiers) 223133"];
1008 [label="param ToDeclarationModifiers(DiagnosticBag diagnostics) 223134"];
1009 [label="var result = DeclarationModifiers.None; 223135"];
1010 [label="bool seenNoDuplicates = true; 223136"];
1011 [label="bool seenNoAccessibilityDuplicates = true; 223137"];
1012 [label="foreach (var modifier in modifiers)\n            {\n                DeclarationModifiers one = ToDeclarationModifier(modifier.ContextualKind());\n\n                ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics);\n\n                result |= one;\n            } 223138"];
1013 [label="DeclarationModifiers one = ToDeclarationModifier(modifier.ContextualKind()); 223139"];
1014 [label="ToDeclarationModifier(modifier.ContextualKind()) 223140"];
1015 [label="param ToDeclarationModifier(SyntaxKind kind) 223141"];
1016 [label="switch (kind)\n            {\n                case SyntaxKind.AbstractKeyword:\n                    return DeclarationModifiers.Abstract;\n                case SyntaxKind.AsyncKeyword:\n                    return DeclarationModifiers.Async;\n                case SyntaxKind.SealedKeyword:\n                    return DeclarationModifiers.Sealed;\n                case SyntaxKind.StaticKeyword:\n                    return DeclarationModifiers.Static;\n                case SyntaxKind.NewKeyword:\n                    return DeclarationModifiers.New;\n                case SyntaxKind.PublicKeyword:\n                    return DeclarationModifiers.Public;\n                case SyntaxKind.ProtectedKeyword:\n                    return DeclarationModifiers.Protected;\n                case SyntaxKind.InternalKeyword:\n                    return DeclarationModifiers.Internal;\n                case SyntaxKind.PrivateKeyword:\n                    return DeclarationModifiers.Private;\n                case SyntaxKind.ExternKeyword:\n                    return DeclarationModifiers.Extern;\n                case SyntaxKind.ReadOnlyKeyword:\n                    return DeclarationModifiers.ReadOnly;\n                case SyntaxKind.PartialKeyword:\n                    return DeclarationModifiers.Partial;\n                case SyntaxKind.UnsafeKeyword:\n                    return DeclarationModifiers.Unsafe;\n                case SyntaxKind.VirtualKeyword:\n                    return DeclarationModifiers.Virtual;\n                case SyntaxKind.OverrideKeyword:\n                    return DeclarationModifiers.Override;\n                case SyntaxKind.ConstKeyword:\n                    return DeclarationModifiers.Const;\n                case SyntaxKind.FixedKeyword:\n                    return DeclarationModifiers.Fixed;\n                case SyntaxKind.VolatileKeyword:\n                    return DeclarationModifiers.Volatile;\n                case SyntaxKind.RefKeyword:\n                    return DeclarationModifiers.Ref;\n                case SyntaxKind.DataKeyword:\n                    return DeclarationModifiers.Data;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 223142"];
1017 [label="return DeclarationModifiers.Public; 223143"];
1018 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 223144"];
1019 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 223145"];
1020 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 223146"];
1021 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 223147"];
1022 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 223148"];
1023 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 223149"];
1024 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics) 223150"];
1025 [label="param ReportDuplicateModifiers(SyntaxToken modifierToken) 223151"];
1026 [label="param ReportDuplicateModifiers(DeclarationModifiers modifierKind) 223152"];
1027 [label="param ReportDuplicateModifiers(DeclarationModifiers allModifiers) 223153"];
1028 [label="param ReportDuplicateModifiers(ref bool seenNoDuplicates) 223154"];
1029 [label="param ReportDuplicateModifiers(ref bool seenNoAccessibilityDuplicates) 223155"];
1030 [label="param ReportDuplicateModifiers(DiagnosticBag diagnostics) 223156"];
1031 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 223157"];
1032 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 223158"];
1033 [label="result |= one; 223159"];
1034 [label="switch (result & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.Protected | DeclarationModifiers.Internal:\n                    // the two keywords 'protected' and 'internal' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.ProtectedInternal;\n                    break;\n\n                case DeclarationModifiers.Private | DeclarationModifiers.Protected:\n                    // the two keywords 'private' and 'protected' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.PrivateProtected;\n                    break;\n            } 223160"];
1035 [label="return result; 223161"];
1036 [label="get { return _options; } 223162"];
1037 [label="return _options; 223163"];
1038 [label="get { return CSharp.MessageProvider.Instance; } 223164"];
1039 [label="return CSharp.MessageProvider.Instance; 223165"];
1040 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 223166"];
1041 [label="param CreateAssemblyDataForFile(PEAssembly assembly) 223167"];
1042 [label="param CreateAssemblyDataForFile(WeakList<IAssemblySymbolInternal> cachedSymbols) 223168"];
1043 [label="param CreateAssemblyDataForFile(DocumentationProvider documentationProvider) 223169"];
1044 [label="param CreateAssemblyDataForFile(string sourceAssemblySimpleName) 223170"];
1045 [label="param CreateAssemblyDataForFile(MetadataImportOptions importOptions) 223171"];
1046 [label="param CreateAssemblyDataForFile(bool embedInteropTypes) 223172"];
1047 [label="param CreateAssemblyDataForFile(this) 223173"];
1048 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 223174"];
1049 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 223175"];
1050 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 223176"];
1051 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 223177"];
1052 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 223178"];
1053 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 223179"];
1054 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 223180"];
1055 [label="new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions) 223181"];
1056 [label="param AssemblyDataForFile(PEAssembly assembly) 223182"];
1057 [label="param AssemblyDataForFile(WeakList<IAssemblySymbolInternal> cachedSymbols) 223183"];
1058 [label="param AssemblyDataForFile(bool embedInteropTypes) 223184"];
1059 [label="param AssemblyDataForFile(DocumentationProvider documentationProvider) 223185"];
1060 [label="param AssemblyDataForFile(string sourceAssemblySimpleName) 223186"];
1061 [label="param AssemblyDataForFile(MetadataImportOptions compilationImportOptions) 223187"];
1062 [label="param AssemblyDataForFile(this) 223188"];
1063 [label="assembly.Identity 223189"];
1064 [label="assembly.AssemblyReferences 223190"];
1065 [label="embedInteropTypes 223191"];
1066 [label="param AssemblyDataForFile(this) 223192"];
1067 [label="param AssemblyDataForMetadataOrCompilation(AssemblyIdentity identity) 223193"];
1068 [label="param AssemblyDataForMetadataOrCompilation(ImmutableArray<AssemblyIdentity> referencedAssemblies) 223194"];
1069 [label="param AssemblyDataForMetadataOrCompilation(bool embedInteropTypes) 223195"];
1070 [label="param AssemblyDataForMetadataOrCompilation(this) 223196"];
1071 [label="param AssemblyDataForMetadataOrCompilation(this) 223197"];
1072 [label="_assemblies 223198"];
1073 [label="_identity 223199"];
1074 [label="_embedInteropTypes 223200"];
1075 [label="RoslynDebug.Assert(identity != null); 223201"];
1076 [label="RoslynDebug.Assert(identity != null); 223202"];
1077 [label="Debug.Assert(!referencedAssemblies.IsDefault); 223203"];
1078 [label="_embedInteropTypes 223204"];
1079 [label="_identity 223205"];
1080 [label="_referencedAssemblies 223206"];
1081 [label="Assembly 223207"];
1082 [label="CachedSymbols 223208"];
1083 [label="DocumentationProvider 223209"];
1084 [label="_compilationImportOptions 223210"];
1085 [label="_sourceAssemblySimpleName 223211"];
1086 [label="_internalsVisibleComputed 223212"];
1087 [label="_internalsPotentiallyVisibleToCompilation 223213"];
1088 [label="RoslynDebug.Assert(documentationProvider != null); 223214"];
1089 [label="RoslynDebug.Assert(documentationProvider != null); 223215"];
1090 [label="RoslynDebug.Assert(cachedSymbols != null); 223216"];
1091 [label="RoslynDebug.Assert(cachedSymbols != null); 223217"];
1092 [label="CachedSymbols 223218"];
1093 [label="Assembly 223219"];
1094 [label="DocumentationProvider 223220"];
1095 [label="_compilationImportOptions 223221"];
1096 [label="_sourceAssemblySimpleName 223222"];
1097 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 223223"];
1098 [label="RoslynDebug.Assert(identity != null); 223224"];
1099 [label="Debug.Assert(!referencedAssemblies.IsDefault); 223225"];
1100 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 223226"];
1101 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 223227"];
1102 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 223228"];
1103 [label="get\n                    {\n                        return _identity;\n                    } 223229"];
1104 [label="return _identity; 223230"];
1105 [label="var explicitAssemblyData = referencedAssemblies.Insert(0, assemblyBeingBuiltData); 223231"];
1106 [label="var explicitAssemblyData = referencedAssemblies.Insert(0, assemblyBeingBuiltData); 223232"];
1107 [label="bool hasCircularReference; 223233"];
1108 [label="int corLibraryIndex; 223234"];
1109 [label="ImmutableArray<MetadataReference> implicitlyResolvedReferences; 223235"];
1110 [label="implicitlyResolvedReferences 223236"];
1111 [label="ImmutableArray<ResolvedReference> implicitlyResolvedReferenceMap; 223237"];
1112 [label="implicitlyResolvedReferenceMap 223238"];
1113 [label="ImmutableArray<AssemblyData> allAssemblyData; 223239"];
1114 [label="allAssemblyData 223240"];
1115 [label="var temp1 = compilation.ScriptCompilationInfo; 223241"];
1116 [label="var temp2 = temp1 != null ? temp1.PreviousScriptCompilation : null; 223242"];
1117 [label="var temp2 = temp1 != null ? temp1.PreviousScriptCompilation : null; 223243"];
1118 [label="temp1 != null 223244"];
1119 [label="var temp3 = temp2 != null ? temp2.GetBoundReferenceManager() : null; 223245"];
1120 [label="var temp3 = temp2 != null ? temp2.GetBoundReferenceManager() : null; 223246"];
1121 [label="temp2 != null 223247"];
1122 [label="var temp4 = temp3 != null ? temp3.ImplicitReferenceResolutions : null; 223248"];
1123 [label="var temp4 = temp3 != null ? temp3.ImplicitReferenceResolutions : null; 223249"];
1124 [label="temp3 != null 223250"];
1125 [label="var implicitReferenceResolutions = temp4 ?? ImmutableDictionary<AssemblyIdentity, PortableExecutableReference?>.Empty; 223251"];
1126 [label="var implicitReferenceResolutions = temp4 ?? ImmutableDictionary<AssemblyIdentity, PortableExecutableReference?>.Empty; 223252"];
1127 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 223253"];
1128 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 223254"];
1129 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 223255"];
1130 [label="compilation.Options 223256"];
1131 [label="get\n            {\n                return _options;\n            } 223257"];
1132 [label="return _options; 223258"];
1133 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 223259"];
1134 [label="compilation.Options 223260"];
1135 [label="get\n            {\n                return _options;\n            } 223261"];
1136 [label="return _options; 223262"];
1137 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 223263"];
1138 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 223264"];
1139 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 223265"];
1140 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 223266"];
1141 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 223267"];
1142 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 223268"];
1143 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 223269"];
1144 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 223270"];
1145 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 223271"];
1146 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 223272"];
1147 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 223273"];
1148 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 223274"];
1149 [label="param BindAssemblyReferences(ImmutableArray<AssemblyData> assemblies) 223275"];
1150 [label="param BindAssemblyReferences(AssemblyIdentityComparer assemblyIdentityComparer) 223276"];
1151 [label="param BindAssemblyReferences(this) 223277"];
1152 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 223278"];
1153 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 223279"];
1154 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 223280"];
1155 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 223281"];
1156 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 223282"];
1157 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 223283"];
1158 [label="return _embedInteropTypes; 223284"];
1159 [label="get\n                    {\n                        return _referencedAssemblies;\n                    } 223285"];
1160 [label="return _referencedAssemblies; 223286"];
1161 [label="get\n                    {\n                        return Assembly.ContainsNoPiaLocalTypes();\n                    } 223287"];
1162 [label="return Assembly.ContainsNoPiaLocalTypes(); 223288"];
1163 [label="get\n                    {\n                        return Assembly.DeclaresTheObjectClass;\n                    } 223289"];
1164 [label="return Assembly.DeclaresTheObjectClass; 223290"];
1165 [label="get\n                    {\n                        if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        }\n\n                        return _assemblies;\n                    } 223291"];
1166 [label="if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        } 223292"];
1167 [label="if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        } 223293"];
1168 [label="_assemblies = new List<AssemblySymbol>(); 223294"];
1169 [label="_assemblies 223295"];
1170 [label="AddAvailableSymbols(_assemblies); 223296"];
1171 [label="AddAvailableSymbols(_assemblies) 223297"];
1172 [label="param AddAvailableSymbols(List<AssemblySymbol> assemblies) 223298"];
1173 [label="param AddAvailableSymbols(this) 223299"];
1174 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 223300"];
1175 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 223301"];
1176 [label="AddAvailableSymbols(_assemblies); 223302"];
1177 [label="return _assemblies; 223303"];
1178 [label="AddAvailableSymbols(_assemblies); 223304"];
1179 [label="AddAvailableSymbols(_assemblies) 223305"];
1180 [label="param AddAvailableSymbols(List<AssemblySymbol> assemblies) 223306"];
1181 [label="param AddAvailableSymbols(this) 223307"];
1182 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 223308"];
1183 [label="AddAvailableSymbols(_assemblies); 223309"];
1184 [label="Debug.Assert(bindingResult.Length == allAssemblyData.Length); 223310"];
1185 [label="var references = explicitReferences.AddRange(implicitlyResolvedReferences); 223311"];
1186 [label="referenceMap = referenceMap.AddRange(implicitlyResolvedReferenceMap); 223312"];
1187 [label="referenceMap = referenceMap.AddRange(implicitlyResolvedReferenceMap); 223313"];
1188 [label="Dictionary<MetadataReference, int> referencedAssembliesMap, referencedModulesMap; 223314"];
1189 [label="ImmutableArray<ImmutableArray<string>> aliasesOfReferencedAssemblies; 223315"];
1190 [label="aliasesOfReferencedAssemblies 223316"];
1191 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 223317"];
1192 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 223318"];
1193 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 223319"];
1194 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 223320"];
1195 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 223321"];
1196 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 223322"];
1197 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 223323"];
1198 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 223324"];
1199 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 223325"];
1200 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 223326"];
1201 [label="var newSymbols = new List<int>(); 223327"];
1202 [label="for (int i = 1; i < bindingResult.Length; i++)\n                    {\n                        ref BoundInputAssembly bound = ref bindingResult[i];\n                        if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        }\n\n                        Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked);\n                    } 223328"];
1203 [label="for (int i = 1; i < bindingResult.Length; i++)\n                    {\n                        ref BoundInputAssembly bound = ref bindingResult[i];\n                        if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        }\n\n                        Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked);\n                    } 223329"];
1204 [label="ref BoundInputAssembly bound = ref bindingResult[i]; 223330"];
1205 [label="if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        } 223331"];
1206 [label="bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol(); 223332"];
1207 [label="((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol() 223333"];
1208 [label="param CreateAssemblySymbol(this) 223334"];
1209 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 223335"];
1210 [label="this.IsLinked 223336"];
1211 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 223337"];
1212 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 223338"];
1213 [label="this.EffectiveImportOptions 223339"];
1214 [label="get\n                    {\n                        // We need to import internal members if they might be visible to the compilation being compiled:\n                        if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        }\n\n                        return _compilationImportOptions;\n                    } 223340"];
1215 [label="InternalsMayBeVisibleToCompilation 223341"];
1216 [label="get\n                    {\n                        if (!_internalsVisibleComputed)\n                        {\n                            _internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly);\n                            _internalsVisibleComputed = true;\n                        }\n\n                        return _internalsPotentiallyVisibleToCompilation;\n                    } 223342"];
1217 [label="if (!_internalsVisibleComputed)\n                        {\n                            _internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly);\n                            _internalsVisibleComputed = true;\n                        } 223343"];
1218 [label="_internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly); 223344"];
1219 [label="_internalsPotentiallyVisibleToCompilation 223345"];
1220 [label="_internalsVisibleComputed = true; 223346"];
1221 [label="_internalsVisibleComputed 223347"];
1222 [label="return _internalsPotentiallyVisibleToCompilation; 223348"];
1223 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 223349"];
1224 [label="return _compilationImportOptions; 223350"];
1225 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 223351"];
1226 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 223352"];
1227 [label="new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions) 223353"];
1228 [label="param PEAssemblySymbol(PEAssembly assembly) 223354"];
1229 [label="param PEAssemblySymbol(DocumentationProvider documentationProvider) 223355"];
1230 [label="param PEAssemblySymbol(bool isLinked) 223356"];
1231 [label="param PEAssemblySymbol(MetadataImportOptions importOptions) 223357"];
1232 [label="param PEAssemblySymbol(this) 223358"];
1233 [label="param PEAssemblySymbol(this) 223359"];
1234 [label="param MetadataOrSourceAssemblySymbol(this) 223360"];
1235 [label="param MetadataOrSourceAssemblySymbol(this) 223361"];
1236 [label="param NonMissingAssemblySymbol(this) 223362"];
1237 [label="new char[] { '+' } 223363"];
1238 [label="'+' 223364"];
1239 [label="new char[] { '+' } 223365"];
1240 [label="s_nestedTypeNameSeparators = new char[] { '+' } 223366"];
1241 [label="param NonMissingAssemblySymbol(this) 223367"];
1242 [label="param AssemblySymbol(this) 223368"];
1243 [label="param AssemblySymbol(this) 223369"];
1244 [label="param Symbol(this) 223370"];
1245 [label="_lazyISymbol 223371"];
1246 [label="_corLibrary 223372"];
1247 [label="new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 223373"];
1248 [label="_emittedNameToTypeMap =\n            new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 223374"];
1249 [label="_globalNamespace 223375"];
1250 [label="_lazySpecialTypes 223376"];
1251 [label="_cachedSpecialTypes 223377"];
1252 [label="_lazyNativeIntegerTypes 223378"];
1253 [label="_lazyTypeNames 223379"];
1254 [label="_lazyNamespaceNames 223380"];
1255 [label="_lazySpecialTypeMembers 223381"];
1256 [label="_assembliesToWhichInternalAccessHasBeenAnalyzed 223382"];
1257 [label="_assembly 223383"];
1258 [label="_documentationProvider 223384"];
1259 [label="_isLinked 223385"];
1260 [label="Debug.Assert(assembly != null); 223386"];
1261 [label="Debug.Assert(assembly != null); 223387"];
1262 [label="Debug.Assert(documentationProvider != null); 223388"];
1263 [label="Debug.Assert(documentationProvider != null); 223389"];
1264 [label="_assembly 223390"];
1265 [label="_documentationProvider 223391"];
1266 [label="var modules = new ModuleSymbol[assembly.Modules.Length]; 223392"];
1267 [label="for (int i = 0; i < assembly.Modules.Length; i++)\n            {\n                modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i);\n            } 223393"];
1268 [label="for (int i = 0; i < assembly.Modules.Length; i++)\n            {\n                modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i);\n            } 223394"];
1269 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 223395"];
1270 [label="31 223396"];
1271 [label="DefaultTypeMapCapacity = 31 223397"];
1272 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 223398"];
1273 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 223399"];
1274 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 223400"];
1275 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 223401"];
1276 [label="new PEModuleSymbol(this, assembly.Modules[i], importOptions, i) 223402"];
1277 [label="param PEModuleSymbol(PEAssemblySymbol assemblySymbol) 223403"];
1278 [label="param PEModuleSymbol(PEModule module) 223404"];
1279 [label="param PEModuleSymbol(MetadataImportOptions importOptions) 223405"];
1280 [label="param PEModuleSymbol(int ordinal) 223406"];
1281 [label="param PEModuleSymbol(this) 223407"];
1282 [label="assemblySymbol 223408"];
1283 [label="module 223409"];
1284 [label="importOptions 223410"];
1285 [label="ordinal 223411"];
1286 [label="param PEModuleSymbol(this) 223412"];
1287 [label="param PEModuleSymbol(AssemblySymbol assemblySymbol) 223413"];
1288 [label="param PEModuleSymbol(PEModule module) 223414"];
1289 [label="param PEModuleSymbol(MetadataImportOptions importOptions) 223415"];
1290 [label="param PEModuleSymbol(int ordinal) 223416"];
1291 [label="param PEModuleSymbol(this) 223417"];
1292 [label="param PEModuleSymbol(this) 223418"];
1293 [label="param NonMissingModuleSymbol(this) 223419"];
1294 [label="param NonMissingModuleSymbol(this) 223420"];
1295 [label="param ModuleSymbol(this) 223421"];
1296 [label="param ModuleSymbol(this) 223422"];
1297 [label="param Symbol(this) 223423"];
1298 [label="_lazyISymbol 223424"];
1299 [label="_moduleReferences 223425"];
1300 [label="_assemblySymbol 223426"];
1301 [label="_ordinal 223427"];
1302 [label="_module 223428"];
1303 [label="_globalNamespace 223429"];
1304 [label="_lazySystemTypeSymbol 223430"];
1305 [label="_lazyEventRegistrationTokenSymbol 223431"];
1306 [label="_lazyEventRegistrationTokenTableSymbol 223432"];
1307 [label="2 223433"];
1308 [label="concurrencyLevel: 2 223434"];
1309 [label="capacity: DefaultTypeMapCapacity 223435"];
1310 [label="new ConcurrentDictionary<TypeDefinitionHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 223436"];
1311 [label="TypeHandleToTypeMap =\n                                    new ConcurrentDictionary<TypeDefinitionHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 223437"];
1312 [label="2 223438"];
1313 [label="concurrencyLevel: 2 223439"];
1314 [label="capacity: DefaultTypeMapCapacity 223440"];
1315 [label="new ConcurrentDictionary<TypeReferenceHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 223441"];
1316 [label="TypeRefHandleToTypeMap =\n                                    new ConcurrentDictionary<TypeReferenceHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 223442"];
1317 [label="ImportOptions 223443"];
1318 [label="_lazyTypeNames 223444"];
1319 [label="_lazyNamespaceNames 223445"];
1320 [label="_lazyNullableMemberMetadata 223446"];
1321 [label="Debug.Assert((object)assemblySymbol != null); 223447"];
1322 [label="Debug.Assert((object)assemblySymbol != null); 223448"];
1323 [label="Debug.Assert(module != null); 223449"];
1324 [label="Debug.Assert(module != null); 223450"];
1325 [label="_assemblySymbol 223451"];
1326 [label="_ordinal 223452"];
1327 [label="_module 223453"];
1328 [label="this.ImportOptions 223454"];
1329 [label="_globalNamespace = new PEGlobalNamespaceSymbol(this); 223455"];
1330 [label="_globalNamespace = new PEGlobalNamespaceSymbol(this); 223456"];
1331 [label="new PEGlobalNamespaceSymbol(this) 223457"];
1332 [label="param PEGlobalNamespaceSymbol(PEModuleSymbol moduleSymbol) 223458"];
1333 [label="param PEGlobalNamespaceSymbol(this) 223459"];
1334 [label="param PEGlobalNamespaceSymbol(this) 223460"];
1335 [label="param PENamespaceSymbol(this) 223461"];
1336 [label="param PENamespaceSymbol(this) 223462"];
1337 [label="param NamespaceSymbol(this) 223463"];
1338 [label="param NamespaceSymbol(this) 223464"];
1339 [label="param NamespaceOrTypeSymbol(this) 223465"];
1340 [label="param NamespaceOrTypeSymbol(this) 223466"];
1341 [label="param Symbol(this) 223467"];
1342 [label="_lazyISymbol 223468"];
1343 [label="_lazyAdapter 223469"];
1344 [label="_lazyQualifiedName 223470"];
1345 [label="lazyNamespaces 223471"];
1346 [label="lazyTypes 223472"];
1347 [label="_lazyNoPiaLocalTypes 223473"];
1348 [label="_moduleSymbol 223474"];
1349 [label="Debug.Assert((object)moduleSymbol != null); 223475"];
1350 [label="Debug.Assert((object)moduleSymbol != null); 223476"];
1351 [label="_moduleSymbol 223477"];
1352 [label="_globalNamespace 223478"];
1353 [label="this.MetadataLocation = ImmutableArray.Create<MetadataLocation>(new MetadataLocation(this)); 223479"];
1354 [label="this.MetadataLocation = ImmutableArray.Create<MetadataLocation>(new MetadataLocation(this)); 223480"];
1355 [label="this.MetadataLocation 223481"];
1356 [label="Debug.Assert(ordinal >= 0); 223482"];
1357 [label="Debug.Assert(ordinal >= 0); 223483"];
1358 [label="modules[i] 223484"];
1359 [label="_modules = modules.AsImmutableOrNull(); 223485"];
1360 [label="_modules = modules.AsImmutableOrNull(); 223486"];
1361 [label="_modules 223487"];
1362 [label="_isLinked 223488"];
1363 [label="bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol(); 223489"];
1364 [label="bound.AssemblySymbol 223490"];
1365 [label="newSymbols.Add(i); 223491"];
1366 [label="newSymbols.Add(i); 223492"];
1367 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 223493"];
1368 [label="allAssemblyData[i].IsLinked 223494"];
1369 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 223495"];
1370 [label="bound.AssemblySymbol.IsLinked 223496"];
1371 [label="get\n            {\n                return _isLinked;\n            } 223497"];
1372 [label="return _isLinked; 223498"];
1373 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 223499"];
1374 [label="return _internalsPotentiallyVisibleToCompilation; 223500"];
1375 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 223501"];
1376 [label="_assembly 223502"];
1377 [label="_documentationProvider 223503"];
1378 [label="Debug.Assert(assembly != null); 223504"];
1379 [label="Debug.Assert(documentationProvider != null); 223505"];
1380 [label="_assemblySymbol 223506"];
1381 [label="_ordinal 223507"];
1382 [label="_module 223508"];
1383 [label="_globalNamespace 223509"];
1384 [label="ImportOptions 223510"];
1385 [label="Debug.Assert((object)assemblySymbol != null); 223511"];
1386 [label="Debug.Assert(module != null); 223512"];
1387 [label="_moduleSymbol 223513"];
1388 [label="Debug.Assert((object)moduleSymbol != null); 223514"];
1389 [label="Debug.Assert(ordinal >= 0); 223515"];
1390 [label="bound.AssemblySymbol 223516"];
1391 [label="newSymbols.Add(i); 223517"];
1392 [label="newSymbols.Add(i); 223518"];
1393 [label="allAssemblyData[i].IsLinked 223519"];
1394 [label="bound.AssemblySymbol.IsLinked 223520"];
1395 [label="get\n            {\n                return _isLinked;\n            } 223521"];
1396 [label="return _isLinked; 223522"];
1397 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 223523"];
1398 [label="_assembly 223524"];
1399 [label="_documentationProvider 223525"];
1400 [label="_assemblySymbol 223526"];
1401 [label="_ordinal 223527"];
1402 [label="_module 223528"];
1403 [label="_globalNamespace 223529"];
1404 [label="ImportOptions 223530"];
1405 [label="Debug.Assert((object)assemblySymbol != null); 223531"];
1406 [label="Debug.Assert(module != null); 223532"];
1407 [label="_moduleSymbol 223533"];
1408 [label="Debug.Assert((object)moduleSymbol != null); 223534"];
1409 [label="Debug.Assert(ordinal >= 0); 223535"];
1410 [label="bound.AssemblySymbol 223536"];
1411 [label="newSymbols.Add(i); 223537"];
1412 [label="get\n            {\n                return _isLinked;\n            } 223538"];
1413 [label="return _isLinked; 223539"];
1414 [label="return _internalsPotentiallyVisibleToCompilation; 223540"];
1415 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 223541"];
1416 [label="_assembly 223542"];
1417 [label="_documentationProvider 223543"];
1418 [label="Debug.Assert(assembly != null); 223544"];
1419 [label="Debug.Assert(documentationProvider != null); 223545"];
1420 [label="Debug.Assert(ordinal >= 0); 223546"];
1421 [label="bound.AssemblySymbol 223547"];
1422 [label="newSymbols.Add(i); 223548"];
1423 [label="newSymbols.Add(i); 223549"];
1424 [label="bound.AssemblySymbol.IsLinked 223550"];
1425 [label="get\n            {\n                return _isLinked;\n            } 223551"];
1426 [label="return _isLinked; 223552"];
1427 [label="newSymbols.Add(i); 223553"];
1428 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 223554"];
1429 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 223555"];
1430 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 223556"];
1431 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 223557"];
1432 [label="t_assemblyForWhichCurrentThreadIsComputingKeys 223558"];
1433 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 223559"];
1434 [label="new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules) 223560"];
1435 [label="param SourceAssemblySymbol(CSharpCompilation compilation) 223561"];
1436 [label="param SourceAssemblySymbol(string assemblySimpleName) 223562"];
1437 [label="param SourceAssemblySymbol(string moduleName) 223563"];
1438 [label="param SourceAssemblySymbol(ImmutableArray<PEModule> netModules) 223564"];
1439 [label="param SourceAssemblySymbol(this) 223565"];
1440 [label="param SourceAssemblySymbol(this) 223566"];
1441 [label="param MetadataOrSourceAssemblySymbol(this) 223567"];
1442 [label="param MetadataOrSourceAssemblySymbol(this) 223568"];
1443 [label="param NonMissingAssemblySymbol(this) 223569"];
1444 [label="param NonMissingAssemblySymbol(this) 223570"];
1445 [label="param AssemblySymbol(this) 223571"];
1446 [label="param AssemblySymbol(this) 223572"];
1447 [label="param Symbol(this) 223573"];
1448 [label="_lazyISymbol 223574"];
1449 [label="_corLibrary 223575"];
1450 [label="new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 223576"];
1451 [label="_emittedNameToTypeMap =\n            new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 223577"];
1452 [label="_globalNamespace 223578"];
1453 [label="_lazySpecialTypes 223579"];
1454 [label="_cachedSpecialTypes 223580"];
1455 [label="_lazyNativeIntegerTypes 223581"];
1456 [label="_lazyTypeNames 223582"];
1457 [label="_lazyNamespaceNames 223583"];
1458 [label="_lazySpecialTypeMembers 223584"];
1459 [label="_assembliesToWhichInternalAccessHasBeenAnalyzed 223585"];
1460 [label="_compilation 223586"];
1461 [label="lazyAssemblyIdentity 223587"];
1462 [label="_assemblySimpleName 223588"];
1463 [label="_lazyStrongNameKeys 223589"];
1464 [label="_lazySourceAttributesBag 223590"];
1465 [label="_lazyNetModuleAttributesBag 223591"];
1466 [label="_lazyForwardedTypesFromSource 223592"];
1467 [label="_lazyOmittedAttributeIndices 223593"];
1468 [label="_lazyContainsExtensionMethods 223594"];
1469 [label="new ConcurrentDictionary<FieldSymbol, bool>() 223595"];
1470 [label="_unassignedFieldsMap = new ConcurrentDictionary<FieldSymbol, bool>() 223596"];
1471 [label="new ConcurrentSet<FieldSymbol>() 223597"];
1472 [label="_unreadFields = new ConcurrentSet<FieldSymbol>() 223598"];
1473 [label="new ConcurrentSet<TypeSymbol>() 223599"];
1474 [label="TypesReferencedInExternalMethods = new ConcurrentSet<TypeSymbol>() 223600"];
1475 [label="_optimisticallyGrantedInternalsAccess 223601"];
1476 [label="_lazyInternalsVisibleToMap 223602"];
1477 [label="Debug.Assert(compilation != null); 223603"];
1478 [label="Debug.Assert(compilation != null); 223604"];
1479 [label="Debug.Assert(assemblySimpleName != null); 223605"];
1480 [label="Debug.Assert(assemblySimpleName != null); 223606"];
1481 [label="Debug.Assert(!String.IsNullOrWhiteSpace(moduleName)); 223607"];
1482 [label="Debug.Assert(!netModules.IsDefault); 223608"];
1483 [label="_compilation 223609"];
1484 [label="_assemblySimpleName 223610"];
1485 [label="ArrayBuilder<ModuleSymbol> moduleBuilder = new ArrayBuilder<ModuleSymbol>(1 + netModules.Length); 223611"];
1486 [label="ArrayBuilder<ModuleSymbol> moduleBuilder = new ArrayBuilder<ModuleSymbol>(1 + netModules.Length); 223612"];
1487 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 223613"];
1488 [label="compilation.Declarations 223614"];
1489 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 223615"];
1490 [label="return _syntaxAndDeclarations.GetLazyState().DeclarationTable; 223616"];
1491 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 223617"];
1492 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 223618"];
1493 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 223619"];
1494 [label="new SourceModuleSymbol(this, compilation.Declarations, moduleName) 223620"];
1495 [label="param SourceModuleSymbol(SourceAssemblySymbol assemblySymbol) 223621"];
1496 [label="param SourceModuleSymbol(DeclarationTable declarations) 223622"];
1497 [label="param SourceModuleSymbol(string moduleName) 223623"];
1498 [label="param SourceModuleSymbol(this) 223624"];
1499 [label="param SourceModuleSymbol(this) 223625"];
1500 [label="param NonMissingModuleSymbol(this) 223626"];
1501 [label="param NonMissingModuleSymbol(this) 223627"];
1502 [label="param ModuleSymbol(this) 223628"];
1503 [label="param ModuleSymbol(this) 223629"];
1504 [label="param Symbol(this) 223630"];
1505 [label="_lazyISymbol 223631"];
1506 [label="_moduleReferences 223632"];
1507 [label="_assemblySymbol 223633"];
1508 [label="_lazyContainsExplicitDefinitionOfNoPiaLocalTypes = ThreeState.Unknown 223634"];
1509 [label="_sources 223635"];
1510 [label="_lazyCustomAttributesBag 223636"];
1511 [label="_globalNamespace 223637"];
1512 [label="_hasBadAttributes 223638"];
1513 [label="_name 223639"];
1514 [label="Debug.Assert((object)assemblySymbol != null); 223640"];
1515 [label="Debug.Assert((object)assemblySymbol != null); 223641"];
1516 [label="_assemblySymbol 223642"];
1517 [label="_sources 223643"];
1518 [label="_name 223644"];
1519 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 223645"];
1520 [label="compilation.Options 223646"];
1521 [label="get\n            {\n                return _options;\n            } 223647"];
1522 [label="return _options; 223648"];
1523 [label="var importOptions = (compilation.Options.MetadataImportOptions == MetadataImportOptions.All) ?\n                MetadataImportOptions.All : MetadataImportOptions.Internal; 223649"];
1524 [label="(compilation.Options.MetadataImportOptions == MetadataImportOptions.All) 223650"];
1525 [label="foreach (PEModule netModule in netModules)\n            {\n                moduleBuilder.Add(new PEModuleSymbol(this, netModule, importOptions, moduleBuilder.Count));\n                // SetReferences will be called later by the ReferenceManager (in CreateSourceAssemblyFullBind for \n                // a fresh manager, in CreateSourceAssemblyReuseData for a reused one).\n            } 223651"];
1526 [label="_modules = moduleBuilder.ToImmutableAndFree(); 223652"];
1527 [label="_modules 223653"];
1528 [label="compilation.Options 223654"];
1529 [label="get\n            {\n                return _options;\n            } 223655"];
1530 [label="return _options; 223656"];
1531 [label="if (!compilation.Options.CryptoPublicKey.IsEmpty)\n            {\n                // Private key is not necessary for assembly identity, only when emitting.  For this reason, the private key can remain null.\n                _lazyStrongNameKeys = StrongNameKeys.Create(compilation.Options.CryptoPublicKey, privateKey: null, hasCounterSignature: false, MessageProvider.Instance);\n            } 223657"];
1532 [label="if (!compilation.Options.CryptoPublicKey.IsEmpty)\n            {\n                // Private key is not necessary for assembly identity, only when emitting.  For this reason, the private key can remain null.\n                _lazyStrongNameKeys = StrongNameKeys.Create(compilation.Options.CryptoPublicKey, privateKey: null, hasCounterSignature: false, MessageProvider.Instance);\n            } 223658"];
1533 [label="AssemblySymbol? corLibrary; 223659"];
1534 [label="if (corLibraryIndex == 0)\n                    {\n                        corLibrary = assemblySymbol;\n                    }\n                    else if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 223660"];
1535 [label="if (corLibraryIndex == 0)\n                    {\n                        corLibrary = assemblySymbol;\n                    }\n                    else if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 223661"];
1536 [label="if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 223662"];
1537 [label="corLibrary = bindingResult[corLibraryIndex].AssemblySymbol; 223663"];
1538 [label="assemblySymbol.SetCorLibrary(corLibrary); 223664"];
1539 [label="assemblySymbol.SetCorLibrary(corLibrary) 223665"];
1540 [label="param SetCorLibrary(AssemblySymbol corLibrary) 223666"];
1541 [label="param SetCorLibrary(this) 223667"];
1542 [label="Debug.Assert((object)_corLibrary == null); 223668"];
1543 [label="Debug.Assert((object)_corLibrary == null); 223669"];
1544 [label="_corLibrary 223670"];
1545 [label="assemblySymbol.SetCorLibrary(corLibrary); 223671"];
1546 [label="Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies = null; 223672"];
1547 [label="int totalReferencedAssemblyCount = allAssemblyData.Length - 1; 223673"];
1548 [label="int totalReferencedAssemblyCount = allAssemblyData.Length - 1; 223674"];
1549 [label="ImmutableArray<ModuleReferences<AssemblySymbol>> moduleReferences; 223675"];
1550 [label="moduleReferences 223676"];
1551 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 223677"];
1552 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 223678"];
1553 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 223679"];
1554 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 223680"];
1555 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 223681"];
1556 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 223682"];
1557 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences) 223683"];
1558 [label="param SetupReferencesForSourceAssembly(SourceAssemblySymbol sourceAssembly) 223684"];
1559 [label="param SetupReferencesForSourceAssembly(ImmutableArray<PEModule> modules) 223685"];
1560 [label="param SetupReferencesForSourceAssembly(int totalReferencedAssemblyCount) 223686"];
1561 [label="param SetupReferencesForSourceAssembly(BoundInputAssembly[] bindingResult) 223687"];
1562 [label="param SetupReferencesForSourceAssembly(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 223688"];
1563 [label="param SetupReferencesForSourceAssembly(out ImmutableArray<ModuleReferences<AssemblySymbol>> moduleReferences) 223689"];
1564 [label="sourceAssembly.Modules 223690"];
1565 [label="get\n            {\n                return _modules;\n            } 223691"];
1566 [label="return _modules; 223692"];
1567 [label="var moduleSymbols = sourceAssembly.Modules; 223693"];
1568 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 223694"];
1569 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 223695"];
1570 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 223696"];
1571 [label="var moduleReferencesBuilder = (moduleSymbols.Length > 1) ? ArrayBuilder<ModuleReferences<AssemblySymbol>>.GetInstance() : null; 223697"];
1572 [label="var moduleReferencesBuilder = (moduleSymbols.Length > 1) ? ArrayBuilder<ModuleReferences<AssemblySymbol>>.GetInstance() : null; 223698"];
1573 [label="(moduleSymbols.Length > 1) 223699"];
1574 [label="int refsUsed = 0; 223700"];
1575 [label="for (int moduleIndex = 0; moduleIndex < moduleSymbols.Length; moduleIndex++)\n                {\n                    int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length;\n\n                    var identities = new AssemblyIdentity[refsCount];\n                    var symbols = new AssemblySymbol[refsCount];\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n\n                    for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    }\n\n                    var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty());\n\n                    if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    }\n\n                    moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly);\n\n                    refsUsed += refsCount;\n                } 223701"];
1576 [label="for (int moduleIndex = 0; moduleIndex < moduleSymbols.Length; moduleIndex++)\n                {\n                    int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length;\n\n                    var identities = new AssemblyIdentity[refsCount];\n                    var symbols = new AssemblySymbol[refsCount];\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n\n                    for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    }\n\n                    var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty());\n\n                    if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    }\n\n                    moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly);\n\n                    refsUsed += refsCount;\n                } 223702"];
1577 [label="int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length; 223703"];
1578 [label="(moduleIndex == 0) 223704"];
1579 [label="int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length; 223705"];
1580 [label="var identities = new AssemblyIdentity[refsCount]; 223706"];
1581 [label="var symbols = new AssemblySymbol[refsCount]; 223707"];
1582 [label="ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null; 223708"];
1583 [label="for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    } 223709"];
1584 [label="for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    } 223710"];
1585 [label="Debug.Assert(bindingResult[0].ReferenceBinding is object); 223711"];
1586 [label="Debug.Assert(bindingResult[0].ReferenceBinding is object); 223712"];
1587 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 223713"];
1588 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 223714"];
1589 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 223715"];
1590 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 223716"];
1591 [label="Debug.Assert(boundReference.ReferenceIdentity is object); 223717"];
1592 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        } 223718"];
1593 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 223719"];
1594 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 223720"];
1595 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 223721"];
1596 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 223722"];
1597 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 223723"];
1598 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 223724"];
1599 [label="param GetAssemblyDefinitionSymbol(ref ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies) 223725"];
1600 [label="Debug.Assert(referenceBinding.IsBound); 223726"];
1601 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 223727"];
1602 [label="var assembly = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol; 223728"];
1603 [label="Debug.Assert(assembly is object); 223729"];
1604 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 223730"];
1605 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 223731"];
1606 [label="return assembly; 223732"];
1607 [label="symbols[k] 223733"];
1608 [label="identities[k] 223734"];
1609 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 223735"];
1610 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 223736"];
1611 [label="Debug.Assert(boundReference.ReferenceIdentity is object); 223737"];
1612 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        } 223738"];
1613 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 223739"];
1614 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 223740"];
1615 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 223741"];
1616 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 223742"];
1617 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 223743"];
1618 [label="Debug.Assert(referenceBinding.IsBound); 223744"];
1619 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 223745"];
1620 [label="var assembly = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol; 223746"];
1621 [label="Debug.Assert(assembly is object); 223747"];
1622 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 223748"];
1623 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 223749"];
1624 [label="return assembly; 223750"];
1625 [label="symbols[k] 223751"];
1626 [label="identities[k] 223752"];
1627 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 223753"];
1628 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 223754"];
1629 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 223755"];
1630 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 223756"];
1631 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 223757"];
1632 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 223758"];
1633 [label="if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    } 223759"];
1634 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 223760"];
1635 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 223761"];
1636 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 223762"];
1637 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly) 223763"];
1638 [label="param SetReferences(ModuleReferences<AssemblySymbol> moduleReferences) 223764"];
1639 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 223765"];
1640 [label="param SetReferences(this) 223766"];
1641 [label="Debug.Assert(moduleReferences != null); 223767"];
1642 [label="Debug.Assert(moduleReferences != null); 223768"];
1643 [label="AssertReferencesUninitialized() 223769"];
1644 [label="param AssertReferencesUninitialized(this) 223770"];
1645 [label="Debug.Assert(_moduleReferences == null); 223771"];
1646 [label="Debug.Assert(_moduleReferences == null); 223772"];
1647 [label="AssertReferencesUninitialized(); 223773"];
1648 [label="_moduleReferences 223774"];
1649 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 223775"];
1650 [label="refsUsed += refsCount; 223776"];
1651 [label="moduleReferences = moduleReferencesBuilder.ToImmutableOrEmptyAndFree(); 223777"];
1652 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 223778"];
1653 [label="if (newSymbols.Count > 0)\n                    {\n                        // Only if we detected that a referenced assembly refers to the assembly being built\n                        // we allow the references to get a hold of the assembly being built.\n                        if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        }\n\n                        InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies);\n                    } 223779"];
1654 [label="if (newSymbols.Count > 0)\n                    {\n                        // Only if we detected that a referenced assembly refers to the assembly being built\n                        // we allow the references to get a hold of the assembly being built.\n                        if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        }\n\n                        InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies);\n                    } 223780"];
1655 [label="if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        } 223781"];
1656 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 223782"];
1657 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 223783"];
1658 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 223784"];
1659 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 223785"];
1660 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies) 223786"];
1661 [label="param InitializeNewSymbols(List<int> newSymbols) 223787"];
1662 [label="param InitializeNewSymbols(SourceAssemblySymbol sourceAssembly) 223788"];
1663 [label="param InitializeNewSymbols(ImmutableArray<AssemblyData> assemblies) 223789"];
1664 [label="param InitializeNewSymbols(BoundInputAssembly[] bindingResult) 223790"];
1665 [label="param InitializeNewSymbols(Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 223791"];
1666 [label="Debug.Assert(newSymbols.Count > 0); 223792"];
1667 [label="Debug.Assert(newSymbols.Count > 0); 223793"];
1668 [label="sourceAssembly.CorLibrary 223794"];
1669 [label="get\n            {\n                return _corLibrary;\n            } 223795"];
1670 [label="return _corLibrary; 223796"];
1671 [label="var corLibrary = sourceAssembly.CorLibrary; 223797"];
1672 [label="RoslynDebug.Assert((object)corLibrary != null); 223798"];
1673 [label="RoslynDebug.Assert((object)corLibrary != null); 223799"];
1674 [label="foreach (int i in newSymbols)\n                {\n                    var compilationData = assemblies[i] as AssemblyDataForCompilation;\n\n                    if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                } 223800"];
1675 [label="var compilationData = assemblies[i] as AssemblyDataForCompilation; 223801"];
1676 [label="if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    } 223802"];
1677 [label="if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    } 223803"];
1678 [label="var fileData = (AssemblyDataForFile)assemblies[i]; 223804"];
1679 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 223805"];
1680 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 223806"];
1681 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 223807"];
1682 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 223808"];
1683 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 223809"];
1684 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly) 223810"];
1685 [label="param SetupReferencesForFileAssembly(AssemblyDataForFile fileData) 223811"];
1686 [label="param SetupReferencesForFileAssembly(BoundInputAssembly[] bindingResult) 223812"];
1687 [label="param SetupReferencesForFileAssembly(ref BoundInputAssembly currentBindingResult) 223813"];
1688 [label="param SetupReferencesForFileAssembly(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 223814"];
1689 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 223815"];
1690 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 223816"];
1691 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 223817"];
1692 [label="var portableExecutableAssemblySymbol = (PEAssemblySymbol)currentBindingResult.AssemblySymbol; 223818"];
1693 [label="portableExecutableAssemblySymbol.Modules 223819"];
1694 [label="get\n            {\n                return _modules;\n            } 223820"];
1695 [label="return _modules; 223821"];
1696 [label="ImmutableArray<ModuleSymbol> modules = portableExecutableAssemblySymbol.Modules; 223822"];
1697 [label="int moduleCount = modules.Length; 223823"];
1698 [label="int refsUsed = 0; 223824"];
1699 [label="for (int j = 0; j < moduleCount; j++)\n                {\n                    int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j];\n                    var identities = new AssemblyIdentity[moduleReferenceCount];\n                    var symbols = new AssemblySymbol[moduleReferenceCount];\n\n                    fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount);\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n                    for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    }\n\n                    var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty());\n                    modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly);\n\n                    refsUsed += moduleReferenceCount;\n                } 223825"];
1700 [label="for (int j = 0; j < moduleCount; j++)\n                {\n                    int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j];\n                    var identities = new AssemblyIdentity[moduleReferenceCount];\n                    var symbols = new AssemblySymbol[moduleReferenceCount];\n\n                    fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount);\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n                    for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    }\n\n                    var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty());\n                    modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly);\n\n                    refsUsed += moduleReferenceCount;\n                } 223826"];
1701 [label="int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j]; 223827"];
1702 [label="var identities = new AssemblyIdentity[moduleReferenceCount]; 223828"];
1703 [label="var symbols = new AssemblySymbol[moduleReferenceCount]; 223829"];
1704 [label="fileData.AssemblyReferences 223830"];
1705 [label="get\n                    {\n                        return _referencedAssemblies;\n                    } 223831"];
1706 [label="return _referencedAssemblies; 223832"];
1707 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 223833"];
1708 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 223834"];
1709 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 223835"];
1710 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 223836"];
1711 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 223837"];
1712 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 223838"];
1713 [label="ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null; 223839"];
1714 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 223840"];
1715 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 223841"];
1716 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 223842"];
1717 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 223843"];
1718 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 223844"];
1719 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 223845"];
1720 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 223846"];
1721 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 223847"];
1722 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 223848"];
1723 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 223849"];
1724 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly) 223850"];
1725 [label="param SetReferences(ModuleReferences<AssemblySymbol> moduleReferences) 223851"];
1726 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 223852"];
1727 [label="param SetReferences(this) 223853"];
1728 [label="Debug.Assert(moduleReferences != null); 223854"];
1729 [label="Debug.Assert(moduleReferences != null); 223855"];
1730 [label="AssertReferencesUninitialized() 223856"];
1731 [label="param AssertReferencesUninitialized(this) 223857"];
1732 [label="Debug.Assert(_moduleReferences == null); 223858"];
1733 [label="Debug.Assert(_moduleReferences == null); 223859"];
1734 [label="AssertReferencesUninitialized(); 223860"];
1735 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 223861"];
1736 [label="refsUsed += moduleReferenceCount; 223862"];
1737 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 223863"];
1738 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 223864"];
1739 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 223865"];
1740 [label="param SetupReferencesForFileAssembly(BoundInputAssembly[] bindingResult) 223866"];
1741 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 223867"];
1742 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 223868"];
1743 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 223869"];
1744 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 223870"];
1745 [label="var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k]; 223871"];
1746 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        } 223872"];
1747 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 223873"];
1748 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 223874"];
1749 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 223875"];
1750 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 223876"];
1751 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 223877"];
1752 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 223878"];
1753 [label="param GetAssemblyDefinitionSymbol(ref ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies) 223879"];
1754 [label="Debug.Assert(referenceBinding.IsBound); 223880"];
1755 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 223881"];
1756 [label="Debug.Assert(assembly is object); 223882"];
1757 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 223883"];
1758 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 223884"];
1759 [label="symbols[k] 223885"];
1760 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 223886"];
1761 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 223887"];
1762 [label="GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies) 223888"];
1763 [label="param GetOrAddMissingAssemblySymbol(AssemblyIdentity assemblyIdentity) 223889"];
1764 [label="param GetOrAddMissingAssemblySymbol(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 223890"];
1765 [label="MissingAssemblySymbol? missingAssembly; 223891"];
1766 [label="if (missingAssemblies == null)\n                {\n                    missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>();\n                }\n                else if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 223892"];
1767 [label="if (missingAssemblies == null)\n                {\n                    missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>();\n                }\n                else if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 223893"];
1768 [label="missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>(); 223894"];
1769 [label="missingAssembly = new MissingAssemblySymbol(assemblyIdentity); 223895"];
1770 [label="missingAssembly = new MissingAssemblySymbol(assemblyIdentity); 223896"];
1771 [label="new MissingAssemblySymbol(assemblyIdentity) 223897"];
1772 [label="param MissingAssemblySymbol(AssemblyIdentity identity) 223898"];
1773 [label="param MissingAssemblySymbol(this) 223899"];
1774 [label="param MissingAssemblySymbol(this) 223900"];
1775 [label="identity 223901"];
1776 [label="moduleSymbol 223902"];
1777 [label="Debug.Assert(identity != null); 223903"];
1778 [label="Debug.Assert(identity != null); 223904"];
1779 [label="this.identity 223905"];
1780 [label="moduleSymbol = new MissingModuleSymbol(this, 0); 223906"];
1781 [label="moduleSymbol = new MissingModuleSymbol(this, 0); 223907"];
1782 [label="new MissingModuleSymbol(this, 0) 223908"];
1783 [label="param MissingModuleSymbol(AssemblySymbol assembly) 223909"];
1784 [label="param MissingModuleSymbol(int ordinal) 223910"];
1785 [label="param MissingModuleSymbol(this) 223911"];
1786 [label="param MissingModuleSymbol(this) 223912"];
1787 [label="assembly 223913"];
1788 [label="ordinal 223914"];
1789 [label="globalNamespace 223915"];
1790 [label="Debug.Assert((object)assembly != null); 223916"];
1791 [label="Debug.Assert((object)assembly != null); 223917"];
1792 [label="Debug.Assert(ordinal >= -1); 223918"];
1793 [label="Debug.Assert(ordinal >= -1); 223919"];
1794 [label="this.assembly 223920"];
1795 [label="this.ordinal 223921"];
1796 [label="globalNamespace = new MissingNamespaceSymbol(this); 223922"];
1797 [label="globalNamespace = new MissingNamespaceSymbol(this); 223923"];
1798 [label="new MissingNamespaceSymbol(this) 223924"];
1799 [label="param MissingNamespaceSymbol(MissingModuleSymbol containingModule) 223925"];
1800 [label="param MissingNamespaceSymbol(this) 223926"];
1801 [label="param MissingNamespaceSymbol(this) 223927"];
1802 [label="_name 223928"];
1803 [label="_containingSymbol 223929"];
1804 [label="Debug.Assert((object)containingModule != null); 223930"];
1805 [label="Debug.Assert((object)containingModule != null); 223931"];
1806 [label="_containingSymbol 223932"];
1807 [label="_name 223933"];
1808 [label="globalNamespace 223934"];
1809 [label="moduleSymbol 223935"];
1810 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 223936"];
1811 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 223937"];
1812 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 223938"];
1813 [label="return missingAssembly; 223939"];
1814 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 223940"];
1815 [label="symbols[k] 223941"];
1816 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 223942"];
1817 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 223943"];
1818 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 223944"];
1819 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 223945"];
1820 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 223946"];
1821 [label="Debug.Assert(moduleReferences != null); 223947"];
1822 [label="Debug.Assert(moduleReferences != null); 223948"];
1823 [label="AssertReferencesUninitialized() 223949"];
1824 [label="param AssertReferencesUninitialized(this) 223950"];
1825 [label="Debug.Assert(_moduleReferences == null); 223951"];
1826 [label="Debug.Assert(_moduleReferences == null); 223952"];
1827 [label="AssertReferencesUninitialized(); 223953"];
1828 [label="refsUsed += moduleReferenceCount; 223954"];
1829 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 223955"];
1830 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 223956"];
1831 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 223957"];
1832 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 223958"];
1833 [label="Debug.Assert(referenceBinding.IsBound); 223959"];
1834 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 223960"];
1835 [label="Debug.Assert(assembly is object); 223961"];
1836 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 223962"];
1837 [label="return missingAssembly; 223963"];
1838 [label="identity 223964"];
1839 [label="moduleSymbol 223965"];
1840 [label="Debug.Assert(identity != null); 223966"];
1841 [label="Debug.Assert(identity != null); 223967"];
1842 [label="assembly 223968"];
1843 [label="ordinal 223969"];
1844 [label="globalNamespace 223970"];
1845 [label="Debug.Assert((object)assembly != null); 223971"];
1846 [label="Debug.Assert((object)assembly != null); 223972"];
1847 [label="Debug.Assert(ordinal >= -1); 223973"];
1848 [label="Debug.Assert(ordinal >= -1); 223974"];
1849 [label="_name 223975"];
1850 [label="_containingSymbol 223976"];
1851 [label="Debug.Assert((object)containingModule != null); 223977"];
1852 [label="Debug.Assert((object)containingModule != null); 223978"];
1853 [label="identity 223979"];
1854 [label="moduleSymbol 223980"];
1855 [label="Debug.Assert(identity != null); 223981"];
1856 [label="assembly 223982"];
1857 [label="ordinal 223983"];
1858 [label="globalNamespace 223984"];
1859 [label="Debug.Assert((object)assembly != null); 223985"];
1860 [label="Debug.Assert(ordinal >= -1); 223986"];
1861 [label="_name 223987"];
1862 [label="_containingSymbol 223988"];
1863 [label="Debug.Assert((object)containingModule != null); 223989"];
1864 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 223990"];
1865 [label="Debug.Assert(moduleReferences != null); 223991"];
1866 [label="Debug.Assert(moduleReferences != null); 223992"];
1867 [label="AssertReferencesUninitialized() 223993"];
1868 [label="param AssertReferencesUninitialized(this) 223994"];
1869 [label="Debug.Assert(_moduleReferences == null); 223995"];
1870 [label="Debug.Assert(_moduleReferences == null); 223996"];
1871 [label="AssertReferencesUninitialized(); 223997"];
1872 [label="refsUsed += moduleReferenceCount; 223998"];
1873 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 223999"];
1874 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 224000"];
1875 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 224001"];
1876 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 224002"];
1877 [label="Debug.Assert(referenceBinding.IsBound); 224003"];
1878 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 224004"];
1879 [label="Debug.Assert(assembly is object); 224005"];
1880 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 224006"];
1881 [label="if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    } 224007"];
1882 [label="unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>(); 224008"];
1883 [label="unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity)); 224009"];
1884 [label="unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity)); 224010"];
1885 [label="identity 224011"];
1886 [label="moduleSymbol 224012"];
1887 [label="Debug.Assert(identity != null); 224013"];
1888 [label="assembly 224014"];
1889 [label="ordinal 224015"];
1890 [label="globalNamespace 224016"];
1891 [label="Debug.Assert((object)assembly != null); 224017"];
1892 [label="Debug.Assert(ordinal >= -1); 224018"];
1893 [label="_name 224019"];
1894 [label="_containingSymbol 224020"];
1895 [label="Debug.Assert((object)containingModule != null); 224021"];
1896 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 224022"];
1897 [label="Debug.Assert(moduleReferences != null); 224023"];
1898 [label="Debug.Assert(moduleReferences != null); 224024"];
1899 [label="AssertReferencesUninitialized() 224025"];
1900 [label="param AssertReferencesUninitialized(this) 224026"];
1901 [label="Debug.Assert(_moduleReferences == null); 224027"];
1902 [label="Debug.Assert(_moduleReferences == null); 224028"];
1903 [label="AssertReferencesUninitialized(); 224029"];
1904 [label="refsUsed += moduleReferenceCount; 224030"];
1905 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 224031"];
1906 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 224032"];
1907 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 224033"];
1908 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 224034"];
1909 [label="Debug.Assert(referenceBinding.IsBound); 224035"];
1910 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 224036"];
1911 [label="Debug.Assert(assembly is object); 224037"];
1912 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 224038"];
1913 [label="Debug.Assert(moduleReferences != null); 224039"];
1914 [label="AssertReferencesUninitialized() 224040"];
1915 [label="param AssertReferencesUninitialized(this) 224041"];
1916 [label="Debug.Assert(_moduleReferences == null); 224042"];
1917 [label="Debug.Assert(_moduleReferences == null); 224043"];
1918 [label="AssertReferencesUninitialized(); 224044"];
1919 [label="refsUsed += moduleReferenceCount; 224045"];
1920 [label="var linkedReferencedAssembliesBuilder = ArrayBuilder<AssemblySymbol>.GetInstance(); 224046"];
1921 [label="sourceAssembly.Modules 224047"];
1922 [label="get\n            {\n                return _modules;\n            } 224048"];
1923 [label="return _modules; 224049"];
1924 [label="var noPiaResolutionAssemblies = sourceAssembly.Modules[0].GetReferencedAssemblySymbols(); 224050"];
1925 [label="var noPiaResolutionAssemblies = sourceAssembly.Modules[0].GetReferencedAssemblySymbols(); 224051"];
1926 [label="sourceAssembly.Modules[0].GetReferencedAssemblySymbols() 224052"];
1927 [label="param GetReferencedAssemblySymbols(this) 224053"];
1928 [label="AssertReferencesInitialized() 224054"];
1929 [label="param AssertReferencesInitialized(this) 224055"];
1930 [label="Debug.Assert(_moduleReferences != null); 224056"];
1931 [label="Debug.Assert(_moduleReferences != null); 224057"];
1932 [label="AssertReferencesInitialized(); 224058"];
1933 [label="return _moduleReferences.Symbols; 224059"];
1934 [label="foreach (int i in newSymbols)\n                {\n                    ref BoundInputAssembly currentBindingResult = ref bindingResult[i];\n                    Debug.Assert(currentBindingResult.AssemblySymbol is object);\n                    Debug.Assert(currentBindingResult.ReferenceBinding is object);\n\n                    if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    }\n\n                    // Setup linked referenced assemblies.\n                    linkedReferencedAssembliesBuilder.Clear();\n\n                    if (assemblies[i].IsLinked)\n                    {\n                        linkedReferencedAssembliesBuilder.Add(currentBindingResult.AssemblySymbol);\n                    }\n\n                    foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    }\n\n                    if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    }\n\n                    currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary);\n                } 224060"];
1935 [label="ref BoundInputAssembly currentBindingResult = ref bindingResult[i]; 224061"];
1936 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 224062"];
1937 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 224063"];
1938 [label="if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    } 224064"];
1939 [label="assemblies[i].ContainsNoPiaLocalTypes 224065"];
1940 [label="get\n                    {\n                        return Assembly.ContainsNoPiaLocalTypes();\n                    } 224066"];
1941 [label="linkedReferencedAssembliesBuilder.Clear(); 224067"];
1942 [label="if (assemblies[i].IsLinked)\n                    {\n                        linkedReferencedAssembliesBuilder.Add(currentBindingResult.AssemblySymbol);\n                    } 224068"];
1943 [label="assemblies[i].IsLinked 224069"];
1944 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 224070"];
1945 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 224071"];
1946 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 224072"];
1947 [label="if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    } 224073"];
1948 [label="if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    } 224074"];
1949 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary); 224075"];
1950 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary) 224076"];
1951 [label="param SetCorLibrary(AssemblySymbol corLibrary) 224077"];
1952 [label="param SetCorLibrary(this) 224078"];
1953 [label="Debug.Assert((object)_corLibrary == null); 224079"];
1954 [label="Debug.Assert((object)_corLibrary == null); 224080"];
1955 [label="_corLibrary 224081"];
1956 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary); 224082"];
1957 [label="ref BoundInputAssembly currentBindingResult = ref bindingResult[i]; 224083"];
1958 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 224084"];
1959 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 224085"];
1960 [label="if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    } 224086"];
1961 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 224087"];
1962 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 224088"];
1963 [label="if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        } 224089"];
1964 [label="assemblies[referenceBinding.DefinitionIndex].IsLinked 224090"];
1965 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 224091"];
1966 [label="Debug.Assert((object)_corLibrary == null); 224092"];
1967 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 224093"];
1968 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 224094"];
1969 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 224095"];
1970 [label="assemblies[referenceBinding.DefinitionIndex].IsLinked 224096"];
1971 [label="Debug.Assert((object)_corLibrary == null); 224097"];
1972 [label="linkedReferencedAssembliesBuilder.Free(); 224098"];
1973 [label="if (missingAssemblies != null)\n                {\n                    foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    }\n                } 224099"];
1974 [label="if (missingAssemblies != null)\n                {\n                    foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    }\n                } 224100"];
1975 [label="foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    } 224101"];
1976 [label="missingAssembly.SetCorLibrary(corLibrary); 224102"];
1977 [label="missingAssembly.SetCorLibrary(corLibrary) 224103"];
1978 [label="param SetCorLibrary(AssemblySymbol corLibrary) 224104"];
1979 [label="Debug.Assert((object)_corLibrary == null); 224105"];
1980 [label="missingAssembly.SetCorLibrary(corLibrary); 224106"];
1981 [label="Debug.Assert((object)_corLibrary == null); 224107"];
1982 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 224108"];
1983 [label="if (compilation._lazyAssemblySymbol is null)\n                    {\n                        lock (SymbolCacheAndReferenceManagerStateGuard)\n                        {\n                            if (compilation._lazyAssemblySymbol is null)\n                            {\n                                if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                }\n\n                                UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult);\n\n                                InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies());\n\n                                // Make sure that the given compilation holds on this instance of reference manager.\n                                Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference);\n                                compilation._referenceManager = this;\n\n                                // Finally, publish the source symbol after all data have been written.\n                                // Once lazyAssemblySymbol is non-null other readers might start reading the data written above.\n                                compilation._lazyAssemblySymbol = assemblySymbol;\n                            }\n                        }\n                    } 224109"];
1984 [label="if (compilation._lazyAssemblySymbol is null)\n                            {\n                                if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                }\n\n                                UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult);\n\n                                InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies());\n\n                                // Make sure that the given compilation holds on this instance of reference manager.\n                                Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference);\n                                compilation._referenceManager = this;\n\n                                // Finally, publish the source symbol after all data have been written.\n                                // Once lazyAssemblySymbol is non-null other readers might start reading the data written above.\n                                compilation._lazyAssemblySymbol = assemblySymbol;\n                            } 224110"];
1985 [label="if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                } 224111"];
1986 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 224112"];
1987 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 224113"];
1988 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult) 224114"];
1989 [label="param UpdateSymbolCacheNoLock(List<int> newSymbols) 224115"];
1990 [label="param UpdateSymbolCacheNoLock(ImmutableArray<AssemblyData> assemblies) 224116"];
1991 [label="param UpdateSymbolCacheNoLock(BoundInputAssembly[] bindingResult) 224117"];
1992 [label="foreach (int i in newSymbols)\n                {\n                    ref BoundInputAssembly current = ref bindingResult[i];\n                    Debug.Assert(current.AssemblySymbol is object);\n\n                    var compilationData = assemblies[i] as AssemblyDataForCompilation;\n                    if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    }\n                } 224118"];
1993 [label="ref BoundInputAssembly current = ref bindingResult[i]; 224119"];
1994 [label="Debug.Assert(current.AssemblySymbol is object); 224120"];
1995 [label="var compilationData = assemblies[i] as AssemblyDataForCompilation; 224121"];
1996 [label="if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    } 224122"];
1997 [label="if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    } 224123"];
1998 [label="var fileData = (AssemblyDataForFile)assemblies[i]; 224124"];
1999 [label="fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol); 224125"];
2000 [label="fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol); 224126"];
2001 [label="Debug.Assert(current.AssemblySymbol is object); 224127"];
2002 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 224128"];
2003 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 224129"];
2004 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 224130"];
2005 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 224131"];
2006 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 224132"];
2007 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 224133"];
2008 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 224134"];
2009 [label="ReferenceEquals(corLibrary, assemblySymbol) 224135"];
2010 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 224136"];
2011 [label="assemblySymbol.SourceModule 224137"];
2012 [label="get { return (SourceModuleSymbol)this.Modules[0]; } 224138"];
2013 [label="this.Modules 224139"];
2014 [label="get\n            {\n                return _modules;\n            } 224140"];
2015 [label="return _modules; 224141"];
2016 [label="return (SourceModuleSymbol)this.Modules[0]; 224142"];
2017 [label="return (SourceModuleSymbol)this.Modules[0]; 224143"];
2018 [label="assemblySymbol.SourceModule.GetReferencedAssemblySymbols() 224144"];
2019 [label="param GetReferencedAssemblySymbols(this) 224145"];
2020 [label="AssertReferencesInitialized() 224146"];
2021 [label="param AssertReferencesInitialized(this) 224147"];
2022 [label="Debug.Assert(_moduleReferences != null); 224148"];
2023 [label="Debug.Assert(_moduleReferences != null); 224149"];
2024 [label="AssertReferencesInitialized(); 224150"];
2025 [label="return _moduleReferences.Symbols; 224151"];
2026 [label="assemblySymbol.SourceModule 224152"];
2027 [label="get { return (SourceModuleSymbol)this.Modules[0]; } 224153"];
2028 [label="this.Modules 224154"];
2029 [label="get\n            {\n                return _modules;\n            } 224155"];
2030 [label="return _modules; 224156"];
2031 [label="return (SourceModuleSymbol)this.Modules[0]; 224157"];
2032 [label="assemblySymbol.SourceModule.GetUnifiedAssemblies() 224158"];
2033 [label="param GetUnifiedAssemblies(this) 224159"];
2034 [label="AssertReferencesInitialized() 224160"];
2035 [label="param AssertReferencesInitialized(this) 224161"];
2036 [label="Debug.Assert(_moduleReferences != null); 224162"];
2037 [label="Debug.Assert(_moduleReferences != null); 224163"];
2038 [label="AssertReferencesInitialized(); 224164"];
2039 [label="return _moduleReferences.UnifiedAssemblies; 224165"];
2040 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 224166"];
2041 [label="Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference); 224167"];
2042 [label="Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference); 224168"];
2043 [label="compilation._referenceManager 224169"];
2044 [label="compilation._lazyAssemblySymbol 224170"];
2045 [label="return true; 224171"];
2046 [label="resolutionDiagnostics.Free(); 224172"];
2047 [label="assemblyReferencesBySimpleName.Free(); 224173"];
2048 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 224174"];
2049 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 224175"];
2050 [label="AssertBound(); 224176"];
2051 [label="Debug.Assert(compilation._lazyAssemblySymbol is object); 224177"];
2052 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 224178"];
2053 [label="Debug.Assert(_lazyAssemblySymbol is object); 224179"];
2054 [label="return _referenceManager; 224180"];
2055 [label="GetBoundReferenceManager(); 224181"];
2056 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 224182"];
2057 [label="return _lazyAssemblySymbol; 224183"];
2058 [label="return SourceAssembly; 224184"];
2059 [label="return Assembly.Modules[0]; 224185"];
2060 [label="Assembly.Modules 224186"];
2061 [label="get\n            {\n                return _modules;\n            } 224187"];
2062 [label="return Assembly.Modules[0]; 224188"];
2063 [label="var globalNS = compilation.SourceModule.GlobalNamespace; 224189"];
2064 [label="compilation.SourceModule.GlobalNamespace 224190"];
2065 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 224191"];
2066 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 224192"];
2067 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 224193"];
2068 [label="var diagnostics = DiagnosticBag.GetInstance(); 224194"];
2069 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 224195"];
2070 [label="DeclaringCompilation 224196"];
2071 [label="get\n            {\n                return _assemblySymbol.DeclaringCompilation;\n            } 224197"];
2072 [label="_assemblySymbol.DeclaringCompilation 224198"];
2073 [label="get\n            {\n                return _compilation;\n            } 224199"];
2074 [label="return _compilation; 224200"];
2075 [label="return _assemblySymbol.DeclaringCompilation; 224201"];
2076 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 224202"];
2077 [label="DeclaringCompilation.MergedRootDeclaration 224203"];
2078 [label="get\n            {\n                return Declarations.GetMergedRoot(this);\n            } 224204"];
2079 [label="Declarations 224205"];
2080 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 224206"];
2081 [label="return Declarations.GetMergedRoot(this); 224207"];
2082 [label="return Declarations.GetMergedRoot(this); 224208"];
2083 [label="return Declarations.GetMergedRoot(this); 224209"];
2084 [label="0x1 224210"];
2085 [label="LazyAllMembersIsSorted = 0x1 224211"];
2086 [label="d =>\n            new NamespaceDeclarationSyntaxReference(d.SyntaxReference) 224212"];
2087 [label="s_declaringSyntaxReferencesSelector = d =>\n            new NamespaceDeclarationSyntaxReference(d.SyntaxReference) 224213"];
2088 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 224214"];
2089 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 224215"];
2090 [label="new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics) 224216"];
2091 [label="param SourceNamespaceSymbol(SourceModuleSymbol module) 224217"];
2092 [label="param SourceNamespaceSymbol(Symbol container) 224218"];
2093 [label="param SourceNamespaceSymbol(MergedNamespaceDeclaration mergedDeclaration) 224219"];
2094 [label="param SourceNamespaceSymbol(DiagnosticBag diagnostics) 224220"];
2095 [label="param SourceNamespaceSymbol(this) 224221"];
2096 [label="param SourceNamespaceSymbol(this) 224222"];
2097 [label="_module 224223"];
2098 [label="_container 224224"];
2099 [label="_mergedDeclaration 224225"];
2100 [label="_nameToMembersMap 224226"];
2101 [label="_nameToTypeMembersMap 224227"];
2102 [label="_flags 224228"];
2103 [label="new LexicalSortKey() { _treeOrdinal = -1, _position = 0 } 224229"];
2104 [label="1 224230"];
2105 [label="_treeOrdinal 224231"];
2106 [label="0 224232"];
2107 [label="_position 224233"];
2108 [label="NotInSource = new LexicalSortKey() { _treeOrdinal = -1, _position = 0 } 224234"];
2109 [label="new LexicalSortKey() { _treeOrdinal = -1, _position = -1 } 224235"];
2110 [label="1 224236"];
2111 [label="_treeOrdinal 224237"];
2112 [label="1 224238"];
2113 [label="_position 224239"];
2114 [label="NotInitialized = new LexicalSortKey() { _treeOrdinal = -1, _position = -1 } 224240"];
2115 [label="new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue - 1 } 224241"];
2116 [label="_treeOrdinal 224242"];
2117 [label="1 224243"];
2118 [label="int.MaxValue - 1 224244"];
2119 [label="_position 224245"];
2120 [label="SynthesizedCtor = new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue - 1 } 224246"];
2121 [label="new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue } 224247"];
2122 [label="_treeOrdinal 224248"];
2123 [label="_position 224249"];
2124 [label="SynthesizedCCtor = new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue } 224250"];
2125 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 224251"];
2126 [label="Debug.Assert(mergedDeclaration != null); 224252"];
2127 [label="Debug.Assert(mergedDeclaration != null); 224253"];
2128 [label="_module 224254"];
2129 [label="_container 224255"];
2130 [label="_mergedDeclaration 224256"];
2131 [label="foreach (var singleDeclaration in mergedDeclaration.Declarations)\n            {\n                diagnostics.AddRange(singleDeclaration.Diagnostics);\n            } 224257"];
2132 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 224258"];
2133 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 224259"];
2134 [label="Debug.Assert(diagnostics.IsEmptyWithoutResolution); 224260"];
2135 [label="diagnostics.Free(); 224261"];
2136 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 224262"];
2137 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 224263"];
2138 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 224264"];
2139 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 224265"];
2140 [label="return _globalNamespace; 224266"];
2141 [label="var classTest = globalNS.GetTypeMembers('A').Single() as NamedTypeSymbol; 224267"];
2142 [label="globalNS.GetTypeMembers('A') 224268"];
2143 [label="param GetTypeMembers(string name) 224269"];
2144 [label="param GetTypeMembers(this) 224270"];
2145 [label="ImmutableArray<NamedTypeSymbol> members; 224271"];
2146 [label="members 224272"];
2147 [label="this.GetNameToTypeMembersMap() 224273"];
2148 [label="param GetNameToTypeMembersMap(this) 224274"];
2149 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 224275"];
2150 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 224276"];
2151 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 224277"];
2152 [label="GetNameToMembersMap() 224278"];
2153 [label="param GetNameToMembersMap(this) 224279"];
2154 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 224280"];
2155 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 224281"];
2156 [label="var diagnostics = DiagnosticBag.GetInstance(); 224282"];
2157 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 224283"];
2158 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 224284"];
2159 [label="MakeNameToMembersMap(diagnostics) 224285"];
2160 [label="param MakeNameToMembersMap(DiagnosticBag diagnostics) 224286"];
2161 [label="param MakeNameToMembersMap(this) 224287"];
2162 [label="var builder = new NameToSymbolMapBuilder(_mergedDeclaration.Children.Length); 224288"];
2163 [label="_mergedDeclaration.Children 224289"];
2164 [label="param NameToSymbolMapBuilder(int capacity) 224290"];
2165 [label="param NameToSymbolMapBuilder(this) 224291"];
2166 [label="_dictionary = new Dictionary<string, object>(capacity, StringOrdinalComparer.Instance); 224292"];
2167 [label="_dictionary = new Dictionary<string, object>(capacity, StringOrdinalComparer.Instance); 224293"];
2168 [label="_dictionary 224294"];
2169 [label="foreach (var declaration in _mergedDeclaration.Children)\n            {\n                builder.Add(BuildSymbol(declaration, diagnostics));\n            } 224295"];
2170 [label="builder.Add(BuildSymbol(declaration, diagnostics)); 224296"];
2171 [label="builder.Add(BuildSymbol(declaration, diagnostics)); 224297"];
2172 [label="BuildSymbol(declaration, diagnostics) 224298"];
2173 [label="param BuildSymbol(MergedNamespaceOrTypeDeclaration declaration) 224299"];
2174 [label="param BuildSymbol(DiagnosticBag diagnostics) 224300"];
2175 [label="param BuildSymbol(this) 224301"];
2176 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Namespace:\n                    return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.Script:\n                case DeclarationKind.Submission:\n                case DeclarationKind.ImplicitClass:\n                    return new ImplicitNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.SimpleProgram:\n                    return new SimpleProgramNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(declaration.Kind);\n            } 224302"];
2177 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 224303"];
2178 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 224304"];
2179 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 224305"];
2180 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 224306"];
2181 [label="new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics) 224307"];
2182 [label="param SourceNamedTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 224308"];
2183 [label="param SourceNamedTypeSymbol(MergedTypeDeclaration declaration) 224309"];
2184 [label="param SourceNamedTypeSymbol(DiagnosticBag diagnostics) 224310"];
2185 [label="param SourceNamedTypeSymbol(TupleExtraData tupleData = null) 224311"];
2186 [label="param SourceNamedTypeSymbol(this) 224312"];
2187 [label="false 224313"];
2188 [label="considerName: false 224314"];
2189 [label="false 224315"];
2190 [label="considerExplicitlyImplementedInterfaces: false 224316"];
2191 [label="true 224317"];
2192 [label="considerReturnType: true 224318"];
2193 [label="false 224319"];
2194 [label="considerTypeConstraints: false 224320"];
2195 [label="true 224321"];
2196 [label="considerRefKindDifferences: true 224322"];
2197 [label="true 224323"];
2198 [label="considerCallingConvention: true 224324"];
2199 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 224325"];
2200 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerRefKindDifferences: true,\n            considerCallingConvention: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224326"];
2201 [label="param MemberSignatureComparer(bool considerName) 224327"];
2202 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 224328"];
2203 [label="param MemberSignatureComparer(bool considerReturnType) 224329"];
2204 [label="param MemberSignatureComparer(bool considerTypeConstraints) 224330"];
2205 [label="param MemberSignatureComparer(bool considerCallingConvention) 224331"];
2206 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 224332"];
2207 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 224333"];
2208 [label="param MemberSignatureComparer(this) 224334"];
2209 [label="_considerName 224335"];
2210 [label="_considerExplicitlyImplementedInterfaces 224336"];
2211 [label="_considerReturnType 224337"];
2212 [label="_considerTypeConstraints 224338"];
2213 [label="_considerCallingConvention 224339"];
2214 [label="_considerRefKindDifferences 224340"];
2215 [label="_typeComparison 224341"];
2216 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224342"];
2217 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224343"];
2218 [label="_considerName 224344"];
2219 [label="_considerExplicitlyImplementedInterfaces 224345"];
2220 [label="_considerReturnType 224346"];
2221 [label="_considerTypeConstraints 224347"];
2222 [label="_considerCallingConvention 224348"];
2223 [label="_considerRefKindDifferences 224349"];
2224 [label="_typeComparison 224350"];
2225 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224351"];
2226 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224352"];
2227 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 224353"];
2228 [label="ExplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerRefKindDifferences: true,\n            considerCallingConvention: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224354"];
2229 [label="true 224355"];
2230 [label="considerName: true 224356"];
2231 [label="true 224357"];
2232 [label="considerExplicitlyImplementedInterfaces: true 224358"];
2233 [label="true 224359"];
2234 [label="considerReturnType: true 224360"];
2235 [label="false 224361"];
2236 [label="considerTypeConstraints: false 224362"];
2237 [label="true 224363"];
2238 [label="considerCallingConvention: true 224364"];
2239 [label="true 224365"];
2240 [label="considerRefKindDifferences: true 224366"];
2241 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 224367"];
2242 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224368"];
2243 [label="param MemberSignatureComparer(bool considerName) 224369"];
2244 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 224370"];
2245 [label="param MemberSignatureComparer(bool considerReturnType) 224371"];
2246 [label="param MemberSignatureComparer(bool considerTypeConstraints) 224372"];
2247 [label="param MemberSignatureComparer(bool considerCallingConvention) 224373"];
2248 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 224374"];
2249 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 224375"];
2250 [label="param MemberSignatureComparer(this) 224376"];
2251 [label="_considerName 224377"];
2252 [label="_considerExplicitlyImplementedInterfaces 224378"];
2253 [label="_considerReturnType 224379"];
2254 [label="_considerTypeConstraints 224380"];
2255 [label="_considerCallingConvention 224381"];
2256 [label="_considerRefKindDifferences 224382"];
2257 [label="_typeComparison 224383"];
2258 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224384"];
2259 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224385"];
2260 [label="_considerName 224386"];
2261 [label="_considerExplicitlyImplementedInterfaces 224387"];
2262 [label="_considerReturnType 224388"];
2263 [label="_considerTypeConstraints 224389"];
2264 [label="_considerCallingConvention 224390"];
2265 [label="_considerRefKindDifferences 224391"];
2266 [label="_typeComparison 224392"];
2267 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224393"];
2268 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224394"];
2269 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 224395"];
2270 [label="CSharpImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224396"];
2271 [label="true 224397"];
2272 [label="considerName: true 224398"];
2273 [label="true 224399"];
2274 [label="considerExplicitlyImplementedInterfaces: true 224400"];
2275 [label="false 224401"];
2276 [label="considerReturnType: false 224402"];
2277 [label="false 224403"];
2278 [label="considerTypeConstraints: false 224404"];
2279 [label="false 224405"];
2280 [label="considerCallingConvention: false 224406"];
2281 [label="true 224407"];
2282 [label="considerRefKindDifferences: true 224408"];
2283 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 224409"];
2284 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224410"];
2285 [label="param MemberSignatureComparer(bool considerName) 224411"];
2286 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 224412"];
2287 [label="param MemberSignatureComparer(bool considerReturnType) 224413"];
2288 [label="param MemberSignatureComparer(bool considerTypeConstraints) 224414"];
2289 [label="param MemberSignatureComparer(bool considerCallingConvention) 224415"];
2290 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 224416"];
2291 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 224417"];
2292 [label="param MemberSignatureComparer(this) 224418"];
2293 [label="_considerName 224419"];
2294 [label="_considerExplicitlyImplementedInterfaces 224420"];
2295 [label="_considerReturnType 224421"];
2296 [label="_considerTypeConstraints 224422"];
2297 [label="_considerCallingConvention 224423"];
2298 [label="_considerRefKindDifferences 224424"];
2299 [label="_typeComparison 224425"];
2300 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224426"];
2301 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224427"];
2302 [label="_considerName 224428"];
2303 [label="_considerExplicitlyImplementedInterfaces 224429"];
2304 [label="_considerReturnType 224430"];
2305 [label="_considerTypeConstraints 224431"];
2306 [label="_considerCallingConvention 224432"];
2307 [label="_considerRefKindDifferences 224433"];
2308 [label="_typeComparison 224434"];
2309 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224435"];
2310 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224436"];
2311 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 224437"];
2312 [label="CSharpCloseImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224438"];
2313 [label="true 224439"];
2314 [label="considerName: true 224440"];
2315 [label="true 224441"];
2316 [label="considerExplicitlyImplementedInterfaces: true 224442"];
2317 [label="false 224443"];
2318 [label="considerReturnType: false 224444"];
2319 [label="false 224445"];
2320 [label="considerTypeConstraints: false 224446"];
2321 [label="false 224447"];
2322 [label="considerCallingConvention: false 224448"];
2323 [label="false 224449"];
2324 [label="considerRefKindDifferences: false 224450"];
2325 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 224451"];
2326 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224452"];
2327 [label="param MemberSignatureComparer(bool considerName) 224453"];
2328 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 224454"];
2329 [label="param MemberSignatureComparer(bool considerReturnType) 224455"];
2330 [label="param MemberSignatureComparer(bool considerTypeConstraints) 224456"];
2331 [label="param MemberSignatureComparer(bool considerCallingConvention) 224457"];
2332 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 224458"];
2333 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 224459"];
2334 [label="param MemberSignatureComparer(this) 224460"];
2335 [label="_considerName 224461"];
2336 [label="_considerExplicitlyImplementedInterfaces 224462"];
2337 [label="_considerReturnType 224463"];
2338 [label="_considerTypeConstraints 224464"];
2339 [label="_considerCallingConvention 224465"];
2340 [label="_considerRefKindDifferences 224466"];
2341 [label="_typeComparison 224467"];
2342 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224468"];
2343 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224469"];
2344 [label="_considerName 224470"];
2345 [label="_considerExplicitlyImplementedInterfaces 224471"];
2346 [label="_considerReturnType 224472"];
2347 [label="_considerTypeConstraints 224473"];
2348 [label="_considerCallingConvention 224474"];
2349 [label="_considerRefKindDifferences 224475"];
2350 [label="_typeComparison 224476"];
2351 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224477"];
2352 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224478"];
2353 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 224479"];
2354 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 224480"];
2355 [label="_typeComparison 224481"];
2356 [label="DuplicateSourceComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224482"];
2357 [label="true 224483"];
2358 [label="considerName: true 224484"];
2359 [label="true 224485"];
2360 [label="considerExplicitlyImplementedInterfaces: true 224486"];
2361 [label="false 224487"];
2362 [label="considerReturnType: false 224488"];
2363 [label="false 224489"];
2364 [label="considerTypeConstraints: false 224490"];
2365 [label="false 224491"];
2366 [label="considerCallingConvention: false 224492"];
2367 [label="true 224493"];
2368 [label="considerRefKindDifferences: true 224494"];
2369 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 224495"];
2370 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224496"];
2371 [label="param MemberSignatureComparer(bool considerName) 224497"];
2372 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 224498"];
2373 [label="param MemberSignatureComparer(bool considerReturnType) 224499"];
2374 [label="param MemberSignatureComparer(bool considerTypeConstraints) 224500"];
2375 [label="param MemberSignatureComparer(bool considerCallingConvention) 224501"];
2376 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 224502"];
2377 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 224503"];
2378 [label="param MemberSignatureComparer(this) 224504"];
2379 [label="_considerName 224505"];
2380 [label="_considerExplicitlyImplementedInterfaces 224506"];
2381 [label="_considerReturnType 224507"];
2382 [label="_considerTypeConstraints 224508"];
2383 [label="_considerCallingConvention 224509"];
2384 [label="_considerRefKindDifferences 224510"];
2385 [label="_typeComparison 224511"];
2386 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224512"];
2387 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224513"];
2388 [label="_considerName 224514"];
2389 [label="_considerExplicitlyImplementedInterfaces 224515"];
2390 [label="_considerReturnType 224516"];
2391 [label="_considerTypeConstraints 224517"];
2392 [label="_considerCallingConvention 224518"];
2393 [label="_considerRefKindDifferences 224519"];
2394 [label="_typeComparison 224520"];
2395 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224521"];
2396 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224522"];
2397 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 224523"];
2398 [label="RecordAPISignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224524"];
2399 [label="true 224525"];
2400 [label="considerName: true 224526"];
2401 [label="true 224527"];
2402 [label="considerExplicitlyImplementedInterfaces: true 224528"];
2403 [label="false 224529"];
2404 [label="considerReturnType: false 224530"];
2405 [label="false 224531"];
2406 [label="considerTypeConstraints: false 224532"];
2407 [label="false 224533"];
2408 [label="considerCallingConvention: false 224534"];
2409 [label="true 224535"];
2410 [label="considerRefKindDifferences: true 224536"];
2411 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 224537"];
2412 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224538"];
2413 [label="param MemberSignatureComparer(bool considerName) 224539"];
2414 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 224540"];
2415 [label="param MemberSignatureComparer(bool considerReturnType) 224541"];
2416 [label="param MemberSignatureComparer(bool considerTypeConstraints) 224542"];
2417 [label="param MemberSignatureComparer(bool considerCallingConvention) 224543"];
2418 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 224544"];
2419 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 224545"];
2420 [label="param MemberSignatureComparer(this) 224546"];
2421 [label="_considerName 224547"];
2422 [label="_considerExplicitlyImplementedInterfaces 224548"];
2423 [label="_considerReturnType 224549"];
2424 [label="_considerTypeConstraints 224550"];
2425 [label="_considerCallingConvention 224551"];
2426 [label="_considerRefKindDifferences 224552"];
2427 [label="_typeComparison 224553"];
2428 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224554"];
2429 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224555"];
2430 [label="_considerName 224556"];
2431 [label="_considerExplicitlyImplementedInterfaces 224557"];
2432 [label="_considerReturnType 224558"];
2433 [label="_considerTypeConstraints 224559"];
2434 [label="_considerCallingConvention 224560"];
2435 [label="_considerRefKindDifferences 224561"];
2436 [label="_typeComparison 224562"];
2437 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224563"];
2438 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224564"];
2439 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 224565"];
2440 [label="PartialMethodsComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224566"];
2441 [label="true 224567"];
2442 [label="considerName: true 224568"];
2443 [label="false 224569"];
2444 [label="considerExplicitlyImplementedInterfaces: false 224570"];
2445 [label="false 224571"];
2446 [label="considerReturnType: false 224572"];
2447 [label="false 224573"];
2448 [label="considerTypeConstraints: false 224574"];
2449 [label="false 224575"];
2450 [label="considerCallingConvention: false 224576"];
2451 [label="true 224577"];
2452 [label="considerRefKindDifferences: true 224578"];
2453 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 224579"];
2454 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224580"];
2455 [label="param MemberSignatureComparer(bool considerName) 224581"];
2456 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 224582"];
2457 [label="param MemberSignatureComparer(bool considerReturnType) 224583"];
2458 [label="param MemberSignatureComparer(bool considerTypeConstraints) 224584"];
2459 [label="param MemberSignatureComparer(bool considerCallingConvention) 224585"];
2460 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 224586"];
2461 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 224587"];
2462 [label="param MemberSignatureComparer(this) 224588"];
2463 [label="_considerName 224589"];
2464 [label="_considerExplicitlyImplementedInterfaces 224590"];
2465 [label="_considerReturnType 224591"];
2466 [label="_considerTypeConstraints 224592"];
2467 [label="_considerCallingConvention 224593"];
2468 [label="_considerRefKindDifferences 224594"];
2469 [label="_typeComparison 224595"];
2470 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224596"];
2471 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224597"];
2472 [label="_considerName 224598"];
2473 [label="_considerExplicitlyImplementedInterfaces 224599"];
2474 [label="_considerReturnType 224600"];
2475 [label="_considerTypeConstraints 224601"];
2476 [label="_considerCallingConvention 224602"];
2477 [label="_considerRefKindDifferences 224603"];
2478 [label="_typeComparison 224604"];
2479 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224605"];
2480 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224606"];
2481 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 224607"];
2482 [label="CSharpOverrideComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224608"];
2483 [label="true 224609"];
2484 [label="considerName: true 224610"];
2485 [label="false 224611"];
2486 [label="considerExplicitlyImplementedInterfaces: false 224612"];
2487 [label="true 224613"];
2488 [label="considerReturnType: true 224614"];
2489 [label="false 224615"];
2490 [label="considerTypeConstraints: false 224616"];
2491 [label="false 224617"];
2492 [label="considerCallingConvention: false 224618"];
2493 [label="false 224619"];
2494 [label="considerRefKindDifferences: false 224620"];
2495 [label="TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames 224621"];
2496 [label="typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames 224622"];
2497 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames) 224623"];
2498 [label="param MemberSignatureComparer(bool considerName) 224624"];
2499 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 224625"];
2500 [label="param MemberSignatureComparer(bool considerReturnType) 224626"];
2501 [label="param MemberSignatureComparer(bool considerTypeConstraints) 224627"];
2502 [label="param MemberSignatureComparer(bool considerCallingConvention) 224628"];
2503 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 224629"];
2504 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 224630"];
2505 [label="param MemberSignatureComparer(this) 224631"];
2506 [label="_considerName 224632"];
2507 [label="_considerExplicitlyImplementedInterfaces 224633"];
2508 [label="_considerReturnType 224634"];
2509 [label="_considerTypeConstraints 224635"];
2510 [label="_considerCallingConvention 224636"];
2511 [label="_considerRefKindDifferences 224637"];
2512 [label="_typeComparison 224638"];
2513 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224639"];
2514 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224640"];
2515 [label="_considerName 224641"];
2516 [label="_considerExplicitlyImplementedInterfaces 224642"];
2517 [label="_considerReturnType 224643"];
2518 [label="_considerTypeConstraints 224644"];
2519 [label="_considerCallingConvention 224645"];
2520 [label="_considerRefKindDifferences 224646"];
2521 [label="_typeComparison 224647"];
2522 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224648"];
2523 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224649"];
2524 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 224650"];
2525 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 224651"];
2526 [label="_typeComparison 224652"];
2527 [label="CSharpWithTupleNamesComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames) 224653"];
2528 [label="true 224654"];
2529 [label="considerName: true 224655"];
2530 [label="false 224656"];
2531 [label="considerExplicitlyImplementedInterfaces: false 224657"];
2532 [label="true 224658"];
2533 [label="considerReturnType: true 224659"];
2534 [label="false 224660"];
2535 [label="considerTypeConstraints: false 224661"];
2536 [label="false 224662"];
2537 [label="considerCallingConvention: false 224663"];
2538 [label="false 224664"];
2539 [label="considerRefKindDifferences: false 224665"];
2540 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 224666"];
2541 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224667"];
2542 [label="param MemberSignatureComparer(bool considerName) 224668"];
2543 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 224669"];
2544 [label="param MemberSignatureComparer(bool considerReturnType) 224670"];
2545 [label="param MemberSignatureComparer(bool considerTypeConstraints) 224671"];
2546 [label="param MemberSignatureComparer(bool considerCallingConvention) 224672"];
2547 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 224673"];
2548 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 224674"];
2549 [label="param MemberSignatureComparer(this) 224675"];
2550 [label="_considerName 224676"];
2551 [label="_considerExplicitlyImplementedInterfaces 224677"];
2552 [label="_considerReturnType 224678"];
2553 [label="_considerTypeConstraints 224679"];
2554 [label="_considerCallingConvention 224680"];
2555 [label="_considerRefKindDifferences 224681"];
2556 [label="_typeComparison 224682"];
2557 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224683"];
2558 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224684"];
2559 [label="_considerName 224685"];
2560 [label="_considerExplicitlyImplementedInterfaces 224686"];
2561 [label="_considerReturnType 224687"];
2562 [label="_considerTypeConstraints 224688"];
2563 [label="_considerCallingConvention 224689"];
2564 [label="_considerRefKindDifferences 224690"];
2565 [label="_typeComparison 224691"];
2566 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224692"];
2567 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224693"];
2568 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 224694"];
2569 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 224695"];
2570 [label="_typeComparison 224696"];
2571 [label="CSharpWithoutTupleNamesComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224697"];
2572 [label="false 224698"];
2573 [label="considerName: false 224699"];
2574 [label="false 224700"];
2575 [label="considerExplicitlyImplementedInterfaces: false 224701"];
2576 [label="false 224702"];
2577 [label="considerReturnType: false 224703"];
2578 [label="false 224704"];
2579 [label="considerTypeConstraints: false 224705"];
2580 [label="false 224706"];
2581 [label="considerCallingConvention: false 224707"];
2582 [label="true 224708"];
2583 [label="considerRefKindDifferences: true 224709"];
2584 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 224710"];
2585 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false, //Bug: DevDiv #15775\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224711"];
2586 [label="param MemberSignatureComparer(bool considerName) 224712"];
2587 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 224713"];
2588 [label="param MemberSignatureComparer(bool considerReturnType) 224714"];
2589 [label="param MemberSignatureComparer(bool considerTypeConstraints) 224715"];
2590 [label="param MemberSignatureComparer(bool considerCallingConvention) 224716"];
2591 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 224717"];
2592 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 224718"];
2593 [label="param MemberSignatureComparer(this) 224719"];
2594 [label="_considerName 224720"];
2595 [label="_considerExplicitlyImplementedInterfaces 224721"];
2596 [label="_considerReturnType 224722"];
2597 [label="_considerTypeConstraints 224723"];
2598 [label="_considerCallingConvention 224724"];
2599 [label="_considerRefKindDifferences 224725"];
2600 [label="_typeComparison 224726"];
2601 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224727"];
2602 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224728"];
2603 [label="_considerName 224729"];
2604 [label="_considerExplicitlyImplementedInterfaces 224730"];
2605 [label="_considerReturnType 224731"];
2606 [label="_considerTypeConstraints 224732"];
2607 [label="_considerCallingConvention 224733"];
2608 [label="_considerRefKindDifferences 224734"];
2609 [label="_typeComparison 224735"];
2610 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224736"];
2611 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224737"];
2612 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 224738"];
2613 [label="CSharpAccessorOverrideComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false, //Bug: DevDiv #15775\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 224739"];
2614 [label="true 224740"];
2615 [label="considerName: true 224741"];
2616 [label="false 224742"];
2617 [label="considerExplicitlyImplementedInterfaces: false 224743"];
2618 [label="true 224744"];
2619 [label="considerReturnType: true 224745"];
2620 [label="false 224746"];
2621 [label="considerTypeConstraints: false 224747"];
2622 [label="false 224748"];
2623 [label="considerCallingConvention: false 224749"];
2624 [label="true 224750"];
2625 [label="considerRefKindDifferences: true 224751"];
2626 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 224752"];
2627 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 224753"];
2628 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 224754"];
2629 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 224755"];
2630 [label="param MemberSignatureComparer(bool considerName) 224756"];
2631 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 224757"];
2632 [label="param MemberSignatureComparer(bool considerReturnType) 224758"];
2633 [label="param MemberSignatureComparer(bool considerTypeConstraints) 224759"];
2634 [label="param MemberSignatureComparer(bool considerCallingConvention) 224760"];
2635 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 224761"];
2636 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 224762"];
2637 [label="param MemberSignatureComparer(this) 224763"];
2638 [label="_considerName 224764"];
2639 [label="_considerExplicitlyImplementedInterfaces 224765"];
2640 [label="_considerReturnType 224766"];
2641 [label="_considerTypeConstraints 224767"];
2642 [label="_considerCallingConvention 224768"];
2643 [label="_considerRefKindDifferences 224769"];
2644 [label="_typeComparison 224770"];
2645 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224771"];
2646 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224772"];
2647 [label="_considerName 224773"];
2648 [label="_considerExplicitlyImplementedInterfaces 224774"];
2649 [label="_considerReturnType 224775"];
2650 [label="_considerTypeConstraints 224776"];
2651 [label="_considerCallingConvention 224777"];
2652 [label="_considerRefKindDifferences 224778"];
2653 [label="_typeComparison 224779"];
2654 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224780"];
2655 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224781"];
2656 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 224782"];
2657 [label="CSharpCustomModifierOverrideComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 224783"];
2658 [label="false 224784"];
2659 [label="considerName: false 224785"];
2660 [label="false 224786"];
2661 [label="considerExplicitlyImplementedInterfaces: false 224787"];
2662 [label="false 224788"];
2663 [label="considerReturnType: false 224789"];
2664 [label="false 224790"];
2665 [label="considerTypeConstraints: false 224791"];
2666 [label="false 224792"];
2667 [label="considerCallingConvention: false 224793"];
2668 [label="false 224794"];
2669 [label="considerRefKindDifferences: false 224795"];
2670 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 224796"];
2671 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 224797"];
2672 [label="typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 224798"];
2673 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 224799"];
2674 [label="param MemberSignatureComparer(bool considerName) 224800"];
2675 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 224801"];
2676 [label="param MemberSignatureComparer(bool considerReturnType) 224802"];
2677 [label="param MemberSignatureComparer(bool considerTypeConstraints) 224803"];
2678 [label="param MemberSignatureComparer(bool considerCallingConvention) 224804"];
2679 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 224805"];
2680 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 224806"];
2681 [label="param MemberSignatureComparer(this) 224807"];
2682 [label="_considerName 224808"];
2683 [label="_considerExplicitlyImplementedInterfaces 224809"];
2684 [label="_considerReturnType 224810"];
2685 [label="_considerTypeConstraints 224811"];
2686 [label="_considerCallingConvention 224812"];
2687 [label="_considerRefKindDifferences 224813"];
2688 [label="_typeComparison 224814"];
2689 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224815"];
2690 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224816"];
2691 [label="_considerName 224817"];
2692 [label="_considerExplicitlyImplementedInterfaces 224818"];
2693 [label="_considerReturnType 224819"];
2694 [label="_considerTypeConstraints 224820"];
2695 [label="_considerCallingConvention 224821"];
2696 [label="_considerRefKindDifferences 224822"];
2697 [label="_typeComparison 224823"];
2698 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224824"];
2699 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224825"];
2700 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 224826"];
2701 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 224827"];
2702 [label="_typeComparison 224828"];
2703 [label="SloppyOverrideComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 224829"];
2704 [label="true 224830"];
2705 [label="considerName: true 224831"];
2706 [label="false 224832"];
2707 [label="considerExplicitlyImplementedInterfaces: false 224833"];
2708 [label="true 224834"];
2709 [label="considerReturnType: true 224835"];
2710 [label="false 224836"];
2711 [label="considerTypeConstraints: false 224837"];
2712 [label="true 224838"];
2713 [label="considerCallingConvention: true 224839"];
2714 [label="false 224840"];
2715 [label="considerRefKindDifferences: false 224841"];
2716 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 224842"];
2717 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 224843"];
2718 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 224844"];
2719 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 224845"];
2720 [label="param MemberSignatureComparer(bool considerName) 224846"];
2721 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 224847"];
2722 [label="param MemberSignatureComparer(bool considerReturnType) 224848"];
2723 [label="param MemberSignatureComparer(bool considerTypeConstraints) 224849"];
2724 [label="param MemberSignatureComparer(bool considerCallingConvention) 224850"];
2725 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 224851"];
2726 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 224852"];
2727 [label="param MemberSignatureComparer(this) 224853"];
2728 [label="_considerName 224854"];
2729 [label="_considerExplicitlyImplementedInterfaces 224855"];
2730 [label="_considerReturnType 224856"];
2731 [label="_considerTypeConstraints 224857"];
2732 [label="_considerCallingConvention 224858"];
2733 [label="_considerRefKindDifferences 224859"];
2734 [label="_typeComparison 224860"];
2735 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224861"];
2736 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224862"];
2737 [label="_considerName 224863"];
2738 [label="_considerExplicitlyImplementedInterfaces 224864"];
2739 [label="_considerReturnType 224865"];
2740 [label="_considerTypeConstraints 224866"];
2741 [label="_considerCallingConvention 224867"];
2742 [label="_considerRefKindDifferences 224868"];
2743 [label="_typeComparison 224869"];
2744 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224870"];
2745 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224871"];
2746 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 224872"];
2747 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 224873"];
2748 [label="_typeComparison 224874"];
2749 [label="RuntimeSignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 224875"];
2750 [label="true 224876"];
2751 [label="considerName: true 224877"];
2752 [label="false 224878"];
2753 [label="considerExplicitlyImplementedInterfaces: false 224879"];
2754 [label="true 224880"];
2755 [label="considerReturnType: true 224881"];
2756 [label="false 224882"];
2757 [label="considerTypeConstraints: false 224883"];
2758 [label="true 224884"];
2759 [label="considerCallingConvention: true 224885"];
2760 [label="true 224886"];
2761 [label="considerRefKindDifferences: true 224887"];
2762 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 224888"];
2763 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 224889"];
2764 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 224890"];
2765 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 224891"];
2766 [label="param MemberSignatureComparer(bool considerName) 224892"];
2767 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 224893"];
2768 [label="param MemberSignatureComparer(bool considerReturnType) 224894"];
2769 [label="param MemberSignatureComparer(bool considerTypeConstraints) 224895"];
2770 [label="param MemberSignatureComparer(bool considerCallingConvention) 224896"];
2771 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 224897"];
2772 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 224898"];
2773 [label="param MemberSignatureComparer(this) 224899"];
2774 [label="_considerName 224900"];
2775 [label="_considerExplicitlyImplementedInterfaces 224901"];
2776 [label="_considerReturnType 224902"];
2777 [label="_considerTypeConstraints 224903"];
2778 [label="_considerCallingConvention 224904"];
2779 [label="_considerRefKindDifferences 224905"];
2780 [label="_typeComparison 224906"];
2781 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224907"];
2782 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224908"];
2783 [label="_considerName 224909"];
2784 [label="_considerExplicitlyImplementedInterfaces 224910"];
2785 [label="_considerReturnType 224911"];
2786 [label="_considerTypeConstraints 224912"];
2787 [label="_considerCallingConvention 224913"];
2788 [label="_considerRefKindDifferences 224914"];
2789 [label="_typeComparison 224915"];
2790 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224916"];
2791 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224917"];
2792 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 224918"];
2793 [label="RuntimePlusRefOutSignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 224919"];
2794 [label="true 224920"];
2795 [label="considerName: true 224921"];
2796 [label="true 224922"];
2797 [label="considerExplicitlyImplementedInterfaces: true 224923"];
2798 [label="true 224924"];
2799 [label="considerReturnType: true 224925"];
2800 [label="false 224926"];
2801 [label="considerTypeConstraints: false 224927"];
2802 [label="true 224928"];
2803 [label="considerCallingConvention: true 224929"];
2804 [label="false 224930"];
2805 [label="considerRefKindDifferences: false 224931"];
2806 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 224932"];
2807 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 224933"];
2808 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 224934"];
2809 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 224935"];
2810 [label="param MemberSignatureComparer(bool considerName) 224936"];
2811 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 224937"];
2812 [label="param MemberSignatureComparer(bool considerReturnType) 224938"];
2813 [label="param MemberSignatureComparer(bool considerTypeConstraints) 224939"];
2814 [label="param MemberSignatureComparer(bool considerCallingConvention) 224940"];
2815 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 224941"];
2816 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 224942"];
2817 [label="param MemberSignatureComparer(this) 224943"];
2818 [label="_considerName 224944"];
2819 [label="_considerExplicitlyImplementedInterfaces 224945"];
2820 [label="_considerReturnType 224946"];
2821 [label="_considerTypeConstraints 224947"];
2822 [label="_considerCallingConvention 224948"];
2823 [label="_considerRefKindDifferences 224949"];
2824 [label="_typeComparison 224950"];
2825 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224951"];
2826 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224952"];
2827 [label="_considerName 224953"];
2828 [label="_considerExplicitlyImplementedInterfaces 224954"];
2829 [label="_considerReturnType 224955"];
2830 [label="_considerTypeConstraints 224956"];
2831 [label="_considerCallingConvention 224957"];
2832 [label="_considerRefKindDifferences 224958"];
2833 [label="_typeComparison 224959"];
2834 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224960"];
2835 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 224961"];
2836 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 224962"];
2837 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 224963"];
2838 [label="_typeComparison 224964"];
2839 [label="RuntimeImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 224965"];
2840 [label="true 224966"];
2841 [label="considerName: true 224967"];
2842 [label="true 224968"];
2843 [label="considerExplicitlyImplementedInterfaces: true 224969"];
2844 [label="true 224970"];
2845 [label="considerReturnType: true 224971"];
2846 [label="true 224972"];
2847 [label="considerTypeConstraints: true 224973"];
2848 [label="true 224974"];
2849 [label="considerCallingConvention: true 224975"];
2850 [label="true 224976"];
2851 [label="considerRefKindDifferences: true 224977"];
2852 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 224978"];
2853 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 224979"];
2854 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 224980"];
2855 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: true,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 224981"];
2856 [label="param MemberSignatureComparer(bool considerName) 224982"];
2857 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 224983"];
2858 [label="param MemberSignatureComparer(bool considerReturnType) 224984"];
2859 [label="param MemberSignatureComparer(bool considerTypeConstraints) 224985"];
2860 [label="param MemberSignatureComparer(bool considerCallingConvention) 224986"];
2861 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 224987"];
2862 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 224988"];
2863 [label="param MemberSignatureComparer(this) 224989"];
2864 [label="_considerName 224990"];
2865 [label="_considerExplicitlyImplementedInterfaces 224991"];
2866 [label="_considerReturnType 224992"];
2867 [label="_considerTypeConstraints 224993"];
2868 [label="_considerCallingConvention 224994"];
2869 [label="_considerRefKindDifferences 224995"];
2870 [label="_typeComparison 224996"];
2871 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224997"];
2872 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 224998"];
2873 [label="_considerName 224999"];
2874 [label="_considerExplicitlyImplementedInterfaces 225000"];
2875 [label="_considerReturnType 225001"];
2876 [label="_considerTypeConstraints 225002"];
2877 [label="_considerCallingConvention 225003"];
2878 [label="_considerRefKindDifferences 225004"];
2879 [label="_typeComparison 225005"];
2880 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 225006"];
2881 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 225007"];
2882 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 225008"];
2883 [label="CSharpSignatureAndConstraintsAndReturnTypeComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: true,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 225009"];
2884 [label="true 225010"];
2885 [label="considerName: true 225011"];
2886 [label="false 225012"];
2887 [label="considerExplicitlyImplementedInterfaces: false 225013"];
2888 [label="true 225014"];
2889 [label="considerReturnType: true 225015"];
2890 [label="false 225016"];
2891 [label="considerTypeConstraints: false 225017"];
2892 [label="true 225018"];
2893 [label="considerCallingConvention: true 225019"];
2894 [label="true 225020"];
2895 [label="considerRefKindDifferences: true 225021"];
2896 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 225022"];
2897 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 225023"];
2898 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 225024"];
2899 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false, //we'll be comparing interface members anyway\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 225025"];
2900 [label="param MemberSignatureComparer(bool considerName) 225026"];
2901 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 225027"];
2902 [label="param MemberSignatureComparer(bool considerReturnType) 225028"];
2903 [label="param MemberSignatureComparer(bool considerTypeConstraints) 225029"];
2904 [label="param MemberSignatureComparer(bool considerCallingConvention) 225030"];
2905 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 225031"];
2906 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 225032"];
2907 [label="param MemberSignatureComparer(this) 225033"];
2908 [label="_considerName 225034"];
2909 [label="_considerExplicitlyImplementedInterfaces 225035"];
2910 [label="_considerReturnType 225036"];
2911 [label="_considerTypeConstraints 225037"];
2912 [label="_considerCallingConvention 225038"];
2913 [label="_considerRefKindDifferences 225039"];
2914 [label="_typeComparison 225040"];
2915 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 225041"];
2916 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 225042"];
2917 [label="_considerName 225043"];
2918 [label="_considerExplicitlyImplementedInterfaces 225044"];
2919 [label="_considerReturnType 225045"];
2920 [label="_considerTypeConstraints 225046"];
2921 [label="_considerCallingConvention 225047"];
2922 [label="_considerRefKindDifferences 225048"];
2923 [label="_typeComparison 225049"];
2924 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 225050"];
2925 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 225051"];
2926 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 225052"];
2927 [label="RetargetedExplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false, //we'll be comparing interface members anyway\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 225053"];
2928 [label="false 225054"];
2929 [label="considerName: false 225055"];
2930 [label="false 225056"];
2931 [label="considerExplicitlyImplementedInterfaces: false 225057"];
2932 [label="false 225058"];
2933 [label="considerReturnType: false 225059"];
2934 [label="false 225060"];
2935 [label="considerTypeConstraints: false 225061"];
2936 [label="false 225062"];
2937 [label="considerCallingConvention: false 225063"];
2938 [label="true 225064"];
2939 [label="considerRefKindDifferences: true 225065"];
2940 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 225066"];
2941 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 225067"];
2942 [label="typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 225068"];
2943 [label="new MemberSignatureComparer(\n            considerName: false, //handled by lookup\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 225069"];
2944 [label="param MemberSignatureComparer(bool considerName) 225070"];
2945 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 225071"];
2946 [label="param MemberSignatureComparer(bool considerReturnType) 225072"];
2947 [label="param MemberSignatureComparer(bool considerTypeConstraints) 225073"];
2948 [label="param MemberSignatureComparer(bool considerCallingConvention) 225074"];
2949 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 225075"];
2950 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 225076"];
2951 [label="param MemberSignatureComparer(this) 225077"];
2952 [label="_considerName 225078"];
2953 [label="_considerExplicitlyImplementedInterfaces 225079"];
2954 [label="_considerReturnType 225080"];
2955 [label="_considerTypeConstraints 225081"];
2956 [label="_considerCallingConvention 225082"];
2957 [label="_considerRefKindDifferences 225083"];
2958 [label="_typeComparison 225084"];
2959 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 225085"];
2960 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 225086"];
2961 [label="_considerName 225087"];
2962 [label="_considerExplicitlyImplementedInterfaces 225088"];
2963 [label="_considerReturnType 225089"];
2964 [label="_considerTypeConstraints 225090"];
2965 [label="_considerCallingConvention 225091"];
2966 [label="_considerRefKindDifferences 225092"];
2967 [label="_typeComparison 225093"];
2968 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 225094"];
2969 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 225095"];
2970 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 225096"];
2971 [label="CrefComparer = new MemberSignatureComparer(\n            considerName: false, //handled by lookup\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 225097"];
2972 [label="MemberSignatureComparer.RecordAPISignatureComparer 225098"];
2973 [label="PooledDictionary<Symbol, Symbol>.CreatePool(MemberSignatureComparer.RecordAPISignatureComparer) 225099"];
2974 [label="s_duplicateRecordMemberSignatureDictionary =\n            PooledDictionary<Symbol, Symbol>.CreatePool(MemberSignatureComparer.RecordAPISignatureComparer) 225100"];
2975 [label="EmptyComparer.Instance 225101"];
2976 [label="new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(EmptyComparer.Instance) 225102"];
2977 [label="s_emptyTypeMembers = new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(EmptyComparer.Instance) 225103"];
2978 [label="(DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, bool topLevel, Location location)\n            => diagnostics.Add(topLevel ?\n                ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride :\n                ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride,\n                location) 225104"];
2979 [label="ReportBadReturn =\n            (DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, bool topLevel, Location location)\n            => diagnostics.Add(topLevel ?\n                ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride :\n                ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride,\n                location) 225105"];
2980 [label="(DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, ParameterSymbol overridingParameter, bool topLevel, Location location)\n            => diagnostics.Add(\n                topLevel ? ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride : ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride,\n                location,\n                new FormattedSymbol(overridingParameter, SymbolDisplayFormat.ShortFormat)) 225106"];
2981 [label="ReportBadParameter =\n            (DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, ParameterSymbol overridingParameter, bool topLevel, Location location)\n            => diagnostics.Add(\n                topLevel ? ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride : ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride,\n                location,\n                new FormattedSymbol(overridingParameter, SymbolDisplayFormat.ShortFormat)) 225107"];
2982 [label="containingSymbol 225108"];
2983 [label="declaration 225109"];
2984 [label="diagnostics 225110"];
2985 [label="tupleData 225111"];
2986 [label="param SourceNamedTypeSymbol(this) 225112"];
2987 [label="param SourceMemberContainerTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 225113"];
2988 [label="param SourceMemberContainerTypeSymbol(MergedTypeDeclaration declaration) 225114"];
2989 [label="param SourceMemberContainerTypeSymbol(DiagnosticBag diagnostics) 225115"];
2990 [label="param SourceMemberContainerTypeSymbol(TupleExtraData? tupleData = null) 225116"];
2991 [label="param SourceMemberContainerTypeSymbol(this) 225117"];
2992 [label="symbol =>\n        {\n            if (!symbol.IsStatic)\n            {\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Field:\n                    case SymbolKind.Event:\n                        return true;\n                }\n            }\n            return false;\n        } 225118"];
2993 [label="IsInstanceFieldOrEvent = symbol =>\n        {\n            if (!symbol.IsStatic)\n            {\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Field:\n                    case SymbolKind.Event:\n                        return true;\n                }\n            }\n            return false;\n        } 225119"];
2994 [label="type => !type.HasType 225120"];
2995 [label="TypeWithAnnotationsIsNullFunction = type => !type.HasType 225121"];
2996 [label="type => type.HasType && type.Type.IsErrorType() 225122"];
2997 [label="TypeWithAnnotationsIsErrorType = type => type.HasType && type.Type.IsErrorType() 225123"];
2998 [label="8 225124"];
2999 [label="ValueTupleRestPosition = 8 225125"];
3000 [label="1 225126"];
3001 [label="ValueTupleRestPosition - 1 225127"];
3002 [label="ValueTupleRestIndex = ValueTupleRestPosition - 1 225128"];
3003 [label="'ValueTuple' 225129"];
3004 [label="ValueTupleTypeName = 'ValueTuple' 225130"];
3005 [label="'Rest' 225131"];
3006 [label="ValueTupleRestFieldName = 'Rest' 225132"];
3007 [label="{\n                                                            WellKnownType.System_ValueTuple_T1,\n                                                            WellKnownType.System_ValueTuple_T2,\n                                                            WellKnownType.System_ValueTuple_T3,\n                                                            WellKnownType.System_ValueTuple_T4,\n                                                            WellKnownType.System_ValueTuple_T5,\n                                                            WellKnownType.System_ValueTuple_T6,\n                                                            WellKnownType.System_ValueTuple_T7,\n                                                            WellKnownType.System_ValueTuple_TRest } 225133"];
3008 [label="tupleTypes = {\n                                                            WellKnownType.System_ValueTuple_T1,\n                                                            WellKnownType.System_ValueTuple_T2,\n                                                            WellKnownType.System_ValueTuple_T3,\n                                                            WellKnownType.System_ValueTuple_T4,\n                                                            WellKnownType.System_ValueTuple_T5,\n                                                            WellKnownType.System_ValueTuple_T6,\n                                                            WellKnownType.System_ValueTuple_T7,\n                                                            WellKnownType.System_ValueTuple_TRest } 225134"];
3009 [label="{\n                                                            WellKnownMember.System_ValueTuple_T1__ctor,\n                                                            WellKnownMember.System_ValueTuple_T2__ctor,\n                                                            WellKnownMember.System_ValueTuple_T3__ctor,\n                                                            WellKnownMember.System_ValueTuple_T4__ctor,\n                                                            WellKnownMember.System_ValueTuple_T5__ctor,\n                                                            WellKnownMember.System_ValueTuple_T6__ctor,\n                                                            WellKnownMember.System_ValueTuple_T7__ctor,\n                                                            WellKnownMember.System_ValueTuple_TRest__ctor } 225135"];
3010 [label="tupleCtors = {\n                                                            WellKnownMember.System_ValueTuple_T1__ctor,\n                                                            WellKnownMember.System_ValueTuple_T2__ctor,\n                                                            WellKnownMember.System_ValueTuple_T3__ctor,\n                                                            WellKnownMember.System_ValueTuple_T4__ctor,\n                                                            WellKnownMember.System_ValueTuple_T5__ctor,\n                                                            WellKnownMember.System_ValueTuple_T6__ctor,\n                                                            WellKnownMember.System_ValueTuple_T7__ctor,\n                                                            WellKnownMember.System_ValueTuple_TRest__ctor } 225136"];
3011 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 225137"];
3012 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 } 225138"];
3013 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 } 225139"];
3014 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 } 225140"];
3015 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 } 225141"];
3016 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 } 225142"];
3017 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 } 225143"];
3018 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 } 225144"];
3019 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest } 225145"];
3020 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 225146"];
3021 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 225147"];
3022 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 225148"];
3023 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 225149"];
3024 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 225150"];
3025 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 225151"];
3026 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 225152"];
3027 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 225153"];
3028 [label="tupleMembers = new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 225154"];
3029 [label="tupleData 225155"];
3030 [label="param SourceMemberContainerTypeSymbol(this) 225156"];
3031 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 225157"];
3032 [label="param NamedTypeSymbol(this) 225158"];
3033 [label="'<invalid-global-code>' 225159"];
3034 [label="ImplicitTypeName = '<invalid-global-code>' 225160"];
3035 [label="0 225161"];
3036 [label="TypeCompareKind.ConsiderEverything 225162"];
3037 [label="new SymbolEqualityComparer(TypeCompareKind.ConsiderEverything) 225163"];
3038 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 225164"];
3039 [label="param SymbolEqualityComparer(this) 225165"];
3040 [label="_comparison 225166"];
3041 [label="_comparison 225167"];
3042 [label="ConsiderEverything = new SymbolEqualityComparer(TypeCompareKind.ConsiderEverything) 225168"];
3043 [label="TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 225169"];
3044 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 225170"];
3045 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 225171"];
3046 [label="param SymbolEqualityComparer(this) 225172"];
3047 [label="_comparison 225173"];
3048 [label="_comparison 225174"];
3049 [label="IgnoringTupleNamesAndNullability = new SymbolEqualityComparer(TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 225175"];
3050 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 225176"];
3051 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 225177"];
3052 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 225178"];
3053 [label="param SymbolEqualityComparer(this) 225179"];
3054 [label="_comparison 225180"];
3055 [label="_comparison 225181"];
3056 [label="IgnoringDynamicTupleNamesAndNullability = new SymbolEqualityComparer(TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 225182"];
3057 [label="TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 225183"];
3058 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 225184"];
3059 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 225185"];
3060 [label="param SymbolEqualityComparer(this) 225186"];
3061 [label="_comparison 225187"];
3062 [label="_comparison 225188"];
3063 [label="IgnoringNullable = new SymbolEqualityComparer(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 225189"];
3064 [label="TypeCompareKind.ObliviousNullableModifierMatchesAny 225190"];
3065 [label="new SymbolEqualityComparer(TypeCompareKind.ObliviousNullableModifierMatchesAny) 225191"];
3066 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 225192"];
3067 [label="param SymbolEqualityComparer(this) 225193"];
3068 [label="_comparison 225194"];
3069 [label="_comparison 225195"];
3070 [label="ObliviousNullableModifierMatchesAny = new SymbolEqualityComparer(TypeCompareKind.ObliviousNullableModifierMatchesAny) 225196"];
3071 [label="TypeCompareKind.AllIgnoreOptions 225197"];
3072 [label="new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions) 225198"];
3073 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 225199"];
3074 [label="param SymbolEqualityComparer(this) 225200"];
3075 [label="_comparison 225201"];
3076 [label="_comparison 225202"];
3077 [label="AllIgnoreOptions = new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions) 225203"];
3078 [label="TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 225204"];
3079 [label="new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes)) 225205"];
3080 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 225206"];
3081 [label="param SymbolEqualityComparer(this) 225207"];
3082 [label="_comparison 225208"];
3083 [label="_comparison 225209"];
3084 [label="AllIgnoreOptionsPlusNullableWithUnknownMatchesAny =\n                                                                  new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes)) 225210"];
3085 [label="TypeCompareKind.CLRSignatureCompareOptions 225211"];
3086 [label="new SymbolEqualityComparer(TypeCompareKind.CLRSignatureCompareOptions) 225212"];
3087 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 225213"];
3088 [label="param SymbolEqualityComparer(this) 225214"];
3089 [label="_comparison 225215"];
3090 [label="_comparison 225216"];
3091 [label="CLRSignature = new SymbolEqualityComparer(TypeCompareKind.CLRSignatureCompareOptions) 225217"];
3092 [label="SymbolEqualityComparer.CLRSignature 225218"];
3093 [label="new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 225219"];
3094 [label="new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 225220"];
3095 [label="EmptyInterfacesAndTheirBaseInterfaces =\n                                                new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 225221"];
3096 [label="new InterfaceInfo() 225222"];
3097 [label="param InterfaceInfo(this) 225223"];
3098 [label="interfacesAndTheirBaseInterfaces 225224"];
3099 [label="_implementationForInterfaceMemberMap 225225"];
3100 [label="explicitInterfaceImplementationMap 225226"];
3101 [label="s_noInterfaces = new InterfaceInfo() 225227"];
3102 [label="(type) => type.SetUnknownNullabilityForReferenceTypes() 225228"];
3103 [label="s_setUnknownNullability =\n            (type) => type.SetUnknownNullabilityForReferenceTypes() 225229"];
3104 [label="param NamedTypeSymbol(this) 225230"];
3105 [label="param TypeSymbol(this) 225231"];
3106 [label="param TypeSymbol(this) 225232"];
3107 [label="_lazyAbstractMembers 225233"];
3108 [label="_lazyInterfaceInfo 225234"];
3109 [label="_lazyAdapter 225235"];
3110 [label="_hasNoBaseCycles 225236"];
3111 [label="_lazyTupleData 225237"];
3112 [label="_lazyTupleData 225238"];
3113 [label="_declModifiers 225239"];
3114 [label="_containingSymbol 225240"];
3115 [label="declaration 225241"];
3116 [label="new DeclaredMembersAndInitializers() 225242"];
3117 [label="param DeclaredMembersAndInitializers(this) 225243"];
3118 [label="HaveIndexers 225244"];
3119 [label="RecordDeclarationWithParameters 225245"];
3120 [label="RecordPrimaryConstructor 225246"];
3121 [label="InstanceInitializersIndexForRecordDeclarationWithParameters 225247"];
3122 [label="IsNullableEnabledForInstanceConstructorsAndFields 225248"];
3123 [label="IsNullableEnabledForStaticConstructorsAndFields 225249"];
3124 [label="UninitializedSentinel = new DeclaredMembersAndInitializers() 225250"];
3125 [label="_lazyDeclaredMembersAndInitializers = DeclaredMembersAndInitializers.UninitializedSentinel 225251"];
3126 [label="_lazyMembersAndInitializers 225252"];
3127 [label="_lazyMembersDictionary 225253"];
3128 [label="_lazyEarlyAttributeDecodingMembersDictionary 225254"];
3129 [label="_lazyTypeMembers 225255"];
3130 [label="_lazyKnownCircularStruct 225256"];
3131 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 225257"];
3132 [label="_lazyContainsExtensionMethods 225258"];
3133 [label="_lazyAnyMemberHasAttributes 225259"];
3134 [label="_containingSymbol 225260"];
3135 [label="this.declaration 225261"];
3136 [label="TypeKind typeKind = declaration.Kind.ToTypeKind(); 225262"];
3137 [label="declaration.Kind.ToTypeKind() 225263"];
3138 [label="param ToTypeKind(this DeclarationKind kind) 225264"];
3139 [label="switch (kind)\n            {\n                case DeclarationKind.Class:\n                case DeclarationKind.Script:\n                case DeclarationKind.ImplicitClass:\n                case DeclarationKind.SimpleProgram:\n                case DeclarationKind.Record:\n                    return TypeKind.Class;\n\n                case DeclarationKind.Submission:\n                    return TypeKind.Submission;\n\n                case DeclarationKind.Delegate:\n                    return TypeKind.Delegate;\n\n                case DeclarationKind.Enum:\n                    return TypeKind.Enum;\n\n                case DeclarationKind.Interface:\n                    return TypeKind.Interface;\n\n                case DeclarationKind.Struct:\n                    return TypeKind.Struct;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 225265"];
3140 [label="return TypeKind.Class; 225266"];
3141 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 225267"];
3142 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 225268"];
3143 [label="MakeModifiers(typeKind, diagnostics) 225269"];
3144 [label="param MakeModifiers(TypeKind typeKind) 225270"];
3145 [label="param MakeModifiers(DiagnosticBag diagnostics) 225271"];
3146 [label="param MakeModifiers(this) 225272"];
3147 [label="this.ContainingSymbol 225273"];
3148 [label="get\n            {\n                return _containingSymbol;\n            } 225274"];
3149 [label="return _containingSymbol; 225275"];
3150 [label="Symbol containingSymbol = this.ContainingSymbol; 225276"];
3151 [label="DeclarationModifiers defaultAccess; 225277"];
3152 [label="var allowedModifiers = DeclarationModifiers.AccessibilityMask; 225278"];
3153 [label="containingSymbol.Kind 225279"];
3154 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 225280"];
3155 [label="return SymbolKind.Namespace; 225281"];
3156 [label="if (containingSymbol.Kind == SymbolKind.Namespace)\n            {\n                defaultAccess = DeclarationModifiers.Internal;\n            }\n            else\n            {\n                allowedModifiers |= DeclarationModifiers.New;\n\n                if (((NamedTypeSymbol)containingSymbol).IsInterface)\n                {\n                    defaultAccess = DeclarationModifiers.Public;\n                }\n                else\n                {\n                    defaultAccess = DeclarationModifiers.Private;\n                }\n            } 225282"];
3157 [label="defaultAccess = DeclarationModifiers.Internal; 225283"];
3158 [label="switch (typeKind)\n            {\n                case TypeKind.Class:\n                case TypeKind.Submission:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe;\n\n                    if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    }\n\n                    break;\n                case TypeKind.Struct:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Ref | DeclarationModifiers.ReadOnly | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Interface:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Delegate:\n                    allowedModifiers |= DeclarationModifiers.Unsafe;\n                    break;\n            } 225284"];
3159 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 225285"];
3160 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 225286"];
3161 [label="this.IsRecord 225287"];
3162 [label="get\n            {\n                return this.declaration.Declarations[0].Kind == DeclarationKind.Record;\n            } 225288"];
3163 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.Record; 225289"];
3164 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.Record; 225290"];
3165 [label="if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    } 225291"];
3166 [label="allowedModifiers |= DeclarationModifiers.Static; 225292"];
3167 [label="bool modifierErrors; 225293"];
3168 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 225294"];
3169 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 225295"];
3170 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 225296"];
3171 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 225297"];
3172 [label="MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors) 225298"];
3173 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers defaultAccess) 225299"];
3174 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers allowedModifiers) 225300"];
3175 [label="param MakeAndCheckTypeModifiers(DiagnosticBag diagnostics) 225301"];
3176 [label="param MakeAndCheckTypeModifiers(out bool modifierErrors) 225302"];
3177 [label="param MakeAndCheckTypeModifiers(this) 225303"];
3178 [label="modifierErrors = false; 225304"];
3179 [label="var result = DeclarationModifiers.Unset; 225305"];
3180 [label="var partCount = declaration.Declarations.Length; 225306"];
3181 [label="var missingPartial = false; 225307"];
3182 [label="for (var i = 0; i < partCount; i++)\n            {\n                var decl = declaration.Declarations[i];\n                var mods = decl.Modifiers;\n\n                if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                }\n\n                if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n\n                if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                }\n\n            } 225308"];
3183 [label="for (var i = 0; i < partCount; i++)\n            {\n                var decl = declaration.Declarations[i];\n                var mods = decl.Modifiers;\n\n                if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                }\n\n                if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n\n                if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                }\n\n            } 225309"];
3184 [label="var decl = declaration.Declarations[i]; 225310"];
3185 [label="var mods = decl.Modifiers; 225311"];
3186 [label="if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                } 225312"];
3187 [label="if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                } 225313"];
3188 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 225314"];
3189 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 225315"];
3190 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 225316"];
3191 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 225317"];
3192 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 225318"];
3193 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 225319"];
3194 [label="ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors) 225320"];
3195 [label="param CheckModifiers(DeclarationModifiers modifiers) 225321"];
3196 [label="param CheckModifiers(DeclarationModifiers allowedModifiers) 225322"];
3197 [label="param CheckModifiers(Location errorLocation) 225323"];
3198 [label="param CheckModifiers(DiagnosticBag diagnostics) 225324"];
3199 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 225325"];
3200 [label="param CheckModifiers(out bool modifierErrors) 225326"];
3201 [label="modifierErrors = false; 225327"];
3202 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 225328"];
3203 [label="DeclarationModifiers result = modifiers & allowedModifiers; 225329"];
3204 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 225330"];
3205 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 225331"];
3206 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 225332"];
3207 [label="return result; 225333"];
3208 [label="if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    } 225334"];
3209 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 225335"];
3210 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 225336"];
3211 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 225337"];
3212 [label="ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false) 225338"];
3213 [label="param CheckAccessibility(DeclarationModifiers modifiers) 225339"];
3214 [label="param CheckAccessibility(Symbol symbol) 225340"];
3215 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 225341"];
3216 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 225342"];
3217 [label="IsValidAccessibility(modifiers) 225343"];
3218 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 225344"];
3219 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 225345"];
3220 [label="return true; 225346"];
3221 [label="symbol.Kind 225347"];
3222 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 225348"];
3223 [label="return SymbolKind.NamedType; 225349"];
3224 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 225350"];
3225 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 225351"];
3226 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 225352"];
3227 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 225353"];
3228 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 225354"];
3229 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 225355"];
3230 [label="return null; 225356"];
3231 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 225357"];
3232 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 225358"];
3233 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 225359"];
3234 [label="if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                } 225360"];
3235 [label="result = mods; 225361"];
3236 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 225362"];
3237 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 225363"];
3238 [label="if (missingPartial)\n            {\n                if ((result & DeclarationModifiers.Partial) == 0)\n                {\n                    // duplicate definitions\n                    switch (this.ContainingSymbol.Kind)\n                    {\n                        case SymbolKind.Namespace:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, declaration.Declarations[i].NameLocation, this.Name, this.ContainingSymbol);\n                                modifierErrors = true;\n                            }\n                            break;\n\n                        case SymbolKind.NamedType:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                if (ContainingType!.Locations.Length == 1 || ContainingType.IsPartial())\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, declaration.Declarations[i].NameLocation, this.ContainingSymbol, this.Name);\n                                modifierErrors = true;\n                            }\n                            break;\n                    }\n                }\n                else\n                {\n                    for (var i = 0; i < partCount; i++)\n                    {\n                        var singleDeclaration = declaration.Declarations[i];\n                        var mods = singleDeclaration.Modifiers;\n                        if ((mods & DeclarationModifiers.Partial) == 0)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_MissingPartial, singleDeclaration.NameLocation, this.Name);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n            } 225364"];
3239 [label="this.Name 225365"];
3240 [label="get\n            {\n                return declaration.Name;\n            } 225366"];
3241 [label="return declaration.Name; 225367"];
3242 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 225368"];
3243 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 225369"];
3244 [label="return result; 225370"];
3245 [label="(type, containingSymbol, unused) => HasInvalidTypeParameter(type, containingSymbol) 225371"];
3246 [label="s_hasInvalidTypeParameterFunc =\n            (type, containingSymbol, unused) => HasInvalidTypeParameter(type, containingSymbol) 225372"];
3247 [label="this.CheckUnsafeModifier(mods, diagnostics); 225373"];
3248 [label="this.CheckUnsafeModifier(mods, diagnostics); 225374"];
3249 [label="this.CheckUnsafeModifier(mods, diagnostics); 225375"];
3250 [label="this.CheckUnsafeModifier(mods, diagnostics) 225376"];
3251 [label="param CheckUnsafeModifier(this Symbol symbol) 225377"];
3252 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 225378"];
3253 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 225379"];
3254 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 225380"];
3255 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 225381"];
3256 [label="symbol.Locations 225382"];
3257 [label="get\n            {\n                return declaration.NameLocations.Cast<SourceLocation, Location>();\n            } 225383"];
3258 [label="return declaration.NameLocations.Cast<SourceLocation, Location>(); 225384"];
3259 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 225385"];
3260 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 225386"];
3261 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 225387"];
3262 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics) 225388"];
3263 [label="param CheckUnsafeModifier(this Symbol symbol) 225389"];
3264 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 225390"];
3265 [label="param CheckUnsafeModifier(Location errorLocation) 225391"];
3266 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 225392"];
3267 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 225393"];
3268 [label="this.CheckUnsafeModifier(mods, diagnostics); 225394"];
3269 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 225395"];
3270 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 225396"];
3271 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 225397"];
3272 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 225398"];
3273 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 225399"];
3274 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 225400"];
3275 [label="switch (typeKind)\n            {\n                case TypeKind.Interface:\n                    mods |= DeclarationModifiers.Abstract;\n                    break;\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n                case TypeKind.Delegate:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n            } 225401"];
3276 [label="return mods; 225402"];
3277 [label="foreach (var singleDeclaration in declaration.Declarations)\n            {\n                diagnostics.AddRange(singleDeclaration.Diagnostics);\n            } 225403"];
3278 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 225404"];
3279 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 225405"];
3280 [label="int access = (int)(modifiers & DeclarationModifiers.AccessibilityMask); 225406"];
3281 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 225407"];
3282 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 225408"];
3283 [label="_declModifiers 225409"];
3284 [label="var specialType = access == (int)DeclarationModifiers.Public\n                ? MakeSpecialType()\n                : SpecialType.None; 225410"];
3285 [label="access == (int)DeclarationModifiers.Public 225411"];
3286 [label="MakeSpecialType() 225412"];
3287 [label="param MakeSpecialType(this) 225413"];
3288 [label="ContainingSymbol 225414"];
3289 [label="get\n            {\n                return _containingSymbol;\n            } 225415"];
3290 [label="return _containingSymbol; 225416"];
3291 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 225417"];
3292 [label="ContainingSymbol.Kind 225418"];
3293 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 225419"];
3294 [label="return SymbolKind.Namespace; 225420"];
3295 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 225421"];
3296 [label="ContainingSymbol 225422"];
3297 [label="get\n            {\n                return _containingSymbol;\n            } 225423"];
3298 [label="return _containingSymbol; 225424"];
3299 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 225425"];
3300 [label="ContainingSymbol.ContainingAssembly 225426"];
3301 [label="=> _module.ContainingAssembly 225427"];
3302 [label="_module.ContainingAssembly 225428"];
3303 [label="get\n            {\n                return _assemblySymbol;\n            } 225429"];
3304 [label="return _assemblySymbol; 225430"];
3305 [label="ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes 225431"];
3306 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 225432"];
3307 [label="this.CorLibrary 225433"];
3308 [label="get\n            {\n                return _corLibrary;\n            } 225434"];
3309 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 225435"];
3310 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 225436"];
3311 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 225437"];
3312 [label="return SpecialType.None; 225438"];
3313 [label="0 225439"];
3314 [label="SpecialTypeOffset = 0 225440"];
3315 [label="6 225441"];
3316 [label="SpecialTypeSize = 6 225442"];
3317 [label="SpecialTypeOffset + SpecialTypeSize 225443"];
3318 [label="ManagedKindOffset = SpecialTypeOffset + SpecialTypeSize 225444"];
3319 [label="2 225445"];
3320 [label="ManagedKindSize = 2 225446"];
3321 [label="ManagedKindOffset + ManagedKindSize 225447"];
3322 [label="FieldDefinitionsNotedOffset = ManagedKindOffset + ManagedKindSize 225448"];
3323 [label="1 225449"];
3324 [label="FieldDefinitionsNotedSize = 1 225450"];
3325 [label="FieldDefinitionsNotedOffset + FieldDefinitionsNotedSize 225451"];
3326 [label="FlattenedMembersIsSortedOffset = FieldDefinitionsNotedOffset + FieldDefinitionsNotedSize 225452"];
3327 [label="1 225453"];
3328 [label="FlattenedMembersIsSortedSize = 1 225454"];
3329 [label="FlattenedMembersIsSortedOffset + FlattenedMembersIsSortedSize 225455"];
3330 [label="TypeKindOffset = FlattenedMembersIsSortedOffset + FlattenedMembersIsSortedSize 225456"];
3331 [label="4 225457"];
3332 [label="TypeKindSize = 4 225458"];
3333 [label="TypeKindOffset + TypeKindSize 225459"];
3334 [label="NullableContextOffset = TypeKindOffset + TypeKindSize 225460"];
3335 [label="3 225461"];
3336 [label="NullableContextSize = 3 225462"];
3337 [label="1 225463"];
3338 [label="1 << SpecialTypeSize 225464"];
3339 [label="1 225465"];
3340 [label="(1 << SpecialTypeSize) - 1 225466"];
3341 [label="SpecialTypeMask = (1 << SpecialTypeSize) - 1 225467"];
3342 [label="1 225468"];
3343 [label="1 << ManagedKindSize 225469"];
3344 [label="1 225470"];
3345 [label="(1 << ManagedKindSize) - 1 225471"];
3346 [label="ManagedKindMask = (1 << ManagedKindSize) - 1 225472"];
3347 [label="1 225473"];
3348 [label="1 << TypeKindSize 225474"];
3349 [label="1 225475"];
3350 [label="(1 << TypeKindSize) - 1 225476"];
3351 [label="TypeKindMask = (1 << TypeKindSize) - 1 225477"];
3352 [label="1 225478"];
3353 [label="1 << NullableContextSize 225479"];
3354 [label="1 225480"];
3355 [label="(1 << NullableContextSize) - 1 225481"];
3356 [label="NullableContextMask = (1 << NullableContextSize) - 1 225482"];
3357 [label="1 225483"];
3358 [label="1 << FieldDefinitionsNotedOffset 225484"];
3359 [label="FieldDefinitionsNotedBit = 1 << FieldDefinitionsNotedOffset 225485"];
3360 [label="1 225486"];
3361 [label="1 << FlattenedMembersIsSortedOffset 225487"];
3362 [label="FlattenedMembersIsSortedBit = 1 << FlattenedMembersIsSortedOffset 225488"];
3363 [label="Debug.Assert(EnumUtilities.ContainsAllValues<SpecialType>(SpecialTypeMask)); 225489"];
3364 [label="Debug.Assert(EnumUtilities.ContainsAllValues<NullableContextKind>(NullableContextMask)); 225490"];
3365 [label="_flags = new Flags(specialType, typeKind); 225491"];
3366 [label="_flags = new Flags(specialType, typeKind); 225492"];
3367 [label="_flags = new Flags(specialType, typeKind); 225493"];
3368 [label="new Flags(specialType, typeKind) 225494"];
3369 [label="param Flags(SpecialType specialType) 225495"];
3370 [label="param Flags(TypeKind typeKind) 225496"];
3371 [label="param Flags(this) 225497"];
3372 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 225498"];
3373 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 225499"];
3374 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 225500"];
3375 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 225501"];
3376 [label="_flags = specialTypeInt | typeKindInt; 225502"];
3377 [label="_flags 225503"];
3378 [label="_flags 225504"];
3379 [label="this.ContainingType 225505"];
3380 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 225506"];
3381 [label="return _containingSymbol as NamedTypeSymbol; 225507"];
3382 [label="var containingType = this.ContainingType; 225508"];
3383 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 225509"];
3384 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 225510"];
3385 [label="state.NotePartComplete(CompletionPart.TypeArguments); 225511"];
3386 [label="state.NotePartComplete(CompletionPart.TypeArguments) 225512"];
3387 [label="param NotePartComplete(CompletionPart part) 225513"];
3388 [label="param NotePartComplete(this) 225514"];
3389 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 225515"];
3390 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 225516"];
3391 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 225517"];
3392 [label="_lazyCustomAttributesBag 225518"];
3393 [label="_lazyDocComment 225519"];
3394 [label="_lazyExpandedDocComment 225520"];
3395 [label="_lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.Unknown 225521"];
3396 [label="_lazyDeclaredBases 225522"];
3397 [label="new UnsupportedMetadataTypeSymbol() 225523"];
3398 [label="param UnsupportedMetadataTypeSymbol(BadImageFormatException? mrEx = null) 225524"];
3399 [label="param UnsupportedMetadataTypeSymbol(this) 225525"];
3400 [label="param ErrorTypeSymbol(this) 225526"];
3401 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 225527"];
3402 [label="tupleData 225528"];
3403 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 225529"];
3404 [label="param NamedTypeSymbol(this) 225530"];
3405 [label="param TypeSymbol(this) 225531"];
3406 [label="param NamespaceOrTypeSymbol(this) 225532"];
3407 [label="param Symbol(this) 225533"];
3408 [label="_lazyISymbol 225534"];
3409 [label="_lazyAbstractMembers 225535"];
3410 [label="_lazyInterfaceInfo 225536"];
3411 [label="_lazyAdapter 225537"];
3412 [label="_hasNoBaseCycles 225538"];
3413 [label="_lazyTupleData 225539"];
3414 [label="_lazyTupleData 225540"];
3415 [label="_mrEx 225541"];
3416 [label="_mrEx 225542"];
3417 [label="UnknownResultType = new UnsupportedMetadataTypeSymbol() 225543"];
3418 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 225544"];
3419 [label="_lazyEnumValueField 225545"];
3420 [label="_lazyEnumUnderlyingType = ErrorTypeSymbol.UnknownResultType 225546"];
3421 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    break;\n                default:\n                    Debug.Assert(false, 'bad declaration kind');\n                    break;\n            } 225547"];
3422 [label="containingSymbol.Kind 225548"];
3423 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 225549"];
3424 [label="return SymbolKind.Namespace; 225550"];
3425 [label="if (containingSymbol.Kind == SymbolKind.NamedType)\n            {\n                // Nested types are never unified.\n                _lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.False;\n            } 225551"];
3426 [label="builder.Add(BuildSymbol(declaration, diagnostics)) 225552"];
3427 [label="param Add(NamespaceOrTypeSymbol symbol) 225553"];
3428 [label="param Add(this) 225554"];
3429 [label="symbol.Name 225555"];
3430 [label="get\n            {\n                return declaration.Name;\n            } 225556"];
3431 [label="return declaration.Name; 225557"];
3432 [label="string name = symbol.Name; 225558"];
3433 [label="object item; 225559"];
3434 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 225560"];
3435 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 225561"];
3436 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 225562"];
3437 [label="_dictionary 225563"];
3438 [label="builder.CreateMap() 225564"];
3439 [label="param CreateMap(this) 225565"];
3440 [label="var result = new Dictionary<String, ImmutableArray<NamespaceOrTypeSymbol>>(_dictionary.Count, StringOrdinalComparer.Instance); 225566"];
3441 [label="var result = new Dictionary<String, ImmutableArray<NamespaceOrTypeSymbol>>(_dictionary.Count, StringOrdinalComparer.Instance); 225567"];
3442 [label="foreach (var kvp in _dictionary)\n                {\n                    object value = kvp.Value;\n                    ImmutableArray<NamespaceOrTypeSymbol> members;\n\n                    var builder = value as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    }\n\n                    result.Add(kvp.Key, members);\n                } 225568"];
3443 [label="object value = kvp.Value; 225569"];
3444 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 225570"];
3445 [label="members 225571"];
3446 [label="var builder = value as ArrayBuilder<NamespaceOrTypeSymbol>; 225572"];
3447 [label="if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    } 225573"];
3448 [label="if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    } 225574"];
3449 [label="NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value; 225575"];
3450 [label="symbol.Kind 225576"];
3451 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 225577"];
3452 [label="return SymbolKind.NamedType; 225578"];
3453 [label="members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol)); 225579"];
3454 [label="symbol.Kind == SymbolKind.Namespace 225580"];
3455 [label="members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol)); 225581"];
3456 [label="result.Add(kvp.Key, members); 225582"];
3457 [label="result.Add(kvp.Key, members); 225583"];
3458 [label="result.Add(kvp.Key, members); 225584"];
3459 [label="return result; 225585"];
3460 [label="var result = builder.CreateMap(); 225586"];
3461 [label="CheckMembers(this, result, diagnostics); 225587"];
3462 [label="CheckMembers(this, result, diagnostics); 225588"];
3463 [label="CheckMembers(this, result, diagnostics); 225589"];
3464 [label="CheckMembers(this, result, diagnostics) 225590"];
3465 [label="param CheckMembers(NamespaceSymbol @namespace) 225591"];
3466 [label="param CheckMembers(Dictionary<string, ImmutableArray<NamespaceOrTypeSymbol>> result) 225592"];
3467 [label="param CheckMembers(DiagnosticBag diagnostics) 225593"];
3468 [label="var memberOfArity = new Symbol[10]; 225594"];
3469 [label="MergedNamespaceSymbol mergedAssemblyNamespace = null; 225595"];
3470 [label="@namespace.ContainingAssembly 225596"];
3471 [label="=> _module.ContainingAssembly 225597"];
3472 [label="_module.ContainingAssembly 225598"];
3473 [label="get\n            {\n                return _assemblySymbol;\n            } 225599"];
3474 [label="return _assemblySymbol; 225600"];
3475 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 225601"];
3476 [label="@namespace.ContainingAssembly.Modules 225602"];
3477 [label="get\n            {\n                return _modules;\n            } 225603"];
3478 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 225604"];
3479 [label="foreach (var name in result.Keys)\n            {\n                Array.Clear(memberOfArity, 0, memberOfArity.Length);\n                foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                }\n            } 225605"];
3480 [label="foreach (var name in result.Keys)\n            {\n                Array.Clear(memberOfArity, 0, memberOfArity.Length);\n                foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                }\n            } 225606"];
3481 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 225607"];
3482 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 225608"];
3483 [label="foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                } 225609"];
3484 [label="var nts = symbol as NamedTypeSymbol; 225610"];
3485 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 225611"];
3486 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 225612"];
3487 [label="((object)nts != null) 225613"];
3488 [label="nts.Arity 225614"];
3489 [label="get\n            {\n                return declaration.Arity;\n            } 225615"];
3490 [label="return declaration.Arity; 225616"];
3491 [label="if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    } 225617"];
3492 [label="var other = memberOfArity[arity]; 225618"];
3493 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 225619"];
3494 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 225620"];
3495 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 225621"];
3496 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 225622"];
3497 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 225623"];
3498 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 225624"];
3499 [label="memberOfArity[arity] 225625"];
3500 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 225626"];
3501 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 225627"];
3502 [label="nts.DeclaredAccessibility 225628"];
3503 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 225629"];
3504 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 225630"];
3505 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 225631"];
3506 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 225632"];
3507 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 225633"];
3508 [label="return Accessibility.Public; 225634"];
3509 [label="Accessibility declaredAccessibility = nts.DeclaredAccessibility; 225635"];
3510 [label="if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        } 225636"];
3511 [label="CheckMembers(this, result, diagnostics); 225637"];
3512 [label="return result; 225638"];
3513 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 225639"];
3514 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 225640"];
3515 [label="this.DeclaringCompilation 225641"];
3516 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 225642"];
3517 [label="this.Kind 225643"];
3518 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 225644"];
3519 [label="return SymbolKind.Namespace; 225645"];
3520 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 225646"];
3521 [label="this.ContainingModule 225647"];
3522 [label="get\n            {\n                return _module;\n            } 225648"];
3523 [label="return _module; 225649"];
3524 [label="var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol; 225650"];
3525 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 225651"];
3526 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 225652"];
3527 [label="(object)sourceModuleSymbol == null 225653"];
3528 [label="sourceModuleSymbol.DeclaringCompilation 225654"];
3529 [label="this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics); 225655"];
3530 [label="this.DeclaringCompilation.DeclarationDiagnostics 225656"];
3531 [label="get\n            {\n                // We should only be placing diagnostics in this bag until\n                // we are done gathering declaration diagnostics. Assert that is\n                // the case. But since we have bugs (see https://github.com/dotnet/roslyn/issues/846)\n                // we disable the assertion until they are fixed.\n                Debug.Assert(!_declarationDiagnosticsFrozen || true);\n                if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                }\n\n                return _lazyDeclarationDiagnostics;\n            } 225657"];
3532 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 225658"];
3533 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 225659"];
3534 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 225660"];
3535 [label="var diagnostics = new DiagnosticBag(); 225661"];
3536 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 225662"];
3537 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 225663"];
3538 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 225664"];
3539 [label="return _lazyDeclarationDiagnostics; 225665"];
3540 [label="this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics); 225666"];
3541 [label="RegisterDeclaredCorTypes() 225667"];
3542 [label="param RegisterDeclaredCorTypes(this) 225668"];
3543 [label="ContainingAssembly 225669"];
3544 [label="=> _module.ContainingAssembly 225670"];
3545 [label="_module.ContainingAssembly 225671"];
3546 [label="get\n            {\n                return _assemblySymbol;\n            } 225672"];
3547 [label="return _assemblySymbol; 225673"];
3548 [label="AssemblySymbol containingAssembly = ContainingAssembly; 225674"];
3549 [label="containingAssembly.KeepLookingForDeclaredSpecialTypes 225675"];
3550 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 225676"];
3551 [label="this.CorLibrary 225677"];
3552 [label="get\n            {\n                return _corLibrary;\n            } 225678"];
3553 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 225679"];
3554 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 225680"];
3555 [label="if (containingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                // Register newly declared COR types\n                foreach (var array in _nameToMembersMap.Values)\n                {\n                    foreach (var member in array)\n                    {\n                        var type = member as NamedTypeSymbol;\n\n                        if ((object)type != null && type.SpecialType != SpecialType.None)\n                        {\n                            containingAssembly.RegisterDeclaredSpecialType(type);\n\n                            if (!containingAssembly.KeepLookingForDeclaredSpecialTypes)\n                            {\n                                return;\n                            }\n                        }\n                    }\n                }\n            } 225681"];
3556 [label="RegisterDeclaredCorTypes(); 225682"];
3557 [label="DeclaringCompilation 225683"];
3558 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 225684"];
3559 [label="this.Kind 225685"];
3560 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 225686"];
3561 [label="return SymbolKind.Namespace; 225687"];
3562 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 225688"];
3563 [label="this.ContainingModule 225689"];
3564 [label="get\n            {\n                return _module;\n            } 225690"];
3565 [label="return _module; 225691"];
3566 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 225692"];
3567 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 225693"];
3568 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 225694"];
3569 [label="DeclaringCompilation.SymbolDeclaredEvent(this) 225695"];
3570 [label="param SymbolDeclaredEvent(Symbol symbol) 225696"];
3571 [label="param SymbolDeclaredEvent(this) 225697"];
3572 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 225698"];
3573 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 225699"];
3574 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 225700"];
3575 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 225701"];
3576 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 225702"];
3577 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 225703"];
3578 [label="var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap); 225704"];
3579 [label="_state.NotePartComplete(CompletionPart.NameToMembersMap) 225705"];
3580 [label="param NotePartComplete(CompletionPart part) 225706"];
3581 [label="param NotePartComplete(this) 225707"];
3582 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 225708"];
3583 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 225709"];
3584 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 225710"];
3585 [label="Debug.Assert(wasSetThisThread); 225711"];
3586 [label="diagnostics.Free(); 225712"];
3587 [label="return _nameToMembersMap; 225713"];
3588 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 225714"];
3589 [label="GetTypesFromMemberMap(GetNameToMembersMap()) 225715"];
3590 [label="param GetTypesFromMemberMap(Dictionary<string, ImmutableArray<NamespaceOrTypeSymbol>> map) 225716"];
3591 [label="var dictionary = new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(StringOrdinalComparer.Instance); 225717"];
3592 [label="foreach (var kvp in map)\n            {\n                ImmutableArray<NamespaceOrTypeSymbol> members = kvp.Value;\n\n                bool hasType = false;\n                bool hasNamespace = false;\n\n                foreach (var symbol in members)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                if (hasType)\n                {\n                    if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    }\n                }\n            } 225718"];
3593 [label="ImmutableArray<NamespaceOrTypeSymbol> members = kvp.Value; 225719"];
3594 [label="bool hasType = false; 225720"];
3595 [label="bool hasNamespace = false; 225721"];
3596 [label="foreach (var symbol in members)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    }\n                } 225722"];
3597 [label="symbol.Kind 225723"];
3598 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 225724"];
3599 [label="if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    } 225725"];
3600 [label="hasType = true; 225726"];
3601 [label="if (hasNamespace)\n                        {\n                            break;\n                        } 225727"];
3602 [label="if (hasType)\n                {\n                    if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    }\n                } 225728"];
3603 [label="if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    } 225729"];
3604 [label="dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>()); 225730"];
3605 [label="dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>()); 225731"];
3606 [label="dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>()); 225732"];
3607 [label="return dictionary; 225733"];
3608 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 225734"];
3609 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 225735"];
3610 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 225736"];
3611 [label="return _nameToTypeMembersMap; 225737"];
3612 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 225738"];
3613 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 225739"];
3614 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 225740"];
3615 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 225741"];
3616 [label="this.GetNameToTypeMembersMap().TryGetValue(name, out members) 225742"];
3617 [label="classTest.GetMembers() 225743"];
3618 [label="param GetMembers(this) 225744"];
3619 [label="_flags.FlattenedMembersIsSorted 225745"];
3620 [label="get { return (_flags & FlattenedMembersIsSortedBit) != 0; } 225746"];
3621 [label="return (_flags & FlattenedMembersIsSortedBit) != 0; 225747"];
3622 [label="return (_flags & FlattenedMembersIsSortedBit) != 0; 225748"];
3623 [label="if (_flags.FlattenedMembersIsSorted)\n            {\n                return _lazyMembersFlattened;\n            }\n            else\n            {\n                var allMembers = this.GetMembersUnordered();\n\n                if (allMembers.Length > 1)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyMembersFlattened, allMembers);\n                }\n\n                _flags.SetFlattenedMembersIsSorted();\n                return allMembers;\n            } 225749"];
3624 [label="this.GetMembersUnordered() 225750"];
3625 [label="param GetMembersUnordered(this) 225751"];
3626 [label="var result = _lazyMembersFlattened; 225752"];
3627 [label="if (result.IsDefault)\n            {\n                result = GetMembersByName().Flatten(null);  // do not sort.\n                ImmutableInterlocked.InterlockedInitialize(ref _lazyMembersFlattened, result);\n                result = _lazyMembersFlattened;\n            } 225753"];
3628 [label="GetMembersByName() 225754"];
3629 [label="param GetMembersByName(this) 225755"];
3630 [label="if (this.state.HasComplete(CompletionPart.Members))\n            {\n                return _lazyMembersDictionary!;\n            } 225756"];
3631 [label="this.state.HasComplete(CompletionPart.Members) 225757"];
3632 [label="param HasComplete(CompletionPart part) 225758"];
3633 [label="param HasComplete(this) 225759"];
3634 [label="return (_completeParts & (int)part) == (int)part; 225760"];
3635 [label="GetMembersByNameSlow() 225761"];
3636 [label="param GetMembersByNameSlow(this) 225762"];
3637 [label="if (_lazyMembersDictionary == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                var membersDictionary = MakeAllMembers(diagnostics);\n\n                if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                }\n\n                diagnostics.Free();\n            } 225763"];
3638 [label="if (_lazyMembersDictionary == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                var membersDictionary = MakeAllMembers(diagnostics);\n\n                if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                }\n\n                diagnostics.Free();\n            } 225764"];
3639 [label="var diagnostics = DiagnosticBag.GetInstance(); 225765"];
3640 [label="var membersDictionary = MakeAllMembers(diagnostics); 225766"];
3641 [label="MakeAllMembers(diagnostics) 225767"];
3642 [label="param MakeAllMembers(DiagnosticBag diagnostics) 225768"];
3643 [label="param MakeAllMembers(this) 225769"];
3644 [label="Dictionary<string, ImmutableArray<Symbol>> membersByName; 225770"];
3645 [label="GetMembersAndInitializers() 225771"];
3646 [label="param GetMembersAndInitializers(this) 225772"];
3647 [label="var membersAndInitializers = _lazyMembersAndInitializers; 225773"];
3648 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 225774"];
3649 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 225775"];
3650 [label="var diagnostics = DiagnosticBag.GetInstance(); 225776"];
3651 [label="membersAndInitializers = BuildMembersAndInitializers(diagnostics); 225777"];
3652 [label="BuildMembersAndInitializers(diagnostics) 225778"];
3653 [label="param BuildMembersAndInitializers(DiagnosticBag diagnostics) 225779"];
3654 [label="param BuildMembersAndInitializers(this) 225780"];
3655 [label="getDeclaredMembersAndInitializers() 225781"];
3656 [label="DeclaredMembersAndInitializers? getDeclaredMembersAndInitializers()\n            {\n                var declaredMembersAndInitializers = _lazyDeclaredMembersAndInitializers;\n                if (declaredMembersAndInitializers != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    return declaredMembersAndInitializers;\n                }\n\n                if (Volatile.Read(ref _lazyMembersAndInitializers) is not null)\n                {\n                    // We're previously computed declared members and already cleared them out\n                    // No need to compute them again\n                    return null;\n                }\n\n                var diagnostics = DiagnosticBag.GetInstance();\n                declaredMembersAndInitializers = buildDeclaredMembersAndInitializers(diagnostics);\n\n                var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel);\n                if (alreadyKnown != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    diagnostics.Free();\n                    return alreadyKnown;\n                }\n\n                AddDeclarationDiagnostics(diagnostics);\n                diagnostics.Free();\n\n                return declaredMembersAndInitializers!;\n            } 225782"];
3657 [label="var declaredMembersAndInitializers = _lazyDeclaredMembersAndInitializers; 225783"];
3658 [label="if (declaredMembersAndInitializers != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    return declaredMembersAndInitializers;\n                } 225784"];
3659 [label="if (Volatile.Read(ref _lazyMembersAndInitializers) is not null)\n                {\n                    // We're previously computed declared members and already cleared them out\n                    // No need to compute them again\n                    return null;\n                } 225785"];
3660 [label="var diagnostics = DiagnosticBag.GetInstance(); 225786"];
3661 [label="declaredMembersAndInitializers = buildDeclaredMembersAndInitializers(diagnostics); 225787"];
3662 [label="buildDeclaredMembersAndInitializers(diagnostics) 225788"];
3663 [label="DeclaredMembersAndInitializers? buildDeclaredMembersAndInitializers(DiagnosticBag diagnostics)\n            {\n                var builder = new DeclaredMembersAndInitializersBuilder();\n                AddDeclaredNontypeMembers(builder, diagnostics);\n\n                switch (TypeKind)\n                {\n                    case TypeKind.Struct:\n                        CheckForStructBadInitializers(builder, diagnostics);\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: false, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Enum:\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: true, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Class:\n                    case TypeKind.Interface:\n                    case TypeKind.Submission:\n                        // No additional checking required.\n                        break;\n\n                    default:\n                        break;\n                }\n\n                if (IsTupleType)\n                {\n                    builder.AddOrWrapTupleMembers(this);\n                }\n\n                if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                }\n\n                return builder.ToReadOnlyAndFree();\n            } 225789"];
3664 [label="DeclaredMembersAndInitializers? buildDeclaredMembersAndInitializers(DiagnosticBag diagnostics)\n            {\n                var builder = new DeclaredMembersAndInitializersBuilder();\n                AddDeclaredNontypeMembers(builder, diagnostics);\n\n                switch (TypeKind)\n                {\n                    case TypeKind.Struct:\n                        CheckForStructBadInitializers(builder, diagnostics);\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: false, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Enum:\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: true, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Class:\n                    case TypeKind.Interface:\n                    case TypeKind.Submission:\n                        // No additional checking required.\n                        break;\n\n                    default:\n                        break;\n                }\n\n                if (IsTupleType)\n                {\n                    builder.AddOrWrapTupleMembers(this);\n                }\n\n                if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                }\n\n                return builder.ToReadOnlyAndFree();\n            } 225790"];
3665 [label="var builder = new DeclaredMembersAndInitializersBuilder(); 225791"];
3666 [label="new DeclaredMembersAndInitializersBuilder() 225792"];
3667 [label="param DeclaredMembersAndInitializersBuilder(this) 225793"];
3668 [label="ArrayBuilder<Symbol>.GetInstance() 225794"];
3669 [label="NonTypeMembers = ArrayBuilder<Symbol>.GetInstance() 225795"];
3670 [label="ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 225796"];
3671 [label="StaticInitializers = ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 225797"];
3672 [label="ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 225798"];
3673 [label="InstanceInitializers = ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 225799"];
3674 [label="HaveIndexers 225800"];
3675 [label="RecordDeclarationWithParameters 225801"];
3676 [label="RecordPrimaryConstructor 225802"];
3677 [label="1 225803"];
3678 [label="InstanceInitializersIndexForRecordDeclarationWithParameters = -1 225804"];
3679 [label="IsNullableEnabledForInstanceConstructorsAndFields 225805"];
3680 [label="IsNullableEnabledForStaticConstructorsAndFields 225806"];
3681 [label="AddDeclaredNontypeMembers(builder, diagnostics); 225807"];
3682 [label="AddDeclaredNontypeMembers(builder, diagnostics); 225808"];
3683 [label="AddDeclaredNontypeMembers(builder, diagnostics) 225809"];
3684 [label="param AddDeclaredNontypeMembers(DeclaredMembersAndInitializersBuilder builder) 225810"];
3685 [label="param AddDeclaredNontypeMembers(DiagnosticBag diagnostics) 225811"];
3686 [label="param AddDeclaredNontypeMembers(this) 225812"];
3687 [label="foreach (var decl in this.declaration.Declarations)\n            {\n                if (!decl.HasAnyNontypeMembers)\n                {\n                    continue;\n                }\n\n                if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                }\n\n                var syntax = decl.SyntaxReference.GetSyntax();\n\n                switch (syntax.Kind())\n                {\n                    case SyntaxKind.EnumDeclaration:\n                        AddEnumMembers(builder, (EnumDeclarationSyntax)syntax, diagnostics);\n                        break;\n\n                    case SyntaxKind.DelegateDeclaration:\n                        SourceDelegateMethodSymbol.AddDelegateMembers(this, builder.NonTypeMembers, (DelegateDeclarationSyntax)syntax, diagnostics);\n                        break;\n\n                    case SyntaxKind.NamespaceDeclaration:\n                        // The members of a global anonymous type is in a syntax tree of a namespace declaration or a compilation unit.\n                        AddNonTypeMembers(builder, instanceInitializers: null, ((NamespaceDeclarationSyntax)syntax).Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.CompilationUnit:\n                        AddNonTypeMembers(builder, instanceInitializers: null, ((CompilationUnitSyntax)syntax).Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                        var typeDecl = (TypeDeclarationSyntax)syntax;\n                        AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.RecordDeclaration:\n                        var recordDecl = (RecordDeclarationSyntax)syntax;\n                        AddNonTypeMembers(builder,\n                            instanceInitializers: noteRecordParameters(recordDecl, builder, diagnostics),\n                            recordDecl.Members,\n                            diagnostics);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(syntax.Kind());\n                }\n            } 225813"];
3688 [label="if (!decl.HasAnyNontypeMembers)\n                {\n                    continue;\n                } 225814"];
3689 [label="if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                } 225815"];
3690 [label="var syntax = decl.SyntaxReference.GetSyntax(); 225816"];
3691 [label="switch (syntax.Kind())\n                {\n                    case SyntaxKind.EnumDeclaration:\n                        AddEnumMembers(builder, (EnumDeclarationSyntax)syntax, diagnostics);\n                        break;\n\n                    case SyntaxKind.DelegateDeclaration:\n                        SourceDelegateMethodSymbol.AddDelegateMembers(this, builder.NonTypeMembers, (DelegateDeclarationSyntax)syntax, diagnostics);\n                        break;\n\n                    case SyntaxKind.NamespaceDeclaration:\n                        // The members of a global anonymous type is in a syntax tree of a namespace declaration or a compilation unit.\n                        AddNonTypeMembers(builder, instanceInitializers: null, ((NamespaceDeclarationSyntax)syntax).Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.CompilationUnit:\n                        AddNonTypeMembers(builder, instanceInitializers: null, ((CompilationUnitSyntax)syntax).Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                        var typeDecl = (TypeDeclarationSyntax)syntax;\n                        AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.RecordDeclaration:\n                        var recordDecl = (RecordDeclarationSyntax)syntax;\n                        AddNonTypeMembers(builder,\n                            instanceInitializers: noteRecordParameters(recordDecl, builder, diagnostics),\n                            recordDecl.Members,\n                            diagnostics);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(syntax.Kind());\n                } 225817"];
3692 [label="var typeDecl = (TypeDeclarationSyntax)syntax; 225818"];
3693 [label="AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics); 225819"];
3694 [label="AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics); 225820"];
3695 [label="AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics); 225821"];
3696 [label="AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics); 225822"];
3697 [label="AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics) 225823"];
3698 [label="param AddNonTypeMembers(DeclaredMembersAndInitializersBuilder builder) 225824"];
3699 [label="param AddNonTypeMembers(ArrayBuilder<FieldOrPropertyInitializer>? instanceInitializers) 225825"];
3700 [label="param AddNonTypeMembers(SyntaxList<MemberDeclarationSyntax> members) 225826"];
3701 [label="param AddNonTypeMembers(DiagnosticBag diagnostics) 225827"];
3702 [label="param AddNonTypeMembers(this) 225828"];
3703 [label="if (members.Count == 0)\n            {\n                AddInitializers(builder.InstanceInitializers, instanceInitializers);\n                return;\n            } 225829"];
3704 [label="if (members.Count == 0)\n            {\n                AddInitializers(builder.InstanceInitializers, instanceInitializers);\n                return;\n            } 225830"];
3705 [label="var firstMember = members[0]; 225831"];
3706 [label="var firstMember = members[0]; 225832"];
3707 [label="var bodyBinder = this.GetBinder(firstMember); 225833"];
3708 [label="this.GetBinder(firstMember) 225834"];
3709 [label="param GetBinder(CSharpSyntaxNode syntaxNode) 225835"];
3710 [label="param GetBinder(this) 225836"];
3711 [label="this.DeclaringCompilation 225837"];
3712 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 225838"];
3713 [label="this.Kind 225839"];
3714 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 225840"];
3715 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 225841"];
3716 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 225842"];
3717 [label="this.ContainingSymbol 225843"];
3718 [label="get\n            {\n                return _containingSymbol;\n            } 225844"];
3719 [label="return _containingSymbol; 225845"];
3720 [label="var container = this.ContainingSymbol; 225846"];
3721 [label="return (object)container != null ? container.ContainingModule : null; 225847"];
3722 [label="return (object)container != null ? container.ContainingModule : null; 225848"];
3723 [label="(object)container != null 225849"];
3724 [label="container.ContainingModule 225850"];
3725 [label="return this.DeclaringCompilation.GetBinder(syntaxNode); 225851"];
3726 [label="return this.DeclaringCompilation.GetBinder(syntaxNode); 225852"];
3727 [label="this.DeclaringCompilation.GetBinder(syntaxNode) 225853"];
3728 [label="param GetBinder(CSharpSyntaxNode syntax) 225854"];
3729 [label="param GetBinder(this) 225855"];
3730 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 225856"];
3731 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 225857"];
3732 [label="GetBinderFactory(syntax.SyntaxTree) 225858"];
3733 [label="param GetBinderFactory(SyntaxTree syntaxTree) 225859"];
3734 [label="param GetBinderFactory(bool ignoreAccessibility = false) 225860"];
3735 [label="param GetBinderFactory(this) 225861"];
3736 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 225862"];
3737 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 225863"];
3738 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 225864"];
3739 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 225865"];
3740 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 225866"];
3741 [label="param GetBinderFactory(SyntaxTree syntaxTree) 225867"];
3742 [label="param GetBinderFactory(bool ignoreAccessibility) 225868"];
3743 [label="param GetBinderFactory(ref WeakReference<BinderFactory>[]? cachedBinderFactories) 225869"];
3744 [label="param GetBinderFactory(this) 225870"];
3745 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 225871"];
3746 [label="ignoreAccessibility 225872"];
3747 [label="_binderFactories 225873"];
3748 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 225874"];
3749 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 225875"];
3750 [label="var treeNum = GetSyntaxTreeOrdinal(syntaxTree); 225876"];
3751 [label="GetSyntaxTreeOrdinal(syntaxTree) 225877"];
3752 [label="param GetSyntaxTreeOrdinal(SyntaxTree tree) 225878"];
3753 [label="param GetSyntaxTreeOrdinal(this) 225879"];
3754 [label="Debug.Assert(this.ContainsSyntaxTree(tree)); 225880"];
3755 [label="this.ContainsSyntaxTree(tree) 225881"];
3756 [label="param ContainsSyntaxTree(SyntaxTree? syntaxTree) 225882"];
3757 [label="param ContainsSyntaxTree(this) 225883"];
3758 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 225884"];
3759 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 225885"];
3760 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 225886"];
3761 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 225887"];
3762 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 225888"];
3763 [label="return _syntaxAndDeclarations.GetLazyState().OrdinalMap[tree]; 225889"];
3764 [label="WeakReference<BinderFactory>[]? binderFactories = cachedBinderFactories; 225890"];
3765 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 225891"];
3766 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 225892"];
3767 [label="this.SyntaxTrees 225893"];
3768 [label="return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; 225894"];
3769 [label="binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length]; 225895"];
3770 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 225896"];
3771 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 225897"];
3772 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 225898"];
3773 [label="BinderFactory? previousFactory; 225899"];
3774 [label="var previousWeakReference = binderFactories[treeNum]; 225900"];
3775 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 225901"];
3776 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 225902"];
3777 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 225903"];
3778 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 225904"];
3779 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 225905"];
3780 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 225906"];
3781 [label="param AddNewFactory(SyntaxTree syntaxTree) 225907"];
3782 [label="param AddNewFactory(bool ignoreAccessibility) 225908"];
3783 [label="param AddNewFactory([NotNull] ref WeakReference<BinderFactory>? slot) 225909"];
3784 [label="param AddNewFactory(this) 225910"];
3785 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 225911"];
3786 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 225912"];
3787 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 225913"];
3788 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 225914"];
3789 [label="new BinderFactory(this, syntaxTree, ignoreAccessibility) 225915"];
3790 [label="param BinderFactory(CSharpCompilation compilation) 225916"];
3791 [label="param BinderFactory(SyntaxTree syntaxTree) 225917"];
3792 [label="param BinderFactory(bool ignoreAccessibility) 225918"];
3793 [label="param BinderFactory(this) 225919"];
3794 [label="_binderCache 225920"];
3795 [label="_compilation 225921"];
3796 [label="_syntaxTree 225922"];
3797 [label="_buckStopsHereBinder 225923"];
3798 [label="_ignoreAccessibility 225924"];
3799 [label="_binderFactoryVisitorPool 225925"];
3800 [label="_compilation 225926"];
3801 [label="_syntaxTree 225927"];
3802 [label="_ignoreAccessibility 225928"];
3803 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 225929"];
3804 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 225930"];
3805 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 225931"];
3806 [label="_binderFactoryVisitorPool 225932"];
3807 [label="_binderCache = new ConcurrentCache<BinderCacheKey, Binder>(50); 225933"];
3808 [label="_binderCache 225934"];
3809 [label="_buckStopsHereBinder = new BuckStopsHereBinder(compilation); 225935"];
3810 [label="_buckStopsHereBinder = new BuckStopsHereBinder(compilation); 225936"];
3811 [label="new BuckStopsHereBinder(compilation) 225937"];
3812 [label="param BuckStopsHereBinder(CSharpCompilation compilation) 225938"];
3813 [label="param BuckStopsHereBinder(this) 225939"];
3814 [label="0 225940"];
3815 [label="ExternalScope = 0 225941"];
3816 [label="1 225942"];
3817 [label="TopLevelScope = 1 225943"];
3818 [label="2 225944"];
3819 [label="ValueKindInsignificantBits = 2 225945"];
3820 [label="ValueKindSignificantBitsMask = unchecked((BindValueKind)~((1 << ValueKindInsignificantBits) - 1)) 225946"];
3821 [label="property =>\n            {\n                if (property.IsIndexer || !property.IsIndexedProperty)\n                {\n                    return false;\n                }\n\n                Debug.Assert(property.ParameterCount > 0);\n                var parameter = property.Parameters[0];\n                return !parameter.IsOptional && !parameter.IsParams;\n            } 225947"];
3822 [label="s_isIndexedPropertyWithNonOptionalArguments = property =>\n            {\n                if (property.IsIndexer || !property.IsIndexedProperty)\n                {\n                    return false;\n                }\n\n                Debug.Assert(property.ParameterCount > 0);\n                var parameter = property.Parameters[0];\n                return !parameter.IsOptional && !parameter.IsParams;\n            } 225948"];
3823 [label="globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted 225949"];
3824 [label="memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType 225950"];
3825 [label="SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes 225951"];
3826 [label="miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes 225952"];
3827 [label="new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 225953"];
3828 [label="new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 225954"];
3829 [label="s_propertyGroupFormat =\n            new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 225955"];
3830 [label="10 225956"];
3831 [label="MaxParameterListsForErrorRecovery = 10 225957"];
3832 [label="'<>h__TransparentIdentifier' 225958"];
3833 [label="transparentIdentifierPrefix = '<>h__TransparentIdentifier' 225959"];
3834 [label="s => (MethodSymbol)s 225960"];
3835 [label="s_toMethodSymbolFunc = s => (MethodSymbol)s 225961"];
3836 [label="s => (PropertySymbol)s 225962"];
3837 [label="s_toPropertySymbolFunc = s => (PropertySymbol)s 225963"];
3838 [label="compilation 225964"];
3839 [label="param BuckStopsHereBinder(this) 225965"];
3840 [label="param Binder(CSharpCompilation compilation) 225966"];
3841 [label="param Binder(this) 225967"];
3842 [label="internal CSharpCompilation Compilation { get; } 225968"];
3843 [label="Flags 225969"];
3844 [label="protected internal Binder? Next { get; } 225970"];
3845 [label="_lazyConversions 225971"];
3846 [label="_lazyOverloadResolution 225972"];
3847 [label="RoslynDebug.Assert(compilation != null); 225973"];
3848 [label="RoslynDebug.Assert(compilation != null); 225974"];
3849 [label="RoslynDebug.Assert(this is BuckStopsHereBinder); 225975"];
3850 [label="RoslynDebug.Assert(this is BuckStopsHereBinder); 225976"];
3851 [label="compilation.Options 225977"];
3852 [label="get\n            {\n                return _options;\n            } 225978"];
3853 [label="return _options; 225979"];
3854 [label="this.Flags = compilation.Options.TopLevelBinderFlags; 225980"];
3855 [label="this.Flags 225981"];
3856 [label="this.Compilation 225982"];
3857 [label="_buckStopsHereBinder 225983"];
3858 [label="var newWeakReference = new WeakReference<BinderFactory>(newFactory); 225984"];
3859 [label="var newWeakReference = new WeakReference<BinderFactory>(newFactory); 225985"];
3860 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 225986"];
3861 [label="BinderFactory? previousFactory; 225987"];
3862 [label="WeakReference<BinderFactory>? previousWeakReference = slot; 225988"];
3863 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 225989"];
3864 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 225990"];
3865 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 225991"];
3866 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 225992"];
3867 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 225993"];
3868 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 225994"];
3869 [label="return newFactory; 225995"];
3870 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 225996"];
3871 [label="GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax) 225997"];
3872 [label="param GetBinder(SyntaxNode node) 225998"];
3873 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 225999"];
3874 [label="param GetBinder(Symbol memberOpt = null) 226000"];
3875 [label="param GetBinder(this) 226001"];
3876 [label="int position = node.SpanStart; 226002"];
3877 [label="InScript 226003"];
3878 [label="get\n            {\n                return _syntaxTree.Options.Kind == SourceCodeKind.Script;\n            } 226004"];
3879 [label="return _syntaxTree.Options.Kind == SourceCodeKind.Script; 226005"];
3880 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 226006"];
3881 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 226007"];
3882 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 226008"];
3883 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 226009"];
3884 [label="node = node.Parent; 226010"];
3885 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 226011"];
3886 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 226012"];
3887 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 226013"];
3888 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 226014"];
3889 [label="GetBinder(node, position, memberDeclarationOpt, memberOpt) 226015"];
3890 [label="param GetBinder(SyntaxNode node) 226016"];
3891 [label="param GetBinder(int position) 226017"];
3892 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 226018"];
3893 [label="param GetBinder(Symbol memberOpt = null) 226019"];
3894 [label="param GetBinder(this) 226020"];
3895 [label="Debug.Assert(node != null); 226021"];
3896 [label="Debug.Assert(node != null); 226022"];
3897 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 226023"];
3898 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 226024"];
3899 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 226025"];
3900 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 226026"];
3901 [label="param BinderFactoryVisitor(BinderFactory factory) 226027"];
3902 [label="param BinderFactoryVisitor(this) 226028"];
3903 [label="param BinderFactoryVisitor(this) 226029"];
3904 [label="_position 226030"];
3905 [label="_memberDeclarationOpt 226031"];
3906 [label="_memberOpt 226032"];
3907 [label="_factory 226033"];
3908 [label="_factory 226034"];
3909 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 226035"];
3910 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 226036"];
3911 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 226037"];
3912 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 226038"];
3913 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt) 226039"];
3914 [label="param Initialize(int position) 226040"];
3915 [label="param Initialize(CSharpSyntaxNode memberDeclarationOpt) 226041"];
3916 [label="param Initialize(Symbol memberOpt) 226042"];
3917 [label="param Initialize(this) 226043"];
3918 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 226044"];
3919 [label="memberDeclarationOpt == null 226045"];
3920 [label="param ==(Symbol left) 226046"];
3921 [label="param ==(Symbol right) 226047"];
3922 [label="if (right is null)\n            {\n                return left is null;\n            } 226048"];
3923 [label="return left is null; 226049"];
3924 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 226050"];
3925 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 226051"];
3926 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 226052"];
3927 [label="_position 226053"];
3928 [label="_memberDeclarationOpt 226054"];
3929 [label="_memberOpt 226055"];
3930 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 226056"];
3931 [label="Binder result = visitor.Visit(node); 226057"];
3932 [label="visitor.Visit(node) 226058"];
3933 [label="param Visit(SyntaxNode node) 226059"];
3934 [label="param Visit(this) 226060"];
3935 [label="return VisitCore(node); 226061"];
3936 [label="VisitCore(node) 226062"];
3937 [label="param VisitCore(SyntaxNode node) 226063"];
3938 [label="param VisitCore(this) 226064"];
3939 [label="return ((CSharpSyntaxNode)node).Accept(this); 226065"];
3940 [label="return ((CSharpSyntaxNode)node).Accept(this); 226066"];
3941 [label="return ((CSharpSyntaxNode)node).Accept(this); 226067"];
3942 [label="param VisitClassDeclaration(ClassDeclarationSyntax node) 226068"];
3943 [label="param VisitClassDeclaration(this) 226069"];
3944 [label="return VisitTypeDeclarationCore(node); 226070"];
3945 [label="VisitTypeDeclarationCore(node) 226071"];
3946 [label="param VisitTypeDeclarationCore(TypeDeclarationSyntax parent) 226072"];
3947 [label="param VisitTypeDeclarationCore(this) 226073"];
3948 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 226074"];
3949 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 226075"];
3950 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 226076"];
3951 [label="NodeUsage extraInfo = NodeUsage.Normal; 226077"];
3952 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 226078"];
3953 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 226079"];
3954 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 226080"];
3955 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 226081"];
3956 [label="extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters; 226082"];
3957 [label="return VisitTypeDeclarationCore(parent, extraInfo); 226083"];
3958 [label="return VisitTypeDeclarationCore(parent, extraInfo); 226084"];
3959 [label="VisitTypeDeclarationCore(parent, extraInfo) 226085"];
3960 [label="param VisitTypeDeclarationCore(TypeDeclarationSyntax parent) 226086"];
3961 [label="param VisitTypeDeclarationCore(NodeUsage extraInfo) 226087"];
3962 [label="param VisitTypeDeclarationCore(this) 226088"];
3963 [label="var key = CreateBinderCacheKey(parent, extraInfo); 226089"];
3964 [label="var key = CreateBinderCacheKey(parent, extraInfo); 226090"];
3965 [label="CreateBinderCacheKey(parent, extraInfo) 226091"];
3966 [label="param CreateBinderCacheKey(CSharpSyntaxNode node) 226092"];
3967 [label="param CreateBinderCacheKey(NodeUsage usage) 226093"];
3968 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 226094"];
3969 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 226095"];
3970 [label="return new BinderCacheKey(node, usage); 226096"];
3971 [label="return new BinderCacheKey(node, usage); 226097"];
3972 [label="return new BinderCacheKey(node, usage); 226098"];
3973 [label="new BinderCacheKey(node, usage) 226099"];
3974 [label="param BinderCacheKey(CSharpSyntaxNode syntaxNode) 226100"];
3975 [label="param BinderCacheKey(NodeUsage usage) 226101"];
3976 [label="param BinderCacheKey(this) 226102"];
3977 [label="this.syntaxNode 226103"];
3978 [label="this.usage 226104"];
3979 [label="var key = CreateBinderCacheKey(parent, extraInfo); 226105"];
3980 [label="Binder resultBinder; 226106"];
3981 [label="binderCache 226107"];
3982 [label="get\n                {\n                    return _factory._binderCache;\n                } 226108"];
3983 [label="return _factory._binderCache; 226109"];
3984 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 226110"];
3985 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 226111"];
3986 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 226112"];
3987 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 226113"];
3988 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 226114"];
3989 [label="param GetHashCode(this) 226115"];
3990 [label="return Hash.Combine(syntaxNode.GetHashCode(), (int)usage); 226116"];
3991 [label="resultBinder = VisitCore(parent.Parent); 226117"];
3992 [label="VisitCore(parent.Parent) 226118"];
3993 [label="param VisitCore(SyntaxNode node) 226119"];
3994 [label="param VisitCompilationUnit(CompilationUnitSyntax parent) 226120"];
3995 [label="param VisitCompilationUnit(this) 226121"];
3996 [label="return VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript); 226122"];
3997 [label="IsInUsing(parent) 226123"];
3998 [label="param IsInUsing(CSharpSyntaxNode containingNode) 226124"];
3999 [label="param IsInUsing(this) 226125"];
4000 [label="TextSpan containingSpan = containingNode.Span; 226126"];
4001 [label="SyntaxToken token; 226127"];
4002 [label="token 226128"];
4003 [label="if (containingNode.Kind() != SyntaxKind.CompilationUnit && _position == containingSpan.End)\n                {\n                    // This occurs at EOF\n                    token = containingNode.GetLastToken();\n                    Debug.Assert(token == this.syntaxTree.GetRoot().GetLastToken());\n                }\n                else if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 226129"];
4004 [label="if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 226130"];
4005 [label="token = containingNode.FindToken(_position); 226131"];
4006 [label="token = containingNode.FindToken(_position); 226132"];
4007 [label="var node = token.Parent; 226133"];
4008 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 226134"];
4009 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 226135"];
4010 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 226136"];
4011 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 226137"];
4012 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 226138"];
4013 [label="node = node.Parent; 226139"];
4014 [label="return false; 226140"];
4015 [label="return VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript); 226141"];
4016 [label="InScript 226142"];
4017 [label="get\n                {\n                    return _factory.InScript;\n                } 226143"];
4018 [label="_factory.InScript 226144"];
4019 [label="get\n            {\n                return _syntaxTree.Options.Kind == SourceCodeKind.Script;\n            } 226145"];
4020 [label="return _factory.InScript; 226146"];
4021 [label="VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript) 226147"];
4022 [label="param VisitCompilationUnit(CompilationUnitSyntax compilationUnit) 226148"];
4023 [label="param VisitCompilationUnit(bool inUsing) 226149"];
4024 [label="param VisitCompilationUnit(bool inScript) 226150"];
4025 [label="param VisitCompilationUnit(this) 226151"];
4026 [label="syntaxTree 226152"];
4027 [label="get\n                {\n                    return _factory._syntaxTree;\n                } 226153"];
4028 [label="return _factory._syntaxTree; 226154"];
4029 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 226155"];
4030 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 226156"];
4031 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 226157"];
4032 [label="inUsing 226158"];
4033 [label="inScript 226159"];
4034 [label="var extraInfo = inUsing\n                    ? (inScript ? NodeUsage.CompilationUnitScriptUsings : NodeUsage.CompilationUnitUsings)\n                    : (inScript ? NodeUsage.CompilationUnitScript : NodeUsage.Normal); 226160"];
4035 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 226161"];
4036 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 226162"];
4037 [label="CreateBinderCacheKey(compilationUnit, extraInfo) 226163"];
4038 [label="param CreateBinderCacheKey(CSharpSyntaxNode node) 226164"];
4039 [label="param CreateBinderCacheKey(NodeUsage usage) 226165"];
4040 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 226166"];
4041 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 226167"];
4042 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 226168"];
4043 [label="Binder result; 226169"];
4044 [label="binderCache 226170"];
4045 [label="get\n                {\n                    return _factory._binderCache;\n                } 226171"];
4046 [label="return _factory._binderCache; 226172"];
4047 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 226173"];
4048 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 226174"];
4049 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 226175"];
4050 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 226176"];
4051 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 226177"];
4052 [label="this.buckStopsHereBinder 226178"];
4053 [label="get\n                {\n                    return _factory._buckStopsHereBinder;\n                } 226179"];
4054 [label="return _factory._buckStopsHereBinder; 226180"];
4055 [label="result = this.buckStopsHereBinder; 226181"];
4056 [label="if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    } 226182"];
4057 [label="compilation 226183"];
4058 [label="get\n                {\n                    return _factory._compilation;\n                } 226184"];
4059 [label="return _factory._compilation; 226185"];
4060 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 226186"];
4061 [label="compilation.GlobalNamespace 226187"];
4062 [label="get\n            {\n                if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                }\n\n                return _lazyGlobalNamespace;\n            } 226188"];
4063 [label="if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                } 226189"];
4064 [label="var modules = ArrayBuilder<ModuleSymbol>.GetInstance(); 226190"];
4065 [label="GetAllUnaliasedModules(modules); 226191"];
4066 [label="GetAllUnaliasedModules(modules) 226192"];
4067 [label="param GetAllUnaliasedModules(ArrayBuilder<ModuleSymbol> modules) 226193"];
4068 [label="param GetAllUnaliasedModules(this) 226194"];
4069 [label="Assembly 226195"];
4070 [label="get\n            {\n                return SourceAssembly;\n            } 226196"];
4071 [label="return _referenceManager; 226197"];
4072 [label="GetBoundReferenceManager(); 226198"];
4073 [label="modules.AddRange(Assembly.Modules); 226199"];
4074 [label="Assembly.Modules 226200"];
4075 [label="get\n            {\n                return _modules;\n            } 226201"];
4076 [label="modules.AddRange(Assembly.Modules); 226202"];
4077 [label="GetBoundReferenceManager() 226203"];
4078 [label="param GetBoundReferenceManager(this) 226204"];
4079 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 226205"];
4080 [label="return _referenceManager; 226206"];
4081 [label="var referenceManager = GetBoundReferenceManager(); 226207"];
4082 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                }\n            } 226208"];
4083 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                }\n            } 226209"];
4084 [label="if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                } 226210"];
4085 [label="modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules); 226211"];
4086 [label="referenceManager.ReferencedAssemblies[i].Modules 226212"];
4087 [label="get\n            {\n                return _modules;\n            } 226213"];
4088 [label="GetAllUnaliasedModules(modules); 226214"];
4089 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 226215"];
4090 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 226216"];
4091 [label="new NamespaceExtent(this) 226217"];
4092 [label="param NamespaceExtent(CSharpCompilation compilation) 226218"];
4093 [label="param NamespaceExtent(this) 226219"];
4094 [label="_kind 226220"];
4095 [label="_symbolOrCompilation 226221"];
4096 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 226222"];
4097 [label="param GetHashCode(this) 226223"];
4098 [label="return System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(this); 226224"];
4099 [label="get { return _globalNamespace; } 226225"];
4100 [label="return _globalNamespace; 226226"];
4101 [label="MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)) 226227"];
4102 [label="param Create(NamespaceExtent extent) 226228"];
4103 [label="param Create(NamespaceSymbol containingNamespace) 226229"];
4104 [label="param Create(ImmutableArray<NamespaceSymbol> namespacesToMerge) 226230"];
4105 [label="param Create(string nameOpt = null) 226231"];
4106 [label="Debug.Assert(namespacesToMerge.Length != 0); 226232"];
4107 [label="Debug.Assert(namespacesToMerge.Length != 0); 226233"];
4108 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 226234"];
4109 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 226235"];
4110 [label="(namespacesToMerge.Length == 1 && nameOpt == null) 226236"];
4111 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 226237"];
4112 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 226238"];
4113 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 226239"];
4114 [label="new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt) 226240"];
4115 [label="param MergedNamespaceSymbol(NamespaceExtent extent) 226241"];
4116 [label="param MergedNamespaceSymbol(NamespaceSymbol containingNamespace) 226242"];
4117 [label="param MergedNamespaceSymbol(ImmutableArray<NamespaceSymbol> namespacesToMerge) 226243"];
4118 [label="param MergedNamespaceSymbol(string nameOpt) 226244"];
4119 [label="param MergedNamespaceSymbol(this) 226245"];
4120 [label="param MergedNamespaceSymbol(this) 226246"];
4121 [label="_containingNamespace 226247"];
4122 [label="_nameOpt 226248"];
4123 [label="_cachedLookup 226249"];
4124 [label="_extent 226250"];
4125 [label="_namespacesToMerge 226251"];
4126 [label="_containingNamespace 226252"];
4127 [label="_cachedLookup = new CachingDictionary<string, Symbol>(SlowGetChildrenOfName, SlowGetChildNames, EqualityComparer<string>.Default); 226253"];
4128 [label="_cachedLookup = new CachingDictionary<string, Symbol>(SlowGetChildrenOfName, SlowGetChildNames, EqualityComparer<string>.Default); 226254"];
4129 [label="_cachedLookup 226255"];
4130 [label="_nameOpt 226256"];
4131 [label="foreach (NamespaceSymbol ns in namespacesToMerge)\n            {\n                Debug.Assert(ns.ConstituentNamespaces.Length == 1);\n            } 226257"];
4132 [label="ns.ConstituentNamespaces 226258"];
4133 [label="get\n            {\n                return ImmutableArray.Create(this);\n            } 226259"];
4134 [label="return ImmutableArray.Create(this); 226260"];
4135 [label="Debug.Assert(ns.ConstituentNamespaces.Length == 1); 226261"];
4136 [label="Debug.Assert(ns.ConstituentNamespaces.Length == 1); 226262"];
4137 [label="modules.Free(); 226263"];
4138 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 226264"];
4139 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 226265"];
4140 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 226266"];
4141 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 226267"];
4142 [label="return _lazyGlobalNamespace; 226268"];
4143 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 226269"];
4144 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 226270"];
4145 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 226271"];
4146 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 226272"];
4147 [label="new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing) 226273"];
4148 [label="param InContainerBinder(NamespaceOrTypeSymbol container) 226274"];
4149 [label="param InContainerBinder(Binder next) 226275"];
4150 [label="param InContainerBinder(CSharpSyntaxNode declarationSyntax) 226276"];
4151 [label="param InContainerBinder(bool inUsing) 226277"];
4152 [label="param InContainerBinder(this) 226278"];
4153 [label="next 226279"];
4154 [label="param InContainerBinder(this) 226280"];
4155 [label="param Binder(Binder next) 226281"];
4156 [label="param Binder(this) 226282"];
4157 [label="param Binder(Conversions? conversions = null) 226283"];
4158 [label="RoslynDebug.Assert(next != null); 226284"];
4159 [label="RoslynDebug.Assert(next != null); 226285"];
4160 [label="Next 226286"];
4161 [label="this.Flags 226287"];
4162 [label="this.Compilation 226288"];
4163 [label="_lazyConversions 226289"];
4164 [label="_container 226290"];
4165 [label="_computeImports 226291"];
4166 [label="_lazyImports 226292"];
4167 [label="_lazyImportChain 226293"];
4168 [label="_lazyQuickAttributeChecker 226294"];
4169 [label="Debug.Assert((object)container != null); 226295"];
4170 [label="Debug.Assert((object)container != null); 226296"];
4171 [label="Debug.Assert(declarationSyntax != null); 226297"];
4172 [label="Debug.Assert(declarationSyntax != null); 226298"];
4173 [label="_container 226299"];
4174 [label="_computeImports = basesBeingResolved => Imports.FromSyntax(declarationSyntax, this, basesBeingResolved, inUsing); 226300"];
4175 [label="_computeImports 226301"];
4176 [label="if (!inUsing)\n            {\n                if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                }\n            } 226302"];
4177 [label="if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                } 226303"];
4178 [label="var compilationUnit = (CompilationUnitSyntax)declarationSyntax; 226304"];
4179 [label="_usingsSyntax 226305"];
4180 [label="compilation 226306"];
4181 [label="get\n                {\n                    return _factory._compilation;\n                } 226307"];
4182 [label="return _factory._compilation; 226308"];
4183 [label="if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        } 226309"];
4184 [label="if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        } 226310"];
4185 [label="if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        } 226311"];
4186 [label="SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) 226312"];
4187 [label="param GetSimpleProgramEntryPoint(CSharpCompilation compilation) 226313"];
4188 [label="param GetSimpleProgramEntryPoint(CompilationUnitSyntax compilationUnit) 226314"];
4189 [label="param GetSimpleProgramEntryPoint(bool fallbackToMainEntryPoint) 226315"];
4190 [label="var type = GetSimpleProgramNamedTypeSymbol(compilation); 226316"];
4191 [label="GetSimpleProgramNamedTypeSymbol(compilation) 226317"];
4192 [label="param GetSimpleProgramNamedTypeSymbol(CSharpCompilation compilation) 226318"];
4193 [label="compilation.SourceModule 226319"];
4194 [label="get\n            {\n                return Assembly.Modules[0];\n            } 226320"];
4195 [label="GetBoundReferenceManager(); 226321"];
4196 [label="return compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName).OfType<SimpleProgramNamedTypeSymbol>().SingleOrDefault(); 226322"];
4197 [label="compilation.SourceModule.GlobalNamespace 226323"];
4198 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 226324"];
4199 [label="return compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName).OfType<SimpleProgramNamedTypeSymbol>().SingleOrDefault(); 226325"];
4200 [label="compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName) 226326"];
4201 [label="param GetTypeMembers(string name) 226327"];
4202 [label="param GetTypeMembers(this) 226328"];
4203 [label="if (type is null)\n            {\n                return null;\n            } 226329"];
4204 [label="return null; 226330"];
4205 [label="binderCache 226331"];
4206 [label="return _factory._binderCache; 226332"];
4207 [label="binderCache.TryAdd(key, result); 226333"];
4208 [label="binderCache.TryAdd(key, result); 226334"];
4209 [label="binderCache.TryAdd(key, result); 226335"];
4210 [label="binderCache.TryAdd(key, result); 226336"];
4211 [label="binderCache.TryAdd(key, result); 226337"];
4212 [label="return result; 226338"];
4213 [label="return ((CSharpSyntaxNode)node).Accept(this); 226339"];
4214 [label="if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    } 226340"];
4215 [label="resultBinder.ContainingMemberOrLambda 226341"];
4216 [label="get\n            {\n                var merged = _container as MergedNamespaceSymbol;\n                return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container;\n            } 226342"];
4217 [label="var merged = _container as MergedNamespaceSymbol; 226343"];
4218 [label="return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container; 226344"];
4219 [label="return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container; 226345"];
4220 [label="((object)merged != null) 226346"];
4221 [label="merged.GetConstituentForCompilation(this.Compilation) 226347"];
4222 [label="param GetConstituentForCompilation(CSharpCompilation compilation) 226348"];
4223 [label="param GetConstituentForCompilation(this) 226349"];
4224 [label="foreach (var n in _namespacesToMerge)\n            {\n                if (n.IsFromCompilation(compilation))\n                    return n;\n            } 226350"];
4225 [label="if (n.IsFromCompilation(compilation))\n                    return n; 226351"];
4226 [label="n.IsFromCompilation(compilation) 226352"];
4227 [label="param IsFromCompilation(CSharpCompilation compilation) 226353"];
4228 [label="param IsFromCompilation(this) 226354"];
4229 [label="Debug.Assert(compilation != null); 226355"];
4230 [label="Debug.Assert(compilation != null); 226356"];
4231 [label="this.DeclaringCompilation 226357"];
4232 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 226358"];
4233 [label="this.Kind 226359"];
4234 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 226360"];
4235 [label="return SymbolKind.Namespace; 226361"];
4236 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 226362"];
4237 [label="return compilation == this.DeclaringCompilation; 226363"];
4238 [label="return compilation == this.DeclaringCompilation; 226364"];
4239 [label="return n; 226365"];
4240 [label="var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent); 226366"];
4241 [label="var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent); 226367"];
4242 [label="((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent) 226368"];
4243 [label="param GetSourceTypeMember(TypeDeclarationSyntax syntax) 226369"];
4244 [label="param GetSourceTypeMember(this) 226370"];
4245 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 226371"];
4246 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 226372"];
4247 [label="GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax) 226373"];
4248 [label="param GetSourceTypeMember(string name) 226374"];
4249 [label="param GetSourceTypeMember(int arity) 226375"];
4250 [label="param GetSourceTypeMember(SyntaxKind kind) 226376"];
4251 [label="param GetSourceTypeMember(CSharpSyntaxNode syntax) 226377"];
4252 [label="param GetSourceTypeMember(this) 226378"];
4253 [label="TypeKind typeKind = kind.ToDeclarationKind().ToTypeKind(); 226379"];
4254 [label="kind.ToDeclarationKind().ToTypeKind() 226380"];
4255 [label="param ToTypeKind(this DeclarationKind kind) 226381"];
4256 [label="foreach (var member in GetTypeMembers(name, arity))\n            {\n                var memberT = member as SourceNamedTypeSymbol;\n                if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                }\n            } 226382"];
4257 [label="foreach (var member in GetTypeMembers(name, arity))\n            {\n                var memberT = member as SourceNamedTypeSymbol;\n                if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                }\n            } 226383"];
4258 [label="GetTypeMembers(name, arity) 226384"];
4259 [label="param GetTypeMembers(string name) 226385"];
4260 [label="param GetTypeMembers(int arity) 226386"];
4261 [label="param GetTypeMembers(this) 226387"];
4262 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 226388"];
4263 [label="GetTypeMembers(name) 226389"];
4264 [label="param GetTypeMembers(string name) 226390"];
4265 [label="param GetTypeMembers(this) 226391"];
4266 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 226392"];
4267 [label="return _nameToTypeMembersMap; 226393"];
4268 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 226394"];
4269 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 226395"];
4270 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 226396"];
4271 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 226397"];
4272 [label="get\n            {\n                return declaration.Arity;\n            } 226398"];
4273 [label="return declaration.Arity; 226399"];
4274 [label="var memberT = member as SourceNamedTypeSymbol; 226400"];
4275 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 226401"];
4276 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 226402"];
4277 [label="memberT.TypeKind 226403"];
4278 [label="get\n            {\n                return _flags.TypeKind;\n            } 226404"];
4279 [label="_flags.TypeKind 226405"];
4280 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 226406"];
4281 [label="return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); 226407"];
4282 [label="return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); 226408"];
4283 [label="return _flags.TypeKind; 226409"];
4284 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 226410"];
4285 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 226411"];
4286 [label="if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    } 226412"];
4287 [label="if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    } 226413"];
4288 [label="memberT.Locations 226414"];
4289 [label="foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        } 226415"];
4290 [label="if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            } 226416"];
4291 [label="if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            } 226417"];
4292 [label="return memberT; 226418"];
4293 [label="if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        } 226419"];
4294 [label="resultBinder = new InContainerBinder(typeSymbol, resultBinder); 226420"];
4295 [label="resultBinder = new InContainerBinder(typeSymbol, resultBinder); 226421"];
4296 [label="resultBinder = new InContainerBinder(typeSymbol, resultBinder); 226422"];
4297 [label="new InContainerBinder(typeSymbol, resultBinder) 226423"];
4298 [label="param InContainerBinder(NamespaceOrTypeSymbol container) 226424"];
4299 [label="param InContainerBinder(Binder next) 226425"];
4300 [label="param InContainerBinder(Imports imports = null) 226426"];
4301 [label="param InContainerBinder(this) 226427"];
4302 [label="next 226428"];
4303 [label="param InContainerBinder(this) 226429"];
4304 [label="param Binder(Binder next) 226430"];
4305 [label="param Binder(this) 226431"];
4306 [label="param Binder(Conversions? conversions = null) 226432"];
4307 [label="RoslynDebug.Assert(next != null); 226433"];
4308 [label="RoslynDebug.Assert(next != null); 226434"];
4309 [label="this.Flags 226435"];
4310 [label="this.Compilation 226436"];
4311 [label="_lazyConversions 226437"];
4312 [label="_container 226438"];
4313 [label="_computeImports 226439"];
4314 [label="_lazyImports 226440"];
4315 [label="_lazyImportChain 226441"];
4316 [label="_lazyQuickAttributeChecker 226442"];
4317 [label="Debug.Assert((object)container != null || imports != null); 226443"];
4318 [label="Debug.Assert((object)container != null || imports != null); 226444"];
4319 [label="_container 226445"];
4320 [label="null 226446"];
4321 [label="ImmutableDictionary<string, AliasAndUsingDirective>.Empty 226447"];
4322 [label="ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty 226448"];
4323 [label="ImmutableArray<AliasAndExternAliasDirective>.Empty 226449"];
4324 [label="null 226450"];
4325 [label="new Imports(\n            null,\n            ImmutableDictionary<string, AliasAndUsingDirective>.Empty,\n            ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty,\n            ImmutableArray<AliasAndExternAliasDirective>.Empty,\n            null) 226451"];
4326 [label="param Imports(CSharpCompilation compilation) 226452"];
4327 [label="param Imports(ImmutableDictionary<string, AliasAndUsingDirective> usingAliases) 226453"];
4328 [label="param Imports(ImmutableArray<NamespaceOrTypeAndUsingDirective> usings) 226454"];
4329 [label="param Imports(ImmutableArray<AliasAndExternAliasDirective> externs) 226455"];
4330 [label="param Imports(DiagnosticBag diagnostics) 226456"];
4331 [label="param Imports(this) 226457"];
4332 [label="_compilation 226458"];
4333 [label="_diagnostics 226459"];
4334 [label="UsingAliases 226460"];
4335 [label="Debug.Assert(usingAliases != null); 226461"];
4336 [label="Debug.Assert(usingAliases != null); 226462"];
4337 [label="Debug.Assert(!usings.IsDefault); 226463"];
4338 [label="Debug.Assert(!externs.IsDefault); 226464"];
4339 [label="_compilation 226465"];
4340 [label="this.UsingAliases 226466"];
4341 [label="this.Usings 226467"];
4342 [label="_diagnostics 226468"];
4343 [label="this.ExternAliases 226469"];
4344 [label="Empty = new Imports(\n            null,\n            ImmutableDictionary<string, AliasAndUsingDirective>.Empty,\n            ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty,\n            ImmutableArray<AliasAndExternAliasDirective>.Empty,\n            null) 226470"];
4345 [label="_lazyImports = imports ?? Imports.Empty; 226471"];
4346 [label="_lazyImports = imports ?? Imports.Empty; 226472"];
4347 [label="_lazyImports 226473"];
4348 [label="if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            } 226474"];
4349 [label="if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            } 226475"];
4350 [label="resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers); 226476"];
4351 [label="resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers) 226477"];
4352 [label="param WithUnsafeRegionIfNecessary(SyntaxTokenList modifiers) 226478"];
4353 [label="param WithUnsafeRegionIfNecessary(this) 226479"];
4354 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 226480"];
4355 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 226481"];
4356 [label="this.Flags.Includes(BinderFlags.UnsafeRegion) 226482"];
4357 [label="param Includes(this BinderFlags self) 226483"];
4358 [label="param Includes(BinderFlags other) 226484"];
4359 [label="return (self & other) == other; 226485"];
4360 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 226486"];
4361 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 226487"];
4362 [label="(this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword)) 226488"];
4363 [label="binderCache 226489"];
4364 [label="return _factory._binderCache; 226490"];
4365 [label="binderCache.TryAdd(key, resultBinder); 226491"];
4366 [label="binderCache.TryAdd(key, resultBinder); 226492"];
4367 [label="binderCache.TryAdd(key, resultBinder); 226493"];
4368 [label="binderCache.TryAdd(key, resultBinder); 226494"];
4369 [label="binderCache.TryAdd(key, resultBinder); 226495"];
4370 [label="return resultBinder; 226496"];
4371 [label="return ((CSharpSyntaxNode)node).Accept(this); 226497"];
4372 [label="_binderFactoryVisitorPool.Free(visitor); 226498"];
4373 [label="_binderFactoryVisitorPool.Free(visitor); 226499"];
4374 [label="return result; 226500"];
4375 [label="ArrayBuilder<FieldOrPropertyInitializer>? staticInitializers = null; 226501"];
4376 [label="DeclaringCompilation 226502"];
4377 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 226503"];
4378 [label="this.Kind 226504"];
4379 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 226505"];
4380 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 226506"];
4381 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 226507"];
4382 [label="this.ContainingSymbol 226508"];
4383 [label="get\n            {\n                return _containingSymbol;\n            } 226509"];
4384 [label="return _containingSymbol; 226510"];
4385 [label="return (object)container != null ? container.ContainingModule : null; 226511"];
4386 [label="var compilation = DeclaringCompilation; 226512"];
4387 [label="foreach (var m in members)\n            {\n                if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                }\n\n                bool reportMisplacedGlobalCode = !m.HasErrors;\n\n                switch (m.Kind())\n                {\n                    case SyntaxKind.FieldDeclaration:\n                        {\n                            var fieldSyntax = (FieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(fieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            bool modifierErrors;\n                            var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors);\n                            foreach (var variable in fieldSyntax.Declaration.Variables)\n                            {\n                                var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics);\n                                builder.NonTypeMembers.Add(fieldSymbol);\n                                // All fields are included in the nullable context for constructors and initializers, even fields without\n                                // initializers, to ensure warnings are reported for uninitialized non-nullable fields in NullableWalker.\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable);\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                }\n\n                                if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.MethodDeclaration:\n                        {\n                            var methodSyntax = (MethodDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(methodSyntax.Identifier));\n                            }\n\n                            var method = SourceOrdinaryMethodSymbol.CreateMethodSymbol(this, bodyBinder, methodSyntax, compilation.IsNullableAnalysisEnabledIn(methodSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.ConstructorDeclaration:\n                        {\n                            var constructorSyntax = (ConstructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(constructorSyntax.Identifier));\n                            }\n\n                            bool isNullableEnabled = compilation.IsNullableAnalysisEnabledIn(constructorSyntax);\n                            var constructor = SourceConstructorSymbol.CreateConstructorSymbol(this, constructorSyntax, isNullableEnabled, diagnostics);\n                            builder.NonTypeMembers.Add(constructor);\n                            if (constructorSyntax.Initializer?.Kind() != SyntaxKind.ThisConstructorInitializer)\n                            {\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: constructor.IsStatic, isNullableEnabled);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.DestructorDeclaration:\n                        {\n                            var destructorSyntax = (DestructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(destructorSyntax.Identifier));\n                            }\n\n                            // CONSIDER: if this doesn't (directly or indirectly) override object.Finalize, the\n                            // runtime won't consider it a finalizer and it will not be marked as a destructor\n                            // when it is loaded from metadata.  Perhaps we should just treat it as an Ordinary\n                            // method in such cases?\n                            var destructor = new SourceDestructorSymbol(this, destructorSyntax, compilation.IsNullableAnalysisEnabledIn(destructorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(destructor);\n                        }\n                        break;\n\n                    case SyntaxKind.PropertyDeclaration:\n                        {\n                            var propertySyntax = (PropertyDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(propertySyntax.Identifier));\n                            }\n\n                            var property = SourcePropertySymbol.Create(this, bodyBinder, propertySyntax, diagnostics);\n                            builder.NonTypeMembers.Add(property);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.SetMethod);\n                            FieldSymbol backingField = property.BackingField;\n\n                            // TODO: can we leave this out of the member list?\n                            // From the 10/12/11 design notes:\n                            //   In addition, we will change autoproperties to behavior in\n                            //   a similar manner and make the autoproperty fields private.\n                            if ((object)backingField != null)\n                            {\n                                builder.NonTypeMembers.Add(backingField);\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: backingField.IsStatic, compilation, propertySyntax);\n\n                                var initializer = propertySyntax.Initializer;\n                                if (initializer != null)\n                                {\n                                    if (IsScriptClass)\n                                    {\n                                        // also gather expression-declared variables from the initializer\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                                                      initializer,\n                                                                                      this,\n                                                                                      DeclarationModifiers.Private | (property.IsStatic ? DeclarationModifiers.Static : 0),\n                                                                                      backingField);\n                                    }\n\n                                    if (property.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, backingField, initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, backingField, initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventFieldDeclaration:\n                        {\n                            var eventFieldSyntax = (EventFieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(\n                                    ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventFieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            foreach (VariableDeclaratorSyntax declarator in eventFieldSyntax.Declaration.Variables)\n                            {\n                                SourceFieldLikeEventSymbol @event = new SourceFieldLikeEventSymbol(this, bodyBinder, eventFieldSyntax.Modifiers, declarator, diagnostics);\n                                builder.NonTypeMembers.Add(@event);\n\n                                FieldSymbol? associatedField = @event.AssociatedField;\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, declarator, this,\n                                                            DeclarationModifiers.Private | (@event.IsStatic ? DeclarationModifiers.Static : 0),\n                                                            associatedField);\n                                }\n\n                                if ((object?)associatedField != null)\n                                {\n                                    // NOTE: specifically don't add the associated field to the members list\n                                    // (regard it as an implementation detail).\n\n                                    builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: associatedField.IsStatic, compilation, declarator);\n\n                                    if (declarator.Initializer != null)\n                                    {\n                                        if (associatedField.IsStatic)\n                                        {\n                                            AddInitializer(ref staticInitializers, associatedField, declarator.Initializer);\n                                        }\n                                        else\n                                        {\n                                            AddInitializer(ref instanceInitializers, associatedField, declarator.Initializer);\n                                        }\n                                    }\n                                }\n\n                                Debug.Assert((object)@event.AddMethod != null);\n                                Debug.Assert((object)@event.RemoveMethod != null);\n\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventDeclaration:\n                        {\n                            var eventSyntax = (EventDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventSyntax.Identifier));\n                            }\n\n                            var @event = new SourceCustomEventSymbol(this, bodyBinder, eventSyntax, diagnostics);\n\n                            builder.NonTypeMembers.Add(@event);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n\n                            Debug.Assert(@event.AssociatedField is null);\n                        }\n                        break;\n\n                    case SyntaxKind.IndexerDeclaration:\n                        {\n                            var indexerSyntax = (IndexerDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(indexerSyntax.ThisKeyword));\n                            }\n\n                            var indexer = SourcePropertySymbol.Create(this, bodyBinder, indexerSyntax, diagnostics);\n                            builder.HaveIndexers = true;\n                            builder.NonTypeMembers.Add(indexer);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.SetMethod);\n                        }\n                        break;\n\n                    case SyntaxKind.ConversionOperatorDeclaration:\n                        {\n                            var conversionOperatorSyntax = (ConversionOperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(conversionOperatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedConversionSymbol.CreateUserDefinedConversionSymbol(\n                                this, conversionOperatorSyntax, compilation.IsNullableAnalysisEnabledIn(conversionOperatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.OperatorDeclaration:\n                        {\n                            var operatorSyntax = (OperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(operatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedOperatorSymbol.CreateUserDefinedOperatorSymbol(\n                                this, operatorSyntax, compilation.IsNullableAnalysisEnabledIn(operatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.GlobalStatement:\n                        {\n                            var globalStatement = ((GlobalStatementSyntax)m).Statement;\n\n                            if (IsScriptClass)\n                            {\n                                var innerStatement = globalStatement;\n\n                                // drill into any LabeledStatements\n                                while (innerStatement.Kind() == SyntaxKind.LabeledStatement)\n                                {\n                                    innerStatement = ((LabeledStatementSyntax)innerStatement).Statement;\n                                }\n\n                                switch (innerStatement.Kind())\n                                {\n                                    case SyntaxKind.LocalDeclarationStatement:\n                                        // We shouldn't reach this place, but field declarations preceded with a label end up here.\n                                        // This is tracked by https://github.com/dotnet/roslyn/issues/13712. Let's do our best for now.\n                                        var decl = (LocalDeclarationStatementSyntax)innerStatement;\n                                        foreach (var vdecl in decl.Declaration.Variables)\n                                        {\n                                            // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                            ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, vdecl, this, DeclarationModifiers.Private,\n                                                                                          containingFieldOpt: null);\n                                        }\n                                        break;\n\n                                    case SyntaxKind.ExpressionStatement:\n                                    case SyntaxKind.IfStatement:\n                                    case SyntaxKind.YieldReturnStatement:\n                                    case SyntaxKind.ReturnStatement:\n                                    case SyntaxKind.ThrowStatement:\n                                    case SyntaxKind.SwitchStatement:\n                                    case SyntaxKind.LockStatement:\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                  innerStatement,\n                                                  this,\n                                                  DeclarationModifiers.Private,\n                                                  containingFieldOpt: null);\n                                        break;\n\n                                    default:\n                                        // no other statement introduces variables into the enclosing scope\n                                        break;\n                                }\n\n                                AddInitializer(ref instanceInitializers, null, globalStatement);\n                            }\n                            else if (reportMisplacedGlobalCode && !SyntaxFacts.IsSimpleProgramTopLevelStatement((GlobalStatementSyntax)m))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_GlobalStatement, new SourceLocation(globalStatement));\n                            }\n                        }\n                        break;\n\n                    default:\n                        Debug.Assert(\n                            SyntaxFacts.IsTypeDeclaration(m.Kind()) ||\n                            m.Kind() == SyntaxKind.NamespaceDeclaration ||\n                            m.Kind() == SyntaxKind.IncompleteMember);\n                        break;\n                }\n            } 226513"];
4388 [label="foreach (var m in members)\n            {\n                if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                }\n\n                bool reportMisplacedGlobalCode = !m.HasErrors;\n\n                switch (m.Kind())\n                {\n                    case SyntaxKind.FieldDeclaration:\n                        {\n                            var fieldSyntax = (FieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(fieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            bool modifierErrors;\n                            var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors);\n                            foreach (var variable in fieldSyntax.Declaration.Variables)\n                            {\n                                var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics);\n                                builder.NonTypeMembers.Add(fieldSymbol);\n                                // All fields are included in the nullable context for constructors and initializers, even fields without\n                                // initializers, to ensure warnings are reported for uninitialized non-nullable fields in NullableWalker.\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable);\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                }\n\n                                if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.MethodDeclaration:\n                        {\n                            var methodSyntax = (MethodDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(methodSyntax.Identifier));\n                            }\n\n                            var method = SourceOrdinaryMethodSymbol.CreateMethodSymbol(this, bodyBinder, methodSyntax, compilation.IsNullableAnalysisEnabledIn(methodSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.ConstructorDeclaration:\n                        {\n                            var constructorSyntax = (ConstructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(constructorSyntax.Identifier));\n                            }\n\n                            bool isNullableEnabled = compilation.IsNullableAnalysisEnabledIn(constructorSyntax);\n                            var constructor = SourceConstructorSymbol.CreateConstructorSymbol(this, constructorSyntax, isNullableEnabled, diagnostics);\n                            builder.NonTypeMembers.Add(constructor);\n                            if (constructorSyntax.Initializer?.Kind() != SyntaxKind.ThisConstructorInitializer)\n                            {\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: constructor.IsStatic, isNullableEnabled);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.DestructorDeclaration:\n                        {\n                            var destructorSyntax = (DestructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(destructorSyntax.Identifier));\n                            }\n\n                            // CONSIDER: if this doesn't (directly or indirectly) override object.Finalize, the\n                            // runtime won't consider it a finalizer and it will not be marked as a destructor\n                            // when it is loaded from metadata.  Perhaps we should just treat it as an Ordinary\n                            // method in such cases?\n                            var destructor = new SourceDestructorSymbol(this, destructorSyntax, compilation.IsNullableAnalysisEnabledIn(destructorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(destructor);\n                        }\n                        break;\n\n                    case SyntaxKind.PropertyDeclaration:\n                        {\n                            var propertySyntax = (PropertyDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(propertySyntax.Identifier));\n                            }\n\n                            var property = SourcePropertySymbol.Create(this, bodyBinder, propertySyntax, diagnostics);\n                            builder.NonTypeMembers.Add(property);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.SetMethod);\n                            FieldSymbol backingField = property.BackingField;\n\n                            // TODO: can we leave this out of the member list?\n                            // From the 10/12/11 design notes:\n                            //   In addition, we will change autoproperties to behavior in\n                            //   a similar manner and make the autoproperty fields private.\n                            if ((object)backingField != null)\n                            {\n                                builder.NonTypeMembers.Add(backingField);\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: backingField.IsStatic, compilation, propertySyntax);\n\n                                var initializer = propertySyntax.Initializer;\n                                if (initializer != null)\n                                {\n                                    if (IsScriptClass)\n                                    {\n                                        // also gather expression-declared variables from the initializer\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                                                      initializer,\n                                                                                      this,\n                                                                                      DeclarationModifiers.Private | (property.IsStatic ? DeclarationModifiers.Static : 0),\n                                                                                      backingField);\n                                    }\n\n                                    if (property.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, backingField, initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, backingField, initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventFieldDeclaration:\n                        {\n                            var eventFieldSyntax = (EventFieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(\n                                    ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventFieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            foreach (VariableDeclaratorSyntax declarator in eventFieldSyntax.Declaration.Variables)\n                            {\n                                SourceFieldLikeEventSymbol @event = new SourceFieldLikeEventSymbol(this, bodyBinder, eventFieldSyntax.Modifiers, declarator, diagnostics);\n                                builder.NonTypeMembers.Add(@event);\n\n                                FieldSymbol? associatedField = @event.AssociatedField;\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, declarator, this,\n                                                            DeclarationModifiers.Private | (@event.IsStatic ? DeclarationModifiers.Static : 0),\n                                                            associatedField);\n                                }\n\n                                if ((object?)associatedField != null)\n                                {\n                                    // NOTE: specifically don't add the associated field to the members list\n                                    // (regard it as an implementation detail).\n\n                                    builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: associatedField.IsStatic, compilation, declarator);\n\n                                    if (declarator.Initializer != null)\n                                    {\n                                        if (associatedField.IsStatic)\n                                        {\n                                            AddInitializer(ref staticInitializers, associatedField, declarator.Initializer);\n                                        }\n                                        else\n                                        {\n                                            AddInitializer(ref instanceInitializers, associatedField, declarator.Initializer);\n                                        }\n                                    }\n                                }\n\n                                Debug.Assert((object)@event.AddMethod != null);\n                                Debug.Assert((object)@event.RemoveMethod != null);\n\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventDeclaration:\n                        {\n                            var eventSyntax = (EventDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventSyntax.Identifier));\n                            }\n\n                            var @event = new SourceCustomEventSymbol(this, bodyBinder, eventSyntax, diagnostics);\n\n                            builder.NonTypeMembers.Add(@event);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n\n                            Debug.Assert(@event.AssociatedField is null);\n                        }\n                        break;\n\n                    case SyntaxKind.IndexerDeclaration:\n                        {\n                            var indexerSyntax = (IndexerDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(indexerSyntax.ThisKeyword));\n                            }\n\n                            var indexer = SourcePropertySymbol.Create(this, bodyBinder, indexerSyntax, diagnostics);\n                            builder.HaveIndexers = true;\n                            builder.NonTypeMembers.Add(indexer);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.SetMethod);\n                        }\n                        break;\n\n                    case SyntaxKind.ConversionOperatorDeclaration:\n                        {\n                            var conversionOperatorSyntax = (ConversionOperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(conversionOperatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedConversionSymbol.CreateUserDefinedConversionSymbol(\n                                this, conversionOperatorSyntax, compilation.IsNullableAnalysisEnabledIn(conversionOperatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.OperatorDeclaration:\n                        {\n                            var operatorSyntax = (OperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(operatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedOperatorSymbol.CreateUserDefinedOperatorSymbol(\n                                this, operatorSyntax, compilation.IsNullableAnalysisEnabledIn(operatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.GlobalStatement:\n                        {\n                            var globalStatement = ((GlobalStatementSyntax)m).Statement;\n\n                            if (IsScriptClass)\n                            {\n                                var innerStatement = globalStatement;\n\n                                // drill into any LabeledStatements\n                                while (innerStatement.Kind() == SyntaxKind.LabeledStatement)\n                                {\n                                    innerStatement = ((LabeledStatementSyntax)innerStatement).Statement;\n                                }\n\n                                switch (innerStatement.Kind())\n                                {\n                                    case SyntaxKind.LocalDeclarationStatement:\n                                        // We shouldn't reach this place, but field declarations preceded with a label end up here.\n                                        // This is tracked by https://github.com/dotnet/roslyn/issues/13712. Let's do our best for now.\n                                        var decl = (LocalDeclarationStatementSyntax)innerStatement;\n                                        foreach (var vdecl in decl.Declaration.Variables)\n                                        {\n                                            // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                            ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, vdecl, this, DeclarationModifiers.Private,\n                                                                                          containingFieldOpt: null);\n                                        }\n                                        break;\n\n                                    case SyntaxKind.ExpressionStatement:\n                                    case SyntaxKind.IfStatement:\n                                    case SyntaxKind.YieldReturnStatement:\n                                    case SyntaxKind.ReturnStatement:\n                                    case SyntaxKind.ThrowStatement:\n                                    case SyntaxKind.SwitchStatement:\n                                    case SyntaxKind.LockStatement:\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                  innerStatement,\n                                                  this,\n                                                  DeclarationModifiers.Private,\n                                                  containingFieldOpt: null);\n                                        break;\n\n                                    default:\n                                        // no other statement introduces variables into the enclosing scope\n                                        break;\n                                }\n\n                                AddInitializer(ref instanceInitializers, null, globalStatement);\n                            }\n                            else if (reportMisplacedGlobalCode && !SyntaxFacts.IsSimpleProgramTopLevelStatement((GlobalStatementSyntax)m))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_GlobalStatement, new SourceLocation(globalStatement));\n                            }\n                        }\n                        break;\n\n                    default:\n                        Debug.Assert(\n                            SyntaxFacts.IsTypeDeclaration(m.Kind()) ||\n                            m.Kind() == SyntaxKind.NamespaceDeclaration ||\n                            m.Kind() == SyntaxKind.IncompleteMember);\n                        break;\n                }\n            } 226514"];
4389 [label="if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                } 226515"];
4390 [label="bool reportMisplacedGlobalCode = !m.HasErrors; 226516"];
4391 [label="switch (m.Kind())\n                {\n                    case SyntaxKind.FieldDeclaration:\n                        {\n                            var fieldSyntax = (FieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(fieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            bool modifierErrors;\n                            var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors);\n                            foreach (var variable in fieldSyntax.Declaration.Variables)\n                            {\n                                var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics);\n                                builder.NonTypeMembers.Add(fieldSymbol);\n                                // All fields are included in the nullable context for constructors and initializers, even fields without\n                                // initializers, to ensure warnings are reported for uninitialized non-nullable fields in NullableWalker.\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable);\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                }\n\n                                if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.MethodDeclaration:\n                        {\n                            var methodSyntax = (MethodDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(methodSyntax.Identifier));\n                            }\n\n                            var method = SourceOrdinaryMethodSymbol.CreateMethodSymbol(this, bodyBinder, methodSyntax, compilation.IsNullableAnalysisEnabledIn(methodSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.ConstructorDeclaration:\n                        {\n                            var constructorSyntax = (ConstructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(constructorSyntax.Identifier));\n                            }\n\n                            bool isNullableEnabled = compilation.IsNullableAnalysisEnabledIn(constructorSyntax);\n                            var constructor = SourceConstructorSymbol.CreateConstructorSymbol(this, constructorSyntax, isNullableEnabled, diagnostics);\n                            builder.NonTypeMembers.Add(constructor);\n                            if (constructorSyntax.Initializer?.Kind() != SyntaxKind.ThisConstructorInitializer)\n                            {\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: constructor.IsStatic, isNullableEnabled);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.DestructorDeclaration:\n                        {\n                            var destructorSyntax = (DestructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(destructorSyntax.Identifier));\n                            }\n\n                            // CONSIDER: if this doesn't (directly or indirectly) override object.Finalize, the\n                            // runtime won't consider it a finalizer and it will not be marked as a destructor\n                            // when it is loaded from metadata.  Perhaps we should just treat it as an Ordinary\n                            // method in such cases?\n                            var destructor = new SourceDestructorSymbol(this, destructorSyntax, compilation.IsNullableAnalysisEnabledIn(destructorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(destructor);\n                        }\n                        break;\n\n                    case SyntaxKind.PropertyDeclaration:\n                        {\n                            var propertySyntax = (PropertyDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(propertySyntax.Identifier));\n                            }\n\n                            var property = SourcePropertySymbol.Create(this, bodyBinder, propertySyntax, diagnostics);\n                            builder.NonTypeMembers.Add(property);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.SetMethod);\n                            FieldSymbol backingField = property.BackingField;\n\n                            // TODO: can we leave this out of the member list?\n                            // From the 10/12/11 design notes:\n                            //   In addition, we will change autoproperties to behavior in\n                            //   a similar manner and make the autoproperty fields private.\n                            if ((object)backingField != null)\n                            {\n                                builder.NonTypeMembers.Add(backingField);\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: backingField.IsStatic, compilation, propertySyntax);\n\n                                var initializer = propertySyntax.Initializer;\n                                if (initializer != null)\n                                {\n                                    if (IsScriptClass)\n                                    {\n                                        // also gather expression-declared variables from the initializer\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                                                      initializer,\n                                                                                      this,\n                                                                                      DeclarationModifiers.Private | (property.IsStatic ? DeclarationModifiers.Static : 0),\n                                                                                      backingField);\n                                    }\n\n                                    if (property.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, backingField, initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, backingField, initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventFieldDeclaration:\n                        {\n                            var eventFieldSyntax = (EventFieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(\n                                    ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventFieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            foreach (VariableDeclaratorSyntax declarator in eventFieldSyntax.Declaration.Variables)\n                            {\n                                SourceFieldLikeEventSymbol @event = new SourceFieldLikeEventSymbol(this, bodyBinder, eventFieldSyntax.Modifiers, declarator, diagnostics);\n                                builder.NonTypeMembers.Add(@event);\n\n                                FieldSymbol? associatedField = @event.AssociatedField;\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, declarator, this,\n                                                            DeclarationModifiers.Private | (@event.IsStatic ? DeclarationModifiers.Static : 0),\n                                                            associatedField);\n                                }\n\n                                if ((object?)associatedField != null)\n                                {\n                                    // NOTE: specifically don't add the associated field to the members list\n                                    // (regard it as an implementation detail).\n\n                                    builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: associatedField.IsStatic, compilation, declarator);\n\n                                    if (declarator.Initializer != null)\n                                    {\n                                        if (associatedField.IsStatic)\n                                        {\n                                            AddInitializer(ref staticInitializers, associatedField, declarator.Initializer);\n                                        }\n                                        else\n                                        {\n                                            AddInitializer(ref instanceInitializers, associatedField, declarator.Initializer);\n                                        }\n                                    }\n                                }\n\n                                Debug.Assert((object)@event.AddMethod != null);\n                                Debug.Assert((object)@event.RemoveMethod != null);\n\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventDeclaration:\n                        {\n                            var eventSyntax = (EventDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventSyntax.Identifier));\n                            }\n\n                            var @event = new SourceCustomEventSymbol(this, bodyBinder, eventSyntax, diagnostics);\n\n                            builder.NonTypeMembers.Add(@event);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n\n                            Debug.Assert(@event.AssociatedField is null);\n                        }\n                        break;\n\n                    case SyntaxKind.IndexerDeclaration:\n                        {\n                            var indexerSyntax = (IndexerDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(indexerSyntax.ThisKeyword));\n                            }\n\n                            var indexer = SourcePropertySymbol.Create(this, bodyBinder, indexerSyntax, diagnostics);\n                            builder.HaveIndexers = true;\n                            builder.NonTypeMembers.Add(indexer);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.SetMethod);\n                        }\n                        break;\n\n                    case SyntaxKind.ConversionOperatorDeclaration:\n                        {\n                            var conversionOperatorSyntax = (ConversionOperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(conversionOperatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedConversionSymbol.CreateUserDefinedConversionSymbol(\n                                this, conversionOperatorSyntax, compilation.IsNullableAnalysisEnabledIn(conversionOperatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.OperatorDeclaration:\n                        {\n                            var operatorSyntax = (OperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(operatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedOperatorSymbol.CreateUserDefinedOperatorSymbol(\n                                this, operatorSyntax, compilation.IsNullableAnalysisEnabledIn(operatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.GlobalStatement:\n                        {\n                            var globalStatement = ((GlobalStatementSyntax)m).Statement;\n\n                            if (IsScriptClass)\n                            {\n                                var innerStatement = globalStatement;\n\n                                // drill into any LabeledStatements\n                                while (innerStatement.Kind() == SyntaxKind.LabeledStatement)\n                                {\n                                    innerStatement = ((LabeledStatementSyntax)innerStatement).Statement;\n                                }\n\n                                switch (innerStatement.Kind())\n                                {\n                                    case SyntaxKind.LocalDeclarationStatement:\n                                        // We shouldn't reach this place, but field declarations preceded with a label end up here.\n                                        // This is tracked by https://github.com/dotnet/roslyn/issues/13712. Let's do our best for now.\n                                        var decl = (LocalDeclarationStatementSyntax)innerStatement;\n                                        foreach (var vdecl in decl.Declaration.Variables)\n                                        {\n                                            // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                            ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, vdecl, this, DeclarationModifiers.Private,\n                                                                                          containingFieldOpt: null);\n                                        }\n                                        break;\n\n                                    case SyntaxKind.ExpressionStatement:\n                                    case SyntaxKind.IfStatement:\n                                    case SyntaxKind.YieldReturnStatement:\n                                    case SyntaxKind.ReturnStatement:\n                                    case SyntaxKind.ThrowStatement:\n                                    case SyntaxKind.SwitchStatement:\n                                    case SyntaxKind.LockStatement:\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                  innerStatement,\n                                                  this,\n                                                  DeclarationModifiers.Private,\n                                                  containingFieldOpt: null);\n                                        break;\n\n                                    default:\n                                        // no other statement introduces variables into the enclosing scope\n                                        break;\n                                }\n\n                                AddInitializer(ref instanceInitializers, null, globalStatement);\n                            }\n                            else if (reportMisplacedGlobalCode && !SyntaxFacts.IsSimpleProgramTopLevelStatement((GlobalStatementSyntax)m))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_GlobalStatement, new SourceLocation(globalStatement));\n                            }\n                        }\n                        break;\n\n                    default:\n                        Debug.Assert(\n                            SyntaxFacts.IsTypeDeclaration(m.Kind()) ||\n                            m.Kind() == SyntaxKind.NamespaceDeclaration ||\n                            m.Kind() == SyntaxKind.IncompleteMember);\n                        break;\n                } 226517"];
4392 [label="var fieldSyntax = (FieldDeclarationSyntax)m; 226518"];
4393 [label="IsImplicitClass 226519"];
4394 [label="get\n            {\n                return this.declaration.Declarations[0].Kind == DeclarationKind.ImplicitClass;\n            } 226520"];
4395 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.ImplicitClass; 226521"];
4396 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.ImplicitClass; 226522"];
4397 [label="if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(fieldSyntax.Declaration.Variables.First().Identifier));\n                            } 226523"];
4398 [label="bool modifierErrors; 226524"];
4399 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 226525"];
4400 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 226526"];
4401 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 226527"];
4402 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 226528"];
4403 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 226529"];
4404 [label="SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors) 226530"];
4405 [label="param MakeModifiers(NamedTypeSymbol containingType) 226531"];
4406 [label="param MakeModifiers(SyntaxToken firstIdentifier) 226532"];
4407 [label="param MakeModifiers(SyntaxTokenList modifiers) 226533"];
4408 [label="param MakeModifiers(DiagnosticBag diagnostics) 226534"];
4409 [label="param MakeModifiers(out bool modifierErrors) 226535"];
4410 [label="containingType.IsInterface 226536"];
4411 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 226537"];
4412 [label="this.TypeKind 226538"];
4413 [label="get\n            {\n                return _flags.TypeKind;\n            } 226539"];
4414 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 226540"];
4415 [label="return this.TypeKind == TypeKind.Interface; 226541"];
4416 [label="DeclarationModifiers defaultAccess =\n                (containingType.IsInterface) ? DeclarationModifiers.Public : DeclarationModifiers.Private; 226542"];
4417 [label="(containingType.IsInterface) 226543"];
4418 [label="DeclarationModifiers allowedModifiers =\n                DeclarationModifiers.AccessibilityMask |\n                DeclarationModifiers.Const |\n                DeclarationModifiers.New |\n                DeclarationModifiers.ReadOnly |\n                DeclarationModifiers.Static |\n                DeclarationModifiers.Volatile |\n                DeclarationModifiers.Fixed |\n                DeclarationModifiers.Unsafe |\n                DeclarationModifiers.Abstract; 226544"];
4419 [label="var errorLocation = new SourceLocation(firstIdentifier); 226545"];
4420 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 226546"];
4421 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 226547"];
4422 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 226548"];
4423 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 226549"];
4424 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 226550"];
4425 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 226551"];
4426 [label="ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors) 226552"];
4427 [label="param MakeAndCheckNontypeMemberModifiers(SyntaxTokenList modifiers) 226553"];
4428 [label="param MakeAndCheckNontypeMemberModifiers(DeclarationModifiers defaultAccess) 226554"];
4429 [label="param MakeAndCheckNontypeMemberModifiers(DeclarationModifiers allowedModifiers) 226555"];
4430 [label="param MakeAndCheckNontypeMemberModifiers(Location errorLocation) 226556"];
4431 [label="param MakeAndCheckNontypeMemberModifiers(DiagnosticBag diagnostics) 226557"];
4432 [label="param MakeAndCheckNontypeMemberModifiers(out bool modifierErrors) 226558"];
4433 [label="var result = modifiers.ToDeclarationModifiers(diagnostics); 226559"];
4434 [label="var result = modifiers.ToDeclarationModifiers(diagnostics); 226560"];
4435 [label="modifiers.ToDeclarationModifiers(diagnostics) 226561"];
4436 [label="param ToDeclarationModifiers(this SyntaxTokenList modifiers) 226562"];
4437 [label="param ToDeclarationModifiers(DiagnosticBag diagnostics) 226563"];
4438 [label="bool seenNoDuplicates = true; 226564"];
4439 [label="bool seenNoAccessibilityDuplicates = true; 226565"];
4440 [label="DeclarationModifiers one = ToDeclarationModifier(modifier.ContextualKind()); 226566"];
4441 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 226567"];
4442 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 226568"];
4443 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 226569"];
4444 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 226570"];
4445 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 226571"];
4446 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 226572"];
4447 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics) 226573"];
4448 [label="param ReportDuplicateModifiers(SyntaxToken modifierToken) 226574"];
4449 [label="param ReportDuplicateModifiers(DeclarationModifiers modifierKind) 226575"];
4450 [label="param ReportDuplicateModifiers(DeclarationModifiers allModifiers) 226576"];
4451 [label="param ReportDuplicateModifiers(ref bool seenNoDuplicates) 226577"];
4452 [label="param ReportDuplicateModifiers(ref bool seenNoAccessibilityDuplicates) 226578"];
4453 [label="param ReportDuplicateModifiers(DiagnosticBag diagnostics) 226579"];
4454 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 226580"];
4455 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 226581"];
4456 [label="switch (result & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.Protected | DeclarationModifiers.Internal:\n                    // the two keywords 'protected' and 'internal' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.ProtectedInternal;\n                    break;\n\n                case DeclarationModifiers.Private | DeclarationModifiers.Protected:\n                    // the two keywords 'private' and 'protected' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.PrivateProtected;\n                    break;\n            } 226582"];
4457 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 226583"];
4458 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 226584"];
4459 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 226585"];
4460 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 226586"];
4461 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 226587"];
4462 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 226588"];
4463 [label="CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors) 226589"];
4464 [label="param CheckModifiers(DeclarationModifiers modifiers) 226590"];
4465 [label="param CheckModifiers(DeclarationModifiers allowedModifiers) 226591"];
4466 [label="param CheckModifiers(Location errorLocation) 226592"];
4467 [label="param CheckModifiers(DiagnosticBag diagnostics) 226593"];
4468 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 226594"];
4469 [label="param CheckModifiers(out bool modifierErrors) 226595"];
4470 [label="modifierErrors = false; 226596"];
4471 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 226597"];
4472 [label="DeclarationModifiers result = modifiers & allowedModifiers; 226598"];
4473 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 226599"];
4474 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 226600"];
4475 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 226601"];
4476 [label="return result; 226602"];
4477 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 226603"];
4478 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 226604"];
4479 [label="return result; 226605"];
4480 [label="if ((result & DeclarationModifiers.Abstract) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractField, errorLocation);\n                result &= ~DeclarationModifiers.Abstract;\n            } 226606"];
4481 [label="if ((result & DeclarationModifiers.Abstract) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractField, errorLocation);\n                result &= ~DeclarationModifiers.Abstract;\n            } 226607"];
4482 [label="if ((result & DeclarationModifiers.Fixed) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The modifier 'static' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.StaticKeyword));\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Const) != 0)\n                {\n                    // The modifier 'const' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ConstKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                result &= ~(DeclarationModifiers.Static | DeclarationModifiers.ReadOnly | DeclarationModifiers.Const | DeclarationModifiers.Volatile);\n                Debug.Assert((result & ~(DeclarationModifiers.AccessibilityMask | DeclarationModifiers.Fixed | DeclarationModifiers.Unsafe | DeclarationModifiers.New)) == 0);\n            } 226608"];
4483 [label="if ((result & DeclarationModifiers.Fixed) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The modifier 'static' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.StaticKeyword));\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Const) != 0)\n                {\n                    // The modifier 'const' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ConstKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                result &= ~(DeclarationModifiers.Static | DeclarationModifiers.ReadOnly | DeclarationModifiers.Const | DeclarationModifiers.Volatile);\n                Debug.Assert((result & ~(DeclarationModifiers.AccessibilityMask | DeclarationModifiers.Fixed | DeclarationModifiers.Unsafe | DeclarationModifiers.New)) == 0);\n            } 226609"];
4484 [label="if ((result & DeclarationModifiers.Const) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The constant '{0}' cannot be marked static\n                    diagnostics.Add(ErrorCode.ERR_StaticConstant, errorLocation, firstIdentifier.ValueText);\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Unsafe) != 0)\n                {\n                    // The modifier 'unsafe' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.UnsafeKeyword));\n                }\n\n                result |= DeclarationModifiers.Static; // 'constants are considered static members'\n            }\n            else\n            {\n                // NOTE: always cascading on a const, so suppress.\n                // NOTE: we're being a bit sneaky here - we're using the containingType rather than this symbol\n                // to determine whether or not unsafe is allowed.  Since this symbol and the containing type are\n                // in the same compilation, it won't make a difference.  We do, however, have to pass the error\n                // location explicitly.\n                containingType.CheckUnsafeModifier(result, errorLocation, diagnostics);\n            } 226610"];
4485 [label="if ((result & DeclarationModifiers.Const) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The constant '{0}' cannot be marked static\n                    diagnostics.Add(ErrorCode.ERR_StaticConstant, errorLocation, firstIdentifier.ValueText);\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Unsafe) != 0)\n                {\n                    // The modifier 'unsafe' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.UnsafeKeyword));\n                }\n\n                result |= DeclarationModifiers.Static; // 'constants are considered static members'\n            }\n            else\n            {\n                // NOTE: always cascading on a const, so suppress.\n                // NOTE: we're being a bit sneaky here - we're using the containingType rather than this symbol\n                // to determine whether or not unsafe is allowed.  Since this symbol and the containing type are\n                // in the same compilation, it won't make a difference.  We do, however, have to pass the error\n                // location explicitly.\n                containingType.CheckUnsafeModifier(result, errorLocation, diagnostics);\n            } 226611"];
4486 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 226612"];
4487 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 226613"];
4488 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 226614"];
4489 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 226615"];
4490 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics) 226616"];
4491 [label="param CheckUnsafeModifier(this Symbol symbol) 226617"];
4492 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 226618"];
4493 [label="param CheckUnsafeModifier(Location errorLocation) 226619"];
4494 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 226620"];
4495 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 226621"];
4496 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 226622"];
4497 [label="return result; 226623"];
4498 [label="foreach (var variable in fieldSyntax.Declaration.Variables)\n                            {\n                                var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics);\n                                builder.NonTypeMembers.Add(fieldSymbol);\n                                // All fields are included in the nullable context for constructors and initializers, even fields without\n                                // initializers, to ensure warnings are reported for uninitialized non-nullable fields in NullableWalker.\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable);\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                }\n\n                                if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                }\n                            } 226624"];
4499 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 226625"];
4500 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 226626"];
4501 [label="(modifiers & DeclarationModifiers.Fixed) == 0 226627"];
4502 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 226628"];
4503 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 226629"];
4504 [label="new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics) 226630"];
4505 [label="param SourceMemberFieldSymbolFromDeclarator(SourceMemberContainerTypeSymbol containingType) 226631"];
4506 [label="param SourceMemberFieldSymbolFromDeclarator(VariableDeclaratorSyntax declarator) 226632"];
4507 [label="param SourceMemberFieldSymbolFromDeclarator(DeclarationModifiers modifiers) 226633"];
4508 [label="param SourceMemberFieldSymbolFromDeclarator(bool modifierErrors) 226634"];
4509 [label="param SourceMemberFieldSymbolFromDeclarator(DiagnosticBag diagnostics) 226635"];
4510 [label="param SourceMemberFieldSymbolFromDeclarator(this) 226636"];
4511 [label="containingType 226637"];
4512 [label="modifiers 226638"];
4513 [label="declarator.Identifier.ValueText 226639"];
4514 [label="declarator.GetReference() 226640"];
4515 [label="declarator.Identifier 226641"];
4516 [label="declarator.Identifier 226642"];
4517 [label="param SourceMemberFieldSymbol(SourceMemberContainerTypeSymbol containingType) 226643"];
4518 [label="param SourceMemberFieldSymbol(DeclarationModifiers modifiers) 226644"];
4519 [label="param SourceMemberFieldSymbol(string name) 226645"];
4520 [label="param SourceMemberFieldSymbol(SyntaxReference syntax) 226646"];
4521 [label="param SourceMemberFieldSymbol(Location location) 226647"];
4522 [label="param SourceMemberFieldSymbol(this) 226648"];
4523 [label="containingType 226649"];
4524 [label="name 226650"];
4525 [label="syntax 226651"];
4526 [label="location 226652"];
4527 [label="param SourceMemberFieldSymbol(this) 226653"];
4528 [label="param SourceFieldSymbolWithSyntaxReference(SourceMemberContainerTypeSymbol containingType) 226654"];
4529 [label="param SourceFieldSymbolWithSyntaxReference(string name) 226655"];
4530 [label="param SourceFieldSymbolWithSyntaxReference(SyntaxReference syntax) 226656"];
4531 [label="param SourceFieldSymbolWithSyntaxReference(Location location) 226657"];
4532 [label="param SourceFieldSymbolWithSyntaxReference(this) 226658"];
4533 [label="containingType 226659"];
4534 [label="param SourceFieldSymbolWithSyntaxReference(this) 226660"];
4535 [label="param SourceFieldSymbol(SourceMemberContainerTypeSymbol containingType) 226661"];
4536 [label="param SourceFieldSymbol(this) 226662"];
4537 [label="param SourceFieldSymbol(this) 226663"];
4538 [label="param FieldSymbolWithAttributesAndModifiers(this) 226664"];
4539 [label="param FieldSymbolWithAttributesAndModifiers(this) 226665"];
4540 [label="param FieldSymbol(this) 226666"];
4541 [label="param FieldSymbol(this) 226667"];
4542 [label="_lazyAdapter 226668"];
4543 [label="_lazyCustomAttributesBag 226669"];
4544 [label="containingType 226670"];
4545 [label="Debug.Assert((object)containingType != null); 226671"];
4546 [label="Debug.Assert((object)containingType != null); 226672"];
4547 [label="this.containingType 226673"];
4548 [label="_name 226674"];
4549 [label="_location 226675"];
4550 [label="_syntaxReference 226676"];
4551 [label="_lazyDocComment 226677"];
4552 [label="_lazyExpandedDocComment 226678"];
4553 [label="_lazyConstantEarlyDecodingValue = Microsoft.CodeAnalysis.ConstantValue.Unset 226679"];
4554 [label="_lazyConstantValue = Microsoft.CodeAnalysis.ConstantValue.Unset 226680"];
4555 [label="Debug.Assert(name != null); 226681"];
4556 [label="Debug.Assert(name != null); 226682"];
4557 [label="Debug.Assert(syntax != null); 226683"];
4558 [label="Debug.Assert(syntax != null); 226684"];
4559 [label="Debug.Assert(location != null); 226685"];
4560 [label="Debug.Assert(location != null); 226686"];
4561 [label="_name 226687"];
4562 [label="_syntaxReference 226688"];
4563 [label="_location 226689"];
4564 [label="_modifiers 226690"];
4565 [label="_modifiers 226691"];
4566 [label="declarator.Identifier 226692"];
4567 [label="declarator.Identifier.GetLocation() 226693"];
4568 [label="param SourceMemberFieldSymbolFromDeclarator(this) 226694"];
4569 [label="param SourceMemberFieldSymbolFromDeclarator(this) 226695"];
4570 [label="_hasInitializer 226696"];
4571 [label="_lazyType 226697"];
4572 [label="_lazyFieldTypeInferred 226698"];
4573 [label="_hasInitializer = declarator.Initializer != null; 226699"];
4574 [label="_hasInitializer = declarator.Initializer != null; 226700"];
4575 [label="_hasInitializer 226701"];
4576 [label="this.CheckAccessibility(diagnostics); 226702"];
4577 [label="this.CheckAccessibility(diagnostics) 226703"];
4578 [label="param CheckAccessibility(DiagnosticBag diagnostics) 226704"];
4579 [label="param CheckAccessibility(this) 226705"];
4580 [label="Modifiers 226706"];
4581 [label="get\n            {\n                return _modifiers;\n            } 226707"];
4582 [label="return _modifiers; 226708"];
4583 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 226709"];
4584 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 226710"];
4585 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 226711"];
4586 [label="ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false) 226712"];
4587 [label="param CheckAccessibility(DeclarationModifiers modifiers) 226713"];
4588 [label="param CheckAccessibility(Symbol symbol) 226714"];
4589 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 226715"];
4590 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 226716"];
4591 [label="IsValidAccessibility(modifiers) 226717"];
4592 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 226718"];
4593 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 226719"];
4594 [label="return true; 226720"];
4595 [label="symbol.Kind 226721"];
4596 [label="get\n            {\n                return SymbolKind.Field;\n            } 226722"];
4597 [label="return SymbolKind.Field; 226723"];
4598 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 226724"];
4599 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 226725"];
4600 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 226726"];
4601 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 226727"];
4602 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 226728"];
4603 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 226729"];
4604 [label="return null; 226730"];
4605 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 226731"];
4606 [label="if (info != null)\n            {\n                diagnostics.Add(new CSDiagnostic(info, this.ErrorLocation));\n            } 226732"];
4607 [label="if (info != null)\n            {\n                diagnostics.Add(new CSDiagnostic(info, this.ErrorLocation));\n            } 226733"];
4608 [label="this.CheckAccessibility(diagnostics); 226734"];
4609 [label="if (!modifierErrors)\n            {\n                this.ReportModifiersDiagnostics(diagnostics);\n            } 226735"];
4610 [label="this.ReportModifiersDiagnostics(diagnostics); 226736"];
4611 [label="this.ReportModifiersDiagnostics(diagnostics) 226737"];
4612 [label="param ReportModifiersDiagnostics(DiagnosticBag diagnostics) 226738"];
4613 [label="param ReportModifiersDiagnostics(this) 226739"];
4614 [label="ContainingType 226740"];
4615 [label="get\n            {\n                return this.containingType;\n            } 226741"];
4616 [label="return this.containingType; 226742"];
4617 [label="if (ContainingType.IsSealed && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(containingType), ErrorLocation, this);\n            }\n            else if (IsVolatile && IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_VolatileAndReadonly, ErrorLocation, this);\n            }\n            else if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 226743"];
4618 [label="ContainingType.IsSealed 226744"];
4619 [label="=> HasFlag(DeclarationModifiers.Sealed) 226745"];
4620 [label="DeclarationModifiers.Sealed 226746"];
4621 [label="HasFlag(DeclarationModifiers.Sealed) 226747"];
4622 [label="param HasFlag(DeclarationModifiers flag) 226748"];
4623 [label="=> (_declModifiers & flag) != 0 226749"];
4624 [label="_declModifiers & flag 226750"];
4625 [label="0 226751"];
4626 [label="(_declModifiers & flag) != 0 226752"];
4627 [label="IsVolatile 226753"];
4628 [label="=> (Modifiers & DeclarationModifiers.Volatile) != 0 226754"];
4629 [label="Modifiers 226755"];
4630 [label="get\n            {\n                return _modifiers;\n            } 226756"];
4631 [label="return _modifiers; 226757"];
4632 [label="Modifiers & DeclarationModifiers.Volatile 226758"];
4633 [label="0 226759"];
4634 [label="(Modifiers & DeclarationModifiers.Volatile) != 0 226760"];
4635 [label="if (IsVolatile && IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_VolatileAndReadonly, ErrorLocation, this);\n            }\n            else if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 226761"];
4636 [label="containingType.IsStatic 226762"];
4637 [label="=> HasFlag(DeclarationModifiers.Static) 226763"];
4638 [label="DeclarationModifiers.Static 226764"];
4639 [label="HasFlag(DeclarationModifiers.Static) 226765"];
4640 [label="param HasFlag(DeclarationModifiers flag) 226766"];
4641 [label="=> (_declModifiers & flag) != 0 226767"];
4642 [label="_declModifiers & flag 226768"];
4643 [label="if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 226769"];
4644 [label="IsStatic 226770"];
4645 [label="=> (Modifiers & DeclarationModifiers.Static) != 0 226771"];
4646 [label="Modifiers 226772"];
4647 [label="get\n            {\n                return _modifiers;\n            } 226773"];
4648 [label="Modifiers & DeclarationModifiers.Static 226774"];
4649 [label="0 226775"];
4650 [label="(Modifiers & DeclarationModifiers.Static) != 0 226776"];
4651 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 226777"];
4652 [label="IsReadOnly 226778"];
4653 [label="=> (Modifiers & DeclarationModifiers.ReadOnly) != 0 226779"];
4654 [label="Modifiers 226780"];
4655 [label="get\n            {\n                return _modifiers;\n            } 226781"];
4656 [label="Modifiers & DeclarationModifiers.ReadOnly 226782"];
4657 [label="0 226783"];
4658 [label="(Modifiers & DeclarationModifiers.ReadOnly) != 0 226784"];
4659 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 226785"];
4660 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 226786"];
4661 [label="containingType.IsReadOnly 226787"];
4662 [label="=> HasFlag(DeclarationModifiers.ReadOnly) 226788"];
4663 [label="DeclarationModifiers.ReadOnly 226789"];
4664 [label="HasFlag(DeclarationModifiers.ReadOnly) 226790"];
4665 [label="param HasFlag(DeclarationModifiers flag) 226791"];
4666 [label="=> (_declModifiers & flag) != 0 226792"];
4667 [label="_declModifiers & flag 226793"];
4668 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 226794"];
4669 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 226795"];
4670 [label="this.ReportModifiersDiagnostics(diagnostics); 226796"];
4671 [label="containingType.IsInterface 226797"];
4672 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 226798"];
4673 [label="this.TypeKind 226799"];
4674 [label="get\n            {\n                return _flags.TypeKind;\n            } 226800"];
4675 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 226801"];
4676 [label="return this.TypeKind == TypeKind.Interface; 226802"];
4677 [label="if (containingType.IsInterface)\n            {\n                if (this.IsStatic)\n                {\n                    Binder.CheckFeatureAvailability(declarator, MessageID.IDS_DefaultInterfaceImplementation, diagnostics, ErrorLocation);\n\n                    if (!ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation, ErrorLocation);\n                    }\n                }\n                else\n                {\n                    diagnostics.Add(ErrorCode.ERR_InterfacesCantContainFields, ErrorLocation);\n                }\n            } 226803"];
4678 [label="builder.NonTypeMembers.Add(fieldSymbol); 226804"];
4679 [label="builder.NonTypeMembers.Add(fieldSymbol); 226805"];
4680 [label="fieldSymbol.IsStatic 226806"];
4681 [label="=> (Modifiers & DeclarationModifiers.Static) != 0 226807"];
4682 [label="Modifiers 226808"];
4683 [label="get\n            {\n                return _modifiers;\n            } 226809"];
4684 [label="return _modifiers; 226810"];
4685 [label="Modifiers & DeclarationModifiers.Static 226811"];
4686 [label="0 226812"];
4687 [label="(Modifiers & DeclarationModifiers.Static) != 0 226813"];
4688 [label="builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable); 226814"];
4689 [label="builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable); 226815"];
4690 [label="builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable); 226816"];
4691 [label="builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable) 226817"];
4692 [label="param UpdateIsNullableEnabledForConstructorsAndFields(bool useStatic) 226818"];
4693 [label="param UpdateIsNullableEnabledForConstructorsAndFields(CSharpCompilation compilation) 226819"];
4694 [label="param UpdateIsNullableEnabledForConstructorsAndFields(CSharpSyntaxNode syntax) 226820"];
4695 [label="param UpdateIsNullableEnabledForConstructorsAndFields(this) 226821"];
4696 [label="ref bool isNullableEnabled = ref GetIsNullableEnabledForConstructorsAndFields(useStatic); 226822"];
4697 [label="GetIsNullableEnabledForConstructorsAndFields(useStatic) 226823"];
4698 [label="param GetIsNullableEnabledForConstructorsAndFields(bool useStatic) 226824"];
4699 [label="param GetIsNullableEnabledForConstructorsAndFields(this) 226825"];
4700 [label="useStatic 226826"];
4701 [label="IsNullableEnabledForInstanceConstructorsAndFields 226827"];
4702 [label="return ref useStatic ? ref IsNullableEnabledForStaticConstructorsAndFields : ref IsNullableEnabledForInstanceConstructorsAndFields; 226828"];
4703 [label="isNullableEnabled = isNullableEnabled || compilation.IsNullableAnalysisEnabledIn(syntax); 226829"];
4704 [label="compilation.IsNullableAnalysisEnabledIn(syntax) 226830"];
4705 [label="param IsNullableAnalysisEnabledIn(SyntaxNode syntax) 226831"];
4706 [label="param IsNullableAnalysisEnabledIn(this) 226832"];
4707 [label="return IsNullableAnalysisEnabledIn((CSharpSyntaxTree)syntax.SyntaxTree, syntax.Span); 226833"];
4708 [label="IsNullableAnalysisEnabledIn((CSharpSyntaxTree)syntax.SyntaxTree, syntax.Span) 226834"];
4709 [label="param IsNullableAnalysisEnabledIn(CSharpSyntaxTree tree) 226835"];
4710 [label="param IsNullableAnalysisEnabledIn(TextSpan span) 226836"];
4711 [label="param IsNullableAnalysisEnabledIn(this) 226837"];
4712 [label="GetNullableAnalysisValue() 226838"];
4713 [label="param GetNullableAnalysisValue(this) 226839"];
4714 [label="return Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            }; 226840"];
4715 [label="return Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            }; 226841"];
4716 [label="Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            } 226842"];
4717 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 226843"];
4718 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 226844"];
4719 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 226845"];
4720 [label="Options 226846"];
4721 [label="get\n            {\n                return _options;\n            } 226847"];
4722 [label="return _options; 226848"];
4723 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 226849"];
4724 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 226850"];
4725 [label="isNullableEnabled = isNullableEnabled || compilation.IsNullableAnalysisEnabledIn(syntax); 226851"];
4726 [label="IsScriptClass 226852"];
4727 [label="get\n            {\n                var kind = this.declaration.Declarations[0].Kind;\n                return kind == DeclarationKind.Script || kind == DeclarationKind.Submission;\n            } 226853"];
4728 [label="var kind = this.declaration.Declarations[0].Kind; 226854"];
4729 [label="var kind = this.declaration.Declarations[0].Kind; 226855"];
4730 [label="return kind == DeclarationKind.Script || kind == DeclarationKind.Submission; 226856"];
4731 [label="if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                } 226857"];
4732 [label="if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                } 226858"];
4733 [label="if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                } 226859"];
4734 [label="if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                } 226860"];
4735 [label="bool reportMisplacedGlobalCode = !m.HasErrors; 226861"];
4736 [label="if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(fieldSyntax.Declaration.Variables.First().Identifier));\n                            } 226862"];
4737 [label="bool modifierErrors; 226863"];
4738 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 226864"];
4739 [label="param MakeModifiers(NamedTypeSymbol containingType) 226865"];
4740 [label="param MakeModifiers(DiagnosticBag diagnostics) 226866"];
4741 [label="param MakeModifiers(out bool modifierErrors) 226867"];
4742 [label="containingType.IsInterface 226868"];
4743 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 226869"];
4744 [label="this.TypeKind 226870"];
4745 [label="get\n            {\n                return _flags.TypeKind;\n            } 226871"];
4746 [label="return this.TypeKind == TypeKind.Interface; 226872"];
4747 [label="DeclarationModifiers defaultAccess =\n                (containingType.IsInterface) ? DeclarationModifiers.Public : DeclarationModifiers.Private; 226873"];
4748 [label="(containingType.IsInterface) 226874"];
4749 [label="param MakeAndCheckNontypeMemberModifiers(DeclarationModifiers defaultAccess) 226875"];
4750 [label="param MakeAndCheckNontypeMemberModifiers(Location errorLocation) 226876"];
4751 [label="param MakeAndCheckNontypeMemberModifiers(DiagnosticBag diagnostics) 226877"];
4752 [label="param MakeAndCheckNontypeMemberModifiers(out bool modifierErrors) 226878"];
4753 [label="param ToDeclarationModifiers(DiagnosticBag diagnostics) 226879"];
4754 [label="bool seenNoDuplicates = true; 226880"];
4755 [label="bool seenNoAccessibilityDuplicates = true; 226881"];
4756 [label="return DeclarationModifiers.Static; 226882"];
4757 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 226883"];
4758 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 226884"];
4759 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 226885"];
4760 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 226886"];
4761 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 226887"];
4762 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics) 226888"];
4763 [label="param ReportDuplicateModifiers(SyntaxToken modifierToken) 226889"];
4764 [label="param ReportDuplicateModifiers(DeclarationModifiers modifierKind) 226890"];
4765 [label="param ReportDuplicateModifiers(DeclarationModifiers allModifiers) 226891"];
4766 [label="param ReportDuplicateModifiers(ref bool seenNoDuplicates) 226892"];
4767 [label="param ReportDuplicateModifiers(ref bool seenNoAccessibilityDuplicates) 226893"];
4768 [label="param ReportDuplicateModifiers(DiagnosticBag diagnostics) 226894"];
4769 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 226895"];
4770 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 226896"];
4771 [label="switch (result & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.Protected | DeclarationModifiers.Internal:\n                    // the two keywords 'protected' and 'internal' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.ProtectedInternal;\n                    break;\n\n                case DeclarationModifiers.Private | DeclarationModifiers.Protected:\n                    // the two keywords 'private' and 'protected' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.PrivateProtected;\n                    break;\n            } 226897"];
4772 [label="param CheckModifiers(Location errorLocation) 226898"];
4773 [label="param CheckModifiers(DiagnosticBag diagnostics) 226899"];
4774 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 226900"];
4775 [label="param CheckModifiers(out bool modifierErrors) 226901"];
4776 [label="modifierErrors = false; 226902"];
4777 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 226903"];
4778 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 226904"];
4779 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 226905"];
4780 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 226906"];
4781 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 226907"];
4782 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 226908"];
4783 [label="result |= defaultAccess; 226909"];
4784 [label="if ((result & DeclarationModifiers.Abstract) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractField, errorLocation);\n                result &= ~DeclarationModifiers.Abstract;\n            } 226910"];
4785 [label="if ((result & DeclarationModifiers.Abstract) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractField, errorLocation);\n                result &= ~DeclarationModifiers.Abstract;\n            } 226911"];
4786 [label="if ((result & DeclarationModifiers.Fixed) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The modifier 'static' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.StaticKeyword));\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Const) != 0)\n                {\n                    // The modifier 'const' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ConstKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                result &= ~(DeclarationModifiers.Static | DeclarationModifiers.ReadOnly | DeclarationModifiers.Const | DeclarationModifiers.Volatile);\n                Debug.Assert((result & ~(DeclarationModifiers.AccessibilityMask | DeclarationModifiers.Fixed | DeclarationModifiers.Unsafe | DeclarationModifiers.New)) == 0);\n            } 226912"];
4787 [label="if ((result & DeclarationModifiers.Fixed) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The modifier 'static' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.StaticKeyword));\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Const) != 0)\n                {\n                    // The modifier 'const' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ConstKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                result &= ~(DeclarationModifiers.Static | DeclarationModifiers.ReadOnly | DeclarationModifiers.Const | DeclarationModifiers.Volatile);\n                Debug.Assert((result & ~(DeclarationModifiers.AccessibilityMask | DeclarationModifiers.Fixed | DeclarationModifiers.Unsafe | DeclarationModifiers.New)) == 0);\n            } 226913"];
4788 [label="if ((result & DeclarationModifiers.Const) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The constant '{0}' cannot be marked static\n                    diagnostics.Add(ErrorCode.ERR_StaticConstant, errorLocation, firstIdentifier.ValueText);\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Unsafe) != 0)\n                {\n                    // The modifier 'unsafe' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.UnsafeKeyword));\n                }\n\n                result |= DeclarationModifiers.Static; // 'constants are considered static members'\n            }\n            else\n            {\n                // NOTE: always cascading on a const, so suppress.\n                // NOTE: we're being a bit sneaky here - we're using the containingType rather than this symbol\n                // to determine whether or not unsafe is allowed.  Since this symbol and the containing type are\n                // in the same compilation, it won't make a difference.  We do, however, have to pass the error\n                // location explicitly.\n                containingType.CheckUnsafeModifier(result, errorLocation, diagnostics);\n            } 226914"];
4789 [label="if ((result & DeclarationModifiers.Const) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The constant '{0}' cannot be marked static\n                    diagnostics.Add(ErrorCode.ERR_StaticConstant, errorLocation, firstIdentifier.ValueText);\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Unsafe) != 0)\n                {\n                    // The modifier 'unsafe' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.UnsafeKeyword));\n                }\n\n                result |= DeclarationModifiers.Static; // 'constants are considered static members'\n            }\n            else\n            {\n                // NOTE: always cascading on a const, so suppress.\n                // NOTE: we're being a bit sneaky here - we're using the containingType rather than this symbol\n                // to determine whether or not unsafe is allowed.  Since this symbol and the containing type are\n                // in the same compilation, it won't make a difference.  We do, however, have to pass the error\n                // location explicitly.\n                containingType.CheckUnsafeModifier(result, errorLocation, diagnostics);\n            } 226915"];
4790 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 226916"];
4791 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 226917"];
4792 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 226918"];
4793 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 226919"];
4794 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics) 226920"];
4795 [label="param CheckUnsafeModifier(this Symbol symbol) 226921"];
4796 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 226922"];
4797 [label="param CheckUnsafeModifier(Location errorLocation) 226923"];
4798 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 226924"];
4799 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 226925"];
4800 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 226926"];
4801 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 226927"];
4802 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 226928"];
4803 [label="param SourceMemberFieldSymbolFromDeclarator(bool modifierErrors) 226929"];
4804 [label="param SourceMemberFieldSymbolFromDeclarator(DiagnosticBag diagnostics) 226930"];
4805 [label="containingType 226931"];
4806 [label="Debug.Assert((object)containingType != null); 226932"];
4807 [label="_name 226933"];
4808 [label="_location 226934"];
4809 [label="_syntaxReference 226935"];
4810 [label="Debug.Assert(name != null); 226936"];
4811 [label="Debug.Assert(syntax != null); 226937"];
4812 [label="Debug.Assert(location != null); 226938"];
4813 [label="_modifiers 226939"];
4814 [label="this.CheckAccessibility(diagnostics); 226940"];
4815 [label="this.CheckAccessibility(diagnostics) 226941"];
4816 [label="param CheckAccessibility(DiagnosticBag diagnostics) 226942"];
4817 [label="param CheckAccessibility(this) 226943"];
4818 [label="Modifiers 226944"];
4819 [label="get\n            {\n                return _modifiers;\n            } 226945"];
4820 [label="return _modifiers; 226946"];
4821 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 226947"];
4822 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 226948"];
4823 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 226949"];
4824 [label="ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false) 226950"];
4825 [label="param CheckAccessibility(DeclarationModifiers modifiers) 226951"];
4826 [label="param CheckAccessibility(Symbol symbol) 226952"];
4827 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 226953"];
4828 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 226954"];
4829 [label="IsValidAccessibility(modifiers) 226955"];
4830 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 226956"];
4831 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 226957"];
4832 [label="return true; 226958"];
4833 [label="symbol.Kind 226959"];
4834 [label="get\n            {\n                return SymbolKind.Field;\n            } 226960"];
4835 [label="return SymbolKind.Field; 226961"];
4836 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 226962"];
4837 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 226963"];
4838 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 226964"];
4839 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 226965"];
4840 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 226966"];
4841 [label="return null; 226967"];
4842 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 226968"];
4843 [label="if (info != null)\n            {\n                diagnostics.Add(new CSDiagnostic(info, this.ErrorLocation));\n            } 226969"];
4844 [label="if (info != null)\n            {\n                diagnostics.Add(new CSDiagnostic(info, this.ErrorLocation));\n            } 226970"];
4845 [label="this.CheckAccessibility(diagnostics); 226971"];
4846 [label="if (!modifierErrors)\n            {\n                this.ReportModifiersDiagnostics(diagnostics);\n            } 226972"];
4847 [label="this.ReportModifiersDiagnostics(diagnostics); 226973"];
4848 [label="this.ReportModifiersDiagnostics(diagnostics) 226974"];
4849 [label="param ReportModifiersDiagnostics(DiagnosticBag diagnostics) 226975"];
4850 [label="param ReportModifiersDiagnostics(this) 226976"];
4851 [label="ContainingType 226977"];
4852 [label="get\n            {\n                return this.containingType;\n            } 226978"];
4853 [label="return this.containingType; 226979"];
4854 [label="if (ContainingType.IsSealed && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(containingType), ErrorLocation, this);\n            }\n            else if (IsVolatile && IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_VolatileAndReadonly, ErrorLocation, this);\n            }\n            else if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 226980"];
4855 [label="ContainingType.IsSealed 226981"];
4856 [label="=> HasFlag(DeclarationModifiers.Sealed) 226982"];
4857 [label="DeclarationModifiers.Sealed 226983"];
4858 [label="HasFlag(DeclarationModifiers.Sealed) 226984"];
4859 [label="param HasFlag(DeclarationModifiers flag) 226985"];
4860 [label="=> (_declModifiers & flag) != 0 226986"];
4861 [label="_declModifiers & flag 226987"];
4862 [label="0 226988"];
4863 [label="(_declModifiers & flag) != 0 226989"];
4864 [label="IsVolatile 226990"];
4865 [label="=> (Modifiers & DeclarationModifiers.Volatile) != 0 226991"];
4866 [label="Modifiers 226992"];
4867 [label="get\n            {\n                return _modifiers;\n            } 226993"];
4868 [label="return _modifiers; 226994"];
4869 [label="Modifiers & DeclarationModifiers.Volatile 226995"];
4870 [label="0 226996"];
4871 [label="(Modifiers & DeclarationModifiers.Volatile) != 0 226997"];
4872 [label="if (IsVolatile && IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_VolatileAndReadonly, ErrorLocation, this);\n            }\n            else if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 226998"];
4873 [label="containingType.IsStatic 226999"];
4874 [label="=> HasFlag(DeclarationModifiers.Static) 227000"];
4875 [label="DeclarationModifiers.Static 227001"];
4876 [label="HasFlag(DeclarationModifiers.Static) 227002"];
4877 [label="param HasFlag(DeclarationModifiers flag) 227003"];
4878 [label="=> (_declModifiers & flag) != 0 227004"];
4879 [label="_declModifiers & flag 227005"];
4880 [label="if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 227006"];
4881 [label="IsStatic 227007"];
4882 [label="=> (Modifiers & DeclarationModifiers.Static) != 0 227008"];
4883 [label="Modifiers 227009"];
4884 [label="get\n            {\n                return _modifiers;\n            } 227010"];
4885 [label="Modifiers & DeclarationModifiers.Static 227011"];
4886 [label="0 227012"];
4887 [label="(Modifiers & DeclarationModifiers.Static) != 0 227013"];
4888 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 227014"];
4889 [label="this.ReportModifiersDiagnostics(diagnostics); 227015"];
4890 [label="containingType.IsInterface 227016"];
4891 [label="if (containingType.IsInterface)\n            {\n                if (this.IsStatic)\n                {\n                    Binder.CheckFeatureAvailability(declarator, MessageID.IDS_DefaultInterfaceImplementation, diagnostics, ErrorLocation);\n\n                    if (!ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation, ErrorLocation);\n                    }\n                }\n                else\n                {\n                    diagnostics.Add(ErrorCode.ERR_InterfacesCantContainFields, ErrorLocation);\n                }\n            } 227017"];
4892 [label="fieldSymbol.IsStatic 227018"];
4893 [label="=> (Modifiers & DeclarationModifiers.Static) != 0 227019"];
4894 [label="Modifiers 227020"];
4895 [label="get\n            {\n                return _modifiers;\n            } 227021"];
4896 [label="return _modifiers; 227022"];
4897 [label="Modifiers & DeclarationModifiers.Static 227023"];
4898 [label="0 227024"];
4899 [label="(Modifiers & DeclarationModifiers.Static) != 0 227025"];
4900 [label="param UpdateIsNullableEnabledForConstructorsAndFields(bool useStatic) 227026"];
4901 [label="param UpdateIsNullableEnabledForConstructorsAndFields(this) 227027"];
4902 [label="ref bool isNullableEnabled = ref GetIsNullableEnabledForConstructorsAndFields(useStatic); 227028"];
4903 [label="GetIsNullableEnabledForConstructorsAndFields(useStatic) 227029"];
4904 [label="param GetIsNullableEnabledForConstructorsAndFields(bool useStatic) 227030"];
4905 [label="param GetIsNullableEnabledForConstructorsAndFields(this) 227031"];
4906 [label="useStatic 227032"];
4907 [label="IsNullableEnabledForStaticConstructorsAndFields 227033"];
4908 [label="return ref useStatic ? ref IsNullableEnabledForStaticConstructorsAndFields : ref IsNullableEnabledForInstanceConstructorsAndFields; 227034"];
4909 [label="Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            } 227035"];
4910 [label="Options 227036"];
4911 [label="return _options; 227037"];
4912 [label="isNullableEnabled = isNullableEnabled || compilation.IsNullableAnalysisEnabledIn(syntax); 227038"];
4913 [label="return kind == DeclarationKind.Script || kind == DeclarationKind.Submission; 227039"];
4914 [label="if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                } 227040"];
4915 [label="if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                } 227041"];
4916 [label="if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                } 227042"];
4917 [label="if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                } 227043"];
4918 [label="bool reportMisplacedGlobalCode = !m.HasErrors; 227044"];
4919 [label="if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(fieldSyntax.Declaration.Variables.First().Identifier));\n                            } 227045"];
4920 [label="bool modifierErrors; 227046"];
4921 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 227047"];
4922 [label="param MakeModifiers(DiagnosticBag diagnostics) 227048"];
4923 [label="param MakeModifiers(out bool modifierErrors) 227049"];
4924 [label="param MakeAndCheckNontypeMemberModifiers(Location errorLocation) 227050"];
4925 [label="param MakeAndCheckNontypeMemberModifiers(DiagnosticBag diagnostics) 227051"];
4926 [label="param MakeAndCheckNontypeMemberModifiers(out bool modifierErrors) 227052"];
4927 [label="param ToDeclarationModifiers(DiagnosticBag diagnostics) 227053"];
4928 [label="bool seenNoDuplicates = true; 227054"];
4929 [label="bool seenNoAccessibilityDuplicates = true; 227055"];
4930 [label="return DeclarationModifiers.Private; 227056"];
4931 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 227057"];
4932 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 227058"];
4933 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 227059"];
4934 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 227060"];
4935 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 227061"];
4936 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics) 227062"];
4937 [label="param ReportDuplicateModifiers(SyntaxToken modifierToken) 227063"];
4938 [label="param ReportDuplicateModifiers(DeclarationModifiers modifierKind) 227064"];
4939 [label="param ReportDuplicateModifiers(DeclarationModifiers allModifiers) 227065"];
4940 [label="param ReportDuplicateModifiers(ref bool seenNoDuplicates) 227066"];
4941 [label="param ReportDuplicateModifiers(ref bool seenNoAccessibilityDuplicates) 227067"];
4942 [label="param ReportDuplicateModifiers(DiagnosticBag diagnostics) 227068"];
4943 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 227069"];
4944 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 227070"];
4945 [label="switch (result & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.Protected | DeclarationModifiers.Internal:\n                    // the two keywords 'protected' and 'internal' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.ProtectedInternal;\n                    break;\n\n                case DeclarationModifiers.Private | DeclarationModifiers.Protected:\n                    // the two keywords 'private' and 'protected' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.PrivateProtected;\n                    break;\n            } 227071"];
4946 [label="param CheckModifiers(Location errorLocation) 227072"];
4947 [label="param CheckModifiers(DiagnosticBag diagnostics) 227073"];
4948 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 227074"];
4949 [label="param CheckModifiers(out bool modifierErrors) 227075"];
4950 [label="modifierErrors = false; 227076"];
4951 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 227077"];
4952 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 227078"];
4953 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 227079"];
4954 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 227080"];
4955 [label="if ((result & DeclarationModifiers.Abstract) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractField, errorLocation);\n                result &= ~DeclarationModifiers.Abstract;\n            } 227081"];
4956 [label="if ((result & DeclarationModifiers.Abstract) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractField, errorLocation);\n                result &= ~DeclarationModifiers.Abstract;\n            } 227082"];
4957 [label="if ((result & DeclarationModifiers.Fixed) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The modifier 'static' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.StaticKeyword));\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Const) != 0)\n                {\n                    // The modifier 'const' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ConstKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                result &= ~(DeclarationModifiers.Static | DeclarationModifiers.ReadOnly | DeclarationModifiers.Const | DeclarationModifiers.Volatile);\n                Debug.Assert((result & ~(DeclarationModifiers.AccessibilityMask | DeclarationModifiers.Fixed | DeclarationModifiers.Unsafe | DeclarationModifiers.New)) == 0);\n            } 227083"];
4958 [label="if ((result & DeclarationModifiers.Fixed) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The modifier 'static' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.StaticKeyword));\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Const) != 0)\n                {\n                    // The modifier 'const' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ConstKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                result &= ~(DeclarationModifiers.Static | DeclarationModifiers.ReadOnly | DeclarationModifiers.Const | DeclarationModifiers.Volatile);\n                Debug.Assert((result & ~(DeclarationModifiers.AccessibilityMask | DeclarationModifiers.Fixed | DeclarationModifiers.Unsafe | DeclarationModifiers.New)) == 0);\n            } 227084"];
4959 [label="if ((result & DeclarationModifiers.Const) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The constant '{0}' cannot be marked static\n                    diagnostics.Add(ErrorCode.ERR_StaticConstant, errorLocation, firstIdentifier.ValueText);\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Unsafe) != 0)\n                {\n                    // The modifier 'unsafe' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.UnsafeKeyword));\n                }\n\n                result |= DeclarationModifiers.Static; // 'constants are considered static members'\n            }\n            else\n            {\n                // NOTE: always cascading on a const, so suppress.\n                // NOTE: we're being a bit sneaky here - we're using the containingType rather than this symbol\n                // to determine whether or not unsafe is allowed.  Since this symbol and the containing type are\n                // in the same compilation, it won't make a difference.  We do, however, have to pass the error\n                // location explicitly.\n                containingType.CheckUnsafeModifier(result, errorLocation, diagnostics);\n            } 227085"];
4960 [label="if ((result & DeclarationModifiers.Const) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The constant '{0}' cannot be marked static\n                    diagnostics.Add(ErrorCode.ERR_StaticConstant, errorLocation, firstIdentifier.ValueText);\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Unsafe) != 0)\n                {\n                    // The modifier 'unsafe' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.UnsafeKeyword));\n                }\n\n                result |= DeclarationModifiers.Static; // 'constants are considered static members'\n            }\n            else\n            {\n                // NOTE: always cascading on a const, so suppress.\n                // NOTE: we're being a bit sneaky here - we're using the containingType rather than this symbol\n                // to determine whether or not unsafe is allowed.  Since this symbol and the containing type are\n                // in the same compilation, it won't make a difference.  We do, however, have to pass the error\n                // location explicitly.\n                containingType.CheckUnsafeModifier(result, errorLocation, diagnostics);\n            } 227086"];
4961 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 227087"];
4962 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 227088"];
4963 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 227089"];
4964 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics) 227090"];
4965 [label="param CheckUnsafeModifier(this Symbol symbol) 227091"];
4966 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 227092"];
4967 [label="param CheckUnsafeModifier(Location errorLocation) 227093"];
4968 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 227094"];
4969 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 227095"];
4970 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 227096"];
4971 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 227097"];
4972 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 227098"];
4973 [label="param SourceMemberFieldSymbolFromDeclarator(bool modifierErrors) 227099"];
4974 [label="param SourceMemberFieldSymbolFromDeclarator(DiagnosticBag diagnostics) 227100"];
4975 [label="containingType 227101"];
4976 [label="Debug.Assert((object)containingType != null); 227102"];
4977 [label="_name 227103"];
4978 [label="_location 227104"];
4979 [label="_syntaxReference 227105"];
4980 [label="Debug.Assert(name != null); 227106"];
4981 [label="Debug.Assert(syntax != null); 227107"];
4982 [label="Debug.Assert(location != null); 227108"];
4983 [label="_modifiers 227109"];
4984 [label="this.CheckAccessibility(diagnostics); 227110"];
4985 [label="this.CheckAccessibility(diagnostics) 227111"];
4986 [label="param CheckAccessibility(DiagnosticBag diagnostics) 227112"];
4987 [label="param CheckAccessibility(this) 227113"];
4988 [label="Modifiers 227114"];
4989 [label="get\n            {\n                return _modifiers;\n            } 227115"];
4990 [label="return _modifiers; 227116"];
4991 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 227117"];
4992 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 227118"];
4993 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 227119"];
4994 [label="ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false) 227120"];
4995 [label="param CheckAccessibility(DeclarationModifiers modifiers) 227121"];
4996 [label="param CheckAccessibility(Symbol symbol) 227122"];
4997 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 227123"];
4998 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 227124"];
4999 [label="IsValidAccessibility(modifiers) 227125"];
5000 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 227126"];
5001 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 227127"];
5002 [label="return true; 227128"];
5003 [label="symbol.Kind 227129"];
5004 [label="get\n            {\n                return SymbolKind.Field;\n            } 227130"];
5005 [label="return SymbolKind.Field; 227131"];
5006 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 227132"];
5007 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 227133"];
5008 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 227134"];
5009 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 227135"];
5010 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 227136"];
5011 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 227137"];
5012 [label="return null; 227138"];
5013 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 227139"];
5014 [label="if (info != null)\n            {\n                diagnostics.Add(new CSDiagnostic(info, this.ErrorLocation));\n            } 227140"];
5015 [label="if (info != null)\n            {\n                diagnostics.Add(new CSDiagnostic(info, this.ErrorLocation));\n            } 227141"];
5016 [label="this.CheckAccessibility(diagnostics); 227142"];
5017 [label="if (!modifierErrors)\n            {\n                this.ReportModifiersDiagnostics(diagnostics);\n            } 227143"];
5018 [label="this.ReportModifiersDiagnostics(diagnostics); 227144"];
5019 [label="this.ReportModifiersDiagnostics(diagnostics) 227145"];
5020 [label="param ReportModifiersDiagnostics(DiagnosticBag diagnostics) 227146"];
5021 [label="param ReportModifiersDiagnostics(this) 227147"];
5022 [label="ContainingType 227148"];
5023 [label="get\n            {\n                return this.containingType;\n            } 227149"];
5024 [label="return this.containingType; 227150"];
5025 [label="if (ContainingType.IsSealed && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(containingType), ErrorLocation, this);\n            }\n            else if (IsVolatile && IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_VolatileAndReadonly, ErrorLocation, this);\n            }\n            else if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 227151"];
5026 [label="ContainingType.IsSealed 227152"];
5027 [label="=> HasFlag(DeclarationModifiers.Sealed) 227153"];
5028 [label="DeclarationModifiers.Sealed 227154"];
5029 [label="HasFlag(DeclarationModifiers.Sealed) 227155"];
5030 [label="param HasFlag(DeclarationModifiers flag) 227156"];
5031 [label="=> (_declModifiers & flag) != 0 227157"];
5032 [label="_declModifiers & flag 227158"];
5033 [label="0 227159"];
5034 [label="(_declModifiers & flag) != 0 227160"];
5035 [label="IsVolatile 227161"];
5036 [label="=> (Modifiers & DeclarationModifiers.Volatile) != 0 227162"];
5037 [label="Modifiers 227163"];
5038 [label="get\n            {\n                return _modifiers;\n            } 227164"];
5039 [label="return _modifiers; 227165"];
5040 [label="Modifiers & DeclarationModifiers.Volatile 227166"];
5041 [label="0 227167"];
5042 [label="(Modifiers & DeclarationModifiers.Volatile) != 0 227168"];
5043 [label="if (IsVolatile && IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_VolatileAndReadonly, ErrorLocation, this);\n            }\n            else if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 227169"];
5044 [label="containingType.IsStatic 227170"];
5045 [label="=> HasFlag(DeclarationModifiers.Static) 227171"];
5046 [label="DeclarationModifiers.Static 227172"];
5047 [label="HasFlag(DeclarationModifiers.Static) 227173"];
5048 [label="param HasFlag(DeclarationModifiers flag) 227174"];
5049 [label="=> (_declModifiers & flag) != 0 227175"];
5050 [label="_declModifiers & flag 227176"];
5051 [label="if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 227177"];
5052 [label="IsStatic 227178"];
5053 [label="=> (Modifiers & DeclarationModifiers.Static) != 0 227179"];
5054 [label="Modifiers 227180"];
5055 [label="get\n            {\n                return _modifiers;\n            } 227181"];
5056 [label="Modifiers & DeclarationModifiers.Static 227182"];
5057 [label="0 227183"];
5058 [label="(Modifiers & DeclarationModifiers.Static) != 0 227184"];
5059 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 227185"];
5060 [label="IsReadOnly 227186"];
5061 [label="=> (Modifiers & DeclarationModifiers.ReadOnly) != 0 227187"];
5062 [label="Modifiers 227188"];
5063 [label="get\n            {\n                return _modifiers;\n            } 227189"];
5064 [label="Modifiers & DeclarationModifiers.ReadOnly 227190"];
5065 [label="0 227191"];
5066 [label="(Modifiers & DeclarationModifiers.ReadOnly) != 0 227192"];
5067 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 227193"];
5068 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 227194"];
5069 [label="containingType.IsReadOnly 227195"];
5070 [label="=> HasFlag(DeclarationModifiers.ReadOnly) 227196"];
5071 [label="DeclarationModifiers.ReadOnly 227197"];
5072 [label="HasFlag(DeclarationModifiers.ReadOnly) 227198"];
5073 [label="param HasFlag(DeclarationModifiers flag) 227199"];
5074 [label="=> (_declModifiers & flag) != 0 227200"];
5075 [label="_declModifiers & flag 227201"];
5076 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 227202"];
5077 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 227203"];
5078 [label="this.ReportModifiersDiagnostics(diagnostics); 227204"];
5079 [label="containingType.IsInterface 227205"];
5080 [label="if (containingType.IsInterface)\n            {\n                if (this.IsStatic)\n                {\n                    Binder.CheckFeatureAvailability(declarator, MessageID.IDS_DefaultInterfaceImplementation, diagnostics, ErrorLocation);\n\n                    if (!ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation, ErrorLocation);\n                    }\n                }\n                else\n                {\n                    diagnostics.Add(ErrorCode.ERR_InterfacesCantContainFields, ErrorLocation);\n                }\n            } 227206"];
5081 [label="fieldSymbol.IsStatic 227207"];
5082 [label="=> (Modifiers & DeclarationModifiers.Static) != 0 227208"];
5083 [label="Modifiers 227209"];
5084 [label="get\n            {\n                return _modifiers;\n            } 227210"];
5085 [label="return _modifiers; 227211"];
5086 [label="Modifiers & DeclarationModifiers.Static 227212"];
5087 [label="0 227213"];
5088 [label="(Modifiers & DeclarationModifiers.Static) != 0 227214"];
5089 [label="param UpdateIsNullableEnabledForConstructorsAndFields(bool useStatic) 227215"];
5090 [label="param UpdateIsNullableEnabledForConstructorsAndFields(this) 227216"];
5091 [label="ref bool isNullableEnabled = ref GetIsNullableEnabledForConstructorsAndFields(useStatic); 227217"];
5092 [label="GetIsNullableEnabledForConstructorsAndFields(useStatic) 227218"];
5093 [label="param GetIsNullableEnabledForConstructorsAndFields(bool useStatic) 227219"];
5094 [label="param GetIsNullableEnabledForConstructorsAndFields(this) 227220"];
5095 [label="useStatic 227221"];
5096 [label="IsNullableEnabledForInstanceConstructorsAndFields 227222"];
5097 [label="return ref useStatic ? ref IsNullableEnabledForStaticConstructorsAndFields : ref IsNullableEnabledForInstanceConstructorsAndFields; 227223"];
5098 [label="Options 227224"];
5099 [label="return _options; 227225"];
5100 [label="isNullableEnabled = isNullableEnabled || compilation.IsNullableAnalysisEnabledIn(syntax); 227226"];
5101 [label="return kind == DeclarationKind.Script || kind == DeclarationKind.Submission; 227227"];
5102 [label="if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                } 227228"];
5103 [label="if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                } 227229"];
5104 [label="if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                } 227230"];
5105 [label="if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                } 227231"];
5106 [label="bool reportMisplacedGlobalCode = !m.HasErrors; 227232"];
5107 [label="var constructorSyntax = (ConstructorDeclarationSyntax)m; 227233"];
5108 [label="IsImplicitClass 227234"];
5109 [label="if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(constructorSyntax.Identifier));\n                            } 227235"];
5110 [label="bool isNullableEnabled = compilation.IsNullableAnalysisEnabledIn(constructorSyntax); 227236"];
5111 [label="compilation.IsNullableAnalysisEnabledIn(constructorSyntax) 227237"];
5112 [label="param IsNullableAnalysisEnabledIn(SyntaxNode syntax) 227238"];
5113 [label="return IsNullableAnalysisEnabledIn((CSharpSyntaxTree)syntax.SyntaxTree, syntax.Span); 227239"];
5114 [label="return Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            }; 227240"];
5115 [label="Options 227241"];
5116 [label="return _options; 227242"];
5117 [label="var constructor = SourceConstructorSymbol.CreateConstructorSymbol(this, constructorSyntax, isNullableEnabled, diagnostics); 227243"];
5118 [label="var constructor = SourceConstructorSymbol.CreateConstructorSymbol(this, constructorSyntax, isNullableEnabled, diagnostics); 227244"];
5119 [label="var constructor = SourceConstructorSymbol.CreateConstructorSymbol(this, constructorSyntax, isNullableEnabled, diagnostics); 227245"];
5120 [label="var constructor = SourceConstructorSymbol.CreateConstructorSymbol(this, constructorSyntax, isNullableEnabled, diagnostics); 227246"];
5121 [label="SourceConstructorSymbol.CreateConstructorSymbol(this, constructorSyntax, isNullableEnabled, diagnostics) 227247"];
5122 [label="param CreateConstructorSymbol(SourceMemberContainerTypeSymbol containingType) 227248"];
5123 [label="param CreateConstructorSymbol(ConstructorDeclarationSyntax syntax) 227249"];
5124 [label="param CreateConstructorSymbol(bool isNullableAnalysisEnabled) 227250"];
5125 [label="param CreateConstructorSymbol(DiagnosticBag diagnostics) 227251"];
5126 [label="var methodKind = syntax.Modifiers.Any(SyntaxKind.StaticKeyword) ? MethodKind.StaticConstructor : MethodKind.Constructor; 227252"];
5127 [label="var methodKind = syntax.Modifiers.Any(SyntaxKind.StaticKeyword) ? MethodKind.StaticConstructor : MethodKind.Constructor; 227253"];
5128 [label="syntax.Modifiers.Any(SyntaxKind.StaticKeyword) 227254"];
5129 [label="return new SourceConstructorSymbol(containingType, syntax.Identifier.GetLocation(), syntax, methodKind, isNullableAnalysisEnabled, diagnostics); 227255"];
5130 [label="return new SourceConstructorSymbol(containingType, syntax.Identifier.GetLocation(), syntax, methodKind, isNullableAnalysisEnabled, diagnostics); 227256"];
5131 [label="syntax.Identifier 227257"];
5132 [label="param SourceConstructorSymbol(SourceMemberContainerTypeSymbol containingType) 227258"];
5133 [label="param SourceConstructorSymbol(Location location) 227259"];
5134 [label="param SourceConstructorSymbol(ConstructorDeclarationSyntax syntax) 227260"];
5135 [label="param SourceConstructorSymbol(MethodKind methodKind) 227261"];
5136 [label="param SourceConstructorSymbol(bool isNullableAnalysisEnabled) 227262"];
5137 [label="param SourceConstructorSymbol(DiagnosticBag diagnostics) 227263"];
5138 [label="param SourceConstructorSymbol(this) 227264"];
5139 [label="containingType 227265"];
5140 [label="location 227266"];
5141 [label="syntax 227267"];
5142 [label="syntax 227268"];
5143 [label="SyntaxFacts.HasYieldOperations(syntax) 227269"];
5144 [label="param SourceConstructorSymbol(this) 227270"];
5145 [label="param SourceConstructorSymbolBase(SourceMemberContainerTypeSymbol containingType) 227271"];
5146 [label="param SourceConstructorSymbolBase(Location location) 227272"];
5147 [label="param SourceConstructorSymbolBase(CSharpSyntaxNode syntax) 227273"];
5148 [label="param SourceConstructorSymbolBase(bool isIterator) 227274"];
5149 [label="param SourceConstructorSymbolBase(this) 227275"];
5150 [label="containingType 227276"];
5151 [label="syntax.GetReference() 227277"];
5152 [label="location 227278"];
5153 [label="ImmutableArray.Create(location) 227279"];
5154 [label="isIterator 227280"];
5155 [label="param SourceConstructorSymbolBase(this) 227281"];
5156 [label="param SourceMemberMethodSymbol(NamedTypeSymbol containingType) 227282"];
5157 [label="param SourceMemberMethodSymbol(SyntaxReference syntaxReferenceOpt) 227283"];
5158 [label="param SourceMemberMethodSymbol(ImmutableArray<Location> locations) 227284"];
5159 [label="param SourceMemberMethodSymbol(bool isIterator) 227285"];
5160 [label="param SourceMemberMethodSymbol(this) 227286"];
5161 [label="syntaxReferenceOpt 227287"];
5162 [label="param SourceMemberMethodSymbol(this) 227288"];
5163 [label="param SourceMethodSymbolWithAttributes(SyntaxReference syntaxReferenceOpt) 227289"];
5164 [label="param SourceMethodSymbolWithAttributes(this) 227290"];
5165 [label="param SourceMethodSymbolWithAttributes(this) 227291"];
5166 [label="param SourceMethodSymbol(this) 227292"];
5167 [label="null 227293"];
5168 [label="None = null 227294"];
5169 [label="param SourceMethodSymbol(this) 227295"];
5170 [label="param MethodSymbol(this) 227296"];
5171 [label="param MethodSymbol(this) 227297"];
5172 [label="_lazyAdapter 227298"];
5173 [label="_lazyParameterSignature 227299"];
5174 [label="_lazyCustomAttributesBag 227300"];
5175 [label="_lazyReturnTypeCustomAttributesBag 227301"];
5176 [label="syntaxReferenceOpt 227302"];
5177 [label="this.syntaxReferenceOpt 227303"];
5178 [label="DeclarationModifiers 227304"];
5179 [label="_containingType 227305"];
5180 [label="_lazyThisParameter 227306"];
5181 [label="_lazyIteratorElementType 227307"];
5182 [label="_lazyOverriddenOrHiddenMembers 227308"];
5183 [label="lazyDocComment 227309"];
5184 [label="lazyExpandedDocComment 227310"];
5185 [label="Debug.Assert((object)containingType != null); 227311"];
5186 [label="Debug.Assert((object)containingType != null); 227312"];
5187 [label="Debug.Assert(!locations.IsEmpty); 227313"];
5188 [label="_containingType 227314"];
5189 [label="this.locations 227315"];
5190 [label="if (isIterator)\n            {\n                _lazyIteratorElementType = TypeWithAnnotations.Boxed.Sentinel;\n            } 227316"];
5191 [label="_lazyIsVararg 227317"];
5192 [label="Debug.Assert(\n                syntax.IsKind(SyntaxKind.ConstructorDeclaration) ||\n                syntax.IsKind(SyntaxKind.RecordDeclaration)); 227318"];
5193 [label="Debug.Assert(\n                syntax.IsKind(SyntaxKind.ConstructorDeclaration) ||\n                syntax.IsKind(SyntaxKind.RecordDeclaration)); 227319"];
5194 [label="Debug.Assert(\n                syntax.IsKind(SyntaxKind.ConstructorDeclaration) ||\n                syntax.IsKind(SyntaxKind.RecordDeclaration)); 227320"];
5195 [label="_isExpressionBodied 227321"];
5196 [label="_hasThisInitializer 227322"];
5197 [label="bool hasBlockBody = syntax.Body != null; 227323"];
5198 [label="bool hasBlockBody = syntax.Body != null; 227324"];
5199 [label="_isExpressionBodied = !hasBlockBody && syntax.ExpressionBody != null; 227325"];
5200 [label="_isExpressionBodied 227326"];
5201 [label="bool hasBody = hasBlockBody || _isExpressionBodied; 227327"];
5202 [label="_hasThisInitializer = syntax.Initializer?.Kind() == SyntaxKind.ThisConstructorInitializer; 227328"];
5203 [label="_hasThisInitializer 227329"];
5204 [label="bool modifierErrors; 227330"];
5205 [label="var declarationModifiers = this.MakeModifiers(syntax.Modifiers, methodKind, hasBody, location, diagnostics, out modifierErrors); 227331"];
5206 [label="var declarationModifiers = this.MakeModifiers(syntax.Modifiers, methodKind, hasBody, location, diagnostics, out modifierErrors); 227332"];
5207 [label="var declarationModifiers = this.MakeModifiers(syntax.Modifiers, methodKind, hasBody, location, diagnostics, out modifierErrors); 227333"];
5208 [label="var declarationModifiers = this.MakeModifiers(syntax.Modifiers, methodKind, hasBody, location, diagnostics, out modifierErrors); 227334"];
5209 [label="var declarationModifiers = this.MakeModifiers(syntax.Modifiers, methodKind, hasBody, location, diagnostics, out modifierErrors); 227335"];
5210 [label="var declarationModifiers = this.MakeModifiers(syntax.Modifiers, methodKind, hasBody, location, diagnostics, out modifierErrors); 227336"];
5211 [label="this.MakeModifiers(syntax.Modifiers, methodKind, hasBody, location, diagnostics, out modifierErrors) 227337"];
5212 [label="param MakeModifiers(SyntaxTokenList modifiers) 227338"];
5213 [label="param MakeModifiers(MethodKind methodKind) 227339"];
5214 [label="param MakeModifiers(bool hasBody) 227340"];
5215 [label="param MakeModifiers(Location location) 227341"];
5216 [label="param MakeModifiers(DiagnosticBag diagnostics) 227342"];
5217 [label="param MakeModifiers(out bool modifierErrors) 227343"];
5218 [label="param MakeModifiers(this) 227344"];
5219 [label="var defaultAccess = (methodKind == MethodKind.StaticConstructor) ? DeclarationModifiers.None : DeclarationModifiers.Private; 227345"];
5220 [label="(methodKind == MethodKind.StaticConstructor) 227346"];
5221 [label="const DeclarationModifiers allowedModifiers =\n                DeclarationModifiers.AccessibilityMask |\n                DeclarationModifiers.Static |\n                DeclarationModifiers.Extern |\n                DeclarationModifiers.Unsafe; 227347"];
5222 [label="var mods = ModifierUtils.MakeAndCheckNontypeMemberModifiers(modifiers, defaultAccess, allowedModifiers, location, diagnostics, out modifierErrors); 227348"];
5223 [label="var mods = ModifierUtils.MakeAndCheckNontypeMemberModifiers(modifiers, defaultAccess, allowedModifiers, location, diagnostics, out modifierErrors); 227349"];
5224 [label="var mods = ModifierUtils.MakeAndCheckNontypeMemberModifiers(modifiers, defaultAccess, allowedModifiers, location, diagnostics, out modifierErrors); 227350"];
5225 [label="var mods = ModifierUtils.MakeAndCheckNontypeMemberModifiers(modifiers, defaultAccess, allowedModifiers, location, diagnostics, out modifierErrors); 227351"];
5226 [label="var mods = ModifierUtils.MakeAndCheckNontypeMemberModifiers(modifiers, defaultAccess, allowedModifiers, location, diagnostics, out modifierErrors); 227352"];
5227 [label="var mods = ModifierUtils.MakeAndCheckNontypeMemberModifiers(modifiers, defaultAccess, allowedModifiers, location, diagnostics, out modifierErrors); 227353"];
5228 [label="ModifierUtils.MakeAndCheckNontypeMemberModifiers(modifiers, defaultAccess, allowedModifiers, location, diagnostics, out modifierErrors) 227354"];
5229 [label="param MakeAndCheckNontypeMemberModifiers(SyntaxTokenList modifiers) 227355"];
5230 [label="param MakeAndCheckNontypeMemberModifiers(DeclarationModifiers defaultAccess) 227356"];
5231 [label="param MakeAndCheckNontypeMemberModifiers(DeclarationModifiers allowedModifiers) 227357"];
5232 [label="param MakeAndCheckNontypeMemberModifiers(Location errorLocation) 227358"];
5233 [label="param MakeAndCheckNontypeMemberModifiers(DiagnosticBag diagnostics) 227359"];
5234 [label="param MakeAndCheckNontypeMemberModifiers(out bool modifierErrors) 227360"];
5235 [label="param ToDeclarationModifiers(DiagnosticBag diagnostics) 227361"];
5236 [label="bool seenNoDuplicates = true; 227362"];
5237 [label="bool seenNoAccessibilityDuplicates = true; 227363"];
5238 [label="switch (result & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.Protected | DeclarationModifiers.Internal:\n                    // the two keywords 'protected' and 'internal' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.ProtectedInternal;\n                    break;\n\n                case DeclarationModifiers.Private | DeclarationModifiers.Protected:\n                    // the two keywords 'private' and 'protected' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.PrivateProtected;\n                    break;\n            } 227364"];
5239 [label="param CheckModifiers(Location errorLocation) 227365"];
5240 [label="param CheckModifiers(DiagnosticBag diagnostics) 227366"];
5241 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 227367"];
5242 [label="param CheckModifiers(out bool modifierErrors) 227368"];
5243 [label="modifierErrors = false; 227369"];
5244 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 227370"];
5245 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 227371"];
5246 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 227372"];
5247 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 227373"];
5248 [label="result |= defaultAccess; 227374"];
5249 [label="this.CheckUnsafeModifier(mods, diagnostics); 227375"];
5250 [label="this.CheckUnsafeModifier(mods, diagnostics); 227376"];
5251 [label="this.CheckUnsafeModifier(mods, diagnostics); 227377"];
5252 [label="this.CheckUnsafeModifier(mods, diagnostics) 227378"];
5253 [label="param CheckUnsafeModifier(this Symbol symbol) 227379"];
5254 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 227380"];
5255 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 227381"];
5256 [label="get\n            {\n                return this.locations;\n            } 227382"];
5257 [label="return this.locations; 227383"];
5258 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 227384"];
5259 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics) 227385"];
5260 [label="param CheckUnsafeModifier(this Symbol symbol) 227386"];
5261 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 227387"];
5262 [label="param CheckUnsafeModifier(Location errorLocation) 227388"];
5263 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 227389"];
5264 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 227390"];
5265 [label="this.CheckUnsafeModifier(mods, diagnostics); 227391"];
5266 [label="if (methodKind == MethodKind.StaticConstructor)\n            {\n                if ((mods & DeclarationModifiers.AccessibilityMask) != 0)\n                {\n                    diagnostics.Add(ErrorCode.ERR_StaticConstructorWithAccessModifiers, location, this);\n                    mods = mods & ~DeclarationModifiers.AccessibilityMask;\n                    modifierErrors = true;\n                }\n\n                mods |= DeclarationModifiers.Private; // we mark static constructors private in the symbol table\n\n                if (this.ContainingType.IsInterface)\n                {\n                    ModifierUtils.ReportDefaultInterfaceImplementationModifiers(hasBody, mods,\n                                                                                DeclarationModifiers.Extern,\n                                                                                location, diagnostics);\n                }\n            } 227392"];
5267 [label="return mods; 227393"];
5268 [label="this.MakeFlags(methodKind, declarationModifiers, returnsVoid: true, isExtensionMethod: false, isNullableAnalysisEnabled: isNullableAnalysisEnabled); 227394"];
5269 [label="this.MakeFlags(methodKind, declarationModifiers, returnsVoid: true, isExtensionMethod: false, isNullableAnalysisEnabled: isNullableAnalysisEnabled); 227395"];
5270 [label="this.MakeFlags(methodKind, declarationModifiers, returnsVoid: true, isExtensionMethod: false, isNullableAnalysisEnabled: isNullableAnalysisEnabled); 227396"];
5271 [label="this.MakeFlags(methodKind, declarationModifiers, returnsVoid: true, isExtensionMethod: false, isNullableAnalysisEnabled: isNullableAnalysisEnabled); 227397"];
5272 [label="this.MakeFlags(methodKind, declarationModifiers, returnsVoid: true, isExtensionMethod: false, isNullableAnalysisEnabled: isNullableAnalysisEnabled) 227398"];
5273 [label="param MakeFlags(MethodKind methodKind) 227399"];
5274 [label="param MakeFlags(DeclarationModifiers declarationModifiers) 227400"];
5275 [label="param MakeFlags(bool returnsVoid) 227401"];
5276 [label="param MakeFlags(bool isExtensionMethod) 227402"];
5277 [label="param MakeFlags(bool isNullableAnalysisEnabled) 227403"];
5278 [label="param MakeFlags(bool isMetadataVirtualIgnoringModifiers = false) 227404"];
5279 [label="param MakeFlags(this) 227405"];
5280 [label="DeclarationModifiers 227406"];
5281 [label="0 227407"];
5282 [label="MethodKindOffset = 0 227408"];
5283 [label="5 227409"];
5284 [label="MethodKindSize = 5 227410"];
5285 [label="MethodKindOffset + MethodKindSize 227411"];
5286 [label="IsExtensionMethodOffset = MethodKindOffset + MethodKindSize 227412"];
5287 [label="1 227413"];
5288 [label="IsExtensionMethodSize = 1 227414"];
5289 [label="IsExtensionMethodOffset + IsExtensionMethodSize 227415"];
5290 [label="IsMetadataVirtualIgnoringInterfaceChangesOffset = IsExtensionMethodOffset + IsExtensionMethodSize 227416"];
5291 [label="1 227417"];
5292 [label="IsMetadataVirtualIgnoringInterfaceChangesSize = 1 227418"];
5293 [label="IsMetadataVirtualIgnoringInterfaceChangesOffset + IsMetadataVirtualIgnoringInterfaceChangesSize 227419"];
5294 [label="IsMetadataVirtualOffset = IsMetadataVirtualIgnoringInterfaceChangesOffset + IsMetadataVirtualIgnoringInterfaceChangesSize 227420"];
5295 [label="1 227421"];
5296 [label="IsMetadataVirtualSize = 1 227422"];
5297 [label="IsMetadataVirtualOffset + IsMetadataVirtualSize 227423"];
5298 [label="IsMetadataVirtualLockedOffset = IsMetadataVirtualOffset + IsMetadataVirtualSize 227424"];
5299 [label="1 227425"];
5300 [label="IsMetadataVirtualLockedSize = 1 227426"];
5301 [label="IsMetadataVirtualLockedOffset + IsMetadataVirtualLockedSize 227427"];
5302 [label="ReturnsVoidOffset = IsMetadataVirtualLockedOffset + IsMetadataVirtualLockedSize 227428"];
5303 [label="2 227429"];
5304 [label="ReturnsVoidSize = 2 227430"];
5305 [label="ReturnsVoidOffset + ReturnsVoidSize 227431"];
5306 [label="NullableContextOffset = ReturnsVoidOffset + ReturnsVoidSize 227432"];
5307 [label="3 227433"];
5308 [label="NullableContextSize = 3 227434"];
5309 [label="NullableContextOffset + NullableContextSize 227435"];
5310 [label="IsNullableAnalysisEnabledOffset = NullableContextOffset + NullableContextSize 227436"];
5311 [label="1 227437"];
5312 [label="IsNullableAnalysisEnabledSize = 1 227438"];
5313 [label="1 227439"];
5314 [label="1 << MethodKindSize 227440"];
5315 [label="1 227441"];
5316 [label="(1 << MethodKindSize) - 1 227442"];
5317 [label="MethodKindMask = (1 << MethodKindSize) - 1 227443"];
5318 [label="1 227444"];
5319 [label="1 << IsExtensionMethodOffset 227445"];
5320 [label="IsExtensionMethodBit = 1 << IsExtensionMethodOffset 227446"];
5321 [label="1 227447"];
5322 [label="1 << IsMetadataVirtualIgnoringInterfaceChangesOffset 227448"];
5323 [label="IsMetadataVirtualIgnoringInterfaceChangesBit = 1 << IsMetadataVirtualIgnoringInterfaceChangesOffset 227449"];
5324 [label="1 227450"];
5325 [label="1 << IsMetadataVirtualIgnoringInterfaceChangesOffset 227451"];
5326 [label="IsMetadataVirtualBit = 1 << IsMetadataVirtualIgnoringInterfaceChangesOffset 227452"];
5327 [label="1 227453"];
5328 [label="1 << IsMetadataVirtualLockedOffset 227454"];
5329 [label="IsMetadataVirtualLockedBit = 1 << IsMetadataVirtualLockedOffset 227455"];
5330 [label="1 227456"];
5331 [label="1 << ReturnsVoidOffset 227457"];
5332 [label="ReturnsVoidBit = 1 << ReturnsVoidOffset 227458"];
5333 [label="1 227459"];
5334 [label="1 227460"];
5335 [label="ReturnsVoidOffset + 1 227461"];
5336 [label="1 << ReturnsVoidOffset + 1 227462"];
5337 [label="ReturnsVoidIsSetBit = 1 << ReturnsVoidOffset + 1 227463"];
5338 [label="1 227464"];
5339 [label="1 << NullableContextSize 227465"];
5340 [label="1 227466"];
5341 [label="(1 << NullableContextSize) - 1 227467"];
5342 [label="NullableContextMask = (1 << NullableContextSize) - 1 227468"];
5343 [label="1 227469"];
5344 [label="1 << IsNullableAnalysisEnabledOffset 227470"];
5345 [label="IsNullableAnalysisEnabledBit = 1 << IsNullableAnalysisEnabledOffset 227471"];
5346 [label="Debug.Assert(EnumUtilities.ContainsAllValues<MethodKind>(MethodKindMask)); 227472"];
5347 [label="Debug.Assert(EnumUtilities.ContainsAllValues<NullableContextKind>(NullableContextMask)); 227473"];
5348 [label="this.flags = new Flags(methodKind, declarationModifiers, returnsVoid, isExtensionMethod, isNullableAnalysisEnabled, isMetadataVirtualIgnoringModifiers); 227474"];
5349 [label="this.flags = new Flags(methodKind, declarationModifiers, returnsVoid, isExtensionMethod, isNullableAnalysisEnabled, isMetadataVirtualIgnoringModifiers); 227475"];
5350 [label="this.flags = new Flags(methodKind, declarationModifiers, returnsVoid, isExtensionMethod, isNullableAnalysisEnabled, isMetadataVirtualIgnoringModifiers); 227476"];
5351 [label="this.flags = new Flags(methodKind, declarationModifiers, returnsVoid, isExtensionMethod, isNullableAnalysisEnabled, isMetadataVirtualIgnoringModifiers); 227477"];
5352 [label="this.flags = new Flags(methodKind, declarationModifiers, returnsVoid, isExtensionMethod, isNullableAnalysisEnabled, isMetadataVirtualIgnoringModifiers); 227478"];
5353 [label="this.flags = new Flags(methodKind, declarationModifiers, returnsVoid, isExtensionMethod, isNullableAnalysisEnabled, isMetadataVirtualIgnoringModifiers); 227479"];
5354 [label="this.flags = new Flags(methodKind, declarationModifiers, returnsVoid, isExtensionMethod, isNullableAnalysisEnabled, isMetadataVirtualIgnoringModifiers); 227480"];
5355 [label="new Flags(methodKind, declarationModifiers, returnsVoid, isExtensionMethod, isNullableAnalysisEnabled, isMetadataVirtualIgnoringModifiers) 227481"];
5356 [label="param Flags(MethodKind methodKind) 227482"];
5357 [label="param Flags(DeclarationModifiers declarationModifiers) 227483"];
5358 [label="param Flags(bool returnsVoid) 227484"];
5359 [label="param Flags(bool isExtensionMethod) 227485"];
5360 [label="param Flags(bool isNullableAnalysisEnabled) 227486"];
5361 [label="param Flags(bool isMetadataVirtualIgnoringModifiers = false) 227487"];
5362 [label="param Flags(this) 227488"];
5363 [label="bool isMetadataVirtual = isMetadataVirtualIgnoringModifiers || ModifiersRequireMetadataVirtual(declarationModifiers); 227489"];
5364 [label="ModifiersRequireMetadataVirtual(declarationModifiers) 227490"];
5365 [label="param ModifiersRequireMetadataVirtual(DeclarationModifiers modifiers) 227491"];
5366 [label="return (modifiers & (DeclarationModifiers.Abstract | DeclarationModifiers.Virtual | DeclarationModifiers.Override)) != 0; 227492"];
5367 [label="return (modifiers & (DeclarationModifiers.Abstract | DeclarationModifiers.Virtual | DeclarationModifiers.Override)) != 0; 227493"];
5368 [label="return (modifiers & (DeclarationModifiers.Abstract | DeclarationModifiers.Virtual | DeclarationModifiers.Override)) != 0; 227494"];
5369 [label="bool isMetadataVirtual = isMetadataVirtualIgnoringModifiers || ModifiersRequireMetadataVirtual(declarationModifiers); 227495"];
5370 [label="int methodKindInt = ((int)methodKind & MethodKindMask) << MethodKindOffset; 227496"];
5371 [label="int methodKindInt = ((int)methodKind & MethodKindMask) << MethodKindOffset; 227497"];
5372 [label="isExtensionMethod 227498"];
5373 [label="int isExtensionMethodInt = isExtensionMethod ? IsExtensionMethodBit : 0; 227499"];
5374 [label="isNullableAnalysisEnabled 227500"];
5375 [label="int isNullableAnalysisEnabledInt = isNullableAnalysisEnabled ? IsNullableAnalysisEnabledBit : 0; 227501"];
5376 [label="isMetadataVirtual 227502"];
5377 [label="int isMetadataVirtualIgnoringInterfaceImplementationChangesInt = isMetadataVirtual ? IsMetadataVirtualIgnoringInterfaceChangesBit : 0; 227503"];
5378 [label="isMetadataVirtual 227504"];
5379 [label="int isMetadataVirtualInt = isMetadataVirtual ? IsMetadataVirtualBit : 0; 227505"];
5380 [label="_flags = methodKindInt\n                    | isExtensionMethodInt\n                    | isNullableAnalysisEnabledInt\n                    | isMetadataVirtualIgnoringInterfaceImplementationChangesInt\n                    | isMetadataVirtualInt\n                    | (returnsVoid ? ReturnsVoidBit : 0)\n                    | ReturnsVoidIsSetBit; 227506"];
5381 [label="_flags = methodKindInt\n                    | isExtensionMethodInt\n                    | isNullableAnalysisEnabledInt\n                    | isMetadataVirtualIgnoringInterfaceImplementationChangesInt\n                    | isMetadataVirtualInt\n                    | (returnsVoid ? ReturnsVoidBit : 0)\n                    | ReturnsVoidIsSetBit; 227507"];
5382 [label="_flags = methodKindInt\n                    | isExtensionMethodInt\n                    | isNullableAnalysisEnabledInt\n                    | isMetadataVirtualIgnoringInterfaceImplementationChangesInt\n                    | isMetadataVirtualInt\n                    | (returnsVoid ? ReturnsVoidBit : 0)\n                    | ReturnsVoidIsSetBit; 227508"];
5383 [label="_flags = methodKindInt\n                    | isExtensionMethodInt\n                    | isNullableAnalysisEnabledInt\n                    | isMetadataVirtualIgnoringInterfaceImplementationChangesInt\n                    | isMetadataVirtualInt\n                    | (returnsVoid ? ReturnsVoidBit : 0)\n                    | ReturnsVoidIsSetBit; 227509"];
5384 [label="returnsVoid 227510"];
5385 [label="_flags = methodKindInt\n                    | isExtensionMethodInt\n                    | isNullableAnalysisEnabledInt\n                    | isMetadataVirtualIgnoringInterfaceImplementationChangesInt\n                    | isMetadataVirtualInt\n                    | (returnsVoid ? ReturnsVoidBit : 0)\n                    | ReturnsVoidIsSetBit; 227511"];
5386 [label="_flags = methodKindInt\n                    | isExtensionMethodInt\n                    | isNullableAnalysisEnabledInt\n                    | isMetadataVirtualIgnoringInterfaceImplementationChangesInt\n                    | isMetadataVirtualInt\n                    | (returnsVoid ? ReturnsVoidBit : 0)\n                    | ReturnsVoidIsSetBit; 227512"];
5387 [label="_flags = methodKindInt\n                    | isExtensionMethodInt\n                    | isNullableAnalysisEnabledInt\n                    | isMetadataVirtualIgnoringInterfaceImplementationChangesInt\n                    | isMetadataVirtualInt\n                    | (returnsVoid ? ReturnsVoidBit : 0)\n                    | ReturnsVoidIsSetBit; 227513"];
5388 [label="_flags 227514"];
5389 [label="this.flags 227515"];
5390 [label="if (syntax.Identifier.ValueText != containingType.Name)\n            {\n                // This is probably a method declaration with the type missing.\n                diagnostics.Add(ErrorCode.ERR_MemberNeedsType, location);\n            } 227516"];
5391 [label="syntax.Identifier 227517"];
5392 [label="get\n            {\n                return declaration.Name;\n            } 227518"];
5393 [label="if (syntax.Identifier.ValueText != containingType.Name)\n            {\n                // This is probably a method declaration with the type missing.\n                diagnostics.Add(ErrorCode.ERR_MemberNeedsType, location);\n            } 227519"];
5394 [label="IsExtern 227520"];
5395 [label="get\n            {\n                return HasExternModifier;\n            } 227521"];
5396 [label="HasExternModifier 227522"];
5397 [label="get\n            {\n                return (this.DeclarationModifiers & DeclarationModifiers.Extern) != 0;\n            } 227523"];
5398 [label="return (this.DeclarationModifiers & DeclarationModifiers.Extern) != 0; 227524"];
5399 [label="return (this.DeclarationModifiers & DeclarationModifiers.Extern) != 0; 227525"];
5400 [label="return HasExternModifier; 227526"];
5401 [label="if (IsExtern)\n            {\n                if (methodKind == MethodKind.Constructor && syntax.Initializer != null)\n                {\n                    diagnostics.Add(ErrorCode.ERR_ExternHasConstructorInitializer, location, this);\n                }\n\n                if (hasBody)\n                {\n                    diagnostics.Add(ErrorCode.ERR_ExternHasBody, location, this);\n                }\n            } 227527"];
5402 [label="if (methodKind == MethodKind.StaticConstructor)\n            {\n                CheckFeatureAvailabilityAndRuntimeSupport(syntax, location, hasBody, diagnostics);\n            } 227528"];
5403 [label="var info = ModifierUtils.CheckAccessibility(this.DeclarationModifiers, this, isExplicitInterfaceImplementation: false); 227529"];
5404 [label="var info = ModifierUtils.CheckAccessibility(this.DeclarationModifiers, this, isExplicitInterfaceImplementation: false); 227530"];
5405 [label="var info = ModifierUtils.CheckAccessibility(this.DeclarationModifiers, this, isExplicitInterfaceImplementation: false); 227531"];
5406 [label="ModifierUtils.CheckAccessibility(this.DeclarationModifiers, this, isExplicitInterfaceImplementation: false) 227532"];
5407 [label="param CheckAccessibility(DeclarationModifiers modifiers) 227533"];
5408 [label="param CheckAccessibility(Symbol symbol) 227534"];
5409 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 227535"];
5410 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 227536"];
5411 [label="IsValidAccessibility(modifiers) 227537"];
5412 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 227538"];
5413 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 227539"];
5414 [label="return true; 227540"];
5415 [label="symbol.Kind 227541"];
5416 [label="get\n            {\n                return SymbolKind.Method;\n            } 227542"];
5417 [label="return SymbolKind.Method; 227543"];
5418 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 227544"];
5419 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 227545"];
5420 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 227546"];
5421 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 227547"];
5422 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 227548"];
5423 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 227549"];
5424 [label="return null; 227550"];
5425 [label="var info = ModifierUtils.CheckAccessibility(this.DeclarationModifiers, this, isExplicitInterfaceImplementation: false); 227551"];
5426 [label="if (info != null)\n            {\n                diagnostics.Add(info, location);\n            } 227552"];
5427 [label="if (info != null)\n            {\n                diagnostics.Add(info, location);\n            } 227553"];
5428 [label="if (!modifierErrors)\n            {\n                this.CheckModifiers(methodKind, hasBody, location, diagnostics);\n            } 227554"];
5429 [label="this.CheckModifiers(methodKind, hasBody, location, diagnostics); 227555"];
5430 [label="this.CheckModifiers(methodKind, hasBody, location, diagnostics); 227556"];
5431 [label="this.CheckModifiers(methodKind, hasBody, location, diagnostics); 227557"];
5432 [label="this.CheckModifiers(methodKind, hasBody, location, diagnostics); 227558"];
5433 [label="this.CheckModifiers(methodKind, hasBody, location, diagnostics) 227559"];
5434 [label="param CheckModifiers(MethodKind methodKind) 227560"];
5435 [label="param CheckModifiers(bool hasBody) 227561"];
5436 [label="param CheckModifiers(Location location) 227562"];
5437 [label="param CheckModifiers(DiagnosticBag diagnostics) 227563"];
5438 [label="param CheckModifiers(this) 227564"];
5439 [label="if (!hasBody && !IsExtern)\n            {\n                diagnostics.Add(ErrorCode.ERR_ConcreteMissingBody, location, this);\n            }\n            else if (ContainingType.IsSealed && this.DeclaredAccessibility.HasProtected() && !this.IsOverride)\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), location, this);\n            }\n            else if (ContainingType.IsStatic && methodKind == MethodKind.Constructor)\n            {\n                diagnostics.Add(ErrorCode.ERR_ConstructorInStaticClass, location);\n            } 227565"];
5440 [label="ContainingType 227566"];
5441 [label="get\n            {\n                return _containingType;\n            } 227567"];
5442 [label="return _containingType; 227568"];
5443 [label="if (ContainingType.IsSealed && this.DeclaredAccessibility.HasProtected() && !this.IsOverride)\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), location, this);\n            }\n            else if (ContainingType.IsStatic && methodKind == MethodKind.Constructor)\n            {\n                diagnostics.Add(ErrorCode.ERR_ConstructorInStaticClass, location);\n            } 227569"];
5444 [label="ContainingType.IsSealed 227570"];
5445 [label="=> HasFlag(DeclarationModifiers.Sealed) 227571"];
5446 [label="DeclarationModifiers.Sealed 227572"];
5447 [label="HasFlag(DeclarationModifiers.Sealed) 227573"];
5448 [label="param HasFlag(DeclarationModifiers flag) 227574"];
5449 [label="=> (_declModifiers & flag) != 0 227575"];
5450 [label="_declModifiers & flag 227576"];
5451 [label="0 227577"];
5452 [label="(_declModifiers & flag) != 0 227578"];
5453 [label="ContainingType 227579"];
5454 [label="if (ContainingType.IsStatic && methodKind == MethodKind.Constructor)\n            {\n                diagnostics.Add(ErrorCode.ERR_ConstructorInStaticClass, location);\n            } 227580"];
5455 [label="ContainingType.IsStatic 227581"];
5456 [label="=> HasFlag(DeclarationModifiers.Static) 227582"];
5457 [label="DeclarationModifiers.Static 227583"];
5458 [label="HasFlag(DeclarationModifiers.Static) 227584"];
5459 [label="param HasFlag(DeclarationModifiers flag) 227585"];
5460 [label="=> (_declModifiers & flag) != 0 227586"];
5461 [label="_declModifiers & flag 227587"];
5462 [label="this.CheckModifiers(methodKind, hasBody, location, diagnostics); 227588"];
5463 [label="CheckForBlockAndExpressionBody(\n                syntax.Body, syntax.ExpressionBody, syntax, diagnostics); 227589"];
5464 [label="CheckForBlockAndExpressionBody(\n                syntax.Body, syntax.ExpressionBody, syntax, diagnostics); 227590"];
5465 [label="CheckForBlockAndExpressionBody(\n                syntax.Body, syntax.ExpressionBody, syntax, diagnostics); 227591"];
5466 [label="CheckForBlockAndExpressionBody(\n                syntax.Body, syntax.ExpressionBody, syntax, diagnostics) 227592"];
5467 [label="param CheckForBlockAndExpressionBody(CSharpSyntaxNode block) 227593"];
5468 [label="param CheckForBlockAndExpressionBody(CSharpSyntaxNode expression) 227594"];
5469 [label="param CheckForBlockAndExpressionBody(CSharpSyntaxNode syntax) 227595"];
5470 [label="param CheckForBlockAndExpressionBody(DiagnosticBag diagnostics) 227596"];
5471 [label="if (block != null && expression != null)\n            {\n                diagnostics.Add(ErrorCode.ERR_BlockBodyAndExpressionBody, syntax.GetLocation());\n            } 227597"];
5472 [label="if (block != null && expression != null)\n            {\n                diagnostics.Add(ErrorCode.ERR_BlockBodyAndExpressionBody, syntax.GetLocation());\n            } 227598"];
5473 [label="if (block != null && expression != null)\n            {\n                diagnostics.Add(ErrorCode.ERR_BlockBodyAndExpressionBody, syntax.GetLocation());\n            } 227599"];
5474 [label="if (block != null && expression != null)\n            {\n                diagnostics.Add(ErrorCode.ERR_BlockBodyAndExpressionBody, syntax.GetLocation());\n            } 227600"];
5475 [label="CheckForBlockAndExpressionBody(\n                syntax.Body, syntax.ExpressionBody, syntax, diagnostics); 227601"];
5476 [label="return new SourceConstructorSymbol(containingType, syntax.Identifier.GetLocation(), syntax, methodKind, isNullableAnalysisEnabled, diagnostics); 227602"];
5477 [label="return new SourceConstructorSymbol(containingType, syntax.Identifier.GetLocation(), syntax, methodKind, isNullableAnalysisEnabled, diagnostics); 227603"];
5478 [label="return new SourceConstructorSymbol(containingType, syntax.Identifier.GetLocation(), syntax, methodKind, isNullableAnalysisEnabled, diagnostics); 227604"];
5479 [label="return new SourceConstructorSymbol(containingType, syntax.Identifier.GetLocation(), syntax, methodKind, isNullableAnalysisEnabled, diagnostics); 227605"];
5480 [label="return new SourceConstructorSymbol(containingType, syntax.Identifier.GetLocation(), syntax, methodKind, isNullableAnalysisEnabled, diagnostics); 227606"];
5481 [label="return new SourceConstructorSymbol(containingType, syntax.Identifier.GetLocation(), syntax, methodKind, isNullableAnalysisEnabled, diagnostics); 227607"];
5482 [label="builder.NonTypeMembers.Add(constructor); 227608"];
5483 [label="if (constructorSyntax.Initializer?.Kind() != SyntaxKind.ThisConstructorInitializer)\n                            {\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: constructor.IsStatic, isNullableEnabled);\n                            } 227609"];
5484 [label="constructor.IsStatic 227610"];
5485 [label="get\n            {\n                return (this.DeclarationModifiers & DeclarationModifiers.Static) != 0;\n            } 227611"];
5486 [label="return (this.DeclarationModifiers & DeclarationModifiers.Static) != 0; 227612"];
5487 [label="return (this.DeclarationModifiers & DeclarationModifiers.Static) != 0; 227613"];
5488 [label="builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: constructor.IsStatic, isNullableEnabled); 227614"];
5489 [label="builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: constructor.IsStatic, isNullableEnabled); 227615"];
5490 [label="builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: constructor.IsStatic, isNullableEnabled) 227616"];
5491 [label="param UpdateIsNullableEnabledForConstructorsAndFields(bool useStatic) 227617"];
5492 [label="param UpdateIsNullableEnabledForConstructorsAndFields(bool value) 227618"];
5493 [label="param UpdateIsNullableEnabledForConstructorsAndFields(this) 227619"];
5494 [label="ref bool isNullableEnabled = ref GetIsNullableEnabledForConstructorsAndFields(useStatic); 227620"];
5495 [label="GetIsNullableEnabledForConstructorsAndFields(useStatic) 227621"];
5496 [label="param GetIsNullableEnabledForConstructorsAndFields(bool useStatic) 227622"];
5497 [label="param GetIsNullableEnabledForConstructorsAndFields(this) 227623"];
5498 [label="useStatic 227624"];
5499 [label="IsNullableEnabledForInstanceConstructorsAndFields 227625"];
5500 [label="return ref useStatic ? ref IsNullableEnabledForStaticConstructorsAndFields : ref IsNullableEnabledForInstanceConstructorsAndFields; 227626"];
5501 [label="isNullableEnabled = isNullableEnabled || value; 227627"];
5502 [label="builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: constructor.IsStatic, isNullableEnabled); 227628"];
5503 [label="AddInitializers(builder.InstanceInitializers, instanceInitializers); 227629"];
5504 [label="AddInitializers(builder.InstanceInitializers, instanceInitializers); 227630"];
5505 [label="AddInitializers(builder.InstanceInitializers, instanceInitializers) 227631"];
5506 [label="param AddInitializers(ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>> allInitializers) 227632"];
5507 [label="param AddInitializers(ArrayBuilder<FieldOrPropertyInitializer>? siblingsOpt) 227633"];
5508 [label="if (siblingsOpt != null)\n            {\n                allInitializers.Add(siblingsOpt);\n            } 227634"];
5509 [label="if (siblingsOpt != null)\n            {\n                allInitializers.Add(siblingsOpt);\n            } 227635"];
5510 [label="AddInitializers(builder.InstanceInitializers, instanceInitializers); 227636"];
5511 [label="AddInitializers(builder.StaticInitializers, staticInitializers); 227637"];
5512 [label="AddInitializers(builder.StaticInitializers, staticInitializers); 227638"];
5513 [label="AddInitializers(builder.StaticInitializers, staticInitializers) 227639"];
5514 [label="param AddInitializers(ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>> allInitializers) 227640"];
5515 [label="param AddInitializers(ArrayBuilder<FieldOrPropertyInitializer>? siblingsOpt) 227641"];
5516 [label="if (siblingsOpt != null)\n            {\n                allInitializers.Add(siblingsOpt);\n            } 227642"];
5517 [label="if (siblingsOpt != null)\n            {\n                allInitializers.Add(siblingsOpt);\n            } 227643"];
5518 [label="AddInitializers(builder.StaticInitializers, staticInitializers); 227644"];
5519 [label="AddDeclaredNontypeMembers(builder, diagnostics); 227645"];
5520 [label="TypeKind 227646"];
5521 [label="get\n            {\n                return _flags.TypeKind;\n            } 227647"];
5522 [label="_flags.TypeKind 227648"];
5523 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 227649"];
5524 [label="switch (TypeKind)\n                {\n                    case TypeKind.Struct:\n                        CheckForStructBadInitializers(builder, diagnostics);\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: false, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Enum:\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: true, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Class:\n                    case TypeKind.Interface:\n                    case TypeKind.Submission:\n                        // No additional checking required.\n                        break;\n\n                    default:\n                        break;\n                } 227650"];
5525 [label="IsTupleType 227651"];
5526 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 227652"];
5527 [label="_ 227653"];
5528 [label="tupleCardinality: out _ 227654"];
5529 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 227655"];
5530 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 227656"];
5531 [label="param IsTupleTypeOfCardinality(this) 227657"];
5532 [label="IsUnboundGenericType 227658"];
5533 [label="get\n            {\n                return false;\n            } 227659"];
5534 [label="return false; 227660"];
5535 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 227661"];
5536 [label="ContainingSymbol 227662"];
5537 [label="get\n            {\n                return _containingSymbol;\n            } 227663"];
5538 [label="return _containingSymbol; 227664"];
5539 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 227665"];
5540 [label=".Kind 227666"];
5541 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 227667"];
5542 [label="return SymbolKind.Namespace; 227668"];
5543 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 227669"];
5544 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 227670"];
5545 [label="ContainingNamespace 227671"];
5546 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 227672"];
5547 [label="this.ContainingSymbol 227673"];
5548 [label="get\n            {\n                return _containingSymbol;\n            } 227674"];
5549 [label="return _containingSymbol; 227675"];
5550 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 227676"];
5551 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 227677"];
5552 [label="var ns = container as NamespaceSymbol; 227678"];
5553 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 227679"];
5554 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 227680"];
5555 [label="return ns; 227681"];
5556 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 227682"];
5557 [label="ContainingNamespace.ContainingNamespace 227683"];
5558 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 227684"];
5559 [label="this.ContainingSymbol 227685"];
5560 [label="=> _container 227686"];
5561 [label="_container 227687"];
5562 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 227688"];
5563 [label="container.ContainingSymbol 227689"];
5564 [label="get\n            {\n                return _assemblySymbol;\n            } 227690"];
5565 [label="return _assemblySymbol; 227691"];
5566 [label="get\n            {\n                return null;\n            } 227692"];
5567 [label="return null; 227693"];
5568 [label="return null; 227694"];
5569 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 227695"];
5570 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 227696"];
5571 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 227697"];
5572 [label="tupleCardinality = 0; 227698"];
5573 [label="return false; 227699"];
5574 [label="if (IsTupleType)\n                {\n                    builder.AddOrWrapTupleMembers(this);\n                } 227700"];
5575 [label="if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                } 227701"];
5576 [label="if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                } 227702"];
5577 [label="builder.ToReadOnlyAndFree() 227703"];
5578 [label="param ToReadOnlyAndFree(this) 227704"];
5579 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 227705"];
5580 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 227706"];
5581 [label="MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers) 227707"];
5582 [label="param ToReadOnlyAndFree(ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>> initializers) 227708"];
5583 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 227709"];
5584 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 227710"];
5585 [label="initializers.Free(); 227711"];
5586 [label="return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty; 227712"];
5587 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 227713"];
5588 [label="MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers) 227714"];
5589 [label="param ToReadOnlyAndFree(ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>> initializers) 227715"];
5590 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 227716"];
5591 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 227717"];
5592 [label="initializers.Free(); 227718"];
5593 [label="return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty; 227719"];
5594 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 227720"];
5595 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 227721"];
5596 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 227722"];
5597 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 227723"];
5598 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 227724"];
5599 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 227725"];
5600 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 227726"];
5601 [label="new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields) 227727"];
5602 [label="param DeclaredMembersAndInitializers(ImmutableArray<Symbol> nonTypeMembers) 227728"];
5603 [label="param DeclaredMembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> staticInitializers) 227729"];
5604 [label="param DeclaredMembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> instanceInitializers) 227730"];
5605 [label="param DeclaredMembersAndInitializers(bool haveIndexers) 227731"];
5606 [label="param DeclaredMembersAndInitializers(RecordDeclarationSyntax? recordDeclarationWithParameters) 227732"];
5607 [label="param DeclaredMembersAndInitializers(SynthesizedRecordConstructor? recordPrimaryConstructor) 227733"];
5608 [label="param DeclaredMembersAndInitializers(int instanceInitializersIndexForRecordDeclarationWithParameters) 227734"];
5609 [label="param DeclaredMembersAndInitializers(bool isNullableEnabledForInstanceConstructorsAndFields) 227735"];
5610 [label="param DeclaredMembersAndInitializers(bool isNullableEnabledForStaticConstructorsAndFields) 227736"];
5611 [label="param DeclaredMembersAndInitializers(this) 227737"];
5612 [label="HaveIndexers 227738"];
5613 [label="RecordDeclarationWithParameters 227739"];
5614 [label="RecordPrimaryConstructor 227740"];
5615 [label="InstanceInitializersIndexForRecordDeclarationWithParameters 227741"];
5616 [label="IsNullableEnabledForInstanceConstructorsAndFields 227742"];
5617 [label="IsNullableEnabledForStaticConstructorsAndFields 227743"];
5618 [label="Debug.Assert(!nonTypeMembers.IsDefault); 227744"];
5619 [label="Debug.Assert(!staticInitializers.IsDefault); 227745"];
5620 [label="Debug.Assert(!instanceInitializers.IsDefault); 227746"];
5621 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 227747"];
5622 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 227748"];
5623 [label="Debug.Assert(recordDeclarationWithParameters is object == recordPrimaryConstructor is object); 227749"];
5624 [label="this.NonTypeMembers 227750"];
5625 [label="this.StaticInitializers 227751"];
5626 [label="this.InstanceInitializers 227752"];
5627 [label="this.HaveIndexers 227753"];
5628 [label="this.RecordDeclarationWithParameters 227754"];
5629 [label="this.RecordPrimaryConstructor 227755"];
5630 [label="this.InstanceInitializersIndexForRecordDeclarationWithParameters 227756"];
5631 [label="this.IsNullableEnabledForInstanceConstructorsAndFields 227757"];
5632 [label="this.IsNullableEnabledForStaticConstructorsAndFields 227758"];
5633 [label="return builder.ToReadOnlyAndFree(); 227759"];
5634 [label="declaredMembersAndInitializers = buildDeclaredMembersAndInitializers(diagnostics); 227760"];
5635 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 227761"];
5636 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 227762"];
5637 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 227763"];
5638 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 227764"];
5639 [label="if (alreadyKnown != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    diagnostics.Free();\n                    return alreadyKnown;\n                } 227765"];
5640 [label="AddDeclarationDiagnostics(diagnostics); 227766"];
5641 [label="AddDeclarationDiagnostics(diagnostics) 227767"];
5642 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 227768"];
5643 [label="param AddDeclarationDiagnostics(this) 227769"];
5644 [label="ContainingSymbol 227770"];
5645 [label="get\n            {\n                return _containingSymbol;\n            } 227771"];
5646 [label="return _containingSymbol; 227772"];
5647 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 227773"];
5648 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 227774"];
5649 [label="AddDeclarationDiagnostics(diagnostics); 227775"];
5650 [label="diagnostics.Free(); 227776"];
5651 [label="return declaredMembersAndInitializers!; 227777"];
5652 [label="var declaredMembersAndInitializers = getDeclaredMembersAndInitializers(); 227778"];
5653 [label="if (declaredMembersAndInitializers is null)\n            {\n                // Another thread completed the work before this one\n                return null;\n            } 227779"];
5654 [label="var membersAndInitializersBuilder = new MembersAndInitializersBuilder(declaredMembersAndInitializers); 227780"];
5655 [label="var membersAndInitializersBuilder = new MembersAndInitializersBuilder(declaredMembersAndInitializers); 227781"];
5656 [label="new MembersAndInitializersBuilder(declaredMembersAndInitializers) 227782"];
5657 [label="param MembersAndInitializersBuilder(DeclaredMembersAndInitializers declaredMembersAndInitializers) 227783"];
5658 [label="param MembersAndInitializersBuilder(this) 227784"];
5659 [label="NonTypeMembers 227785"];
5660 [label="InstanceInitializersForPositionalMembers 227786"];
5661 [label="IsNullableEnabledForInstanceConstructorsAndFields 227787"];
5662 [label="IsNullableEnabledForStaticConstructorsAndFields 227788"];
5663 [label="Debug.Assert(declaredMembersAndInitializers != DeclaredMembersAndInitializers.UninitializedSentinel); 227789"];
5664 [label="this.IsNullableEnabledForInstanceConstructorsAndFields 227790"];
5665 [label="this.IsNullableEnabledForStaticConstructorsAndFields 227791"];
5666 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 227792"];
5667 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 227793"];
5668 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 227794"];
5669 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics) 227795"];
5670 [label="param AddSynthesizedMembers(MembersAndInitializersBuilder builder) 227796"];
5671 [label="param AddSynthesizedMembers(DeclaredMembersAndInitializers declaredMembersAndInitializers) 227797"];
5672 [label="param AddSynthesizedMembers(DiagnosticBag diagnostics) 227798"];
5673 [label="param AddSynthesizedMembers(this) 227799"];
5674 [label="TypeKind 227800"];
5675 [label="get\n            {\n                return _flags.TypeKind;\n            } 227801"];
5676 [label="_flags.TypeKind 227802"];
5677 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 227803"];
5678 [label="switch (TypeKind)\n            {\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                case TypeKind.Class:\n                case TypeKind.Interface:\n                case TypeKind.Submission:\n                    AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics);\n                    AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics);\n                    break;\n\n                default:\n                    break;\n            } 227804"];
5679 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 227805"];
5680 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 227806"];
5681 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 227807"];
5682 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics) 227808"];
5683 [label="param AddSynthesizedRecordMembersIfNecessary(MembersAndInitializersBuilder builder) 227809"];
5684 [label="param AddSynthesizedRecordMembersIfNecessary(DeclaredMembersAndInitializers declaredMembersAndInitializers) 227810"];
5685 [label="param AddSynthesizedRecordMembersIfNecessary(DiagnosticBag diagnostics) 227811"];
5686 [label="param AddSynthesizedRecordMembersIfNecessary(this) 227812"];
5687 [label="if (declaration.Kind != DeclarationKind.Record)\n            {\n                return;\n            } 227813"];
5688 [label="return; 227814"];
5689 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 227815"];
5690 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 227816"];
5691 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 227817"];
5692 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 227818"];
5693 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics) 227819"];
5694 [label="param AddSynthesizedConstructorsIfNecessary(MembersAndInitializersBuilder builder) 227820"];
5695 [label="param AddSynthesizedConstructorsIfNecessary(DeclaredMembersAndInitializers declaredMembersAndInitializers) 227821"];
5696 [label="param AddSynthesizedConstructorsIfNecessary(DiagnosticBag diagnostics) 227822"];
5697 [label="param AddSynthesizedConstructorsIfNecessary(this) 227823"];
5698 [label="var hasInstanceConstructor = false; 227824"];
5699 [label="var hasParameterlessInstanceConstructor = false; 227825"];
5700 [label="var hasStaticConstructor = false; 227826"];
5701 [label="var membersSoFar = builder.GetNonTypeMembers(declaredMembersAndInitializers); 227827"];
5702 [label="builder.GetNonTypeMembers(declaredMembersAndInitializers) 227828"];
5703 [label="param GetNonTypeMembers(DeclaredMembersAndInitializers declaredMembers) 227829"];
5704 [label="param GetNonTypeMembers(this) 227830"];
5705 [label="return NonTypeMembers ?? (IReadOnlyCollection<Symbol>)declaredMembers.NonTypeMembers; 227831"];
5706 [label="return NonTypeMembers ?? (IReadOnlyCollection<Symbol>)declaredMembers.NonTypeMembers; 227832"];
5707 [label="foreach (var member in membersSoFar)\n            {\n                if (member.Kind == SymbolKind.Method)\n                {\n                    var method = (MethodSymbol)member;\n                    switch (method.MethodKind)\n                    {\n                        case MethodKind.Constructor:\n                            // Ignore the record copy constructor\n                            if (!IsRecord ||\n                                !(SynthesizedRecordCopyCtor.HasCopyConstructorSignature(method) && method is not SynthesizedRecordConstructor))\n                            {\n                                hasInstanceConstructor = true;\n                                hasParameterlessInstanceConstructor = hasParameterlessInstanceConstructor || method.ParameterCount == 0;\n                            }\n                            break;\n\n                        case MethodKind.StaticConstructor:\n                            hasStaticConstructor = true;\n                            break;\n                    }\n                }\n\n                //kick out early if we've seen everything we're looking for\n                if (hasInstanceConstructor && hasStaticConstructor)\n                {\n                    break;\n                }\n            } 227833"];
5708 [label="member.Kind 227834"];
5709 [label="get\n            {\n                return SymbolKind.Field;\n            } 227835"];
5710 [label="return SymbolKind.Field; 227836"];
5711 [label="if (member.Kind == SymbolKind.Method)\n                {\n                    var method = (MethodSymbol)member;\n                    switch (method.MethodKind)\n                    {\n                        case MethodKind.Constructor:\n                            // Ignore the record copy constructor\n                            if (!IsRecord ||\n                                !(SynthesizedRecordCopyCtor.HasCopyConstructorSignature(method) && method is not SynthesizedRecordConstructor))\n                            {\n                                hasInstanceConstructor = true;\n                                hasParameterlessInstanceConstructor = hasParameterlessInstanceConstructor || method.ParameterCount == 0;\n                            }\n                            break;\n\n                        case MethodKind.StaticConstructor:\n                            hasStaticConstructor = true;\n                            break;\n                    }\n                } 227837"];
5712 [label="if (hasInstanceConstructor && hasStaticConstructor)\n                {\n                    break;\n                } 227838"];
5713 [label="get\n            {\n                return SymbolKind.Method;\n            } 227839"];
5714 [label="return SymbolKind.Method; 227840"];
5715 [label="if (member.Kind == SymbolKind.Method)\n                {\n                    var method = (MethodSymbol)member;\n                    switch (method.MethodKind)\n                    {\n                        case MethodKind.Constructor:\n                            // Ignore the record copy constructor\n                            if (!IsRecord ||\n                                !(SynthesizedRecordCopyCtor.HasCopyConstructorSignature(method) && method is not SynthesizedRecordConstructor))\n                            {\n                                hasInstanceConstructor = true;\n                                hasParameterlessInstanceConstructor = hasParameterlessInstanceConstructor || method.ParameterCount == 0;\n                            }\n                            break;\n\n                        case MethodKind.StaticConstructor:\n                            hasStaticConstructor = true;\n                            break;\n                    }\n                } 227841"];
5716 [label="var method = (MethodSymbol)member; 227842"];
5717 [label="method.MethodKind 227843"];
5718 [label="get\n            {\n                return this.flags.MethodKind;\n            } 227844"];
5719 [label="this.flags.MethodKind 227845"];
5720 [label="get { return (MethodKind)((_flags >> MethodKindOffset) & MethodKindMask); } 227846"];
5721 [label="return (MethodKind)((_flags >> MethodKindOffset) & MethodKindMask); 227847"];
5722 [label="return this.flags.MethodKind; 227848"];
5723 [label="switch (method.MethodKind)\n                    {\n                        case MethodKind.Constructor:\n                            // Ignore the record copy constructor\n                            if (!IsRecord ||\n                                !(SynthesizedRecordCopyCtor.HasCopyConstructorSignature(method) && method is not SynthesizedRecordConstructor))\n                            {\n                                hasInstanceConstructor = true;\n                                hasParameterlessInstanceConstructor = hasParameterlessInstanceConstructor || method.ParameterCount == 0;\n                            }\n                            break;\n\n                        case MethodKind.StaticConstructor:\n                            hasStaticConstructor = true;\n                            break;\n                    } 227849"];
5724 [label="IsRecord 227850"];
5725 [label="get\n            {\n                return this.declaration.Declarations[0].Kind == DeclarationKind.Record;\n            } 227851"];
5726 [label="if (!IsRecord ||\n                                !(SynthesizedRecordCopyCtor.HasCopyConstructorSignature(method) && method is not SynthesizedRecordConstructor))\n                            {\n                                hasInstanceConstructor = true;\n                                hasParameterlessInstanceConstructor = hasParameterlessInstanceConstructor || method.ParameterCount == 0;\n                            } 227852"];
5727 [label="hasInstanceConstructor = true; 227853"];
5728 [label="method.ParameterCount 227854"];
5729 [label="get\n            {\n                if (!_lazyParameters.IsDefault)\n                {\n                    return _lazyParameters.Length;\n                }\n\n                return GetParameterList().ParameterCount;\n            } 227855"];
5730 [label="if (!_lazyParameters.IsDefault)\n                {\n                    return _lazyParameters.Length;\n                } 227856"];
5731 [label="GetParameterList() 227857"];
5732 [label="param GetParameterList(this) 227858"];
5733 [label="GetSyntax() 227859"];
5734 [label="param GetSyntax(this) 227860"];
5735 [label="Debug.Assert(syntaxReferenceOpt != null); 227861"];
5736 [label="Debug.Assert(syntaxReferenceOpt != null); 227862"];
5737 [label="return (ConstructorDeclarationSyntax)syntaxReferenceOpt.GetSyntax(); 227863"];
5738 [label="return (ConstructorDeclarationSyntax)syntaxReferenceOpt.GetSyntax(); 227864"];
5739 [label="return GetSyntax().ParameterList; 227865"];
5740 [label="return GetParameterList().ParameterCount; 227866"];
5741 [label="hasParameterlessInstanceConstructor = hasParameterlessInstanceConstructor || method.ParameterCount == 0; 227867"];
5742 [label="hasParameterlessInstanceConstructor = hasParameterlessInstanceConstructor || method.ParameterCount == 0; 227868"];
5743 [label="hasParameterlessInstanceConstructor = hasParameterlessInstanceConstructor || method.ParameterCount == 0; 227869"];
5744 [label="if (hasInstanceConstructor && hasStaticConstructor)\n                {\n                    break;\n                } 227870"];
5745 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 227871"];
5746 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 227872"];
5747 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 227873"];
5748 [label="if (!hasStaticConstructor && hasNonConstantInitializer(declaredMembersAndInitializers.StaticInitializers))\n            {\n                // Note: we don't have to put anything in the method - the binder will\n                // do that when processing field initializers.\n                builder.AddNonTypeMember(new SynthesizedStaticConstructor(this), declaredMembersAndInitializers);\n            } 227874"];
5749 [label="hasNonConstantInitializer(declaredMembersAndInitializers.StaticInitializers) 227875"];
5750 [label="static bool hasNonConstantInitializer(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> initializers)\n            {\n                return initializers.Any(siblings => siblings.Any(initializer => !initializer.FieldOpt.IsConst));\n            } 227876"];
5751 [label="return initializers.Any(siblings => siblings.Any(initializer => !initializer.FieldOpt.IsConst)); 227877"];
5752 [label="return initializers.Any(siblings => siblings.Any(initializer => !initializer.FieldOpt.IsConst)); 227878"];
5753 [label="if (!hasStaticConstructor && hasNonConstantInitializer(declaredMembersAndInitializers.StaticInitializers))\n            {\n                // Note: we don't have to put anything in the method - the binder will\n                // do that when processing field initializers.\n                builder.AddNonTypeMember(new SynthesizedStaticConstructor(this), declaredMembersAndInitializers);\n            } 227879"];
5754 [label="this.IsScriptClass 227880"];
5755 [label="get\n            {\n                var kind = this.declaration.Declarations[0].Kind;\n                return kind == DeclarationKind.Script || kind == DeclarationKind.Submission;\n            } 227881"];
5756 [label="var kind = this.declaration.Declarations[0].Kind; 227882"];
5757 [label="return kind == DeclarationKind.Script || kind == DeclarationKind.Submission; 227883"];
5758 [label="if (this.IsScriptClass)\n            {\n                var scriptInitializer = new SynthesizedInteractiveInitializerMethod(this, diagnostics);\n                builder.AddNonTypeMember(scriptInitializer, declaredMembersAndInitializers);\n                var scriptEntryPoint = SynthesizedEntryPointSymbol.Create(scriptInitializer, diagnostics);\n                builder.AddNonTypeMember(scriptEntryPoint, declaredMembersAndInitializers);\n            } 227884"];
5759 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 227885"];
5760 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 227886"];
5761 [label="if (Volatile.Read(ref _lazyMembersAndInitializers) != null)\n            {\n                // Another thread completed the work before this one\n                membersAndInitializersBuilder.Free();\n                return null;\n            } 227887"];
5762 [label="if (Volatile.Read(ref _lazyMembersAndInitializers) != null)\n            {\n                // Another thread completed the work before this one\n                membersAndInitializersBuilder.Free();\n                return null;\n            } 227888"];
5763 [label="return membersAndInitializersBuilder.ToReadOnlyAndFree(declaredMembersAndInitializers); 227889"];
5764 [label="membersAndInitializersBuilder.ToReadOnlyAndFree(declaredMembersAndInitializers) 227890"];
5765 [label="param ToReadOnlyAndFree(DeclaredMembersAndInitializers declaredMembers) 227891"];
5766 [label="param ToReadOnlyAndFree(this) 227892"];
5767 [label="var nonTypeMembers = NonTypeMembers?.ToImmutableAndFree() ?? declaredMembers.NonTypeMembers; 227893"];
5768 [label="var nonTypeMembers = NonTypeMembers?.ToImmutableAndFree() ?? declaredMembers.NonTypeMembers; 227894"];
5769 [label="var nonTypeMembers = NonTypeMembers?.ToImmutableAndFree() ?? declaredMembers.NonTypeMembers; 227895"];
5770 [label="var instanceInitializers = InstanceInitializersForPositionalMembers is null\n                    ? declaredMembers.InstanceInitializers\n                    : mergeInitializers(); 227896"];
5771 [label="InstanceInitializersForPositionalMembers is null 227897"];
5772 [label="declaredMembers.InstanceInitializers 227898"];
5773 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 227899"];
5774 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 227900"];
5775 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 227901"];
5776 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 227902"];
5777 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 227903"];
5778 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 227904"];
5779 [label="new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields) 227905"];
5780 [label="param MembersAndInitializers(ImmutableArray<Symbol> nonTypeMembers) 227906"];
5781 [label="param MembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> staticInitializers) 227907"];
5782 [label="param MembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> instanceInitializers) 227908"];
5783 [label="param MembersAndInitializers(bool haveIndexers) 227909"];
5784 [label="param MembersAndInitializers(bool isNullableEnabledForInstanceConstructorsAndFields) 227910"];
5785 [label="param MembersAndInitializers(bool isNullableEnabledForStaticConstructorsAndFields) 227911"];
5786 [label="param MembersAndInitializers(this) 227912"];
5787 [label="HaveIndexers 227913"];
5788 [label="IsNullableEnabledForInstanceConstructorsAndFields 227914"];
5789 [label="IsNullableEnabledForStaticConstructorsAndFields 227915"];
5790 [label="Debug.Assert(!nonTypeMembers.IsDefault); 227916"];
5791 [label="Debug.Assert(!staticInitializers.IsDefault); 227917"];
5792 [label="Debug.Assert(staticInitializers.All(g => !g.IsDefault)); 227918"];
5793 [label="Debug.Assert(staticInitializers.All(g => !g.IsDefault)); 227919"];
5794 [label="Debug.Assert(staticInitializers.All(g => !g.IsDefault)); 227920"];
5795 [label="Debug.Assert(!instanceInitializers.IsDefault); 227921"];
5796 [label="Debug.Assert(instanceInitializers.All(g => !g.IsDefault)); 227922"];
5797 [label="Debug.Assert(instanceInitializers.All(g => !g.IsDefault)); 227923"];
5798 [label="Debug.Assert(instanceInitializers.All(g => !g.IsDefault)); 227924"];
5799 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 227925"];
5800 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 227926"];
5801 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 227927"];
5802 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 227928"];
5803 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 227929"];
5804 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 227930"];
5805 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 227931"];
5806 [label="param IsIndexer(this Symbol symbol) 227932"];
5807 [label="symbol.Kind 227933"];
5808 [label="get\n            {\n                return SymbolKind.Field;\n            } 227934"];
5809 [label="return SymbolKind.Field; 227935"];
5810 [label="return symbol.Kind == SymbolKind.Property && ((PropertySymbol)symbol).IsIndexer; 227936"];
5811 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 227937"];
5812 [label="get\n            {\n                return SymbolKind.Method;\n            } 227938"];
5813 [label="return SymbolKind.Method; 227939"];
5814 [label="return symbol.Kind == SymbolKind.Property && ((PropertySymbol)symbol).IsIndexer; 227940"];
5815 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 227941"];
5816 [label="this.NonTypeMembers 227942"];
5817 [label="this.StaticInitializers 227943"];
5818 [label="this.InstanceInitializers 227944"];
5819 [label="this.HaveIndexers 227945"];
5820 [label="this.IsNullableEnabledForInstanceConstructorsAndFields 227946"];
5821 [label="this.IsNullableEnabledForStaticConstructorsAndFields 227947"];
5822 [label="return membersAndInitializersBuilder.ToReadOnlyAndFree(declaredMembersAndInitializers); 227948"];
5823 [label="membersAndInitializers = BuildMembersAndInitializers(diagnostics); 227949"];
5824 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 227950"];
5825 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 227951"];
5826 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 227952"];
5827 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 227953"];
5828 [label="if (alreadyKnown != null)\n            {\n                diagnostics.Free();\n                return alreadyKnown;\n            } 227954"];
5829 [label="if (alreadyKnown != null)\n            {\n                diagnostics.Free();\n                return alreadyKnown;\n            } 227955"];
5830 [label="AddDeclarationDiagnostics(diagnostics); 227956"];
5831 [label="AddDeclarationDiagnostics(diagnostics) 227957"];
5832 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 227958"];
5833 [label="param AddDeclarationDiagnostics(this) 227959"];
5834 [label="ContainingSymbol 227960"];
5835 [label="get\n            {\n                return _containingSymbol;\n            } 227961"];
5836 [label="return _containingSymbol; 227962"];
5837 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 227963"];
5838 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 227964"];
5839 [label="AddDeclarationDiagnostics(diagnostics); 227965"];
5840 [label="diagnostics.Free(); 227966"];
5841 [label="_lazyDeclaredMembersAndInitializers = null; 227967"];
5842 [label="_lazyDeclaredMembersAndInitializers 227968"];
5843 [label="return membersAndInitializers!; 227969"];
5844 [label="var membersAndInitializers = GetMembersAndInitializers(); 227970"];
5845 [label="this.IsTupleType 227971"];
5846 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 227972"];
5847 [label="_ 227973"];
5848 [label="tupleCardinality: out _ 227974"];
5849 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 227975"];
5850 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 227976"];
5851 [label="param IsTupleTypeOfCardinality(this) 227977"];
5852 [label="IsUnboundGenericType 227978"];
5853 [label="get\n            {\n                return false;\n            } 227979"];
5854 [label="return false; 227980"];
5855 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 227981"];
5856 [label="ContainingSymbol 227982"];
5857 [label="get\n            {\n                return _containingSymbol;\n            } 227983"];
5858 [label="return _containingSymbol; 227984"];
5859 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 227985"];
5860 [label=".Kind 227986"];
5861 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 227987"];
5862 [label="return SymbolKind.Namespace; 227988"];
5863 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 227989"];
5864 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 227990"];
5865 [label="ContainingNamespace 227991"];
5866 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 227992"];
5867 [label="this.ContainingSymbol 227993"];
5868 [label="get\n            {\n                return _containingSymbol;\n            } 227994"];
5869 [label="return _containingSymbol; 227995"];
5870 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 227996"];
5871 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 227997"];
5872 [label="var ns = container as NamespaceSymbol; 227998"];
5873 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 227999"];
5874 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 228000"];
5875 [label="return ns; 228001"];
5876 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 228002"];
5877 [label="ContainingNamespace.ContainingNamespace 228003"];
5878 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 228004"];
5879 [label="this.ContainingSymbol 228005"];
5880 [label="=> _container 228006"];
5881 [label="_container 228007"];
5882 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 228008"];
5883 [label="container.ContainingSymbol 228009"];
5884 [label="get\n            {\n                return _assemblySymbol;\n            } 228010"];
5885 [label="return _assemblySymbol; 228011"];
5886 [label="get\n            {\n                return null;\n            } 228012"];
5887 [label="return null; 228013"];
5888 [label="return null; 228014"];
5889 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 228015"];
5890 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 228016"];
5891 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 228017"];
5892 [label="tupleCardinality = 0; 228018"];
5893 [label="return false; 228019"];
5894 [label="if (!membersAndInitializers.HaveIndexers && !this.IsTupleType && _lazyEarlyAttributeDecodingMembersDictionary is object)\n            {\n                membersByName = _lazyEarlyAttributeDecodingMembersDictionary;\n            }\n            else\n            {\n                membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance);\n\n                // Merge types into the member dictionary\n                AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary());\n            } 228020"];
5895 [label="if (!membersAndInitializers.HaveIndexers && !this.IsTupleType && _lazyEarlyAttributeDecodingMembersDictionary is object)\n            {\n                membersByName = _lazyEarlyAttributeDecodingMembersDictionary;\n            }\n            else\n            {\n                membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance);\n\n                // Merge types into the member dictionary\n                AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary());\n            } 228021"];
5896 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 228022"];
5897 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 228023"];
5898 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 228024"];
5899 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 228025"];
5900 [label="get\n            {\n                return _name;\n            } 228026"];
5901 [label="return _name; 228027"];
5902 [label="get { return this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName; } 228028"];
5903 [label="this.IsStatic 228029"];
5904 [label="get\n            {\n                return (this.DeclarationModifiers & DeclarationModifiers.Static) != 0;\n            } 228030"];
5905 [label="return (this.DeclarationModifiers & DeclarationModifiers.Static) != 0; 228031"];
5906 [label="return this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName; 228032"];
5907 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()); 228033"];
5908 [label="GetTypeMembersDictionary() 228034"];
5909 [label="param GetTypeMembersDictionary(this) 228035"];
5910 [label="if (_lazyTypeMembers == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                }\n\n                diagnostics.Free();\n            } 228036"];
5911 [label="if (_lazyTypeMembers == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                }\n\n                diagnostics.Free();\n            } 228037"];
5912 [label="var diagnostics = DiagnosticBag.GetInstance(); 228038"];
5913 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 228039"];
5914 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 228040"];
5915 [label="MakeTypeMembers(diagnostics) 228041"];
5916 [label="param MakeTypeMembers(DiagnosticBag diagnostics) 228042"];
5917 [label="param MakeTypeMembers(this) 228043"];
5918 [label="var symbols = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 228044"];
5919 [label="var conflictDict = new Dictionary<(string, int), SourceNamedTypeSymbol>(); 228045"];
5920 [label="foreach (var childDeclaration in declaration.Children)\n                {\n                    var t = new SourceNamedTypeSymbol(this, childDeclaration, diagnostics);\n                    this.CheckMemberNameDistinctFromType(t, diagnostics);\n\n                    var key = (t.Name, t.Arity);\n                    SourceNamedTypeSymbol? other;\n                    if (conflictDict.TryGetValue(key, out other))\n                    {\n                        if (Locations.Length == 1 || IsPartial)\n                        {\n                            if (t.IsPartial && other.IsPartial)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, t.Locations[0], t);\n                            }\n                            else\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, t.Locations[0], this, t.Name);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        conflictDict.Add(key, t);\n                    }\n\n                    symbols.Add(t);\n                } 228046"];
5921 [label="IsInterface 228047"];
5922 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 228048"];
5923 [label="if (IsInterface)\n                {\n                    foreach (var t in symbols)\n                    {\n                        Binder.CheckFeatureAvailability(t.DeclaringSyntaxReferences[0].GetSyntax(), MessageID.IDS_DefaultInterfaceImplementation, diagnostics, t.Locations[0]);\n                    }\n                } 228049"];
5924 [label="Debug.Assert(s_emptyTypeMembers.Count == 0); 228050"];
5925 [label="Debug.Assert(s_emptyTypeMembers.Count == 0); 228051"];
5926 [label="return symbols.Count > 0 ?\n                    symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance) :\n                    s_emptyTypeMembers; 228052"];
5927 [label="return symbols.Count > 0 ?\n                    symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance) :\n                    s_emptyTypeMembers; 228053"];
5928 [label="symbols.Count > 0 228054"];
5929 [label="return symbols.Count > 0 ?\n                    symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance) :\n                    s_emptyTypeMembers; 228055"];
5930 [label="symbols.Free(); 228056"];
5931 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 228057"];
5932 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 228058"];
5933 [label="AddDeclarationDiagnostics(diagnostics); 228059"];
5934 [label="AddDeclarationDiagnostics(diagnostics) 228060"];
5935 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 228061"];
5936 [label="param AddDeclarationDiagnostics(this) 228062"];
5937 [label="ContainingSymbol 228063"];
5938 [label="get\n            {\n                return _containingSymbol;\n            } 228064"];
5939 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 228065"];
5940 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 228066"];
5941 [label="AddDeclarationDiagnostics(diagnostics); 228067"];
5942 [label="state.NotePartComplete(CompletionPart.TypeMembers); 228068"];
5943 [label="state.NotePartComplete(CompletionPart.TypeMembers) 228069"];
5944 [label="param NotePartComplete(CompletionPart part) 228070"];
5945 [label="diagnostics.Free(); 228071"];
5946 [label="return _lazyTypeMembers; 228072"];
5947 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()); 228073"];
5948 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()) 228074"];
5949 [label="param AddNestedTypesToDictionary(Dictionary<string, ImmutableArray<Symbol>> membersByName) 228075"];
5950 [label="param AddNestedTypesToDictionary(Dictionary<string, ImmutableArray<NamedTypeSymbol>> typesByName) 228076"];
5951 [label="foreach (var pair in typesByName)\n            {\n                string name = pair.Key;\n                ImmutableArray<NamedTypeSymbol> types = pair.Value;\n                ImmutableArray<Symbol> typesAsSymbols = StaticCast<Symbol>.From(types);\n\n                ImmutableArray<Symbol> membersForName;\n                if (membersByName.TryGetValue(name, out membersForName))\n                {\n                    membersByName[name] = membersForName.Concat(typesAsSymbols);\n                }\n                else\n                {\n                    membersByName.Add(name, typesAsSymbols);\n                }\n            } 228077"];
5952 [label="foreach (var pair in typesByName)\n            {\n                string name = pair.Key;\n                ImmutableArray<NamedTypeSymbol> types = pair.Value;\n                ImmutableArray<Symbol> typesAsSymbols = StaticCast<Symbol>.From(types);\n\n                ImmutableArray<Symbol> membersForName;\n                if (membersByName.TryGetValue(name, out membersForName))\n                {\n                    membersByName[name] = membersForName.Concat(typesAsSymbols);\n                }\n                else\n                {\n                    membersByName.Add(name, typesAsSymbols);\n                }\n            } 228078"];
5953 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()); 228079"];
5954 [label="MergePartialMembers(ref membersByName, diagnostics); 228080"];
5955 [label="MergePartialMembers(ref membersByName, diagnostics); 228081"];
5956 [label="MergePartialMembers(ref membersByName, diagnostics) 228082"];
5957 [label="param MergePartialMembers(ref Dictionary<string, ImmutableArray<Symbol>> membersByName) 228083"];
5958 [label="param MergePartialMembers(DiagnosticBag diagnostics) 228084"];
5959 [label="param MergePartialMembers(this) 228085"];
5960 [label="var memberNames = ArrayBuilder<string>.GetInstance(membersByName.Count); 228086"];
5961 [label="memberNames.AddRange(membersByName.Keys); 228087"];
5962 [label="memberNames.AddRange(membersByName.Keys); 228088"];
5963 [label="var methodsBySignature = new Dictionary<MethodSymbol, SourceMemberMethodSymbol>(MemberSignatureComparer.PartialMethodsComparer); 228089"];
5964 [label="foreach (var name in memberNames)\n            {\n                methodsBySignature.Clear();\n                foreach (var symbol in membersByName[name])\n                {\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    }\n\n                    if (methodsBySignature.TryGetValue(method, out var prev))\n                    {\n                        var prevPart = (SourceOrdinaryMethodSymbol)prev;\n                        var methodPart = (SourceOrdinaryMethodSymbol)method;\n\n                        if (methodPart.IsPartialImplementation &&\n                            (prevPart.IsPartialImplementation || (prevPart.OtherPartOfPartial is MethodSymbol otherImplementation && (object)otherImplementation != methodPart)))\n                        {\n                            // A partial method may not have multiple implementing declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneActual, methodPart.Locations[0]);\n                        }\n                        else if (methodPart.IsPartialDefinition &&\n                                 (prevPart.IsPartialDefinition || (prevPart.OtherPartOfPartial is MethodSymbol otherDefinition && (object)otherDefinition != methodPart)))\n                        {\n                            // A partial method may not have multiple defining declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneLatent, methodPart.Locations[0]);\n                        }\n                        else\n                        {\n                            if ((object)membersByName == _lazyEarlyAttributeDecodingMembersDictionary)\n                            {\n                                // Avoid mutating the cached dictionary and especially avoid doing this possibly on multiple threads in parallel.\n                                membersByName = new Dictionary<string, ImmutableArray<Symbol>>(membersByName);\n                            }\n\n                            membersByName[name] = FixPartialMember(membersByName[name], prevPart, methodPart);\n                        }\n                    }\n                    else\n                    {\n                        methodsBySignature.Add(method, method);\n                    }\n                }\n\n                foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                }\n            } 228090"];
5965 [label="foreach (var name in memberNames)\n            {\n                methodsBySignature.Clear();\n                foreach (var symbol in membersByName[name])\n                {\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    }\n\n                    if (methodsBySignature.TryGetValue(method, out var prev))\n                    {\n                        var prevPart = (SourceOrdinaryMethodSymbol)prev;\n                        var methodPart = (SourceOrdinaryMethodSymbol)method;\n\n                        if (methodPart.IsPartialImplementation &&\n                            (prevPart.IsPartialImplementation || (prevPart.OtherPartOfPartial is MethodSymbol otherImplementation && (object)otherImplementation != methodPart)))\n                        {\n                            // A partial method may not have multiple implementing declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneActual, methodPart.Locations[0]);\n                        }\n                        else if (methodPart.IsPartialDefinition &&\n                                 (prevPart.IsPartialDefinition || (prevPart.OtherPartOfPartial is MethodSymbol otherDefinition && (object)otherDefinition != methodPart)))\n                        {\n                            // A partial method may not have multiple defining declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneLatent, methodPart.Locations[0]);\n                        }\n                        else\n                        {\n                            if ((object)membersByName == _lazyEarlyAttributeDecodingMembersDictionary)\n                            {\n                                // Avoid mutating the cached dictionary and especially avoid doing this possibly on multiple threads in parallel.\n                                membersByName = new Dictionary<string, ImmutableArray<Symbol>>(membersByName);\n                            }\n\n                            membersByName[name] = FixPartialMember(membersByName[name], prevPart, methodPart);\n                        }\n                    }\n                    else\n                    {\n                        methodsBySignature.Add(method, method);\n                    }\n                }\n\n                foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                }\n            } 228091"];
5966 [label="methodsBySignature.Clear(); 228092"];
5967 [label="foreach (var symbol in membersByName[name])\n                {\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    }\n\n                    if (methodsBySignature.TryGetValue(method, out var prev))\n                    {\n                        var prevPart = (SourceOrdinaryMethodSymbol)prev;\n                        var methodPart = (SourceOrdinaryMethodSymbol)method;\n\n                        if (methodPart.IsPartialImplementation &&\n                            (prevPart.IsPartialImplementation || (prevPart.OtherPartOfPartial is MethodSymbol otherImplementation && (object)otherImplementation != methodPart)))\n                        {\n                            // A partial method may not have multiple implementing declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneActual, methodPart.Locations[0]);\n                        }\n                        else if (methodPart.IsPartialDefinition &&\n                                 (prevPart.IsPartialDefinition || (prevPart.OtherPartOfPartial is MethodSymbol otherDefinition && (object)otherDefinition != methodPart)))\n                        {\n                            // A partial method may not have multiple defining declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneLatent, methodPart.Locations[0]);\n                        }\n                        else\n                        {\n                            if ((object)membersByName == _lazyEarlyAttributeDecodingMembersDictionary)\n                            {\n                                // Avoid mutating the cached dictionary and especially avoid doing this possibly on multiple threads in parallel.\n                                membersByName = new Dictionary<string, ImmutableArray<Symbol>>(membersByName);\n                            }\n\n                            membersByName[name] = FixPartialMember(membersByName[name], prevPart, methodPart);\n                        }\n                    }\n                    else\n                    {\n                        methodsBySignature.Add(method, method);\n                    }\n                } 228093"];
5968 [label="var method = symbol as SourceMemberMethodSymbol; 228094"];
5969 [label="if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    } 228095"];
5970 [label="foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                } 228096"];
5971 [label="methodsBySignature.Clear(); 228097"];
5972 [label="foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                } 228098"];
5973 [label="method.IsPartial 228099"];
5974 [label="get\n            {\n                return (this.DeclarationModifiers & DeclarationModifiers.Partial) != 0;\n            } 228100"];
5975 [label="return (this.DeclarationModifiers & DeclarationModifiers.Partial) != 0; 228101"];
5976 [label="return (this.DeclarationModifiers & DeclarationModifiers.Partial) != 0; 228102"];
5977 [label="if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    } 228103"];
5978 [label="memberNames.Free(); 228104"];
5979 [label="MergePartialMembers(ref membersByName, diagnostics); 228105"];
5980 [label="return membersByName; 228106"];
5981 [label="var membersDictionary = MakeAllMembers(diagnostics); 228107"];
5982 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 228108"];
5983 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 228109"];
5984 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 228110"];
5985 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 228111"];
5986 [label="AddDeclarationDiagnostics(diagnostics); 228112"];
5987 [label="AddDeclarationDiagnostics(diagnostics) 228113"];
5988 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 228114"];
5989 [label="param AddDeclarationDiagnostics(this) 228115"];
5990 [label="ContainingSymbol 228116"];
5991 [label="get\n            {\n                return _containingSymbol;\n            } 228117"];
5992 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 228118"];
5993 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 228119"];
5994 [label="AddDeclarationDiagnostics(diagnostics); 228120"];
5995 [label="state.NotePartComplete(CompletionPart.Members); 228121"];
5996 [label="state.NotePartComplete(CompletionPart.Members) 228122"];
5997 [label="param NotePartComplete(CompletionPart part) 228123"];
5998 [label="diagnostics.Free(); 228124"];
5999 [label="state.SpinWaitComplete(CompletionPart.Members, default(CancellationToken)); 228125"];
6000 [label="state.SpinWaitComplete(CompletionPart.Members, default(CancellationToken)); 228126"];
6001 [label="state.SpinWaitComplete(CompletionPart.Members, default(CancellationToken)) 228127"];
6002 [label="param SpinWaitComplete(CompletionPart part) 228128"];
6003 [label="param SpinWaitComplete(CancellationToken cancellationToken) 228129"];
6004 [label="param SpinWaitComplete(this) 228130"];
6005 [label="if (HasComplete(part))\n            {\n                return;\n            } 228131"];
6006 [label="HasComplete(part) 228132"];
6007 [label="param HasComplete(CompletionPart part) 228133"];
6008 [label="param HasComplete(this) 228134"];
6009 [label="return (_completeParts & (int)part) == (int)part; 228135"];
6010 [label="return; 228136"];
6011 [label="return _lazyMembersDictionary; 228137"];
6012 [label="return GetMembersByNameSlow(); 228138"];
6013 [label="result = GetMembersByName().Flatten(null); 228139"];
6014 [label="result = GetMembersByName().Flatten(null); 228140"];
6015 [label="result = GetMembersByName().Flatten(null); 228141"];
6016 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyMembersFlattened, result); 228142"];
6017 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyMembersFlattened, result); 228143"];
6018 [label="result = _lazyMembersFlattened; 228144"];
6019 [label="return result.ConditionallyDeOrder(); 228145"];
6020 [label="var allMembers = this.GetMembersUnordered(); 228146"];
6021 [label="if (allMembers.Length > 1)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyMembersFlattened, allMembers);\n                } 228147"];
6022 [label="if (allMembers.Length > 1)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyMembersFlattened, allMembers);\n                } 228148"];
6023 [label="allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance); 228149"];
6024 [label="allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance); 228150"];
6025 [label="param ==(Symbol left) 228151"];
6026 [label="param ==(Symbol right) 228152"];
6027 [label="if (right is null)\n            {\n                return left is null;\n            } 228153"];
6028 [label="return (object)left == (object)right || right.Equals(left); 228154"];
6029 [label="return (object)left == (object)right || right.Equals(left); 228155"];
6030 [label="right.Equals(left) 228156"];
6031 [label="param Equals(object obj) 228157"];
6032 [label="param Equals(this) 228158"];
6033 [label="return this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind); 228159"];
6034 [label="return this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind); 228160"];
6035 [label="this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind) 228161"];
6036 [label="param Equals(Symbol other) 228162"];
6037 [label="param Equals(TypeCompareKind compareKind) 228163"];
6038 [label="param Equals(this) 228164"];
6039 [label="if (other is SubstitutedFieldSymbol sfs)\n            {\n                return sfs.Equals(this, compareKind);\n            } 228165"];
6040 [label="return base.Equals(other, compareKind); 228166"];
6041 [label="return base.Equals(other, compareKind); 228167"];
6042 [label="base.Equals(other, compareKind) 228168"];
6043 [label="param Equals(Symbol other) 228169"];
6044 [label="param Equals(TypeCompareKind compareKind) 228170"];
6045 [label="param Equals(this) 228171"];
6046 [label="return (object)this == other; 228172"];
6047 [label="param GetLexicalSortKey(this) 228173"];
6048 [label="this.Locations 228174"];
6049 [label="get\n            {\n                return this.locations;\n            } 228175"];
6050 [label="return this.locations; 228176"];
6051 [label="var locations = this.Locations; 228177"];
6052 [label="this.DeclaringCompilation 228178"];
6053 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 228179"];
6054 [label="this.Kind 228180"];
6055 [label="get\n            {\n                return SymbolKind.Method;\n            } 228181"];
6056 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 228182"];
6057 [label="get\n            {\n                return _containingType;\n            } 228183"];
6058 [label="return _containingType; 228184"];
6059 [label="var declaringCompilation = this.DeclaringCompilation; 228185"];
6060 [label="Debug.Assert(declaringCompilation != null); 228186"];
6061 [label="Debug.Assert(declaringCompilation != null); 228187"];
6062 [label="return (locations.Length > 0) ? new LexicalSortKey(locations[0], declaringCompilation) : LexicalSortKey.NotInSource; 228188"];
6063 [label="return (locations.Length > 0) ? new LexicalSortKey(locations[0], declaringCompilation) : LexicalSortKey.NotInSource; 228189"];
6064 [label="(locations.Length > 0) 228190"];
6065 [label="return (locations.Length > 0) ? new LexicalSortKey(locations[0], declaringCompilation) : LexicalSortKey.NotInSource; 228191"];
6066 [label="new LexicalSortKey(locations[0], declaringCompilation) 228192"];
6067 [label="param LexicalSortKey(Location location) 228193"];
6068 [label="param LexicalSortKey(CSharpCompilation compilation) 228194"];
6069 [label="param LexicalSortKey(this) 228195"];
6070 [label="location.SourceTree 228196"];
6071 [label="location.SourceSpan.Start 228197"];
6072 [label="compilation 228198"];
6073 [label="param LexicalSortKey(this) 228199"];
6074 [label="param LexicalSortKey(SyntaxTree tree) 228200"];
6075 [label="param LexicalSortKey(int position) 228201"];
6076 [label="param LexicalSortKey(CSharpCompilation compilation) 228202"];
6077 [label="param LexicalSortKey(this) 228203"];
6078 [label="null 228204"];
6079 [label="tree == null 228205"];
6080 [label="tree 228206"];
6081 [label="compilation.GetSyntaxTreeOrdinal(tree) 228207"];
6082 [label="param GetSyntaxTreeOrdinal(SyntaxTree tree) 228208"];
6083 [label="param GetSyntaxTreeOrdinal(this) 228209"];
6084 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 228210"];
6085 [label="position 228211"];
6086 [label="param LexicalSortKey(int treeOrdinal) 228212"];
6087 [label="param LexicalSortKey(int position) 228213"];
6088 [label="param LexicalSortKey(this) 228214"];
6089 [label="Debug.Assert(position >= 0); 228215"];
6090 [label="Debug.Assert(position >= 0); 228216"];
6091 [label="Debug.Assert(treeOrdinal >= 0); 228217"];
6092 [label="Debug.Assert(treeOrdinal >= 0); 228218"];
6093 [label="_treeOrdinal 228219"];
6094 [label="_position 228220"];
6095 [label="allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance); 228221"];
6096 [label="param GetLexicalSortKey(this) 228222"];
6097 [label="return new LexicalSortKey(_location, this.DeclaringCompilation); 228223"];
6098 [label="this.DeclaringCompilation 228224"];
6099 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 228225"];
6100 [label="this.Kind 228226"];
6101 [label="get\n            {\n                return SymbolKind.Field;\n            } 228227"];
6102 [label="return SymbolKind.Field; 228228"];
6103 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 228229"];
6104 [label="get\n            {\n                return containingType;\n            } 228230"];
6105 [label="return containingType; 228231"];
6106 [label="return new LexicalSortKey(_location, this.DeclaringCompilation); 228232"];
6107 [label="return new LexicalSortKey(_location, this.DeclaringCompilation); 228233"];
6108 [label="new LexicalSortKey(_location, this.DeclaringCompilation) 228234"];
6109 [label="param LexicalSortKey(Location location) 228235"];
6110 [label="param LexicalSortKey(CSharpCompilation compilation) 228236"];
6111 [label="param LexicalSortKey(this) 228237"];
6112 [label="param LexicalSortKey(this) 228238"];
6113 [label="param LexicalSortKey(this) 228239"];
6114 [label="null 228240"];
6115 [label="param LexicalSortKey(this) 228241"];
6116 [label="Debug.Assert(position >= 0); 228242"];
6117 [label="Debug.Assert(position >= 0); 228243"];
6118 [label="Debug.Assert(treeOrdinal >= 0); 228244"];
6119 [label="Debug.Assert(treeOrdinal >= 0); 228245"];
6120 [label="this.Kind 228246"];
6121 [label="get\n            {\n                return SymbolKind.Method;\n            } 228247"];
6122 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 228248"];
6123 [label="get\n            {\n                return _containingType;\n            } 228249"];
6124 [label="get\n            {\n                return SymbolKind.Field;\n            } 228250"];
6125 [label="return SymbolKind.Field; 228251"];
6126 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 228252"];
6127 [label="get\n            {\n                return containingType;\n            } 228253"];
6128 [label="param Compare(LexicalSortKey xSortKey) 228254"];
6129 [label="param Compare(LexicalSortKey ySortKey) 228255"];
6130 [label="int comparison; 228256"];
6131 [label="xSortKey.TreeOrdinal 228257"];
6132 [label="get { return _treeOrdinal; } 228258"];
6133 [label="return _treeOrdinal; 228259"];
6134 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 228260"];
6135 [label="ySortKey.TreeOrdinal 228261"];
6136 [label="get { return _treeOrdinal; } 228262"];
6137 [label="return _treeOrdinal; 228263"];
6138 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 228264"];
6139 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 228265"];
6140 [label="xSortKey.Position 228266"];
6141 [label="get { return _position; } 228267"];
6142 [label="return _position; 228268"];
6143 [label="return xSortKey.Position - ySortKey.Position; 228269"];
6144 [label="ySortKey.Position 228270"];
6145 [label="get { return _position; } 228271"];
6146 [label="return _position; 228272"];
6147 [label="return xSortKey.Position - ySortKey.Position; 228273"];
6148 [label="return xSortKey.Position - ySortKey.Position; 228274"];
6149 [label="param Equals(Symbol other) 228275"];
6150 [label="param Equals(TypeCompareKind compareKind) 228276"];
6151 [label="param Equals(this) 228277"];
6152 [label="if (other is SubstitutedMethodSymbol sms)\n            {\n                return sms.Equals(this, compareKind);\n            } 228278"];
6153 [label="if (other is NativeIntegerMethodSymbol nms)\n            {\n                return nms.Equals(this, compareKind);\n            } 228279"];
6154 [label="return base.Equals(other, compareKind); 228280"];
6155 [label="return base.Equals(other, compareKind); 228281"];
6156 [label="base.Equals(other, compareKind) 228282"];
6157 [label="param Equals(Symbol other) 228283"];
6158 [label="param Equals(TypeCompareKind compareKind) 228284"];
6159 [label="param Equals(this) 228285"];
6160 [label="return (object)this == other; 228286"];
6161 [label="allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance); 228287"];
6162 [label="Debug.Assert(position >= 0); 228288"];
6163 [label="Debug.Assert(treeOrdinal >= 0); 228289"];
6164 [label="Debug.Assert(declaringCompilation != null); 228290"];
6165 [label="Debug.Assert(position >= 0); 228291"];
6166 [label="Debug.Assert(treeOrdinal >= 0); 228292"];
6167 [label="return _treeOrdinal; 228293"];
6168 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 228294"];
6169 [label="return _treeOrdinal; 228295"];
6170 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 228296"];
6171 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 228297"];
6172 [label="ImmutableInterlocked.InterlockedExchange(ref _lazyMembersFlattened, allMembers); 228298"];
6173 [label="ImmutableInterlocked.InterlockedExchange(ref _lazyMembersFlattened, allMembers); 228299"];
6174 [label="_flags.SetFlattenedMembersIsSorted() 228300"];
6175 [label="param SetFlattenedMembersIsSorted(this) 228301"];
6176 [label="ThreadSafeFlagOperations.Set(ref _flags, (FlattenedMembersIsSortedBit)); 228302"];
6177 [label="ThreadSafeFlagOperations.Set(ref _flags, (FlattenedMembersIsSortedBit)); 228303"];
6178 [label="_flags.SetFlattenedMembersIsSorted(); 228304"];
6179 [label="return allMembers; 228305"];
6180 [label="var sym1 = (classTest.GetMembers().First() as FieldSymbol).Type; 228306"];
6181 [label="var sym1 = (classTest.GetMembers().First() as FieldSymbol).Type; 228307"];
6182 [label="(classTest.GetMembers().First() as FieldSymbol).Type 228308"];
6183 [label="=> TypeWithAnnotations.Type 228309"];
6184 [label="TypeWithAnnotations 228310"];
6185 [label="get\n            {\n                return GetFieldType(ConsList<FieldSymbol>.Empty);\n            } 228311"];
6186 [label="return GetFieldType(ConsList<FieldSymbol>.Empty); 228312"];
6187 [label="GetFieldType(ConsList<FieldSymbol>.Empty) 228313"];
6188 [label="param GetFieldType(ConsList<FieldSymbol> fieldsBeingBound) 228314"];
6189 [label="param GetFieldType(this) 228315"];
6190 [label="Debug.Assert(fieldsBeingBound != null); 228316"];
6191 [label="Debug.Assert(fieldsBeingBound != null); 228317"];
6192 [label="if (_lazyType != null)\n            {\n                return _lazyType.Value;\n            } 228318"];
6193 [label="if (_lazyType != null)\n            {\n                return _lazyType.Value;\n            } 228319"];
6194 [label="VariableDeclaratorNode 228320"];
6195 [label="get\n            {\n                return (VariableDeclaratorSyntax)this.SyntaxNode;\n            } 228321"];
6196 [label="this.SyntaxNode 228322"];
6197 [label="get\n            {\n                return (CSharpSyntaxNode)_syntaxReference.GetSyntax();\n            } 228323"];
6198 [label="return (CSharpSyntaxNode)_syntaxReference.GetSyntax(); 228324"];
6199 [label="return (CSharpSyntaxNode)_syntaxReference.GetSyntax(); 228325"];
6200 [label="return (VariableDeclaratorSyntax)this.SyntaxNode; 228326"];
6201 [label="var declarator = VariableDeclaratorNode; 228327"];
6202 [label="var fieldSyntax = GetFieldDeclaration(declarator); 228328"];
6203 [label="GetFieldDeclaration(declarator) 228329"];
6204 [label="param GetFieldDeclaration(CSharpSyntaxNode declarator) 228330"];
6205 [label="return (BaseFieldDeclarationSyntax)declarator.Parent.Parent; 228331"];
6206 [label="var typeSyntax = fieldSyntax.Declaration.Type; 228332"];
6207 [label="this.DeclaringCompilation 228333"];
6208 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 228334"];
6209 [label="this.Kind 228335"];
6210 [label="get\n            {\n                return SymbolKind.Field;\n            } 228336"];
6211 [label="return SymbolKind.Field; 228337"];
6212 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 228338"];
6213 [label="this.ContainingModule 228339"];
6214 [label="this.ContainingSymbol 228340"];
6215 [label="return containingType; 228341"];
6216 [label="return (object)container != null ? container.ContainingModule : null; 228342"];
6217 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 228343"];
6218 [label="var compilation = this.DeclaringCompilation; 228344"];
6219 [label="var diagnostics = DiagnosticBag.GetInstance(); 228345"];
6220 [label="TypeWithAnnotations type; 228346"];
6221 [label="type 228347"];
6222 [label="DiagnosticBag diagnosticsForFirstDeclarator = DiagnosticBag.GetInstance(); 228348"];
6223 [label="this.AssociatedSymbol 228349"];
6224 [label="get\n            {\n                return null;\n            } 228350"];
6225 [label="return null; 228351"];
6226 [label="Symbol associatedPropertyOrEvent = this.AssociatedSymbol; 228352"];
6227 [label="if ((object)associatedPropertyOrEvent != null && associatedPropertyOrEvent.Kind == SymbolKind.Event)\n            {\n                EventSymbol @event = (EventSymbol)associatedPropertyOrEvent;\n                if (@event.IsWindowsRuntimeEvent)\n                {\n                    NamedTypeSymbol tokenTableType = this.DeclaringCompilation.GetWellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T);\n                    Binder.ReportUseSiteDiagnostics(tokenTableType, diagnosticsForFirstDeclarator, this.ErrorLocation);\n\n                    // CONSIDER: Do we want to guard against the possibility that someone has created their own EventRegistrationTokenTable<T>\n                    // type that has additional generic constraints?\n                    type = TypeWithAnnotations.Create(tokenTableType.Construct(ImmutableArray.Create(@event.TypeWithAnnotations)));\n                }\n                else\n                {\n                    type = @event.TypeWithAnnotations;\n                }\n            }\n            else\n            {\n                var binderFactory = compilation.GetBinderFactory(SyntaxTree);\n                var binder = binderFactory.GetBinder(typeSyntax);\n\n                binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this);\n                if (!ContainingType.IsScriptClass)\n                {\n                    type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator);\n                }\n                else\n                {\n                    bool isVar;\n                    type = binder.BindTypeOrVarKeyword(typeSyntax, diagnostics, out isVar);\n\n                    Debug.Assert(type.HasType || isVar);\n\n                    if (isVar)\n                    {\n                        if (this.IsConst)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableCannotBeConst, typeSyntax.Location);\n                        }\n\n                        if (fieldsBeingBound.ContainsReference(this))\n                        {\n                            diagnostics.Add(ErrorCode.ERR_RecursivelyTypedVariable, this.ErrorLocation, this);\n                            type = default;\n                        }\n                        else if (fieldSyntax.Declaration.Variables.Count > 1)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, typeSyntax.Location);\n                        }\n                        else if (this.IsConst && this.ContainingType.IsScriptClass)\n                        {\n                            // For const var in script, we won't try to bind the initializer (case below), as it can lead to an unbound recursion\n                            type = default;\n                        }\n                        else\n                        {\n                            fieldsBeingBound = new ConsList<FieldSymbol>(this, fieldsBeingBound);\n\n                            var initializerBinder = new ImplicitlyTypedFieldBinder(binder, fieldsBeingBound);\n                            var initializerOpt = initializerBinder.BindInferredVariableInitializer(diagnostics, RefKind.None, (EqualsValueClauseSyntax)declarator.Initializer, declarator);\n\n                            if (initializerOpt != null)\n                            {\n                                if ((object)initializerOpt.Type != null && !initializerOpt.Type.IsErrorType())\n                                {\n                                    type = TypeWithAnnotations.Create(initializerOpt.Type);\n                                }\n\n                                _lazyFieldTypeInferred = 1;\n                            }\n                        }\n\n                        if (!type.HasType)\n                        {\n                            type = TypeWithAnnotations.Create(binder.CreateErrorType('var'));\n                        }\n                    }\n                }\n\n                if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                }\n            } 228353"];
6228 [label="if ((object)associatedPropertyOrEvent != null && associatedPropertyOrEvent.Kind == SymbolKind.Event)\n            {\n                EventSymbol @event = (EventSymbol)associatedPropertyOrEvent;\n                if (@event.IsWindowsRuntimeEvent)\n                {\n                    NamedTypeSymbol tokenTableType = this.DeclaringCompilation.GetWellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T);\n                    Binder.ReportUseSiteDiagnostics(tokenTableType, diagnosticsForFirstDeclarator, this.ErrorLocation);\n\n                    // CONSIDER: Do we want to guard against the possibility that someone has created their own EventRegistrationTokenTable<T>\n                    // type that has additional generic constraints?\n                    type = TypeWithAnnotations.Create(tokenTableType.Construct(ImmutableArray.Create(@event.TypeWithAnnotations)));\n                }\n                else\n                {\n                    type = @event.TypeWithAnnotations;\n                }\n            }\n            else\n            {\n                var binderFactory = compilation.GetBinderFactory(SyntaxTree);\n                var binder = binderFactory.GetBinder(typeSyntax);\n\n                binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this);\n                if (!ContainingType.IsScriptClass)\n                {\n                    type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator);\n                }\n                else\n                {\n                    bool isVar;\n                    type = binder.BindTypeOrVarKeyword(typeSyntax, diagnostics, out isVar);\n\n                    Debug.Assert(type.HasType || isVar);\n\n                    if (isVar)\n                    {\n                        if (this.IsConst)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableCannotBeConst, typeSyntax.Location);\n                        }\n\n                        if (fieldsBeingBound.ContainsReference(this))\n                        {\n                            diagnostics.Add(ErrorCode.ERR_RecursivelyTypedVariable, this.ErrorLocation, this);\n                            type = default;\n                        }\n                        else if (fieldSyntax.Declaration.Variables.Count > 1)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, typeSyntax.Location);\n                        }\n                        else if (this.IsConst && this.ContainingType.IsScriptClass)\n                        {\n                            // For const var in script, we won't try to bind the initializer (case below), as it can lead to an unbound recursion\n                            type = default;\n                        }\n                        else\n                        {\n                            fieldsBeingBound = new ConsList<FieldSymbol>(this, fieldsBeingBound);\n\n                            var initializerBinder = new ImplicitlyTypedFieldBinder(binder, fieldsBeingBound);\n                            var initializerOpt = initializerBinder.BindInferredVariableInitializer(diagnostics, RefKind.None, (EqualsValueClauseSyntax)declarator.Initializer, declarator);\n\n                            if (initializerOpt != null)\n                            {\n                                if ((object)initializerOpt.Type != null && !initializerOpt.Type.IsErrorType())\n                                {\n                                    type = TypeWithAnnotations.Create(initializerOpt.Type);\n                                }\n\n                                _lazyFieldTypeInferred = 1;\n                            }\n                        }\n\n                        if (!type.HasType)\n                        {\n                            type = TypeWithAnnotations.Create(binder.CreateErrorType('var'));\n                        }\n                    }\n                }\n\n                if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                }\n            } 228354"];
6229 [label="SyntaxTree 228355"];
6230 [label="get\n            {\n                return _syntaxReference.SyntaxTree;\n            } 228356"];
6231 [label="return _syntaxReference.SyntaxTree; 228357"];
6232 [label="var binderFactory = compilation.GetBinderFactory(SyntaxTree); 228358"];
6233 [label="var binderFactory = compilation.GetBinderFactory(SyntaxTree); 228359"];
6234 [label="compilation.GetBinderFactory(SyntaxTree) 228360"];
6235 [label="param GetBinderFactory(SyntaxTree syntaxTree) 228361"];
6236 [label="param GetBinderFactory(bool ignoreAccessibility = false) 228362"];
6237 [label="param GetBinderFactory(this) 228363"];
6238 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 228364"];
6239 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 228365"];
6240 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 228366"];
6241 [label="param GetBinderFactory(bool ignoreAccessibility) 228367"];
6242 [label="ignoreAccessibility 228368"];
6243 [label="GetSyntaxTreeOrdinal(syntaxTree) 228369"];
6244 [label="this.ContainsSyntaxTree(tree) 228370"];
6245 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 228371"];
6246 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 228372"];
6247 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 228373"];
6248 [label="BinderFactory? previousFactory; 228374"];
6249 [label="var previousWeakReference = binderFactories[treeNum]; 228375"];
6250 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 228376"];
6251 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 228377"];
6252 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 228378"];
6253 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 228379"];
6254 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 228380"];
6255 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 228381"];
6256 [label="param AddNewFactory(bool ignoreAccessibility) 228382"];
6257 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 228383"];
6258 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 228384"];
6259 [label="new BinderFactory(this, syntaxTree, ignoreAccessibility) 228385"];
6260 [label="param BinderFactory(bool ignoreAccessibility) 228386"];
6261 [label="param BinderFactory(this) 228387"];
6262 [label="_binderCache 228388"];
6263 [label="_compilation 228389"];
6264 [label="_syntaxTree 228390"];
6265 [label="_buckStopsHereBinder 228391"];
6266 [label="_ignoreAccessibility 228392"];
6267 [label="_binderFactoryVisitorPool 228393"];
6268 [label="_ignoreAccessibility 228394"];
6269 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 228395"];
6270 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 228396"];
6271 [label="_binderCache = new ConcurrentCache<BinderCacheKey, Binder>(50); 228397"];
6272 [label="_binderCache 228398"];
6273 [label="_buckStopsHereBinder = new BuckStopsHereBinder(compilation); 228399"];
6274 [label="new BuckStopsHereBinder(compilation) 228400"];
6275 [label="param BuckStopsHereBinder(this) 228401"];
6276 [label="param BuckStopsHereBinder(this) 228402"];
6277 [label="param Binder(this) 228403"];
6278 [label="internal CSharpCompilation Compilation { get; } 228404"];
6279 [label="Flags 228405"];
6280 [label="protected internal Binder? Next { get; } 228406"];
6281 [label="_lazyConversions 228407"];
6282 [label="_lazyOverloadResolution 228408"];
6283 [label="RoslynDebug.Assert(compilation != null); 228409"];
6284 [label="RoslynDebug.Assert(compilation != null); 228410"];
6285 [label="RoslynDebug.Assert(this is BuckStopsHereBinder); 228411"];
6286 [label="RoslynDebug.Assert(this is BuckStopsHereBinder); 228412"];
6287 [label="compilation.Options 228413"];
6288 [label="_buckStopsHereBinder 228414"];
6289 [label="var newWeakReference = new WeakReference<BinderFactory>(newFactory); 228415"];
6290 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 228416"];
6291 [label="BinderFactory? previousFactory; 228417"];
6292 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 228418"];
6293 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 228419"];
6294 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 228420"];
6295 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 228421"];
6296 [label="var binder = binderFactory.GetBinder(typeSyntax); 228422"];
6297 [label="var binder = binderFactory.GetBinder(typeSyntax); 228423"];
6298 [label="binderFactory.GetBinder(typeSyntax) 228424"];
6299 [label="param GetBinder(SyntaxNode node) 228425"];
6300 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 228426"];
6301 [label="param GetBinder(Symbol memberOpt = null) 228427"];
6302 [label="param GetBinder(this) 228428"];
6303 [label="int position = node.SpanStart; 228429"];
6304 [label="InScript 228430"];
6305 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 228431"];
6306 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 228432"];
6307 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 228433"];
6308 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 228434"];
6309 [label="GetBinder(node, position, memberDeclarationOpt, memberOpt) 228435"];
6310 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 228436"];
6311 [label="param GetBinder(Symbol memberOpt = null) 228437"];
6312 [label="Debug.Assert(node != null); 228438"];
6313 [label="Debug.Assert(node != null); 228439"];
6314 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 228440"];
6315 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 228441"];
6316 [label="param BinderFactoryVisitor(this) 228442"];
6317 [label="_position 228443"];
6318 [label="_memberDeclarationOpt 228444"];
6319 [label="_memberOpt 228445"];
6320 [label="_factory 228446"];
6321 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 228447"];
6322 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 228448"];
6323 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt) 228449"];
6324 [label="param Initialize(CSharpSyntaxNode memberDeclarationOpt) 228450"];
6325 [label="param Initialize(Symbol memberOpt) 228451"];
6326 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 228452"];
6327 [label="memberDeclarationOpt == null 228453"];
6328 [label="param ==(Symbol left) 228454"];
6329 [label="param ==(Symbol right) 228455"];
6330 [label="if (right is null)\n            {\n                return left is null;\n            } 228456"];
6331 [label="return left is null; 228457"];
6332 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 228458"];
6333 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 228459"];
6334 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 228460"];
6335 [label="_memberDeclarationOpt 228461"];
6336 [label="_memberOpt 228462"];
6337 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 228463"];
6338 [label="visitor.Visit(node) 228464"];
6339 [label="VisitCore(node) 228465"];
6340 [label="return ((CSharpSyntaxNode)node).Accept(this); 228466"];
6341 [label="param DefaultVisit(SyntaxNode parent) 228467"];
6342 [label="param DefaultVisit(this) 228468"];
6343 [label="return VisitCore(parent.Parent); 228469"];
6344 [label="VisitCore(parent.Parent) 228470"];
6345 [label="param VisitCore(SyntaxNode node) 228471"];
6346 [label="param VisitCore(this) 228472"];
6347 [label="return ((CSharpSyntaxNode)node).Accept(this); 228473"];
6348 [label="param VisitFieldDeclaration(FieldDeclarationSyntax parent) 228474"];
6349 [label="param VisitFieldDeclaration(this) 228475"];
6350 [label="return VisitCore(parent.Parent).WithUnsafeRegionIfNecessary(parent.Modifiers); 228476"];
6351 [label="VisitCore(parent.Parent) 228477"];
6352 [label="param VisitCore(SyntaxNode node) 228478"];
6353 [label="param VisitCore(this) 228479"];
6354 [label="return ((CSharpSyntaxNode)node).Accept(this); 228480"];
6355 [label="VisitTypeDeclarationCore(node) 228481"];
6356 [label="NodeUsage extraInfo = NodeUsage.Normal; 228482"];
6357 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 228483"];
6358 [label="VisitTypeDeclarationCore(parent, extraInfo) 228484"];
6359 [label="CreateBinderCacheKey(parent, extraInfo) 228485"];
6360 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 228486"];
6361 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 228487"];
6362 [label="return new BinderCacheKey(node, usage); 228488"];
6363 [label="new BinderCacheKey(node, usage) 228489"];
6364 [label="param BinderCacheKey(this) 228490"];
6365 [label="var key = CreateBinderCacheKey(parent, extraInfo); 228491"];
6366 [label="Binder resultBinder; 228492"];
6367 [label="binderCache 228493"];
6368 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 228494"];
6369 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 228495"];
6370 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 228496"];
6371 [label="SyntaxToken token; 228497"];
6372 [label="token 228498"];
6373 [label="syntaxTree 228499"];
6374 [label="get\n                {\n                    return _factory._syntaxTree;\n                } 228500"];
6375 [label="return _factory._syntaxTree; 228501"];
6376 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 228502"];
6377 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 228503"];
6378 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 228504"];
6379 [label="RoslynDebug.Assert(next != null); 228505"];
6380 [label="_container 228506"];
6381 [label="Debug.Assert((object)container != null); 228507"];
6382 [label="Debug.Assert(declarationSyntax != null); 228508"];
6383 [label="param GetSimpleProgramEntryPoint(CompilationUnitSyntax compilationUnit) 228509"];
6384 [label="param GetSimpleProgramEntryPoint(bool fallbackToMainEntryPoint) 228510"];
6385 [label="GetBoundReferenceManager(); 228511"];
6386 [label="if (type is null)\n            {\n                return null;\n            } 228512"];
6387 [label="return null; 228513"];
6388 [label="Debug.Assert(compilation != null); 228514"];
6389 [label="this.Kind 228515"];
6390 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 228516"];
6391 [label="return SymbolKind.Namespace; 228517"];
6392 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 228518"];
6393 [label="Debug.Assert((object)container != null || imports != null); 228519"];
6394 [label="if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            } 228520"];
6395 [label="VisitCore(parent.Parent).WithUnsafeRegionIfNecessary(parent.Modifiers) 228521"];
6396 [label="param WithUnsafeRegionIfNecessary(SyntaxTokenList modifiers) 228522"];
6397 [label="param WithUnsafeRegionIfNecessary(this) 228523"];
6398 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 228524"];
6399 [label="this.Flags.Includes(BinderFlags.UnsafeRegion) 228525"];
6400 [label="param Includes(BinderFlags other) 228526"];
6401 [label="return result; 228527"];
6402 [label="binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 228528"];
6403 [label="binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 228529"];
6404 [label="binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this) 228530"];
6405 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags flags) 228531"];
6406 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(Symbol containing) 228532"];
6407 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(this) 228533"];
6408 [label="Debug.Assert((object)containing != null); 228534"];
6409 [label="Debug.Assert((object)containing != null); 228535"];
6410 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 228536"];
6411 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 228537"];
6412 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 228538"];
6413 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 228539"];
6414 [label="new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing) 228540"];
6415 [label="param BinderWithContainingMemberOrLambda(Binder next) 228541"];
6416 [label="param BinderWithContainingMemberOrLambda(BinderFlags flags) 228542"];
6417 [label="param BinderWithContainingMemberOrLambda(Symbol containingMemberOrLambda) 228543"];
6418 [label="param BinderWithContainingMemberOrLambda(this) 228544"];
6419 [label="next 228545"];
6420 [label="flags 228546"];
6421 [label="param BinderWithContainingMemberOrLambda(this) 228547"];
6422 [label="param Binder(Binder next) 228548"];
6423 [label="param Binder(BinderFlags flags) 228549"];
6424 [label="param Binder(this) 228550"];
6425 [label="internal CSharpCompilation Compilation { get; } 228551"];
6426 [label="Flags 228552"];
6427 [label="protected internal Binder? Next { get; } 228553"];
6428 [label="_lazyConversions 228554"];
6429 [label="_lazyOverloadResolution 228555"];
6430 [label="RoslynDebug.Assert(next != null); 228556"];
6431 [label="RoslynDebug.Assert(next != null); 228557"];
6432 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion)); 228558"];
6433 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion)); 228559"];
6434 [label="flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion) 228560"];
6435 [label="param Includes(this BinderFlags self) 228561"];
6436 [label="param Includes(BinderFlags other) 228562"];
6437 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.InNestedFinallyBlock) || flags.Includes(BinderFlags.InFinallyBlock | BinderFlags.InCatchBlock)); 228563"];
6438 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.InNestedFinallyBlock) || flags.Includes(BinderFlags.InFinallyBlock | BinderFlags.InCatchBlock)); 228564"];
6439 [label="flags.Includes(BinderFlags.InNestedFinallyBlock) 228565"];
6440 [label="param Includes(this BinderFlags self) 228566"];
6441 [label="param Includes(BinderFlags other) 228567"];
6442 [label="Next 228568"];
6443 [label="this.Flags 228569"];
6444 [label="this.Compilation 228570"];
6445 [label="_containingMemberOrLambda 228571"];
6446 [label="Debug.Assert(containingMemberOrLambda != null); 228572"];
6447 [label="containingMemberOrLambda != null 228573"];
6448 [label="param !=(Symbol left) 228574"];
6449 [label="param !=(Symbol right) 228575"];
6450 [label="if (right is null)\n            {\n                return left is object;\n            } 228576"];
6451 [label="return left is object; 228577"];
6452 [label="Debug.Assert(containingMemberOrLambda != null); 228578"];
6453 [label="_containingMemberOrLambda 228579"];
6454 [label="binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 228580"];
6455 [label="ContainingType 228581"];
6456 [label="get\n            {\n                return this.containingType;\n            } 228582"];
6457 [label="return this.containingType; 228583"];
6458 [label="if (!ContainingType.IsScriptClass)\n                {\n                    type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator);\n                }\n                else\n                {\n                    bool isVar;\n                    type = binder.BindTypeOrVarKeyword(typeSyntax, diagnostics, out isVar);\n\n                    Debug.Assert(type.HasType || isVar);\n\n                    if (isVar)\n                    {\n                        if (this.IsConst)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableCannotBeConst, typeSyntax.Location);\n                        }\n\n                        if (fieldsBeingBound.ContainsReference(this))\n                        {\n                            diagnostics.Add(ErrorCode.ERR_RecursivelyTypedVariable, this.ErrorLocation, this);\n                            type = default;\n                        }\n                        else if (fieldSyntax.Declaration.Variables.Count > 1)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, typeSyntax.Location);\n                        }\n                        else if (this.IsConst && this.ContainingType.IsScriptClass)\n                        {\n                            // For const var in script, we won't try to bind the initializer (case below), as it can lead to an unbound recursion\n                            type = default;\n                        }\n                        else\n                        {\n                            fieldsBeingBound = new ConsList<FieldSymbol>(this, fieldsBeingBound);\n\n                            var initializerBinder = new ImplicitlyTypedFieldBinder(binder, fieldsBeingBound);\n                            var initializerOpt = initializerBinder.BindInferredVariableInitializer(diagnostics, RefKind.None, (EqualsValueClauseSyntax)declarator.Initializer, declarator);\n\n                            if (initializerOpt != null)\n                            {\n                                if ((object)initializerOpt.Type != null && !initializerOpt.Type.IsErrorType())\n                                {\n                                    type = TypeWithAnnotations.Create(initializerOpt.Type);\n                                }\n\n                                _lazyFieldTypeInferred = 1;\n                            }\n                        }\n\n                        if (!type.HasType)\n                        {\n                            type = TypeWithAnnotations.Create(binder.CreateErrorType('var'));\n                        }\n                    }\n                } 228584"];
6459 [label="ContainingType.IsScriptClass 228585"];
6460 [label="get\n            {\n                var kind = this.declaration.Declarations[0].Kind;\n                return kind == DeclarationKind.Script || kind == DeclarationKind.Submission;\n            } 228586"];
6461 [label="var kind = this.declaration.Declarations[0].Kind; 228587"];
6462 [label="return kind == DeclarationKind.Script || kind == DeclarationKind.Submission; 228588"];
6463 [label="type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator); 228589"];
6464 [label="type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator); 228590"];
6465 [label="type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator); 228591"];
6466 [label="binder.BindType(typeSyntax, diagnosticsForFirstDeclarator) 228592"];
6467 [label="param BindType(ExpressionSyntax syntax) 228593"];
6468 [label="param BindType(DiagnosticBag diagnostics) 228594"];
6469 [label="param BindType(ConsList<TypeSymbol> basesBeingResolved = null) 228595"];
6470 [label="param BindType(bool suppressUseSiteDiagnostics = false) 228596"];
6471 [label="param BindType(this) 228597"];
6472 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 228598"];
6473 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 228599"];
6474 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 228600"];
6475 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 228601"];
6476 [label="BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics) 228602"];
6477 [label="param BindTypeOrAlias(ExpressionSyntax syntax) 228603"];
6478 [label="param BindTypeOrAlias(DiagnosticBag diagnostics) 228604"];
6479 [label="param BindTypeOrAlias(ConsList<TypeSymbol> basesBeingResolved = null) 228605"];
6480 [label="param BindTypeOrAlias(bool suppressUseSiteDiagnostics = false) 228606"];
6481 [label="param BindTypeOrAlias(this) 228607"];
6482 [label="Debug.Assert(diagnostics != null); 228608"];
6483 [label="Debug.Assert(diagnostics != null); 228609"];
6484 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 228610"];
6485 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 228611"];
6486 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 228612"];
6487 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 228613"];
6488 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 228614"];
6489 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 228615"];
6490 [label="BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics) 228616"];
6491 [label="param BindNamespaceOrTypeOrAliasSymbol(ExpressionSyntax syntax) 228617"];
6492 [label="param BindNamespaceOrTypeOrAliasSymbol(DiagnosticBag diagnostics) 228618"];
6493 [label="param BindNamespaceOrTypeOrAliasSymbol(ConsList<TypeSymbol> basesBeingResolved) 228619"];
6494 [label="param BindNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 228620"];
6495 [label="param BindNamespaceOrTypeOrAliasSymbol(this) 228621"];
6496 [label="switch (syntax.Kind())\n            {\n                case SyntaxKind.NullableType:\n                    return bindNullable(syntax, diagnostics, basesBeingResolved);\n\n                case SyntaxKind.PredefinedType:\n                    return bindPredefined(syntax, diagnostics);\n\n                case SyntaxKind.IdentifierName:\n                    return BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt: null);\n\n                case SyntaxKind.GenericName:\n                    return BindGenericSimpleNamespaceOrTypeOrAliasSymbol((GenericNameSyntax)syntax, diagnostics, basesBeingResolved, qualifierOpt: null);\n\n                case SyntaxKind.AliasQualifiedName:\n                    return bindAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n\n                case SyntaxKind.QualifiedName:\n                    {\n                        var node = (QualifiedNameSyntax)syntax;\n                        return BindQualifiedName(node.Left, node.Right, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n                    }\n\n                case SyntaxKind.SimpleMemberAccessExpression:\n                    {\n                        var node = (MemberAccessExpressionSyntax)syntax;\n                        return BindQualifiedName(node.Expression, node.Name, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n                    }\n\n                case SyntaxKind.ArrayType:\n                    {\n                        return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true);\n                    }\n\n                case SyntaxKind.PointerType:\n                    return bindPointer(syntax, diagnostics, basesBeingResolved);\n\n                case SyntaxKind.FunctionPointerType:\n                    var functionPointerTypeSyntax = (FunctionPointerTypeSyntax)syntax;\n                    if (GetUnsafeDiagnosticInfo(sizeOfTypeOpt: null) is CSDiagnosticInfo info)\n                    {\n                        var @delegate = functionPointerTypeSyntax.DelegateKeyword;\n                        var asterisk = functionPointerTypeSyntax.AsteriskToken;\n                        RoslynDebug.Assert(@delegate.SyntaxTree is object);\n                        diagnostics.Add(info, Location.Create(@delegate.SyntaxTree, TextSpan.FromBounds(@delegate.SpanStart, asterisk.Span.End)));\n                    }\n\n                    return TypeWithAnnotations.Create(\n                        FunctionPointerTypeSymbol.CreateFromSource(\n                            functionPointerTypeSyntax,\n                            this,\n                            diagnostics,\n                            basesBeingResolved,\n                            suppressUseSiteDiagnostics));\n\n                case SyntaxKind.OmittedTypeArgument:\n                    {\n                        return BindTypeArgument((TypeSyntax)syntax, diagnostics, basesBeingResolved);\n                    }\n\n                case SyntaxKind.TupleType:\n                    {\n                        var tupleTypeSyntax = (TupleTypeSyntax)syntax;\n                        return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(tupleTypeSyntax.CloseParenToken), BindTupleType(tupleTypeSyntax, diagnostics, basesBeingResolved));\n                    }\n\n                case SyntaxKind.RefType:\n                    {\n                        // ref needs to be handled by the caller\n                        var refTypeSyntax = (RefTypeSyntax)syntax;\n                        var refToken = refTypeSyntax.RefKeyword;\n                        if (!syntax.HasErrors)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_UnexpectedToken, refToken.GetLocation(), refToken.ToString());\n                        }\n\n                        return BindNamespaceOrTypeOrAliasSymbol(refTypeSyntax.Type, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n                    }\n\n                default:\n                    {\n                        // This is invalid syntax for a type.  This arises when a constant pattern that fails to bind\n                        // is attempted to be bound as a type pattern.\n                        return createErrorType(syntax);\n                    }\n            } 228622"];
6497 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 228623"];
6498 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 228624"];
6499 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 228625"];
6500 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 228626"];
6501 [label="BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true) 228627"];
6502 [label="param BindArrayType(ArrayTypeSyntax node) 228628"];
6503 [label="param BindArrayType(DiagnosticBag diagnostics) 228629"];
6504 [label="param BindArrayType(bool permitDimensions) 228630"];
6505 [label="param BindArrayType(ConsList<TypeSymbol> basesBeingResolved) 228631"];
6506 [label="param BindArrayType(bool disallowRestrictedTypes) 228632"];
6507 [label="param BindArrayType(this) 228633"];
6508 [label="TypeWithAnnotations type = BindType(node.ElementType, diagnostics, basesBeingResolved); 228634"];
6509 [label="TypeWithAnnotations type = BindType(node.ElementType, diagnostics, basesBeingResolved); 228635"];
6510 [label="TypeWithAnnotations type = BindType(node.ElementType, diagnostics, basesBeingResolved); 228636"];
6511 [label="TypeWithAnnotations type = BindType(node.ElementType, diagnostics, basesBeingResolved); 228637"];
6512 [label="BindType(node.ElementType, diagnostics, basesBeingResolved) 228638"];
6513 [label="param BindType(ExpressionSyntax syntax) 228639"];
6514 [label="param BindType(DiagnosticBag diagnostics) 228640"];
6515 [label="param BindType(ConsList<TypeSymbol> basesBeingResolved = null) 228641"];
6516 [label="param BindType(bool suppressUseSiteDiagnostics = false) 228642"];
6517 [label="param BindType(this) 228643"];
6518 [label="param BindTypeOrAlias(bool suppressUseSiteDiagnostics = false) 228644"];
6519 [label="Debug.Assert(diagnostics != null); 228645"];
6520 [label="Debug.Assert(diagnostics != null); 228646"];
6521 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 228647"];
6522 [label="param BindNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 228648"];
6523 [label="return bindPredefined(syntax, diagnostics); 228649"];
6524 [label="return bindPredefined(syntax, diagnostics); 228650"];
6525 [label="bindPredefined(syntax, diagnostics) 228651"];
6526 [label="NamespaceOrTypeOrAliasSymbolWithAnnotations bindPredefined(ExpressionSyntax syntax, DiagnosticBag diagnostics)\n            {\n                var predefinedType = (PredefinedTypeSyntax)syntax;\n                var type = BindPredefinedTypeSymbol(predefinedType, diagnostics);\n                return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type);\n            } 228652"];
6527 [label="NamespaceOrTypeOrAliasSymbolWithAnnotations bindPredefined(ExpressionSyntax syntax, DiagnosticBag diagnostics)\n            {\n                var predefinedType = (PredefinedTypeSyntax)syntax;\n                var type = BindPredefinedTypeSymbol(predefinedType, diagnostics);\n                return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type);\n            } 228653"];
6528 [label="NamespaceOrTypeOrAliasSymbolWithAnnotations bindPredefined(ExpressionSyntax syntax, DiagnosticBag diagnostics)\n            {\n                var predefinedType = (PredefinedTypeSyntax)syntax;\n                var type = BindPredefinedTypeSymbol(predefinedType, diagnostics);\n                return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type);\n            } 228654"];
6529 [label="var predefinedType = (PredefinedTypeSyntax)syntax; 228655"];
6530 [label="var type = BindPredefinedTypeSymbol(predefinedType, diagnostics); 228656"];
6531 [label="var type = BindPredefinedTypeSymbol(predefinedType, diagnostics); 228657"];
6532 [label="BindPredefinedTypeSymbol(predefinedType, diagnostics) 228658"];
6533 [label="param BindPredefinedTypeSymbol(PredefinedTypeSyntax node) 228659"];
6534 [label="param BindPredefinedTypeSymbol(DiagnosticBag diagnostics) 228660"];
6535 [label="param BindPredefinedTypeSymbol(this) 228661"];
6536 [label="return GetSpecialType(node.Keyword.Kind().GetSpecialType(), diagnostics, node); 228662"];
6537 [label="return GetSpecialType(node.Keyword.Kind().GetSpecialType(), diagnostics, node); 228663"];
6538 [label="return GetSpecialType(node.Keyword.Kind().GetSpecialType(), diagnostics, node); 228664"];
6539 [label="GetSpecialType(node.Keyword.Kind().GetSpecialType(), diagnostics, node) 228665"];
6540 [label="param GetSpecialType(SpecialType typeId) 228666"];
6541 [label="param GetSpecialType(DiagnosticBag diagnostics) 228667"];
6542 [label="param GetSpecialType(SyntaxNode node) 228668"];
6543 [label="param GetSpecialType(this) 228669"];
6544 [label="return GetSpecialType(this.Compilation, typeId, node, diagnostics); 228670"];
6545 [label="return GetSpecialType(this.Compilation, typeId, node, diagnostics); 228671"];
6546 [label="return GetSpecialType(this.Compilation, typeId, node, diagnostics); 228672"];
6547 [label="return GetSpecialType(this.Compilation, typeId, node, diagnostics); 228673"];
6548 [label="GetSpecialType(this.Compilation, typeId, node, diagnostics) 228674"];
6549 [label="param GetSpecialType(CSharpCompilation compilation) 228675"];
6550 [label="param GetSpecialType(SpecialType typeId) 228676"];
6551 [label="param GetSpecialType(SyntaxNode node) 228677"];
6552 [label="param GetSpecialType(DiagnosticBag diagnostics) 228678"];
6553 [label="NamedTypeSymbol typeSymbol = compilation.GetSpecialType(typeId); 228679"];
6554 [label="compilation.GetSpecialType(typeId) 228680"];
6555 [label="param GetSpecialType(SpecialType specialType) 228681"];
6556 [label="param GetSpecialType(this) 228682"];
6557 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 228683"];
6558 [label="NamedTypeSymbol result; 228684"];
6559 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 228685"];
6560 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 228686"];
6561 [label="Assembly 228687"];
6562 [label="GetBoundReferenceManager(); 228688"];
6563 [label="result = Assembly.GetSpecialType(specialType); 228689"];
6564 [label="result = Assembly.GetSpecialType(specialType); 228690"];
6565 [label="Assembly.GetSpecialType(specialType) 228691"];
6566 [label="param GetSpecialType(SpecialType type) 228692"];
6567 [label="param GetSpecialType(this) 228693"];
6568 [label="CorLibrary 228694"];
6569 [label="get\n            {\n                return _corLibrary;\n            } 228695"];
6570 [label="return CorLibrary.GetDeclaredSpecialType(type); 228696"];
6571 [label="return CorLibrary.GetDeclaredSpecialType(type); 228697"];
6572 [label="CorLibrary.GetDeclaredSpecialType(type) 228698"];
6573 [label="param GetDeclaredSpecialType(SpecialType type) 228699"];
6574 [label="param GetDeclaredSpecialType(this) 228700"];
6575 [label="this.Modules 228701"];
6576 [label="get\n            {\n                return _modules;\n            } 228702"];
6577 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 228703"];
6578 [label="module.GetReferencedAssemblies() 228704"];
6579 [label="param GetReferencedAssemblies(this) 228705"];
6580 [label="AssertReferencesInitialized() 228706"];
6581 [label="param AssertReferencesInitialized(this) 228707"];
6582 [label="Debug.Assert(_moduleReferences != null); 228708"];
6583 [label="Debug.Assert(_moduleReferences != null); 228709"];
6584 [label="AssertReferencesInitialized(); 228710"];
6585 [label="return _moduleReferences.Identities; 228711"];
6586 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 228712"];
6587 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 228713"];
6588 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 228714"];
6589 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 228715"];
6590 [label="MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true); 228716"];
6591 [label="MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true); 228717"];
6592 [label="this.Modules 228718"];
6593 [label="ModuleSymbol module = this.Modules[0]; 228719"];
6594 [label="ModuleSymbol module = this.Modules[0]; 228720"];
6595 [label="NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName); 228721"];
6596 [label="module.LookupTopLevelMetadataType(ref emittedName) 228722"];
6597 [label="param LookupTopLevelMetadataType(ref MetadataTypeName emittedName) 228723"];
6598 [label="param LookupTopLevelMetadataType(this) 228724"];
6599 [label="NamedTypeSymbol result; 228725"];
6600 [label="this.GlobalNamespace 228726"];
6601 [label="get { return _globalNamespace; } 228727"];
6602 [label="NamespaceSymbol scope = this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments); 228728"];
6603 [label="NamespaceSymbol scope = this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments); 228729"];
6604 [label="this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments) 228730"];
6605 [label="param LookupNestedNamespace(ImmutableArray<string> names) 228731"];
6606 [label="param LookupNestedNamespace(this) 228732"];
6607 [label="NamespaceSymbol scope = this; 228733"];
6608 [label="foreach (string name in names)\n            {\n                NamespaceSymbol nextScope = null;\n\n                foreach (NamespaceOrTypeSymbol symbol in scope.GetMembers(name))\n                {\n                    var ns = symbol as NamespaceSymbol;\n\n                    if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    }\n                }\n\n                scope = nextScope;\n\n                if ((object)scope == null)\n                {\n                    break;\n                }\n            } 228734"];
6609 [label="NamespaceSymbol nextScope = null; 228735"];
6610 [label="foreach (NamespaceOrTypeSymbol symbol in scope.GetMembers(name))\n                {\n                    var ns = symbol as NamespaceSymbol;\n\n                    if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    }\n                } 228736"];
6611 [label="scope.GetMembers(name) 228737"];
6612 [label="param GetMembers(string name) 228738"];
6613 [label="param GetMembers(this) 228739"];
6614 [label="EnsureAllMembersLoaded() 228740"];
6615 [label="param EnsureAllMembersLoaded(this) 228741"];
6616 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups;\n\n                try\n                {\n                    groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal);\n                }\n                catch (BadImageFormatException)\n                {\n                    groups = SpecializedCollections.EmptyEnumerable<IGrouping<string, TypeDefinitionHandle>>();\n                }\n\n                LoadAllMembers(groups);\n            } 228742"];
6617 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups;\n\n                try\n                {\n                    groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal);\n                }\n                catch (BadImageFormatException)\n                {\n                    groups = SpecializedCollections.EmptyEnumerable<IGrouping<string, TypeDefinitionHandle>>();\n                }\n\n                LoadAllMembers(groups);\n            } 228743"];
6618 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 228744"];
6619 [label="_moduleSymbol.Module 228745"];
6620 [label="get\n            {\n                return _module;\n            } 228746"];
6621 [label="return _module; 228747"];
6622 [label="groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal); 228748"];
6623 [label="groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal); 228749"];
6624 [label="LoadAllMembers(groups); 228750"];
6625 [label="LoadAllMembers(groups) 228751"];
6626 [label="param LoadAllMembers(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 228752"];
6627 [label="param LoadAllMembers(this) 228753"];
6628 [label="Debug.Assert(typesByNS != null); 228754"];
6629 [label="Debug.Assert(typesByNS != null); 228755"];
6630 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> nestedTypes = null; 228756"];
6631 [label="IEnumerable<KeyValuePair<string, IEnumerable<IGrouping<string, TypeDefinitionHandle>>>> nestedNamespaces = null; 228757"];
6632 [label="this.IsGlobalNamespace 228758"];
6633 [label="get\n            {\n                return true;\n            } 228759"];
6634 [label="return true; 228760"];
6635 [label="bool isGlobalNamespace = this.IsGlobalNamespace; 228761"];
6636 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 228762"];
6637 [label="isGlobalNamespace 228763"];
6638 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 228764"];
6639 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 228765"];
6640 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 228766"];
6641 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 228767"];
6642 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 228768"];
6643 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 228769"];
6644 [label="LazyInitializeNamespaces(nestedNamespaces); 228770"];
6645 [label="LazyInitializeNamespaces(nestedNamespaces) 228771"];
6646 [label="param LazyInitializeNamespaces(IEnumerable<KeyValuePair<string, IEnumerable<IGrouping<string, TypeDefinitionHandle>>>> childNamespaces) 228772"];
6647 [label="param LazyInitializeNamespaces(this) 228773"];
6648 [label="if (this.lazyNamespaces == null)\n            {\n                var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance);\n\n                foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                }\n\n                Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null);\n            } 228774"];
6649 [label="if (this.lazyNamespaces == null)\n            {\n                var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance);\n\n                foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                }\n\n                Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null);\n            } 228775"];
6650 [label="var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance); 228776"];
6651 [label="foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                } 228777"];
6652 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 228778"];
6653 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 228779"];
6654 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 228780"];
6655 [label="new PENestedNamespaceSymbol(child.Key, this, child.Value) 228781"];
6656 [label="param PENestedNamespaceSymbol(string name) 228782"];
6657 [label="param PENestedNamespaceSymbol(PENamespaceSymbol containingNamespace) 228783"];
6658 [label="param PENestedNamespaceSymbol(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 228784"];
6659 [label="param PENestedNamespaceSymbol(this) 228785"];
6660 [label="param PENestedNamespaceSymbol(this) 228786"];
6661 [label="_containingNamespaceSymbol 228787"];
6662 [label="_name 228788"];
6663 [label="_typesByNS 228789"];
6664 [label="Debug.Assert(name != null); 228790"];
6665 [label="Debug.Assert(name != null); 228791"];
6666 [label="Debug.Assert((object)containingNamespace != null); 228792"];
6667 [label="Debug.Assert((object)containingNamespace != null); 228793"];
6668 [label="Debug.Assert(typesByNS != null); 228794"];
6669 [label="Debug.Assert(typesByNS != null); 228795"];
6670 [label="_containingNamespaceSymbol 228796"];
6671 [label="_name 228797"];
6672 [label="_typesByNS 228798"];
6673 [label="c.Name 228799"];
6674 [label="get\n            {\n                return _name;\n            } 228800"];
6675 [label="return _name; 228801"];
6676 [label="namespaces.Add(c.Name, c); 228802"];
6677 [label="namespaces.Add(c.Name, c); 228803"];
6678 [label="namespaces.Add(c.Name, c); 228804"];
6679 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 228805"];
6680 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 228806"];
6681 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 228807"];
6682 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 228808"];
6683 [label="LazyInitializeNamespaces(nestedNamespaces); 228809"];
6684 [label="LazyInitializeTypes(nestedTypes); 228810"];
6685 [label="LazyInitializeTypes(nestedTypes) 228811"];
6686 [label="param LazyInitializeTypes(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typeGroups) 228812"];
6687 [label="param LazyInitializeTypes(this) 228813"];
6688 [label="if (this.lazyTypes == null)\n            {\n                var moduleSymbol = ContainingPEModule;\n\n                var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes();\n                Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null;\n\n                foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                }\n\n                var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance);\n                children.Free();\n\n                if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                }\n\n                var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null);\n\n                // Build cache of TypeDef Tokens\n                // Potentially this can be done in the background.\n                if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n            } 228814"];
6689 [label="if (this.lazyTypes == null)\n            {\n                var moduleSymbol = ContainingPEModule;\n\n                var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes();\n                Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null;\n\n                foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                }\n\n                var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance);\n                children.Free();\n\n                if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                }\n\n                var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null);\n\n                // Build cache of TypeDef Tokens\n                // Potentially this can be done in the background.\n                if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n            } 228815"];
6690 [label="ContainingPEModule 228816"];
6691 [label="get\n            {\n                return _moduleSymbol;\n            } 228817"];
6692 [label="return _moduleSymbol; 228818"];
6693 [label="var moduleSymbol = ContainingPEModule; 228819"];
6694 [label="var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance(); 228820"];
6695 [label="moduleSymbol.Module 228821"];
6696 [label="get\n            {\n                return _module;\n            } 228822"];
6697 [label="var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes(); 228823"];
6698 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 228824"];
6699 [label="foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                } 228825"];
6700 [label="foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                } 228826"];
6701 [label="foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    } 228827"];
6702 [label="if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        } 228828"];
6703 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 228829"];
6704 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 228830"];
6705 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 228831"];
6706 [label="EmptyComparer.Instance 228832"];
6707 [label="new Dictionary<string, ImmutableArray<PENamedTypeSymbol>>(EmptyComparer.Instance) 228833"];
6708 [label="s_emptyNestedTypes = new Dictionary<string, ImmutableArray<PENamedTypeSymbol>>(EmptyComparer.Instance) 228834"];
6709 [label="new UncommonProperties() 228835"];
6710 [label="param UncommonProperties(this) 228836"];
6711 [label="lazyEnumUnderlyingType 228837"];
6712 [label="lazyObsoleteAttributeData = ObsoleteAttributeData.Uninitialized 228838"];
6713 [label="lazyAttributeUsageInfo = AttributeUsageInfo.Null 228839"];
6714 [label="lazyContainsExtensionMethods 228840"];
6715 [label="lazyIsByRefLike 228841"];
6716 [label="lazyIsReadOnly 228842"];
6717 [label="lazyDefaultMemberName 228843"];
6718 [label="lazyComImportCoClassType = ErrorTypeSymbol.UnknownResultType 228844"];
6719 [label="lazyHasEmbeddedAttribute = ThreeState.Unknown 228845"];
6720 [label="s_noUncommonProperties = new UncommonProperties() 228846"];
6721 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 228847"];
6722 [label="PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key) 228848"];
6723 [label="param Create(PEModuleSymbol moduleSymbol) 228849"];
6724 [label="param Create(PENamespaceSymbol containingNamespace) 228850"];
6725 [label="param Create(TypeDefinitionHandle handle) 228851"];
6726 [label="param Create(string emittedNamespaceName) 228852"];
6727 [label="GenericParameterHandleCollection genericParameterHandles; 228853"];
6728 [label="genericParameterHandles 228854"];
6729 [label="ushort arity; 228855"];
6730 [label="BadImageFormatException mrEx = null; 228856"];
6731 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 228857"];
6732 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 228858"];
6733 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 228859"];
6734 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 228860"];
6735 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 228861"];
6736 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx) 228862"];
6737 [label="param GetGenericInfo(PEModuleSymbol moduleSymbol) 228863"];
6738 [label="param GetGenericInfo(TypeDefinitionHandle handle) 228864"];
6739 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 228865"];
6740 [label="param GetGenericInfo(out ushort arity) 228866"];
6741 [label="param GetGenericInfo(out BadImageFormatException mrEx) 228867"];
6742 [label="moduleSymbol.Module 228868"];
6743 [label="get\n            {\n                return _module;\n            } 228869"];
6744 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 228870"];
6745 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 228871"];
6746 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 228872"];
6747 [label="arity = (ushort)genericParameterHandles.Count; 228873"];
6748 [label="mrEx = null; 228874"];
6749 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 228875"];
6750 [label="bool mangleName; 228876"];
6751 [label="PENamedTypeSymbol result; 228877"];
6752 [label="if (arity == 0)\n            {\n                result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName);\n            }\n            else\n            {\n                result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName);\n            } 228878"];
6753 [label="if (arity == 0)\n            {\n                result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName);\n            }\n            else\n            {\n                result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName);\n            } 228879"];
6754 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 228880"];
6755 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 228881"];
6756 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 228882"];
6757 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 228883"];
6758 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 228884"];
6759 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 228885"];
6760 [label="new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName) 228886"];
6761 [label="param PENamedTypeSymbolNonGeneric(PEModuleSymbol moduleSymbol) 228887"];
6762 [label="param PENamedTypeSymbolNonGeneric(NamespaceOrTypeSymbol container) 228888"];
6763 [label="param PENamedTypeSymbolNonGeneric(TypeDefinitionHandle handle) 228889"];
6764 [label="param PENamedTypeSymbolNonGeneric(string emittedNamespaceName) 228890"];
6765 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 228891"];
6766 [label="param PENamedTypeSymbolNonGeneric(this) 228892"];
6767 [label="moduleSymbol 228893"];
6768 [label="container 228894"];
6769 [label="handle 228895"];
6770 [label="emittedNamespaceName 228896"];
6771 [label="0 228897"];
6772 [label="mangleName 228898"];
6773 [label="param PENamedTypeSymbolNonGeneric(this) 228899"];
6774 [label="param PENamedTypeSymbol(PEModuleSymbol moduleSymbol) 228900"];
6775 [label="param PENamedTypeSymbol(NamespaceOrTypeSymbol container) 228901"];
6776 [label="param PENamedTypeSymbol(TypeDefinitionHandle handle) 228902"];
6777 [label="param PENamedTypeSymbol(string emittedNamespaceName) 228903"];
6778 [label="param PENamedTypeSymbol(ushort arity) 228904"];
6779 [label="param PENamedTypeSymbol(out bool mangleName) 228905"];
6780 [label="param PENamedTypeSymbol(this) 228906"];
6781 [label="param PENamedTypeSymbol(this) 228907"];
6782 [label="param NamedTypeSymbol(this) 228908"];
6783 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 228909"];
6784 [label="param NamedTypeSymbol(this) 228910"];
6785 [label="param TypeSymbol(this) 228911"];
6786 [label="param TypeSymbol(this) 228912"];
6787 [label="_lazyAbstractMembers 228913"];
6788 [label="_lazyInterfaceInfo 228914"];
6789 [label="_lazyAdapter 228915"];
6790 [label="_hasNoBaseCycles 228916"];
6791 [label="_lazyTupleData 228917"];
6792 [label="_lazyTupleData 228918"];
6793 [label="_container 228919"];
6794 [label="_name 228920"];
6795 [label="_flags 228921"];
6796 [label="_corTypeId 228922"];
6797 [label="_lazyMemberNames 228923"];
6798 [label="_lazyMembersByName 228924"];
6799 [label="_lazyNestedTypes 228925"];
6800 [label="_lazyKind 228926"];
6801 [label="_lazyNullableContextValue 228927"];
6802 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 228928"];
6803 [label="default(ImmutableArray<NamedTypeSymbol>) 228929"];
6804 [label="_lazyInterfaces = default(ImmutableArray<NamedTypeSymbol>) 228930"];
6805 [label="_lazyDeclaredBaseType = ErrorTypeSymbol.UnknownResultType 228931"];
6806 [label="default(ImmutableArray<NamedTypeSymbol>) 228932"];
6807 [label="_lazyDeclaredInterfaces = default(ImmutableArray<NamedTypeSymbol>) 228933"];
6808 [label="_lazyDocComment 228934"];
6809 [label="_lazyUseSiteDiagnostic = CSDiagnosticInfo.EmptyErrorInfo 228935"];
6810 [label="_lazyUncommonProperties 228936"];
6811 [label="public IEnumerable<object> fieldDefs { get; set; } 228937"];
6812 [label="Debug.Assert(!handle.IsNil); 228938"];
6813 [label="Debug.Assert((object)container != null); 228939"];
6814 [label="Debug.Assert((object)container != null); 228940"];
6815 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 228941"];
6816 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 228942"];
6817 [label="string metadataName; 228943"];
6818 [label="bool makeBad = false; 228944"];
6819 [label="moduleSymbol.Module 228945"];
6820 [label="get\n            {\n                return _module;\n            } 228946"];
6821 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 228947"];
6822 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 228948"];
6823 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 228949"];
6824 [label="_handle 228950"];
6825 [label="_container 228951"];
6826 [label="moduleSymbol.Module 228952"];
6827 [label="get\n            {\n                return _module;\n            } 228953"];
6828 [label="return _module; 228954"];
6829 [label="_flags = moduleSymbol.Module.GetTypeDefFlagsOrThrow(handle); 228955"];
6830 [label="_flags = moduleSymbol.Module.GetTypeDefFlagsOrThrow(handle); 228956"];
6831 [label="_flags 228957"];
6832 [label="if (arity == 0)\n            {\n                _name = metadataName;\n                mangleName = false;\n            }\n            else\n            {\n                // Unmangle name for a generic type.\n                _name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity);\n                Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName));\n                mangleName = !ReferenceEquals(_name, metadataName);\n            } 228958"];
6833 [label="if (arity == 0)\n            {\n                _name = metadataName;\n                mangleName = false;\n            }\n            else\n            {\n                // Unmangle name for a generic type.\n                _name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity);\n                Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName));\n                mangleName = !ReferenceEquals(_name, metadataName);\n            } 228959"];
6834 [label="_name 228960"];
6835 [label="mangleName = false; 228961"];
6836 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 228962"];
6837 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 228963"];
6838 [label="moduleSymbol.ContainingAssembly 228964"];
6839 [label="get\n            {\n                return _assemblySymbol;\n            } 228965"];
6840 [label="return _assemblySymbol; 228966"];
6841 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 228967"];
6842 [label="moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes 228968"];
6843 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 228969"];
6844 [label="this.CorLibrary 228970"];
6845 [label="get\n            {\n                return _corLibrary;\n            } 228971"];
6846 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 228972"];
6847 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 228973"];
6848 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 228974"];
6849 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 228975"];
6850 [label="this.DeclaredAccessibility 228976"];
6851 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 228977"];
6852 [label="Accessibility access = Accessibility.Private; 228978"];
6853 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 228979"];
6854 [label="access = Accessibility.Internal; 228980"];
6855 [label="return access; 228981"];
6856 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 228982"];
6857 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 228983"];
6858 [label="_corTypeId 228984"];
6859 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 228985"];
6860 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 228986"];
6861 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 228987"];
6862 [label="return result; 228988"];
6863 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 228989"];
6864 [label="GenericParameterHandleCollection genericParameterHandles; 228990"];
6865 [label="genericParameterHandles 228991"];
6866 [label="ushort arity; 228992"];
6867 [label="BadImageFormatException mrEx = null; 228993"];
6868 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 228994"];
6869 [label="param GetGenericInfo(out ushort arity) 228995"];
6870 [label="param GetGenericInfo(out BadImageFormatException mrEx) 228996"];
6871 [label="mrEx = null; 228997"];
6872 [label="bool mangleName; 228998"];
6873 [label="PENamedTypeSymbol result; 228999"];
6874 [label="result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName); 229000"];
6875 [label="result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName); 229001"];
6876 [label="new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName) 229002"];
6877 [label="param PENamedTypeSymbolGeneric(PEModuleSymbol moduleSymbol) 229003"];
6878 [label="param PENamedTypeSymbolGeneric(NamespaceOrTypeSymbol container) 229004"];
6879 [label="param PENamedTypeSymbolGeneric(TypeDefinitionHandle handle) 229005"];
6880 [label="param PENamedTypeSymbolGeneric(string emittedNamespaceName) 229006"];
6881 [label="param PENamedTypeSymbolGeneric(GenericParameterHandleCollection genericParameterHandles) 229007"];
6882 [label="param PENamedTypeSymbolGeneric(ushort arity) 229008"];
6883 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 229009"];
6884 [label="param PENamedTypeSymbolGeneric(this) 229010"];
6885 [label="moduleSymbol 229011"];
6886 [label="container 229012"];
6887 [label="handle 229013"];
6888 [label="emittedNamespaceName 229014"];
6889 [label="arity 229015"];
6890 [label="mangleName 229016"];
6891 [label="param PENamedTypeSymbolGeneric(this) 229017"];
6892 [label="param PENamedTypeSymbol(PEModuleSymbol moduleSymbol) 229018"];
6893 [label="param PENamedTypeSymbol(NamespaceOrTypeSymbol container) 229019"];
6894 [label="param PENamedTypeSymbol(TypeDefinitionHandle handle) 229020"];
6895 [label="param PENamedTypeSymbol(string emittedNamespaceName) 229021"];
6896 [label="param PENamedTypeSymbol(ushort arity) 229022"];
6897 [label="param PENamedTypeSymbol(out bool mangleName) 229023"];
6898 [label="_lazyTupleData 229024"];
6899 [label="_container 229025"];
6900 [label="_name 229026"];
6901 [label="_flags 229027"];
6902 [label="_corTypeId 229028"];
6903 [label="Debug.Assert(!handle.IsNil); 229029"];
6904 [label="Debug.Assert((object)container != null); 229030"];
6905 [label="Debug.Assert((object)container != null); 229031"];
6906 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 229032"];
6907 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 229033"];
6908 [label="string metadataName; 229034"];
6909 [label="bool makeBad = false; 229035"];
6910 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 229036"];
6911 [label="_name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity); 229037"];
6912 [label="_name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity); 229038"];
6913 [label="_name 229039"];
6914 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 229040"];
6915 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 229041"];
6916 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 229042"];
6917 [label="mangleName = !ReferenceEquals(_name, metadataName); 229043"];
6918 [label="mangleName = !ReferenceEquals(_name, metadataName); 229044"];
6919 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 229045"];
6920 [label="Accessibility access = Accessibility.Private; 229046"];
6921 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 229047"];
6922 [label="_arity 229048"];
6923 [label="_mangleName 229049"];
6924 [label="Debug.Assert(genericParameterHandles.Count > 0); 229050"];
6925 [label="Debug.Assert(genericParameterHandles.Count > 0); 229051"];
6926 [label="_arity 229052"];
6927 [label="_genericParameterHandles 229053"];
6928 [label="_mangleName 229054"];
6929 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 229055"];
6930 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 229056"];
6931 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 229057"];
6932 [label="GenericParameterHandleCollection genericParameterHandles; 229058"];
6933 [label="genericParameterHandles 229059"];
6934 [label="ushort arity; 229060"];
6935 [label="BadImageFormatException mrEx = null; 229061"];
6936 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 229062"];
6937 [label="param GetGenericInfo(out ushort arity) 229063"];
6938 [label="param GetGenericInfo(out BadImageFormatException mrEx) 229064"];
6939 [label="mrEx = null; 229065"];
6940 [label="bool mangleName; 229066"];
6941 [label="PENamedTypeSymbol result; 229067"];
6942 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 229068"];
6943 [label="mangleName 229069"];
6944 [label="param PENamedTypeSymbol(out bool mangleName) 229070"];
6945 [label="_lazyTupleData 229071"];
6946 [label="_container 229072"];
6947 [label="_name 229073"];
6948 [label="_flags 229074"];
6949 [label="_corTypeId 229075"];
6950 [label="Debug.Assert(!handle.IsNil); 229076"];
6951 [label="Debug.Assert((object)container != null); 229077"];
6952 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 229078"];
6953 [label="string metadataName; 229079"];
6954 [label="bool makeBad = false; 229080"];
6955 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 229081"];
6956 [label="Accessibility access = Accessibility.Private; 229082"];
6957 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 229083"];
6958 [label="_arity 229084"];
6959 [label="_mangleName 229085"];
6960 [label="Debug.Assert(genericParameterHandles.Count > 0); 229086"];
6961 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 229087"];
6962 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 229088"];
6963 [label="GenericParameterHandleCollection genericParameterHandles; 229089"];
6964 [label="genericParameterHandles 229090"];
6965 [label="ushort arity; 229091"];
6966 [label="BadImageFormatException mrEx = null; 229092"];
6967 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 229093"];
6968 [label="param GetGenericInfo(out ushort arity) 229094"];
6969 [label="param GetGenericInfo(out BadImageFormatException mrEx) 229095"];
6970 [label="mrEx = null; 229096"];
6971 [label="PENamedTypeSymbol result; 229097"];
6972 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 229098"];
6973 [label="mangleName 229099"];
6974 [label="param PENamedTypeSymbol(out bool mangleName) 229100"];
6975 [label="Debug.Assert(!handle.IsNil); 229101"];
6976 [label="mangleName = false; 229102"];
6977 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 229103"];
6978 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 229104"];
6979 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 229105"];
6980 [label="mangleName 229106"];
6981 [label="param PENamedTypeSymbol(out bool mangleName) 229107"];
6982 [label="_lazyTupleData 229108"];
6983 [label="_container 229109"];
6984 [label="_name 229110"];
6985 [label="_flags 229111"];
6986 [label="_corTypeId 229112"];
6987 [label="Debug.Assert(!handle.IsNil); 229113"];
6988 [label="Debug.Assert((object)container != null); 229114"];
6989 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 229115"];
6990 [label="string metadataName; 229116"];
6991 [label="bool makeBad = false; 229117"];
6992 [label="mangleName = false; 229118"];
6993 [label="Accessibility access = Accessibility.Private; 229119"];
6994 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 229120"];
6995 [label="genericParameterHandles 229121"];
6996 [label="ushort arity; 229122"];
6997 [label="BadImageFormatException mrEx = null; 229123"];
6998 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 229124"];
6999 [label="param GetGenericInfo(out ushort arity) 229125"];
7000 [label="param GetGenericInfo(out BadImageFormatException mrEx) 229126"];
7001 [label="mrEx = null; 229127"];
7002 [label="PENamedTypeSymbol result; 229128"];
7003 [label="Debug.Assert(!handle.IsNil); 229129"];
7004 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 229130"];
7005 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 229131"];
7006 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 229132"];
7007 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 229133"];
7008 [label="mangleName 229134"];
7009 [label="param PENamedTypeSymbol(out bool mangleName) 229135"];
7010 [label="_lazyTupleData 229136"];
7011 [label="_container 229137"];
7012 [label="_name 229138"];
7013 [label="_flags 229139"];
7014 [label="_corTypeId 229140"];
7015 [label="Debug.Assert(!handle.IsNil); 229141"];
7016 [label="Debug.Assert((object)container != null); 229142"];
7017 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 229143"];
7018 [label="string metadataName; 229144"];
7019 [label="bool makeBad = false; 229145"];
7020 [label="mangleName = false; 229146"];
7021 [label="Accessibility access = Accessibility.Private; 229147"];
7022 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 229148"];
7023 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 229149"];
7024 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 229150"];
7025 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 229151"];
7026 [label="get\n            {\n                return _name;\n            } 229152"];
7027 [label="return _name; 229153"];
7028 [label="children.Free(); 229154"];
7029 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 229155"];
7030 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 229156"];
7031 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 229157"];
7032 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 229158"];
7033 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 229159"];
7034 [label="if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 229160"];
7035 [label="if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 229161"];
7036 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 229162"];
7037 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict) 229163"];
7038 [label="param OnNewTypeDeclarationsLoaded(Dictionary<string, ImmutableArray<PENamedTypeSymbol>> typesDict) 229164"];
7039 [label="param OnNewTypeDeclarationsLoaded(this) 229165"];
7040 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 229166"];
7041 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 229167"];
7042 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 229168"];
7043 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 229169"];
7044 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 229170"];
7045 [label="foreach (var types in typesDict.Values)\n            {\n                foreach (var type in types)\n                {\n                    bool added;\n                    added = TypeHandleToTypeMap.TryAdd(type.Handle, type);\n                    Debug.Assert(added);\n\n                    // Register newly loaded COR types\n                    if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    }\n                }\n            } 229171"];
7046 [label="foreach (var type in types)\n                {\n                    bool added;\n                    added = TypeHandleToTypeMap.TryAdd(type.Handle, type);\n                    Debug.Assert(added);\n\n                    // Register newly loaded COR types\n                    if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    }\n                } 229172"];
7047 [label="bool added; 229173"];
7048 [label="type.Handle 229174"];
7049 [label="get\n            {\n                return _handle;\n            } 229175"];
7050 [label="return _handle; 229176"];
7051 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 229177"];
7052 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 229178"];
7053 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 229179"];
7054 [label="Debug.Assert(added); 229180"];
7055 [label="type.SpecialType 229181"];
7056 [label="get\n            {\n                return _corTypeId;\n            } 229182"];
7057 [label="return _corTypeId; 229183"];
7058 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 229184"];
7059 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 229185"];
7060 [label="bool added; 229186"];
7061 [label="Debug.Assert(added); 229187"];
7062 [label="type.SpecialType 229188"];
7063 [label="get\n            {\n                return _corTypeId;\n            } 229189"];
7064 [label="return _corTypeId; 229190"];
7065 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 229191"];
7066 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 229192"];
7067 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 229193"];
7068 [label="LazyInitializeTypes(nestedTypes); 229194"];
7069 [label="LoadAllMembers(groups); 229195"];
7070 [label="EnsureAllMembersLoaded(); 229196"];
7071 [label="PENestedNamespaceSymbol ns = null; 229197"];
7072 [label="ImmutableArray<PENamedTypeSymbol> t; 229198"];
7073 [label="t 229199"];
7074 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 229200"];
7075 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 229201"];
7076 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 229202"];
7077 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 229203"];
7078 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 229204"];
7079 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 229205"];
7080 [label="return ImmutableArray.Create<Symbol>(ns); 229206"];
7081 [label="var ns = symbol as NamespaceSymbol; 229207"];
7082 [label="if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    } 229208"];
7083 [label="if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    } 229209"];
7084 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 229210"];
7085 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 229211"];
7086 [label="nextScope = ns; 229212"];
7087 [label="scope = nextScope; 229213"];
7088 [label="if ((object)scope == null)\n                {\n                    break;\n                } 229214"];
7089 [label="if ((object)scope == null)\n                {\n                    break;\n                } 229215"];
7090 [label="return scope; 229216"];
7091 [label="if ((object)scope == null)\n            {\n                // We failed to locate the namespace\n                result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName);\n            }\n            else\n            {\n                result = scope.LookupMetadataType(ref emittedName);\n            } 229217"];
7092 [label="if ((object)scope == null)\n            {\n                // We failed to locate the namespace\n                result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName);\n            }\n            else\n            {\n                result = scope.LookupMetadataType(ref emittedName);\n            } 229218"];
7093 [label="result = scope.LookupMetadataType(ref emittedName); 229219"];
7094 [label="scope.LookupMetadataType(ref emittedName) 229220"];
7095 [label="param LookupMetadataType(ref MetadataTypeName emittedTypeName) 229221"];
7096 [label="param LookupMetadataType(this) 229222"];
7097 [label="Debug.Assert(!emittedTypeName.IsNull); 229223"];
7098 [label="NamespaceOrTypeSymbol scope = this; 229224"];
7099 [label="scope.Kind 229225"];
7100 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 229226"];
7101 [label="return SymbolKind.Namespace; 229227"];
7102 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 229228"];
7103 [label="NamedTypeSymbol? namedType = null; 229229"];
7104 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 229230"];
7105 [label="namespaceOrTypeMembers 229231"];
7106 [label="scope.IsNamespace 229232"];
7107 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 229233"];
7108 [label="Kind 229234"];
7109 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 229235"];
7110 [label="return SymbolKind.Namespace; 229236"];
7111 [label="return Kind == SymbolKind.Namespace; 229237"];
7112 [label="bool isTopLevel = scope.IsNamespace; 229238"];
7113 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 229239"];
7114 [label="scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) 229240"];
7115 [label="param ToDisplayString(SymbolDisplayFormat format = null) 229241"];
7116 [label="param ToDisplayString(this) 229242"];
7117 [label="ISymbol 229243"];
7118 [label="get\n            {\n                if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                }\n\n                return _lazyISymbol;\n            } 229244"];
7119 [label="if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                } 229245"];
7120 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 229246"];
7121 [label="CreateISymbol() 229247"];
7122 [label="param CreateISymbol(this) 229248"];
7123 [label="return new PublicModel.NamespaceSymbol(this); 229249"];
7124 [label="return new PublicModel.NamespaceSymbol(this); 229250"];
7125 [label="new PublicModel.NamespaceSymbol(this) 229251"];
7126 [label="param NamespaceSymbol(Symbols.NamespaceSymbol underlying) 229252"];
7127 [label="param NamespaceSymbol(this) 229253"];
7128 [label="param NamespaceSymbol(this) 229254"];
7129 [label="param NamespaceOrTypeSymbol(this) 229255"];
7130 [label="param NamespaceOrTypeSymbol(this) 229256"];
7131 [label="param Symbol(this) 229257"];
7132 [label="_underlying 229258"];
7133 [label="Debug.Assert(underlying is object); 229259"];
7134 [label="_underlying 229260"];
7135 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 229261"];
7136 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 229262"];
7137 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 229263"];
7138 [label="return _lazyISymbol; 229264"];
7139 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 229265"];
7140 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 229266"];
7141 [label="SymbolDisplay.ToDisplayString(ISymbol, format) 229267"];
7142 [label="param ToDisplayString(ISymbol symbol) 229268"];
7143 [label="param ToDisplayString(SymbolDisplayFormat? format = null) 229269"];
7144 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 229270"];
7145 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 229271"];
7146 [label="ToDisplayParts(symbol, format) 229272"];
7147 [label="param ToDisplayParts(ISymbol symbol) 229273"];
7148 [label="param ToDisplayParts(SymbolDisplayFormat? format = null) 229274"];
7149 [label="format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat; 229275"];
7150 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 229276"];
7151 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 229277"];
7152 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 229278"];
7153 [label="ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false) 229279"];
7154 [label="param ToDisplayParts(ISymbol symbol) 229280"];
7155 [label="param ToDisplayParts(SemanticModel? semanticModelOpt) 229281"];
7156 [label="param ToDisplayParts(int positionOpt) 229282"];
7157 [label="param ToDisplayParts(SymbolDisplayFormat format) 229283"];
7158 [label="param ToDisplayParts(bool minimal) 229284"];
7159 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 229285"];
7160 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 229286"];
7161 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 229287"];
7162 [label="Debug.Assert(semanticModelOpt == null); 229288"];
7163 [label="Debug.Assert(semanticModelOpt == null); 229289"];
7164 [label="Debug.Assert(positionOpt < 0); 229290"];
7165 [label="Debug.Assert(positionOpt < 0); 229291"];
7166 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 229292"];
7167 [label="var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance(); 229293"];
7168 [label="'modopt' 229294"];
7169 [label="IL_KEYWORD_MODOPT = 'modopt' 229295"];
7170 [label="'modreq' 229296"];
7171 [label="IL_KEYWORD_MODREQ = 'modreq' 229297"];
7172 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 229298"];
7173 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 229299"];
7174 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 229300"];
7175 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 229301"];
7176 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 229302"];
7177 [label="new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt) 229303"];
7178 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 229304"];
7179 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 229305"];
7180 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 229306"];
7181 [label="param SymbolDisplayVisitor(int positionOpt) 229307"];
7182 [label="param SymbolDisplayVisitor(this) 229308"];
7183 [label="builder 229309"];
7184 [label="format 229310"];
7185 [label="true 229311"];
7186 [label="semanticModelOpt 229312"];
7187 [label="positionOpt 229313"];
7188 [label="param SymbolDisplayVisitor(this) 229314"];
7189 [label="param SymbolDisplayVisitor(this) 229315"];
7190 [label="_escapeKeywordIdentifiers 229316"];
7191 [label="_lazyAliasMap 229317"];
7192 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 229318"];
7193 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 229319"];
7194 [label="_escapeKeywordIdentifiers 229320"];
7195 [label="symbol.Accept(visitor); 229321"];
7196 [label="symbol.Accept(visitor) 229322"];
7197 [label="param Accept(SymbolVisitor visitor) 229323"];
7198 [label="param Accept(this) 229324"];
7199 [label="Accept(visitor); 229325"];
7200 [label="Accept(visitor) 229326"];
7201 [label="param Accept(SymbolVisitor visitor) 229327"];
7202 [label="param Accept(this) 229328"];
7203 [label="visitor.VisitNamespace(this); 229329"];
7204 [label="visitor.VisitNamespace(this) 229330"];
7205 [label="param VisitNamespace(INamespaceSymbol symbol) 229331"];
7206 [label="param VisitNamespace(this) 229332"];
7207 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 229333"];
7208 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 229334"];
7209 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 229335"];
7210 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                var containingNamespace = symbol.ContainingNamespace;\n                if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 229336"];
7211 [label="symbol.ContainingNamespace 229337"];
7212 [label="=> UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 229338"];
7213 [label="UnderlyingSymbol 229339"];
7214 [label="=> _underlying 229340"];
7215 [label="_underlying 229341"];
7216 [label="UnderlyingSymbol.ContainingNamespace 229342"];
7217 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 229343"];
7218 [label="this.ContainingSymbol 229344"];
7219 [label="get { return _containingNamespaceSymbol; } 229345"];
7220 [label="return _containingNamespaceSymbol; 229346"];
7221 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 229347"];
7222 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 229348"];
7223 [label="var ns = container as NamespaceSymbol; 229349"];
7224 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 229350"];
7225 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 229351"];
7226 [label="return ns; 229352"];
7227 [label="UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 229353"];
7228 [label="param GetPublicSymbol(this NamespaceSymbol? symbol) 229354"];
7229 [label="return symbol.GetPublicSymbol<INamespaceSymbol>(); 229355"];
7230 [label="symbol.GetPublicSymbol<INamespaceSymbol>() 229356"];
7231 [label="param GetPublicSymbol(this Symbol? symbol) 229357"];
7232 [label=".ISymbol 229358"];
7233 [label="get\n            {\n                if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                }\n\n                return _lazyISymbol;\n            } 229359"];
7234 [label="param NamespaceOrTypeSymbol(this) 229360"];
7235 [label="param Symbol(this) 229361"];
7236 [label="_underlying 229362"];
7237 [label="Debug.Assert(underlying is object); 229363"];
7238 [label="return (TISymbol?)symbol?.ISymbol; 229364"];
7239 [label="var containingNamespace = symbol.ContainingNamespace; 229365"];
7240 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 229366"];
7241 [label="ShouldVisitNamespace(containingNamespace) 229367"];
7242 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 229368"];
7243 [label="param ShouldVisitNamespace(this) 229369"];
7244 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 229370"];
7245 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 229371"];
7246 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 229372"];
7247 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 229373"];
7248 [label="namespaceSymbol.IsGlobalNamespace 229374"];
7249 [label="=> _underlying.IsGlobalNamespace 229375"];
7250 [label="_underlying.IsGlobalNamespace 229376"];
7251 [label="get\n            {\n                return true;\n            } 229377"];
7252 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 229378"];
7253 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 229379"];
7254 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 229380"];
7255 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 229381"];
7256 [label="symbol.IsGlobalNamespace 229382"];
7257 [label="=> _underlying.IsGlobalNamespace 229383"];
7258 [label="_underlying.IsGlobalNamespace 229384"];
7259 [label="get\n            {\n                return false;\n            } 229385"];
7260 [label="return false; 229386"];
7261 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 229387"];
7262 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 229388"];
7263 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 229389"];
7264 [label="symbol.Name 229390"];
7265 [label="=> UnderlyingSymbol.Name 229391"];
7266 [label="UnderlyingSymbol 229392"];
7267 [label="=> _underlying 229393"];
7268 [label="_underlying 229394"];
7269 [label="UnderlyingSymbol.Name 229395"];
7270 [label="get\n            {\n                return _name;\n            } 229396"];
7271 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 229397"];
7272 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 229398"];
7273 [label="param CreatePart(SymbolDisplayPartKind kind) 229399"];
7274 [label="param CreatePart(ISymbol symbol) 229400"];
7275 [label="param CreatePart(string text) 229401"];
7276 [label="param CreatePart(this) 229402"];
7277 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 229403"];
7278 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 229404"];
7279 [label="(text == null) 229405"];
7280 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 229406"];
7281 [label="(_escapeKeywordIdentifiers && IsEscapable(kind)) 229407"];
7282 [label="return new SymbolDisplayPart(kind, symbol, text); 229408"];
7283 [label="return new SymbolDisplayPart(kind, symbol, text); 229409"];
7284 [label="return new SymbolDisplayPart(kind, symbol, text); 229410"];
7285 [label="return new SymbolDisplayPart(kind, symbol, text); 229411"];
7286 [label="visitor.VisitNamespace(this); 229412"];
7287 [label="Accept(visitor); 229413"];
7288 [label="symbol.Accept(visitor); 229414"];
7289 [label="return builder.ToImmutableAndFree(); 229415"];
7290 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 229416"];
7291 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 229417"];
7292 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 229418"];
7293 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 229419"];
7294 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 229420"];
7295 [label="int forcedArity = emittedTypeName.ForcedArity; 229421"];
7296 [label="if (emittedTypeName.UseCLSCompliantNameArityEncoding)\n            {\n                // Only types with arity 0 are acceptable, we already examined types with mangled names.\n                if (emittedTypeName.InferredArity > 0)\n                {\n                    goto Done;\n                }\n                else if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                }\n            } 229422"];
7297 [label="if (emittedTypeName.InferredArity > 0)\n                {\n                    goto Done;\n                }\n                else if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 229423"];
7298 [label="if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 229424"];
7299 [label="if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 229425"];
7300 [label="forcedArity = 0; 229426"];
7301 [label="namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.TypeName); 229427"];
7302 [label="scope.GetTypeMembers(emittedTypeName.TypeName) 229428"];
7303 [label="param GetTypeMembers(string name) 229429"];
7304 [label="param GetTypeMembers(this) 229430"];
7305 [label="EnsureAllMembersLoaded() 229431"];
7306 [label="param EnsureAllMembersLoaded(this) 229432"];
7307 [label="var typesByNS = _typesByNS; 229433"];
7308 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 229434"];
7309 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 229435"];
7310 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 229436"];
7311 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 229437"];
7312 [label="LoadAllMembers(typesByNS); 229438"];
7313 [label="LoadAllMembers(typesByNS) 229439"];
7314 [label="param LoadAllMembers(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 229440"];
7315 [label="Debug.Assert(typesByNS != null); 229441"];
7316 [label="Debug.Assert(typesByNS != null); 229442"];
7317 [label="get\n            {\n                return false;\n            } 229443"];
7318 [label="GetQualifiedNameLength() 229444"];
7319 [label="param GetQualifiedNameLength(this) 229445"];
7320 [label="this.Name 229446"];
7321 [label="get\n            {\n                return _name;\n            } 229447"];
7322 [label="int length = this.Name.Length; 229448"];
7323 [label="ContainingNamespace 229449"];
7324 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 229450"];
7325 [label="var parent = ContainingNamespace; 229451"];
7326 [label=".IsGlobalNamespace 229452"];
7327 [label="get\n            {\n                return true;\n            } 229453"];
7328 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 229454"];
7329 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 229455"];
7330 [label="return length; 229456"];
7331 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 229457"];
7332 [label="_containingNamespaceSymbol 229458"];
7333 [label="_name 229459"];
7334 [label="_typesByNS 229460"];
7335 [label="Debug.Assert(name != null); 229461"];
7336 [label="Debug.Assert((object)containingNamespace != null); 229462"];
7337 [label="Debug.Assert(typesByNS != null); 229463"];
7338 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 229464"];
7339 [label="_containingNamespaceSymbol.ContainingPEModule 229465"];
7340 [label="get\n            {\n                return _moduleSymbol;\n            } 229466"];
7341 [label="return _containingNamespaceSymbol.ContainingPEModule; 229467"];
7342 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 229468"];
7343 [label="genericParameterHandles 229469"];
7344 [label="BadImageFormatException mrEx = null; 229470"];
7345 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 229471"];
7346 [label="param GetGenericInfo(out ushort arity) 229472"];
7347 [label="param GetGenericInfo(out BadImageFormatException mrEx) 229473"];
7348 [label="mrEx = null; 229474"];
7349 [label="PENamedTypeSymbol result; 229475"];
7350 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 229476"];
7351 [label="mangleName 229477"];
7352 [label="param PENamedTypeSymbol(out bool mangleName) 229478"];
7353 [label="_lazyTupleData 229479"];
7354 [label="_container 229480"];
7355 [label="_name 229481"];
7356 [label="_flags 229482"];
7357 [label="_corTypeId 229483"];
7358 [label="Debug.Assert(!handle.IsNil); 229484"];
7359 [label="Debug.Assert((object)container != null); 229485"];
7360 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 229486"];
7361 [label="string metadataName; 229487"];
7362 [label="bool makeBad = false; 229488"];
7363 [label="mangleName = false; 229489"];
7364 [label="Accessibility access = Accessibility.Private; 229490"];
7365 [label="access = Accessibility.Public; 229491"];
7366 [label="_corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName)); 229492"];
7367 [label="_corTypeId 229493"];
7368 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 229494"];
7369 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 229495"];
7370 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 229496"];
7371 [label="genericParameterHandles 229497"];
7372 [label="BadImageFormatException mrEx = null; 229498"];
7373 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 229499"];
7374 [label="param GetGenericInfo(out ushort arity) 229500"];
7375 [label="param GetGenericInfo(out BadImageFormatException mrEx) 229501"];
7376 [label="mrEx = null; 229502"];
7377 [label="PENamedTypeSymbol result; 229503"];
7378 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 229504"];
7379 [label="mangleName 229505"];
7380 [label="param PENamedTypeSymbol(out bool mangleName) 229506"];
7381 [label="_lazyTupleData 229507"];
7382 [label="_container 229508"];
7383 [label="_name 229509"];
7384 [label="_flags 229510"];
7385 [label="_corTypeId 229511"];
7386 [label="Debug.Assert(!handle.IsNil); 229512"];
7387 [label="Debug.Assert((object)container != null); 229513"];
7388 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 229514"];
7389 [label="string metadataName; 229515"];
7390 [label="bool makeBad = false; 229516"];
7391 [label="mangleName = false; 229517"];
7392 [label="Accessibility access = Accessibility.Private; 229518"];
7393 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 229519"];
7394 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 229520"];
7395 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 229521"];
7396 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 229522"];
7397 [label="param GetGenericInfo(out ushort arity) 229523"];
7398 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 229524"];
7399 [label="mangleName 229525"];
7400 [label="param PENamedTypeSymbol(out bool mangleName) 229526"];
7401 [label="_lazyTupleData 229527"];
7402 [label="_container 229528"];
7403 [label="_name 229529"];
7404 [label="_flags 229530"];
7405 [label="_corTypeId 229531"];
7406 [label="Debug.Assert(!handle.IsNil); 229532"];
7407 [label="Debug.Assert((object)container != null); 229533"];
7408 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 229534"];
7409 [label="string metadataName; 229535"];
7410 [label="bool makeBad = false; 229536"];
7411 [label="mangleName = false; 229537"];
7412 [label="Accessibility access = Accessibility.Private; 229538"];
7413 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 229539"];
7414 [label="genericParameterHandles 229540"];
7415 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 229541"];
7416 [label="param GetGenericInfo(out ushort arity) 229542"];
7417 [label="param GetGenericInfo(out BadImageFormatException mrEx) 229543"];
7418 [label="mrEx = null; 229544"];
7419 [label="PENamedTypeSymbol result; 229545"];
7420 [label="Debug.Assert(!handle.IsNil); 229546"];
7421 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 229547"];
7422 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 229548"];
7423 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 229549"];
7424 [label="mangleName 229550"];
7425 [label="param PENamedTypeSymbol(out bool mangleName) 229551"];
7426 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 229552"];
7427 [label="_arity 229553"];
7428 [label="_mangleName 229554"];
7429 [label="Debug.Assert(genericParameterHandles.Count > 0); 229555"];
7430 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 229556"];
7431 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 229557"];
7432 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 229558"];
7433 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 229559"];
7434 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 229560"];
7435 [label="bool added; 229561"];
7436 [label="Debug.Assert(added); 229562"];
7437 [label="type.SpecialType 229563"];
7438 [label="get\n            {\n                return _corTypeId;\n            } 229564"];
7439 [label="return _corTypeId; 229565"];
7440 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 229566"];
7441 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 229567"];
7442 [label="_assemblySymbol.RegisterDeclaredSpecialType(type); 229568"];
7443 [label="_assemblySymbol.RegisterDeclaredSpecialType(type) 229569"];
7444 [label="param RegisterDeclaredSpecialType(NamedTypeSymbol corType) 229570"];
7445 [label="param RegisterDeclaredSpecialType(this) 229571"];
7446 [label="corType.SpecialType 229572"];
7447 [label="get\n            {\n                return _corTypeId;\n            } 229573"];
7448 [label="SpecialType typeId = corType.SpecialType; 229574"];
7449 [label="Debug.Assert(typeId != SpecialType.None); 229575"];
7450 [label="corType.ContainingAssembly 229576"];
7451 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 229577"];
7452 [label="this.ContainingSymbol 229578"];
7453 [label="get\n            {\n                return _container;\n            } 229579"];
7454 [label="return _container; 229580"];
7455 [label="var container = this.ContainingSymbol; 229581"];
7456 [label="return (object)container != null ? container.ContainingAssembly : null; 229582"];
7457 [label="return (object)container != null ? container.ContainingAssembly : null; 229583"];
7458 [label="(object)container != null 229584"];
7459 [label="container.ContainingAssembly 229585"];
7460 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 229586"];
7461 [label="ContainingPEModule 229587"];
7462 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 229588"];
7463 [label="return ContainingPEModule.ContainingAssembly; 229589"];
7464 [label="ContainingPEModule.ContainingAssembly 229590"];
7465 [label="get\n            {\n                return _assemblySymbol;\n            } 229591"];
7466 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 229592"];
7467 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 229593"];
7468 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 229594"];
7469 [label="corType.ContainingModule 229595"];
7470 [label="get\n            {\n                return ContainingPEModule;\n            } 229596"];
7471 [label="ContainingPEModule 229597"];
7472 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 229598"];
7473 [label="Symbol s = _container; 229599"];
7474 [label="s.Kind 229600"];
7475 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 229601"];
7476 [label="return SymbolKind.Namespace; 229602"];
7477 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 229603"];
7478 [label="((PENamespaceSymbol)s).ContainingPEModule 229604"];
7479 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 229605"];
7480 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 229606"];
7481 [label="return ContainingPEModule; 229607"];
7482 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 229608"];
7483 [label="corType.ContainingModule.Ordinal 229609"];
7484 [label="get\n            {\n                return _ordinal;\n            } 229610"];
7485 [label="return _ordinal; 229611"];
7486 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 229612"];
7487 [label="this.CorLibrary 229613"];
7488 [label="get\n            {\n                return _corLibrary;\n            } 229614"];
7489 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 229615"];
7490 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 229616"];
7491 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 229617"];
7492 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 229618"];
7493 [label="Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null); 229619"];
7494 [label="Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null); 229620"];
7495 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 229621"];
7496 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 229622"];
7497 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 229623"];
7498 [label="Interlocked.Increment(ref _cachedSpecialTypes); 229624"];
7499 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 229625"];
7500 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 229626"];
7501 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 229627"];
7502 [label="_assemblySymbol.RegisterDeclaredSpecialType(type); 229628"];
7503 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 229629"];
7504 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 229630"];
7505 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 229631"];
7506 [label="keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes; 229632"];
7507 [label="bool added; 229633"];
7508 [label="Debug.Assert(added); 229634"];
7509 [label="Debug.Assert(typeId != SpecialType.None); 229635"];
7510 [label="corType.ContainingAssembly 229636"];
7511 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 229637"];
7512 [label="this.ContainingSymbol 229638"];
7513 [label="get\n            {\n                return _container;\n            } 229639"];
7514 [label="return _container; 229640"];
7515 [label="var container = this.ContainingSymbol; 229641"];
7516 [label="return (object)container != null ? container.ContainingAssembly : null; 229642"];
7517 [label="return (object)container != null ? container.ContainingAssembly : null; 229643"];
7518 [label="(object)container != null 229644"];
7519 [label="container.ContainingAssembly 229645"];
7520 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 229646"];
7521 [label="ContainingPEModule 229647"];
7522 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 229648"];
7523 [label="return ContainingPEModule.ContainingAssembly; 229649"];
7524 [label="ContainingPEModule.ContainingAssembly 229650"];
7525 [label="get\n            {\n                return _assemblySymbol;\n            } 229651"];
7526 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 229652"];
7527 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 229653"];
7528 [label="corType.ContainingModule 229654"];
7529 [label="get\n            {\n                return ContainingPEModule;\n            } 229655"];
7530 [label="ContainingPEModule 229656"];
7531 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 229657"];
7532 [label="Symbol s = _container; 229658"];
7533 [label="s.Kind 229659"];
7534 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 229660"];
7535 [label="return SymbolKind.Namespace; 229661"];
7536 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 229662"];
7537 [label="((PENamespaceSymbol)s).ContainingPEModule 229663"];
7538 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 229664"];
7539 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 229665"];
7540 [label="return ContainingPEModule; 229666"];
7541 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 229667"];
7542 [label="corType.ContainingModule.Ordinal 229668"];
7543 [label="get\n            {\n                return _ordinal;\n            } 229669"];
7544 [label="return _ordinal; 229670"];
7545 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 229671"];
7546 [label="this.CorLibrary 229672"];
7547 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 229673"];
7548 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 229674"];
7549 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 229675"];
7550 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 229676"];
7551 [label="bool added; 229677"];
7552 [label="Debug.Assert(added); 229678"];
7553 [label="Debug.Assert(typeId != SpecialType.None); 229679"];
7554 [label="corType.ContainingAssembly 229680"];
7555 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 229681"];
7556 [label="this.ContainingSymbol 229682"];
7557 [label="get\n            {\n                return _container;\n            } 229683"];
7558 [label="return _container; 229684"];
7559 [label="var container = this.ContainingSymbol; 229685"];
7560 [label="return (object)container != null ? container.ContainingAssembly : null; 229686"];
7561 [label="return (object)container != null ? container.ContainingAssembly : null; 229687"];
7562 [label="(object)container != null 229688"];
7563 [label="container.ContainingAssembly 229689"];
7564 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 229690"];
7565 [label="ContainingPEModule 229691"];
7566 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 229692"];
7567 [label="return ContainingPEModule.ContainingAssembly; 229693"];
7568 [label="ContainingPEModule.ContainingAssembly 229694"];
7569 [label="get\n            {\n                return _assemblySymbol;\n            } 229695"];
7570 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 229696"];
7571 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 229697"];
7572 [label="corType.ContainingModule 229698"];
7573 [label="get\n            {\n                return ContainingPEModule;\n            } 229699"];
7574 [label="ContainingPEModule 229700"];
7575 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 229701"];
7576 [label="Symbol s = _container; 229702"];
7577 [label="s.Kind 229703"];
7578 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 229704"];
7579 [label="return SymbolKind.Namespace; 229705"];
7580 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 229706"];
7581 [label="((PENamespaceSymbol)s).ContainingPEModule 229707"];
7582 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 229708"];
7583 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 229709"];
7584 [label="return ContainingPEModule; 229710"];
7585 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 229711"];
7586 [label="corType.ContainingModule.Ordinal 229712"];
7587 [label="get\n            {\n                return _ordinal;\n            } 229713"];
7588 [label="return _ordinal; 229714"];
7589 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 229715"];
7590 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 229716"];
7591 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 229717"];
7592 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 229718"];
7593 [label="bool added; 229719"];
7594 [label="Debug.Assert(added); 229720"];
7595 [label="return _container; 229721"];
7596 [label="var container = this.ContainingSymbol; 229722"];
7597 [label="return (object)container != null ? container.ContainingAssembly : null; 229723"];
7598 [label="(object)container != null 229724"];
7599 [label="container.ContainingAssembly 229725"];
7600 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 229726"];
7601 [label="ContainingPEModule 229727"];
7602 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 229728"];
7603 [label="return ContainingPEModule.ContainingAssembly; 229729"];
7604 [label="ContainingPEModule.ContainingAssembly 229730"];
7605 [label="get\n            {\n                return _assemblySymbol;\n            } 229731"];
7606 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 229732"];
7607 [label="Symbol s = _container; 229733"];
7608 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 229734"];
7609 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 229735"];
7610 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 229736"];
7611 [label="return ContainingPEModule; 229737"];
7612 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 229738"];
7613 [label="get\n            {\n                return _ordinal;\n            } 229739"];
7614 [label="return _ordinal; 229740"];
7615 [label="LoadAllMembers(typesByNS); 229741"];
7616 [label="Interlocked.Exchange(ref _typesByNS, null); 229742"];
7617 [label="Interlocked.Exchange(ref _typesByNS, null); 229743"];
7618 [label="EnsureAllMembersLoaded(); 229744"];
7619 [label="ImmutableArray<PENamedTypeSymbol> t; 229745"];
7620 [label="t 229746"];
7621 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 229747"];
7622 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 229748"];
7623 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 229749"];
7624 [label="lazyTypes.TryGetValue(name, out t) 229750"];
7625 [label="foreach (var named in namespaceOrTypeMembers)\n            {\n                if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                }\n            } 229751"];
7626 [label="named.MangleName 229752"];
7627 [label="get\n                {\n                    return false;\n                } 229753"];
7628 [label="return false; 229754"];
7629 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 229755"];
7630 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 229756"];
7631 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 229757"];
7632 [label="named.Arity 229758"];
7633 [label="get\n                {\n                    return 0;\n                } 229759"];
7634 [label="return 0; 229760"];
7635 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 229761"];
7636 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 229762"];
7637 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 229763"];
7638 [label="if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    } 229764"];
7639 [label="if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    } 229765"];
7640 [label="namedType = named; 229766"];
7641 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 229767"];
7642 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 229768"];
7643 [label="return namedType; 229769"];
7644 [label="Debug.Assert((object)result != null); 229770"];
7645 [label="Debug.Assert((object)result != null); 229771"];
7646 [label="return result; 229772"];
7647 [label="result.Kind 229773"];
7648 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 229774"];
7649 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 229775"];
7650 [label="result.DeclaredAccessibility 229776"];
7651 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 229777"];
7652 [label="Accessibility access = Accessibility.Private; 229778"];
7653 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 229779"];
7654 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 229780"];
7655 [label="RegisterDeclaredSpecialType(result); 229781"];
7656 [label="RegisterDeclaredSpecialType(result) 229782"];
7657 [label="param RegisterDeclaredSpecialType(NamedTypeSymbol corType) 229783"];
7658 [label="param RegisterDeclaredSpecialType(this) 229784"];
7659 [label="corType.SpecialType 229785"];
7660 [label="Debug.Assert(typeId != SpecialType.None); 229786"];
7661 [label="corType.ContainingAssembly 229787"];
7662 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 229788"];
7663 [label="this.ContainingSymbol 229789"];
7664 [label="get\n            {\n                return _container;\n            } 229790"];
7665 [label="return _container; 229791"];
7666 [label="var container = this.ContainingSymbol; 229792"];
7667 [label="return (object)container != null ? container.ContainingAssembly : null; 229793"];
7668 [label="return (object)container != null ? container.ContainingAssembly : null; 229794"];
7669 [label="(object)container != null 229795"];
7670 [label="container.ContainingAssembly 229796"];
7671 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 229797"];
7672 [label="ContainingPEModule 229798"];
7673 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 229799"];
7674 [label="return ContainingPEModule.ContainingAssembly; 229800"];
7675 [label="ContainingPEModule.ContainingAssembly 229801"];
7676 [label="get\n            {\n                return _assemblySymbol;\n            } 229802"];
7677 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 229803"];
7678 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 229804"];
7679 [label="corType.ContainingModule 229805"];
7680 [label="get\n            {\n                return ContainingPEModule;\n            } 229806"];
7681 [label="ContainingPEModule 229807"];
7682 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 229808"];
7683 [label="Symbol s = _container; 229809"];
7684 [label="s.Kind 229810"];
7685 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 229811"];
7686 [label="return SymbolKind.Namespace; 229812"];
7687 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 229813"];
7688 [label="((PENamespaceSymbol)s).ContainingPEModule 229814"];
7689 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 229815"];
7690 [label="_containingNamespaceSymbol.ContainingPEModule 229816"];
7691 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 229817"];
7692 [label="return ContainingPEModule; 229818"];
7693 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 229819"];
7694 [label="corType.ContainingModule.Ordinal 229820"];
7695 [label="get\n            {\n                return _ordinal;\n            } 229821"];
7696 [label="return _ordinal; 229822"];
7697 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 229823"];
7698 [label="this.CorLibrary 229824"];
7699 [label="get\n            {\n                return _corLibrary;\n            } 229825"];
7700 [label="return _corLibrary; 229826"];
7701 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 229827"];
7702 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 229828"];
7703 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 229829"];
7704 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 229830"];
7705 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 229831"];
7706 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 229832"];
7707 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 229833"];
7708 [label="RegisterDeclaredSpecialType(result); 229834"];
7709 [label="return _lazySpecialTypes[(int)type]; 229835"];
7710 [label="result.SpecialType 229836"];
7711 [label="get\n            {\n                return _corTypeId;\n            } 229837"];
7712 [label="Debug.Assert(result.SpecialType == specialType); 229838"];
7713 [label="return result; 229839"];
7714 [label="Debug.Assert((object)typeSymbol != null, 'Expect an error type if special type isn't found'); 229840"];
7715 [label="Debug.Assert((object)typeSymbol != null, 'Expect an error type if special type isn't found'); 229841"];
7716 [label="ReportUseSiteDiagnostics(typeSymbol, diagnostics, node); 229842"];
7717 [label="ReportUseSiteDiagnostics(typeSymbol, diagnostics, node); 229843"];
7718 [label="ReportUseSiteDiagnostics(typeSymbol, diagnostics, node); 229844"];
7719 [label="ReportUseSiteDiagnostics(typeSymbol, diagnostics, node) 229845"];
7720 [label="param ReportUseSiteDiagnostics(Symbol symbol) 229846"];
7721 [label="param ReportUseSiteDiagnostics(DiagnosticBag diagnostics) 229847"];
7722 [label="param ReportUseSiteDiagnostics(SyntaxNode node) 229848"];
7723 [label="symbol.GetUseSiteDiagnostic() 229849"];
7724 [label="param GetUseSiteDiagnostic(this) 229850"];
7725 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 229851"];
7726 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 229852"];
7727 [label="GetUseSiteDiagnosticImpl() 229853"];
7728 [label="param GetUseSiteDiagnosticImpl(this) 229854"];
7729 [label="DiagnosticInfo diagnostic = null; 229855"];
7730 [label="if (!MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()))\n            {\n                // Check if this type is marked by RequiredAttribute attribute.\n                // If so mark the type as bad, because it relies upon semantics that are not understood by the C# compiler.\n                if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                }\n            } 229856"];
7731 [label="CalculateUseSiteDiagnostic() 229857"];
7732 [label="param CalculateUseSiteDiagnostic(this) 229858"];
7733 [label="DiagnosticInfo result = null; 229859"];
7734 [label="if (MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()))\n            {\n                return result;\n            } 229860"];
7735 [label="DeriveUseSiteDiagnosticFromBase() 229861"];
7736 [label="param DeriveUseSiteDiagnosticFromBase(this) 229862"];
7737 [label="this.BaseTypeNoUseSiteDiagnostics 229863"];
7738 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                }\n\n                return _lazyBaseType;\n            } 229864"];
7739 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 229865"];
7740 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 229866"];
7741 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 229867"];
7742 [label="MakeAcyclicBaseType() 229868"];
7743 [label="param MakeAcyclicBaseType(this) 229869"];
7744 [label="NamedTypeSymbol declaredBase = GetDeclaredBaseType(null); 229870"];
7745 [label="GetDeclaredBaseType(null) 229871"];
7746 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 229872"];
7747 [label="param GetDeclaredBaseType(this) 229873"];
7748 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 229874"];
7749 [label="GetDeclaredBaseType(skipTransformsIfNecessary: false) 229875"];
7750 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 229876"];
7751 [label="param GetDeclaredBaseType(this) 229877"];
7752 [label="if (ReferenceEquals(_lazyDeclaredBaseType, ErrorTypeSymbol.UnknownResultType))\n            {\n                var baseType = MakeDeclaredBaseType();\n                if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                }\n\n                Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType);\n            } 229878"];
7753 [label="if (ReferenceEquals(_lazyDeclaredBaseType, ErrorTypeSymbol.UnknownResultType))\n            {\n                var baseType = MakeDeclaredBaseType();\n                if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                }\n\n                Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType);\n            } 229879"];
7754 [label="MakeDeclaredBaseType() 229880"];
7755 [label="param MakeDeclaredBaseType(this) 229881"];
7756 [label="if (!_flags.IsInterface())\n            {\n                try\n                {\n                    var moduleSymbol = ContainingPEModule;\n                    EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle);\n                    if (!token.IsNil)\n                    {\n                        return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token);\n                    }\n                }\n                catch (BadImageFormatException mrEx)\n                {\n                    return new UnsupportedMetadataTypeSymbol(mrEx);\n                }\n            } 229882"];
7757 [label="ContainingPEModule 229883"];
7758 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 229884"];
7759 [label="Symbol s = _container; 229885"];
7760 [label="s.Kind 229886"];
7761 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 229887"];
7762 [label="return SymbolKind.Namespace; 229888"];
7763 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 229889"];
7764 [label="((PENamespaceSymbol)s).ContainingPEModule 229890"];
7765 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 229891"];
7766 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 229892"];
7767 [label="var moduleSymbol = ContainingPEModule; 229893"];
7768 [label="moduleSymbol.Module 229894"];
7769 [label="get\n            {\n                return _module;\n            } 229895"];
7770 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 229896"];
7771 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 229897"];
7772 [label="if (!token.IsNil)\n                    {\n                        return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token);\n                    } 229898"];
7773 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 229899"];
7774 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 229900"];
7775 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 229901"];
7776 [label="new MetadataDecoder(moduleSymbol, this) 229902"];
7777 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 229903"];
7778 [label="param MetadataDecoder(PENamedTypeSymbol context) 229904"];
7779 [label="param MetadataDecoder(this) 229905"];
7780 [label="moduleSymbol 229906"];
7781 [label="context 229907"];
7782 [label="null 229908"];
7783 [label="param MetadataDecoder(this) 229909"];
7784 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 229910"];
7785 [label="param MetadataDecoder(PENamedTypeSymbol typeContextOpt) 229911"];
7786 [label="param MetadataDecoder(PEMethodSymbol methodContextOpt) 229912"];
7787 [label="param MetadataDecoder(this) 229913"];
7788 [label="moduleSymbol.Module 229914"];
7789 [label="get\n            {\n                return _module;\n            } 229915"];
7790 [label="moduleSymbol.ContainingAssembly 229916"];
7791 [label="get\n            {\n                return _assemblySymbol;\n            } 229917"];
7792 [label="(moduleSymbol.ContainingAssembly is PEAssemblySymbol) 229918"];
7793 [label="moduleSymbol.ContainingAssembly 229919"];
7794 [label="moduleSymbol.ContainingAssembly.Identity 229920"];
7795 [label="get\n            {\n                return _assembly.Identity;\n            } 229921"];
7796 [label="return _assembly.Identity; 229922"];
7797 [label="new SymbolFactory() 229923"];
7798 [label="param SymbolFactory(this) 229924"];
7799 [label="Instance = new SymbolFactory() 229925"];
7800 [label="SymbolFactory.Instance 229926"];
7801 [label="moduleSymbol 229927"];
7802 [label="param MetadataDecoder(this) 229928"];
7803 [label="param MetadataDecoder(this) 229929"];
7804 [label="_typeContextOpt 229930"];
7805 [label="_methodContextOpt 229931"];
7806 [label="Debug.Assert((object)moduleSymbol != null); 229932"];
7807 [label="Debug.Assert((object)moduleSymbol != null); 229933"];
7808 [label="_typeContextOpt 229934"];
7809 [label="_methodContextOpt 229935"];
7810 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 229936"];
7811 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 229937"];
7812 [label="param GetTypeHandleToTypeMap(this) 229938"];
7813 [label="return moduleSymbol.TypeHandleToTypeMap; 229939"];
7814 [label="var baseType = MakeDeclaredBaseType(); 229940"];
7815 [label="if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                } 229941"];
7816 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 229942"];
7817 [label="ContainingPEModule 229943"];
7818 [label="s.Kind 229944"];
7819 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 229945"];
7820 [label="return SymbolKind.Namespace; 229946"];
7821 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 229947"];
7822 [label="var moduleSymbol = ContainingPEModule; 229948"];
7823 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 229949"];
7824 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 229950"];
7825 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 229951"];
7826 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 229952"];
7827 [label="DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol) 229953"];
7828 [label="param TransformType(TypeSymbol metadataType) 229954"];
7829 [label="param TransformType(int targetSymbolCustomModifierCount) 229955"];
7830 [label="param TransformType(EntityHandle targetSymbolToken) 229956"];
7831 [label="param TransformType(PEModuleSymbol containingModule) 229957"];
7832 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 229958"];
7833 [label="Debug.Assert((object)metadataType != null); 229959"];
7834 [label="Debug.Assert((object)metadataType != null); 229960"];
7835 [label="ImmutableArray<bool> dynamicTransformFlags; 229961"];
7836 [label="dynamicTransformFlags 229962"];
7837 [label="containingModule.Module 229963"];
7838 [label="get\n            {\n                return _module;\n            } 229964"];
7839 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 229965"];
7840 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 229966"];
7841 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 229967"];
7842 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 229968"];
7843 [label="return metadataType; 229969"];
7844 [label="decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol); 229970"];
7845 [label="decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol); 229971"];
7846 [label="decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol); 229972"];
7847 [label="NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol) 229973"];
7848 [label="param TransformType(TypeSymbol type) 229974"];
7849 [label="param TransformType(EntityHandle handle) 229975"];
7850 [label="param TransformType(PEModuleSymbol containingModule) 229976"];
7851 [label="containingModule.Module 229977"];
7852 [label="get\n            {\n                return _module;\n            } 229978"];
7853 [label="return _module; 229979"];
7854 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 229980"];
7855 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 229981"];
7856 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 229982"];
7857 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 229983"];
7858 [label="containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) 229984"];
7859 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 229985"];
7860 [label="decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol); 229986"];
7861 [label="decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol); 229987"];
7862 [label="decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol); 229988"];
7863 [label="TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol) 229989"];
7864 [label="param DecodeTupleTypesIfApplicable(TypeSymbol metadataType) 229990"];
7865 [label="param DecodeTupleTypesIfApplicable(EntityHandle targetHandle) 229991"];
7866 [label="param DecodeTupleTypesIfApplicable(PEModuleSymbol containingModule) 229992"];
7867 [label="ImmutableArray<string?> elementNames; 229993"];
7868 [label="elementNames 229994"];
7869 [label="containingModule\n                .Module 229995"];
7870 [label="get\n            {\n                return _module;\n            } 229996"];
7871 [label="return _module; 229997"];
7872 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 229998"];
7873 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 229999"];
7874 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 230000"];
7875 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 230001"];
7876 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 230002"];
7877 [label="return DecodeTupleTypesInternal(metadataType, elementNames, hasTupleElementNamesAttribute); 230003"];
7878 [label="return DecodeTupleTypesInternal(metadataType, elementNames, hasTupleElementNamesAttribute); 230004"];
7879 [label="DecodeTupleTypesInternal(metadataType, elementNames, hasTupleElementNamesAttribute) 230005"];
7880 [label="param DecodeTupleTypesInternal(TypeSymbol metadataType) 230006"];
7881 [label="param DecodeTupleTypesInternal(ImmutableArray<string?> elementNames) 230007"];
7882 [label="param DecodeTupleTypesInternal(bool hasTupleElementNamesAttribute) 230008"];
7883 [label="RoslynDebug.AssertNotNull(metadataType); 230009"];
7884 [label="RoslynDebug.AssertNotNull(metadataType); 230010"];
7885 [label="var decoder = new TupleTypeDecoder(elementNames); 230011"];
7886 [label="var decoder = new TupleTypeDecoder(elementNames); 230012"];
7887 [label="new TupleTypeDecoder(elementNames) 230013"];
7888 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 230014"];
7889 [label="param TupleTypeDecoder(this) 230015"];
7890 [label="_elementNames 230016"];
7891 [label="elementNames.IsDefault 230017"];
7892 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 230018"];
7893 [label="_namesIndex 230019"];
7894 [label="_decodingFailed = false; 230020"];
7895 [label="_decodingFailed 230021"];
7896 [label="_foundUsableErrorType = false; 230022"];
7897 [label="_foundUsableErrorType 230023"];
7898 [label="var decoded = decoder.DecodeType(metadataType); 230024"];
7899 [label="decoder.DecodeType(metadataType) 230025"];
7900 [label="param DecodeType(TypeSymbol type) 230026"];
7901 [label="param DecodeType(this) 230027"];
7902 [label="type.Kind 230028"];
7903 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 230029"];
7904 [label="switch (type.Kind)\n            {\n                case SymbolKind.ErrorType:\n                    _foundUsableErrorType = true;\n                    return type;\n\n                case SymbolKind.DynamicType:\n                case SymbolKind.TypeParameter:\n                    return type;\n\n                case SymbolKind.FunctionPointerType:\n                    return DecodeFunctionPointerType((FunctionPointerTypeSymbol)type);\n\n                case SymbolKind.PointerType:\n                    return DecodePointerType((PointerTypeSymbol)type);\n\n                case SymbolKind.NamedType:\n                    // We may have a tuple type from a substituted type symbol,\n                    // but it will be missing names from metadata, so we'll\n                    // need to re-create the type.\n                    //\n                    // Consider the declaration\n                    //\n                    //      class C : BaseType<(int x, int y)>\n                    //\n                    // The process for decoding tuples in C looks at the BaseType, calls\n                    // DecodeOrThrow, then passes the decoded type to the TupleTypeDecoder.\n                    // However, DecodeOrThrow uses the AbstractTypeMap to construct a\n                    // SubstitutedTypeSymbol, which eagerly converts tuple-compatible\n                    // types to TupleTypeSymbols. Thus, by the time we get to the Decoder\n                    // all metadata instances of System.ValueTuple will have been\n                    //  replaced with TupleTypeSymbols without names.\n                    // \n                    // Rather than fixing up after-the-fact it's possible that we could\n                    // flow up a SubstituteWith/Without tuple unification to the top level\n                    // of the type map and change DecodeOrThrow to call into the substitution\n                    // without unification instead.\n                    return DecodeNamedType((NamedTypeSymbol)type);\n\n                case SymbolKind.ArrayType:\n                    return DecodeArrayType((ArrayTypeSymbol)type);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(type.TypeKind);\n            } 230030"];
7905 [label="return DecodeNamedType((NamedTypeSymbol)type); 230031"];
7906 [label="DecodeNamedType((NamedTypeSymbol)type) 230032"];
7907 [label="param DecodeNamedType(NamedTypeSymbol type) 230033"];
7908 [label="param DecodeNamedType(this) 230034"];
7909 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 230035"];
7910 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 230036"];
7911 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 230037"];
7912 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 230038"];
7913 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 230039"];
7914 [label="DecodeTypeArguments(typeArgs) 230040"];
7915 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 230041"];
7916 [label="param DecodeTypeArguments(this) 230042"];
7917 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 230043"];
7918 [label="return typeArgs; 230044"];
7919 [label="NamedTypeSymbol decodedType = type; 230045"];
7920 [label="type.ContainingType 230046"];
7921 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 230047"];
7922 [label="return _container as NamedTypeSymbol; 230048"];
7923 [label="NamedTypeSymbol containingType = type.ContainingType; 230049"];
7924 [label="NamedTypeSymbol? decodedContainingType; 230050"];
7925 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 230051"];
7926 [label="decodedContainingType = containingType; 230052"];
7927 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 230053"];
7928 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 230054"];
7929 [label="var typeArgsChanged = typeArgs != decodedArgs; 230055"];
7930 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 230056"];
7931 [label="decodedType.IsTupleType 230057"];
7932 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 230058"];
7933 [label="_ 230059"];
7934 [label="tupleCardinality: out _ 230060"];
7935 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 230061"];
7936 [label="param IsTupleTypeOfCardinality(this) 230062"];
7937 [label="IsUnboundGenericType 230063"];
7938 [label="get\n            {\n                return false;\n            } 230064"];
7939 [label="return false; 230065"];
7940 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230066"];
7941 [label="ContainingSymbol 230067"];
7942 [label="get\n            {\n                return _container;\n            } 230068"];
7943 [label="return _container; 230069"];
7944 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230070"];
7945 [label=".Kind 230071"];
7946 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 230072"];
7947 [label="return SymbolKind.Namespace; 230073"];
7948 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230074"];
7949 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230075"];
7950 [label="ContainingNamespace 230076"];
7951 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 230077"];
7952 [label="get\n            {\n                return _container;\n            } 230078"];
7953 [label="return _container; 230079"];
7954 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230080"];
7955 [label="ContainingNamespace.ContainingNamespace 230081"];
7956 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 230082"];
7957 [label=".IsGlobalNamespace 230083"];
7958 [label="get\n            {\n                return true;\n            } 230084"];
7959 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230085"];
7960 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230086"];
7961 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230087"];
7962 [label="Name 230088"];
7963 [label="get\n            {\n                return _name;\n            } 230089"];
7964 [label="return _name; 230090"];
7965 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230091"];
7966 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230092"];
7967 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230093"];
7968 [label="tupleCardinality = 0; 230094"];
7969 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 230095"];
7970 [label="return decodedType; 230096"];
7971 [label="if (!decoder._decodingFailed)\n            {\n                if (!hasTupleElementNamesAttribute || decoder._namesIndex == 0)\n                {\n                    return decoded;\n                }\n            } 230097"];
7972 [label="if (!hasTupleElementNamesAttribute || decoder._namesIndex == 0)\n                {\n                    return decoded;\n                } 230098"];
7973 [label="return decoded; 230099"];
7974 [label="typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces 230100"];
7975 [label="genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters 230101"];
7976 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 230102"];
7977 [label="miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 230103"];
7978 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 230104"];
7979 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 230105"];
7980 [label="DebuggerDisplayFormat = new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 230106"];
7981 [label="typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces 230107"];
7982 [label="genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters 230108"];
7983 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 230109"];
7984 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 230110"];
7985 [label="miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 230111"];
7986 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 230112"];
7987 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 230113"];
7988 [label="TestDisplayFormat = new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 230114"];
7989 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 230115"];
7990 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 230116"];
7991 [label="TypeWithAnnotations.Create(decodedType) 230117"];
7992 [label="param Create(TypeSymbol typeSymbol) 230118"];
7993 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 230119"];
7994 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 230120"];
7995 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 230121"];
7996 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 230122"];
7997 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 230123"];
7998 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 230124"];
7999 [label="'Expressions' 230125"];
8000 [label="'Linq' 230126"];
8001 [label="'' 230127"];
8002 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 230128"];
8003 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 230129"];
8004 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 230130"];
8005 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 230131"];
8006 [label="s_expressionsNamespaceName = { 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 230132"];
8007 [label="(type, parameter, unused) => type.TypeKind == TypeKind.TypeParameter && (parameter is null || TypeSymbol.Equals(type, parameter, TypeCompareKind.ConsiderEverything2)) 230133"];
8008 [label="s_containsTypeParameterPredicate =\n            (type, parameter, unused) => type.TypeKind == TypeKind.TypeParameter && (parameter is null || TypeSymbol.Equals(type, parameter, TypeCompareKind.ConsiderEverything2)) 230134"];
8009 [label="(type, parameterContainer, unused) => type.TypeKind == TypeKind.TypeParameter && (object)type.ContainingSymbol == (object)parameterContainer 230135"];
8010 [label="s_isTypeParameterWithSpecificContainerPredicate =\n             (type, parameterContainer, unused) => type.TypeKind == TypeKind.TypeParameter && (object)type.ContainingSymbol == (object)parameterContainer 230136"];
8011 [label="(type, parameters, unused) => type.TypeKind == TypeKind.TypeParameter && parameters.Contains((TypeParameterSymbol)type) 230137"];
8012 [label="s_containsTypeParametersPredicate =\n            (type, parameters, unused) => type.TypeKind == TypeKind.TypeParameter && parameters.Contains((TypeParameterSymbol)type) 230138"];
8013 [label="(type, unused1, unused2) => type.TypeKind == TypeKind.Dynamic 230139"];
8014 [label="s_containsDynamicPredicate = (type, unused1, unused2) => type.TypeKind == TypeKind.Dynamic 230140"];
8015 [label="typeSymbol.IsNullableType() 230141"];
8016 [label="param IsNullableType(this TypeSymbol type) 230142"];
8017 [label="type.OriginalDefinition 230143"];
8018 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 230144"];
8019 [label="OriginalTypeSymbolDefinition 230145"];
8020 [label="get\n            {\n                return this.OriginalDefinition;\n            } 230146"];
8021 [label="this.OriginalDefinition 230147"];
8022 [label="get\n            {\n                return this;\n            } 230148"];
8023 [label="return this; 230149"];
8024 [label="return this.OriginalDefinition; 230150"];
8025 [label="return OriginalTypeSymbolDefinition; 230151"];
8026 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 230152"];
8027 [label="type.OriginalDefinition.SpecialType 230153"];
8028 [label="get\n            {\n                return _corTypeId;\n            } 230154"];
8029 [label="return _corTypeId; 230155"];
8030 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 230156"];
8031 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 230157"];
8032 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 230158"];
8033 [label="CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()) 230159"];
8034 [label="param CreateNonLazyType(TypeSymbol typeSymbol) 230160"];
8035 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 230161"];
8036 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 230162"];
8037 [label="customModifiers: ImmutableArray<CustomModifier>.Empty 230163"];
8038 [label="new NonLazyType(customModifiers: ImmutableArray<CustomModifier>.Empty) 230164"];
8039 [label="param NonLazyType(ImmutableArray<CustomModifier> customModifiers) 230165"];
8040 [label="param NonLazyType(this) 230166"];
8041 [label="param Extensions(this) 230167"];
8042 [label="Debug.Assert(!customModifiers.IsDefault); 230168"];
8043 [label="_customModifiers 230169"];
8044 [label="Default = new NonLazyType(customModifiers: ImmutableArray<CustomModifier>.Empty) 230170"];
8045 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 230171"];
8046 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 230172"];
8047 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 230173"];
8048 [label="Extensions.Create(customModifiers) 230174"];
8049 [label="param Create(ImmutableArray<CustomModifier> customModifiers) 230175"];
8050 [label="if (customModifiers.IsEmpty)\n                {\n                    return Default;\n                } 230176"];
8051 [label="return Default; 230177"];
8052 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 230178"];
8053 [label="new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)) 230179"];
8054 [label="param TypeWithAnnotations(TypeSymbol defaultType) 230180"];
8055 [label="param TypeWithAnnotations(NullableAnnotation nullableAnnotation) 230181"];
8056 [label="param TypeWithAnnotations(Extensions extensions) 230182"];
8057 [label="param TypeWithAnnotations(this) 230183"];
8058 [label="var a1 = defaultType is null; 230184"];
8059 [label="!a1 230185"];
8060 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 230186"];
8061 [label="defaultType.IsNullableType() 230187"];
8062 [label="param IsNullableType(this TypeSymbol type) 230188"];
8063 [label="type.OriginalDefinition 230189"];
8064 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 230190"];
8065 [label="OriginalTypeSymbolDefinition 230191"];
8066 [label="get\n            {\n                return this.OriginalDefinition;\n            } 230192"];
8067 [label="this.OriginalDefinition 230193"];
8068 [label="get\n            {\n                return this;\n            } 230194"];
8069 [label="return this; 230195"];
8070 [label="return this.OriginalDefinition; 230196"];
8071 [label="return OriginalTypeSymbolDefinition; 230197"];
8072 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 230198"];
8073 [label="type.OriginalDefinition.SpecialType 230199"];
8074 [label="get\n            {\n                return _corTypeId;\n            } 230200"];
8075 [label="return _corTypeId; 230201"];
8076 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 230202"];
8077 [label="Debug.Assert(a1 || a2 != true || a3); 230203"];
8078 [label="Debug.Assert(a1 || a2 != true || a3); 230204"];
8079 [label="Debug.Assert(extensions != null); 230205"];
8080 [label="Debug.Assert(extensions != null); 230206"];
8081 [label="DefaultType 230207"];
8082 [label="NullableAnnotation 230208"];
8083 [label="_extensions 230209"];
8084 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 230210"];
8085 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 230211"];
8086 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 230212"];
8087 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 230213"];
8088 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 230214"];
8089 [label="NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this) 230215"];
8090 [label="param TransformType(TypeWithAnnotations metadataType) 230216"];
8091 [label="param TransformType(EntityHandle targetSymbolToken) 230217"];
8092 [label="param TransformType(PEModuleSymbol containingModule) 230218"];
8093 [label="param TransformType(Symbol accessSymbol) 230219"];
8094 [label="param TransformType(Symbol nullableContext) 230220"];
8095 [label="metadataType.HasType 230221"];
8096 [label="=> !(DefaultType is null) 230222"];
8097 [label="DefaultType is null 230223"];
8098 [label="!(DefaultType is null) 230224"];
8099 [label="Debug.Assert(metadataType.HasType); 230225"];
8100 [label="accessSymbol.IsDefinition 230226"];
8101 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 230227"];
8102 [label="OriginalDefinition 230228"];
8103 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 230229"];
8104 [label="OriginalSymbolDefinition 230230"];
8105 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 230231"];
8106 [label="this.OriginalTypeSymbolDefinition 230232"];
8107 [label="get\n            {\n                return this.OriginalDefinition;\n            } 230233"];
8108 [label="this.OriginalDefinition 230234"];
8109 [label="get\n            {\n                return this;\n            } 230235"];
8110 [label="return this; 230236"];
8111 [label="return this.OriginalDefinition; 230237"];
8112 [label="return this.OriginalTypeSymbolDefinition; 230238"];
8113 [label="return OriginalSymbolDefinition; 230239"];
8114 [label="return (object)this == (object)OriginalDefinition; 230240"];
8115 [label="Debug.Assert(accessSymbol.IsDefinition); 230241"];
8116 [label="accessSymbol.ContainingModule 230242"];
8117 [label="get\n            {\n                return ContainingPEModule;\n            } 230243"];
8118 [label="ContainingPEModule 230244"];
8119 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 230245"];
8120 [label="Symbol s = _container; 230246"];
8121 [label="s.Kind 230247"];
8122 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 230248"];
8123 [label="return SymbolKind.Namespace; 230249"];
8124 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 230250"];
8125 [label="return ContainingPEModule; 230251"];
8126 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 230252"];
8127 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 230253"];
8128 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 230254"];
8129 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 230255"];
8130 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 230256"];
8131 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 230257"];
8132 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 230258"];
8133 [label="Debug.Assert(symbol is object); 230259"];
8134 [label="symbol.Kind 230260"];
8135 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 230261"];
8136 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 230262"];
8137 [label="isInternal = false; 230263"];
8138 [label="symbol.DeclaredAccessibility 230264"];
8139 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 230265"];
8140 [label="Accessibility access = Accessibility.Private; 230266"];
8141 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 230267"];
8142 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 230268"];
8143 [label="symbol.ContainingType 230269"];
8144 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 230270"];
8145 [label="return _container as NamedTypeSymbol; 230271"];
8146 [label="symbol = symbol.ContainingType; 230272"];
8147 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 230273"];
8148 [label="return true; 230274"];
8149 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 230275"];
8150 [label="byte defaultTransformFlag; 230276"];
8151 [label="ImmutableArray<byte> nullableTransformFlags; 230277"];
8152 [label="nullableTransformFlags 230278"];
8153 [label="containingModule.Module 230279"];
8154 [label="get\n            {\n                return _module;\n            } 230280"];
8155 [label="return _module; 230281"];
8156 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 230282"];
8157 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 230283"];
8158 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 230284"];
8159 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 230285"];
8160 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 230286"];
8161 [label="nullableContext.GetNullableContextValue() 230287"];
8162 [label="param GetNullableContextValue(this) 230288"];
8163 [label="byte? value; 230289"];
8164 [label="if (!_lazyNullableContextValue.TryGetByte(out value))\n            {\n                value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue();\n                _lazyNullableContextValue = value.ToNullableContextFlags();\n            } 230290"];
8165 [label="if (!_lazyNullableContextValue.TryGetByte(out value))\n            {\n                value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue();\n                _lazyNullableContextValue = value.ToNullableContextFlags();\n            } 230291"];
8166 [label="_lazyNullableContextValue.TryGetByte(out value) 230292"];
8167 [label="param TryGetByte(this NullableContextKind kind) 230293"];
8168 [label="param TryGetByte(out byte? value) 230294"];
8169 [label="switch (kind)\n            {\n                case NullableContextKind.Unknown:\n                    value = null;\n                    return false;\n                case NullableContextKind.None:\n                    value = null;\n                    return true;\n                case NullableContextKind.Oblivious:\n                    value = NullableAnnotationExtensions.ObliviousAttributeValue;\n                    return true;\n                case NullableContextKind.NotAnnotated:\n                    value = NullableAnnotationExtensions.NotAnnotatedAttributeValue;\n                    return true;\n                case NullableContextKind.Annotated:\n                    value = NullableAnnotationExtensions.AnnotatedAttributeValue;\n                    return true;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 230295"];
8170 [label="value = null; 230296"];
8171 [label="return false; 230297"];
8172 [label="ContainingPEModule 230298"];
8173 [label="s.Kind 230299"];
8174 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 230300"];
8175 [label="return SymbolKind.Namespace; 230301"];
8176 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 230302"];
8177 [label="value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue(); 230303"];
8178 [label="ContainingPEModule.Module 230304"];
8179 [label="get\n            {\n                return _module;\n            } 230305"];
8180 [label="value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue(); 230306"];
8181 [label="value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue(); 230307"];
8182 [label="ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) 230308"];
8183 [label="_container.GetNullableContextValue() 230309"];
8184 [label="param GetNullableContextValue(this) 230310"];
8185 [label="GetLocalNullableContextValue() 230311"];
8186 [label="param GetLocalNullableContextValue(this) 230312"];
8187 [label="return null; 230313"];
8188 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 230314"];
8189 [label="ContainingSymbol 230315"];
8190 [label="get { return _containingNamespaceSymbol; } 230316"];
8191 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 230317"];
8192 [label=".GetNullableContextValue() 230318"];
8193 [label="param GetNullableContextValue(this) 230319"];
8194 [label="GetLocalNullableContextValue() 230320"];
8195 [label="param GetLocalNullableContextValue(this) 230321"];
8196 [label="return null; 230322"];
8197 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 230323"];
8198 [label="ContainingSymbol 230324"];
8199 [label="get\n            {\n                return _moduleSymbol;\n            } 230325"];
8200 [label="return _moduleSymbol; 230326"];
8201 [label="param GetLocalNullableContextValue(this) 230327"];
8202 [label="get\n            {\n                return _assemblySymbol;\n            } 230328"];
8203 [label="return _assemblySymbol; 230329"];
8204 [label="param GetLocalNullableContextValue(this) 230330"];
8205 [label="get\n            {\n                return null;\n            } 230331"];
8206 [label="return null; 230332"];
8207 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 230333"];
8208 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 230334"];
8209 [label="_lazyNullableContextValue = value.ToNullableContextFlags(); 230335"];
8210 [label="value.ToNullableContextFlags() 230336"];
8211 [label="param ToNullableContextFlags(this byte? value) 230337"];
8212 [label="switch (value)\n            {\n                case null:\n                    return NullableContextKind.None;\n                case NullableAnnotationExtensions.ObliviousAttributeValue:\n                    return NullableContextKind.Oblivious;\n                case NullableAnnotationExtensions.NotAnnotatedAttributeValue:\n                    return NullableContextKind.NotAnnotated;\n                case NullableAnnotationExtensions.AnnotatedAttributeValue:\n                    return NullableContextKind.Annotated;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(value);\n            } 230338"];
8213 [label="return NullableContextKind.None; 230339"];
8214 [label="_lazyNullableContextValue 230340"];
8215 [label="return value; 230341"];
8216 [label="byte? value = nullableContext.GetNullableContextValue(); 230342"];
8217 [label="if (value == null)\n                {\n                    return metadataType;\n                } 230343"];
8218 [label="if (value == null)\n                {\n                    return metadataType;\n                } 230344"];
8219 [label="return metadataType; 230345"];
8220 [label="NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type 230346"];
8221 [label="=> _extensions?.GetResolvedType(DefaultType) 230347"];
8222 [label="DefaultType 230348"];
8223 [label=".GetResolvedType(DefaultType) 230349"];
8224 [label="param GetResolvedType(TypeSymbol defaultType) 230350"];
8225 [label="=> defaultType 230351"];
8226 [label="defaultType 230352"];
8227 [label="_extensions?.GetResolvedType(DefaultType) 230353"];
8228 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 230354"];
8229 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 230355"];
8230 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 230356"];
8231 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 230357"];
8232 [label="return _lazyDeclaredBaseType; 230358"];
8233 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 230359"];
8234 [label="NamedTypeSymbol declaredBase = GetDeclaredBaseType(null); 230360"];
8235 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 230361"];
8236 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 230362"];
8237 [label="if (BaseTypeAnalysis.TypeDependsOn(declaredBase, this))\n            {\n                return CyclicInheritanceError(this, declaredBase);\n            } 230363"];
8238 [label="if (BaseTypeAnalysis.TypeDependsOn(declaredBase, this))\n            {\n                return CyclicInheritanceError(this, declaredBase);\n            } 230364"];
8239 [label="BaseTypeAnalysis.TypeDependsOn(declaredBase, this) 230365"];
8240 [label="param TypeDependsOn(NamedTypeSymbol depends) 230366"];
8241 [label="param TypeDependsOn(NamedTypeSymbol on) 230367"];
8242 [label="Debug.Assert((object)depends != null); 230368"];
8243 [label="Debug.Assert((object)depends != null); 230369"];
8244 [label="Debug.Assert((object)on != null); 230370"];
8245 [label="Debug.Assert((object)on != null); 230371"];
8246 [label="on.IsDefinition 230372"];
8247 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 230373"];
8248 [label="OriginalDefinition 230374"];
8249 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 230375"];
8250 [label="OriginalSymbolDefinition 230376"];
8251 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 230377"];
8252 [label="this.OriginalTypeSymbolDefinition 230378"];
8253 [label="get\n            {\n                return this.OriginalDefinition;\n            } 230379"];
8254 [label="this.OriginalDefinition 230380"];
8255 [label="get\n            {\n                return this;\n            } 230381"];
8256 [label="return this; 230382"];
8257 [label="return this.OriginalDefinition; 230383"];
8258 [label="return this.OriginalTypeSymbolDefinition; 230384"];
8259 [label="return OriginalSymbolDefinition; 230385"];
8260 [label="return (object)this == (object)OriginalDefinition; 230386"];
8261 [label="Debug.Assert(on.IsDefinition); 230387"];
8262 [label="var hs = PooledHashSet<Symbol>.GetInstance(); 230388"];
8263 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 230389"];
8264 [label="depends.DeclaringCompilation 230390"];
8265 [label="get { return null; } 230391"];
8266 [label="return null; 230392"];
8267 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 230393"];
8268 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 230394"];
8269 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs) 230395"];
8270 [label="param TypeDependsClosure(NamedTypeSymbol type) 230396"];
8271 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 230397"];
8272 [label="param TypeDependsClosure(HashSet<Symbol> partialClosure) 230398"];
8273 [label="if ((object)type == null)\n            {\n                return;\n            } 230399"];
8274 [label="if ((object)type == null)\n            {\n                return;\n            } 230400"];
8275 [label="type.OriginalDefinition 230401"];
8276 [label="get\n            {\n                return this;\n            } 230402"];
8277 [label="return this; 230403"];
8278 [label="type = type.OriginalDefinition; 230404"];
8279 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 230405"];
8280 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 230406"];
8281 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 230407"];
8282 [label="param GetHashCode(this) 230408"];
8283 [label="this.SpecialType 230409"];
8284 [label="get\n            {\n                return _corTypeId;\n            } 230410"];
8285 [label="if (this.SpecialType == SpecialType.System_Object)\n            {\n                return (int)SpecialType.System_Object;\n            } 230411"];
8286 [label="OriginalDefinition 230412"];
8287 [label="get\n            {\n                return this;\n            } 230413"];
8288 [label="return RuntimeHelpers.GetHashCode(OriginalDefinition); 230414"];
8289 [label="type.IsInterface 230415"];
8290 [label="get\n            {\n                return _flags.IsInterface();\n            } 230416"];
8291 [label="return _flags.IsInterface(); 230417"];
8292 [label="if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                } 230418"];
8293 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 230419"];
8294 [label="type.GetDeclaredBaseType(null) 230420"];
8295 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 230421"];
8296 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 230422"];
8297 [label="s.Kind 230423"];
8298 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 230424"];
8299 [label="return SymbolKind.Namespace; 230425"];
8300 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 230426"];
8301 [label="Debug.Assert((object)moduleSymbol != null); 230427"];
8302 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 230428"];
8303 [label="param TransformType(int targetSymbolCustomModifierCount) 230429"];
8304 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 230430"];
8305 [label="Debug.Assert((object)metadataType != null); 230431"];
8306 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 230432"];
8307 [label="param DecodeTupleTypesInternal(ImmutableArray<string?> elementNames) 230433"];
8308 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 230434"];
8309 [label="_elementNames 230435"];
8310 [label="elementNames.IsDefault 230436"];
8311 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 230437"];
8312 [label="_namesIndex 230438"];
8313 [label="_foundUsableErrorType = false; 230439"];
8314 [label="_foundUsableErrorType 230440"];
8315 [label="param DecodeType(this) 230441"];
8316 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 230442"];
8317 [label="param DecodeNamedType(this) 230443"];
8318 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 230444"];
8319 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 230445"];
8320 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 230446"];
8321 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 230447"];
8322 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 230448"];
8323 [label="DecodeTypeArguments(typeArgs) 230449"];
8324 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 230450"];
8325 [label="param DecodeTypeArguments(this) 230451"];
8326 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 230452"];
8327 [label="return typeArgs; 230453"];
8328 [label="type.ContainingType 230454"];
8329 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 230455"];
8330 [label="return _container as NamedTypeSymbol; 230456"];
8331 [label="NamedTypeSymbol containingType = type.ContainingType; 230457"];
8332 [label="NamedTypeSymbol? decodedContainingType; 230458"];
8333 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 230459"];
8334 [label="decodedContainingType = containingType; 230460"];
8335 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 230461"];
8336 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 230462"];
8337 [label="var typeArgsChanged = typeArgs != decodedArgs; 230463"];
8338 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 230464"];
8339 [label="decodedType.IsTupleType 230465"];
8340 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 230466"];
8341 [label="_ 230467"];
8342 [label="tupleCardinality: out _ 230468"];
8343 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 230469"];
8344 [label="param IsTupleTypeOfCardinality(this) 230470"];
8345 [label="IsUnboundGenericType 230471"];
8346 [label="get\n            {\n                return false;\n            } 230472"];
8347 [label="return false; 230473"];
8348 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230474"];
8349 [label="ContainingSymbol 230475"];
8350 [label="get\n            {\n                return _container;\n            } 230476"];
8351 [label="return _container; 230477"];
8352 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230478"];
8353 [label=".Kind 230479"];
8354 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 230480"];
8355 [label="return SymbolKind.Namespace; 230481"];
8356 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230482"];
8357 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230483"];
8358 [label="ContainingNamespace 230484"];
8359 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 230485"];
8360 [label="get\n            {\n                return _container;\n            } 230486"];
8361 [label="return _container; 230487"];
8362 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230488"];
8363 [label="ContainingNamespace.ContainingNamespace 230489"];
8364 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 230490"];
8365 [label=".IsGlobalNamespace 230491"];
8366 [label="get\n            {\n                return true;\n            } 230492"];
8367 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230493"];
8368 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230494"];
8369 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230495"];
8370 [label="Name 230496"];
8371 [label="get\n            {\n                return _name;\n            } 230497"];
8372 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230498"];
8373 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230499"];
8374 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 230500"];
8375 [label="tupleCardinality = 0; 230501"];
8376 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 230502"];
8377 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 230503"];
8378 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 230504"];
8379 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 230505"];
8380 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 230506"];
8381 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 230507"];
8382 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 230508"];
8383 [label="typeSymbol.IsNullableType() 230509"];
8384 [label="param IsNullableType(this TypeSymbol type) 230510"];
8385 [label="type.OriginalDefinition 230511"];
8386 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 230512"];
8387 [label="OriginalTypeSymbolDefinition 230513"];
8388 [label="get\n            {\n                return this.OriginalDefinition;\n            } 230514"];
8389 [label="this.OriginalDefinition 230515"];
8390 [label="get\n            {\n                return this;\n            } 230516"];
8391 [label="return this.OriginalDefinition; 230517"];
8392 [label="return OriginalTypeSymbolDefinition; 230518"];
8393 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 230519"];
8394 [label="type.OriginalDefinition.SpecialType 230520"];
8395 [label="get\n            {\n                return _corTypeId;\n            } 230521"];
8396 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 230522"];
8397 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 230523"];
8398 [label="Extensions.Create(customModifiers) 230524"];
8399 [label="param Create(ImmutableArray<CustomModifier> customModifiers) 230525"];
8400 [label="if (customModifiers.IsEmpty)\n                {\n                    return Default;\n                } 230526"];
8401 [label="return Default; 230527"];
8402 [label="param TypeWithAnnotations(NullableAnnotation nullableAnnotation) 230528"];
8403 [label="param TypeWithAnnotations(Extensions extensions) 230529"];
8404 [label="var a1 = defaultType is null; 230530"];
8405 [label="!a1 230531"];
8406 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 230532"];
8407 [label="defaultType.IsNullableType() 230533"];
8408 [label="param IsNullableType(this TypeSymbol type) 230534"];
8409 [label="type.OriginalDefinition 230535"];
8410 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 230536"];
8411 [label="OriginalTypeSymbolDefinition 230537"];
8412 [label="get\n            {\n                return this.OriginalDefinition;\n            } 230538"];
8413 [label="this.OriginalDefinition 230539"];
8414 [label="get\n            {\n                return this;\n            } 230540"];
8415 [label="return this.OriginalDefinition; 230541"];
8416 [label="return OriginalTypeSymbolDefinition; 230542"];
8417 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 230543"];
8418 [label="type.OriginalDefinition.SpecialType 230544"];
8419 [label="get\n            {\n                return _corTypeId;\n            } 230545"];
8420 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 230546"];
8421 [label="Debug.Assert(a1 || a2 != true || a3); 230547"];
8422 [label="Debug.Assert(a1 || a2 != true || a3); 230548"];
8423 [label="Debug.Assert(extensions != null); 230549"];
8424 [label="Debug.Assert(extensions != null); 230550"];
8425 [label="NullableAnnotation 230551"];
8426 [label="_extensions 230552"];
8427 [label="param TransformType(Symbol accessSymbol) 230553"];
8428 [label="metadataType.HasType 230554"];
8429 [label="=> !(DefaultType is null) 230555"];
8430 [label="DefaultType is null 230556"];
8431 [label="!(DefaultType is null) 230557"];
8432 [label="Debug.Assert(metadataType.HasType); 230558"];
8433 [label="accessSymbol.IsDefinition 230559"];
8434 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 230560"];
8435 [label="OriginalDefinition 230561"];
8436 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 230562"];
8437 [label="OriginalSymbolDefinition 230563"];
8438 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 230564"];
8439 [label="this.OriginalTypeSymbolDefinition 230565"];
8440 [label="get\n            {\n                return this.OriginalDefinition;\n            } 230566"];
8441 [label="this.OriginalDefinition 230567"];
8442 [label="get\n            {\n                return this;\n            } 230568"];
8443 [label="return this.OriginalDefinition; 230569"];
8444 [label="return this.OriginalTypeSymbolDefinition; 230570"];
8445 [label="return OriginalSymbolDefinition; 230571"];
8446 [label="return (object)this == (object)OriginalDefinition; 230572"];
8447 [label="Debug.Assert(accessSymbol.IsDefinition); 230573"];
8448 [label="accessSymbol.ContainingModule 230574"];
8449 [label="get\n            {\n                return ContainingPEModule;\n            } 230575"];
8450 [label="ContainingPEModule 230576"];
8451 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 230577"];
8452 [label="s.Kind 230578"];
8453 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 230579"];
8454 [label="return SymbolKind.Namespace; 230580"];
8455 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 230581"];
8456 [label="return ContainingPEModule; 230582"];
8457 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 230583"];
8458 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 230584"];
8459 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 230585"];
8460 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 230586"];
8461 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 230587"];
8462 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 230588"];
8463 [label="Debug.Assert(symbol is object); 230589"];
8464 [label="symbol.Kind 230590"];
8465 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 230591"];
8466 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 230592"];
8467 [label="isInternal = false; 230593"];
8468 [label="symbol.DeclaredAccessibility 230594"];
8469 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 230595"];
8470 [label="Accessibility access = Accessibility.Private; 230596"];
8471 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 230597"];
8472 [label="symbol.ContainingType 230598"];
8473 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 230599"];
8474 [label="return _container as NamedTypeSymbol; 230600"];
8475 [label="symbol = symbol.ContainingType; 230601"];
8476 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 230602"];
8477 [label="return true; 230603"];
8478 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 230604"];
8479 [label="byte? value; 230605"];
8480 [label="param TryGetByte(out byte? value) 230606"];
8481 [label="value = null; 230607"];
8482 [label="s.Kind 230608"];
8483 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 230609"];
8484 [label="return SymbolKind.Namespace; 230610"];
8485 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 230611"];
8486 [label="param GetNullableContextValue(this) 230612"];
8487 [label="param GetLocalNullableContextValue(this) 230613"];
8488 [label="get\n            {\n                return _moduleSymbol;\n            } 230614"];
8489 [label="return _moduleSymbol; 230615"];
8490 [label="param GetLocalNullableContextValue(this) 230616"];
8491 [label="get\n            {\n                return _assemblySymbol;\n            } 230617"];
8492 [label="return _assemblySymbol; 230618"];
8493 [label="param GetLocalNullableContextValue(this) 230619"];
8494 [label="get\n            {\n                return null;\n            } 230620"];
8495 [label="=> defaultType 230621"];
8496 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 230622"];
8497 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 230623"];
8498 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 230624"];
8499 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure) 230625"];
8500 [label="param TypeDependsClosure(NamedTypeSymbol type) 230626"];
8501 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 230627"];
8502 [label="param TypeDependsClosure(HashSet<Symbol> partialClosure) 230628"];
8503 [label="if ((object)type == null)\n            {\n                return;\n            } 230629"];
8504 [label="if ((object)type == null)\n            {\n                return;\n            } 230630"];
8505 [label="this.SpecialType 230631"];
8506 [label="get\n            {\n                return _corTypeId;\n            } 230632"];
8507 [label="if (this.SpecialType == SpecialType.System_Object)\n            {\n                return (int)SpecialType.System_Object;\n            } 230633"];
8508 [label="return (int)SpecialType.System_Object; 230634"];
8509 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 230635"];
8510 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 230636"];
8511 [label="s.Kind 230637"];
8512 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 230638"];
8513 [label="return SymbolKind.Namespace; 230639"];
8514 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 230640"];
8515 [label="return null; 230641"];
8516 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 230642"];
8517 [label="if ((object)type == null)\n            {\n                return;\n            } 230643"];
8518 [label="if ((object)type == null)\n            {\n                return;\n            } 230644"];
8519 [label="return; 230645"];
8520 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 230646"];
8521 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 230647"];
8522 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 230648"];
8523 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 230649"];
8524 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 230650"];
8525 [label="var result = hs.Contains(on); 230651"];
8526 [label="var result = hs.Contains(on); 230652"];
8527 [label="var result = hs.Contains(on); 230653"];
8528 [label="this.SpecialType 230654"];
8529 [label="OriginalDefinition 230655"];
8530 [label="hs.Free(); 230656"];
8531 [label="return result; 230657"];
8532 [label="this.SetKnownToHaveNoDeclaredBaseCycles() 230658"];
8533 [label="param SetKnownToHaveNoDeclaredBaseCycles(this) 230659"];
8534 [label="_hasNoBaseCycles = true; 230660"];
8535 [label="_hasNoBaseCycles 230661"];
8536 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 230662"];
8537 [label="return declaredBase; 230663"];
8538 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 230664"];
8539 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 230665"];
8540 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 230666"];
8541 [label="return _lazyBaseType; 230667"];
8542 [label="NamedTypeSymbol @base = this.BaseTypeNoUseSiteDiagnostics; 230668"];
8543 [label="while ((object)@base != null)\n            {\n                if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                }\n\n                @base = @base.BaseTypeNoUseSiteDiagnostics;\n            } 230669"];
8544 [label="while ((object)@base != null)\n            {\n                if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                }\n\n                @base = @base.BaseTypeNoUseSiteDiagnostics;\n            } 230670"];
8545 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 230671"];
8546 [label="@base.IsErrorType() 230672"];
8547 [label="param IsErrorType(this TypeSymbol type) 230673"];
8548 [label="RoslynDebug.Assert((object)type != null); 230674"];
8549 [label="RoslynDebug.Assert((object)type != null); 230675"];
8550 [label="type.Kind 230676"];
8551 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 230677"];
8552 [label="return type.Kind == SymbolKind.ErrorType; 230678"];
8553 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 230679"];
8554 [label="@base.BaseTypeNoUseSiteDiagnostics 230680"];
8555 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 230681"];
8556 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 230682"];
8557 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 230683"];
8558 [label="Debug.Assert((object)depends != null); 230684"];
8559 [label="Debug.Assert((object)on != null); 230685"];
8560 [label="on.IsDefinition 230686"];
8561 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 230687"];
8562 [label="OriginalDefinition 230688"];
8563 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 230689"];
8564 [label="OriginalSymbolDefinition 230690"];
8565 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 230691"];
8566 [label="this.OriginalTypeSymbolDefinition 230692"];
8567 [label="get\n            {\n                return this.OriginalDefinition;\n            } 230693"];
8568 [label="this.OriginalDefinition 230694"];
8569 [label="get\n            {\n                return this;\n            } 230695"];
8570 [label="return this.OriginalDefinition; 230696"];
8571 [label="return this.OriginalTypeSymbolDefinition; 230697"];
8572 [label="return OriginalSymbolDefinition; 230698"];
8573 [label="return (object)this == (object)OriginalDefinition; 230699"];
8574 [label="Debug.Assert(on.IsDefinition); 230700"];
8575 [label="depends.DeclaringCompilation 230701"];
8576 [label="get { return null; } 230702"];
8577 [label="return null; 230703"];
8578 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 230704"];
8579 [label="if ((object)type == null)\n            {\n                return;\n            } 230705"];
8580 [label="return; 230706"];
8581 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 230707"];
8582 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 230708"];
8583 [label="return result; 230709"];
8584 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 230710"];
8585 [label="@base = @base.BaseTypeNoUseSiteDiagnostics; 230711"];
8586 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 230712"];
8587 [label="@base.IsErrorType() 230713"];
8588 [label="param IsErrorType(this TypeSymbol type) 230714"];
8589 [label="RoslynDebug.Assert((object)type != null); 230715"];
8590 [label="RoslynDebug.Assert((object)type != null); 230716"];
8591 [label="type.Kind 230717"];
8592 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 230718"];
8593 [label="return type.Kind == SymbolKind.ErrorType; 230719"];
8594 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 230720"];
8595 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 230721"];
8596 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 230722"];
8597 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 230723"];
8598 [label="return null; 230724"];
8599 [label="return null; 230725"];
8600 [label="if (MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()))\n            {\n                return result;\n            } 230726"];
8601 [label="MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()) 230727"];
8602 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 230728"];
8603 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 230729"];
8604 [label="param MergeUseSiteDiagnostics(this) 230730"];
8605 [label="if (info == null)\n            {\n                return false;\n            } 230731"];
8606 [label="if (info == null)\n            {\n                return false;\n            } 230732"];
8607 [label="return false; 230733"];
8608 [label="this.ContainingModule 230734"];
8609 [label="get\n            {\n                return ContainingPEModule;\n            } 230735"];
8610 [label="ContainingPEModule 230736"];
8611 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 230737"];
8612 [label="Symbol s = _container; 230738"];
8613 [label="s.Kind 230739"];
8614 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 230740"];
8615 [label="return SymbolKind.Namespace; 230741"];
8616 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 230742"];
8617 [label="((PENamespaceSymbol)s).ContainingPEModule 230743"];
8618 [label="return ContainingPEModule; 230744"];
8619 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 230745"];
8620 [label="this.ContainingModule.HasUnifiedReferences 230746"];
8621 [label="get { return GetUnifiedAssemblies().Length > 0; } 230747"];
8622 [label="GetUnifiedAssemblies() 230748"];
8623 [label="param GetUnifiedAssemblies(this) 230749"];
8624 [label="AssertReferencesInitialized() 230750"];
8625 [label="param AssertReferencesInitialized(this) 230751"];
8626 [label="Debug.Assert(_moduleReferences != null); 230752"];
8627 [label="Debug.Assert(_moduleReferences != null); 230753"];
8628 [label="AssertReferencesInitialized(); 230754"];
8629 [label="return GetUnifiedAssemblies().Length > 0; 230755"];
8630 [label="return GetUnifiedAssemblies().Length > 0; 230756"];
8631 [label="return result; 230757"];
8632 [label="if (!MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()))\n            {\n                // Check if this type is marked by RequiredAttribute attribute.\n                // If so mark the type as bad, because it relies upon semantics that are not understood by the C# compiler.\n                if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                }\n            } 230758"];
8633 [label="MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()) 230759"];
8634 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 230760"];
8635 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 230761"];
8636 [label="param MergeUseSiteDiagnostics(this) 230762"];
8637 [label="if (info == null)\n            {\n                return false;\n            } 230763"];
8638 [label="if (info == null)\n            {\n                return false;\n            } 230764"];
8639 [label="return false; 230765"];
8640 [label="this.ContainingPEModule 230766"];
8641 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 230767"];
8642 [label="Symbol s = _container; 230768"];
8643 [label="s.Kind 230769"];
8644 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 230770"];
8645 [label="return SymbolKind.Namespace; 230771"];
8646 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 230772"];
8647 [label="((PENamespaceSymbol)s).ContainingPEModule 230773"];
8648 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 230774"];
8649 [label="this.ContainingPEModule.Module 230775"];
8650 [label="get\n            {\n                return _module;\n            } 230776"];
8651 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 230777"];
8652 [label="TypeKind 230778"];
8653 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 230779"];
8654 [label="TypeKind result = _lazyKind; 230780"];
8655 [label="if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                } 230781"];
8656 [label="if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    } 230782"];
8657 [label="TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true); 230783"];
8658 [label="GetDeclaredBaseType(skipTransformsIfNecessary: true) 230784"];
8659 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 230785"];
8660 [label="TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true); 230786"];
8661 [label="result = TypeKind.Class; 230787"];
8662 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 230788"];
8663 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 230789"];
8664 [label="@base.SpecialType 230790"];
8665 [label="SpecialType baseCorTypeId = @base.SpecialType; 230791"];
8666 [label="switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            } 230792"];
8667 [label="this.SpecialType 230793"];
8668 [label="if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    } 230794"];
8669 [label="result = TypeKind.Struct; 230795"];
8670 [label="_lazyKind 230796"];
8671 [label="return result; 230797"];
8672 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 230798"];
8673 [label="return diagnostic; 230799"];
8674 [label="_lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl(); 230800"];
8675 [label="_lazyUseSiteDiagnostic 230801"];
8676 [label="return _lazyUseSiteDiagnostic; 230802"];
8677 [label="DiagnosticInfo info = symbol.GetUseSiteDiagnostic(); 230803"];
8678 [label="return info != null && Symbol.ReportUseSiteDiagnostic(info, diagnostics, node.Location); 230804"];
8679 [label="return info != null && Symbol.ReportUseSiteDiagnostic(info, diagnostics, node.Location); 230805"];
8680 [label="return typeSymbol; 230806"];
8681 [label="return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type); 230807"];
8682 [label="AreNullableAnnotationsEnabled(predefinedType.Keyword) 230808"];
8683 [label="param AreNullableAnnotationsEnabled(SyntaxToken token) 230809"];
8684 [label="param AreNullableAnnotationsEnabled(this) 230810"];
8685 [label="RoslynDebug.Assert(token.SyntaxTree is object); 230811"];
8686 [label="RoslynDebug.Assert(token.SyntaxTree is object); 230812"];
8687 [label="return AreNullableAnnotationsEnabled(token.SyntaxTree, token.SpanStart); 230813"];
8688 [label="AreNullableAnnotationsEnabled(token.SyntaxTree, token.SpanStart) 230814"];
8689 [label="param AreNullableAnnotationsEnabled(SyntaxTree syntaxTree) 230815"];
8690 [label="param AreNullableAnnotationsEnabled(int position) 230816"];
8691 [label="param AreNullableAnnotationsEnabled(this) 230817"];
8692 [label="CSharpSyntaxTree csTree = (CSharpSyntaxTree)syntaxTree; 230818"];
8693 [label="Syntax.NullableContextState context = csTree.GetNullableContextState(position); 230819"];
8694 [label="Syntax.NullableContextState context = csTree.GetNullableContextState(position); 230820"];
8695 [label="context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            } 230821"];
8696 [label="this.Compilation.Options 230822"];
8697 [label="get\n            {\n                return _options;\n            } 230823"];
8698 [label="return context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            }; 230824"];
8699 [label="return context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            }; 230825"];
8700 [label="AreNullableAnnotationsGloballyEnabled() 230826"];
8701 [label="param AreNullableAnnotationsGloballyEnabled(this) 230827"];
8702 [label="RoslynDebug.Assert(Next is object); 230828"];
8703 [label="RoslynDebug.Assert(Next is object); 230829"];
8704 [label="Next.AreNullableAnnotationsGloballyEnabled() 230830"];
8705 [label="param AreNullableAnnotationsGloballyEnabled(this) 230831"];
8706 [label="RoslynDebug.Assert(Next is object); 230832"];
8707 [label="param AreNullableAnnotationsGloballyEnabled(this) 230833"];
8708 [label="GetGlobalAnnotationState() 230834"];
8709 [label="param GetGlobalAnnotationState(this) 230835"];
8710 [label="Compilation.Options 230836"];
8711 [label="get\n            {\n                return _options;\n            } 230837"];
8712 [label="switch (Compilation.Options.NullableContextOptions)\n            {\n                case NullableContextOptions.Enable:\n                case NullableContextOptions.Annotations:\n                    return true;\n\n                case NullableContextOptions.Disable:\n                case NullableContextOptions.Warnings:\n                    return false;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(Compilation.Options.NullableContextOptions);\n            } 230838"];
8713 [label="return false; 230839"];
8714 [label="return GetGlobalAnnotationState(); 230840"];
8715 [label="return Next.AreNullableAnnotationsGloballyEnabled(); 230841"];
8716 [label="return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type); 230842"];
8717 [label="return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type); 230843"];
8718 [label="TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type) 230844"];
8719 [label="param Create(bool isNullableEnabled) 230845"];
8720 [label="param Create(TypeSymbol typeSymbol) 230846"];
8721 [label="param Create(bool isAnnotated = false) 230847"];
8722 [label="if (typeSymbol is null)\n            {\n                return default;\n            } 230848"];
8723 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 230849"];
8724 [label="isAnnotated 230850"];
8725 [label="isNullableEnabled 230851"];
8726 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 230852"];
8727 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 230853"];
8728 [label="Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious) 230854"];
8729 [label="param Create(TypeSymbol typeSymbol) 230855"];
8730 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 230856"];
8731 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 230857"];
8732 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 230858"];
8733 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 230859"];
8734 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 230860"];
8735 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 230861"];
8736 [label="typeSymbol.IsNullableType() 230862"];
8737 [label="param IsNullableType(this TypeSymbol type) 230863"];
8738 [label="type.OriginalDefinition 230864"];
8739 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 230865"];
8740 [label="OriginalTypeSymbolDefinition 230866"];
8741 [label="get\n            {\n                return this.OriginalDefinition;\n            } 230867"];
8742 [label="this.OriginalDefinition 230868"];
8743 [label="get\n            {\n                return this;\n            } 230869"];
8744 [label="return this.OriginalDefinition; 230870"];
8745 [label="return OriginalTypeSymbolDefinition; 230871"];
8746 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 230872"];
8747 [label="type.OriginalDefinition.SpecialType 230873"];
8748 [label="get\n            {\n                return _corTypeId;\n            } 230874"];
8749 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 230875"];
8750 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 230876"];
8751 [label="CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()) 230877"];
8752 [label="param CreateNonLazyType(TypeSymbol typeSymbol) 230878"];
8753 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 230879"];
8754 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 230880"];
8755 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 230881"];
8756 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 230882"];
8757 [label="Extensions.Create(customModifiers) 230883"];
8758 [label="param Create(ImmutableArray<CustomModifier> customModifiers) 230884"];
8759 [label="if (customModifiers.IsEmpty)\n                {\n                    return Default;\n                } 230885"];
8760 [label="return Default; 230886"];
8761 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 230887"];
8762 [label="new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)) 230888"];
8763 [label="param TypeWithAnnotations(TypeSymbol defaultType) 230889"];
8764 [label="param TypeWithAnnotations(NullableAnnotation nullableAnnotation) 230890"];
8765 [label="param TypeWithAnnotations(Extensions extensions) 230891"];
8766 [label="param TypeWithAnnotations(this) 230892"];
8767 [label="var a1 = defaultType is null; 230893"];
8768 [label="!a1 230894"];
8769 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 230895"];
8770 [label="defaultType.IsNullableType() 230896"];
8771 [label="param IsNullableType(this TypeSymbol type) 230897"];
8772 [label="type.OriginalDefinition 230898"];
8773 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 230899"];
8774 [label="OriginalTypeSymbolDefinition 230900"];
8775 [label="get\n            {\n                return this.OriginalDefinition;\n            } 230901"];
8776 [label="this.OriginalDefinition 230902"];
8777 [label="get\n            {\n                return this;\n            } 230903"];
8778 [label="return this; 230904"];
8779 [label="return this.OriginalDefinition; 230905"];
8780 [label="return OriginalTypeSymbolDefinition; 230906"];
8781 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 230907"];
8782 [label="type.OriginalDefinition.SpecialType 230908"];
8783 [label="get\n            {\n                return _corTypeId;\n            } 230909"];
8784 [label="return _corTypeId; 230910"];
8785 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 230911"];
8786 [label="Debug.Assert(a1 || a2 != true || a3); 230912"];
8787 [label="Debug.Assert(a1 || a2 != true || a3); 230913"];
8788 [label="Debug.Assert(extensions != null); 230914"];
8789 [label="Debug.Assert(extensions != null); 230915"];
8790 [label="DefaultType 230916"];
8791 [label="NullableAnnotation 230917"];
8792 [label="_extensions 230918"];
8793 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 230919"];
8794 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 230920"];
8795 [label="return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type); 230921"];
8796 [label="param operator(TypeWithAnnotations typeWithAnnotations) 230922"];
8797 [label="return new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations); 230923"];
8798 [label="return new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations); 230924"];
8799 [label="new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations) 230925"];
8800 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(TypeWithAnnotations typeWithAnnotations) 230926"];
8801 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(this) 230927"];
8802 [label="typeWithAnnotations.HasType 230928"];
8803 [label="=> !(DefaultType is null) 230929"];
8804 [label="DefaultType is null 230930"];
8805 [label="!(DefaultType is null) 230931"];
8806 [label="Debug.Assert(typeWithAnnotations.HasType); 230932"];
8807 [label="_typeWithAnnotations 230933"];
8808 [label="_symbol = null; 230934"];
8809 [label="_symbol 230935"];
8810 [label="_isNullableEnabled = false; 230936"];
8811 [label="_isNullableEnabled 230937"];
8812 [label="return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type); 230938"];
8813 [label="return bindPredefined(syntax, diagnostics); 230939"];
8814 [label="symbol.IsType 230940"];
8815 [label="=> !_typeWithAnnotations.IsDefault 230941"];
8816 [label="_typeWithAnnotations.IsDefault 230942"];
8817 [label="=> DefaultType is null && this.NullableAnnotation == 0 && (_extensions == null || _extensions == Extensions.Default) 230943"];
8818 [label="DefaultType is null 230944"];
8819 [label="DefaultType is null && this.NullableAnnotation == 0 230945"];
8820 [label="DefaultType is null && this.NullableAnnotation == 0 && (_extensions == null || _extensions == Extensions.Default) 230946"];
8821 [label="!_typeWithAnnotations.IsDefault 230947"];
8822 [label="if (symbol.IsType ||\n                (symbol.IsAlias && UnwrapAliasNoDiagnostics(symbol.Symbol, basesBeingResolved) is TypeSymbol))\n            {\n                if (symbol.IsType)\n                {\n                    // Obsolete alias targets are reported in UnwrapAlias, but if it was a type (not an\n                    // alias to a type) we report the obsolete type here.\n                    symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics);\n                }\n\n                return symbol;\n            } 230948"];
8823 [label="symbol.IsType 230949"];
8824 [label="if (symbol.IsType)\n                {\n                    // Obsolete alias targets are reported in UnwrapAlias, but if it was a type (not an\n                    // alias to a type) we report the obsolete type here.\n                    symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics);\n                } 230950"];
8825 [label="symbol.TypeWithAnnotations 230951"];
8826 [label="=> _typeWithAnnotations 230952"];
8827 [label="_typeWithAnnotations 230953"];
8828 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 230954"];
8829 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 230955"];
8830 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 230956"];
8831 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 230957"];
8832 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics) 230958"];
8833 [label="param ReportDiagnosticsIfObsolete(Binder binder) 230959"];
8834 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 230960"];
8835 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 230961"];
8836 [label="=>\n            _extensions.ReportDiagnosticsIfObsolete(this, binder, syntax, diagnostics) 230962"];
8837 [label="this 230963"];
8838 [label="binder 230964"];
8839 [label="syntax 230965"];
8840 [label="diagnostics 230966"];
8841 [label="_extensions.ReportDiagnosticsIfObsolete(this, binder, syntax, diagnostics) 230967"];
8842 [label="param ReportDiagnosticsIfObsolete(TypeWithAnnotations type) 230968"];
8843 [label="param ReportDiagnosticsIfObsolete(Binder binder) 230969"];
8844 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 230970"];
8845 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 230971"];
8846 [label="param ReportDiagnosticsIfObsolete(this) 230972"];
8847 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 230973"];
8848 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 230974"];
8849 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 230975"];
8850 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics) 230976"];
8851 [label="param ReportDiagnosticsIfObsoleteCore(Binder binder) 230977"];
8852 [label="param ReportDiagnosticsIfObsoleteCore(SyntaxNode syntax) 230978"];
8853 [label="param ReportDiagnosticsIfObsoleteCore(DiagnosticBag diagnostics) 230979"];
8854 [label="param ReportDiagnosticsIfObsoleteCore(this) 230980"];
8855 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 230981"];
8856 [label="Type 230982"];
8857 [label="=> _extensions?.GetResolvedType(DefaultType) 230983"];
8858 [label="DefaultType 230984"];
8859 [label=".GetResolvedType(DefaultType) 230985"];
8860 [label="param GetResolvedType(TypeSymbol defaultType) 230986"];
8861 [label="=> defaultType 230987"];
8862 [label="defaultType 230988"];
8863 [label="_extensions?.GetResolvedType(DefaultType) 230989"];
8864 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 230990"];
8865 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 230991"];
8866 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 230992"];
8867 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false) 230993"];
8868 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 230994"];
8869 [label="param ReportDiagnosticsIfObsolete(Symbol symbol) 230995"];
8870 [label="param ReportDiagnosticsIfObsolete(SyntaxNode node) 230996"];
8871 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 230997"];
8872 [label="param ReportDiagnosticsIfObsolete(this) 230998"];
8873 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 230999"];
8874 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 231000"];
8875 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 231001"];
8876 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 231002"];
8877 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver) 231003"];
8878 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 231004"];
8879 [label="param ReportDiagnosticsIfObsolete(Symbol symbol) 231005"];
8880 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 231006"];
8881 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 231007"];
8882 [label="param ReportDiagnosticsIfObsolete(this) 231008"];
8883 [label="symbol.Kind 231009"];
8884 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 231010"];
8885 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Event:\n                case SymbolKind.Property:\n                    ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags);\n                    break;\n            } 231011"];
8886 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 231012"];
8887 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 231013"];
8888 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 231014"];
8889 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 231015"];
8890 [label="this.ContainingMemberOrLambda 231016"];
8891 [label="get { return _containingMemberOrLambda; } 231017"];
8892 [label="return _containingMemberOrLambda; 231018"];
8893 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 231019"];
8894 [label="this.ContainingType 231020"];
8895 [label="get\n            {\n                var member = this.ContainingMemberOrLambda;\n                RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType);\n                return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                };\n            } 231021"];
8896 [label="this.ContainingMemberOrLambda 231022"];
8897 [label="get { return _containingMemberOrLambda; } 231023"];
8898 [label="return _containingMemberOrLambda; 231024"];
8899 [label="var member = this.ContainingMemberOrLambda; 231025"];
8900 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 231026"];
8901 [label="member.Kind 231027"];
8902 [label="get\n            {\n                return SymbolKind.Field;\n            } 231028"];
8903 [label="return SymbolKind.Field; 231029"];
8904 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 231030"];
8905 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 231031"];
8906 [label="member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                } 231032"];
8907 [label="member.ContainingType 231033"];
8908 [label="return this.containingType; 231034"];
8909 [label="return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                }; 231035"];
8910 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 231036"];
8911 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 231037"];
8912 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags) 231038"];
8913 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 231039"];
8914 [label="param ReportDiagnosticsIfObsolete(Symbol symbol) 231040"];
8915 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 231041"];
8916 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 231042"];
8917 [label="param ReportDiagnosticsIfObsolete(Symbol? containingMember) 231043"];
8918 [label="param ReportDiagnosticsIfObsolete(NamedTypeSymbol? containingType) 231044"];
8919 [label="param ReportDiagnosticsIfObsolete(BinderFlags location) 231045"];
8920 [label="RoslynDebug.Assert(symbol is object); 231046"];
8921 [label="RoslynDebug.Assert(symbol is object); 231047"];
8922 [label="symbol.Kind 231048"];
8923 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 231049"];
8924 [label="RoslynDebug.Assert(symbol.Kind == SymbolKind.NamedType ||\n                         symbol.Kind == SymbolKind.Field ||\n                         symbol.Kind == SymbolKind.Method ||\n                         symbol.Kind == SymbolKind.Event ||\n                         symbol.Kind == SymbolKind.Property); 231050"];
8925 [label="symbol.Kind 231051"];
8926 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 231052"];
8927 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                symbol = ((MethodSymbol)symbol).ConstructedFrom;\n            } 231053"];
8928 [label="Symbol leastOverriddenSymbol = symbol.GetLeastOverriddenMember(containingType); 231054"];
8929 [label="Symbol leastOverriddenSymbol = symbol.GetLeastOverriddenMember(containingType); 231055"];
8930 [label="symbol.GetLeastOverriddenMember(containingType) 231056"];
8931 [label="param GetLeastOverriddenMember(this Symbol member) 231057"];
8932 [label="param GetLeastOverriddenMember(NamedTypeSymbol accessingTypeOpt) 231058"];
8933 [label="member.Kind 231059"];
8934 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 231060"];
8935 [label="switch (member.Kind)\n            {\n                case SymbolKind.Method:\n                    var method = (MethodSymbol)member;\n                    return method.GetConstructedLeastOverriddenMethod(accessingTypeOpt, requireSameReturnType: false);\n\n                case SymbolKind.Property:\n                    var property = (PropertySymbol)member;\n                    return property.GetLeastOverriddenProperty(accessingTypeOpt);\n\n                case SymbolKind.Event:\n                    var evnt = (EventSymbol)member;\n                    return evnt.GetLeastOverriddenEvent(accessingTypeOpt);\n\n                default:\n                    return member;\n            } 231061"];
8936 [label="return member; 231062"];
8937 [label="bool checkOverridingSymbol = hasBaseReceiver && !ReferenceEquals(symbol, leastOverriddenSymbol); 231063"];
8938 [label="if (checkOverridingSymbol)\n            {\n                // If we have a base receiver, we must be done with declaration binding, so it should\n                // be safe to decode diagnostics.  We want to do this since reporting for the overriding\n                // member is conditional on reporting for the overridden member (i.e. we need a definite\n                // answer so we don't double-report).  You might think that double reporting just results\n                // in cascading diagnostics, but it's possible that the second diagnostic is an error\n                // while the first is merely a warning.\n                leastOverriddenSymbol.GetAttributes();\n            } 231064"];
8939 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 231065"];
8940 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 231066"];
8941 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 231067"];
8942 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 231068"];
8943 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 231069"];
8944 [label="ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location) 231070"];
8945 [label="param ReportDiagnosticsIfObsoleteInternal(DiagnosticBag diagnostics) 231071"];
8946 [label="param ReportDiagnosticsIfObsoleteInternal(Symbol symbol) 231072"];
8947 [label="param ReportDiagnosticsIfObsoleteInternal(SyntaxNodeOrToken node) 231073"];
8948 [label="param ReportDiagnosticsIfObsoleteInternal(Symbol? containingMember) 231074"];
8949 [label="param ReportDiagnosticsIfObsoleteInternal(BinderFlags location) 231075"];
8950 [label="RoslynDebug.Assert(diagnostics != null); 231076"];
8951 [label="RoslynDebug.Assert(diagnostics != null); 231077"];
8952 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 231078"];
8953 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 231079"];
8954 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 231080"];
8955 [label="ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember) 231081"];
8956 [label="param GetObsoleteDiagnosticKind(Symbol symbol) 231082"];
8957 [label="param GetObsoleteDiagnosticKind(Symbol containingMember) 231083"];
8958 [label="param GetObsoleteDiagnosticKind(bool forceComplete = false) 231084"];
8959 [label="symbol.ObsoleteKind 231085"];
8960 [label="get\n            {\n                var data = this.ObsoleteAttributeData;\n                return (data == null) ? ObsoleteAttributeKind.None : data.Kind;\n            } 231086"];
8961 [label="this.ObsoleteAttributeData 231087"];
8962 [label="get\n            {\n                var uncommon = GetUncommonProperties();\n                if (uncommon == s_noUncommonProperties)\n                {\n                    return null;\n                }\n\n                bool ignoreByRefLikeMarker = this.IsRefLikeType;\n                ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker);\n                return uncommon.lazyObsoleteAttributeData;\n            } 231088"];
8963 [label="GetUncommonProperties() 231089"];
8964 [label="param GetUncommonProperties(this) 231090"];
8965 [label="var result = _lazyUncommonProperties; 231091"];
8966 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 231092"];
8967 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 231093"];
8968 [label="this.IsUncommon() 231094"];
8969 [label="param IsUncommon(this) 231095"];
8970 [label="this.ContainingPEModule 231096"];
8971 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 231097"];
8972 [label="Symbol s = _container; 231098"];
8973 [label="s.Kind 231099"];
8974 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 231100"];
8975 [label="return SymbolKind.Namespace; 231101"];
8976 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 231102"];
8977 [label="((PENamespaceSymbol)s).ContainingPEModule 231103"];
8978 [label="if (this.ContainingPEModule.HasAnyCustomAttributes(_handle))\n            {\n                return true;\n            } 231104"];
8979 [label="if (this.ContainingPEModule.HasAnyCustomAttributes(_handle))\n            {\n                return true;\n            } 231105"];
8980 [label="this.ContainingPEModule.HasAnyCustomAttributes(_handle) 231106"];
8981 [label="param HasAnyCustomAttributes(EntityHandle token) 231107"];
8982 [label="param HasAnyCustomAttributes(this) 231108"];
8983 [label="foreach (var attr in _module.GetCustomAttributesOrThrow(token))\n                {\n                    return true;\n                } 231109"];
8984 [label="foreach (var attr in _module.GetCustomAttributesOrThrow(token))\n                {\n                    return true;\n                } 231110"];
8985 [label="return true; 231111"];
8986 [label="return true; 231112"];
8987 [label="if (this.IsUncommon())\n            {\n                result = new UncommonProperties();\n                return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result;\n            } 231113"];
8988 [label="result = new UncommonProperties(); 231114"];
8989 [label="new UncommonProperties() 231115"];
8990 [label="param UncommonProperties(this) 231116"];
8991 [label="lazyEnumUnderlyingType 231117"];
8992 [label="lazyObsoleteAttributeData = ObsoleteAttributeData.Uninitialized 231118"];
8993 [label="lazyAttributeUsageInfo = AttributeUsageInfo.Null 231119"];
8994 [label="lazyContainsExtensionMethods 231120"];
8995 [label="lazyIsByRefLike 231121"];
8996 [label="lazyIsReadOnly 231122"];
8997 [label="lazyDefaultMemberName 231123"];
8998 [label="lazyComImportCoClassType = ErrorTypeSymbol.UnknownResultType 231124"];
8999 [label="lazyHasEmbeddedAttribute = ThreeState.Unknown 231125"];
9000 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 231126"];
9001 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 231127"];
9002 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 231128"];
9003 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 231129"];
9004 [label="var uncommon = GetUncommonProperties(); 231130"];
9005 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return null;\n                } 231131"];
9006 [label="this.IsRefLikeType 231132"];
9007 [label="get\n            {\n                var uncommon = GetUncommonProperties();\n                if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                }\n\n                if (!uncommon.lazyIsByRefLike.HasValue())\n                {\n                    var isByRefLike = ThreeState.False;\n\n                    if (this.TypeKind == TypeKind.Struct)\n                    {\n                        var moduleSymbol = this.ContainingPEModule;\n                        var module = moduleSymbol.Module;\n                        isByRefLike = module.HasIsByRefLikeAttribute(_handle).ToThreeState();\n                    }\n\n                    uncommon.lazyIsByRefLike = isByRefLike;\n                }\n\n                return uncommon.lazyIsByRefLike.Value();\n            } 231133"];
9008 [label="GetUncommonProperties() 231134"];
9009 [label="param GetUncommonProperties(this) 231135"];
9010 [label="var result = _lazyUncommonProperties; 231136"];
9011 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 231137"];
9012 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 231138"];
9013 [label="Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified'); 231139"];
9014 [label="Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified'); 231140"];
9015 [label="return result; 231141"];
9016 [label="var uncommon = GetUncommonProperties(); 231142"];
9017 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                } 231143"];
9018 [label="if (!uncommon.lazyIsByRefLike.HasValue())\n                {\n                    var isByRefLike = ThreeState.False;\n\n                    if (this.TypeKind == TypeKind.Struct)\n                    {\n                        var moduleSymbol = this.ContainingPEModule;\n                        var module = moduleSymbol.Module;\n                        isByRefLike = module.HasIsByRefLikeAttribute(_handle).ToThreeState();\n                    }\n\n                    uncommon.lazyIsByRefLike = isByRefLike;\n                } 231144"];
9019 [label="var isByRefLike = ThreeState.False; 231145"];
9020 [label="this.TypeKind 231146"];
9021 [label="return result; 231147"];
9022 [label="if (this.TypeKind == TypeKind.Struct)\n                    {\n                        var moduleSymbol = this.ContainingPEModule;\n                        var module = moduleSymbol.Module;\n                        isByRefLike = module.HasIsByRefLikeAttribute(_handle).ToThreeState();\n                    } 231148"];
9023 [label="this.ContainingPEModule 231149"];
9024 [label="s.Kind 231150"];
9025 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 231151"];
9026 [label="return SymbolKind.Namespace; 231152"];
9027 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 231153"];
9028 [label="var moduleSymbol = this.ContainingPEModule; 231154"];
9029 [label="moduleSymbol.Module 231155"];
9030 [label="get\n            {\n                return _module;\n            } 231156"];
9031 [label="var module = moduleSymbol.Module; 231157"];
9032 [label="isByRefLike = module.HasIsByRefLikeAttribute(_handle).ToThreeState(); 231158"];
9033 [label="isByRefLike = module.HasIsByRefLikeAttribute(_handle).ToThreeState(); 231159"];
9034 [label="uncommon.lazyIsByRefLike 231160"];
9035 [label="return uncommon.lazyIsByRefLike.Value(); 231161"];
9036 [label="bool ignoreByRefLikeMarker = this.IsRefLikeType; 231162"];
9037 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker); 231163"];
9038 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker); 231164"];
9039 [label="ContainingPEModule 231165"];
9040 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 231166"];
9041 [label="Symbol s = _container; 231167"];
9042 [label="s.Kind 231168"];
9043 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 231169"];
9044 [label="return SymbolKind.Namespace; 231170"];
9045 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 231171"];
9046 [label="((PENamespaceSymbol)s).ContainingPEModule 231172"];
9047 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker); 231173"];
9048 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker); 231174"];
9049 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker) 231175"];
9050 [label="param InitializeObsoleteDataFromMetadata(ref ObsoleteAttributeData data) 231176"];
9051 [label="param InitializeObsoleteDataFromMetadata(EntityHandle token) 231177"];
9052 [label="param InitializeObsoleteDataFromMetadata(PEModuleSymbol containingModule) 231178"];
9053 [label="param InitializeObsoleteDataFromMetadata(bool ignoreByRefLikeMarker) 231179"];
9054 [label="if (ReferenceEquals(data, ObsoleteAttributeData.Uninitialized))\n            {\n                ObsoleteAttributeData obsoleteAttributeData = GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker);\n                Interlocked.CompareExchange(ref data, obsoleteAttributeData, ObsoleteAttributeData.Uninitialized);\n            } 231180"];
9055 [label="if (ReferenceEquals(data, ObsoleteAttributeData.Uninitialized))\n            {\n                ObsoleteAttributeData obsoleteAttributeData = GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker);\n                Interlocked.CompareExchange(ref data, obsoleteAttributeData, ObsoleteAttributeData.Uninitialized);\n            } 231181"];
9056 [label="ObsoleteAttributeData obsoleteAttributeData = GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker); 231182"];
9057 [label="ObsoleteAttributeData obsoleteAttributeData = GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker); 231183"];
9058 [label="ObsoleteAttributeData obsoleteAttributeData = GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker); 231184"];
9059 [label="GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker) 231185"];
9060 [label="param GetObsoleteDataFromMetadata(EntityHandle token) 231186"];
9061 [label="param GetObsoleteDataFromMetadata(PEModuleSymbol containingModule) 231187"];
9062 [label="param GetObsoleteDataFromMetadata(bool ignoreByRefLikeMarker) 231188"];
9063 [label="containingModule.Module 231189"];
9064 [label="get\n            {\n                return _module;\n            } 231190"];
9065 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 231191"];
9066 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 231192"];
9067 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 231193"];
9068 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 231194"];
9069 [label="new MetadataDecoder(containingModule) 231195"];
9070 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 231196"];
9071 [label="param MetadataDecoder(this) 231197"];
9072 [label="moduleSymbol 231198"];
9073 [label="null 231199"];
9074 [label="null 231200"];
9075 [label="param MetadataDecoder(this) 231201"];
9076 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 231202"];
9077 [label="param MetadataDecoder(PENamedTypeSymbol typeContextOpt) 231203"];
9078 [label="param MetadataDecoder(PEMethodSymbol methodContextOpt) 231204"];
9079 [label="return _assembly.Identity; 231205"];
9080 [label="Debug.Assert((object)moduleSymbol != null); 231206"];
9081 [label="Debug.Assert((object)moduleSymbol != null); 231207"];
9082 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 231208"];
9083 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 231209"];
9084 [label="Debug.Assert(obsoleteAttributeData == null || !obsoleteAttributeData.IsUninitialized); 231210"];
9085 [label="Debug.Assert(obsoleteAttributeData == null || !obsoleteAttributeData.IsUninitialized); 231211"];
9086 [label="return obsoleteAttributeData; 231212"];
9087 [label="Interlocked.CompareExchange(ref data, obsoleteAttributeData, ObsoleteAttributeData.Uninitialized); 231213"];
9088 [label="Interlocked.CompareExchange(ref data, obsoleteAttributeData, ObsoleteAttributeData.Uninitialized); 231214"];
9089 [label="Interlocked.CompareExchange(ref data, obsoleteAttributeData, ObsoleteAttributeData.Uninitialized); 231215"];
9090 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker); 231216"];
9091 [label="return uncommon.lazyObsoleteAttributeData; 231217"];
9092 [label="var data = this.ObsoleteAttributeData; 231218"];
9093 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 231219"];
9094 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 231220"];
9095 [label="(data == null) 231221"];
9096 [label="switch (symbol.ObsoleteKind)\n            {\n                case ObsoleteAttributeKind.None:\n                    return ObsoleteDiagnosticKind.NotObsolete;\n                case ObsoleteAttributeKind.Experimental:\n                    return ObsoleteDiagnosticKind.Diagnostic;\n                case ObsoleteAttributeKind.Uninitialized:\n                    // If we haven't cracked attributes on the symbol at all or we haven't\n                    // cracked attribute arguments enough to be able to report diagnostics for\n                    // ObsoleteAttribute, store the symbol so that we can report diagnostics at a \n                    // later stage.\n                    return ObsoleteDiagnosticKind.Lazy;\n            } 231222"];
9097 [label="return ObsoleteDiagnosticKind.NotObsolete; 231223"];
9098 [label="DiagnosticInfo? info = null; 231224"];
9099 [label="switch (kind)\n            {\n                case ObsoleteDiagnosticKind.Diagnostic:\n                    info = ObsoleteAttributeHelpers.CreateObsoleteDiagnostic(symbol, location);\n                    break;\n                case ObsoleteDiagnosticKind.Lazy:\n                case ObsoleteDiagnosticKind.LazyPotentiallySuppressed:\n                    info = new LazyObsoleteDiagnosticInfo(symbol, containingMember, location);\n                    break;\n            } 231225"];
9100 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 231226"];
9101 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 231227"];
9102 [label="return kind; 231228"];
9103 [label="switch (diagnosticKind)\n            {\n                case ObsoleteDiagnosticKind.NotObsolete:\n                case ObsoleteDiagnosticKind.Lazy:\n                    if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    }\n                    break;\n            } 231229"];
9104 [label="if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    } 231230"];
9105 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 231231"];
9106 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 231232"];
9107 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 231233"];
9108 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 231234"];
9109 [label="return symbol; 231235"];
9110 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 231236"];
9111 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 231237"];
9112 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 231238"];
9113 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 231239"];
9114 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved) 231240"];
9115 [label="param UnwrapAlias(in NamespaceOrTypeOrAliasSymbolWithAnnotations symbol) 231241"];
9116 [label="param UnwrapAlias(DiagnosticBag diagnostics) 231242"];
9117 [label="param UnwrapAlias(SyntaxNode syntax) 231243"];
9118 [label="param UnwrapAlias(ConsList<TypeSymbol> basesBeingResolved = null) 231244"];
9119 [label="param UnwrapAlias(this) 231245"];
9120 [label="symbol.IsAlias 231246"];
9121 [label="=> _symbol?.Kind == SymbolKind.Alias 231247"];
9122 [label="_symbol 231248"];
9123 [label="_symbol?.Kind == SymbolKind.Alias 231249"];
9124 [label="if (symbol.IsAlias)\n            {\n                AliasSymbol discarded;\n                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out discarded, diagnostics, syntax, basesBeingResolved));\n            } 231250"];
9125 [label="return symbol; 231251"];
9126 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations 231252"];
9127 [label="=> _typeWithAnnotations 231253"];
9128 [label="_typeWithAnnotations 231254"];
9129 [label="type.IsStatic 231255"];
9130 [label="=>\n            _extensions.IsStatic(DefaultType) 231256"];
9131 [label="DefaultType 231257"];
9132 [label="_extensions.IsStatic(DefaultType) 231258"];
9133 [label="param IsStatic(TypeSymbol typeSymbol) 231259"];
9134 [label="=> typeSymbol.IsStatic 231260"];
9135 [label="typeSymbol.IsStatic 231261"];
9136 [label="get\n            {\n                return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0;\n            } 231262"];
9137 [label="return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0; 231263"];
9138 [label="return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0; 231264"];
9139 [label="if (type.IsStatic)\n            {\n                // CS0719: '{0}': array elements cannot be of static type\n                Error(diagnostics, ErrorCode.ERR_ArrayOfStaticClass, node.ElementType, type.Type);\n            } 231265"];
9140 [label="if (disallowRestrictedTypes)\n            {\n                // Restricted types cannot be on the heap, but they can be on the stack, so are allowed in a stackalloc\n                if (ShouldCheckConstraints)\n                {\n                    if (type.IsRestrictedType())\n                    {\n                        // CS0611: Array elements cannot be of type '{0}'\n                        Error(diagnostics, ErrorCode.ERR_ArrayElementCantBeRefAny, node.ElementType, type.Type);\n                    }\n                }\n                else\n                {\n                    diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation());\n                }\n            } 231266"];
9141 [label="ShouldCheckConstraints 231267"];
9142 [label="get\n            {\n                return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks);\n            } 231268"];
9143 [label="return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks); 231269"];
9144 [label="return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks); 231270"];
9145 [label="this.Flags.Includes(BinderFlags.SuppressConstraintChecks) 231271"];
9146 [label="param Includes(this BinderFlags self) 231272"];
9147 [label="param Includes(BinderFlags other) 231273"];
9148 [label="if (ShouldCheckConstraints)\n                {\n                    if (type.IsRestrictedType())\n                    {\n                        // CS0611: Array elements cannot be of type '{0}'\n                        Error(diagnostics, ErrorCode.ERR_ArrayElementCantBeRefAny, node.ElementType, type.Type);\n                    }\n                }\n                else\n                {\n                    diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation());\n                } 231274"];
9149 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()); 231275"];
9150 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()); 231276"];
9151 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()); 231277"];
9152 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()); 231278"];
9153 [label="for (int i = node.RankSpecifiers.Count - 1; i >= 0; i--)\n            {\n                var rankSpecifier = node.RankSpecifiers[i];\n                var dimension = rankSpecifier.Sizes;\n                if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                }\n\n                var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank);\n                type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array);\n            } 231279"];
9154 [label="for (int i = node.RankSpecifiers.Count - 1; i >= 0; i--)\n            {\n                var rankSpecifier = node.RankSpecifiers[i];\n                var dimension = rankSpecifier.Sizes;\n                if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                }\n\n                var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank);\n                type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array);\n            } 231280"];
9155 [label="var rankSpecifier = node.RankSpecifiers[i]; 231281"];
9156 [label="var dimension = rankSpecifier.Sizes; 231282"];
9157 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 231283"];
9158 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 231284"];
9159 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 231285"];
9160 [label="this.Compilation.Assembly 231286"];
9161 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 231287"];
9162 [label="return _referenceManager; 231288"];
9163 [label="GetBoundReferenceManager(); 231289"];
9164 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 231290"];
9165 [label="var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank); 231291"];
9166 [label="var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank); 231292"];
9167 [label="var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank); 231293"];
9168 [label="ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank) 231294"];
9169 [label="param CreateCSharpArray(AssemblySymbol declaringAssembly) 231295"];
9170 [label="param CreateCSharpArray(TypeWithAnnotations elementTypeWithAnnotations) 231296"];
9171 [label="param CreateCSharpArray(int rank = 1) 231297"];
9172 [label="if (rank == 1)\n            {\n                return CreateSZArray(declaringAssembly, elementTypeWithAnnotations);\n            } 231298"];
9173 [label="if (rank == 1)\n            {\n                return CreateSZArray(declaringAssembly, elementTypeWithAnnotations);\n            } 231299"];
9174 [label="return CreateSZArray(declaringAssembly, elementTypeWithAnnotations); 231300"];
9175 [label="return CreateSZArray(declaringAssembly, elementTypeWithAnnotations); 231301"];
9176 [label="CreateSZArray(declaringAssembly, elementTypeWithAnnotations) 231302"];
9177 [label="param CreateSZArray(AssemblySymbol declaringAssembly) 231303"];
9178 [label="param CreateSZArray(TypeWithAnnotations elementType) 231304"];
9179 [label="return CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)); 231305"];
9180 [label="return CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)); 231306"];
9181 [label="declaringAssembly.GetSpecialType(SpecialType.System_Array) 231307"];
9182 [label="param GetSpecialType(SpecialType type) 231308"];
9183 [label="param GetSpecialType(this) 231309"];
9184 [label="this.Modules 231310"];
9185 [label="get\n            {\n                return _modules;\n            } 231311"];
9186 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 231312"];
9187 [label="module.GetReferencedAssemblies() 231313"];
9188 [label="param GetReferencedAssemblies(this) 231314"];
9189 [label="AssertReferencesInitialized() 231315"];
9190 [label="param AssertReferencesInitialized(this) 231316"];
9191 [label="Debug.Assert(_moduleReferences != null); 231317"];
9192 [label="Debug.Assert(_moduleReferences != null); 231318"];
9193 [label="AssertReferencesInitialized(); 231319"];
9194 [label="return _moduleReferences.Identities; 231320"];
9195 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 231321"];
9196 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 231322"];
9197 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 231323"];
9198 [label="return _lazySpecialTypes[(int)type]; 231324"];
9199 [label="return CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)); 231325"];
9200 [label="GetSZArrayInterfaces(elementType, declaringAssembly) 231326"];
9201 [label="param GetSZArrayInterfaces(TypeWithAnnotations elementTypeWithAnnotations) 231327"];
9202 [label="param GetSZArrayInterfaces(AssemblySymbol declaringAssembly) 231328"];
9203 [label="var constructedInterfaces = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 231329"];
9204 [label="var iListOfT = declaringAssembly.GetSpecialType(SpecialType.System_Collections_Generic_IList_T); 231330"];
9205 [label="declaringAssembly.GetSpecialType(SpecialType.System_Collections_Generic_IList_T) 231331"];
9206 [label="param GetSpecialType(SpecialType type) 231332"];
9207 [label="param GetSpecialType(this) 231333"];
9208 [label="this.Modules 231334"];
9209 [label="get\n            {\n                return _modules;\n            } 231335"];
9210 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 231336"];
9211 [label="module.GetReferencedAssemblies() 231337"];
9212 [label="param GetReferencedAssemblies(this) 231338"];
9213 [label="AssertReferencesInitialized() 231339"];
9214 [label="param AssertReferencesInitialized(this) 231340"];
9215 [label="Debug.Assert(_moduleReferences != null); 231341"];
9216 [label="Debug.Assert(_moduleReferences != null); 231342"];
9217 [label="AssertReferencesInitialized(); 231343"];
9218 [label="return _moduleReferences.Identities; 231344"];
9219 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 231345"];
9220 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 231346"];
9221 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 231347"];
9222 [label="NamedTypeSymbol result; 231348"];
9223 [label="NamespaceSymbol nextScope = null; 231349"];
9224 [label="EnsureAllMembersLoaded(); 231350"];
9225 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 231351"];
9226 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 231352"];
9227 [label="if ((object)scope == null)\n                {\n                    break;\n                } 231353"];
9228 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 231354"];
9229 [label="Debug.Assert(typesByNS != null); 231355"];
9230 [label="get\n            {\n                return false;\n            } 231356"];
9231 [label="ContainingNamespace 231357"];
9232 [label="var parent = ContainingNamespace; 231358"];
9233 [label=".IsGlobalNamespace 231359"];
9234 [label="get\n            {\n                return false;\n            } 231360"];
9235 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 231361"];
9236 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 231362"];
9237 [label="parent.Name 231363"];
9238 [label="get\n            {\n                return _name;\n            } 231364"];
9239 [label="length += parent.Name.Length + 1; 231365"];
9240 [label="length += parent.Name.Length + 1; 231366"];
9241 [label="parent.ContainingNamespace 231367"];
9242 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 231368"];
9243 [label="parent = parent.ContainingNamespace; 231369"];
9244 [label="get\n            {\n                return true;\n            } 231370"];
9245 [label="_containingNamespaceSymbol 231371"];
9246 [label="_name 231372"];
9247 [label="_typesByNS 231373"];
9248 [label="Debug.Assert(name != null); 231374"];
9249 [label="Debug.Assert((object)containingNamespace != null); 231375"];
9250 [label="Debug.Assert(typesByNS != null); 231376"];
9251 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 231377"];
9252 [label="genericParameterHandles 231378"];
9253 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 231379"];
9254 [label="param GetGenericInfo(out ushort arity) 231380"];
9255 [label="param GetGenericInfo(out BadImageFormatException mrEx) 231381"];
9256 [label="mrEx = null; 231382"];
9257 [label="PENamedTypeSymbol result; 231383"];
9258 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 231384"];
9259 [label="mangleName 231385"];
9260 [label="param PENamedTypeSymbol(out bool mangleName) 231386"];
9261 [label="_lazyTupleData 231387"];
9262 [label="_container 231388"];
9263 [label="_name 231389"];
9264 [label="_flags 231390"];
9265 [label="_corTypeId 231391"];
9266 [label="Debug.Assert(!handle.IsNil); 231392"];
9267 [label="Debug.Assert((object)container != null); 231393"];
9268 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 231394"];
9269 [label="string metadataName; 231395"];
9270 [label="bool makeBad = false; 231396"];
9271 [label="mangleName = false; 231397"];
9272 [label="Accessibility access = Accessibility.Private; 231398"];
9273 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 231399"];
9274 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 231400"];
9275 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 231401"];
9276 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 231402"];
9277 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 231403"];
9278 [label="bool added; 231404"];
9279 [label="Debug.Assert(added); 231405"];
9280 [label="Debug.Assert(typeId != SpecialType.None); 231406"];
9281 [label="corType.ContainingAssembly 231407"];
9282 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 231408"];
9283 [label="this.ContainingSymbol 231409"];
9284 [label="get\n            {\n                return _container;\n            } 231410"];
9285 [label="return _container; 231411"];
9286 [label="var container = this.ContainingSymbol; 231412"];
9287 [label="return (object)container != null ? container.ContainingAssembly : null; 231413"];
9288 [label="return (object)container != null ? container.ContainingAssembly : null; 231414"];
9289 [label="(object)container != null 231415"];
9290 [label="container.ContainingAssembly 231416"];
9291 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 231417"];
9292 [label="ContainingPEModule 231418"];
9293 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 231419"];
9294 [label="return ContainingPEModule.ContainingAssembly; 231420"];
9295 [label="ContainingPEModule.ContainingAssembly 231421"];
9296 [label="get\n            {\n                return _assemblySymbol;\n            } 231422"];
9297 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 231423"];
9298 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 231424"];
9299 [label="corType.ContainingModule 231425"];
9300 [label="get\n            {\n                return ContainingPEModule;\n            } 231426"];
9301 [label="ContainingPEModule 231427"];
9302 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 231428"];
9303 [label="s.Kind 231429"];
9304 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 231430"];
9305 [label="return SymbolKind.Namespace; 231431"];
9306 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 231432"];
9307 [label="return ContainingPEModule; 231433"];
9308 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 231434"];
9309 [label="corType.ContainingModule.Ordinal 231435"];
9310 [label="get\n            {\n                return _ordinal;\n            } 231436"];
9311 [label="return _ordinal; 231437"];
9312 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 231438"];
9313 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 231439"];
9314 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 231440"];
9315 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 231441"];
9316 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 231442"];
9317 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 231443"];
9318 [label="if ((object)scope == null)\n                {\n                    break;\n                } 231444"];
9319 [label="Debug.Assert(!emittedTypeName.IsNull); 231445"];
9320 [label="scope.Kind 231446"];
9321 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 231447"];
9322 [label="return SymbolKind.Namespace; 231448"];
9323 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 231449"];
9324 [label="NamedTypeSymbol? namedType = null; 231450"];
9325 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 231451"];
9326 [label="namespaceOrTypeMembers 231452"];
9327 [label="scope.IsNamespace 231453"];
9328 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 231454"];
9329 [label="Kind 231455"];
9330 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 231456"];
9331 [label="return SymbolKind.Namespace; 231457"];
9332 [label="return Kind == SymbolKind.Namespace; 231458"];
9333 [label="bool isTopLevel = scope.IsNamespace; 231459"];
9334 [label="param NamespaceOrTypeSymbol(this) 231460"];
9335 [label="param Symbol(this) 231461"];
9336 [label="_underlying 231462"];
9337 [label="Debug.Assert(underlying is object); 231463"];
9338 [label="param ToDisplayParts(bool minimal) 231464"];
9339 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 231465"];
9340 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 231466"];
9341 [label="Debug.Assert(semanticModelOpt == null); 231467"];
9342 [label="Debug.Assert(positionOpt < 0); 231468"];
9343 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 231469"];
9344 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 231470"];
9345 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 231471"];
9346 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 231472"];
9347 [label="return (TISymbol?)symbol?.ISymbol; 231473"];
9348 [label="var containingNamespace = symbol.ContainingNamespace; 231474"];
9349 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 231475"];
9350 [label="ShouldVisitNamespace(containingNamespace) 231476"];
9351 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 231477"];
9352 [label="param ShouldVisitNamespace(this) 231478"];
9353 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 231479"];
9354 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 231480"];
9355 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 231481"];
9356 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 231482"];
9357 [label="namespaceSymbol.IsGlobalNamespace 231483"];
9358 [label="=> _underlying.IsGlobalNamespace 231484"];
9359 [label="get\n            {\n                return false;\n            } 231485"];
9360 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 231486"];
9361 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 231487"];
9362 [label="containingNamespace.Accept(this.NotFirstVisitor); 231488"];
9363 [label="this.NotFirstVisitor 231489"];
9364 [label="param MakeNotFirstVisitor(bool inNamespaceOrType = false) 231490"];
9365 [label="param MakeNotFirstVisitor(this) 231491"];
9366 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 231492"];
9367 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 231493"];
9368 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 231494"];
9369 [label="new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType) 231495"];
9370 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 231496"];
9371 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 231497"];
9372 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 231498"];
9373 [label="param SymbolDisplayVisitor(int positionOpt) 231499"];
9374 [label="param SymbolDisplayVisitor(bool escapeKeywordIdentifiers) 231500"];
9375 [label="param SymbolDisplayVisitor(IDictionary<INamespaceOrTypeSymbol, IAliasSymbol> aliasMap) 231501"];
9376 [label="param SymbolDisplayVisitor(bool isFirstSymbolVisited) 231502"];
9377 [label="param SymbolDisplayVisitor(bool inNamespaceOrType = false) 231503"];
9378 [label="param SymbolDisplayVisitor(this) 231504"];
9379 [label="builder 231505"];
9380 [label="format 231506"];
9381 [label="isFirstSymbolVisited 231507"];
9382 [label="semanticModelOpt 231508"];
9383 [label="positionOpt 231509"];
9384 [label="inNamespaceOrType 231510"];
9385 [label="param SymbolDisplayVisitor(this) 231511"];
9386 [label="param SymbolDisplayVisitor(this) 231512"];
9387 [label="_escapeKeywordIdentifiers 231513"];
9388 [label="_lazyAliasMap 231514"];
9389 [label="containingNamespace.Accept(this.NotFirstVisitor); 231515"];
9390 [label="containingNamespace.Accept(this.NotFirstVisitor); 231516"];
9391 [label="containingNamespace.Accept(this.NotFirstVisitor) 231517"];
9392 [label="param Accept(SymbolVisitor visitor) 231518"];
9393 [label="param Accept(this) 231519"];
9394 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 231520"];
9395 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 231521"];
9396 [label="=> UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 231522"];
9397 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 231523"];
9398 [label="param ShouldVisitNamespace(this) 231524"];
9399 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 231525"];
9400 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 231526"];
9401 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 231527"];
9402 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 231528"];
9403 [label="=> _underlying.IsGlobalNamespace 231529"];
9404 [label="get\n            {\n                return false;\n            } 231530"];
9405 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 231531"];
9406 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 231532"];
9407 [label="get\n            {\n                return true;\n            } 231533"];
9408 [label="=> _underlying.IsGlobalNamespace 231534"];
9409 [label="get\n            {\n                return false;\n            } 231535"];
9410 [label="containingNamespace.IsGlobalNamespace 231536"];
9411 [label="=> _underlying.IsGlobalNamespace 231537"];
9412 [label="get\n            {\n                return false;\n            } 231538"];
9413 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 231539"];
9414 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 231540"];
9415 [label="param AddPunctuation(SyntaxKind punctuationKind) 231541"];
9416 [label="param AddPunctuation(this) 231542"];
9417 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 231543"];
9418 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 231544"];
9419 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 231545"];
9420 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 231546"];
9421 [label="param CreatePart(SymbolDisplayPartKind kind) 231547"];
9422 [label="param CreatePart(ISymbol symbol) 231548"];
9423 [label="param CreatePart(string text) 231549"];
9424 [label="param CreatePart(this) 231550"];
9425 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 231551"];
9426 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 231552"];
9427 [label="=> _underlying.IsGlobalNamespace 231553"];
9428 [label="get\n            {\n                return false;\n            } 231554"];
9429 [label="containingNamespace.Accept(this.NotFirstVisitor); 231555"];
9430 [label="containingNamespace.IsGlobalNamespace 231556"];
9431 [label="=> _underlying.IsGlobalNamespace 231557"];
9432 [label="get\n            {\n                return false;\n            } 231558"];
9433 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 231559"];
9434 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 231560"];
9435 [label="param AddPunctuation(SyntaxKind punctuationKind) 231561"];
9436 [label="param AddPunctuation(this) 231562"];
9437 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 231563"];
9438 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 231564"];
9439 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 231565"];
9440 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 231566"];
9441 [label="param CreatePart(SymbolDisplayPartKind kind) 231567"];
9442 [label="param CreatePart(ISymbol symbol) 231568"];
9443 [label="param CreatePart(string text) 231569"];
9444 [label="param CreatePart(this) 231570"];
9445 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 231571"];
9446 [label="=> _underlying.IsGlobalNamespace 231572"];
9447 [label="get\n            {\n                return false;\n            } 231573"];
9448 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 231574"];
9449 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 231575"];
9450 [label="Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0); 231576"];
9451 [label="Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0); 231577"];
9452 [label="if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                } 231578"];
9453 [label="namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName); 231579"];
9454 [label="scope.GetTypeMembers(emittedTypeName.UnmangledTypeName) 231580"];
9455 [label="param GetTypeMembers(string name) 231581"];
9456 [label="var typesByNS = _typesByNS; 231582"];
9457 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 231583"];
9458 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 231584"];
9459 [label="Debug.Assert(typesByNS != null); 231585"];
9460 [label="get\n            {\n                return false;\n            } 231586"];
9461 [label="parent.ContainingNamespace 231587"];
9462 [label="parent = parent.ContainingNamespace; 231588"];
9463 [label="get\n            {\n                return false;\n            } 231589"];
9464 [label="get\n            {\n                return true;\n            } 231590"];
9465 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 231591"];
9466 [label="genericParameterHandles 231592"];
9467 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 231593"];
9468 [label="param GetGenericInfo(out ushort arity) 231594"];
9469 [label="param GetGenericInfo(out BadImageFormatException mrEx) 231595"];
9470 [label="mrEx = null; 231596"];
9471 [label="PENamedTypeSymbol result; 231597"];
9472 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 231598"];
9473 [label="mangleName 231599"];
9474 [label="param PENamedTypeSymbol(out bool mangleName) 231600"];
9475 [label="_lazyTupleData 231601"];
9476 [label="_container 231602"];
9477 [label="_name 231603"];
9478 [label="_flags 231604"];
9479 [label="_corTypeId 231605"];
9480 [label="Debug.Assert(!handle.IsNil); 231606"];
9481 [label="Debug.Assert((object)container != null); 231607"];
9482 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 231608"];
9483 [label="string metadataName; 231609"];
9484 [label="bool makeBad = false; 231610"];
9485 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 231611"];
9486 [label="Accessibility access = Accessibility.Private; 231612"];
9487 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 231613"];
9488 [label="_arity 231614"];
9489 [label="_mangleName 231615"];
9490 [label="Debug.Assert(genericParameterHandles.Count > 0); 231616"];
9491 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 231617"];
9492 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 231618"];
9493 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 231619"];
9494 [label="mangleName 231620"];
9495 [label="param PENamedTypeSymbol(out bool mangleName) 231621"];
9496 [label="mangleName = false; 231622"];
9497 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 231623"];
9498 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 231624"];
9499 [label="bool added; 231625"];
9500 [label="Debug.Assert(added); 231626"];
9501 [label="Debug.Assert(typeId != SpecialType.None); 231627"];
9502 [label="corType.ContainingAssembly 231628"];
9503 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 231629"];
9504 [label="this.ContainingSymbol 231630"];
9505 [label="get\n            {\n                return _container;\n            } 231631"];
9506 [label="return _container; 231632"];
9507 [label="var container = this.ContainingSymbol; 231633"];
9508 [label="return (object)container != null ? container.ContainingAssembly : null; 231634"];
9509 [label="return (object)container != null ? container.ContainingAssembly : null; 231635"];
9510 [label="(object)container != null 231636"];
9511 [label="container.ContainingAssembly 231637"];
9512 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 231638"];
9513 [label="ContainingPEModule 231639"];
9514 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 231640"];
9515 [label="return ContainingPEModule.ContainingAssembly; 231641"];
9516 [label="ContainingPEModule.ContainingAssembly 231642"];
9517 [label="get\n            {\n                return _assemblySymbol;\n            } 231643"];
9518 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 231644"];
9519 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 231645"];
9520 [label="corType.ContainingModule 231646"];
9521 [label="get\n            {\n                return ContainingPEModule;\n            } 231647"];
9522 [label="ContainingPEModule 231648"];
9523 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 231649"];
9524 [label="s.Kind 231650"];
9525 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 231651"];
9526 [label="return SymbolKind.Namespace; 231652"];
9527 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 231653"];
9528 [label="return ContainingPEModule; 231654"];
9529 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 231655"];
9530 [label="corType.ContainingModule.Ordinal 231656"];
9531 [label="get\n            {\n                return _ordinal;\n            } 231657"];
9532 [label="return _ordinal; 231658"];
9533 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 231659"];
9534 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 231660"];
9535 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 231661"];
9536 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 231662"];
9537 [label="EnsureAllMembersLoaded(); 231663"];
9538 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 231664"];
9539 [label="foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    } 231665"];
9540 [label="named.Arity 231666"];
9541 [label="get\n                {\n                    return _arity;\n                } 231667"];
9542 [label="return _arity; 231668"];
9543 [label="if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        } 231669"];
9544 [label="named.MangleName 231670"];
9545 [label="get\n                {\n                    return _mangleName;\n                } 231671"];
9546 [label="return _mangleName; 231672"];
9547 [label="if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        } 231673"];
9548 [label="if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        } 231674"];
9549 [label="if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            } 231675"];
9550 [label="if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            } 231676"];
9551 [label="namedType = named; 231677"];
9552 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 231678"];
9553 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 231679"];
9554 [label="Debug.Assert((object)result != null); 231680"];
9555 [label="Debug.Assert((object)result != null); 231681"];
9556 [label="result.Kind 231682"];
9557 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 231683"];
9558 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 231684"];
9559 [label="result.DeclaredAccessibility 231685"];
9560 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 231686"];
9561 [label="Accessibility access = Accessibility.Private; 231687"];
9562 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 231688"];
9563 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 231689"];
9564 [label="Debug.Assert(typeId != SpecialType.None); 231690"];
9565 [label="corType.ContainingAssembly 231691"];
9566 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 231692"];
9567 [label="this.ContainingSymbol 231693"];
9568 [label="get\n            {\n                return _container;\n            } 231694"];
9569 [label="return _container; 231695"];
9570 [label="var container = this.ContainingSymbol; 231696"];
9571 [label="return (object)container != null ? container.ContainingAssembly : null; 231697"];
9572 [label="return (object)container != null ? container.ContainingAssembly : null; 231698"];
9573 [label="(object)container != null 231699"];
9574 [label="container.ContainingAssembly 231700"];
9575 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 231701"];
9576 [label="ContainingPEModule 231702"];
9577 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 231703"];
9578 [label="return ContainingPEModule.ContainingAssembly; 231704"];
9579 [label="ContainingPEModule.ContainingAssembly 231705"];
9580 [label="get\n            {\n                return _assemblySymbol;\n            } 231706"];
9581 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 231707"];
9582 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 231708"];
9583 [label="corType.ContainingModule 231709"];
9584 [label="get\n            {\n                return ContainingPEModule;\n            } 231710"];
9585 [label="ContainingPEModule 231711"];
9586 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 231712"];
9587 [label="s.Kind 231713"];
9588 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 231714"];
9589 [label="return SymbolKind.Namespace; 231715"];
9590 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 231716"];
9591 [label="return ContainingPEModule; 231717"];
9592 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 231718"];
9593 [label="corType.ContainingModule.Ordinal 231719"];
9594 [label="get\n            {\n                return _ordinal;\n            } 231720"];
9595 [label="return _ordinal; 231721"];
9596 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 231722"];
9597 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 231723"];
9598 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 231724"];
9599 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 231725"];
9600 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 231726"];
9601 [label="if (!iListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 231727"];
9602 [label="iListOfT.IsErrorType() 231728"];
9603 [label="param IsErrorType(this TypeSymbol type) 231729"];
9604 [label="RoslynDebug.Assert((object)type != null); 231730"];
9605 [label="RoslynDebug.Assert((object)type != null); 231731"];
9606 [label="type.Kind 231732"];
9607 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 231733"];
9608 [label="return type.Kind == SymbolKind.ErrorType; 231734"];
9609 [label="if (!iListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 231735"];
9610 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 231736"];
9611 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 231737"];
9612 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 231738"];
9613 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 231739"];
9614 [label="new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations)) 231740"];
9615 [label="param ConstructedNamedTypeSymbol(NamedTypeSymbol constructedFrom) 231741"];
9616 [label="param ConstructedNamedTypeSymbol(ImmutableArray<TypeWithAnnotations> typeArgumentsWithAnnotations) 231742"];
9617 [label="param ConstructedNamedTypeSymbol(bool unbound = false) 231743"];
9618 [label="param ConstructedNamedTypeSymbol(TupleExtraData tupleData = null) 231744"];
9619 [label="param ConstructedNamedTypeSymbol(this) 231745"];
9620 [label="constructedFrom.ContainingSymbol 231746"];
9621 [label="get\n            {\n                return _container;\n            } 231747"];
9622 [label="return _container; 231748"];
9623 [label="constructedFrom.ContainingType 231749"];
9624 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 231750"];
9625 [label="return _container as NamedTypeSymbol; 231751"];
9626 [label="constructedFrom.OriginalDefinition 231752"];
9627 [label="get\n            {\n                return this;\n            } 231753"];
9628 [label="constructedFrom.OriginalDefinition.TypeParameters 231754"];
9629 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 231755"];
9630 [label="EnsureTypeParametersAreLoaded() 231756"];
9631 [label="param EnsureTypeParametersAreLoaded(this) 231757"];
9632 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 231758"];
9633 [label="ContainingPEModule 231759"];
9634 [label="s.Kind 231760"];
9635 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 231761"];
9636 [label="return SymbolKind.Namespace; 231762"];
9637 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 231763"];
9638 [label="var moduleSymbol = ContainingPEModule; 231764"];
9639 [label="int firstIndex = _genericParameterHandles.Count - _arity; 231765"];
9640 [label="TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity]; 231766"];
9641 [label="for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    } 231767"];
9642 [label="for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    } 231768"];
9643 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 231769"];
9644 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 231770"];
9645 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 231771"];
9646 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 231772"];
9647 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 231773"];
9648 [label="new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]) 231774"];
9649 [label="param PETypeParameterSymbol(PEModuleSymbol moduleSymbol) 231775"];
9650 [label="param PETypeParameterSymbol(PENamedTypeSymbol definingNamedType) 231776"];
9651 [label="param PETypeParameterSymbol(ushort ordinal) 231777"];
9652 [label="param PETypeParameterSymbol(GenericParameterHandle handle) 231778"];
9653 [label="param PETypeParameterSymbol(this) 231779"];
9654 [label="moduleSymbol 231780"];
9655 [label="definingNamedType 231781"];
9656 [label="ordinal 231782"];
9657 [label="handle 231783"];
9658 [label="param PETypeParameterSymbol(this) 231784"];
9659 [label="param PETypeParameterSymbol(PEModuleSymbol moduleSymbol) 231785"];
9660 [label="param PETypeParameterSymbol(Symbol definingSymbol) 231786"];
9661 [label="param PETypeParameterSymbol(ushort ordinal) 231787"];
9662 [label="param PETypeParameterSymbol(GenericParameterHandle handle) 231788"];
9663 [label="param PETypeParameterSymbol(this) 231789"];
9664 [label="param PETypeParameterSymbol(this) 231790"];
9665 [label="param TypeParameterSymbol(this) 231791"];
9666 [label="param TypeParameterSymbol(this) 231792"];
9667 [label="_lazyAdapter 231793"];
9668 [label="_containingSymbol 231794"];
9669 [label="_name 231795"];
9670 [label="_ordinal 231796"];
9671 [label="_lazyConstraintsUseSiteErrorInfo = CSDiagnosticInfo.EmptyErrorInfo 231797"];
9672 [label="_flags 231798"];
9673 [label="_lazyHasIsUnmanagedConstraint 231799"];
9674 [label="new TypeParameterBounds() 231800"];
9675 [label="param TypeParameterBounds(this) 231801"];
9676 [label="EffectiveBaseClass 231802"];
9677 [label="DeducedBaseType 231803"];
9678 [label="EffectiveBaseClass = null!; 231804"];
9679 [label="EffectiveBaseClass 231805"];
9680 [label="DeducedBaseType = null!; 231806"];
9681 [label="DeducedBaseType 231807"];
9682 [label="Unset = new TypeParameterBounds() 231808"];
9683 [label="_lazyBounds = TypeParameterBounds.Unset 231809"];
9684 [label="Debug.Assert((object)moduleSymbol != null); 231810"];
9685 [label="Debug.Assert((object)moduleSymbol != null); 231811"];
9686 [label="Debug.Assert((object)definingSymbol != null); 231812"];
9687 [label="Debug.Assert((object)definingSymbol != null); 231813"];
9688 [label="Debug.Assert(ordinal >= 0); 231814"];
9689 [label="Debug.Assert(ordinal >= 0); 231815"];
9690 [label="Debug.Assert(!handle.IsNil); 231816"];
9691 [label="_containingSymbol 231817"];
9692 [label="GenericParameterAttributes flags = 0; 231818"];
9693 [label="moduleSymbol.Module 231819"];
9694 [label="get\n            {\n                return _module;\n            } 231820"];
9695 [label="return _module; 231821"];
9696 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 231822"];
9697 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 231823"];
9698 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 231824"];
9699 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 231825"];
9700 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 231826"];
9701 [label="_flags = ((flags & GenericParameterAttributes.NotNullableValueTypeConstraint) == 0) ? flags : (flags & ~GenericParameterAttributes.DefaultConstructorConstraint); 231827"];
9702 [label="_flags = ((flags & GenericParameterAttributes.NotNullableValueTypeConstraint) == 0) ? flags : (flags & ~GenericParameterAttributes.DefaultConstructorConstraint); 231828"];
9703 [label="((flags & GenericParameterAttributes.NotNullableValueTypeConstraint) == 0) 231829"];
9704 [label="_flags 231830"];
9705 [label="_ordinal 231831"];
9706 [label="_handle 231832"];
9707 [label="ownedParams[i] 231833"];
9708 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams)); 231834"];
9709 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams)); 231835"];
9710 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams)); 231836"];
9711 [label="EnsureTypeParametersAreLoaded(); 231837"];
9712 [label="return _lazyTypeParameters; 231838"];
9713 [label="t => t.Type 231839"];
9714 [label="AsTypeSymbol = t => t.Type 231840"];
9715 [label="ReferenceEqualityComparer.Instance 231841"];
9716 [label="new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance) 231842"];
9717 [label="s_emptyDictionary =\n            new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance) 231843"];
9718 [label="new TypeMap() 231844"];
9719 [label="param TypeMap(this) 231845"];
9720 [label="s_emptyDictionary 231846"];
9721 [label="param AbstractTypeParameterMap(SmallDictionary<TypeParameterSymbol, TypeWithAnnotations> mapping) 231847"];
9722 [label="param AbstractTypeParameterMap(this) 231848"];
9723 [label="param AbstractTypeMap(this) 231849"];
9724 [label="Mapping 231850"];
9725 [label="this.Mapping 231851"];
9726 [label="Debug.Assert(s_emptyDictionary.IsEmpty()); 231852"];
9727 [label="s_emptyTypeMap = new TypeMap() 231853"];
9728 [label="typeArgumentsWithAnnotations 231854"];
9729 [label="new TypeMap(constructedFrom.ContainingType, constructedFrom.OriginalDefinition.TypeParameters, typeArgumentsWithAnnotations) 231855"];
9730 [label="param TypeMap(NamedTypeSymbol containingType) 231856"];
9731 [label="param TypeMap(ImmutableArray<TypeParameterSymbol> typeParameters) 231857"];
9732 [label="param TypeMap(ImmutableArray<TypeWithAnnotations> typeArguments) 231858"];
9733 [label="param TypeMap(this) 231859"];
9734 [label="containingType 231860"];
9735 [label="ForType(containingType) 231861"];
9736 [label="param ForType(NamedTypeSymbol containingType) 231862"];
9737 [label="var substituted = containingType as SubstitutedNamedTypeSymbol; 231863"];
9738 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 231864"];
9739 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 231865"];
9740 [label="(object)substituted != null 231866"];
9741 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 231867"];
9742 [label="param AbstractTypeParameterMap(SmallDictionary<TypeParameterSymbol, TypeWithAnnotations> mapping) 231868"];
9743 [label="param AbstractTypeParameterMap(this) 231869"];
9744 [label="param AbstractTypeMap(this) 231870"];
9745 [label="Mapping 231871"];
9746 [label="this.Mapping 231872"];
9747 [label="for (int i = 0; i < typeParameters.Length; i++)\n            {\n                TypeParameterSymbol tp = typeParameters[i];\n                TypeWithAnnotations ta = typeArguments[i];\n                if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                }\n            } 231873"];
9748 [label="for (int i = 0; i < typeParameters.Length; i++)\n            {\n                TypeParameterSymbol tp = typeParameters[i];\n                TypeWithAnnotations ta = typeArguments[i];\n                if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                }\n            } 231874"];
9749 [label="TypeParameterSymbol tp = typeParameters[i]; 231875"];
9750 [label="TypeWithAnnotations ta = typeArguments[i]; 231876"];
9751 [label="if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                } 231877"];
9752 [label="ta.Is(tp) 231878"];
9753 [label="param Is(TypeParameterSymbol other) 231879"];
9754 [label="param Is(this) 231880"];
9755 [label="1 231881"];
9756 [label="NotAnnotatedAttributeValue = 1 231882"];
9757 [label="2 231883"];
9758 [label="AnnotatedAttributeValue = 2 231884"];
9759 [label="0 231885"];
9760 [label="ObliviousAttributeValue = 0 231886"];
9761 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 231887"];
9762 [label="NullableAnnotation.IsOblivious() 231888"];
9763 [label="param IsOblivious(this NullableAnnotation annotation) 231889"];
9764 [label="annotation == NullableAnnotation.Oblivious 231890"];
9765 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 231891"];
9766 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 231892"];
9767 [label="Mapping.Add(tp, ta); 231893"];
9768 [label="Mapping.Add(tp, ta); 231894"];
9769 [label="Mapping.Add(tp, ta); 231895"];
9770 [label="constructedFrom.OriginalDefinition 231896"];
9771 [label="get\n            {\n                return this;\n            } 231897"];
9772 [label="s_symbolAsMemberFunc = SymbolExtensions.SymbolAsMember 231898"];
9773 [label="constructedFrom 231899"];
9774 [label="unbound 231900"];
9775 [label="tupleData 231901"];
9776 [label="param ConstructedNamedTypeSymbol(this) 231902"];
9777 [label="param SubstitutedNamedTypeSymbol(Symbol newContainer) 231903"];
9778 [label="param SubstitutedNamedTypeSymbol(TypeMap map) 231904"];
9779 [label="param SubstitutedNamedTypeSymbol(NamedTypeSymbol originalDefinition) 231905"];
9780 [label="param SubstitutedNamedTypeSymbol(NamedTypeSymbol constructedFrom = null) 231906"];
9781 [label="param SubstitutedNamedTypeSymbol(bool unbound = false) 231907"];
9782 [label="param SubstitutedNamedTypeSymbol(TupleExtraData tupleData = null) 231908"];
9783 [label="param SubstitutedNamedTypeSymbol(this) 231909"];
9784 [label="originalDefinition 231910"];
9785 [label="tupleData 231911"];
9786 [label="param SubstitutedNamedTypeSymbol(this) 231912"];
9787 [label="param WrappedNamedTypeSymbol(NamedTypeSymbol underlyingType) 231913"];
9788 [label="param WrappedNamedTypeSymbol(TupleExtraData tupleData) 231914"];
9789 [label="param WrappedNamedTypeSymbol(this) 231915"];
9790 [label="tupleData 231916"];
9791 [label="param WrappedNamedTypeSymbol(this) 231917"];
9792 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 231918"];
9793 [label="_lazyTupleData 231919"];
9794 [label="_underlyingType 231920"];
9795 [label="Debug.Assert((object)underlyingType != null); 231921"];
9796 [label="Debug.Assert((object)underlyingType != null); 231922"];
9797 [label="_underlyingType 231923"];
9798 [label="_unbound 231924"];
9799 [label="_inputMap 231925"];
9800 [label="_newContainer 231926"];
9801 [label="_lazyMap 231927"];
9802 [label="_hashCode 231928"];
9803 [label="_lazyMembersByNameCache 231929"];
9804 [label="originalDefinition.IsDefinition 231930"];
9805 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 231931"];
9806 [label="OriginalDefinition 231932"];
9807 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 231933"];
9808 [label="OriginalSymbolDefinition 231934"];
9809 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 231935"];
9810 [label="this.OriginalTypeSymbolDefinition 231936"];
9811 [label="get\n            {\n                return this.OriginalDefinition;\n            } 231937"];
9812 [label="this.OriginalDefinition 231938"];
9813 [label="get\n            {\n                return this;\n            } 231939"];
9814 [label="return this.OriginalDefinition; 231940"];
9815 [label="return this.OriginalTypeSymbolDefinition; 231941"];
9816 [label="return OriginalSymbolDefinition; 231942"];
9817 [label="return (object)this == (object)OriginalDefinition; 231943"];
9818 [label="Debug.Assert(originalDefinition.IsDefinition); 231944"];
9819 [label="Debug.Assert(!originalDefinition.IsErrorType()); 231945"];
9820 [label="originalDefinition.IsErrorType() 231946"];
9821 [label="param IsErrorType(this TypeSymbol type) 231947"];
9822 [label="RoslynDebug.Assert((object)type != null); 231948"];
9823 [label="RoslynDebug.Assert((object)type != null); 231949"];
9824 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 231950"];
9825 [label="Debug.Assert(!originalDefinition.IsErrorType()); 231951"];
9826 [label="_newContainer 231952"];
9827 [label="_inputMap 231953"];
9828 [label="_unbound 231954"];
9829 [label="if ((object)constructedFrom != null)\n            {\n                Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom));\n                _lazyTypeParameters = constructedFrom.TypeParameters;\n                _lazyMap = map;\n            } 231955"];
9830 [label="if ((object)constructedFrom != null)\n            {\n                Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom));\n                _lazyTypeParameters = constructedFrom.TypeParameters;\n                _lazyMap = map;\n            } 231956"];
9831 [label="constructedFrom.ConstructedFrom 231957"];
9832 [label="get\n            {\n                return this;\n            } 231958"];
9833 [label="return this; 231959"];
9834 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 231960"];
9835 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 231961"];
9836 [label="constructedFrom.TypeParameters 231962"];
9837 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 231963"];
9838 [label="EnsureTypeParametersAreLoaded() 231964"];
9839 [label="param EnsureTypeParametersAreLoaded(this) 231965"];
9840 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 231966"];
9841 [label="EnsureTypeParametersAreLoaded(); 231967"];
9842 [label="return _lazyTypeParameters; 231968"];
9843 [label="_lazyTypeParameters = constructedFrom.TypeParameters; 231969"];
9844 [label="_lazyTypeParameters 231970"];
9845 [label="_lazyMap 231971"];
9846 [label="_constructedFrom 231972"];
9847 [label="_typeArgumentsWithAnnotations 231973"];
9848 [label="_constructedFrom 231974"];
9849 [label="constructedFrom.Arity 231975"];
9850 [label="get\n                {\n                    return _arity;\n                } 231976"];
9851 [label="return _arity; 231977"];
9852 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 231978"];
9853 [label="constructedFrom.Arity 231979"];
9854 [label="get\n                {\n                    return _arity;\n                } 231980"];
9855 [label="return _arity; 231981"];
9856 [label="Debug.Assert(constructedFrom.Arity != 0); 231982"];
9857 [label="Debug.Assert(constructedFrom.Arity != 0); 231983"];
9858 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 231984"];
9859 [label="var iReadOnlyListOfT = declaringAssembly.GetSpecialType(SpecialType.System_Collections_Generic_IReadOnlyList_T); 231985"];
9860 [label="declaringAssembly.GetSpecialType(SpecialType.System_Collections_Generic_IReadOnlyList_T) 231986"];
9861 [label="param GetSpecialType(SpecialType type) 231987"];
9862 [label="param GetSpecialType(this) 231988"];
9863 [label="return _corLibrary; 231989"];
9864 [label="this.Modules 231990"];
9865 [label="get\n            {\n                return _modules;\n            } 231991"];
9866 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 231992"];
9867 [label="module.GetReferencedAssemblies() 231993"];
9868 [label="param GetReferencedAssemblies(this) 231994"];
9869 [label="AssertReferencesInitialized() 231995"];
9870 [label="param AssertReferencesInitialized(this) 231996"];
9871 [label="Debug.Assert(_moduleReferences != null); 231997"];
9872 [label="Debug.Assert(_moduleReferences != null); 231998"];
9873 [label="AssertReferencesInitialized(); 231999"];
9874 [label="return _moduleReferences.Identities; 232000"];
9875 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 232001"];
9876 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 232002"];
9877 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 232003"];
9878 [label="return _lazySpecialTypes[(int)type]; 232004"];
9879 [label="if (!iReadOnlyListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 232005"];
9880 [label="iReadOnlyListOfT.IsErrorType() 232006"];
9881 [label="param IsErrorType(this TypeSymbol type) 232007"];
9882 [label="RoslynDebug.Assert((object)type != null); 232008"];
9883 [label="RoslynDebug.Assert((object)type != null); 232009"];
9884 [label="type.Kind 232010"];
9885 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 232011"];
9886 [label="return type.Kind == SymbolKind.ErrorType; 232012"];
9887 [label="if (!iReadOnlyListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 232013"];
9888 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 232014"];
9889 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 232015"];
9890 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 232016"];
9891 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 232017"];
9892 [label="new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations)) 232018"];
9893 [label="param ConstructedNamedTypeSymbol(NamedTypeSymbol constructedFrom) 232019"];
9894 [label="param ConstructedNamedTypeSymbol(ImmutableArray<TypeWithAnnotations> typeArgumentsWithAnnotations) 232020"];
9895 [label="param ConstructedNamedTypeSymbol(bool unbound = false) 232021"];
9896 [label="param ConstructedNamedTypeSymbol(TupleExtraData tupleData = null) 232022"];
9897 [label="param ConstructedNamedTypeSymbol(this) 232023"];
9898 [label="constructedFrom.ContainingSymbol 232024"];
9899 [label="constructedFrom.ContainingType 232025"];
9900 [label="constructedFrom.OriginalDefinition 232026"];
9901 [label="constructedFrom.OriginalDefinition.TypeParameters 232027"];
9902 [label="EnsureTypeParametersAreLoaded() 232028"];
9903 [label="s.Kind 232029"];
9904 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 232030"];
9905 [label="return SymbolKind.Namespace; 232031"];
9906 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 232032"];
9907 [label="_containingSymbol 232033"];
9908 [label="_ordinal 232034"];
9909 [label="_flags 232035"];
9910 [label="Debug.Assert((object)moduleSymbol != null); 232036"];
9911 [label="Debug.Assert((object)definingSymbol != null); 232037"];
9912 [label="Debug.Assert(ordinal >= 0); 232038"];
9913 [label="Debug.Assert(!handle.IsNil); 232039"];
9914 [label="EnsureTypeParametersAreLoaded(); 232040"];
9915 [label="new TypeMap(constructedFrom.ContainingType, constructedFrom.OriginalDefinition.TypeParameters, typeArgumentsWithAnnotations) 232041"];
9916 [label="param TypeMap(this) 232042"];
9917 [label="ForType(containingType) 232043"];
9918 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 232044"];
9919 [label="param AbstractTypeParameterMap(this) 232045"];
9920 [label="param AbstractTypeMap(this) 232046"];
9921 [label="Mapping 232047"];
9922 [label="for (int i = 0; i < typeParameters.Length; i++)\n            {\n                TypeParameterSymbol tp = typeParameters[i];\n                TypeWithAnnotations ta = typeArguments[i];\n                if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                }\n            } 232048"];
9923 [label="constructedFrom.OriginalDefinition 232049"];
9924 [label="unbound 232050"];
9925 [label="tupleData 232051"];
9926 [label="param ConstructedNamedTypeSymbol(this) 232052"];
9927 [label="param SubstitutedNamedTypeSymbol(TypeMap map) 232053"];
9928 [label="param SubstitutedNamedTypeSymbol(bool unbound = false) 232054"];
9929 [label="param SubstitutedNamedTypeSymbol(TupleExtraData tupleData = null) 232055"];
9930 [label="param SubstitutedNamedTypeSymbol(this) 232056"];
9931 [label="tupleData 232057"];
9932 [label="param SubstitutedNamedTypeSymbol(this) 232058"];
9933 [label="param WrappedNamedTypeSymbol(TupleExtraData tupleData) 232059"];
9934 [label="param WrappedNamedTypeSymbol(this) 232060"];
9935 [label="tupleData 232061"];
9936 [label="param WrappedNamedTypeSymbol(this) 232062"];
9937 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 232063"];
9938 [label="_lazyTupleData 232064"];
9939 [label="_underlyingType 232065"];
9940 [label="Debug.Assert((object)underlyingType != null); 232066"];
9941 [label="Debug.Assert((object)underlyingType != null); 232067"];
9942 [label="_unbound 232068"];
9943 [label="_inputMap 232069"];
9944 [label="_newContainer 232070"];
9945 [label="_lazyMap 232071"];
9946 [label="_hashCode 232072"];
9947 [label="_lazyMembersByNameCache 232073"];
9948 [label="originalDefinition.IsDefinition 232074"];
9949 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 232075"];
9950 [label="OriginalDefinition 232076"];
9951 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 232077"];
9952 [label="OriginalSymbolDefinition 232078"];
9953 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 232079"];
9954 [label="this.OriginalTypeSymbolDefinition 232080"];
9955 [label="get\n            {\n                return this.OriginalDefinition;\n            } 232081"];
9956 [label="this.OriginalDefinition 232082"];
9957 [label="get\n            {\n                return this;\n            } 232083"];
9958 [label="return this.OriginalDefinition; 232084"];
9959 [label="return this.OriginalTypeSymbolDefinition; 232085"];
9960 [label="return OriginalSymbolDefinition; 232086"];
9961 [label="return (object)this == (object)OriginalDefinition; 232087"];
9962 [label="Debug.Assert(originalDefinition.IsDefinition); 232088"];
9963 [label="Debug.Assert(!originalDefinition.IsErrorType()); 232089"];
9964 [label="originalDefinition.IsErrorType() 232090"];
9965 [label="param IsErrorType(this TypeSymbol type) 232091"];
9966 [label="RoslynDebug.Assert((object)type != null); 232092"];
9967 [label="RoslynDebug.Assert((object)type != null); 232093"];
9968 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 232094"];
9969 [label="Debug.Assert(!originalDefinition.IsErrorType()); 232095"];
9970 [label="_inputMap 232096"];
9971 [label="_unbound 232097"];
9972 [label="if ((object)constructedFrom != null)\n            {\n                Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom));\n                _lazyTypeParameters = constructedFrom.TypeParameters;\n                _lazyMap = map;\n            } 232098"];
9973 [label="constructedFrom.ConstructedFrom 232099"];
9974 [label="get\n            {\n                return this;\n            } 232100"];
9975 [label="return this; 232101"];
9976 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 232102"];
9977 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 232103"];
9978 [label="EnsureTypeParametersAreLoaded(); 232104"];
9979 [label="_constructedFrom 232105"];
9980 [label="constructedFrom.Arity 232106"];
9981 [label="get\n                {\n                    return _arity;\n                } 232107"];
9982 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 232108"];
9983 [label="constructedFrom.Arity 232109"];
9984 [label="get\n                {\n                    return _arity;\n                } 232110"];
9985 [label="Debug.Assert(constructedFrom.Arity != 0); 232111"];
9986 [label="Debug.Assert(constructedFrom.Arity != 0); 232112"];
9987 [label="return constructedInterfaces.ToImmutableAndFree(); 232113"];
9988 [label="CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)) 232114"];
9989 [label="param CreateSZArray(TypeWithAnnotations elementTypeWithAnnotations) 232115"];
9990 [label="param CreateSZArray(NamedTypeSymbol array) 232116"];
9991 [label="param CreateSZArray(ImmutableArray<NamedTypeSymbol> constructedInterfaces) 232117"];
9992 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 232118"];
9993 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 232119"];
9994 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 232120"];
9995 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 232121"];
9996 [label="new SZArray(elementTypeWithAnnotations, array, constructedInterfaces) 232122"];
9997 [label="param SZArray(TypeWithAnnotations elementTypeWithAnnotations) 232123"];
9998 [label="param SZArray(NamedTypeSymbol array) 232124"];
9999 [label="param SZArray(ImmutableArray<NamedTypeSymbol> constructedInterfaces) 232125"];
10000 [label="param SZArray(this) 232126"];
10001 [label="elementTypeWithAnnotations 232127"];
10002 [label="array 232128"];
10003 [label="param SZArray(this) 232129"];
10004 [label="param ArrayTypeSymbol(TypeWithAnnotations elementTypeWithAnnotations) 232130"];
10005 [label="param ArrayTypeSymbol(NamedTypeSymbol array) 232131"];
10006 [label="param ArrayTypeSymbol(this) 232132"];
10007 [label="param ArrayTypeSymbol(this) 232133"];
10008 [label="_lazyAdapter 232134"];
10009 [label="_baseType 232135"];
10010 [label="elementTypeWithAnnotations.HasType 232136"];
10011 [label="=> !(DefaultType is null) 232137"];
10012 [label="DefaultType is null 232138"];
10013 [label="!(DefaultType is null) 232139"];
10014 [label="Debug.Assert(elementTypeWithAnnotations.HasType); 232140"];
10015 [label="RoslynDebug.Assert((object)array != null); 232141"];
10016 [label="RoslynDebug.Assert((object)array != null); 232142"];
10017 [label="_elementTypeWithAnnotations 232143"];
10018 [label="_baseType 232144"];
10019 [label="Debug.Assert(constructedInterfaces.Length <= 2); 232145"];
10020 [label="Debug.Assert(constructedInterfaces.Length <= 2); 232146"];
10021 [label="_interfaces 232147"];
10022 [label="return CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)); 232148"];
10023 [label="return CreateSZArray(declaringAssembly, elementTypeWithAnnotations); 232149"];
10024 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 232150"];
10025 [label="AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken) 232151"];
10026 [label="param AreNullableAnnotationsEnabled(SyntaxToken token) 232152"];
10027 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 232153"];
10028 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 232154"];
10029 [label="TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array) 232155"];
10030 [label="param Create(bool isNullableEnabled) 232156"];
10031 [label="param Create(TypeSymbol typeSymbol) 232157"];
10032 [label="param Create(bool isAnnotated = false) 232158"];
10033 [label="if (typeSymbol is null)\n            {\n                return default;\n            } 232159"];
10034 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 232160"];
10035 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 232161"];
10036 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 232162"];
10037 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 232163"];
10038 [label="typeSymbol.IsNullableType() 232164"];
10039 [label="param IsNullableType(this TypeSymbol type) 232165"];
10040 [label="type.OriginalDefinition 232166"];
10041 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 232167"];
10042 [label="OriginalTypeSymbolDefinition 232168"];
10043 [label="get\n            {\n                return this;\n            } 232169"];
10044 [label="return this; 232170"];
10045 [label="return OriginalTypeSymbolDefinition; 232171"];
10046 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 232172"];
10047 [label="type.OriginalDefinition.SpecialType 232173"];
10048 [label="get\n            {\n                return SpecialType.None;\n            } 232174"];
10049 [label="return SpecialType.None; 232175"];
10050 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 232176"];
10051 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 232177"];
10052 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 232178"];
10053 [label="var a1 = defaultType is null; 232179"];
10054 [label="!a1 232180"];
10055 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 232181"];
10056 [label="defaultType.IsNullableType() 232182"];
10057 [label="param IsNullableType(this TypeSymbol type) 232183"];
10058 [label="type.OriginalDefinition 232184"];
10059 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 232185"];
10060 [label="OriginalTypeSymbolDefinition 232186"];
10061 [label="get\n            {\n                return this;\n            } 232187"];
10062 [label="return this; 232188"];
10063 [label="return OriginalTypeSymbolDefinition; 232189"];
10064 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 232190"];
10065 [label="type.OriginalDefinition.SpecialType 232191"];
10066 [label="get\n            {\n                return SpecialType.None;\n            } 232192"];
10067 [label="return SpecialType.None; 232193"];
10068 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 232194"];
10069 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 232195"];
10070 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 232196"];
10071 [label="Debug.Assert(a1 || a2 != true || a3); 232197"];
10072 [label="Debug.Assert(a1 || a2 != true || a3); 232198"];
10073 [label="Debug.Assert(extensions != null); 232199"];
10074 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 232200"];
10075 [label="return type; 232201"];
10076 [label="return new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations); 232202"];
10077 [label="new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations) 232203"];
10078 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(this) 232204"];
10079 [label="typeWithAnnotations.HasType 232205"];
10080 [label="=> !(DefaultType is null) 232206"];
10081 [label="DefaultType is null 232207"];
10082 [label="!(DefaultType is null) 232208"];
10083 [label="Debug.Assert(typeWithAnnotations.HasType); 232209"];
10084 [label="_symbol = null; 232210"];
10085 [label="_symbol 232211"];
10086 [label="_isNullableEnabled = false; 232212"];
10087 [label="_isNullableEnabled 232213"];
10088 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 232214"];
10089 [label="symbol.IsType 232215"];
10090 [label="=> !_typeWithAnnotations.IsDefault 232216"];
10091 [label="_typeWithAnnotations.IsDefault 232217"];
10092 [label="DefaultType is null 232218"];
10093 [label="param ReportDiagnosticsIfObsolete(Binder binder) 232219"];
10094 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 232220"];
10095 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 232221"];
10096 [label="binder 232222"];
10097 [label="syntax 232223"];
10098 [label="diagnostics 232224"];
10099 [label="param ReportDiagnosticsIfObsolete(Binder binder) 232225"];
10100 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 232226"];
10101 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 232227"];
10102 [label="param ReportDiagnosticsIfObsolete(this) 232228"];
10103 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 232229"];
10104 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 232230"];
10105 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 232231"];
10106 [label="param ReportDiagnosticsIfObsoleteCore(Binder binder) 232232"];
10107 [label="param ReportDiagnosticsIfObsoleteCore(SyntaxNode syntax) 232233"];
10108 [label="param ReportDiagnosticsIfObsoleteCore(DiagnosticBag diagnostics) 232234"];
10109 [label="=> defaultType 232235"];
10110 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 232236"];
10111 [label="param ReportDiagnosticsIfObsolete(SyntaxNode node) 232237"];
10112 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 232238"];
10113 [label="param ReportDiagnosticsIfObsolete(this) 232239"];
10114 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 232240"];
10115 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 232241"];
10116 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 232242"];
10117 [label="param ReportDiagnosticsIfObsolete(this) 232243"];
10118 [label="get\n            {\n                return SymbolKind.ArrayType;\n            } 232244"];
10119 [label="return SymbolKind.ArrayType; 232245"];
10120 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 232246"];
10121 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 232247"];
10122 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 232248"];
10123 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 232249"];
10124 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved) 232250"];
10125 [label="param UnwrapAlias(DiagnosticBag diagnostics) 232251"];
10126 [label="param UnwrapAlias(SyntaxNode syntax) 232252"];
10127 [label="param UnwrapAlias(ConsList<TypeSymbol> basesBeingResolved = null) 232253"];
10128 [label="param UnwrapAlias(this) 232254"];
10129 [label="symbol.IsAlias 232255"];
10130 [label="=> _symbol?.Kind == SymbolKind.Alias 232256"];
10131 [label="_symbol 232257"];
10132 [label="_symbol?.Kind == SymbolKind.Alias 232258"];
10133 [label="if (symbol.IsAlias)\n            {\n                AliasSymbol discarded;\n                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out discarded, diagnostics, syntax, basesBeingResolved));\n            } 232259"];
10134 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations 232260"];
10135 [label="IsFixedSizeBuffer 232261"];
10136 [label="=> (Modifiers & DeclarationModifiers.Fixed) != 0 232262"];
10137 [label="Modifiers 232263"];
10138 [label="get\n            {\n                return _modifiers;\n            } 232264"];
10139 [label="return _modifiers; 232265"];
10140 [label="Modifiers & DeclarationModifiers.Fixed 232266"];
10141 [label="0 232267"];
10142 [label="(Modifiers & DeclarationModifiers.Fixed) != 0 232268"];
10143 [label="if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                } 232269"];
10144 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 232270"];
10145 [label="this.RequiredCustomModifiers 232271"];
10146 [label="get\n            {\n                if (!IsVolatile)\n                {\n                    return ImmutableArray<CustomModifier>.Empty;\n                }\n                else\n                {\n                    return ImmutableArray.Create<CustomModifier>(\n                            CSharpCustomModifier.CreateRequired(this.ContainingAssembly.GetSpecialType(SpecialType.System_Runtime_CompilerServices_IsVolatile)));\n                }\n            } 232272"];
10147 [label="IsVolatile 232273"];
10148 [label="=> (Modifiers & DeclarationModifiers.Volatile) != 0 232274"];
10149 [label="Modifiers 232275"];
10150 [label="get\n            {\n                return _modifiers;\n            } 232276"];
10151 [label="return _modifiers; 232277"];
10152 [label="Modifiers & DeclarationModifiers.Volatile 232278"];
10153 [label="0 232279"];
10154 [label="(Modifiers & DeclarationModifiers.Volatile) != 0 232280"];
10155 [label="if (!IsVolatile)\n                {\n                    return ImmutableArray<CustomModifier>.Empty;\n                }\n                else\n                {\n                    return ImmutableArray.Create<CustomModifier>(\n                            CSharpCustomModifier.CreateRequired(this.ContainingAssembly.GetSpecialType(SpecialType.System_Runtime_CompilerServices_IsVolatile)));\n                } 232281"];
10156 [label="return ImmutableArray<CustomModifier>.Empty; 232282"];
10157 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 232283"];
10158 [label="type.WithModifiers(this.RequiredCustomModifiers) 232284"];
10159 [label="param WithModifiers(ImmutableArray<CustomModifier> customModifiers) 232285"];
10160 [label="=>\n            _extensions.WithModifiers(this, customModifiers) 232286"];
10161 [label="this 232287"];
10162 [label="customModifiers 232288"];
10163 [label="_extensions.WithModifiers(this, customModifiers) 232289"];
10164 [label="param WithModifiers(TypeWithAnnotations type) 232290"];
10165 [label="param WithModifiers(ImmutableArray<CustomModifier> customModifiers) 232291"];
10166 [label="param WithModifiers(this) 232292"];
10167 [label="return CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers); 232293"];
10168 [label="return CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers); 232294"];
10169 [label="return CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers); 232295"];
10170 [label="CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers) 232296"];
10171 [label="param CreateNonLazyType(TypeSymbol typeSymbol) 232297"];
10172 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 232298"];
10173 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 232299"];
10174 [label="Extensions.Create(customModifiers) 232300"];
10175 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 232301"];
10176 [label="new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)) 232302"];
10177 [label="param TypeWithAnnotations(this) 232303"];
10178 [label="var a1 = defaultType is null; 232304"];
10179 [label="!a1 232305"];
10180 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 232306"];
10181 [label="defaultType.IsNullableType() 232307"];
10182 [label="param IsNullableType(this TypeSymbol type) 232308"];
10183 [label="type.OriginalDefinition 232309"];
10184 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 232310"];
10185 [label="OriginalTypeSymbolDefinition 232311"];
10186 [label="get\n            {\n                return this;\n            } 232312"];
10187 [label="return this; 232313"];
10188 [label="return OriginalTypeSymbolDefinition; 232314"];
10189 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 232315"];
10190 [label="type.OriginalDefinition.SpecialType 232316"];
10191 [label="get\n            {\n                return SpecialType.None;\n            } 232317"];
10192 [label="return SpecialType.None; 232318"];
10193 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 232319"];
10194 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 232320"];
10195 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 232321"];
10196 [label="Debug.Assert(a1 || a2 != true || a3); 232322"];
10197 [label="Debug.Assert(a1 || a2 != true || a3); 232323"];
10198 [label="Debug.Assert(extensions != null); 232324"];
10199 [label="Debug.Assert(extensions != null); 232325"];
10200 [label="return CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers); 232326"];
10201 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 232327"];
10202 [label="default 232328"];
10203 [label="new Boxed(default) 232329"];
10204 [label="param Boxed(TypeWithAnnotations value) 232330"];
10205 [label="param Boxed(this) 232331"];
10206 [label="Value 232332"];
10207 [label="Sentinel = new Boxed(default) 232333"];
10208 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 232334"];
10209 [label="new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)) 232335"];
10210 [label="param Boxed(TypeWithAnnotations value) 232336"];
10211 [label="param Boxed(this) 232337"];
10212 [label="Value 232338"];
10213 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 232339"];
10214 [label="type.Type 232340"];
10215 [label="=> defaultType 232341"];
10216 [label="TypeChecks(type.Type, diagnostics); 232342"];
10217 [label="TypeChecks(type.Type, diagnostics); 232343"];
10218 [label="TypeChecks(type.Type, diagnostics) 232344"];
10219 [label="param TypeChecks(TypeSymbol type) 232345"];
10220 [label="param TypeChecks(DiagnosticBag diagnostics) 232346"];
10221 [label="param TypeChecks(this) 232347"];
10222 [label="type.IsStatic 232348"];
10223 [label="get\n            {\n                return false;\n            } 232349"];
10224 [label="return false; 232350"];
10225 [label="if (type.IsStatic)\n            {\n                // Cannot declare a variable of static type '{0}'\n                diagnostics.Add(ErrorCode.ERR_VarDeclIsStaticClass, this.ErrorLocation, type);\n            }\n            else if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 232351"];
10226 [label="if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 232352"];
10227 [label="type.IsVoidType() 232353"];
10228 [label="param IsVoidType(this TypeSymbol type) 232354"];
10229 [label="type.SpecialType 232355"];
10230 [label="get\n            {\n                return SpecialType.None;\n            } 232356"];
10231 [label="return SpecialType.None; 232357"];
10232 [label="return type.SpecialType == SpecialType.System_Void; 232358"];
10233 [label="if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 232359"];
10234 [label="if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 232360"];
10235 [label="if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 232361"];
10236 [label="type.IsRestrictedType(ignoreSpanLikeTypes: true) 232362"];
10237 [label="param IsRestrictedType(this TypeSymbol type) 232363"];
10238 [label="param IsRestrictedType(bool ignoreSpanLikeTypes = false) 232364"];
10239 [label="RoslynDebug.Assert((object)type != null); 232365"];
10240 [label="RoslynDebug.Assert((object)type != null); 232366"];
10241 [label="type.SpecialType 232367"];
10242 [label="get\n            {\n                return SpecialType.None;\n            } 232368"];
10243 [label="switch (type.SpecialType)\n            {\n                case SpecialType.System_TypedReference:\n                case SpecialType.System_ArgIterator:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            } 232369"];
10244 [label="ignoreSpanLikeTypes 232370"];
10245 [label="return ignoreSpanLikeTypes ?\n                        false :\n                        type.IsRefLikeType; 232371"];
10246 [label="type.IsRefLikeType 232372"];
10247 [label="get\n            {\n                return false;\n            } 232373"];
10248 [label="return false; 232374"];
10249 [label="if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 232375"];
10250 [label="IsConst 232376"];
10251 [label="=> (Modifiers & DeclarationModifiers.Const) != 0 232377"];
10252 [label="Modifiers 232378"];
10253 [label="get\n            {\n                return _modifiers;\n            } 232379"];
10254 [label="Modifiers & DeclarationModifiers.Const 232380"];
10255 [label="0 232381"];
10256 [label="(Modifiers & DeclarationModifiers.Const) != 0 232382"];
10257 [label="if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 232383"];
10258 [label="IsVolatile 232384"];
10259 [label="if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 232385"];
10260 [label="HashSet<DiagnosticInfo> useSiteDiagnostics = null; 232386"];
10261 [label="if (!this.IsNoMoreVisibleThan(type, ref useSiteDiagnostics))\n            {\n                // Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'\n                diagnostics.Add(ErrorCode.ERR_BadVisFieldType, this.ErrorLocation, this, type);\n            } 232387"];
10262 [label="if (!this.IsNoMoreVisibleThan(type, ref useSiteDiagnostics))\n            {\n                // Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'\n                diagnostics.Add(ErrorCode.ERR_BadVisFieldType, this.ErrorLocation, this, type);\n            } 232388"];
10263 [label="if (!this.IsNoMoreVisibleThan(type, ref useSiteDiagnostics))\n            {\n                // Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'\n                diagnostics.Add(ErrorCode.ERR_BadVisFieldType, this.ErrorLocation, this, type);\n            } 232389"];
10264 [label="this.IsNoMoreVisibleThan(type, ref useSiteDiagnostics) 232390"];
10265 [label="param IsNoMoreVisibleThan(this Symbol symbol) 232391"];
10266 [label="param IsNoMoreVisibleThan(TypeSymbol type) 232392"];
10267 [label="param IsNoMoreVisibleThan(ref HashSet<DiagnosticInfo>? useSiteDiagnostics) 232393"];
10268 [label="return type.IsAtLeastAsVisibleAs(symbol, ref useSiteDiagnostics); 232394"];
10269 [label="return type.IsAtLeastAsVisibleAs(symbol, ref useSiteDiagnostics); 232395"];
10270 [label="return type.IsAtLeastAsVisibleAs(symbol, ref useSiteDiagnostics); 232396"];
10271 [label="type.IsAtLeastAsVisibleAs(symbol, ref useSiteDiagnostics) 232397"];
10272 [label="param IsAtLeastAsVisibleAs(this TypeSymbol type) 232398"];
10273 [label="param IsAtLeastAsVisibleAs(Symbol sym) 232399"];
10274 [label="param IsAtLeastAsVisibleAs(ref HashSet<DiagnosticInfo>? useSiteDiagnostics) 232400"];
10275 [label="HashSet<DiagnosticInfo>? localUseSiteDiagnostics = useSiteDiagnostics; 232401"];
10276 [label="var result = type.VisitType((type1, symbol, unused) => IsTypeLessVisibleThan(type1, symbol, ref localUseSiteDiagnostics), sym,\n                                        canDigThroughNullable: true); 232402"];
10277 [label="var result = type.VisitType((type1, symbol, unused) => IsTypeLessVisibleThan(type1, symbol, ref localUseSiteDiagnostics), sym,\n                                        canDigThroughNullable: true); 232403"];
10278 [label="var result = type.VisitType((type1, symbol, unused) => IsTypeLessVisibleThan(type1, symbol, ref localUseSiteDiagnostics), sym,\n                                        canDigThroughNullable: true); 232404"];
10279 [label="var result = type.VisitType((type1, symbol, unused) => IsTypeLessVisibleThan(type1, symbol, ref localUseSiteDiagnostics), sym,\n                                        canDigThroughNullable: true); 232405"];
10280 [label="type.VisitType((type1, symbol, unused) => IsTypeLessVisibleThan(type1, symbol, ref localUseSiteDiagnostics), sym,\n                                        canDigThroughNullable: true) 232406"];
10281 [label="param VisitType(this TypeSymbol type) 232407"];
10282 [label="param VisitType(Func<TypeSymbol, T, bool, bool> predicate) 232408"];
10283 [label="param VisitType(T arg) 232409"];
10284 [label="param VisitType(bool canDigThroughNullable = false) 232410"];
10285 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 232411"];
10286 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 232412"];
10287 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 232413"];
10288 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 232414"];
10289 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 232415"];
10290 [label="VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable) 232416"];
10291 [label="param VisitType(this TypeWithAnnotations typeWithAnnotationsOpt) 232417"];
10292 [label="param VisitType(TypeSymbol? type) 232418"];
10293 [label="param VisitType(Func<TypeWithAnnotations, T, bool, bool>? typeWithAnnotationsPredicate) 232419"];
10294 [label="param VisitType(Func<TypeSymbol, T, bool, bool>? typePredicate) 232420"];
10295 [label="param VisitType(T arg) 232421"];
10296 [label="param VisitType(bool canDigThroughNullable = false) 232422"];
10297 [label="param VisitType(bool useDefaultType = false) 232423"];
10298 [label="typeWithAnnotationsOpt.HasType 232424"];
10299 [label="=> !(DefaultType is null) 232425"];
10300 [label="DefaultType is null 232426"];
10301 [label="!(DefaultType is null) 232427"];
10302 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 232428"];
10303 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 232429"];
10304 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 232430"];
10305 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 232431"];
10306 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 232432"];
10307 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 232433"];
10308 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 232434"];
10309 [label="while (true)\n            {\n                TypeSymbol current = type ?? (useDefaultType ? typeWithAnnotationsOpt.DefaultType : typeWithAnnotationsOpt.Type);\n                bool isNestedNamedType = false;\n\n                // Visit containing types from outer-most to inner-most.\n                switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                }\n\n                if (typeWithAnnotationsOpt.HasType && typeWithAnnotationsPredicate != null)\n                {\n                    if (typeWithAnnotationsPredicate(typeWithAnnotationsOpt, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n                else if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n\n                TypeWithAnnotations next;\n\n                switch (current.TypeKind)\n                {\n                    case TypeKind.Dynamic:\n                    case TypeKind.TypeParameter:\n                    case TypeKind.Submission:\n                    case TypeKind.Enum:\n                        return null;\n\n                    case TypeKind.Error:\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Delegate:\n                        var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics;\n                        if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        }\n\n                        int i;\n                        for (i = 0; i < typeArguments.Length - 1; i++)\n                        {\n                            // Let's try to avoid early resolution of nullable types\n                            (TypeWithAnnotations nextTypeWithAnnotations, TypeSymbol? nextType) = getNextIterationElements(typeArguments[i], canDigThroughNullable);\n                            var result = VisitType(\n                                typeWithAnnotationsOpt: nextTypeWithAnnotations,\n                                type: nextType,\n                                typeWithAnnotationsPredicate,\n                                typePredicate,\n                                arg,\n                                canDigThroughNullable,\n                                useDefaultType);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n                        }\n\n                        next = typeArguments[i];\n                        break;\n\n                    case TypeKind.Array:\n                        next = ((ArrayTypeSymbol)current).ElementTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.Pointer:\n                        next = ((PointerTypeSymbol)current).PointedAtTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.FunctionPointer:\n                        {\n                            var result = visitFunctionPointerType((FunctionPointerTypeSymbol)current, typeWithAnnotationsPredicate, typePredicate, arg, useDefaultType, canDigThroughNullable, out next);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n\n                            break;\n                        }\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(current.TypeKind);\n                }\n\n                // Let's try to avoid early resolution of nullable types\n                typeWithAnnotationsOpt = canDigThroughNullable ? default : next;\n                type = canDigThroughNullable ? next.NullableUnderlyingTypeOrSelf : null;\n            } 232435"];
10310 [label="TypeSymbol current = type ?? (useDefaultType ? typeWithAnnotationsOpt.DefaultType : typeWithAnnotationsOpt.Type); 232436"];
10311 [label="bool isNestedNamedType = false; 232437"];
10312 [label="current.TypeKind 232438"];
10313 [label="get\n            {\n                return TypeKind.Array;\n            } 232439"];
10314 [label="return TypeKind.Array; 232440"];
10315 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 232441"];
10316 [label="typeWithAnnotationsOpt.HasType 232442"];
10317 [label="=> !(DefaultType is null) 232443"];
10318 [label="DefaultType is null 232444"];
10319 [label="!(DefaultType is null) 232445"];
10320 [label="if (typeWithAnnotationsOpt.HasType && typeWithAnnotationsPredicate != null)\n                {\n                    if (typeWithAnnotationsPredicate(typeWithAnnotationsOpt, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n                else if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 232446"];
10321 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 232447"];
10322 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 232448"];
10323 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 232449"];
10324 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 232450"];
10325 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 232451"];
10326 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 232452"];
10327 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 232453"];
10328 [label="param IsTypeLessVisibleThan(TypeSymbol type) 232454"];
10329 [label="param IsTypeLessVisibleThan(Symbol sym) 232455"];
10330 [label="param IsTypeLessVisibleThan(ref HashSet<DiagnosticInfo>? useSiteDiagnostics) 232456"];
10331 [label="type.TypeKind 232457"];
10332 [label="get\n            {\n                return TypeKind.Array;\n            } 232458"];
10333 [label="return TypeKind.Array; 232459"];
10334 [label="switch (type.TypeKind)\n            {\n                case TypeKind.Class:\n                case TypeKind.Struct:\n                case TypeKind.Interface:\n                case TypeKind.Enum:\n                case TypeKind.Delegate:\n                case TypeKind.Submission:\n                    return !IsAsRestrictive((NamedTypeSymbol)type, sym, ref useSiteDiagnostics);\n\n                default:\n                    return false;\n            } 232460"];
10335 [label="return false; 232461"];
10336 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 232462"];
10337 [label="TypeWithAnnotations next; 232463"];
10338 [label="next 232464"];
10339 [label="current.TypeKind 232465"];
10340 [label="get\n            {\n                return TypeKind.Array;\n            } 232466"];
10341 [label="return TypeKind.Array; 232467"];
10342 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Dynamic:\n                    case TypeKind.TypeParameter:\n                    case TypeKind.Submission:\n                    case TypeKind.Enum:\n                        return null;\n\n                    case TypeKind.Error:\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Delegate:\n                        var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics;\n                        if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        }\n\n                        int i;\n                        for (i = 0; i < typeArguments.Length - 1; i++)\n                        {\n                            // Let's try to avoid early resolution of nullable types\n                            (TypeWithAnnotations nextTypeWithAnnotations, TypeSymbol? nextType) = getNextIterationElements(typeArguments[i], canDigThroughNullable);\n                            var result = VisitType(\n                                typeWithAnnotationsOpt: nextTypeWithAnnotations,\n                                type: nextType,\n                                typeWithAnnotationsPredicate,\n                                typePredicate,\n                                arg,\n                                canDigThroughNullable,\n                                useDefaultType);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n                        }\n\n                        next = typeArguments[i];\n                        break;\n\n                    case TypeKind.Array:\n                        next = ((ArrayTypeSymbol)current).ElementTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.Pointer:\n                        next = ((PointerTypeSymbol)current).PointedAtTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.FunctionPointer:\n                        {\n                            var result = visitFunctionPointerType((FunctionPointerTypeSymbol)current, typeWithAnnotationsPredicate, typePredicate, arg, useDefaultType, canDigThroughNullable, out next);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n\n                            break;\n                        }\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(current.TypeKind);\n                } 232468"];
10343 [label="((ArrayTypeSymbol)current).ElementTypeWithAnnotations 232469"];
10344 [label="get\n            {\n                return _elementTypeWithAnnotations;\n            } 232470"];
10345 [label="return _elementTypeWithAnnotations; 232471"];
10346 [label="next = ((ArrayTypeSymbol)current).ElementTypeWithAnnotations; 232472"];
10347 [label="canDigThroughNullable 232473"];
10348 [label="typeWithAnnotationsOpt = canDigThroughNullable ? default : next; 232474"];
10349 [label="canDigThroughNullable 232475"];
10350 [label="next.NullableUnderlyingTypeOrSelf 232476"];
10351 [label="=> _extensions.GetNullableUnderlyingTypeOrSelf(DefaultType) 232477"];
10352 [label="DefaultType 232478"];
10353 [label="_extensions.GetNullableUnderlyingTypeOrSelf(DefaultType) 232479"];
10354 [label="param GetNullableUnderlyingTypeOrSelf(TypeSymbol typeSymbol) 232480"];
10355 [label="=> typeSymbol.StrippedType() 232481"];
10356 [label="typeSymbol 232482"];
10357 [label="typeSymbol.StrippedType() 232483"];
10358 [label="param StrippedType(this TypeSymbol type) 232484"];
10359 [label="return type.IsNullableType() ? type.GetNullableUnderlyingType() : type; 232485"];
10360 [label="type.IsNullableType() 232486"];
10361 [label="param IsNullableType(this TypeSymbol type) 232487"];
10362 [label="type.OriginalDefinition 232488"];
10363 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 232489"];
10364 [label="OriginalTypeSymbolDefinition 232490"];
10365 [label="get\n            {\n                return this.OriginalDefinition;\n            } 232491"];
10366 [label="this.OriginalDefinition 232492"];
10367 [label="get\n            {\n                return this;\n            } 232493"];
10368 [label="return this.OriginalDefinition; 232494"];
10369 [label="return OriginalTypeSymbolDefinition; 232495"];
10370 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 232496"];
10371 [label="type.OriginalDefinition.SpecialType 232497"];
10372 [label="get\n            {\n                return _corTypeId;\n            } 232498"];
10373 [label="type = canDigThroughNullable ? next.NullableUnderlyingTypeOrSelf : null; 232499"];
10374 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 232500"];
10375 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 232501"];
10376 [label="current.ContainingType 232502"];
10377 [label="var containingType = current.ContainingType; 232503"];
10378 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 232504"];
10379 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 232505"];
10380 [label="=> !(DefaultType is null) 232506"];
10381 [label="DefaultType is null 232507"];
10382 [label="!(DefaultType is null) 232508"];
10383 [label="if (typeWithAnnotationsOpt.HasType && typeWithAnnotationsPredicate != null)\n                {\n                    if (typeWithAnnotationsPredicate(typeWithAnnotationsOpt, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n                else if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 232509"];
10384 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 232510"];
10385 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 232511"];
10386 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 232512"];
10387 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 232513"];
10388 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 232514"];
10389 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 232515"];
10390 [label="param IsTypeLessVisibleThan(TypeSymbol type) 232516"];
10391 [label="param IsTypeLessVisibleThan(Symbol sym) 232517"];
10392 [label="type.TypeKind 232518"];
10393 [label="return !IsAsRestrictive((NamedTypeSymbol)type, sym, ref useSiteDiagnostics); 232519"];
10394 [label="return !IsAsRestrictive((NamedTypeSymbol)type, sym, ref useSiteDiagnostics); 232520"];
10395 [label="return !IsAsRestrictive((NamedTypeSymbol)type, sym, ref useSiteDiagnostics); 232521"];
10396 [label="IsAsRestrictive((NamedTypeSymbol)type, sym, ref useSiteDiagnostics) 232522"];
10397 [label="param IsAsRestrictive(NamedTypeSymbol s1) 232523"];
10398 [label="param IsAsRestrictive(Symbol sym2) 232524"];
10399 [label="param IsAsRestrictive(ref HashSet<DiagnosticInfo>? useSiteDiagnostics) 232525"];
10400 [label="s1.DeclaredAccessibility 232526"];
10401 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 232527"];
10402 [label="Accessibility access = Accessibility.Private; 232528"];
10403 [label="Accessibility acc1 = s1.DeclaredAccessibility; 232529"];
10404 [label="if (acc1 == Accessibility.Public)\n            {\n                return true;\n            } 232530"];
10405 [label="return true; 232531"];
10406 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 232532"];
10407 [label="((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 232533"];
10408 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 232534"];
10409 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 232535"];
10410 [label="var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 232536"];
10411 [label="if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        } 232537"];
10412 [label="return null; 232538"];
10413 [label="useSiteDiagnostics = localUseSiteDiagnostics; 232539"];
10414 [label="return result is null; 232540"];
10415 [label="diagnostics.Add(this.ErrorLocation, useSiteDiagnostics); 232541"];
10416 [label="this.ErrorLocation 232542"];
10417 [label="get\n            {\n                return _location;\n            } 232543"];
10418 [label="return _location; 232544"];
10419 [label="diagnostics.Add(this.ErrorLocation, useSiteDiagnostics); 232545"];
10420 [label="diagnostics.Add(this.ErrorLocation, useSiteDiagnostics); 232546"];
10421 [label="diagnostics.Add(this.ErrorLocation, useSiteDiagnostics); 232547"];
10422 [label="TypeChecks(type.Type, diagnostics); 232548"];
10423 [label="compilation.DeclarationDiagnostics 232549"];
10424 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 232550"];
10425 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 232551"];
10426 [label="return _lazyDeclarationDiagnostics; 232552"];
10427 [label="compilation.DeclarationDiagnostics.AddRange(diagnostics); 232553"];
10428 [label="compilation.DeclarationDiagnostics.AddRange(diagnostics); 232554"];
10429 [label="bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator; 232555"];
10430 [label="bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator; 232556"];
10431 [label="if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                } 232557"];
10432 [label="compilation.DeclarationDiagnostics 232558"];
10433 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 232559"];
10434 [label="compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator); 232560"];
10435 [label="compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator); 232561"];
10436 [label="state.NotePartComplete(CompletionPart.Type); 232562"];
10437 [label="state.NotePartComplete(CompletionPart.Type) 232563"];
10438 [label="param NotePartComplete(CompletionPart part) 232564"];
10439 [label="param NotePartComplete(this) 232565"];
10440 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 232566"];
10441 [label="diagnostics.Free(); 232567"];
10442 [label="diagnosticsForFirstDeclarator.Free(); 232568"];
10443 [label="return _lazyType.Value; 232569"];
10444 [label="return GetFieldType(ConsList<FieldSymbol>.Empty); 232570"];
10445 [label="TypeWithAnnotations.Type 232571"];
10446 [label="=> _extensions?.GetResolvedType(DefaultType) 232572"];
10447 [label=".GetResolvedType(DefaultType) 232573"];
10448 [label="=> defaultType 232574"];
10449 [label="CustomAssert.Equal(SymbolKind.ArrayType, sym1.Kind); 232575"];
10450 [label="sym1.Kind 232576"];
10451 [label="get\n            {\n                return SymbolKind.ArrayType;\n            } 232577"];
10452 [label="return SymbolKind.ArrayType; 232578"];
10453 [label="CustomAssert.Equal(SymbolKind.ArrayType, sym1.Kind); 232579"];
10454 [label="sym1.GetHashCode() 232580"];
10455 [label="param GetHashCode(this) 232581"];
10456 [label="int hash = 0; 232582"];
10457 [label="TypeSymbol current = this; 232583"];
10458 [label="current.TypeKind 232584"];
10459 [label="get\n            {\n                return TypeKind.Array;\n            } 232585"];
10460 [label="return TypeKind.Array; 232586"];
10461 [label="while (current.TypeKind == TypeKind.Array)\n            {\n                var cur = (ArrayTypeSymbol)current;\n                hash = Hash.Combine(cur.Rank, hash);\n                current = cur.ElementType;\n            } 232587"];
10462 [label="var cur = (ArrayTypeSymbol)current; 232588"];
10463 [label="cur.Rank 232589"];
10464 [label="get\n                {\n                    return 1;\n                } 232590"];
10465 [label="return 1; 232591"];
10466 [label="hash = Hash.Combine(cur.Rank, hash); 232592"];
10467 [label="hash = Hash.Combine(cur.Rank, hash); 232593"];
10468 [label="hash = Hash.Combine(cur.Rank, hash); 232594"];
10469 [label="cur.ElementType 232595"];
10470 [label="get\n            {\n                return _elementTypeWithAnnotations.Type;\n            } 232596"];
10471 [label="_elementTypeWithAnnotations.Type 232597"];
10472 [label="=> _extensions?.GetResolvedType(DefaultType) 232598"];
10473 [label=".GetResolvedType(DefaultType) 232599"];
10474 [label="=> defaultType 232600"];
10475 [label="return _elementTypeWithAnnotations.Type; 232601"];
10476 [label="current = cur.ElementType; 232602"];
10477 [label="return Hash.Combine(current, hash); 232603"];
10478 [label="return Hash.Combine(current, hash); 232604"];
10479 [label="return Hash.Combine(current, hash); 232605"];
10480 [label="return Hash.Combine(current, hash); 232606"];
10481 [label="this.SpecialType 232607"];
10482 [label="OriginalDefinition 232608"];
10483 [label="var v1 = sym1.GetHashCode(); 232609"];
10484 [label="sym1.GetHashCode() 232610"];
10485 [label="param GetHashCode(this) 232611"];
10486 [label="int hash = 0; 232612"];
10487 [label="TypeSymbol current = this; 232613"];
10488 [label="current.TypeKind 232614"];
10489 [label="get\n            {\n                return TypeKind.Array;\n            } 232615"];
10490 [label="return TypeKind.Array; 232616"];
10491 [label="while (current.TypeKind == TypeKind.Array)\n            {\n                var cur = (ArrayTypeSymbol)current;\n                hash = Hash.Combine(cur.Rank, hash);\n                current = cur.ElementType;\n            } 232617"];
10492 [label="var cur = (ArrayTypeSymbol)current; 232618"];
10493 [label="cur.Rank 232619"];
10494 [label="get\n                {\n                    return 1;\n                } 232620"];
10495 [label="return 1; 232621"];
10496 [label="hash = Hash.Combine(cur.Rank, hash); 232622"];
10497 [label="hash = Hash.Combine(cur.Rank, hash); 232623"];
10498 [label="hash = Hash.Combine(cur.Rank, hash); 232624"];
10499 [label="cur.ElementType 232625"];
10500 [label="get\n            {\n                return _elementTypeWithAnnotations.Type;\n            } 232626"];
10501 [label="_elementTypeWithAnnotations.Type 232627"];
10502 [label="=> _extensions?.GetResolvedType(DefaultType) 232628"];
10503 [label=".GetResolvedType(DefaultType) 232629"];
10504 [label="=> defaultType 232630"];
10505 [label="return Hash.Combine(current, hash); 232631"];
10506 [label="return Hash.Combine(current, hash); 232632"];
10507 [label="this.SpecialType 232633"];
10508 [label="OriginalDefinition 232634"];
10509 [label="var v2 = sym1.GetHashCode(); 232635"];
10510 [label="CustomAssert.Equal(v1, v2); 232636"];
10511 [label="CustomAssert.Equal(v1, v2); 232637"];
10512 [label="CustomAssert.Equal(v1, v2); 232638"];
10513 [label="var sym2 = (classTest.GetMembers('AryField2').First() as FieldSymbol).Type; 232639"];
10514 [label="classTest.GetMembers('AryField2') 232640"];
10515 [label="param GetMembers(string name) 232641"];
10516 [label="param GetMembers(this) 232642"];
10517 [label="ImmutableArray<Symbol> members; 232643"];
10518 [label="members 232644"];
10519 [label="GetMembersByName() 232645"];
10520 [label="param GetMembersByName(this) 232646"];
10521 [label="if (this.state.HasComplete(CompletionPart.Members))\n            {\n                return _lazyMembersDictionary!;\n            } 232647"];
10522 [label="this.state.HasComplete(CompletionPart.Members) 232648"];
10523 [label="param HasComplete(CompletionPart part) 232649"];
10524 [label="param HasComplete(this) 232650"];
10525 [label="return (_completeParts & (int)part) == (int)part; 232651"];
10526 [label="return _lazyMembersDictionary!; 232652"];
10527 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 232653"];
10528 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 232654"];
10529 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 232655"];
10530 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 232656"];
10531 [label="return members; 232657"];
10532 [label="(classTest.GetMembers('AryField2').First() as FieldSymbol).Type 232658"];
10533 [label="=> TypeWithAnnotations.Type 232659"];
10534 [label="TypeWithAnnotations 232660"];
10535 [label="return GetFieldType(ConsList<FieldSymbol>.Empty); 232661"];
10536 [label="GetFieldType(ConsList<FieldSymbol>.Empty) 232662"];
10537 [label="param GetFieldType(ConsList<FieldSymbol> fieldsBeingBound) 232663"];
10538 [label="Debug.Assert(fieldsBeingBound != null); 232664"];
10539 [label="Debug.Assert(fieldsBeingBound != null); 232665"];
10540 [label="if (_lazyType != null)\n            {\n                return _lazyType.Value;\n            } 232666"];
10541 [label="if (_lazyType != null)\n            {\n                return _lazyType.Value;\n            } 232667"];
10542 [label="VariableDeclaratorNode 232668"];
10543 [label="this.SyntaxNode 232669"];
10544 [label="return (CSharpSyntaxNode)_syntaxReference.GetSyntax(); 232670"];
10545 [label="GetFieldDeclaration(declarator) 232671"];
10546 [label="this.DeclaringCompilation 232672"];
10547 [label="this.Kind 232673"];
10548 [label="get\n            {\n                return SymbolKind.Field;\n            } 232674"];
10549 [label="return SymbolKind.Field; 232675"];
10550 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 232676"];
10551 [label="this.ContainingModule 232677"];
10552 [label="this.ContainingSymbol 232678"];
10553 [label="return (object)container != null ? container.ContainingModule : null; 232679"];
10554 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 232680"];
10555 [label="var diagnostics = DiagnosticBag.GetInstance(); 232681"];
10556 [label="TypeWithAnnotations type; 232682"];
10557 [label="type 232683"];
10558 [label="DiagnosticBag diagnosticsForFirstDeclarator = DiagnosticBag.GetInstance(); 232684"];
10559 [label="this.AssociatedSymbol 232685"];
10560 [label="get\n            {\n                return null;\n            } 232686"];
10561 [label="return null; 232687"];
10562 [label="Symbol associatedPropertyOrEvent = this.AssociatedSymbol; 232688"];
10563 [label="if ((object)associatedPropertyOrEvent != null && associatedPropertyOrEvent.Kind == SymbolKind.Event)\n            {\n                EventSymbol @event = (EventSymbol)associatedPropertyOrEvent;\n                if (@event.IsWindowsRuntimeEvent)\n                {\n                    NamedTypeSymbol tokenTableType = this.DeclaringCompilation.GetWellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T);\n                    Binder.ReportUseSiteDiagnostics(tokenTableType, diagnosticsForFirstDeclarator, this.ErrorLocation);\n\n                    // CONSIDER: Do we want to guard against the possibility that someone has created their own EventRegistrationTokenTable<T>\n                    // type that has additional generic constraints?\n                    type = TypeWithAnnotations.Create(tokenTableType.Construct(ImmutableArray.Create(@event.TypeWithAnnotations)));\n                }\n                else\n                {\n                    type = @event.TypeWithAnnotations;\n                }\n            }\n            else\n            {\n                var binderFactory = compilation.GetBinderFactory(SyntaxTree);\n                var binder = binderFactory.GetBinder(typeSyntax);\n\n                binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this);\n                if (!ContainingType.IsScriptClass)\n                {\n                    type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator);\n                }\n                else\n                {\n                    bool isVar;\n                    type = binder.BindTypeOrVarKeyword(typeSyntax, diagnostics, out isVar);\n\n                    Debug.Assert(type.HasType || isVar);\n\n                    if (isVar)\n                    {\n                        if (this.IsConst)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableCannotBeConst, typeSyntax.Location);\n                        }\n\n                        if (fieldsBeingBound.ContainsReference(this))\n                        {\n                            diagnostics.Add(ErrorCode.ERR_RecursivelyTypedVariable, this.ErrorLocation, this);\n                            type = default;\n                        }\n                        else if (fieldSyntax.Declaration.Variables.Count > 1)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, typeSyntax.Location);\n                        }\n                        else if (this.IsConst && this.ContainingType.IsScriptClass)\n                        {\n                            // For const var in script, we won't try to bind the initializer (case below), as it can lead to an unbound recursion\n                            type = default;\n                        }\n                        else\n                        {\n                            fieldsBeingBound = new ConsList<FieldSymbol>(this, fieldsBeingBound);\n\n                            var initializerBinder = new ImplicitlyTypedFieldBinder(binder, fieldsBeingBound);\n                            var initializerOpt = initializerBinder.BindInferredVariableInitializer(diagnostics, RefKind.None, (EqualsValueClauseSyntax)declarator.Initializer, declarator);\n\n                            if (initializerOpt != null)\n                            {\n                                if ((object)initializerOpt.Type != null && !initializerOpt.Type.IsErrorType())\n                                {\n                                    type = TypeWithAnnotations.Create(initializerOpt.Type);\n                                }\n\n                                _lazyFieldTypeInferred = 1;\n                            }\n                        }\n\n                        if (!type.HasType)\n                        {\n                            type = TypeWithAnnotations.Create(binder.CreateErrorType('var'));\n                        }\n                    }\n                }\n\n                if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                }\n            } 232689"];
10564 [label="if ((object)associatedPropertyOrEvent != null && associatedPropertyOrEvent.Kind == SymbolKind.Event)\n            {\n                EventSymbol @event = (EventSymbol)associatedPropertyOrEvent;\n                if (@event.IsWindowsRuntimeEvent)\n                {\n                    NamedTypeSymbol tokenTableType = this.DeclaringCompilation.GetWellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T);\n                    Binder.ReportUseSiteDiagnostics(tokenTableType, diagnosticsForFirstDeclarator, this.ErrorLocation);\n\n                    // CONSIDER: Do we want to guard against the possibility that someone has created their own EventRegistrationTokenTable<T>\n                    // type that has additional generic constraints?\n                    type = TypeWithAnnotations.Create(tokenTableType.Construct(ImmutableArray.Create(@event.TypeWithAnnotations)));\n                }\n                else\n                {\n                    type = @event.TypeWithAnnotations;\n                }\n            }\n            else\n            {\n                var binderFactory = compilation.GetBinderFactory(SyntaxTree);\n                var binder = binderFactory.GetBinder(typeSyntax);\n\n                binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this);\n                if (!ContainingType.IsScriptClass)\n                {\n                    type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator);\n                }\n                else\n                {\n                    bool isVar;\n                    type = binder.BindTypeOrVarKeyword(typeSyntax, diagnostics, out isVar);\n\n                    Debug.Assert(type.HasType || isVar);\n\n                    if (isVar)\n                    {\n                        if (this.IsConst)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableCannotBeConst, typeSyntax.Location);\n                        }\n\n                        if (fieldsBeingBound.ContainsReference(this))\n                        {\n                            diagnostics.Add(ErrorCode.ERR_RecursivelyTypedVariable, this.ErrorLocation, this);\n                            type = default;\n                        }\n                        else if (fieldSyntax.Declaration.Variables.Count > 1)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, typeSyntax.Location);\n                        }\n                        else if (this.IsConst && this.ContainingType.IsScriptClass)\n                        {\n                            // For const var in script, we won't try to bind the initializer (case below), as it can lead to an unbound recursion\n                            type = default;\n                        }\n                        else\n                        {\n                            fieldsBeingBound = new ConsList<FieldSymbol>(this, fieldsBeingBound);\n\n                            var initializerBinder = new ImplicitlyTypedFieldBinder(binder, fieldsBeingBound);\n                            var initializerOpt = initializerBinder.BindInferredVariableInitializer(diagnostics, RefKind.None, (EqualsValueClauseSyntax)declarator.Initializer, declarator);\n\n                            if (initializerOpt != null)\n                            {\n                                if ((object)initializerOpt.Type != null && !initializerOpt.Type.IsErrorType())\n                                {\n                                    type = TypeWithAnnotations.Create(initializerOpt.Type);\n                                }\n\n                                _lazyFieldTypeInferred = 1;\n                            }\n                        }\n\n                        if (!type.HasType)\n                        {\n                            type = TypeWithAnnotations.Create(binder.CreateErrorType('var'));\n                        }\n                    }\n                }\n\n                if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                }\n            } 232690"];
10565 [label="SyntaxTree 232691"];
10566 [label="var binderFactory = compilation.GetBinderFactory(SyntaxTree); 232692"];
10567 [label="compilation.GetBinderFactory(SyntaxTree) 232693"];
10568 [label="param GetBinderFactory(bool ignoreAccessibility = false) 232694"];
10569 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 232695"];
10570 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 232696"];
10571 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 232697"];
10572 [label="param GetBinderFactory(bool ignoreAccessibility) 232698"];
10573 [label="ignoreAccessibility 232699"];
10574 [label="GetSyntaxTreeOrdinal(syntaxTree) 232700"];
10575 [label="this.ContainsSyntaxTree(tree) 232701"];
10576 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 232702"];
10577 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 232703"];
10578 [label="BinderFactory? previousFactory; 232704"];
10579 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 232705"];
10580 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 232706"];
10581 [label="return previousFactory; 232707"];
10582 [label="var binder = binderFactory.GetBinder(typeSyntax); 232708"];
10583 [label="binderFactory.GetBinder(typeSyntax) 232709"];
10584 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 232710"];
10585 [label="param GetBinder(Symbol memberOpt = null) 232711"];
10586 [label="InScript 232712"];
10587 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 232713"];
10588 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 232714"];
10589 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 232715"];
10590 [label="GetBinder(node, position, memberDeclarationOpt, memberOpt) 232716"];
10591 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 232717"];
10592 [label="param GetBinder(Symbol memberOpt = null) 232718"];
10593 [label="Debug.Assert(node != null); 232719"];
10594 [label="Debug.Assert(node != null); 232720"];
10595 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 232721"];
10596 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 232722"];
10597 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 232723"];
10598 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt) 232724"];
10599 [label="param Initialize(CSharpSyntaxNode memberDeclarationOpt) 232725"];
10600 [label="param Initialize(Symbol memberOpt) 232726"];
10601 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 232727"];
10602 [label="memberDeclarationOpt == null 232728"];
10603 [label="param ==(Symbol left) 232729"];
10604 [label="param ==(Symbol right) 232730"];
10605 [label="if (right is null)\n            {\n                return left is null;\n            } 232731"];
10606 [label="return left is null; 232732"];
10607 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 232733"];
10608 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 232734"];
10609 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 232735"];
10610 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 232736"];
10611 [label="visitor.Visit(node) 232737"];
10612 [label="VisitCore(node) 232738"];
10613 [label="return ((CSharpSyntaxNode)node).Accept(this); 232739"];
10614 [label="VisitCore(parent.Parent) 232740"];
10615 [label="VisitCore(parent.Parent) 232741"];
10616 [label="VisitTypeDeclarationCore(node) 232742"];
10617 [label="NodeUsage extraInfo = NodeUsage.Normal; 232743"];
10618 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 232744"];
10619 [label="VisitTypeDeclarationCore(parent, extraInfo) 232745"];
10620 [label="CreateBinderCacheKey(parent, extraInfo) 232746"];
10621 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 232747"];
10622 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 232748"];
10623 [label="return new BinderCacheKey(node, usage); 232749"];
10624 [label="new BinderCacheKey(node, usage) 232750"];
10625 [label="param BinderCacheKey(this) 232751"];
10626 [label="var key = CreateBinderCacheKey(parent, extraInfo); 232752"];
10627 [label="Binder resultBinder; 232753"];
10628 [label="binderCache 232754"];
10629 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 232755"];
10630 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 232756"];
10631 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 232757"];
10632 [label="param Equals(BinderCacheKey other) 232758"];
10633 [label="param Equals(this) 232759"];
10634 [label="return syntaxNode == other.syntaxNode && this.usage == other.usage; 232760"];
10635 [label="VisitCore(parent.Parent).WithUnsafeRegionIfNecessary(parent.Modifiers) 232761"];
10636 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 232762"];
10637 [label="this.Flags.Includes(BinderFlags.UnsafeRegion) 232763"];
10638 [label="param Includes(BinderFlags other) 232764"];
10639 [label="binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 232765"];
10640 [label="binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this) 232766"];
10641 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags flags) 232767"];
10642 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(Symbol containing) 232768"];
10643 [label="Debug.Assert((object)containing != null); 232769"];
10644 [label="Debug.Assert((object)containing != null); 232770"];
10645 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 232771"];
10646 [label="new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing) 232772"];
10647 [label="param BinderWithContainingMemberOrLambda(Symbol containingMemberOrLambda) 232773"];
10648 [label="param BinderWithContainingMemberOrLambda(this) 232774"];
10649 [label="param BinderWithContainingMemberOrLambda(this) 232775"];
10650 [label="param Binder(this) 232776"];
10651 [label="internal CSharpCompilation Compilation { get; } 232777"];
10652 [label="Flags 232778"];
10653 [label="protected internal Binder? Next { get; } 232779"];
10654 [label="_lazyConversions 232780"];
10655 [label="_lazyOverloadResolution 232781"];
10656 [label="RoslynDebug.Assert(next != null); 232782"];
10657 [label="RoslynDebug.Assert(next != null); 232783"];
10658 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion)); 232784"];
10659 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion)); 232785"];
10660 [label="flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion) 232786"];
10661 [label="param Includes(this BinderFlags self) 232787"];
10662 [label="param Includes(BinderFlags other) 232788"];
10663 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.InNestedFinallyBlock) || flags.Includes(BinderFlags.InFinallyBlock | BinderFlags.InCatchBlock)); 232789"];
10664 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.InNestedFinallyBlock) || flags.Includes(BinderFlags.InFinallyBlock | BinderFlags.InCatchBlock)); 232790"];
10665 [label="flags.Includes(BinderFlags.InNestedFinallyBlock) 232791"];
10666 [label="param Includes(this BinderFlags self) 232792"];
10667 [label="param Includes(BinderFlags other) 232793"];
10668 [label="_containingMemberOrLambda 232794"];
10669 [label="Debug.Assert(containingMemberOrLambda != null); 232795"];
10670 [label="containingMemberOrLambda != null 232796"];
10671 [label="param !=(Symbol left) 232797"];
10672 [label="param !=(Symbol right) 232798"];
10673 [label="if (right is null)\n            {\n                return left is object;\n            } 232799"];
10674 [label="return left is object; 232800"];
10675 [label="Debug.Assert(containingMemberOrLambda != null); 232801"];
10676 [label="_containingMemberOrLambda 232802"];
10677 [label="binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 232803"];
10678 [label="ContainingType 232804"];
10679 [label="ContainingType.IsScriptClass 232805"];
10680 [label="var kind = this.declaration.Declarations[0].Kind; 232806"];
10681 [label="param BindType(ConsList<TypeSymbol> basesBeingResolved = null) 232807"];
10682 [label="param BindType(bool suppressUseSiteDiagnostics = false) 232808"];
10683 [label="param BindTypeOrAlias(ConsList<TypeSymbol> basesBeingResolved = null) 232809"];
10684 [label="param BindTypeOrAlias(bool suppressUseSiteDiagnostics = false) 232810"];
10685 [label="Debug.Assert(diagnostics != null); 232811"];
10686 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 232812"];
10687 [label="param BindNamespaceOrTypeOrAliasSymbol(ConsList<TypeSymbol> basesBeingResolved) 232813"];
10688 [label="param BindNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 232814"];
10689 [label="param BindArrayType(bool permitDimensions) 232815"];
10690 [label="param BindArrayType(ConsList<TypeSymbol> basesBeingResolved) 232816"];
10691 [label="Debug.Assert(diagnostics != null); 232817"];
10692 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 232818"];
10693 [label="param BindNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 232819"];
10694 [label="param BindPredefinedTypeSymbol(DiagnosticBag diagnostics) 232820"];
10695 [label="param GetSpecialType(DiagnosticBag diagnostics) 232821"];
10696 [label="param GetSpecialType(SyntaxNode node) 232822"];
10697 [label="param GetSpecialType(SyntaxNode node) 232823"];
10698 [label="param GetSpecialType(DiagnosticBag diagnostics) 232824"];
10699 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 232825"];
10700 [label="NamedTypeSymbol result; 232826"];
10701 [label="GetBoundReferenceManager(); 232827"];
10702 [label="this.Modules 232828"];
10703 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 232829"];
10704 [label="module.GetReferencedAssemblies() 232830"];
10705 [label="param GetReferencedAssemblies(this) 232831"];
10706 [label="AssertReferencesInitialized() 232832"];
10707 [label="param AssertReferencesInitialized(this) 232833"];
10708 [label="Debug.Assert(_moduleReferences != null); 232834"];
10709 [label="Debug.Assert(_moduleReferences != null); 232835"];
10710 [label="AssertReferencesInitialized(); 232836"];
10711 [label="return _moduleReferences.Identities; 232837"];
10712 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 232838"];
10713 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 232839"];
10714 [label="result.SpecialType 232840"];
10715 [label="Debug.Assert(result.SpecialType == specialType); 232841"];
10716 [label="Debug.Assert((object)typeSymbol != null, 'Expect an error type if special type isn't found'); 232842"];
10717 [label="param ReportUseSiteDiagnostics(DiagnosticBag diagnostics) 232843"];
10718 [label="param ReportUseSiteDiagnostics(SyntaxNode node) 232844"];
10719 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 232845"];
10720 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 232846"];
10721 [label="s.Kind 232847"];
10722 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 232848"];
10723 [label="return SymbolKind.Namespace; 232849"];
10724 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 232850"];
10725 [label="Debug.Assert((object)moduleSymbol != null); 232851"];
10726 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 232852"];
10727 [label="param TransformType(int targetSymbolCustomModifierCount) 232853"];
10728 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 232854"];
10729 [label="Debug.Assert((object)metadataType != null); 232855"];
10730 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 232856"];
10731 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 232857"];
10732 [label="_elementNames 232858"];
10733 [label="elementNames.IsDefault 232859"];
10734 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 232860"];
10735 [label="_namesIndex 232861"];
10736 [label="_foundUsableErrorType = false; 232862"];
10737 [label="_foundUsableErrorType 232863"];
10738 [label="param DecodeType(this) 232864"];
10739 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 232865"];
10740 [label="param DecodeNamedType(this) 232866"];
10741 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 232867"];
10742 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 232868"];
10743 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 232869"];
10744 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 232870"];
10745 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 232871"];
10746 [label="DecodeTypeArguments(typeArgs) 232872"];
10747 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 232873"];
10748 [label="param DecodeTypeArguments(this) 232874"];
10749 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 232875"];
10750 [label="return typeArgs; 232876"];
10751 [label="type.ContainingType 232877"];
10752 [label="NamedTypeSymbol containingType = type.ContainingType; 232878"];
10753 [label="NamedTypeSymbol? decodedContainingType; 232879"];
10754 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 232880"];
10755 [label="decodedContainingType = containingType; 232881"];
10756 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 232882"];
10757 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 232883"];
10758 [label="var typeArgsChanged = typeArgs != decodedArgs; 232884"];
10759 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 232885"];
10760 [label="decodedType.IsTupleType 232886"];
10761 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 232887"];
10762 [label="_ 232888"];
10763 [label="tupleCardinality: out _ 232889"];
10764 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 232890"];
10765 [label="param IsTupleTypeOfCardinality(this) 232891"];
10766 [label="IsUnboundGenericType 232892"];
10767 [label="get\n            {\n                return false;\n            } 232893"];
10768 [label="return false; 232894"];
10769 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 232895"];
10770 [label="ContainingSymbol 232896"];
10771 [label="get\n            {\n                return _container;\n            } 232897"];
10772 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 232898"];
10773 [label=".Kind 232899"];
10774 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 232900"];
10775 [label="return SymbolKind.Namespace; 232901"];
10776 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 232902"];
10777 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 232903"];
10778 [label="ContainingNamespace 232904"];
10779 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 232905"];
10780 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 232906"];
10781 [label="ContainingNamespace.ContainingNamespace 232907"];
10782 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 232908"];
10783 [label=".IsGlobalNamespace 232909"];
10784 [label="get\n            {\n                return true;\n            } 232910"];
10785 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 232911"];
10786 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 232912"];
10787 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 232913"];
10788 [label="Name 232914"];
10789 [label="get\n            {\n                return _name;\n            } 232915"];
10790 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 232916"];
10791 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 232917"];
10792 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 232918"];
10793 [label="tupleCardinality = 0; 232919"];
10794 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 232920"];
10795 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 232921"];
10796 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 232922"];
10797 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 232923"];
10798 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 232924"];
10799 [label="typeSymbol.IsNullableType() 232925"];
10800 [label="param IsNullableType(this TypeSymbol type) 232926"];
10801 [label="var a1 = defaultType is null; 232927"];
10802 [label="!a1 232928"];
10803 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 232929"];
10804 [label="defaultType.IsNullableType() 232930"];
10805 [label="param IsNullableType(this TypeSymbol type) 232931"];
10806 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 232932"];
10807 [label="Debug.Assert(a1 || a2 != true || a3); 232933"];
10808 [label="Debug.Assert(a1 || a2 != true || a3); 232934"];
10809 [label="Debug.Assert(extensions != null); 232935"];
10810 [label="param TransformType(Symbol accessSymbol) 232936"];
10811 [label="metadataType.HasType 232937"];
10812 [label="Debug.Assert(metadataType.HasType); 232938"];
10813 [label="accessSymbol.IsDefinition 232939"];
10814 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 232940"];
10815 [label="OriginalDefinition 232941"];
10816 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 232942"];
10817 [label="OriginalSymbolDefinition 232943"];
10818 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 232944"];
10819 [label="this.OriginalTypeSymbolDefinition 232945"];
10820 [label="get\n            {\n                return this.OriginalDefinition;\n            } 232946"];
10821 [label="return this.OriginalTypeSymbolDefinition; 232947"];
10822 [label="return OriginalSymbolDefinition; 232948"];
10823 [label="return (object)this == (object)OriginalDefinition; 232949"];
10824 [label="Debug.Assert(accessSymbol.IsDefinition); 232950"];
10825 [label="accessSymbol.ContainingModule 232951"];
10826 [label="get\n            {\n                return ContainingPEModule;\n            } 232952"];
10827 [label="ContainingPEModule 232953"];
10828 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 232954"];
10829 [label="s.Kind 232955"];
10830 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 232956"];
10831 [label="return SymbolKind.Namespace; 232957"];
10832 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 232958"];
10833 [label="return ContainingPEModule; 232959"];
10834 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 232960"];
10835 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 232961"];
10836 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 232962"];
10837 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 232963"];
10838 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 232964"];
10839 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 232965"];
10840 [label="Debug.Assert(symbol is object); 232966"];
10841 [label="symbol.Kind 232967"];
10842 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 232968"];
10843 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 232969"];
10844 [label="isInternal = false; 232970"];
10845 [label="symbol.DeclaredAccessibility 232971"];
10846 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 232972"];
10847 [label="Accessibility access = Accessibility.Private; 232973"];
10848 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 232974"];
10849 [label="symbol.ContainingType 232975"];
10850 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 232976"];
10851 [label="symbol = symbol.ContainingType; 232977"];
10852 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 232978"];
10853 [label="return true; 232979"];
10854 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 232980"];
10855 [label="param TryGetByte(out byte? value) 232981"];
10856 [label="value = null; 232982"];
10857 [label="param GetNullableContextValue(this) 232983"];
10858 [label="param GetLocalNullableContextValue(this) 232984"];
10859 [label="get\n            {\n                return _moduleSymbol;\n            } 232985"];
10860 [label="return _moduleSymbol; 232986"];
10861 [label="param GetLocalNullableContextValue(this) 232987"];
10862 [label="get\n            {\n                return _assemblySymbol;\n            } 232988"];
10863 [label="return _assemblySymbol; 232989"];
10864 [label="param GetLocalNullableContextValue(this) 232990"];
10865 [label="get\n            {\n                return null;\n            } 232991"];
10866 [label="=> defaultType 232992"];
10867 [label="Debug.Assert((object)depends != null); 232993"];
10868 [label="Debug.Assert((object)depends != null); 232994"];
10869 [label="Debug.Assert((object)on != null); 232995"];
10870 [label="Debug.Assert((object)on != null); 232996"];
10871 [label="on.IsDefinition 232997"];
10872 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 232998"];
10873 [label="OriginalDefinition 232999"];
10874 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 233000"];
10875 [label="OriginalSymbolDefinition 233001"];
10876 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 233002"];
10877 [label="this.OriginalTypeSymbolDefinition 233003"];
10878 [label="get\n            {\n                return this.OriginalDefinition;\n            } 233004"];
10879 [label="return this.OriginalTypeSymbolDefinition; 233005"];
10880 [label="return OriginalSymbolDefinition; 233006"];
10881 [label="return (object)this == (object)OriginalDefinition; 233007"];
10882 [label="Debug.Assert(on.IsDefinition); 233008"];
10883 [label="depends.DeclaringCompilation 233009"];
10884 [label="get { return null; } 233010"];
10885 [label="return null; 233011"];
10886 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 233012"];
10887 [label="if ((object)type == null)\n            {\n                return;\n            } 233013"];
10888 [label="if ((object)type == null)\n            {\n                return;\n            } 233014"];
10889 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 233015"];
10890 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 233016"];
10891 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 233017"];
10892 [label="if ((object)type == null)\n            {\n                return;\n            } 233018"];
10893 [label="return; 233019"];
10894 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 233020"];
10895 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 233021"];
10896 [label="return result; 233022"];
10897 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 233023"];
10898 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 233024"];
10899 [label="@base.IsErrorType() 233025"];
10900 [label="param IsErrorType(this TypeSymbol type) 233026"];
10901 [label="RoslynDebug.Assert((object)type != null); 233027"];
10902 [label="RoslynDebug.Assert((object)type != null); 233028"];
10903 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 233029"];
10904 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 233030"];
10905 [label="return null; 233031"];
10906 [label="param MergeUseSiteDiagnostics(this) 233032"];
10907 [label="this.ContainingModule 233033"];
10908 [label="get\n            {\n                return ContainingPEModule;\n            } 233034"];
10909 [label="ContainingPEModule 233035"];
10910 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 233036"];
10911 [label="Symbol s = _container; 233037"];
10912 [label="s.Kind 233038"];
10913 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 233039"];
10914 [label="return SymbolKind.Namespace; 233040"];
10915 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 233041"];
10916 [label="return ContainingPEModule; 233042"];
10917 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 233043"];
10918 [label="this.ContainingModule.HasUnifiedReferences 233044"];
10919 [label="get { return GetUnifiedAssemblies().Length > 0; } 233045"];
10920 [label="GetUnifiedAssemblies() 233046"];
10921 [label="param GetUnifiedAssemblies(this) 233047"];
10922 [label="AssertReferencesInitialized() 233048"];
10923 [label="param AssertReferencesInitialized(this) 233049"];
10924 [label="Debug.Assert(_moduleReferences != null); 233050"];
10925 [label="Debug.Assert(_moduleReferences != null); 233051"];
10926 [label="AssertReferencesInitialized(); 233052"];
10927 [label="return GetUnifiedAssemblies().Length > 0; 233053"];
10928 [label="return GetUnifiedAssemblies().Length > 0; 233054"];
10929 [label="Symbol s = _container; 233055"];
10930 [label="s.Kind 233056"];
10931 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 233057"];
10932 [label="return SymbolKind.Namespace; 233058"];
10933 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 233059"];
10934 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 233060"];
10935 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 233061"];
10936 [label="result = TypeKind.Class; 233062"];
10937 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 233063"];
10938 [label="SpecialType 233064"];
10939 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 233065"];
10940 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 233066"];
10941 [label="TypeSymbol @base = GetDeclaredBaseType(null); 233067"];
10942 [label="GetDeclaredBaseType(null) 233068"];
10943 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 233069"];
10944 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 233070"];
10945 [label="TypeSymbol @base = GetDeclaredBaseType(null); 233071"];
10946 [label=".SpecialType 233072"];
10947 [label="get\n            {\n                return _corTypeId;\n            } 233073"];
10948 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 233074"];
10949 [label="return _lazyUseSiteDiagnostic; 233075"];
10950 [label="DiagnosticInfo info = symbol.GetUseSiteDiagnostic(); 233076"];
10951 [label="return info != null && Symbol.ReportUseSiteDiagnostic(info, diagnostics, node.Location); 233077"];
10952 [label="return info != null && Symbol.ReportUseSiteDiagnostic(info, diagnostics, node.Location); 233078"];
10953 [label="if (typeSymbol is null)\n            {\n                return default;\n            } 233079"];
10954 [label="isNullableEnabled 233080"];
10955 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 233081"];
10956 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 233082"];
10957 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 233083"];
10958 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 233084"];
10959 [label="typeSymbol.IsNullableType() 233085"];
10960 [label="param IsNullableType(this TypeSymbol type) 233086"];
10961 [label="var a1 = defaultType is null; 233087"];
10962 [label="!a1 233088"];
10963 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 233089"];
10964 [label="defaultType.IsNullableType() 233090"];
10965 [label="param IsNullableType(this TypeSymbol type) 233091"];
10966 [label="return _corTypeId; 233092"];
10967 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 233093"];
10968 [label="Debug.Assert(a1 || a2 != true || a3); 233094"];
10969 [label="Debug.Assert(extensions != null); 233095"];
10970 [label="typeWithAnnotations.HasType 233096"];
10971 [label="=> !(DefaultType is null) 233097"];
10972 [label="Debug.Assert(typeWithAnnotations.HasType); 233098"];
10973 [label="_symbol = null; 233099"];
10974 [label="_symbol 233100"];
10975 [label="_isNullableEnabled = false; 233101"];
10976 [label="_isNullableEnabled 233102"];
10977 [label="param ReportDiagnosticsIfObsolete(Binder binder) 233103"];
10978 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 233104"];
10979 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 233105"];
10980 [label="binder 233106"];
10981 [label="syntax 233107"];
10982 [label="diagnostics 233108"];
10983 [label="param ReportDiagnosticsIfObsolete(Binder binder) 233109"];
10984 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 233110"];
10985 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 233111"];
10986 [label="param ReportDiagnosticsIfObsolete(this) 233112"];
10987 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 233113"];
10988 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 233114"];
10989 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 233115"];
10990 [label="param ReportDiagnosticsIfObsoleteCore(Binder binder) 233116"];
10991 [label="param ReportDiagnosticsIfObsoleteCore(SyntaxNode syntax) 233117"];
10992 [label="param ReportDiagnosticsIfObsoleteCore(DiagnosticBag diagnostics) 233118"];
10993 [label="=> defaultType 233119"];
10994 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 233120"];
10995 [label="param ReportDiagnosticsIfObsolete(SyntaxNode node) 233121"];
10996 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 233122"];
10997 [label="param ReportDiagnosticsIfObsolete(this) 233123"];
10998 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 233124"];
10999 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 233125"];
11000 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 233126"];
11001 [label="param ReportDiagnosticsIfObsolete(this) 233127"];
11002 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 233128"];
11003 [label="this.ContainingMemberOrLambda 233129"];
11004 [label="get { return _containingMemberOrLambda; } 233130"];
11005 [label="return _containingMemberOrLambda; 233131"];
11006 [label="this.ContainingType 233132"];
11007 [label="get\n            {\n                var member = this.ContainingMemberOrLambda;\n                RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType);\n                return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                };\n            } 233133"];
11008 [label="this.ContainingMemberOrLambda 233134"];
11009 [label="get { return _containingMemberOrLambda; } 233135"];
11010 [label="return _containingMemberOrLambda; 233136"];
11011 [label="var member = this.ContainingMemberOrLambda; 233137"];
11012 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 233138"];
11013 [label="member.Kind 233139"];
11014 [label="get\n            {\n                return SymbolKind.Field;\n            } 233140"];
11015 [label="return SymbolKind.Field; 233141"];
11016 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 233142"];
11017 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 233143"];
11018 [label="member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                } 233144"];
11019 [label="member.ContainingType 233145"];
11020 [label="return this.containingType; 233146"];
11021 [label="return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                }; 233147"];
11022 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 233148"];
11023 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 233149"];
11024 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 233150"];
11025 [label="param ReportDiagnosticsIfObsolete(Symbol? containingMember) 233151"];
11026 [label="param ReportDiagnosticsIfObsolete(NamedTypeSymbol? containingType) 233152"];
11027 [label="param ReportDiagnosticsIfObsolete(BinderFlags location) 233153"];
11028 [label="RoslynDebug.Assert(symbol is object); 233154"];
11029 [label="symbol.Kind 233155"];
11030 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 233156"];
11031 [label="RoslynDebug.Assert(symbol.Kind == SymbolKind.NamedType ||\n                         symbol.Kind == SymbolKind.Field ||\n                         symbol.Kind == SymbolKind.Method ||\n                         symbol.Kind == SymbolKind.Event ||\n                         symbol.Kind == SymbolKind.Property); 233157"];
11032 [label="symbol.Kind 233158"];
11033 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 233159"];
11034 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                symbol = ((MethodSymbol)symbol).ConstructedFrom;\n            } 233160"];
11035 [label="param GetLeastOverriddenMember(NamedTypeSymbol accessingTypeOpt) 233161"];
11036 [label="bool checkOverridingSymbol = hasBaseReceiver && !ReferenceEquals(symbol, leastOverriddenSymbol); 233162"];
11037 [label="if (checkOverridingSymbol)\n            {\n                // If we have a base receiver, we must be done with declaration binding, so it should\n                // be safe to decode diagnostics.  We want to do this since reporting for the overriding\n                // member is conditional on reporting for the overridden member (i.e. we need a definite\n                // answer so we don't double-report).  You might think that double reporting just results\n                // in cascading diagnostics, but it's possible that the second diagnostic is an error\n                // while the first is merely a warning.\n                leastOverriddenSymbol.GetAttributes();\n            } 233163"];
11038 [label="param ReportDiagnosticsIfObsoleteInternal(DiagnosticBag diagnostics) 233164"];
11039 [label="param ReportDiagnosticsIfObsoleteInternal(SyntaxNodeOrToken node) 233165"];
11040 [label="param ReportDiagnosticsIfObsoleteInternal(Symbol? containingMember) 233166"];
11041 [label="param ReportDiagnosticsIfObsoleteInternal(BinderFlags location) 233167"];
11042 [label="RoslynDebug.Assert(diagnostics != null); 233168"];
11043 [label="RoslynDebug.Assert(diagnostics != null); 233169"];
11044 [label="param GetObsoleteDiagnosticKind(Symbol containingMember) 233170"];
11045 [label="param GetObsoleteDiagnosticKind(bool forceComplete = false) 233171"];
11046 [label="s.Kind 233172"];
11047 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 233173"];
11048 [label="return SymbolKind.Namespace; 233174"];
11049 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 233175"];
11050 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return null;\n                } 233176"];
11051 [label="Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified'); 233177"];
11052 [label="Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified'); 233178"];
11053 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                } 233179"];
11054 [label="var isByRefLike = ThreeState.False; 233180"];
11055 [label="Debug.Assert((object)moduleSymbol != null); 233181"];
11056 [label="Debug.Assert(obsoleteAttributeData == null || !obsoleteAttributeData.IsUninitialized); 233182"];
11057 [label="Debug.Assert(obsoleteAttributeData == null || !obsoleteAttributeData.IsUninitialized); 233183"];
11058 [label="return uncommon.lazyObsoleteAttributeData; 233184"];
11059 [label="var data = this.ObsoleteAttributeData; 233185"];
11060 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 233186"];
11061 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 233187"];
11062 [label="(data == null) 233188"];
11063 [label="switch (symbol.ObsoleteKind)\n            {\n                case ObsoleteAttributeKind.None:\n                    return ObsoleteDiagnosticKind.NotObsolete;\n                case ObsoleteAttributeKind.Experimental:\n                    return ObsoleteDiagnosticKind.Diagnostic;\n                case ObsoleteAttributeKind.Uninitialized:\n                    // If we haven't cracked attributes on the symbol at all or we haven't\n                    // cracked attribute arguments enough to be able to report diagnostics for\n                    // ObsoleteAttribute, store the symbol so that we can report diagnostics at a \n                    // later stage.\n                    return ObsoleteDiagnosticKind.Lazy;\n            } 233189"];
11064 [label="return ObsoleteDiagnosticKind.NotObsolete; 233190"];
11065 [label="DiagnosticInfo? info = null; 233191"];
11066 [label="switch (kind)\n            {\n                case ObsoleteDiagnosticKind.Diagnostic:\n                    info = ObsoleteAttributeHelpers.CreateObsoleteDiagnostic(symbol, location);\n                    break;\n                case ObsoleteDiagnosticKind.Lazy:\n                case ObsoleteDiagnosticKind.LazyPotentiallySuppressed:\n                    info = new LazyObsoleteDiagnosticInfo(symbol, containingMember, location);\n                    break;\n            } 233192"];
11067 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 233193"];
11068 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 233194"];
11069 [label="return kind; 233195"];
11070 [label="switch (diagnosticKind)\n            {\n                case ObsoleteDiagnosticKind.NotObsolete:\n                case ObsoleteDiagnosticKind.Lazy:\n                    if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    }\n                    break;\n            } 233196"];
11071 [label="if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    } 233197"];
11072 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 233198"];
11073 [label="param UnwrapAlias(DiagnosticBag diagnostics) 233199"];
11074 [label="param UnwrapAlias(SyntaxNode syntax) 233200"];
11075 [label="param UnwrapAlias(ConsList<TypeSymbol> basesBeingResolved = null) 233201"];
11076 [label="param UnwrapAlias(this) 233202"];
11077 [label="symbol.IsAlias 233203"];
11078 [label="=> _symbol?.Kind == SymbolKind.Alias 233204"];
11079 [label="_symbol 233205"];
11080 [label="_symbol?.Kind == SymbolKind.Alias 233206"];
11081 [label="if (symbol.IsAlias)\n            {\n                AliasSymbol discarded;\n                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out discarded, diagnostics, syntax, basesBeingResolved));\n            } 233207"];
11082 [label="type.IsStatic 233208"];
11083 [label="=>\n            _extensions.IsStatic(DefaultType) 233209"];
11084 [label="DefaultType 233210"];
11085 [label="_extensions.IsStatic(DefaultType) 233211"];
11086 [label="param IsStatic(TypeSymbol typeSymbol) 233212"];
11087 [label="=> typeSymbol.IsStatic 233213"];
11088 [label="typeSymbol.IsStatic 233214"];
11089 [label="get\n            {\n                return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0;\n            } 233215"];
11090 [label="return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0; 233216"];
11091 [label="return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0; 233217"];
11092 [label="if (type.IsStatic)\n            {\n                // CS0719: '{0}': array elements cannot be of static type\n                Error(diagnostics, ErrorCode.ERR_ArrayOfStaticClass, node.ElementType, type.Type);\n            } 233218"];
11093 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 233219"];
11094 [label="GetBoundReferenceManager(); 233220"];
11095 [label="this.Modules 233221"];
11096 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 233222"];
11097 [label="module.GetReferencedAssemblies() 233223"];
11098 [label="param GetReferencedAssemblies(this) 233224"];
11099 [label="AssertReferencesInitialized() 233225"];
11100 [label="param AssertReferencesInitialized(this) 233226"];
11101 [label="Debug.Assert(_moduleReferences != null); 233227"];
11102 [label="Debug.Assert(_moduleReferences != null); 233228"];
11103 [label="AssertReferencesInitialized(); 233229"];
11104 [label="return _moduleReferences.Identities; 233230"];
11105 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 233231"];
11106 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 233232"];
11107 [label="param IsErrorType(this TypeSymbol type) 233233"];
11108 [label="RoslynDebug.Assert((object)type != null); 233234"];
11109 [label="RoslynDebug.Assert((object)type != null); 233235"];
11110 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 233236"];
11111 [label="EnsureTypeParametersAreLoaded(); 233237"];
11112 [label="param AbstractTypeMap(this) 233238"];
11113 [label="Mapping 233239"];
11114 [label="_lazyTupleData 233240"];
11115 [label="_underlyingType 233241"];
11116 [label="Debug.Assert((object)underlyingType != null); 233242"];
11117 [label="_unbound 233243"];
11118 [label="_inputMap 233244"];
11119 [label="_newContainer 233245"];
11120 [label="_lazyMap 233246"];
11121 [label="originalDefinition.IsDefinition 233247"];
11122 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 233248"];
11123 [label="OriginalDefinition 233249"];
11124 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 233250"];
11125 [label="OriginalSymbolDefinition 233251"];
11126 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 233252"];
11127 [label="this.OriginalTypeSymbolDefinition 233253"];
11128 [label="get\n            {\n                return this.OriginalDefinition;\n            } 233254"];
11129 [label="return this.OriginalTypeSymbolDefinition; 233255"];
11130 [label="return OriginalSymbolDefinition; 233256"];
11131 [label="return (object)this == (object)OriginalDefinition; 233257"];
11132 [label="Debug.Assert(originalDefinition.IsDefinition); 233258"];
11133 [label="Debug.Assert(!originalDefinition.IsErrorType()); 233259"];
11134 [label="originalDefinition.IsErrorType() 233260"];
11135 [label="param IsErrorType(this TypeSymbol type) 233261"];
11136 [label="RoslynDebug.Assert((object)type != null); 233262"];
11137 [label="RoslynDebug.Assert((object)type != null); 233263"];
11138 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 233264"];
11139 [label="Debug.Assert(!originalDefinition.IsErrorType()); 233265"];
11140 [label="constructedFrom.ConstructedFrom 233266"];
11141 [label="get\n            {\n                return this;\n            } 233267"];
11142 [label="return this; 233268"];
11143 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 233269"];
11144 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 233270"];
11145 [label="_constructedFrom 233271"];
11146 [label="constructedFrom.Arity 233272"];
11147 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 233273"];
11148 [label="constructedFrom.Arity 233274"];
11149 [label="Debug.Assert(constructedFrom.Arity != 0); 233275"];
11150 [label="Debug.Assert(constructedFrom.Arity != 0); 233276"];
11151 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 233277"];
11152 [label="EnsureTypeParametersAreLoaded(); 233278"];
11153 [label="param AbstractTypeMap(this) 233279"];
11154 [label="Mapping 233280"];
11155 [label="_lazyTupleData 233281"];
11156 [label="_underlyingType 233282"];
11157 [label="Debug.Assert((object)underlyingType != null); 233283"];
11158 [label="_unbound 233284"];
11159 [label="_inputMap 233285"];
11160 [label="_newContainer 233286"];
11161 [label="_lazyMap 233287"];
11162 [label="originalDefinition.IsDefinition 233288"];
11163 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 233289"];
11164 [label="OriginalDefinition 233290"];
11165 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 233291"];
11166 [label="OriginalSymbolDefinition 233292"];
11167 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 233293"];
11168 [label="this.OriginalTypeSymbolDefinition 233294"];
11169 [label="get\n            {\n                return this.OriginalDefinition;\n            } 233295"];
11170 [label="return this.OriginalTypeSymbolDefinition; 233296"];
11171 [label="return OriginalSymbolDefinition; 233297"];
11172 [label="return (object)this == (object)OriginalDefinition; 233298"];
11173 [label="Debug.Assert(originalDefinition.IsDefinition); 233299"];
11174 [label="Debug.Assert(!originalDefinition.IsErrorType()); 233300"];
11175 [label="param IsErrorType(this TypeSymbol type) 233301"];
11176 [label="RoslynDebug.Assert((object)type != null); 233302"];
11177 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 233303"];
11178 [label="constructedFrom.ConstructedFrom 233304"];
11179 [label="get\n            {\n                return this;\n            } 233305"];
11180 [label="return this; 233306"];
11181 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 233307"];
11182 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 233308"];
11183 [label="_constructedFrom 233309"];
11184 [label="constructedFrom.Arity 233310"];
11185 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 233311"];
11186 [label="constructedFrom.Arity 233312"];
11187 [label="Debug.Assert(constructedFrom.Arity != 0); 233313"];
11188 [label="Debug.Assert(constructedFrom.Arity != 0); 233314"];
11189 [label="_baseType 233315"];
11190 [label="elementTypeWithAnnotations.HasType 233316"];
11191 [label="Debug.Assert(elementTypeWithAnnotations.HasType); 233317"];
11192 [label="RoslynDebug.Assert((object)array != null); 233318"];
11193 [label="Debug.Assert(constructedInterfaces.Length <= 2); 233319"];
11194 [label="Debug.Assert(constructedInterfaces.Length <= 2); 233320"];
11195 [label="if (typeSymbol is null)\n            {\n                return default;\n            } 233321"];
11196 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 233322"];
11197 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 233323"];
11198 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 233324"];
11199 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 233325"];
11200 [label="typeSymbol.IsNullableType() 233326"];
11201 [label="param IsNullableType(this TypeSymbol type) 233327"];
11202 [label="get\n            {\n                return this;\n            } 233328"];
11203 [label="return this; 233329"];
11204 [label="get\n            {\n                return SpecialType.None;\n            } 233330"];
11205 [label="return SpecialType.None; 233331"];
11206 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 233332"];
11207 [label="var a1 = defaultType is null; 233333"];
11208 [label="!a1 233334"];
11209 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 233335"];
11210 [label="defaultType.IsNullableType() 233336"];
11211 [label="param IsNullableType(this TypeSymbol type) 233337"];
11212 [label="get\n            {\n                return this;\n            } 233338"];
11213 [label="return this; 233339"];
11214 [label="get\n            {\n                return SpecialType.None;\n            } 233340"];
11215 [label="return SpecialType.None; 233341"];
11216 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 233342"];
11217 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 233343"];
11218 [label="Debug.Assert(a1 || a2 != true || a3); 233344"];
11219 [label="Debug.Assert(a1 || a2 != true || a3); 233345"];
11220 [label="Debug.Assert(extensions != null); 233346"];
11221 [label="Debug.Assert(extensions != null); 233347"];
11222 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 233348"];
11223 [label="GetBoundReferenceManager(); 233349"];
11224 [label="this.Modules 233350"];
11225 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 233351"];
11226 [label="module.GetReferencedAssemblies() 233352"];
11227 [label="param GetReferencedAssemblies(this) 233353"];
11228 [label="AssertReferencesInitialized() 233354"];
11229 [label="param AssertReferencesInitialized(this) 233355"];
11230 [label="Debug.Assert(_moduleReferences != null); 233356"];
11231 [label="Debug.Assert(_moduleReferences != null); 233357"];
11232 [label="AssertReferencesInitialized(); 233358"];
11233 [label="return _moduleReferences.Identities; 233359"];
11234 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 233360"];
11235 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 233361"];
11236 [label="param IsErrorType(this TypeSymbol type) 233362"];
11237 [label="RoslynDebug.Assert((object)type != null); 233363"];
11238 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 233364"];
11239 [label="Debug.Assert(constructedInterfaces.Length <= 2); 233365"];
11240 [label="typeWithAnnotations.HasType 233366"];
11241 [label="=> !(DefaultType is null) 233367"];
11242 [label="Debug.Assert(typeWithAnnotations.HasType); 233368"];
11243 [label="_symbol = null; 233369"];
11244 [label="_symbol 233370"];
11245 [label="_isNullableEnabled = false; 233371"];
11246 [label="_isNullableEnabled 233372"];
11247 [label="param ReportDiagnosticsIfObsolete(Binder binder) 233373"];
11248 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 233374"];
11249 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 233375"];
11250 [label="binder 233376"];
11251 [label="syntax 233377"];
11252 [label="diagnostics 233378"];
11253 [label="param ReportDiagnosticsIfObsolete(Binder binder) 233379"];
11254 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 233380"];
11255 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 233381"];
11256 [label="param ReportDiagnosticsIfObsolete(this) 233382"];
11257 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 233383"];
11258 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 233384"];
11259 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 233385"];
11260 [label="param ReportDiagnosticsIfObsoleteCore(Binder binder) 233386"];
11261 [label="param ReportDiagnosticsIfObsoleteCore(SyntaxNode syntax) 233387"];
11262 [label="param ReportDiagnosticsIfObsoleteCore(DiagnosticBag diagnostics) 233388"];
11263 [label="=> defaultType 233389"];
11264 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 233390"];
11265 [label="param ReportDiagnosticsIfObsolete(SyntaxNode node) 233391"];
11266 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 233392"];
11267 [label="param ReportDiagnosticsIfObsolete(this) 233393"];
11268 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 233394"];
11269 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 233395"];
11270 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 233396"];
11271 [label="param ReportDiagnosticsIfObsolete(this) 233397"];
11272 [label="get\n            {\n                return SymbolKind.ArrayType;\n            } 233398"];
11273 [label="return SymbolKind.ArrayType; 233399"];
11274 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 233400"];
11275 [label="param UnwrapAlias(ConsList<TypeSymbol> basesBeingResolved = null) 233401"];
11276 [label="=> _symbol?.Kind == SymbolKind.Alias 233402"];
11277 [label="_symbol 233403"];
11278 [label="_symbol?.Kind == SymbolKind.Alias 233404"];
11279 [label="if (symbol.IsAlias)\n            {\n                AliasSymbol discarded;\n                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out discarded, diagnostics, syntax, basesBeingResolved));\n            } 233405"];
11280 [label="IsFixedSizeBuffer 233406"];
11281 [label="=> (Modifiers & DeclarationModifiers.Fixed) != 0 233407"];
11282 [label="Modifiers 233408"];
11283 [label="get\n            {\n                return _modifiers;\n            } 233409"];
11284 [label="return _modifiers; 233410"];
11285 [label="Modifiers & DeclarationModifiers.Fixed 233411"];
11286 [label="0 233412"];
11287 [label="(Modifiers & DeclarationModifiers.Fixed) != 0 233413"];
11288 [label="if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                } 233414"];
11289 [label="this.RequiredCustomModifiers 233415"];
11290 [label="IsVolatile 233416"];
11291 [label="Modifiers 233417"];
11292 [label="0 233418"];
11293 [label="type.WithModifiers(this.RequiredCustomModifiers) 233419"];
11294 [label="_extensions.WithModifiers(this, customModifiers) 233420"];
11295 [label="param WithModifiers(this) 233421"];
11296 [label="CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers) 233422"];
11297 [label="Extensions.Create(customModifiers) 233423"];
11298 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 233424"];
11299 [label="new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)) 233425"];
11300 [label="param TypeWithAnnotations(this) 233426"];
11301 [label="var a1 = defaultType is null; 233427"];
11302 [label="!a1 233428"];
11303 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 233429"];
11304 [label="defaultType.IsNullableType() 233430"];
11305 [label="param IsNullableType(this TypeSymbol type) 233431"];
11306 [label="get\n            {\n                return this;\n            } 233432"];
11307 [label="return this; 233433"];
11308 [label="get\n            {\n                return SpecialType.None;\n            } 233434"];
11309 [label="return SpecialType.None; 233435"];
11310 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 233436"];
11311 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 233437"];
11312 [label="Debug.Assert(a1 || a2 != true || a3); 233438"];
11313 [label="Debug.Assert(a1 || a2 != true || a3); 233439"];
11314 [label="Debug.Assert(extensions != null); 233440"];
11315 [label="Debug.Assert(extensions != null); 233441"];
11316 [label="return CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers); 233442"];
11317 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 233443"];
11318 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 233444"];
11319 [label="new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)) 233445"];
11320 [label="param Boxed(TypeWithAnnotations value) 233446"];
11321 [label="param Boxed(this) 233447"];
11322 [label="Value 233448"];
11323 [label="type.IsStatic 233449"];
11324 [label="get\n            {\n                return false;\n            } 233450"];
11325 [label="return false; 233451"];
11326 [label="if (type.IsStatic)\n            {\n                // Cannot declare a variable of static type '{0}'\n                diagnostics.Add(ErrorCode.ERR_VarDeclIsStaticClass, this.ErrorLocation, type);\n            }\n            else if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 233452"];
11327 [label="if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 233453"];
11328 [label="type.IsVoidType() 233454"];
11329 [label="param IsVoidType(this TypeSymbol type) 233455"];
11330 [label="type.SpecialType 233456"];
11331 [label="get\n            {\n                return SpecialType.None;\n            } 233457"];
11332 [label="return SpecialType.None; 233458"];
11333 [label="return type.SpecialType == SpecialType.System_Void; 233459"];
11334 [label="if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 233460"];
11335 [label="if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 233461"];
11336 [label="if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 233462"];
11337 [label="type.IsRestrictedType(ignoreSpanLikeTypes: true) 233463"];
11338 [label="param IsRestrictedType(this TypeSymbol type) 233464"];
11339 [label="param IsRestrictedType(bool ignoreSpanLikeTypes = false) 233465"];
11340 [label="RoslynDebug.Assert((object)type != null); 233466"];
11341 [label="RoslynDebug.Assert((object)type != null); 233467"];
11342 [label="type.SpecialType 233468"];
11343 [label="get\n            {\n                return SpecialType.None;\n            } 233469"];
11344 [label="switch (type.SpecialType)\n            {\n                case SpecialType.System_TypedReference:\n                case SpecialType.System_ArgIterator:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            } 233470"];
11345 [label="ignoreSpanLikeTypes 233471"];
11346 [label="return ignoreSpanLikeTypes ?\n                        false :\n                        type.IsRefLikeType; 233472"];
11347 [label="type.IsRefLikeType 233473"];
11348 [label="get\n            {\n                return false;\n            } 233474"];
11349 [label="return false; 233475"];
11350 [label="if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 233476"];
11351 [label="IsConst 233477"];
11352 [label="=> (Modifiers & DeclarationModifiers.Const) != 0 233478"];
11353 [label="Modifiers 233479"];
11354 [label="get\n            {\n                return _modifiers;\n            } 233480"];
11355 [label="Modifiers & DeclarationModifiers.Const 233481"];
11356 [label="0 233482"];
11357 [label="(Modifiers & DeclarationModifiers.Const) != 0 233483"];
11358 [label="if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 233484"];
11359 [label="IsVolatile 233485"];
11360 [label="if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 233486"];
11361 [label="param VisitType(Func<TypeWithAnnotations, T, bool, bool>? typeWithAnnotationsPredicate) 233487"];
11362 [label="param VisitType(bool useDefaultType = false) 233488"];
11363 [label="typeWithAnnotationsOpt.HasType 233489"];
11364 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 233490"];
11365 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 233491"];
11366 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 233492"];
11367 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 233493"];
11368 [label="current.TypeKind 233494"];
11369 [label="get\n            {\n                return TypeKind.Array;\n            } 233495"];
11370 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 233496"];
11371 [label="param IsTypeLessVisibleThan(Symbol sym) 233497"];
11372 [label="get\n            {\n                return TypeKind.Array;\n            } 233498"];
11373 [label="TypeWithAnnotations next; 233499"];
11374 [label="next 233500"];
11375 [label="get\n            {\n                return TypeKind.Array;\n            } 233501"];
11376 [label="=> typeSymbol.StrippedType() 233502"];
11377 [label="get\n            {\n                return this;\n            } 233503"];
11378 [label="return this; 233504"];
11379 [label="get\n            {\n                return SpecialType.None;\n            } 233505"];
11380 [label="return SpecialType.None; 233506"];
11381 [label="return type.IsNullableType() ? type.GetNullableUnderlyingType() : type; 233507"];
11382 [label="get\n            {\n                return TypeKind.Array;\n            } 233508"];
11383 [label="param IsTypeLessVisibleThan(Symbol sym) 233509"];
11384 [label="get\n            {\n                return TypeKind.Array;\n            } 233510"];
11385 [label="get\n            {\n                return TypeKind.Array;\n            } 233511"];
11386 [label="=> typeSymbol.StrippedType() 233512"];
11387 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 233513"];
11388 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 233514"];
11389 [label="current.ContainingType 233515"];
11390 [label="var containingType = current.ContainingType; 233516"];
11391 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 233517"];
11392 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 233518"];
11393 [label="param IsAsRestrictive(Symbol sym2) 233519"];
11394 [label="Accessibility access = Accessibility.Private; 233520"];
11395 [label="((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 233521"];
11396 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 233522"];
11397 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 233523"];
11398 [label="var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 233524"];
11399 [label="if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        } 233525"];
11400 [label="return null; 233526"];
11401 [label="return result is null; 233527"];
11402 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 233528"];
11403 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 233529"];
11404 [label="TypeWithAnnotations.Type 233530"];
11405 [label=".GetResolvedType(DefaultType) 233531"];
11406 [label="=> defaultType 233532"];
11407 [label="CustomAssert.Equal(SymbolKind.ArrayType, sym2.Kind); 233533"];
11408 [label="sym2.Kind 233534"];
11409 [label="get\n            {\n                return SymbolKind.ArrayType;\n            } 233535"];
11410 [label="return SymbolKind.ArrayType; 233536"];
11411 [label="CustomAssert.Equal(SymbolKind.ArrayType, sym2.Kind); 233537"];
11412 [label="sym2.GetHashCode() 233538"];
11413 [label="param GetHashCode(this) 233539"];
11414 [label="int hash = 0; 233540"];
11415 [label="current.TypeKind 233541"];
11416 [label="get\n            {\n                return TypeKind.Array;\n            } 233542"];
11417 [label="return TypeKind.Array; 233543"];
11418 [label="while (current.TypeKind == TypeKind.Array)\n            {\n                var cur = (ArrayTypeSymbol)current;\n                hash = Hash.Combine(cur.Rank, hash);\n                current = cur.ElementType;\n            } 233544"];
11419 [label="cur.Rank 233545"];
11420 [label="get\n                {\n                    return 1;\n                } 233546"];
11421 [label="return 1; 233547"];
11422 [label="hash = Hash.Combine(cur.Rank, hash); 233548"];
11423 [label="hash = Hash.Combine(cur.Rank, hash); 233549"];
11424 [label="hash = Hash.Combine(cur.Rank, hash); 233550"];
11425 [label="cur.ElementType 233551"];
11426 [label="_elementTypeWithAnnotations.Type 233552"];
11427 [label=".GetResolvedType(DefaultType) 233553"];
11428 [label="=> defaultType 233554"];
11429 [label="return Hash.Combine(current, hash); 233555"];
11430 [label="return Hash.Combine(current, hash); 233556"];
11431 [label="this.SpecialType 233557"];
11432 [label="OriginalDefinition 233558"];
11433 [label="v1 = sym2.GetHashCode(); 233559"];
11434 [label="sym2.GetHashCode() 233560"];
11435 [label="param GetHashCode(this) 233561"];
11436 [label="int hash = 0; 233562"];
11437 [label="current.TypeKind 233563"];
11438 [label="get\n            {\n                return TypeKind.Array;\n            } 233564"];
11439 [label="return TypeKind.Array; 233565"];
11440 [label="while (current.TypeKind == TypeKind.Array)\n            {\n                var cur = (ArrayTypeSymbol)current;\n                hash = Hash.Combine(cur.Rank, hash);\n                current = cur.ElementType;\n            } 233566"];
11441 [label="cur.Rank 233567"];
11442 [label="get\n                {\n                    return 1;\n                } 233568"];
11443 [label="return 1; 233569"];
11444 [label="hash = Hash.Combine(cur.Rank, hash); 233570"];
11445 [label="hash = Hash.Combine(cur.Rank, hash); 233571"];
11446 [label="hash = Hash.Combine(cur.Rank, hash); 233572"];
11447 [label="cur.ElementType 233573"];
11448 [label="_elementTypeWithAnnotations.Type 233574"];
11449 [label="=> _extensions?.GetResolvedType(DefaultType) 233575"];
11450 [label=".GetResolvedType(DefaultType) 233576"];
11451 [label="=> defaultType 233577"];
11452 [label="get\n            {\n                return TypeKind.Array;\n            } 233578"];
11453 [label="get\n                {\n                    return 1;\n                } 233579"];
11454 [label="return Hash.Combine(current, hash); 233580"];
11455 [label="return Hash.Combine(current, hash); 233581"];
11456 [label="this.SpecialType 233582"];
11457 [label="OriginalDefinition 233583"];
11458 [label="v2 = sym2.GetHashCode(); 233584"];
11459 [label="CustomAssert.Equal(v1, v2); 233585"];
11460 [label="CustomAssert.Equal(v1, v2); 233586"];
11461 [label="CustomAssert.Equal(v1, v2); 233587"];
11462 [label="var sym3 = (classTest.GetMembers('AryField3').First() as FieldSymbol).Type; 233588"];
11463 [label="classTest.GetMembers('AryField3') 233589"];
11464 [label="param GetMembers(string name) 233590"];
11465 [label="param GetMembers(this) 233591"];
11466 [label="ImmutableArray<Symbol> members; 233592"];
11467 [label="members 233593"];
11468 [label="GetMembersByName() 233594"];
11469 [label="param GetMembersByName(this) 233595"];
11470 [label="if (this.state.HasComplete(CompletionPart.Members))\n            {\n                return _lazyMembersDictionary!;\n            } 233596"];
11471 [label="this.state.HasComplete(CompletionPart.Members) 233597"];
11472 [label="param HasComplete(CompletionPart part) 233598"];
11473 [label="param HasComplete(this) 233599"];
11474 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 233600"];
11475 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 233601"];
11476 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 233602"];
11477 [label="(classTest.GetMembers('AryField3').First() as FieldSymbol).Type 233603"];
11478 [label="=> TypeWithAnnotations.Type 233604"];
11479 [label="TypeWithAnnotations 233605"];
11480 [label="return GetFieldType(ConsList<FieldSymbol>.Empty); 233606"];
11481 [label="GetFieldType(ConsList<FieldSymbol>.Empty) 233607"];
11482 [label="param GetFieldType(ConsList<FieldSymbol> fieldsBeingBound) 233608"];
11483 [label="Debug.Assert(fieldsBeingBound != null); 233609"];
11484 [label="Debug.Assert(fieldsBeingBound != null); 233610"];
11485 [label="if (_lazyType != null)\n            {\n                return _lazyType.Value;\n            } 233611"];
11486 [label="if (_lazyType != null)\n            {\n                return _lazyType.Value;\n            } 233612"];
11487 [label="VariableDeclaratorNode 233613"];
11488 [label="this.SyntaxNode 233614"];
11489 [label="return (CSharpSyntaxNode)_syntaxReference.GetSyntax(); 233615"];
11490 [label="GetFieldDeclaration(declarator) 233616"];
11491 [label="this.DeclaringCompilation 233617"];
11492 [label="this.Kind 233618"];
11493 [label="get\n            {\n                return SymbolKind.Field;\n            } 233619"];
11494 [label="return SymbolKind.Field; 233620"];
11495 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 233621"];
11496 [label="this.ContainingModule 233622"];
11497 [label="this.ContainingSymbol 233623"];
11498 [label="return (object)container != null ? container.ContainingModule : null; 233624"];
11499 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 233625"];
11500 [label="var diagnostics = DiagnosticBag.GetInstance(); 233626"];
11501 [label="TypeWithAnnotations type; 233627"];
11502 [label="type 233628"];
11503 [label="DiagnosticBag diagnosticsForFirstDeclarator = DiagnosticBag.GetInstance(); 233629"];
11504 [label="this.AssociatedSymbol 233630"];
11505 [label="get\n            {\n                return null;\n            } 233631"];
11506 [label="return null; 233632"];
11507 [label="Symbol associatedPropertyOrEvent = this.AssociatedSymbol; 233633"];
11508 [label="if ((object)associatedPropertyOrEvent != null && associatedPropertyOrEvent.Kind == SymbolKind.Event)\n            {\n                EventSymbol @event = (EventSymbol)associatedPropertyOrEvent;\n                if (@event.IsWindowsRuntimeEvent)\n                {\n                    NamedTypeSymbol tokenTableType = this.DeclaringCompilation.GetWellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T);\n                    Binder.ReportUseSiteDiagnostics(tokenTableType, diagnosticsForFirstDeclarator, this.ErrorLocation);\n\n                    // CONSIDER: Do we want to guard against the possibility that someone has created their own EventRegistrationTokenTable<T>\n                    // type that has additional generic constraints?\n                    type = TypeWithAnnotations.Create(tokenTableType.Construct(ImmutableArray.Create(@event.TypeWithAnnotations)));\n                }\n                else\n                {\n                    type = @event.TypeWithAnnotations;\n                }\n            }\n            else\n            {\n                var binderFactory = compilation.GetBinderFactory(SyntaxTree);\n                var binder = binderFactory.GetBinder(typeSyntax);\n\n                binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this);\n                if (!ContainingType.IsScriptClass)\n                {\n                    type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator);\n                }\n                else\n                {\n                    bool isVar;\n                    type = binder.BindTypeOrVarKeyword(typeSyntax, diagnostics, out isVar);\n\n                    Debug.Assert(type.HasType || isVar);\n\n                    if (isVar)\n                    {\n                        if (this.IsConst)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableCannotBeConst, typeSyntax.Location);\n                        }\n\n                        if (fieldsBeingBound.ContainsReference(this))\n                        {\n                            diagnostics.Add(ErrorCode.ERR_RecursivelyTypedVariable, this.ErrorLocation, this);\n                            type = default;\n                        }\n                        else if (fieldSyntax.Declaration.Variables.Count > 1)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, typeSyntax.Location);\n                        }\n                        else if (this.IsConst && this.ContainingType.IsScriptClass)\n                        {\n                            // For const var in script, we won't try to bind the initializer (case below), as it can lead to an unbound recursion\n                            type = default;\n                        }\n                        else\n                        {\n                            fieldsBeingBound = new ConsList<FieldSymbol>(this, fieldsBeingBound);\n\n                            var initializerBinder = new ImplicitlyTypedFieldBinder(binder, fieldsBeingBound);\n                            var initializerOpt = initializerBinder.BindInferredVariableInitializer(diagnostics, RefKind.None, (EqualsValueClauseSyntax)declarator.Initializer, declarator);\n\n                            if (initializerOpt != null)\n                            {\n                                if ((object)initializerOpt.Type != null && !initializerOpt.Type.IsErrorType())\n                                {\n                                    type = TypeWithAnnotations.Create(initializerOpt.Type);\n                                }\n\n                                _lazyFieldTypeInferred = 1;\n                            }\n                        }\n\n                        if (!type.HasType)\n                        {\n                            type = TypeWithAnnotations.Create(binder.CreateErrorType('var'));\n                        }\n                    }\n                }\n\n                if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                }\n            } 233634"];
11509 [label="if ((object)associatedPropertyOrEvent != null && associatedPropertyOrEvent.Kind == SymbolKind.Event)\n            {\n                EventSymbol @event = (EventSymbol)associatedPropertyOrEvent;\n                if (@event.IsWindowsRuntimeEvent)\n                {\n                    NamedTypeSymbol tokenTableType = this.DeclaringCompilation.GetWellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T);\n                    Binder.ReportUseSiteDiagnostics(tokenTableType, diagnosticsForFirstDeclarator, this.ErrorLocation);\n\n                    // CONSIDER: Do we want to guard against the possibility that someone has created their own EventRegistrationTokenTable<T>\n                    // type that has additional generic constraints?\n                    type = TypeWithAnnotations.Create(tokenTableType.Construct(ImmutableArray.Create(@event.TypeWithAnnotations)));\n                }\n                else\n                {\n                    type = @event.TypeWithAnnotations;\n                }\n            }\n            else\n            {\n                var binderFactory = compilation.GetBinderFactory(SyntaxTree);\n                var binder = binderFactory.GetBinder(typeSyntax);\n\n                binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this);\n                if (!ContainingType.IsScriptClass)\n                {\n                    type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator);\n                }\n                else\n                {\n                    bool isVar;\n                    type = binder.BindTypeOrVarKeyword(typeSyntax, diagnostics, out isVar);\n\n                    Debug.Assert(type.HasType || isVar);\n\n                    if (isVar)\n                    {\n                        if (this.IsConst)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableCannotBeConst, typeSyntax.Location);\n                        }\n\n                        if (fieldsBeingBound.ContainsReference(this))\n                        {\n                            diagnostics.Add(ErrorCode.ERR_RecursivelyTypedVariable, this.ErrorLocation, this);\n                            type = default;\n                        }\n                        else if (fieldSyntax.Declaration.Variables.Count > 1)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, typeSyntax.Location);\n                        }\n                        else if (this.IsConst && this.ContainingType.IsScriptClass)\n                        {\n                            // For const var in script, we won't try to bind the initializer (case below), as it can lead to an unbound recursion\n                            type = default;\n                        }\n                        else\n                        {\n                            fieldsBeingBound = new ConsList<FieldSymbol>(this, fieldsBeingBound);\n\n                            var initializerBinder = new ImplicitlyTypedFieldBinder(binder, fieldsBeingBound);\n                            var initializerOpt = initializerBinder.BindInferredVariableInitializer(diagnostics, RefKind.None, (EqualsValueClauseSyntax)declarator.Initializer, declarator);\n\n                            if (initializerOpt != null)\n                            {\n                                if ((object)initializerOpt.Type != null && !initializerOpt.Type.IsErrorType())\n                                {\n                                    type = TypeWithAnnotations.Create(initializerOpt.Type);\n                                }\n\n                                _lazyFieldTypeInferred = 1;\n                            }\n                        }\n\n                        if (!type.HasType)\n                        {\n                            type = TypeWithAnnotations.Create(binder.CreateErrorType('var'));\n                        }\n                    }\n                }\n\n                if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                }\n            } 233635"];
11510 [label="SyntaxTree 233636"];
11511 [label="var binderFactory = compilation.GetBinderFactory(SyntaxTree); 233637"];
11512 [label="compilation.GetBinderFactory(SyntaxTree) 233638"];
11513 [label="param GetBinderFactory(bool ignoreAccessibility = false) 233639"];
11514 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 233640"];
11515 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 233641"];
11516 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 233642"];
11517 [label="param GetBinderFactory(bool ignoreAccessibility) 233643"];
11518 [label="ignoreAccessibility 233644"];
11519 [label="GetSyntaxTreeOrdinal(syntaxTree) 233645"];
11520 [label="this.ContainsSyntaxTree(tree) 233646"];
11521 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 233647"];
11522 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 233648"];
11523 [label="BinderFactory? previousFactory; 233649"];
11524 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 233650"];
11525 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 233651"];
11526 [label="var binder = binderFactory.GetBinder(typeSyntax); 233652"];
11527 [label="binderFactory.GetBinder(typeSyntax) 233653"];
11528 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 233654"];
11529 [label="param GetBinder(Symbol memberOpt = null) 233655"];
11530 [label="InScript 233656"];
11531 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 233657"];
11532 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 233658"];
11533 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 233659"];
11534 [label="GetBinder(node, position, memberDeclarationOpt, memberOpt) 233660"];
11535 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 233661"];
11536 [label="param GetBinder(Symbol memberOpt = null) 233662"];
11537 [label="Debug.Assert(node != null); 233663"];
11538 [label="Debug.Assert(node != null); 233664"];
11539 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 233665"];
11540 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 233666"];
11541 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 233667"];
11542 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt) 233668"];
11543 [label="param Initialize(CSharpSyntaxNode memberDeclarationOpt) 233669"];
11544 [label="param Initialize(Symbol memberOpt) 233670"];
11545 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 233671"];
11546 [label="memberDeclarationOpt == null 233672"];
11547 [label="param ==(Symbol left) 233673"];
11548 [label="param ==(Symbol right) 233674"];
11549 [label="if (right is null)\n            {\n                return left is null;\n            } 233675"];
11550 [label="return left is null; 233676"];
11551 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 233677"];
11552 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 233678"];
11553 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 233679"];
11554 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 233680"];
11555 [label="visitor.Visit(node) 233681"];
11556 [label="VisitCore(node) 233682"];
11557 [label="return ((CSharpSyntaxNode)node).Accept(this); 233683"];
11558 [label="VisitCore(parent.Parent) 233684"];
11559 [label="VisitCore(parent.Parent) 233685"];
11560 [label="VisitTypeDeclarationCore(node) 233686"];
11561 [label="NodeUsage extraInfo = NodeUsage.Normal; 233687"];
11562 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 233688"];
11563 [label="VisitTypeDeclarationCore(parent, extraInfo) 233689"];
11564 [label="CreateBinderCacheKey(parent, extraInfo) 233690"];
11565 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 233691"];
11566 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 233692"];
11567 [label="return new BinderCacheKey(node, usage); 233693"];
11568 [label="new BinderCacheKey(node, usage) 233694"];
11569 [label="param BinderCacheKey(this) 233695"];
11570 [label="var key = CreateBinderCacheKey(parent, extraInfo); 233696"];
11571 [label="Binder resultBinder; 233697"];
11572 [label="binderCache 233698"];
11573 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 233699"];
11574 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 233700"];
11575 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 233701"];
11576 [label="VisitCore(parent.Parent).WithUnsafeRegionIfNecessary(parent.Modifiers) 233702"];
11577 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 233703"];
11578 [label="this.Flags.Includes(BinderFlags.UnsafeRegion) 233704"];
11579 [label="param Includes(BinderFlags other) 233705"];
11580 [label="binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 233706"];
11581 [label="binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this) 233707"];
11582 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags flags) 233708"];
11583 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(Symbol containing) 233709"];
11584 [label="Debug.Assert((object)containing != null); 233710"];
11585 [label="Debug.Assert((object)containing != null); 233711"];
11586 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 233712"];
11587 [label="new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing) 233713"];
11588 [label="param BinderWithContainingMemberOrLambda(Symbol containingMemberOrLambda) 233714"];
11589 [label="param BinderWithContainingMemberOrLambda(this) 233715"];
11590 [label="param BinderWithContainingMemberOrLambda(this) 233716"];
11591 [label="param Binder(this) 233717"];
11592 [label="internal CSharpCompilation Compilation { get; } 233718"];
11593 [label="Flags 233719"];
11594 [label="protected internal Binder? Next { get; } 233720"];
11595 [label="_lazyConversions 233721"];
11596 [label="_lazyOverloadResolution 233722"];
11597 [label="RoslynDebug.Assert(next != null); 233723"];
11598 [label="RoslynDebug.Assert(next != null); 233724"];
11599 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion)); 233725"];
11600 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion)); 233726"];
11601 [label="flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion) 233727"];
11602 [label="param Includes(this BinderFlags self) 233728"];
11603 [label="param Includes(BinderFlags other) 233729"];
11604 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.InNestedFinallyBlock) || flags.Includes(BinderFlags.InFinallyBlock | BinderFlags.InCatchBlock)); 233730"];
11605 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.InNestedFinallyBlock) || flags.Includes(BinderFlags.InFinallyBlock | BinderFlags.InCatchBlock)); 233731"];
11606 [label="flags.Includes(BinderFlags.InNestedFinallyBlock) 233732"];
11607 [label="param Includes(this BinderFlags self) 233733"];
11608 [label="param Includes(BinderFlags other) 233734"];
11609 [label="_containingMemberOrLambda 233735"];
11610 [label="Debug.Assert(containingMemberOrLambda != null); 233736"];
11611 [label="containingMemberOrLambda != null 233737"];
11612 [label="param !=(Symbol left) 233738"];
11613 [label="param !=(Symbol right) 233739"];
11614 [label="if (right is null)\n            {\n                return left is object;\n            } 233740"];
11615 [label="return left is object; 233741"];
11616 [label="Debug.Assert(containingMemberOrLambda != null); 233742"];
11617 [label="_containingMemberOrLambda 233743"];
11618 [label="binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 233744"];
11619 [label="ContainingType 233745"];
11620 [label="ContainingType.IsScriptClass 233746"];
11621 [label="var kind = this.declaration.Declarations[0].Kind; 233747"];
11622 [label="param BindType(bool suppressUseSiteDiagnostics = false) 233748"];
11623 [label="param BindTypeOrAlias(bool suppressUseSiteDiagnostics = false) 233749"];
11624 [label="Debug.Assert(diagnostics != null); 233750"];
11625 [label="param BindNamespaceOrTypeOrAliasSymbol(ConsList<TypeSymbol> basesBeingResolved) 233751"];
11626 [label="param BindNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 233752"];
11627 [label="param BindArrayType(bool permitDimensions) 233753"];
11628 [label="param BindArrayType(ConsList<TypeSymbol> basesBeingResolved) 233754"];
11629 [label="Debug.Assert(diagnostics != null); 233755"];
11630 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 233756"];
11631 [label="param BindNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 233757"];
11632 [label="param GetSpecialType(DiagnosticBag diagnostics) 233758"];
11633 [label="param GetSpecialType(SyntaxNode node) 233759"];
11634 [label="param GetSpecialType(SyntaxNode node) 233760"];
11635 [label="param GetSpecialType(DiagnosticBag diagnostics) 233761"];
11636 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 233762"];
11637 [label="NamedTypeSymbol result; 233763"];
11638 [label="GetBoundReferenceManager(); 233764"];
11639 [label="this.Modules 233765"];
11640 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 233766"];
11641 [label="module.GetReferencedAssemblies() 233767"];
11642 [label="param GetReferencedAssemblies(this) 233768"];
11643 [label="AssertReferencesInitialized() 233769"];
11644 [label="param AssertReferencesInitialized(this) 233770"];
11645 [label="Debug.Assert(_moduleReferences != null); 233771"];
11646 [label="Debug.Assert(_moduleReferences != null); 233772"];
11647 [label="AssertReferencesInitialized(); 233773"];
11648 [label="return _moduleReferences.Identities; 233774"];
11649 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 233775"];
11650 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 233776"];
11651 [label="result.SpecialType 233777"];
11652 [label="Debug.Assert(result.SpecialType == specialType); 233778"];
11653 [label="Debug.Assert((object)typeSymbol != null, 'Expect an error type if special type isn't found'); 233779"];
11654 [label="param ReportUseSiteDiagnostics(DiagnosticBag diagnostics) 233780"];
11655 [label="param ReportUseSiteDiagnostics(SyntaxNode node) 233781"];
11656 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 233782"];
11657 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 233783"];
11658 [label="s.Kind 233784"];
11659 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 233785"];
11660 [label="return SymbolKind.Namespace; 233786"];
11661 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 233787"];
11662 [label="Debug.Assert((object)moduleSymbol != null); 233788"];
11663 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 233789"];
11664 [label="param TransformType(int targetSymbolCustomModifierCount) 233790"];
11665 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 233791"];
11666 [label="Debug.Assert((object)metadataType != null); 233792"];
11667 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 233793"];
11668 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 233794"];
11669 [label="_elementNames 233795"];
11670 [label="elementNames.IsDefault 233796"];
11671 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 233797"];
11672 [label="_namesIndex 233798"];
11673 [label="_foundUsableErrorType = false; 233799"];
11674 [label="_foundUsableErrorType 233800"];
11675 [label="param DecodeType(this) 233801"];
11676 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 233802"];
11677 [label="param DecodeNamedType(this) 233803"];
11678 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 233804"];
11679 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 233805"];
11680 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 233806"];
11681 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 233807"];
11682 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 233808"];
11683 [label="DecodeTypeArguments(typeArgs) 233809"];
11684 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 233810"];
11685 [label="param DecodeTypeArguments(this) 233811"];
11686 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 233812"];
11687 [label="return typeArgs; 233813"];
11688 [label="type.ContainingType 233814"];
11689 [label="NamedTypeSymbol containingType = type.ContainingType; 233815"];
11690 [label="NamedTypeSymbol? decodedContainingType; 233816"];
11691 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 233817"];
11692 [label="decodedContainingType = containingType; 233818"];
11693 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 233819"];
11694 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 233820"];
11695 [label="var typeArgsChanged = typeArgs != decodedArgs; 233821"];
11696 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 233822"];
11697 [label="decodedType.IsTupleType 233823"];
11698 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 233824"];
11699 [label="_ 233825"];
11700 [label="tupleCardinality: out _ 233826"];
11701 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 233827"];
11702 [label="param IsTupleTypeOfCardinality(this) 233828"];
11703 [label="IsUnboundGenericType 233829"];
11704 [label="get\n            {\n                return false;\n            } 233830"];
11705 [label="return false; 233831"];
11706 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 233832"];
11707 [label="ContainingSymbol 233833"];
11708 [label="get\n            {\n                return _container;\n            } 233834"];
11709 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 233835"];
11710 [label=".Kind 233836"];
11711 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 233837"];
11712 [label="return SymbolKind.Namespace; 233838"];
11713 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 233839"];
11714 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 233840"];
11715 [label="ContainingNamespace 233841"];
11716 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 233842"];
11717 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 233843"];
11718 [label="ContainingNamespace.ContainingNamespace 233844"];
11719 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 233845"];
11720 [label=".IsGlobalNamespace 233846"];
11721 [label="get\n            {\n                return true;\n            } 233847"];
11722 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 233848"];
11723 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 233849"];
11724 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 233850"];
11725 [label="Name 233851"];
11726 [label="get\n            {\n                return _name;\n            } 233852"];
11727 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 233853"];
11728 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 233854"];
11729 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 233855"];
11730 [label="tupleCardinality = 0; 233856"];
11731 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 233857"];
11732 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 233858"];
11733 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 233859"];
11734 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 233860"];
11735 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 233861"];
11736 [label="typeSymbol.IsNullableType() 233862"];
11737 [label="param IsNullableType(this TypeSymbol type) 233863"];
11738 [label="var a1 = defaultType is null; 233864"];
11739 [label="!a1 233865"];
11740 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 233866"];
11741 [label="defaultType.IsNullableType() 233867"];
11742 [label="param IsNullableType(this TypeSymbol type) 233868"];
11743 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 233869"];
11744 [label="Debug.Assert(a1 || a2 != true || a3); 233870"];
11745 [label="Debug.Assert(a1 || a2 != true || a3); 233871"];
11746 [label="Debug.Assert(extensions != null); 233872"];
11747 [label="param TransformType(Symbol accessSymbol) 233873"];
11748 [label="metadataType.HasType 233874"];
11749 [label="Debug.Assert(metadataType.HasType); 233875"];
11750 [label="accessSymbol.IsDefinition 233876"];
11751 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 233877"];
11752 [label="OriginalDefinition 233878"];
11753 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 233879"];
11754 [label="OriginalSymbolDefinition 233880"];
11755 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 233881"];
11756 [label="this.OriginalTypeSymbolDefinition 233882"];
11757 [label="get\n            {\n                return this.OriginalDefinition;\n            } 233883"];
11758 [label="return this.OriginalTypeSymbolDefinition; 233884"];
11759 [label="return OriginalSymbolDefinition; 233885"];
11760 [label="return (object)this == (object)OriginalDefinition; 233886"];
11761 [label="Debug.Assert(accessSymbol.IsDefinition); 233887"];
11762 [label="accessSymbol.ContainingModule 233888"];
11763 [label="get\n            {\n                return ContainingPEModule;\n            } 233889"];
11764 [label="ContainingPEModule 233890"];
11765 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 233891"];
11766 [label="s.Kind 233892"];
11767 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 233893"];
11768 [label="return SymbolKind.Namespace; 233894"];
11769 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 233895"];
11770 [label="return ContainingPEModule; 233896"];
11771 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 233897"];
11772 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 233898"];
11773 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 233899"];
11774 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 233900"];
11775 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 233901"];
11776 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 233902"];
11777 [label="Debug.Assert(symbol is object); 233903"];
11778 [label="symbol.Kind 233904"];
11779 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 233905"];
11780 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 233906"];
11781 [label="isInternal = false; 233907"];
11782 [label="symbol.DeclaredAccessibility 233908"];
11783 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 233909"];
11784 [label="Accessibility access = Accessibility.Private; 233910"];
11785 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 233911"];
11786 [label="symbol.ContainingType 233912"];
11787 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 233913"];
11788 [label="symbol = symbol.ContainingType; 233914"];
11789 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 233915"];
11790 [label="return true; 233916"];
11791 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 233917"];
11792 [label="param TryGetByte(out byte? value) 233918"];
11793 [label="value = null; 233919"];
11794 [label="param GetLocalNullableContextValue(this) 233920"];
11795 [label="get\n            {\n                return _moduleSymbol;\n            } 233921"];
11796 [label="return _moduleSymbol; 233922"];
11797 [label="param GetLocalNullableContextValue(this) 233923"];
11798 [label="get\n            {\n                return _assemblySymbol;\n            } 233924"];
11799 [label="return _assemblySymbol; 233925"];
11800 [label="param GetLocalNullableContextValue(this) 233926"];
11801 [label="get\n            {\n                return null;\n            } 233927"];
11802 [label="=> defaultType 233928"];
11803 [label="Debug.Assert((object)depends != null); 233929"];
11804 [label="Debug.Assert((object)on != null); 233930"];
11805 [label="on.IsDefinition 233931"];
11806 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 233932"];
11807 [label="OriginalDefinition 233933"];
11808 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 233934"];
11809 [label="OriginalSymbolDefinition 233935"];
11810 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 233936"];
11811 [label="this.OriginalTypeSymbolDefinition 233937"];
11812 [label="get\n            {\n                return this.OriginalDefinition;\n            } 233938"];
11813 [label="return this.OriginalTypeSymbolDefinition; 233939"];
11814 [label="return OriginalSymbolDefinition; 233940"];
11815 [label="return (object)this == (object)OriginalDefinition; 233941"];
11816 [label="Debug.Assert(on.IsDefinition); 233942"];
11817 [label="depends.DeclaringCompilation 233943"];
11818 [label="get { return null; } 233944"];
11819 [label="return null; 233945"];
11820 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 233946"];
11821 [label="if ((object)type == null)\n            {\n                return;\n            } 233947"];
11822 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 233948"];
11823 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 233949"];
11824 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 233950"];
11825 [label="if ((object)type == null)\n            {\n                return;\n            } 233951"];
11826 [label="return; 233952"];
11827 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 233953"];
11828 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 233954"];
11829 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 233955"];
11830 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 233956"];
11831 [label="return result; 233957"];
11832 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 233958"];
11833 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 233959"];
11834 [label="@base.IsErrorType() 233960"];
11835 [label="param IsErrorType(this TypeSymbol type) 233961"];
11836 [label="RoslynDebug.Assert((object)type != null); 233962"];
11837 [label="RoslynDebug.Assert((object)type != null); 233963"];
11838 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 233964"];
11839 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 233965"];
11840 [label="param MergeUseSiteDiagnostics(this) 233966"];
11841 [label="this.ContainingModule 233967"];
11842 [label="get\n            {\n                return ContainingPEModule;\n            } 233968"];
11843 [label="ContainingPEModule 233969"];
11844 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 233970"];
11845 [label="Symbol s = _container; 233971"];
11846 [label="s.Kind 233972"];
11847 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 233973"];
11848 [label="return SymbolKind.Namespace; 233974"];
11849 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 233975"];
11850 [label="return ContainingPEModule; 233976"];
11851 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 233977"];
11852 [label="this.ContainingModule.HasUnifiedReferences 233978"];
11853 [label="get { return GetUnifiedAssemblies().Length > 0; } 233979"];
11854 [label="GetUnifiedAssemblies() 233980"];
11855 [label="param GetUnifiedAssemblies(this) 233981"];
11856 [label="AssertReferencesInitialized() 233982"];
11857 [label="param AssertReferencesInitialized(this) 233983"];
11858 [label="Debug.Assert(_moduleReferences != null); 233984"];
11859 [label="Debug.Assert(_moduleReferences != null); 233985"];
11860 [label="AssertReferencesInitialized(); 233986"];
11861 [label="return GetUnifiedAssemblies().Length > 0; 233987"];
11862 [label="return GetUnifiedAssemblies().Length > 0; 233988"];
11863 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 233989"];
11864 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 233990"];
11865 [label="return _lazyUseSiteDiagnostic; 233991"];
11866 [label="DiagnosticInfo info = symbol.GetUseSiteDiagnostic(); 233992"];
11867 [label="return info != null && Symbol.ReportUseSiteDiagnostic(info, diagnostics, node.Location); 233993"];
11868 [label="return info != null && Symbol.ReportUseSiteDiagnostic(info, diagnostics, node.Location); 233994"];
11869 [label="if (typeSymbol is null)\n            {\n                return default;\n            } 233995"];
11870 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 233996"];
11871 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 233997"];
11872 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 233998"];
11873 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 233999"];
11874 [label="typeSymbol.IsNullableType() 234000"];
11875 [label="param IsNullableType(this TypeSymbol type) 234001"];
11876 [label="var a1 = defaultType is null; 234002"];
11877 [label="!a1 234003"];
11878 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 234004"];
11879 [label="defaultType.IsNullableType() 234005"];
11880 [label="param IsNullableType(this TypeSymbol type) 234006"];
11881 [label="return _corTypeId; 234007"];
11882 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 234008"];
11883 [label="Debug.Assert(a1 || a2 != true || a3); 234009"];
11884 [label="Debug.Assert(extensions != null); 234010"];
11885 [label="NullableAnnotation 234011"];
11886 [label="typeWithAnnotations.HasType 234012"];
11887 [label="=> !(DefaultType is null) 234013"];
11888 [label="Debug.Assert(typeWithAnnotations.HasType); 234014"];
11889 [label="_symbol = null; 234015"];
11890 [label="_symbol 234016"];
11891 [label="_isNullableEnabled = false; 234017"];
11892 [label="_isNullableEnabled 234018"];
11893 [label="param ReportDiagnosticsIfObsolete(Binder binder) 234019"];
11894 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 234020"];
11895 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 234021"];
11896 [label="binder 234022"];
11897 [label="syntax 234023"];
11898 [label="diagnostics 234024"];
11899 [label="param ReportDiagnosticsIfObsolete(Binder binder) 234025"];
11900 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 234026"];
11901 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 234027"];
11902 [label="param ReportDiagnosticsIfObsolete(this) 234028"];
11903 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 234029"];
11904 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 234030"];
11905 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 234031"];
11906 [label="param ReportDiagnosticsIfObsoleteCore(Binder binder) 234032"];
11907 [label="param ReportDiagnosticsIfObsoleteCore(SyntaxNode syntax) 234033"];
11908 [label="param ReportDiagnosticsIfObsoleteCore(DiagnosticBag diagnostics) 234034"];
11909 [label="=> defaultType 234035"];
11910 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 234036"];
11911 [label="param ReportDiagnosticsIfObsolete(SyntaxNode node) 234037"];
11912 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 234038"];
11913 [label="param ReportDiagnosticsIfObsolete(this) 234039"];
11914 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 234040"];
11915 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 234041"];
11916 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 234042"];
11917 [label="param ReportDiagnosticsIfObsolete(this) 234043"];
11918 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 234044"];
11919 [label="this.ContainingMemberOrLambda 234045"];
11920 [label="get { return _containingMemberOrLambda; } 234046"];
11921 [label="return _containingMemberOrLambda; 234047"];
11922 [label="this.ContainingType 234048"];
11923 [label="get\n            {\n                var member = this.ContainingMemberOrLambda;\n                RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType);\n                return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                };\n            } 234049"];
11924 [label="this.ContainingMemberOrLambda 234050"];
11925 [label="get { return _containingMemberOrLambda; } 234051"];
11926 [label="return _containingMemberOrLambda; 234052"];
11927 [label="var member = this.ContainingMemberOrLambda; 234053"];
11928 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 234054"];
11929 [label="member.Kind 234055"];
11930 [label="get\n            {\n                return SymbolKind.Field;\n            } 234056"];
11931 [label="return SymbolKind.Field; 234057"];
11932 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 234058"];
11933 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 234059"];
11934 [label="member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                } 234060"];
11935 [label="member.ContainingType 234061"];
11936 [label="return this.containingType; 234062"];
11937 [label="return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                }; 234063"];
11938 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 234064"];
11939 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 234065"];
11940 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 234066"];
11941 [label="param ReportDiagnosticsIfObsolete(Symbol? containingMember) 234067"];
11942 [label="param ReportDiagnosticsIfObsolete(NamedTypeSymbol? containingType) 234068"];
11943 [label="param ReportDiagnosticsIfObsolete(BinderFlags location) 234069"];
11944 [label="RoslynDebug.Assert(symbol is object); 234070"];
11945 [label="symbol.Kind 234071"];
11946 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 234072"];
11947 [label="RoslynDebug.Assert(symbol.Kind == SymbolKind.NamedType ||\n                         symbol.Kind == SymbolKind.Field ||\n                         symbol.Kind == SymbolKind.Method ||\n                         symbol.Kind == SymbolKind.Event ||\n                         symbol.Kind == SymbolKind.Property); 234073"];
11948 [label="symbol.Kind 234074"];
11949 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 234075"];
11950 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                symbol = ((MethodSymbol)symbol).ConstructedFrom;\n            } 234076"];
11951 [label="param GetLeastOverriddenMember(NamedTypeSymbol accessingTypeOpt) 234077"];
11952 [label="bool checkOverridingSymbol = hasBaseReceiver && !ReferenceEquals(symbol, leastOverriddenSymbol); 234078"];
11953 [label="if (checkOverridingSymbol)\n            {\n                // If we have a base receiver, we must be done with declaration binding, so it should\n                // be safe to decode diagnostics.  We want to do this since reporting for the overriding\n                // member is conditional on reporting for the overridden member (i.e. we need a definite\n                // answer so we don't double-report).  You might think that double reporting just results\n                // in cascading diagnostics, but it's possible that the second diagnostic is an error\n                // while the first is merely a warning.\n                leastOverriddenSymbol.GetAttributes();\n            } 234079"];
11954 [label="param ReportDiagnosticsIfObsoleteInternal(DiagnosticBag diagnostics) 234080"];
11955 [label="param ReportDiagnosticsIfObsoleteInternal(SyntaxNodeOrToken node) 234081"];
11956 [label="param ReportDiagnosticsIfObsoleteInternal(Symbol? containingMember) 234082"];
11957 [label="param ReportDiagnosticsIfObsoleteInternal(BinderFlags location) 234083"];
11958 [label="RoslynDebug.Assert(diagnostics != null); 234084"];
11959 [label="RoslynDebug.Assert(diagnostics != null); 234085"];
11960 [label="param GetObsoleteDiagnosticKind(Symbol containingMember) 234086"];
11961 [label="param GetObsoleteDiagnosticKind(bool forceComplete = false) 234087"];
11962 [label="s.Kind 234088"];
11963 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 234089"];
11964 [label="return SymbolKind.Namespace; 234090"];
11965 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 234091"];
11966 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return null;\n                } 234092"];
11967 [label="Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified'); 234093"];
11968 [label="Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified'); 234094"];
11969 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                } 234095"];
11970 [label="s.Kind 234096"];
11971 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 234097"];
11972 [label="return SymbolKind.Namespace; 234098"];
11973 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 234099"];
11974 [label="Debug.Assert((object)moduleSymbol != null); 234100"];
11975 [label="Debug.Assert(obsoleteAttributeData == null || !obsoleteAttributeData.IsUninitialized); 234101"];
11976 [label="return uncommon.lazyObsoleteAttributeData; 234102"];
11977 [label="var data = this.ObsoleteAttributeData; 234103"];
11978 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 234104"];
11979 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 234105"];
11980 [label="(data == null) 234106"];
11981 [label="switch (symbol.ObsoleteKind)\n            {\n                case ObsoleteAttributeKind.None:\n                    return ObsoleteDiagnosticKind.NotObsolete;\n                case ObsoleteAttributeKind.Experimental:\n                    return ObsoleteDiagnosticKind.Diagnostic;\n                case ObsoleteAttributeKind.Uninitialized:\n                    // If we haven't cracked attributes on the symbol at all or we haven't\n                    // cracked attribute arguments enough to be able to report diagnostics for\n                    // ObsoleteAttribute, store the symbol so that we can report diagnostics at a \n                    // later stage.\n                    return ObsoleteDiagnosticKind.Lazy;\n            } 234107"];
11982 [label="return ObsoleteDiagnosticKind.NotObsolete; 234108"];
11983 [label="DiagnosticInfo? info = null; 234109"];
11984 [label="switch (kind)\n            {\n                case ObsoleteDiagnosticKind.Diagnostic:\n                    info = ObsoleteAttributeHelpers.CreateObsoleteDiagnostic(symbol, location);\n                    break;\n                case ObsoleteDiagnosticKind.Lazy:\n                case ObsoleteDiagnosticKind.LazyPotentiallySuppressed:\n                    info = new LazyObsoleteDiagnosticInfo(symbol, containingMember, location);\n                    break;\n            } 234110"];
11985 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 234111"];
11986 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 234112"];
11987 [label="return kind; 234113"];
11988 [label="switch (diagnosticKind)\n            {\n                case ObsoleteDiagnosticKind.NotObsolete:\n                case ObsoleteDiagnosticKind.Lazy:\n                    if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    }\n                    break;\n            } 234114"];
11989 [label="if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    } 234115"];
11990 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 234116"];
11991 [label="param UnwrapAlias(DiagnosticBag diagnostics) 234117"];
11992 [label="param UnwrapAlias(SyntaxNode syntax) 234118"];
11993 [label="param UnwrapAlias(ConsList<TypeSymbol> basesBeingResolved = null) 234119"];
11994 [label="param UnwrapAlias(this) 234120"];
11995 [label="symbol.IsAlias 234121"];
11996 [label="=> _symbol?.Kind == SymbolKind.Alias 234122"];
11997 [label="_symbol 234123"];
11998 [label="_symbol?.Kind == SymbolKind.Alias 234124"];
11999 [label="if (symbol.IsAlias)\n            {\n                AliasSymbol discarded;\n                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out discarded, diagnostics, syntax, basesBeingResolved));\n            } 234125"];
12000 [label="type.IsStatic 234126"];
12001 [label="=>\n            _extensions.IsStatic(DefaultType) 234127"];
12002 [label="DefaultType 234128"];
12003 [label="_extensions.IsStatic(DefaultType) 234129"];
12004 [label="param IsStatic(TypeSymbol typeSymbol) 234130"];
12005 [label="=> typeSymbol.IsStatic 234131"];
12006 [label="typeSymbol.IsStatic 234132"];
12007 [label="get\n            {\n                return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0;\n            } 234133"];
12008 [label="return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0; 234134"];
12009 [label="return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0; 234135"];
12010 [label="if (type.IsStatic)\n            {\n                // CS0719: '{0}': array elements cannot be of static type\n                Error(diagnostics, ErrorCode.ERR_ArrayOfStaticClass, node.ElementType, type.Type);\n            } 234136"];
12011 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()); 234137"];
12012 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()); 234138"];
12013 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 234139"];
12014 [label="GetBoundReferenceManager(); 234140"];
12015 [label="return CreateMDArray(declaringAssembly, elementTypeWithAnnotations, rank, default(ImmutableArray<int>), default(ImmutableArray<int>)); 234141"];
12016 [label="CreateMDArray(declaringAssembly, elementTypeWithAnnotations, rank, default(ImmutableArray<int>), default(ImmutableArray<int>)) 234142"];
12017 [label="param CreateMDArray(AssemblySymbol declaringAssembly) 234143"];
12018 [label="param CreateMDArray(TypeWithAnnotations elementType) 234144"];
12019 [label="param CreateMDArray(int rank) 234145"];
12020 [label="param CreateMDArray(ImmutableArray<int> sizes) 234146"];
12021 [label="param CreateMDArray(ImmutableArray<int> lowerBounds) 234147"];
12022 [label="return CreateMDArray(elementType, rank, sizes, lowerBounds, declaringAssembly.GetSpecialType(SpecialType.System_Array)); 234148"];
12023 [label="return CreateMDArray(elementType, rank, sizes, lowerBounds, declaringAssembly.GetSpecialType(SpecialType.System_Array)); 234149"];
12024 [label="return CreateMDArray(elementType, rank, sizes, lowerBounds, declaringAssembly.GetSpecialType(SpecialType.System_Array)); 234150"];
12025 [label="return CreateMDArray(elementType, rank, sizes, lowerBounds, declaringAssembly.GetSpecialType(SpecialType.System_Array)); 234151"];
12026 [label="return CreateMDArray(elementType, rank, sizes, lowerBounds, declaringAssembly.GetSpecialType(SpecialType.System_Array)); 234152"];
12027 [label="declaringAssembly.GetSpecialType(SpecialType.System_Array) 234153"];
12028 [label="param GetSpecialType(SpecialType type) 234154"];
12029 [label="param GetSpecialType(this) 234155"];
12030 [label="this.Modules 234156"];
12031 [label="get\n            {\n                return _modules;\n            } 234157"];
12032 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 234158"];
12033 [label="module.GetReferencedAssemblies() 234159"];
12034 [label="param GetReferencedAssemblies(this) 234160"];
12035 [label="AssertReferencesInitialized() 234161"];
12036 [label="param AssertReferencesInitialized(this) 234162"];
12037 [label="Debug.Assert(_moduleReferences != null); 234163"];
12038 [label="Debug.Assert(_moduleReferences != null); 234164"];
12039 [label="AssertReferencesInitialized(); 234165"];
12040 [label="return _moduleReferences.Identities; 234166"];
12041 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 234167"];
12042 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 234168"];
12043 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 234169"];
12044 [label="return _lazySpecialTypes[(int)type]; 234170"];
12045 [label="CreateMDArray(elementType, rank, sizes, lowerBounds, declaringAssembly.GetSpecialType(SpecialType.System_Array)) 234171"];
12046 [label="param CreateMDArray(TypeWithAnnotations elementTypeWithAnnotations) 234172"];
12047 [label="param CreateMDArray(int rank) 234173"];
12048 [label="param CreateMDArray(ImmutableArray<int> sizes) 234174"];
12049 [label="param CreateMDArray(ImmutableArray<int> lowerBounds) 234175"];
12050 [label="param CreateMDArray(NamedTypeSymbol array) 234176"];
12051 [label="if (sizes.IsDefaultOrEmpty && lowerBounds.IsDefault)\n            {\n                return new MDArrayNoSizesOrBounds(elementTypeWithAnnotations, rank, array);\n            } 234177"];
12052 [label="return new MDArrayNoSizesOrBounds(elementTypeWithAnnotations, rank, array); 234178"];
12053 [label="return new MDArrayNoSizesOrBounds(elementTypeWithAnnotations, rank, array); 234179"];
12054 [label="return new MDArrayNoSizesOrBounds(elementTypeWithAnnotations, rank, array); 234180"];
12055 [label="return new MDArrayNoSizesOrBounds(elementTypeWithAnnotations, rank, array); 234181"];
12056 [label="new MDArrayNoSizesOrBounds(elementTypeWithAnnotations, rank, array) 234182"];
12057 [label="param MDArrayNoSizesOrBounds(TypeWithAnnotations elementTypeWithAnnotations) 234183"];
12058 [label="param MDArrayNoSizesOrBounds(int rank) 234184"];
12059 [label="param MDArrayNoSizesOrBounds(NamedTypeSymbol array) 234185"];
12060 [label="param MDArrayNoSizesOrBounds(this) 234186"];
12061 [label="elementTypeWithAnnotations 234187"];
12062 [label="rank 234188"];
12063 [label="array 234189"];
12064 [label="param MDArrayNoSizesOrBounds(this) 234190"];
12065 [label="param MDArray(TypeWithAnnotations elementTypeWithAnnotations) 234191"];
12066 [label="param MDArray(int rank) 234192"];
12067 [label="param MDArray(NamedTypeSymbol array) 234193"];
12068 [label="param MDArray(this) 234194"];
12069 [label="elementTypeWithAnnotations 234195"];
12070 [label="array 234196"];
12071 [label="param MDArray(this) 234197"];
12072 [label="param ArrayTypeSymbol(TypeWithAnnotations elementTypeWithAnnotations) 234198"];
12073 [label="param ArrayTypeSymbol(NamedTypeSymbol array) 234199"];
12074 [label="_baseType 234200"];
12075 [label="Debug.Assert(elementTypeWithAnnotations.HasType); 234201"];
12076 [label="RoslynDebug.Assert((object)array != null); 234202"];
12077 [label="RoslynDebug.Assert((object)array != null); 234203"];
12078 [label="_rank 234204"];
12079 [label="Debug.Assert(rank >= 1); 234205"];
12080 [label="Debug.Assert(rank >= 1); 234206"];
12081 [label="_rank 234207"];
12082 [label="if (typeSymbol is null)\n            {\n                return default;\n            } 234208"];
12083 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 234209"];
12084 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 234210"];
12085 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 234211"];
12086 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 234212"];
12087 [label="typeSymbol.IsNullableType() 234213"];
12088 [label="param IsNullableType(this TypeSymbol type) 234214"];
12089 [label="get\n            {\n                return this;\n            } 234215"];
12090 [label="return this; 234216"];
12091 [label="get\n            {\n                return SpecialType.None;\n            } 234217"];
12092 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 234218"];
12093 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 234219"];
12094 [label="var a1 = defaultType is null; 234220"];
12095 [label="!a1 234221"];
12096 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 234222"];
12097 [label="defaultType.IsNullableType() 234223"];
12098 [label="param IsNullableType(this TypeSymbol type) 234224"];
12099 [label="get\n            {\n                return this;\n            } 234225"];
12100 [label="return this; 234226"];
12101 [label="get\n            {\n                return SpecialType.None;\n            } 234227"];
12102 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 234228"];
12103 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 234229"];
12104 [label="Debug.Assert(a1 || a2 != true || a3); 234230"];
12105 [label="Debug.Assert(a1 || a2 != true || a3); 234231"];
12106 [label="Debug.Assert(extensions != null); 234232"];
12107 [label="typeWithAnnotations.HasType 234233"];
12108 [label="=> !(DefaultType is null) 234234"];
12109 [label="DefaultType is null 234235"];
12110 [label="Debug.Assert(typeWithAnnotations.HasType); 234236"];
12111 [label="_symbol = null; 234237"];
12112 [label="_symbol 234238"];
12113 [label="_isNullableEnabled = false; 234239"];
12114 [label="_isNullableEnabled 234240"];
12115 [label="=> DefaultType is null && this.NullableAnnotation == 0 && (_extensions == null || _extensions == Extensions.Default) 234241"];
12116 [label="DefaultType is null 234242"];
12117 [label="param ReportDiagnosticsIfObsolete(Binder binder) 234243"];
12118 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 234244"];
12119 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 234245"];
12120 [label="binder 234246"];
12121 [label="syntax 234247"];
12122 [label="diagnostics 234248"];
12123 [label="param ReportDiagnosticsIfObsolete(Binder binder) 234249"];
12124 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 234250"];
12125 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 234251"];
12126 [label="param ReportDiagnosticsIfObsolete(this) 234252"];
12127 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 234253"];
12128 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 234254"];
12129 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 234255"];
12130 [label="param ReportDiagnosticsIfObsoleteCore(Binder binder) 234256"];
12131 [label="param ReportDiagnosticsIfObsoleteCore(SyntaxNode syntax) 234257"];
12132 [label="param ReportDiagnosticsIfObsoleteCore(DiagnosticBag diagnostics) 234258"];
12133 [label="=> defaultType 234259"];
12134 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 234260"];
12135 [label="param ReportDiagnosticsIfObsolete(SyntaxNode node) 234261"];
12136 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 234262"];
12137 [label="param ReportDiagnosticsIfObsolete(this) 234263"];
12138 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 234264"];
12139 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 234265"];
12140 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 234266"];
12141 [label="param ReportDiagnosticsIfObsolete(this) 234267"];
12142 [label="get\n            {\n                return SymbolKind.ArrayType;\n            } 234268"];
12143 [label="return SymbolKind.ArrayType; 234269"];
12144 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 234270"];
12145 [label="param UnwrapAlias(ConsList<TypeSymbol> basesBeingResolved = null) 234271"];
12146 [label="=> _symbol?.Kind == SymbolKind.Alias 234272"];
12147 [label="_symbol 234273"];
12148 [label="_symbol?.Kind == SymbolKind.Alias 234274"];
12149 [label="if (symbol.IsAlias)\n            {\n                AliasSymbol discarded;\n                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out discarded, diagnostics, syntax, basesBeingResolved));\n            } 234275"];
12150 [label="IsFixedSizeBuffer 234276"];
12151 [label="=> (Modifiers & DeclarationModifiers.Fixed) != 0 234277"];
12152 [label="Modifiers 234278"];
12153 [label="get\n            {\n                return _modifiers;\n            } 234279"];
12154 [label="return _modifiers; 234280"];
12155 [label="Modifiers & DeclarationModifiers.Fixed 234281"];
12156 [label="0 234282"];
12157 [label="(Modifiers & DeclarationModifiers.Fixed) != 0 234283"];
12158 [label="if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                } 234284"];
12159 [label="this.RequiredCustomModifiers 234285"];
12160 [label="IsVolatile 234286"];
12161 [label="Modifiers 234287"];
12162 [label="0 234288"];
12163 [label="type.WithModifiers(this.RequiredCustomModifiers) 234289"];
12164 [label="_extensions.WithModifiers(this, customModifiers) 234290"];
12165 [label="param WithModifiers(this) 234291"];
12166 [label="CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers) 234292"];
12167 [label="Extensions.Create(customModifiers) 234293"];
12168 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 234294"];
12169 [label="new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)) 234295"];
12170 [label="param TypeWithAnnotations(this) 234296"];
12171 [label="var a1 = defaultType is null; 234297"];
12172 [label="!a1 234298"];
12173 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 234299"];
12174 [label="defaultType.IsNullableType() 234300"];
12175 [label="param IsNullableType(this TypeSymbol type) 234301"];
12176 [label="get\n            {\n                return this;\n            } 234302"];
12177 [label="return this; 234303"];
12178 [label="get\n            {\n                return SpecialType.None;\n            } 234304"];
12179 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 234305"];
12180 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 234306"];
12181 [label="Debug.Assert(a1 || a2 != true || a3); 234307"];
12182 [label="Debug.Assert(a1 || a2 != true || a3); 234308"];
12183 [label="Debug.Assert(extensions != null); 234309"];
12184 [label="Debug.Assert(extensions != null); 234310"];
12185 [label="return CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers); 234311"];
12186 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 234312"];
12187 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 234313"];
12188 [label="new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)) 234314"];
12189 [label="param Boxed(TypeWithAnnotations value) 234315"];
12190 [label="param Boxed(this) 234316"];
12191 [label="Value 234317"];
12192 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 234318"];
12193 [label="=> defaultType 234319"];
12194 [label="type.IsStatic 234320"];
12195 [label="get\n            {\n                return false;\n            } 234321"];
12196 [label="return false; 234322"];
12197 [label="if (type.IsStatic)\n            {\n                // Cannot declare a variable of static type '{0}'\n                diagnostics.Add(ErrorCode.ERR_VarDeclIsStaticClass, this.ErrorLocation, type);\n            }\n            else if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 234323"];
12198 [label="if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 234324"];
12199 [label="type.IsVoidType() 234325"];
12200 [label="param IsVoidType(this TypeSymbol type) 234326"];
12201 [label="type.SpecialType 234327"];
12202 [label="get\n            {\n                return SpecialType.None;\n            } 234328"];
12203 [label="return type.SpecialType == SpecialType.System_Void; 234329"];
12204 [label="if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 234330"];
12205 [label="if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 234331"];
12206 [label="if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 234332"];
12207 [label="type.IsRestrictedType(ignoreSpanLikeTypes: true) 234333"];
12208 [label="param IsRestrictedType(this TypeSymbol type) 234334"];
12209 [label="param IsRestrictedType(bool ignoreSpanLikeTypes = false) 234335"];
12210 [label="RoslynDebug.Assert((object)type != null); 234336"];
12211 [label="RoslynDebug.Assert((object)type != null); 234337"];
12212 [label="type.SpecialType 234338"];
12213 [label="get\n            {\n                return SpecialType.None;\n            } 234339"];
12214 [label="switch (type.SpecialType)\n            {\n                case SpecialType.System_TypedReference:\n                case SpecialType.System_ArgIterator:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            } 234340"];
12215 [label="ignoreSpanLikeTypes 234341"];
12216 [label="return ignoreSpanLikeTypes ?\n                        false :\n                        type.IsRefLikeType; 234342"];
12217 [label="type.IsRefLikeType 234343"];
12218 [label="get\n            {\n                return false;\n            } 234344"];
12219 [label="return false; 234345"];
12220 [label="if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 234346"];
12221 [label="IsConst 234347"];
12222 [label="=> (Modifiers & DeclarationModifiers.Const) != 0 234348"];
12223 [label="Modifiers 234349"];
12224 [label="get\n            {\n                return _modifiers;\n            } 234350"];
12225 [label="Modifiers & DeclarationModifiers.Const 234351"];
12226 [label="0 234352"];
12227 [label="(Modifiers & DeclarationModifiers.Const) != 0 234353"];
12228 [label="if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 234354"];
12229 [label="IsVolatile 234355"];
12230 [label="if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 234356"];
12231 [label="param VisitType(Func<TypeWithAnnotations, T, bool, bool>? typeWithAnnotationsPredicate) 234357"];
12232 [label="param VisitType(bool useDefaultType = false) 234358"];
12233 [label="typeWithAnnotationsOpt.HasType 234359"];
12234 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 234360"];
12235 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 234361"];
12236 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 234362"];
12237 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 234363"];
12238 [label="current.TypeKind 234364"];
12239 [label="get\n            {\n                return TypeKind.Array;\n            } 234365"];
12240 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 234366"];
12241 [label="param IsTypeLessVisibleThan(Symbol sym) 234367"];
12242 [label="get\n            {\n                return TypeKind.Array;\n            } 234368"];
12243 [label="TypeWithAnnotations next; 234369"];
12244 [label="next 234370"];
12245 [label="get\n            {\n                return TypeKind.Array;\n            } 234371"];
12246 [label="=> typeSymbol.StrippedType() 234372"];
12247 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 234373"];
12248 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 234374"];
12249 [label="current.ContainingType 234375"];
12250 [label="var containingType = current.ContainingType; 234376"];
12251 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 234377"];
12252 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 234378"];
12253 [label="param IsAsRestrictive(Symbol sym2) 234379"];
12254 [label="Accessibility access = Accessibility.Private; 234380"];
12255 [label="((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 234381"];
12256 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 234382"];
12257 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 234383"];
12258 [label="var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 234384"];
12259 [label="if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        } 234385"];
12260 [label="return null; 234386"];
12261 [label="return result is null; 234387"];
12262 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 234388"];
12263 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 234389"];
12264 [label="TypeWithAnnotations.Type 234390"];
12265 [label=".GetResolvedType(DefaultType) 234391"];
12266 [label="=> defaultType 234392"];
12267 [label="CustomAssert.Equal(SymbolKind.ArrayType, sym3.Kind); 234393"];
12268 [label="sym3.Kind 234394"];
12269 [label="get\n            {\n                return SymbolKind.ArrayType;\n            } 234395"];
12270 [label="return SymbolKind.ArrayType; 234396"];
12271 [label="CustomAssert.Equal(SymbolKind.ArrayType, sym3.Kind); 234397"];
12272 [label="sym3.GetHashCode() 234398"];
12273 [label="param GetHashCode(this) 234399"];
12274 [label="int hash = 0; 234400"];
12275 [label="current.TypeKind 234401"];
12276 [label="get\n            {\n                return TypeKind.Array;\n            } 234402"];
12277 [label="return TypeKind.Array; 234403"];
12278 [label="while (current.TypeKind == TypeKind.Array)\n            {\n                var cur = (ArrayTypeSymbol)current;\n                hash = Hash.Combine(cur.Rank, hash);\n                current = cur.ElementType;\n            } 234404"];
12279 [label="cur.Rank 234405"];
12280 [label="get\n                {\n                    return _rank;\n                } 234406"];
12281 [label="return _rank; 234407"];
12282 [label="hash = Hash.Combine(cur.Rank, hash); 234408"];
12283 [label="cur.ElementType 234409"];
12284 [label="_elementTypeWithAnnotations.Type 234410"];
12285 [label=".GetResolvedType(DefaultType) 234411"];
12286 [label="=> defaultType 234412"];
12287 [label="return Hash.Combine(current, hash); 234413"];
12288 [label="this.SpecialType 234414"];
12289 [label="OriginalDefinition 234415"];
12290 [label="v1 = sym3.GetHashCode(); 234416"];
12291 [label="sym3.GetHashCode() 234417"];
12292 [label="param GetHashCode(this) 234418"];
12293 [label="int hash = 0; 234419"];
12294 [label="current.TypeKind 234420"];
12295 [label="get\n            {\n                return TypeKind.Array;\n            } 234421"];
12296 [label="return TypeKind.Array; 234422"];
12297 [label="while (current.TypeKind == TypeKind.Array)\n            {\n                var cur = (ArrayTypeSymbol)current;\n                hash = Hash.Combine(cur.Rank, hash);\n                current = cur.ElementType;\n            } 234423"];
12298 [label="cur.Rank 234424"];
12299 [label="get\n                {\n                    return _rank;\n                } 234425"];
12300 [label="return _rank; 234426"];
12301 [label="hash = Hash.Combine(cur.Rank, hash); 234427"];
12302 [label="cur.ElementType 234428"];
12303 [label="_elementTypeWithAnnotations.Type 234429"];
12304 [label="=> _extensions?.GetResolvedType(DefaultType) 234430"];
12305 [label=".GetResolvedType(DefaultType) 234431"];
12306 [label="=> defaultType 234432"];
12307 [label="return Hash.Combine(current, hash); 234433"];
12308 [label="this.SpecialType 234434"];
12309 [label="OriginalDefinition 234435"];
12310 [label="v2 = sym3.GetHashCode(); 234436"];
12311 [label="CustomAssert.Equal(v1, v2); 234437"];
12312 [label="CustomAssert.Equal(v1, v2); 234438"];
12313 [label="CustomAssert.Equal(v1, v2); 234439"];
2 -> 0;
2 -> 1;
3 -> 1;
5 -> 4;
7 -> 6;
9 -> 8;
11 -> 10;
13 -> 12;
15 -> 14;
17 -> 16;
19 -> 18;
21 -> 20;
23 -> 22;
25 -> 24;
27 -> 26;
29 -> 28;
31 -> 30;
33 -> 32;
35 -> 34;
37 -> 36;
39 -> 38;
41 -> 40;
42 -> 0;
43 -> 0;
44 -> 42;
44 -> 43;
44 -> 0;
45 -> 44;
46 -> 0;
47 -> 0;
48 -> 46;
48 -> 47;
48 -> 44;
49 -> 48;
50 -> 0;
51 -> 50;
52 -> 51;
52 -> 50;
53 -> 52;
55 -> 0;
56 -> 54;
56 -> 55;
57 -> 56;
58 -> 0;
59 -> 0;
60 -> 58;
60 -> 59;
60 -> 0;
61 -> 60;
62 -> 0;
63 -> 0;
64 -> 62;
64 -> 63;
64 -> 48;
65 -> 64;
66 -> 0;
67 -> 0;
68 -> 66;
68 -> 67;
68 -> 64;
69 -> 68;
70 -> 0;
71 -> 0;
72 -> 70;
72 -> 71;
72 -> 68;
73 -> 72;
74 -> 0;
75 -> 0;
76 -> 74;
76 -> 75;
76 -> 0;
77 -> 76;
78 -> 0;
79 -> 0;
80 -> 78;
80 -> 79;
80 -> 0;
81 -> 80;
82 -> 0;
83 -> 0;
84 -> 82;
84 -> 83;
84 -> 0;
85 -> 84;
86 -> 0;
87 -> 0;
88 -> 86;
88 -> 87;
88 -> 72;
89 -> 88;
90 -> 0;
91 -> 0;
92 -> 90;
92 -> 91;
92 -> 0;
93 -> 92;
95 -> 0;
96 -> 94;
96 -> 95;
97 -> 96;
98 -> 0;
99 -> 0;
100 -> 98;
100 -> 99;
100 -> 88;
101 -> 100;
102 -> 0;
103 -> 0;
104 -> 102;
104 -> 103;
104 -> 0;
105 -> 104;
106 -> 0;
107 -> 0;
108 -> 106;
108 -> 107;
108 -> 0;
109 -> 108;
110 -> 0;
111 -> 0;
112 -> 110;
112 -> 111;
112 -> 0;
113 -> 112;
114 -> 0;
115 -> 0;
116 -> 114;
116 -> 115;
116 -> 0;
117 -> 116;
118 -> 0;
119 -> 0;
120 -> 118;
120 -> 119;
120 -> 0;
121 -> 120;
122 -> 0;
123 -> 0;
124 -> 122;
124 -> 123;
124 -> 100;
125 -> 124;
126 -> 0;
127 -> 0;
128 -> 126;
128 -> 127;
128 -> 124;
129 -> 128;
130 -> 0;
131 -> 0;
132 -> 130;
132 -> 131;
132 -> 128;
133 -> 132;
134 -> 0;
135 -> 0;
136 -> 134;
136 -> 135;
136 -> 132;
137 -> 136;
138 -> 0;
139 -> 0;
140 -> 138;
140 -> 139;
140 -> 0;
141 -> 140;
142 -> 0;
143 -> 0;
144 -> 142;
144 -> 143;
144 -> 0;
145 -> 144;
146 -> 0;
147 -> 0;
148 -> 146;
148 -> 147;
148 -> 136;
149 -> 148;
150 -> 0;
151 -> 0;
152 -> 150;
152 -> 151;
152 -> 0;
153 -> 152;
154 -> 0;
155 -> 0;
156 -> 154;
156 -> 155;
156 -> 0;
157 -> 156;
158 -> 0;
159 -> 0;
160 -> 158;
160 -> 159;
160 -> 0;
161 -> 160;
162 -> 0;
163 -> 0;
164 -> 162;
164 -> 163;
164 -> 148;
165 -> 164;
166 -> 0;
167 -> 0;
168 -> 166;
168 -> 167;
168 -> 0;
169 -> 168;
170 -> 0;
171 -> 0;
172 -> 170;
172 -> 171;
172 -> 0;
173 -> 172;
175 -> 174;
177 -> 175;
177 -> 176;
178 -> 177;
180 -> 0;
180 -> 179;
181 -> 180;
181 -> 0;
182 -> 181;
184 -> 183;
186 -> 185;
188 -> 187;
190 -> 189;
191 -> 3;
192 -> 191;
193 -> 192;
194 -> 193;
194 -> 192;
195 -> 1;
195 -> 2;
195 -> 194;
196 -> 1;
197 -> 1;
198 -> 197;
198 -> 1;
199 -> 1;
200 -> 198;
200 -> 199;
201 -> 200;
201 -> 199;
202 -> 199;
203 -> 201;
203 -> 202;
204 -> 202;
205 -> 203;
205 -> 204;
205 -> 202;
206 -> 202;
206 -> 1;
207 -> 1;
208 -> 1;
209 -> 206;
209 -> 208;
210 -> 207;
210 -> 208;
211 -> 207;
211 -> 208;
212 -> 207;
212 -> 208;
213 -> 207;
213 -> 208;
214 -> 207;
214 -> 208;
215 -> 207;
215 -> 208;
216 -> 207;
216 -> 208;
217 -> 209;
217 -> 208;
218 -> 213;
218 -> 208;
219 -> 210;
219 -> 208;
220 -> 208;
221 -> 218;
221 -> 220;
222 -> 219;
222 -> 220;
223 -> 221;
223 -> 220;
224 -> 220;
225 -> 223;
225 -> 224;
226 -> 225;
226 -> 224;
227 -> 226;
228 -> 0;
228 -> 227;
229 -> 228;
230 -> 229;
231 -> 229;
232 -> 0;
232 -> 231;
233 -> 232;
233 -> 230;
233 -> 229;
234 -> 233;
234 -> 227;
235 -> 220;
236 -> 222;
236 -> 235;
236 -> 220;
237 -> 234;
237 -> 236;
238 -> 211;
238 -> 208;
239 -> 212;
239 -> 208;
240 -> 214;
240 -> 208;
241 -> 215;
241 -> 208;
242 -> 216;
242 -> 208;
243 -> 208;
244 -> 217;
244 -> 243;
245 -> 237;
245 -> 243;
246 -> 238;
246 -> 243;
247 -> 239;
247 -> 243;
248 -> 240;
248 -> 243;
249 -> 241;
249 -> 243;
250 -> 242;
250 -> 243;
251 -> 244;
251 -> 243;
252 -> 245;
252 -> 243;
253 -> 246;
253 -> 243;
254 -> 247;
254 -> 243;
255 -> 248;
255 -> 243;
256 -> 249;
256 -> 243;
257 -> 250;
257 -> 243;
258 -> 243;
259 -> 258;
259 -> 243;
260 -> 243;
261 -> 251;
261 -> 260;
262 -> 252;
262 -> 260;
263 -> 253;
263 -> 260;
264 -> 254;
264 -> 260;
265 -> 255;
265 -> 260;
266 -> 256;
266 -> 260;
267 -> 257;
267 -> 260;
268 -> 259;
268 -> 260;
269 -> 264;
269 -> 260;
270 -> 266;
270 -> 260;
271 -> 260;
272 -> 269;
272 -> 271;
273 -> 270;
273 -> 271;
274 -> 261;
274 -> 271;
275 -> 274;
275 -> 205;
275 -> 271;
276 -> 275;
277 -> 273;
277 -> 275;
278 -> 272;
278 -> 275;
279 -> 275;
280 -> 276;
280 -> 279;
281 -> 277;
281 -> 279;
282 -> 278;
282 -> 279;
283 -> 276;
283 -> 279;
284 -> 279;
285 -> 282;
285 -> 284;
285 -> 279;
286 -> 0;
287 -> 0;
289 -> 286;
289 -> 287;
289 -> 288;
290 -> 289;
291 -> 0;
292 -> 290;
292 -> 289;
292 -> 291;
293 -> 292;
294 -> 0;
295 -> 290;
295 -> 289;
295 -> 294;
296 -> 295;
297 -> 0;
298 -> 290;
298 -> 289;
298 -> 297;
299 -> 298;
300 -> 0;
301 -> 290;
301 -> 289;
301 -> 300;
302 -> 301;
303 -> 0;
304 -> 290;
304 -> 289;
304 -> 303;
305 -> 304;
306 -> 0;
307 -> 290;
307 -> 289;
307 -> 306;
308 -> 307;
309 -> 0;
310 -> 290;
310 -> 289;
310 -> 309;
311 -> 310;
312 -> 0;
313 -> 290;
313 -> 289;
313 -> 312;
314 -> 313;
315 -> 0;
316 -> 290;
316 -> 289;
316 -> 315;
317 -> 316;
318 -> 0;
319 -> 290;
319 -> 289;
319 -> 318;
320 -> 319;
321 -> 0;
322 -> 290;
322 -> 289;
322 -> 321;
323 -> 322;
324 -> 290;
327 -> 324;
327 -> 326;
328 -> 325;
328 -> 326;
329 -> 326;
330 -> 327;
330 -> 289;
330 -> 326;
331 -> 326;
332 -> 328;
332 -> 326;
333 -> 329;
333 -> 326;
334 -> 332;
334 -> 333;
334 -> 326;
335 -> 334;
335 -> 331;
335 -> 326;
336 -> 330;
336 -> 331;
336 -> 289;
336 -> 335;
336 -> 334;
336 -> 326;
337 -> 336;
338 -> 0;
339 -> 338;
341 -> 339;
341 -> 340;
342 -> 290;
342 -> 289;
342 -> 341;
343 -> 342;
344 -> 0;
345 -> 344;
346 -> 290;
346 -> 289;
346 -> 345;
347 -> 346;
348 -> 0;
349 -> 290;
349 -> 289;
349 -> 348;
350 -> 349;
351 -> 314;
353 -> 352;
354 -> 0;
355 -> 0;
356 -> 0;
358 -> 354;
358 -> 355;
358 -> 356;
358 -> 357;
359 -> 353;
360 -> 358;
360 -> 359;
360 -> 352;
361 -> 360;
365 -> 362;
365 -> 363;
365 -> 364;
366 -> 296;
366 -> 289;
366 -> 295;
366 -> 362;
366 -> 365;
367 -> 366;
368 -> 308;
369 -> 317;
370 -> 317;
371 -> 314;
372 -> 0;
373 -> 0;
375 -> 372;
375 -> 374;
376 -> 373;
376 -> 374;
377 -> 374;
378 -> 375;
378 -> 374;
379 -> 376;
379 -> 374;
380 -> 0;
380 -> 374;
381 -> 377;
381 -> 374;
382 -> 374;
383 -> 378;
383 -> 379;
383 -> 380;
383 -> 381;
383 -> 382;
383 -> 374;
384 -> 383;
385 -> 0;
386 -> 0;
388 -> 385;
388 -> 387;
389 -> 386;
389 -> 387;
390 -> 387;
391 -> 388;
391 -> 387;
392 -> 389;
392 -> 387;
393 -> 0;
393 -> 387;
394 -> 390;
394 -> 387;
395 -> 387;
396 -> 391;
396 -> 392;
396 -> 393;
396 -> 394;
396 -> 395;
396 -> 387;
397 -> 396;
399 -> 384;
399 -> 383;
399 -> 398;
400 -> 399;
402 -> 397;
402 -> 396;
402 -> 401;
403 -> 402;
404 -> 0;
405 -> 0;
407 -> 404;
407 -> 406;
408 -> 405;
408 -> 406;
409 -> 406;
410 -> 407;
410 -> 406;
411 -> 408;
411 -> 406;
412 -> 0;
412 -> 406;
413 -> 409;
413 -> 406;
414 -> 406;
415 -> 410;
415 -> 411;
415 -> 412;
415 -> 413;
415 -> 414;
415 -> 406;
416 -> 415;
417 -> 0;
418 -> 0;
420 -> 417;
420 -> 419;
421 -> 418;
421 -> 419;
422 -> 419;
423 -> 420;
423 -> 419;
424 -> 421;
424 -> 419;
425 -> 0;
425 -> 419;
426 -> 422;
426 -> 419;
427 -> 419;
428 -> 423;
428 -> 424;
428 -> 425;
428 -> 426;
428 -> 427;
428 -> 419;
429 -> 428;
430 -> 0;
431 -> 0;
433 -> 430;
433 -> 432;
434 -> 431;
434 -> 432;
435 -> 432;
436 -> 433;
436 -> 432;
437 -> 434;
437 -> 432;
438 -> 0;
438 -> 432;
439 -> 435;
439 -> 432;
440 -> 432;
441 -> 436;
441 -> 437;
441 -> 438;
441 -> 439;
441 -> 440;
441 -> 432;
442 -> 441;
443 -> 0;
444 -> 0;
446 -> 443;
446 -> 445;
447 -> 444;
447 -> 445;
448 -> 445;
449 -> 446;
449 -> 445;
450 -> 447;
450 -> 445;
451 -> 0;
451 -> 445;
452 -> 448;
452 -> 445;
453 -> 445;
454 -> 449;
454 -> 450;
454 -> 451;
454 -> 452;
454 -> 453;
454 -> 445;
455 -> 454;
456 -> 0;
457 -> 0;
459 -> 456;
459 -> 458;
460 -> 457;
460 -> 458;
461 -> 458;
462 -> 459;
462 -> 458;
463 -> 460;
463 -> 458;
464 -> 0;
464 -> 458;
465 -> 461;
465 -> 458;
466 -> 458;
467 -> 462;
467 -> 463;
467 -> 464;
467 -> 465;
467 -> 466;
467 -> 458;
468 -> 467;
469 -> 0;
470 -> 0;
472 -> 469;
472 -> 471;
473 -> 470;
473 -> 471;
474 -> 471;
475 -> 472;
475 -> 471;
476 -> 473;
476 -> 471;
477 -> 0;
477 -> 471;
478 -> 474;
478 -> 471;
479 -> 471;
480 -> 475;
480 -> 476;
480 -> 477;
480 -> 478;
480 -> 479;
480 -> 471;
481 -> 480;
483 -> 384;
483 -> 383;
483 -> 482;
484 -> 483;
486 -> 397;
486 -> 396;
486 -> 485;
487 -> 486;
489 -> 416;
489 -> 415;
489 -> 488;
490 -> 489;
492 -> 429;
492 -> 428;
492 -> 491;
493 -> 492;
494 -> 0;
495 -> 384;
495 -> 383;
495 -> 494;
495 -> 0;
496 -> 495;
497 -> 0;
498 -> 397;
498 -> 396;
498 -> 497;
498 -> 0;
499 -> 498;
500 -> 0;
501 -> 468;
501 -> 467;
501 -> 500;
501 -> 0;
502 -> 501;
503 -> 0;
504 -> 416;
504 -> 415;
504 -> 503;
504 -> 0;
505 -> 504;
506 -> 0;
507 -> 0;
507 -> 506;
508 -> 507;
509 -> 290;
509 -> 285;
510 -> 280;
510 -> 279;
511 -> 0;
511 -> 279;
512 -> 511;
512 -> 283;
512 -> 279;
513 -> 279;
514 -> 510;
514 -> 512;
514 -> 513;
514 -> 0;
514 -> 279;
515 -> 514;
515 -> 279;
516 -> 509;
516 -> 279;
517 -> 281;
517 -> 279;
518 -> 279;
519 -> 515;
519 -> 516;
519 -> 517;
519 -> 518;
519 -> 514;
519 -> 289;
519 -> 279;
520 -> 279;
521 -> 519;
521 -> 520;
522 -> 520;
523 -> 520;
524 -> 521;
524 -> 519;
524 -> 523;
524 -> 520;
525 -> 522;
525 -> 520;
526 -> 520;
527 -> 524;
527 -> 519;
527 -> 523;
527 -> 525;
527 -> 526;
527 -> 522;
527 -> 520;
528 -> 520;
529 -> 528;
529 -> 522;
529 -> 520;
530 -> 522;
530 -> 520;
531 -> 520;
532 -> 530;
532 -> 531;
532 -> 522;
532 -> 529;
532 -> 520;
533 -> 521;
533 -> 520;
534 -> 533;
534 -> 276;
534 -> 275;
535 -> 276;
535 -> 260;
536 -> 260;
537 -> 263;
537 -> 536;
537 -> 260;
538 -> 535;
538 -> 537;
539 -> 537;
540 -> 538;
540 -> 539;
540 -> 276;
540 -> 534;
540 -> 519;
540 -> 537;
541 -> 540;
541 -> 537;
542 -> 384;
542 -> 541;
543 -> 0;
543 -> 260;
544 -> 268;
544 -> 260;
545 -> 265;
545 -> 535;
545 -> 262;
545 -> 542;
545 -> 260;
546 -> 545;
546 -> 260;
547 -> 260;
548 -> 546;
548 -> 547;
549 -> 0;
549 -> 547;
550 -> 549;
551 -> 260;
552 -> 545;
552 -> 276;
552 -> 534;
552 -> 519;
552 -> 233;
552 -> 0;
552 -> 383;
552 -> 230;
552 -> 260;
553 -> 260;
554 -> 553;
555 -> 552;
555 -> 554;
555 -> 260;
556 -> 0;
558 -> 556;
558 -> 557;
559 -> 558;
560 -> 0;
562 -> 560;
562 -> 561;
564 -> 562;
564 -> 563;
565 -> 564;
566 -> 552;
566 -> 553;
567 -> 552;
567 -> 553;
568 -> 552;
568 -> 553;
569 -> 552;
569 -> 553;
570 -> 566;
570 -> 553;
571 -> 569;
571 -> 553;
572 -> 567;
572 -> 553;
573 -> 568;
573 -> 553;
574 -> 553;
575 -> 553;
576 -> 570;
576 -> 575;
577 -> 571;
577 -> 575;
578 -> 572;
578 -> 575;
579 -> 573;
579 -> 575;
580 -> 574;
580 -> 575;
581 -> 574;
581 -> 575;
582 -> 574;
582 -> 575;
583 -> 574;
583 -> 575;
584 -> 575;
585 -> 577;
585 -> 584;
585 -> 575;
586 -> 583;
586 -> 575;
587 -> 579;
587 -> 575;
588 -> 587;
588 -> 555;
588 -> 575;
589 -> 576;
589 -> 575;
590 -> 577;
590 -> 575;
591 -> 588;
591 -> 575;
592 -> 580;
592 -> 575;
593 -> 581;
593 -> 575;
594 -> 582;
594 -> 575;
595 -> 583;
595 -> 575;
596 -> 575;
597 -> 0;
597 -> 575;
598 -> 577;
598 -> 588;
598 -> 575;
599 -> 597;
599 -> 598;
599 -> 595;
599 -> 596;
599 -> 0;
599 -> 588;
599 -> 575;
600 -> 575;
601 -> 589;
601 -> 600;
602 -> 590;
602 -> 600;
603 -> 591;
603 -> 600;
604 -> 592;
604 -> 600;
605 -> 593;
605 -> 600;
606 -> 594;
606 -> 600;
607 -> 595;
607 -> 600;
608 -> 596;
608 -> 600;
609 -> 596;
609 -> 600;
610 -> 599;
610 -> 600;
611 -> 596;
611 -> 600;
612 -> 596;
612 -> 600;
613 -> 596;
613 -> 600;
614 -> 601;
614 -> 600;
615 -> 602;
615 -> 600;
616 -> 603;
616 -> 600;
617 -> 604;
617 -> 600;
618 -> 605;
618 -> 600;
619 -> 606;
619 -> 600;
620 -> 607;
620 -> 600;
621 -> 608;
621 -> 600;
622 -> 609;
622 -> 600;
623 -> 610;
623 -> 600;
624 -> 610;
624 -> 599;
624 -> 600;
625 -> 624;
625 -> 599;
625 -> 600;
626 -> 611;
626 -> 600;
627 -> 612;
627 -> 600;
628 -> 600;
629 -> 614;
629 -> 628;
630 -> 615;
630 -> 628;
631 -> 616;
631 -> 628;
632 -> 617;
632 -> 628;
633 -> 618;
633 -> 628;
634 -> 619;
634 -> 628;
635 -> 620;
635 -> 628;
636 -> 621;
636 -> 628;
637 -> 622;
637 -> 628;
638 -> 623;
638 -> 628;
639 -> 625;
639 -> 628;
640 -> 626;
640 -> 628;
641 -> 627;
641 -> 628;
642 -> 613;
642 -> 628;
643 -> 629;
643 -> 628;
644 -> 631;
644 -> 628;
645 -> 639;
645 -> 628;
646 -> 635;
646 -> 628;
647 -> 640;
647 -> 628;
648 -> 641;
648 -> 628;
649 -> 628;
650 -> 649;
650 -> 643;
650 -> 644;
650 -> 645;
650 -> 646;
650 -> 647;
650 -> 648;
650 -> 588;
650 -> 625;
650 -> 628;
651 -> 649;
651 -> 628;
652 -> 649;
652 -> 628;
653 -> 649;
653 -> 628;
654 -> 649;
654 -> 628;
655 -> 649;
655 -> 628;
656 -> 649;
656 -> 628;
657 -> 649;
657 -> 628;
658 -> 649;
658 -> 628;
659 -> 649;
659 -> 628;
660 -> 649;
660 -> 628;
661 -> 649;
661 -> 628;
662 -> 649;
662 -> 628;
663 -> 649;
663 -> 628;
664 -> 649;
664 -> 628;
665 -> 649;
665 -> 628;
666 -> 649;
666 -> 628;
667 -> 649;
667 -> 628;
668 -> 649;
668 -> 628;
669 -> 649;
669 -> 628;
670 -> 649;
670 -> 628;
671 -> 649;
671 -> 628;
672 -> 649;
672 -> 628;
673 -> 649;
673 -> 628;
674 -> 649;
674 -> 628;
675 -> 649;
675 -> 628;
676 -> 649;
676 -> 628;
677 -> 628;
678 -> 677;
678 -> 649;
678 -> 628;
679 -> 649;
679 -> 628;
680 -> 649;
680 -> 628;
681 -> 649;
681 -> 628;
682 -> 649;
682 -> 628;
683 -> 649;
683 -> 628;
684 -> 649;
684 -> 628;
685 -> 649;
685 -> 628;
686 -> 628;
687 -> 628;
688 -> 685;
688 -> 687;
689 -> 686;
689 -> 687;
691 -> 690;
692 -> 690;
693 -> 687;
694 -> 689;
694 -> 693;
695 -> 693;
696 -> 689;
696 -> 687;
697 -> 688;
697 -> 689;
697 -> 687;
698 -> 686;
698 -> 649;
698 -> 628;
699 -> 630;
699 -> 649;
699 -> 628;
700 -> 649;
700 -> 628;
701 -> 700;
701 -> 650;
701 -> 651;
701 -> 699;
701 -> 652;
701 -> 653;
701 -> 654;
701 -> 655;
701 -> 656;
701 -> 657;
701 -> 658;
701 -> 659;
701 -> 660;
701 -> 661;
701 -> 662;
701 -> 663;
701 -> 664;
701 -> 665;
701 -> 666;
701 -> 667;
701 -> 668;
701 -> 669;
701 -> 670;
701 -> 671;
701 -> 672;
701 -> 673;
701 -> 674;
701 -> 675;
701 -> 676;
701 -> 678;
701 -> 679;
701 -> 698;
701 -> 680;
701 -> 681;
701 -> 682;
701 -> 683;
701 -> 684;
701 -> 677;
701 -> 695;
701 -> 696;
701 -> 697;
701 -> 628;
702 -> 701;
702 -> 649;
702 -> 628;
703 -> 649;
703 -> 701;
703 -> 628;
704 -> 703;
704 -> 701;
704 -> 702;
704 -> 628;
705 -> 704;
705 -> 649;
705 -> 628;
706 -> 649;
706 -> 704;
706 -> 628;
707 -> 706;
707 -> 704;
707 -> 705;
707 -> 628;
708 -> 707;
708 -> 649;
708 -> 628;
709 -> 649;
709 -> 707;
709 -> 628;
710 -> 709;
710 -> 707;
710 -> 708;
710 -> 628;
711 -> 710;
711 -> 649;
711 -> 628;
712 -> 649;
712 -> 710;
712 -> 628;
713 -> 712;
713 -> 710;
713 -> 711;
713 -> 628;
714 -> 713;
714 -> 649;
714 -> 628;
715 -> 649;
715 -> 628;
716 -> 628;
717 -> 628;
718 -> 715;
718 -> 717;
719 -> 716;
719 -> 717;
720 -> 717;
721 -> 720;
721 -> 717;
722 -> 720;
722 -> 717;
723 -> 720;
723 -> 717;
724 -> 717;
725 -> 724;
725 -> 720;
725 -> 717;
726 -> 717;
727 -> 718;
727 -> 726;
727 -> 717;
728 -> 718;
728 -> 720;
728 -> 717;
729 -> 716;
729 -> 649;
729 -> 628;
730 -> 638;
730 -> 713;
730 -> 628;
731 -> 628;
732 -> 730;
732 -> 731;
733 -> 731;
734 -> 732;
734 -> 731;
735 -> 734;
735 -> 713;
735 -> 714;
735 -> 729;
735 -> 731;
736 -> 0;
736 -> 731;
737 -> 736;
737 -> 733;
737 -> 731;
738 -> 737;
738 -> 628;
739 -> 738;
739 -> 649;
739 -> 628;
740 -> 635;
740 -> 628;
741 -> 740;
742 -> 632;
742 -> 741;
742 -> 740;
743 -> 633;
743 -> 741;
743 -> 740;
744 -> 742;
744 -> 743;
744 -> 740;
745 -> 634;
745 -> 741;
745 -> 740;
746 -> 744;
746 -> 745;
746 -> 740;
747 -> 637;
747 -> 628;
748 -> 649;
748 -> 713;
748 -> 714;
748 -> 729;
748 -> 739;
748 -> 720;
748 -> 721;
748 -> 728;
748 -> 722;
748 -> 723;
748 -> 725;
748 -> 724;
748 -> 747;
749 -> 747;
750 -> 649;
750 -> 749;
751 -> 750;
751 -> 748;
751 -> 749;
752 -> 636;
752 -> 747;
753 -> 747;
754 -> 747;
755 -> 748;
755 -> 754;
756 -> 751;
756 -> 754;
757 -> 752;
757 -> 754;
758 -> 753;
758 -> 754;
759 -> 755;
759 -> 754;
760 -> 756;
760 -> 754;
761 -> 757;
761 -> 754;
762 -> 754;
763 -> 762;
763 -> 759;
763 -> 760;
763 -> 761;
763 -> 748;
763 -> 754;
764 -> 753;
764 -> 649;
764 -> 747;
765 -> 638;
765 -> 649;
765 -> 628;
766 -> 649;
766 -> 763;
766 -> 628;
767 -> 628;
768 -> 649;
768 -> 763;
768 -> 767;
768 -> 628;
769 -> 575;
770 -> 578;
770 -> 769;
770 -> 575;
771 -> 578;
771 -> 770;
772 -> 770;
773 -> 771;
773 -> 772;
774 -> 596;
774 -> 772;
775 -> 772;
776 -> 773;
776 -> 775;
776 -> 772;
777 -> 773;
777 -> 772;
778 -> 777;
778 -> 763;
778 -> 764;
778 -> 765;
778 -> 772;
779 -> 772;
780 -> 774;
780 -> 778;
780 -> 772;
781 -> 779;
781 -> 772;
782 -> 780;
782 -> 778;
782 -> 772;
783 -> 781;
783 -> 782;
783 -> 779;
783 -> 778;
783 -> 772;
784 -> 772;
785 -> 772;
786 -> 773;
786 -> 772;
787 -> 786;
787 -> 783;
787 -> 772;
788 -> 787;
789 -> 787;
790 -> 787;
791 -> 774;
791 -> 790;
791 -> 787;
792 -> 787;
793 -> 779;
793 -> 792;
793 -> 790;
793 -> 787;
794 -> 784;
794 -> 787;
794 -> 793;
795 -> 785;
795 -> 787;
796 -> 779;
796 -> 793;
796 -> 772;
797 -> 774;
797 -> 796;
797 -> 772;
798 -> 773;
798 -> 772;
799 -> 780;
799 -> 798;
799 -> 796;
799 -> 772;
800 -> 774;
800 -> 799;
800 -> 772;
801 -> 794;
801 -> 772;
802 -> 799;
802 -> 772;
803 -> 772;
804 -> 800;
804 -> 803;
805 -> 801;
805 -> 803;
806 -> 802;
806 -> 803;
807 -> 774;
807 -> 803;
808 -> 807;
808 -> 799;
808 -> 803;
809 -> 803;
810 -> 807;
810 -> 809;
811 -> 810;
811 -> 799;
811 -> 809;
812 -> 811;
812 -> 809;
813 -> 812;
813 -> 803;
814 -> 803;
815 -> 808;
815 -> 814;
816 -> 815;
816 -> 808;
816 -> 814;
817 -> 803;
818 -> 816;
818 -> 817;
819 -> 804;
819 -> 803;
820 -> 805;
820 -> 803;
821 -> 806;
821 -> 803;
822 -> 803;
823 -> 803;
824 -> 808;
824 -> 823;
825 -> 808;
825 -> 823;
826 -> 808;
826 -> 823;
827 -> 813;
827 -> 823;
828 -> 816;
828 -> 823;
829 -> 818;
829 -> 823;
830 -> 818;
830 -> 823;
831 -> 819;
831 -> 823;
832 -> 820;
832 -> 823;
833 -> 821;
833 -> 823;
834 -> 818;
834 -> 823;
835 -> 822;
835 -> 823;
836 -> 822;
836 -> 823;
837 -> 827;
837 -> 823;
838 -> 828;
838 -> 823;
839 -> 829;
839 -> 823;
840 -> 833;
840 -> 818;
840 -> 823;
841 -> 835;
841 -> 823;
842 -> 823;
843 -> 837;
843 -> 842;
844 -> 838;
844 -> 842;
845 -> 839;
845 -> 842;
846 -> 841;
846 -> 842;
847 -> 836;
847 -> 842;
848 -> 846;
848 -> 842;
849 -> 842;
850 -> 849;
850 -> 842;
851 -> 849;
851 -> 842;
852 -> 849;
852 -> 842;
853 -> 849;
853 -> 842;
854 -> 849;
854 -> 842;
855 -> 849;
855 -> 842;
856 -> 849;
856 -> 842;
857 -> 849;
857 -> 842;
858 -> 849;
858 -> 842;
859 -> 849;
859 -> 842;
860 -> 849;
860 -> 842;
861 -> 849;
861 -> 842;
862 -> 849;
862 -> 842;
863 -> 849;
863 -> 842;
864 -> 849;
864 -> 842;
865 -> 849;
865 -> 842;
866 -> 849;
866 -> 842;
867 -> 849;
867 -> 842;
868 -> 849;
868 -> 842;
869 -> 849;
869 -> 842;
870 -> 849;
870 -> 842;
871 -> 849;
871 -> 842;
872 -> 849;
872 -> 842;
873 -> 849;
873 -> 842;
874 -> 849;
874 -> 842;
875 -> 849;
875 -> 842;
876 -> 842;
877 -> 876;
877 -> 849;
877 -> 842;
878 -> 849;
878 -> 842;
879 -> 849;
879 -> 842;
880 -> 849;
880 -> 842;
881 -> 849;
881 -> 842;
882 -> 849;
882 -> 842;
883 -> 849;
883 -> 842;
884 -> 849;
884 -> 842;
885 -> 842;
886 -> 842;
887 -> 884;
887 -> 886;
888 -> 885;
888 -> 886;
889 -> 886;
890 -> 888;
890 -> 889;
891 -> 889;
892 -> 888;
892 -> 886;
893 -> 887;
893 -> 888;
893 -> 886;
894 -> 885;
894 -> 849;
894 -> 842;
895 -> 849;
895 -> 842;
896 -> 849;
896 -> 842;
897 -> 842;
898 -> 842;
899 -> 896;
899 -> 898;
900 -> 897;
900 -> 898;
901 -> 898;
902 -> 901;
902 -> 898;
903 -> 901;
903 -> 898;
904 -> 901;
904 -> 898;
905 -> 898;
906 -> 905;
906 -> 901;
906 -> 898;
907 -> 898;
908 -> 899;
908 -> 907;
908 -> 898;
909 -> 899;
909 -> 901;
909 -> 898;
910 -> 897;
910 -> 849;
910 -> 842;
911 -> 842;
912 -> 840;
912 -> 911;
913 -> 911;
914 -> 912;
914 -> 911;
915 -> 914;
915 -> 840;
915 -> 910;
915 -> 901;
915 -> 902;
915 -> 909;
915 -> 903;
915 -> 904;
915 -> 906;
915 -> 905;
916 -> 914;
917 -> 915;
917 -> 916;
918 -> 830;
918 -> 842;
919 -> 918;
920 -> 843;
920 -> 919;
920 -> 918;
921 -> 844;
921 -> 919;
921 -> 918;
922 -> 920;
922 -> 921;
922 -> 918;
923 -> 845;
923 -> 919;
923 -> 918;
924 -> 922;
924 -> 923;
924 -> 918;
925 -> 831;
925 -> 832;
926 -> 849;
926 -> 832;
927 -> 831;
927 -> 926;
927 -> 840;
927 -> 910;
927 -> 917;
927 -> 901;
927 -> 902;
927 -> 909;
927 -> 903;
927 -> 904;
927 -> 906;
927 -> 905;
927 -> 832;
928 -> 831;
928 -> 849;
928 -> 832;
929 -> 849;
929 -> 927;
929 -> 842;
930 -> 842;
931 -> 849;
931 -> 927;
931 -> 930;
931 -> 842;
932 -> 822;
932 -> 772;
933 -> 932;
933 -> 770;
934 -> 933;
934 -> 927;
934 -> 575;
935 -> 933;
935 -> 575;
936 -> 552;
936 -> 935;
936 -> 927;
936 -> 928;
936 -> 833;
936 -> 260;
937 -> 936;
937 -> 260;
938 -> 260;
939 -> 937;
939 -> 938;
940 -> 938;
941 -> 939;
941 -> 940;
942 -> 941;
942 -> 936;
942 -> 940;
943 -> 942;
943 -> 938;
944 -> 943;
944 -> 942;
944 -> 938;
945 -> 938;
946 -> 943;
946 -> 945;
946 -> 942;
946 -> 938;
947 -> 0;
947 -> 938;
948 -> 946;
948 -> 947;
948 -> 938;
949 -> 267;
949 -> 948;
949 -> 260;
950 -> 936;
950 -> 260;
951 -> 1;
952 -> 950;
952 -> 951;
953 -> 951;
954 -> 952;
954 -> 953;
955 -> 953;
956 -> 954;
956 -> 955;
957 -> 955;
958 -> 956;
958 -> 957;
959 -> 958;
959 -> 948;
959 -> 957;
960 -> 958;
960 -> 959;
961 -> 959;
962 -> 960;
962 -> 961;
963 -> 958;
963 -> 948;
963 -> 961;
964 -> 962;
964 -> 961;
965 -> 961;
966 -> 964;
966 -> 965;
967 -> 963;
967 -> 965;
968 -> 965;
969 -> 965;
970 -> 965;
971 -> 966;
971 -> 970;
972 -> 971;
972 -> 965;
973 -> 965;
974 -> 965;
975 -> 974;
975 -> 965;
976 -> 965;
977 -> 976;
977 -> 965;
978 -> 965;
979 -> 978;
979 -> 965;
980 -> 965;
981 -> 980;
981 -> 965;
982 -> 966;
982 -> 965;
983 -> 969;
983 -> 965;
984 -> 980;
984 -> 965;
985 -> 973;
985 -> 965;
986 -> 974;
986 -> 965;
987 -> 976;
987 -> 965;
988 -> 978;
988 -> 965;
989 -> 968;
989 -> 965;
990 -> 982;
990 -> 983;
990 -> 984;
990 -> 985;
990 -> 986;
990 -> 987;
990 -> 988;
990 -> 989;
990 -> 967;
990 -> 948;
990 -> 969;
990 -> 968;
990 -> 981;
990 -> 975;
990 -> 977;
990 -> 979;
990 -> 965;
991 -> 965;
992 -> 990;
992 -> 991;
993 -> 991;
994 -> 992;
994 -> 993;
995 -> 994;
995 -> 990;
995 -> 993;
996 -> 995;
996 -> 991;
997 -> 0;
998 -> 0;
998 -> 997;
999 -> 0;
1000 -> 998;
1000 -> 0;
1000 -> 999;
1001 -> 1000;
1002 -> 991;
1003 -> 996;
1003 -> 1002;
1004 -> 996;
1004 -> 1002;
1005 -> 1002;
1006 -> 1003;
1006 -> 996;
1006 -> 1005;
1006 -> 1002;
1007 -> 996;
1007 -> 1002;
1008 -> 996;
1008 -> 1002;
1009 -> 0;
1009 -> 1002;
1010 -> 1002;
1011 -> 1002;
1012 -> 1007;
1012 -> 1002;
1013 -> 1012;
1014 -> 1012;
1015 -> 1013;
1015 -> 1014;
1016 -> 1015;
1016 -> 1014;
1017 -> 0;
1017 -> 1016;
1018 -> 1012;
1019 -> 1017;
1019 -> 1012;
1020 -> 1009;
1020 -> 1012;
1021 -> 1010;
1021 -> 1012;
1022 -> 1011;
1022 -> 1012;
1023 -> 1008;
1023 -> 1012;
1024 -> 1012;
1025 -> 1018;
1025 -> 1024;
1026 -> 1019;
1026 -> 1024;
1027 -> 1020;
1027 -> 1024;
1028 -> 1021;
1028 -> 1024;
1029 -> 1022;
1029 -> 1024;
1030 -> 1023;
1030 -> 1024;
1031 -> 1027;
1031 -> 1026;
1031 -> 1024;
1032 -> 1024;
1033 -> 1009;
1033 -> 1017;
1033 -> 1012;
1034 -> 1033;
1034 -> 0;
1034 -> 1002;
1035 -> 1033;
1035 -> 1002;
1036 -> 990;
1036 -> 991;
1037 -> 1036;
1037 -> 1035;
1037 -> 991;
1038 -> 990;
1038 -> 991;
1039 -> 0;
1039 -> 991;
1040 -> 990;
1040 -> 1039;
1040 -> 1037;
1040 -> 965;
1041 -> 990;
1041 -> 991;
1042 -> 990;
1042 -> 991;
1043 -> 990;
1043 -> 991;
1044 -> 990;
1044 -> 991;
1045 -> 990;
1045 -> 991;
1046 -> 990;
1046 -> 991;
1047 -> 990;
1047 -> 991;
1048 -> 1041;
1048 -> 991;
1049 -> 1042;
1049 -> 991;
1050 -> 1046;
1050 -> 991;
1051 -> 1043;
1051 -> 991;
1052 -> 1044;
1052 -> 991;
1053 -> 1045;
1053 -> 991;
1054 -> 991;
1055 -> 991;
1056 -> 1048;
1056 -> 1055;
1057 -> 1049;
1057 -> 1055;
1058 -> 1050;
1058 -> 1055;
1059 -> 1051;
1059 -> 1055;
1060 -> 1052;
1060 -> 1055;
1061 -> 1053;
1061 -> 1055;
1062 -> 1054;
1062 -> 1055;
1063 -> 1056;
1063 -> 1040;
1063 -> 1055;
1064 -> 1056;
1064 -> 1040;
1064 -> 1055;
1065 -> 1058;
1065 -> 1055;
1066 -> 1055;
1067 -> 1063;
1067 -> 1066;
1068 -> 1064;
1068 -> 1066;
1069 -> 1065;
1069 -> 1066;
1070 -> 1062;
1070 -> 1066;
1071 -> 1066;
1072 -> 1071;
1072 -> 1066;
1073 -> 1071;
1073 -> 1066;
1074 -> 1071;
1074 -> 1066;
1075 -> 1066;
1076 -> 1067;
1076 -> 1075;
1076 -> 1066;
1077 -> 1068;
1077 -> 1040;
1077 -> 1066;
1078 -> 1069;
1078 -> 1071;
1078 -> 1066;
1079 -> 1067;
1079 -> 1071;
1079 -> 1066;
1080 -> 1068;
1080 -> 1071;
1080 -> 1066;
1081 -> 1062;
1081 -> 1055;
1082 -> 1062;
1082 -> 1055;
1083 -> 1062;
1083 -> 1055;
1084 -> 1062;
1084 -> 1055;
1085 -> 1062;
1085 -> 1055;
1086 -> 1062;
1086 -> 1055;
1087 -> 1062;
1087 -> 1055;
1088 -> 1055;
1089 -> 1059;
1089 -> 1088;
1089 -> 1055;
1090 -> 1055;
1091 -> 1057;
1091 -> 1090;
1091 -> 1055;
1092 -> 1057;
1092 -> 1062;
1092 -> 1055;
1093 -> 1056;
1093 -> 1062;
1093 -> 1055;
1094 -> 1059;
1094 -> 1062;
1094 -> 1055;
1095 -> 1061;
1095 -> 1062;
1095 -> 1055;
1096 -> 1060;
1096 -> 1062;
1096 -> 1055;
1097 -> 990;
1097 -> 1054;
1097 -> 1040;
1097 -> 1071;
1097 -> 1072;
1097 -> 1073;
1097 -> 1079;
1097 -> 1074;
1097 -> 1078;
1097 -> 1080;
1097 -> 1081;
1097 -> 1093;
1097 -> 1082;
1097 -> 1092;
1097 -> 1083;
1097 -> 1094;
1097 -> 1084;
1097 -> 1095;
1097 -> 1085;
1097 -> 1096;
1097 -> 1086;
1097 -> 1087;
1097 -> 965;
1098 -> 1097;
1098 -> 1075;
1098 -> 1066;
1099 -> 1097;
1099 -> 1066;
1100 -> 967;
1100 -> 1097;
1100 -> 965;
1101 -> 965;
1102 -> 1097;
1102 -> 965;
1103 -> 1100;
1103 -> 1101;
1104 -> 1103;
1104 -> 1100;
1104 -> 1101;
1105 -> 965;
1106 -> 1104;
1106 -> 965;
1107 -> 965;
1108 -> 965;
1109 -> 965;
1110 -> 1109;
1110 -> 965;
1111 -> 965;
1112 -> 1111;
1112 -> 965;
1113 -> 965;
1114 -> 1113;
1114 -> 965;
1115 -> 966;
1115 -> 1106;
1115 -> 965;
1116 -> 965;
1117 -> 1115;
1117 -> 1116;
1117 -> 965;
1118 -> 1117;
1118 -> 965;
1119 -> 965;
1120 -> 1118;
1120 -> 1119;
1120 -> 965;
1121 -> 1120;
1121 -> 965;
1122 -> 965;
1123 -> 1121;
1123 -> 1122;
1123 -> 965;
1124 -> 1123;
1124 -> 965;
1125 -> 0;
1125 -> 965;
1126 -> 1125;
1126 -> 1124;
1126 -> 965;
1127 -> 966;
1127 -> 965;
1128 -> 1106;
1128 -> 965;
1129 -> 1097;
1129 -> 965;
1130 -> 965;
1131 -> 966;
1131 -> 1130;
1132 -> 1131;
1132 -> 1106;
1132 -> 1130;
1133 -> 1132;
1133 -> 965;
1134 -> 965;
1135 -> 966;
1135 -> 1134;
1136 -> 1135;
1136 -> 1106;
1136 -> 1134;
1137 -> 1136;
1137 -> 965;
1138 -> 972;
1138 -> 965;
1139 -> 969;
1139 -> 965;
1140 -> 1113;
1140 -> 965;
1141 -> 1109;
1141 -> 965;
1142 -> 1111;
1142 -> 965;
1143 -> 1126;
1143 -> 965;
1144 -> 968;
1144 -> 965;
1145 -> 1107;
1145 -> 965;
1146 -> 1108;
1146 -> 965;
1147 -> 1127;
1147 -> 1128;
1147 -> 1129;
1147 -> 1133;
1147 -> 1137;
1147 -> 1138;
1147 -> 1139;
1147 -> 1140;
1147 -> 1141;
1147 -> 1142;
1147 -> 1143;
1147 -> 1144;
1147 -> 1145;
1147 -> 1146;
1147 -> 967;
1147 -> 1106;
1147 -> 1097;
1147 -> 1114;
1147 -> 1110;
1147 -> 1112;
1147 -> 0;
1147 -> 965;
1148 -> 965;
1149 -> 1147;
1149 -> 1148;
1150 -> 1147;
1150 -> 1148;
1151 -> 1147;
1151 -> 1148;
1152 -> 1151;
1152 -> 1147;
1152 -> 1148;
1153 -> 1149;
1153 -> 1148;
1154 -> 1148;
1155 -> 1150;
1155 -> 1148;
1156 -> 1152;
1156 -> 1153;
1156 -> 1154;
1156 -> 1155;
1156 -> 1147;
1156 -> 1148;
1157 -> 1147;
1157 -> 1148;
1158 -> 1157;
1158 -> 1156;
1158 -> 1148;
1159 -> 1147;
1159 -> 1148;
1160 -> 1159;
1160 -> 1158;
1160 -> 1148;
1161 -> 1147;
1161 -> 1148;
1162 -> 1161;
1162 -> 1160;
1162 -> 1148;
1163 -> 1147;
1163 -> 1148;
1164 -> 1163;
1164 -> 1162;
1164 -> 1148;
1165 -> 1147;
1165 -> 1148;
1166 -> 1148;
1167 -> 1165;
1167 -> 1164;
1167 -> 1166;
1167 -> 1148;
1168 -> 1167;
1169 -> 1168;
1169 -> 1165;
1169 -> 1167;
1170 -> 1165;
1170 -> 1164;
1170 -> 1169;
1170 -> 1167;
1171 -> 1167;
1172 -> 1170;
1172 -> 1171;
1173 -> 1165;
1173 -> 1171;
1174 -> 1173;
1174 -> 1164;
1174 -> 1171;
1175 -> 1174;
1175 -> 1164;
1175 -> 1169;
1175 -> 1171;
1176 -> 1167;
1177 -> 1165;
1177 -> 1164;
1177 -> 1169;
1177 -> 1148;
1178 -> 1165;
1178 -> 1177;
1179 -> 1177;
1180 -> 1178;
1180 -> 1179;
1181 -> 1165;
1181 -> 1179;
1182 -> 1181;
1182 -> 1177;
1182 -> 1179;
1183 -> 1177;
1184 -> 1177;
1184 -> 965;
1185 -> 1177;
1185 -> 965;
1186 -> 1177;
1186 -> 965;
1187 -> 1097;
1187 -> 1186;
1187 -> 1177;
1187 -> 1185;
1187 -> 965;
1188 -> 965;
1189 -> 965;
1190 -> 1189;
1190 -> 965;
1191 -> 1177;
1191 -> 965;
1192 -> 1185;
1192 -> 965;
1193 -> 1187;
1193 -> 965;
1194 -> 1097;
1194 -> 965;
1195 -> 1097;
1195 -> 1187;
1195 -> 965;
1196 -> 969;
1196 -> 965;
1197 -> 972;
1197 -> 965;
1198 -> 1188;
1198 -> 965;
1199 -> 1189;
1199 -> 965;
1200 -> 1191;
1200 -> 1192;
1200 -> 1193;
1200 -> 1194;
1200 -> 1195;
1200 -> 1196;
1200 -> 1197;
1200 -> 1198;
1200 -> 1199;
1200 -> 1187;
1200 -> 1185;
1200 -> 1190;
1200 -> 965;
1201 -> 965;
1202 -> 965;
1203 -> 1202;
1203 -> 1177;
1203 -> 1200;
1203 -> 965;
1204 -> 1177;
1204 -> 1200;
1204 -> 1202;
1204 -> 1203;
1205 -> 1204;
1205 -> 1200;
1205 -> 1203;
1206 -> 1177;
1206 -> 1202;
1206 -> 1200;
1206 -> 1205;
1207 -> 1205;
1208 -> 1206;
1208 -> 1207;
1209 -> 1208;
1209 -> 1206;
1209 -> 1207;
1210 -> 1207;
1211 -> 1208;
1211 -> 1210;
1212 -> 1211;
1212 -> 1207;
1213 -> 1207;
1214 -> 1208;
1214 -> 1213;
1215 -> 1213;
1216 -> 1214;
1216 -> 1215;
1217 -> 1216;
1217 -> 1206;
1217 -> 1215;
1218 -> 1216;
1218 -> 1206;
1218 -> 1217;
1219 -> 1218;
1219 -> 1216;
1219 -> 1217;
1220 -> 1217;
1221 -> 1220;
1221 -> 1216;
1221 -> 1217;
1222 -> 1216;
1222 -> 1218;
1222 -> 1219;
1222 -> 1215;
1223 -> 1222;
1223 -> 1213;
1224 -> 1214;
1224 -> 1218;
1224 -> 1213;
1225 -> 1224;
1225 -> 1207;
1226 -> 1207;
1227 -> 1207;
1228 -> 1209;
1228 -> 1227;
1229 -> 1209;
1229 -> 1227;
1230 -> 1212;
1230 -> 1227;
1231 -> 1225;
1231 -> 1227;
1232 -> 1226;
1232 -> 1227;
1233 -> 1227;
1234 -> 1232;
1234 -> 1233;
1235 -> 1233;
1236 -> 1234;
1236 -> 1235;
1239 -> 1238;
1239 -> 1237;
1240 -> 1237;
1241 -> 1235;
1242 -> 1236;
1242 -> 1241;
1243 -> 1241;
1244 -> 1242;
1244 -> 1243;
1245 -> 1244;
1245 -> 1243;
1246 -> 1242;
1246 -> 1241;
1247 -> 1235;
1248 -> 1247;
1248 -> 1236;
1248 -> 1235;
1249 -> 1236;
1249 -> 1235;
1250 -> 1234;
1250 -> 1233;
1251 -> 1234;
1251 -> 1233;
1252 -> 1234;
1252 -> 1233;
1253 -> 1234;
1253 -> 1233;
1254 -> 1234;
1254 -> 1233;
1255 -> 1234;
1255 -> 1233;
1256 -> 1234;
1256 -> 1233;
1257 -> 1232;
1257 -> 1227;
1258 -> 1232;
1258 -> 1227;
1259 -> 1232;
1259 -> 1227;
1260 -> 1227;
1261 -> 1228;
1261 -> 1260;
1261 -> 1227;
1262 -> 1227;
1263 -> 1229;
1263 -> 1262;
1263 -> 1227;
1264 -> 1228;
1264 -> 1232;
1264 -> 1227;
1265 -> 1229;
1265 -> 1232;
1265 -> 1227;
1266 -> 1228;
1266 -> 1218;
1266 -> 1219;
1266 -> 1221;
1266 -> 1227;
1267 -> 1227;
1268 -> 1267;
1268 -> 1228;
1268 -> 1218;
1268 -> 1219;
1268 -> 1221;
1268 -> 1227;
1269 -> 1232;
1269 -> 1268;
1271 -> 1270;
1272 -> 1228;
1272 -> 1218;
1272 -> 1267;
1272 -> 1219;
1272 -> 1221;
1272 -> 1268;
1273 -> 1231;
1273 -> 1268;
1274 -> 1267;
1274 -> 1268;
1275 -> 1268;
1276 -> 1268;
1277 -> 1269;
1277 -> 1276;
1278 -> 1272;
1278 -> 1276;
1279 -> 1273;
1279 -> 1276;
1280 -> 1274;
1280 -> 1276;
1281 -> 1275;
1281 -> 1276;
1282 -> 1277;
1282 -> 1276;
1283 -> 1278;
1283 -> 1276;
1284 -> 1279;
1284 -> 1276;
1285 -> 1280;
1285 -> 1276;
1286 -> 1276;
1287 -> 1282;
1287 -> 1286;
1288 -> 1283;
1288 -> 1286;
1289 -> 1284;
1289 -> 1286;
1290 -> 1285;
1290 -> 1286;
1291 -> 1281;
1291 -> 1286;
1292 -> 1286;
1293 -> 1291;
1293 -> 1292;
1294 -> 1292;
1295 -> 1293;
1295 -> 1294;
1296 -> 1294;
1297 -> 1295;
1297 -> 1296;
1298 -> 1297;
1298 -> 1296;
1299 -> 1293;
1299 -> 1292;
1300 -> 1291;
1300 -> 1286;
1301 -> 1291;
1301 -> 1286;
1302 -> 1291;
1302 -> 1286;
1303 -> 1291;
1303 -> 1286;
1304 -> 1291;
1304 -> 1286;
1305 -> 1291;
1305 -> 1286;
1306 -> 1291;
1306 -> 1286;
1307 -> 1286;
1308 -> 1307;
1308 -> 1286;
1309 -> 1271;
1309 -> 1286;
1310 -> 1308;
1310 -> 1309;
1310 -> 1286;
1311 -> 1310;
1311 -> 1291;
1311 -> 1286;
1312 -> 1286;
1313 -> 1312;
1313 -> 1286;
1314 -> 1271;
1314 -> 1286;
1315 -> 1313;
1315 -> 1314;
1315 -> 1286;
1316 -> 1315;
1316 -> 1291;
1316 -> 1286;
1317 -> 1291;
1317 -> 1286;
1318 -> 1291;
1318 -> 1286;
1319 -> 1291;
1319 -> 1286;
1320 -> 1291;
1320 -> 1286;
1321 -> 1286;
1322 -> 1287;
1322 -> 1321;
1322 -> 1286;
1323 -> 1286;
1324 -> 1288;
1324 -> 1323;
1324 -> 1286;
1325 -> 1287;
1325 -> 1291;
1325 -> 1286;
1326 -> 1290;
1326 -> 1291;
1326 -> 1286;
1327 -> 1288;
1327 -> 1291;
1327 -> 1286;
1328 -> 1289;
1328 -> 1291;
1328 -> 1286;
1329 -> 1291;
1329 -> 1286;
1330 -> 1286;
1331 -> 1286;
1332 -> 1329;
1332 -> 1331;
1333 -> 1330;
1333 -> 1331;
1334 -> 1331;
1335 -> 1333;
1335 -> 1334;
1336 -> 1334;
1337 -> 1335;
1337 -> 1336;
1338 -> 1336;
1339 -> 1337;
1339 -> 1338;
1340 -> 1338;
1341 -> 1339;
1341 -> 1340;
1342 -> 1341;
1342 -> 1340;
1343 -> 1337;
1343 -> 1336;
1344 -> 1337;
1344 -> 1336;
1345 -> 1335;
1345 -> 1334;
1346 -> 1335;
1346 -> 1334;
1347 -> 1335;
1347 -> 1334;
1348 -> 1333;
1348 -> 1331;
1349 -> 1331;
1350 -> 1332;
1350 -> 1349;
1350 -> 1331;
1351 -> 1332;
1351 -> 1333;
1351 -> 1331;
1352 -> 1330;
1352 -> 1291;
1352 -> 1286;
1353 -> 1291;
1353 -> 1286;
1354 -> 1353;
1354 -> 1298;
1354 -> 1299;
1354 -> 1325;
1354 -> 1326;
1354 -> 1327;
1354 -> 1352;
1354 -> 1304;
1354 -> 1305;
1354 -> 1306;
1354 -> 1311;
1354 -> 1316;
1354 -> 1328;
1354 -> 1318;
1354 -> 1319;
1354 -> 1320;
1354 -> 1310;
1354 -> 1315;
1354 -> 1245;
1354 -> 1246;
1354 -> 1248;
1354 -> 1249;
1354 -> 1250;
1354 -> 1251;
1354 -> 1252;
1354 -> 1253;
1354 -> 1254;
1354 -> 1255;
1354 -> 1256;
1354 -> 1264;
1354 -> 1265;
1354 -> 1259;
1354 -> 1247;
1354 -> 1272;
1354 -> 1342;
1354 -> 1343;
1354 -> 1344;
1354 -> 1345;
1354 -> 1346;
1354 -> 1347;
1354 -> 1351;
1354 -> 1286;
1355 -> 1354;
1355 -> 1291;
1355 -> 1286;
1356 -> 1276;
1357 -> 1280;
1357 -> 1356;
1357 -> 1276;
1358 -> 1275;
1358 -> 1267;
1358 -> 1266;
1358 -> 1268;
1359 -> 1266;
1359 -> 1227;
1360 -> 1359;
1360 -> 1266;
1360 -> 1358;
1360 -> 1354;
1360 -> 1355;
1360 -> 1227;
1361 -> 1360;
1361 -> 1232;
1361 -> 1227;
1362 -> 1230;
1362 -> 1232;
1362 -> 1227;
1363 -> 1226;
1363 -> 1205;
1364 -> 1363;
1364 -> 1204;
1364 -> 1205;
1365 -> 1202;
1365 -> 1205;
1366 -> 1201;
1366 -> 1365;
1366 -> 1205;
1367 -> 1177;
1367 -> 1202;
1367 -> 1360;
1367 -> 1361;
1367 -> 1362;
1367 -> 1203;
1368 -> 1203;
1369 -> 1367;
1369 -> 1368;
1370 -> 1203;
1371 -> 1204;
1371 -> 1200;
1371 -> 1364;
1371 -> 1370;
1372 -> 1371;
1372 -> 1367;
1372 -> 1370;
1373 -> 1369;
1373 -> 1372;
1373 -> 1203;
1374 -> 1367;
1375 -> 1374;
1375 -> 1367;
1376 -> 1367;
1377 -> 1367;
1378 -> 1367;
1379 -> 1367;
1380 -> 1367;
1381 -> 1367;
1382 -> 1367;
1383 -> 1367;
1384 -> 1367;
1385 -> 1367;
1386 -> 1367;
1387 -> 1367;
1388 -> 1367;
1389 -> 1367;
1390 -> 1367;
1391 -> 1203;
1391 -> 1367;
1392 -> 1201;
1392 -> 1366;
1392 -> 1391;
1392 -> 1367;
1393 -> 1367;
1394 -> 1367;
1395 -> 1367;
1395 -> 1390;
1395 -> 1394;
1396 -> 1395;
1396 -> 1367;
1396 -> 1394;
1397 -> 1393;
1397 -> 1396;
1397 -> 1367;
1398 -> 1393;
1398 -> 1367;
1399 -> 1393;
1399 -> 1367;
1400 -> 1393;
1401 -> 1393;
1402 -> 1393;
1403 -> 1393;
1404 -> 1393;
1405 -> 1393;
1406 -> 1393;
1407 -> 1393;
1408 -> 1393;
1409 -> 1393;
1409 -> 1389;
1409 -> 1367;
1410 -> 1393;
1410 -> 1367;
1411 -> 1367;
1412 -> 1367;
1412 -> 1410;
1412 -> 1394;
1413 -> 1412;
1413 -> 1393;
1413 -> 1394;
1414 -> 1393;
1415 -> 1414;
1415 -> 1393;
1416 -> 1393;
1417 -> 1393;
1418 -> 1393;
1419 -> 1393;
1420 -> 1393;
1421 -> 1393;
1422 -> 1367;
1422 -> 1393;
1423 -> 1201;
1423 -> 1366;
1423 -> 1392;
1423 -> 1422;
1423 -> 1393;
1424 -> 1393;
1425 -> 1393;
1425 -> 1421;
1425 -> 1424;
1426 -> 1425;
1426 -> 1393;
1426 -> 1424;
1427 -> 1393;
1428 -> 966;
1428 -> 965;
1429 -> 967;
1429 -> 1393;
1429 -> 965;
1430 -> 966;
1430 -> 1393;
1430 -> 965;
1431 -> 965;
1433 -> 1097;
1433 -> 965;
1434 -> 965;
1435 -> 1428;
1435 -> 1434;
1436 -> 1429;
1436 -> 1434;
1437 -> 1430;
1437 -> 1434;
1438 -> 1433;
1438 -> 1434;
1439 -> 1431;
1439 -> 1434;
1440 -> 1434;
1441 -> 1439;
1441 -> 1440;
1442 -> 1440;
1443 -> 1441;
1443 -> 1442;
1444 -> 1442;
1445 -> 1443;
1445 -> 1444;
1446 -> 1444;
1447 -> 1445;
1447 -> 1446;
1448 -> 1447;
1448 -> 1446;
1449 -> 1445;
1449 -> 1444;
1450 -> 1442;
1451 -> 1450;
1451 -> 1443;
1451 -> 1442;
1452 -> 1443;
1452 -> 1442;
1453 -> 1441;
1453 -> 1440;
1454 -> 1441;
1454 -> 1440;
1455 -> 1441;
1455 -> 1440;
1456 -> 1441;
1456 -> 1440;
1457 -> 1441;
1457 -> 1440;
1458 -> 1441;
1458 -> 1440;
1459 -> 1441;
1459 -> 1440;
1460 -> 1439;
1460 -> 1434;
1461 -> 1439;
1461 -> 1434;
1462 -> 1439;
1462 -> 1434;
1463 -> 1439;
1463 -> 1434;
1464 -> 1439;
1464 -> 1434;
1465 -> 1439;
1465 -> 1434;
1466 -> 1439;
1466 -> 1434;
1467 -> 1439;
1467 -> 1434;
1468 -> 1439;
1468 -> 1434;
1469 -> 1434;
1470 -> 1469;
1470 -> 1439;
1470 -> 1434;
1471 -> 1434;
1472 -> 1471;
1472 -> 1439;
1472 -> 1434;
1473 -> 1434;
1474 -> 1473;
1474 -> 1439;
1474 -> 1434;
1475 -> 1439;
1475 -> 1434;
1476 -> 1439;
1476 -> 1434;
1477 -> 1434;
1478 -> 1435;
1478 -> 1477;
1478 -> 1434;
1479 -> 1434;
1480 -> 1436;
1480 -> 1479;
1480 -> 1434;
1481 -> 1437;
1481 -> 1434;
1482 -> 1438;
1482 -> 1097;
1482 -> 1434;
1483 -> 1435;
1483 -> 1439;
1483 -> 1434;
1484 -> 1436;
1484 -> 1439;
1484 -> 1434;
1485 -> 1434;
1486 -> 1485;
1486 -> 1438;
1486 -> 1097;
1486 -> 1434;
1487 -> 1439;
1487 -> 1434;
1488 -> 1434;
1489 -> 1435;
1489 -> 1488;
1490 -> 1489;
1490 -> 1430;
1490 -> 1488;
1491 -> 1490;
1491 -> 1434;
1492 -> 1437;
1492 -> 1434;
1493 -> 1434;
1494 -> 1434;
1495 -> 1487;
1495 -> 1494;
1496 -> 1491;
1496 -> 1494;
1497 -> 1492;
1497 -> 1494;
1498 -> 1493;
1498 -> 1494;
1499 -> 1494;
1500 -> 1498;
1500 -> 1499;
1501 -> 1499;
1502 -> 1500;
1502 -> 1501;
1503 -> 1501;
1504 -> 1502;
1504 -> 1503;
1505 -> 1504;
1505 -> 1503;
1506 -> 1500;
1506 -> 1499;
1507 -> 1498;
1507 -> 1494;
1508 -> 0;
1508 -> 1498;
1508 -> 1494;
1509 -> 1498;
1509 -> 1494;
1510 -> 1498;
1510 -> 1494;
1511 -> 1498;
1511 -> 1494;
1512 -> 1498;
1512 -> 1494;
1513 -> 1498;
1513 -> 1494;
1514 -> 1494;
1515 -> 1495;
1515 -> 1514;
1515 -> 1494;
1516 -> 1495;
1516 -> 1498;
1516 -> 1494;
1517 -> 1496;
1517 -> 1498;
1517 -> 1494;
1518 -> 1497;
1518 -> 1498;
1518 -> 1494;
1519 -> 1486;
1519 -> 1493;
1519 -> 1505;
1519 -> 1506;
1519 -> 1516;
1519 -> 1508;
1519 -> 1517;
1519 -> 1510;
1519 -> 1511;
1519 -> 1512;
1519 -> 1518;
1519 -> 1448;
1519 -> 1449;
1519 -> 1451;
1519 -> 1452;
1519 -> 1453;
1519 -> 1454;
1519 -> 1455;
1519 -> 1456;
1519 -> 1457;
1519 -> 1458;
1519 -> 1459;
1519 -> 1483;
1519 -> 1461;
1519 -> 1484;
1519 -> 1463;
1519 -> 1464;
1519 -> 1465;
1519 -> 1466;
1519 -> 1467;
1519 -> 1468;
1519 -> 1470;
1519 -> 1472;
1519 -> 1474;
1519 -> 1475;
1519 -> 1476;
1519 -> 1450;
1519 -> 1490;
1519 -> 1469;
1519 -> 1471;
1519 -> 1473;
1519 -> 1434;
1520 -> 1434;
1521 -> 1435;
1521 -> 1520;
1522 -> 1521;
1522 -> 1519;
1522 -> 1520;
1523 -> 1522;
1523 -> 1434;
1524 -> 1523;
1524 -> 1434;
1525 -> 1438;
1525 -> 1434;
1526 -> 1486;
1526 -> 1519;
1526 -> 1434;
1527 -> 1526;
1527 -> 1439;
1527 -> 1434;
1528 -> 1434;
1529 -> 1435;
1529 -> 1528;
1530 -> 1529;
1530 -> 1519;
1530 -> 1528;
1531 -> 1530;
1531 -> 1434;
1532 -> 1531;
1532 -> 1519;
1532 -> 1527;
1532 -> 1434;
1533 -> 965;
1534 -> 965;
1535 -> 1177;
1535 -> 1534;
1535 -> 965;
1536 -> 1535;
1537 -> 1177;
1537 -> 1519;
1537 -> 1527;
1537 -> 1536;
1538 -> 1537;
1538 -> 965;
1539 -> 965;
1540 -> 1538;
1540 -> 1539;
1541 -> 1431;
1541 -> 1539;
1542 -> 1539;
1543 -> 1541;
1543 -> 1519;
1543 -> 1542;
1543 -> 1539;
1544 -> 1540;
1544 -> 1541;
1544 -> 1539;
1545 -> 965;
1546 -> 965;
1547 -> 965;
1548 -> 1177;
1548 -> 1519;
1548 -> 1547;
1548 -> 965;
1549 -> 965;
1550 -> 1549;
1550 -> 965;
1551 -> 1431;
1551 -> 965;
1552 -> 1097;
1552 -> 965;
1553 -> 1548;
1553 -> 965;
1554 -> 1177;
1554 -> 965;
1555 -> 1546;
1555 -> 965;
1556 -> 1549;
1556 -> 965;
1557 -> 965;
1558 -> 1551;
1558 -> 1557;
1559 -> 1552;
1559 -> 1557;
1560 -> 1553;
1560 -> 1557;
1561 -> 1554;
1561 -> 1557;
1562 -> 1555;
1562 -> 1557;
1563 -> 1556;
1563 -> 1557;
1564 -> 1557;
1565 -> 1558;
1565 -> 1564;
1566 -> 1565;
1566 -> 1519;
1566 -> 1527;
1566 -> 1564;
1567 -> 1566;
1567 -> 1557;
1568 -> 1557;
1569 -> 1568;
1569 -> 1559;
1569 -> 1097;
1569 -> 1557;
1570 -> 1567;
1570 -> 1519;
1570 -> 1526;
1570 -> 1569;
1570 -> 1557;
1571 -> 1557;
1572 -> 1567;
1572 -> 1519;
1572 -> 1526;
1572 -> 1571;
1572 -> 1557;
1573 -> 1572;
1573 -> 1557;
1574 -> 1557;
1575 -> 1557;
1576 -> 1575;
1576 -> 1567;
1576 -> 1519;
1576 -> 1526;
1576 -> 1557;
1577 -> 1576;
1578 -> 1577;
1578 -> 1576;
1579 -> 1560;
1579 -> 1578;
1580 -> 1579;
1580 -> 1576;
1581 -> 1579;
1581 -> 1576;
1582 -> 1576;
1583 -> 1576;
1584 -> 1583;
1584 -> 1579;
1584 -> 1576;
1585 -> 1584;
1586 -> 1561;
1586 -> 1519;
1586 -> 1527;
1586 -> 1544;
1586 -> 1585;
1586 -> 1584;
1587 -> 1584;
1588 -> 1561;
1588 -> 1519;
1588 -> 1527;
1588 -> 1544;
1588 -> 1587;
1588 -> 1584;
1589 -> 1574;
1589 -> 1583;
1589 -> 1584;
1590 -> 1588;
1590 -> 1519;
1590 -> 1527;
1590 -> 1544;
1590 -> 1526;
1590 -> 1589;
1590 -> 1584;
1591 -> 1590;
1591 -> 1519;
1591 -> 1526;
1591 -> 1584;
1592 -> 1590;
1592 -> 1519;
1592 -> 1526;
1592 -> 1584;
1593 -> 1561;
1593 -> 1592;
1594 -> 1590;
1594 -> 1592;
1595 -> 1582;
1595 -> 1592;
1596 -> 1592;
1597 -> 1593;
1597 -> 1596;
1598 -> 1594;
1598 -> 1596;
1599 -> 1595;
1599 -> 1596;
1600 -> 1598;
1600 -> 1519;
1600 -> 1526;
1600 -> 1596;
1601 -> 1598;
1601 -> 1519;
1601 -> 1526;
1601 -> 1596;
1602 -> 1597;
1602 -> 1519;
1602 -> 1527;
1602 -> 1544;
1602 -> 1598;
1602 -> 1526;
1602 -> 1596;
1603 -> 1602;
1603 -> 1596;
1604 -> 1596;
1605 -> 1598;
1605 -> 1519;
1605 -> 1526;
1605 -> 1604;
1605 -> 1596;
1606 -> 1602;
1606 -> 1596;
1607 -> 1606;
1607 -> 1583;
1607 -> 1581;
1607 -> 1592;
1608 -> 1590;
1608 -> 1519;
1608 -> 1526;
1608 -> 1583;
1608 -> 1580;
1608 -> 1584;
1609 -> 1574;
1609 -> 1584;
1610 -> 1588;
1610 -> 1519;
1610 -> 1527;
1610 -> 1544;
1610 -> 1526;
1610 -> 1609;
1610 -> 1584;
1611 -> 1610;
1611 -> 1519;
1611 -> 1526;
1611 -> 1584;
1612 -> 1610;
1612 -> 1519;
1612 -> 1526;
1612 -> 1584;
1613 -> 1561;
1613 -> 1612;
1614 -> 1610;
1614 -> 1612;
1615 -> 1612;
1616 -> 1613;
1616 -> 1615;
1617 -> 1614;
1617 -> 1615;
1618 -> 1617;
1618 -> 1519;
1618 -> 1526;
1618 -> 1615;
1619 -> 1617;
1619 -> 1519;
1619 -> 1526;
1619 -> 1615;
1620 -> 1616;
1620 -> 1519;
1620 -> 1527;
1620 -> 1544;
1620 -> 1617;
1620 -> 1526;
1620 -> 1615;
1621 -> 1620;
1621 -> 1615;
1622 -> 1615;
1623 -> 1617;
1623 -> 1519;
1623 -> 1526;
1623 -> 1622;
1623 -> 1615;
1624 -> 1620;
1624 -> 1615;
1625 -> 1624;
1625 -> 1584;
1625 -> 1581;
1625 -> 1612;
1626 -> 1610;
1626 -> 1519;
1626 -> 1526;
1626 -> 1584;
1626 -> 1580;
1627 -> 1580;
1627 -> 1576;
1628 -> 1627;
1628 -> 1580;
1628 -> 1608;
1628 -> 1626;
1628 -> 1519;
1628 -> 1527;
1628 -> 1544;
1628 -> 1526;
1628 -> 1576;
1629 -> 1581;
1629 -> 1576;
1630 -> 1629;
1630 -> 1581;
1630 -> 1607;
1630 -> 1625;
1630 -> 1628;
1630 -> 1576;
1631 -> 1599;
1631 -> 1576;
1632 -> 1628;
1632 -> 1630;
1632 -> 1631;
1632 -> 1576;
1633 -> 1576;
1634 -> 1567;
1634 -> 1575;
1634 -> 1519;
1634 -> 1527;
1634 -> 1544;
1634 -> 1526;
1634 -> 1632;
1634 -> 1576;
1635 -> 1632;
1635 -> 1576;
1636 -> 1558;
1636 -> 1576;
1637 -> 1576;
1638 -> 1635;
1638 -> 1637;
1639 -> 1636;
1639 -> 1637;
1640 -> 1634;
1640 -> 1637;
1641 -> 1637;
1642 -> 1638;
1642 -> 1641;
1642 -> 1637;
1643 -> 1637;
1644 -> 1640;
1644 -> 1643;
1645 -> 1643;
1646 -> 1644;
1646 -> 1634;
1646 -> 1645;
1646 -> 1643;
1647 -> 1637;
1648 -> 1638;
1648 -> 1640;
1648 -> 1637;
1649 -> 1576;
1650 -> 1574;
1650 -> 1579;
1650 -> 1576;
1651 -> 1573;
1651 -> 1557;
1652 -> 965;
1653 -> 965;
1654 -> 1201;
1654 -> 1366;
1654 -> 1392;
1654 -> 1423;
1654 -> 1653;
1654 -> 965;
1655 -> 1177;
1655 -> 1654;
1656 -> 1201;
1656 -> 1654;
1657 -> 1431;
1657 -> 1654;
1658 -> 1177;
1658 -> 1654;
1659 -> 1562;
1659 -> 1654;
1660 -> 1654;
1661 -> 1656;
1661 -> 1660;
1662 -> 1657;
1662 -> 1660;
1663 -> 1658;
1663 -> 1660;
1664 -> 1658;
1664 -> 1660;
1665 -> 1659;
1665 -> 1660;
1666 -> 1660;
1667 -> 1661;
1667 -> 1201;
1667 -> 1366;
1667 -> 1392;
1667 -> 1423;
1667 -> 1666;
1667 -> 1660;
1668 -> 1660;
1669 -> 1662;
1669 -> 1668;
1670 -> 1669;
1670 -> 1634;
1670 -> 1668;
1671 -> 1670;
1671 -> 1660;
1672 -> 1660;
1673 -> 1671;
1673 -> 1672;
1673 -> 1660;
1674 -> 1661;
1674 -> 1660;
1675 -> 1663;
1675 -> 1674;
1675 -> 1634;
1675 -> 1648;
1676 -> 1674;
1677 -> 1675;
1677 -> 1676;
1677 -> 1674;
1678 -> 1663;
1678 -> 1674;
1678 -> 1675;
1678 -> 1677;
1679 -> 1678;
1679 -> 1677;
1680 -> 1664;
1680 -> 1677;
1681 -> 1664;
1681 -> 1678;
1681 -> 1674;
1681 -> 1677;
1682 -> 1665;
1682 -> 1677;
1683 -> 1662;
1683 -> 1677;
1684 -> 1677;
1685 -> 1679;
1685 -> 1684;
1686 -> 1680;
1686 -> 1684;
1687 -> 1681;
1687 -> 1684;
1688 -> 1682;
1688 -> 1684;
1689 -> 1683;
1689 -> 1684;
1690 -> 1687;
1690 -> 1678;
1690 -> 1684;
1691 -> 1687;
1691 -> 1678;
1691 -> 1684;
1692 -> 1687;
1692 -> 1678;
1692 -> 1684;
1693 -> 1684;
1694 -> 1692;
1694 -> 1693;
1695 -> 1694;
1695 -> 1678;
1695 -> 1693;
1696 -> 1695;
1696 -> 1684;
1697 -> 1696;
1697 -> 1678;
1697 -> 1684;
1698 -> 1684;
1699 -> 1684;
1700 -> 1699;
1700 -> 1697;
1700 -> 1684;
1701 -> 1685;
1701 -> 1678;
1701 -> 1699;
1701 -> 1700;
1702 -> 1701;
1702 -> 1700;
1703 -> 1701;
1703 -> 1700;
1704 -> 1700;
1705 -> 1685;
1705 -> 1704;
1706 -> 1705;
1706 -> 1701;
1706 -> 1704;
1707 -> 1706;
1707 -> 1700;
1708 -> 1698;
1708 -> 1700;
1709 -> 1702;
1709 -> 1700;
1710 -> 1700;
1711 -> 1701;
1711 -> 1700;
1712 -> 1707;
1712 -> 1708;
1712 -> 1709;
1712 -> 1710;
1712 -> 1711;
1712 -> 1701;
1712 -> 1702;
1712 -> 1700;
1713 -> 1700;
1714 -> 1700;
1715 -> 1714;
1715 -> 1701;
1715 -> 1700;
1716 -> 1702;
1716 -> 1700;
1717 -> 1716;
1717 -> 1712;
1717 -> 1700;
1718 -> 1703;
1718 -> 1700;
1719 -> 1713;
1719 -> 1700;
1720 -> 1717;
1720 -> 1718;
1720 -> 1719;
1720 -> 1700;
1721 -> 1696;
1721 -> 1699;
1721 -> 1678;
1721 -> 1720;
1721 -> 1700;
1722 -> 1720;
1722 -> 1700;
1723 -> 1689;
1723 -> 1700;
1724 -> 1700;
1725 -> 1722;
1725 -> 1724;
1726 -> 1723;
1726 -> 1724;
1727 -> 1721;
1727 -> 1724;
1728 -> 1724;
1729 -> 1725;
1729 -> 1728;
1729 -> 1724;
1730 -> 1724;
1731 -> 1727;
1731 -> 1730;
1732 -> 1730;
1733 -> 1731;
1733 -> 1721;
1733 -> 1732;
1733 -> 1730;
1734 -> 1724;
1735 -> 1700;
1736 -> 1698;
1736 -> 1701;
1736 -> 1700;
1737 -> 1677;
1738 -> 1688;
1738 -> 1725;
1739 -> 1662;
1739 -> 1725;
1740 -> 1725;
1741 -> 1739;
1741 -> 1725;
1742 -> 1725;
1743 -> 1725;
1744 -> 1725;
1745 -> 1725;
1745 -> 1744;
1746 -> 1745;
1746 -> 1725;
1746 -> 1744;
1747 -> 1740;
1747 -> 1746;
1748 -> 1745;
1748 -> 1746;
1749 -> 1725;
1749 -> 1746;
1750 -> 1746;
1751 -> 1747;
1751 -> 1750;
1752 -> 1748;
1752 -> 1750;
1753 -> 1749;
1753 -> 1750;
1754 -> 1752;
1754 -> 1725;
1754 -> 1750;
1755 -> 1752;
1755 -> 1725;
1755 -> 1750;
1756 -> 1751;
1756 -> 1750;
1757 -> 1750;
1758 -> 1752;
1758 -> 1725;
1758 -> 1757;
1758 -> 1750;
1759 -> 1751;
1759 -> 1744;
1759 -> 1725;
1759 -> 1746;
1760 -> 1725;
1760 -> 1744;
1760 -> 1746;
1761 -> 1738;
1761 -> 1746;
1762 -> 1746;
1763 -> 1760;
1763 -> 1762;
1764 -> 1761;
1764 -> 1762;
1765 -> 1762;
1766 -> 1762;
1767 -> 1764;
1767 -> 1766;
1767 -> 1762;
1768 -> 1767;
1769 -> 1763;
1769 -> 1762;
1770 -> 1762;
1771 -> 1762;
1772 -> 1769;
1772 -> 1771;
1773 -> 1770;
1773 -> 1771;
1774 -> 1771;
1775 -> 1773;
1775 -> 1771;
1776 -> 1773;
1776 -> 1771;
1777 -> 1771;
1778 -> 1772;
1778 -> 1777;
1778 -> 1771;
1779 -> 1772;
1779 -> 1773;
1779 -> 1771;
1780 -> 1773;
1780 -> 1771;
1781 -> 1771;
1782 -> 1771;
1783 -> 1780;
1783 -> 1782;
1784 -> 1781;
1784 -> 1782;
1785 -> 1781;
1785 -> 1782;
1786 -> 1782;
1787 -> 1785;
1787 -> 1782;
1788 -> 1785;
1788 -> 1782;
1789 -> 1785;
1789 -> 1782;
1790 -> 1782;
1791 -> 1783;
1791 -> 1790;
1791 -> 1782;
1792 -> 1782;
1793 -> 1784;
1793 -> 1792;
1793 -> 1782;
1794 -> 1783;
1794 -> 1785;
1794 -> 1782;
1795 -> 1784;
1795 -> 1785;
1795 -> 1782;
1796 -> 1785;
1796 -> 1782;
1797 -> 1782;
1798 -> 1782;
1799 -> 1796;
1799 -> 1798;
1800 -> 1797;
1800 -> 1798;
1801 -> 1798;
1802 -> 1800;
1802 -> 1798;
1803 -> 1800;
1803 -> 1798;
1804 -> 1798;
1805 -> 1799;
1805 -> 1804;
1805 -> 1798;
1806 -> 1799;
1806 -> 1800;
1806 -> 1798;
1807 -> 0;
1807 -> 1800;
1807 -> 1798;
1808 -> 1797;
1808 -> 1785;
1808 -> 1782;
1809 -> 1781;
1809 -> 1773;
1809 -> 1771;
1810 -> 1763;
1810 -> 1762;
1811 -> 1770;
1811 -> 1762;
1812 -> 1768;
1812 -> 1810;
1812 -> 1811;
1812 -> 1762;
1813 -> 1770;
1813 -> 1762;
1814 -> 1813;
1814 -> 1746;
1815 -> 1814;
1815 -> 1744;
1815 -> 1725;
1815 -> 1746;
1816 -> 1763;
1816 -> 1768;
1817 -> 1765;
1817 -> 1768;
1818 -> 1768;
1818 -> 1816;
1818 -> 1817;
1818 -> 1725;
1818 -> 1812;
1818 -> 1773;
1818 -> 1779;
1818 -> 1809;
1818 -> 1785;
1818 -> 1794;
1818 -> 1795;
1818 -> 1808;
1818 -> 1800;
1818 -> 1807;
1818 -> 1806;
1819 -> 1725;
1819 -> 1759;
1819 -> 1815;
1819 -> 1818;
1820 -> 1741;
1820 -> 1725;
1821 -> 1725;
1822 -> 1819;
1822 -> 1821;
1822 -> 1725;
1823 -> 1725;
1824 -> 1819;
1824 -> 1823;
1825 -> 1823;
1826 -> 1824;
1826 -> 1819;
1826 -> 1825;
1826 -> 1823;
1827 -> 1725;
1828 -> 1725;
1829 -> 1662;
1829 -> 1819;
1830 -> 1829;
1830 -> 1819;
1831 -> 1819;
1832 -> 1819;
1833 -> 1819;
1834 -> 1819;
1835 -> 1819;
1836 -> 1819;
1837 -> 1819;
1838 -> 1837;
1838 -> 1819;
1839 -> 1837;
1839 -> 1819;
1840 -> 1819;
1841 -> 1837;
1841 -> 1840;
1841 -> 1819;
1842 -> 1837;
1842 -> 1819;
1843 -> 1837;
1843 -> 1819;
1844 -> 1837;
1844 -> 1819;
1845 -> 1819;
1846 -> 1837;
1846 -> 1845;
1846 -> 1819;
1847 -> 1819;
1848 -> 1837;
1848 -> 1847;
1848 -> 1819;
1849 -> 1837;
1849 -> 1819;
1850 -> 1837;
1850 -> 1819;
1851 -> 1819;
1852 -> 1837;
1852 -> 1851;
1852 -> 1819;
1853 -> 1837;
1854 -> 1837;
1855 -> 1837;
1856 -> 1837;
1857 -> 1837;
1858 -> 1837;
1859 -> 1837;
1860 -> 1837;
1861 -> 1837;
1862 -> 1837;
1863 -> 1837;
1864 -> 1830;
1864 -> 1819;
1865 -> 1819;
1866 -> 1837;
1866 -> 1865;
1866 -> 1819;
1867 -> 1819;
1868 -> 1837;
1868 -> 1867;
1869 -> 1867;
1870 -> 1868;
1870 -> 1837;
1870 -> 1869;
1870 -> 1867;
1871 -> 1819;
1872 -> 1819;
1873 -> 1662;
1873 -> 1837;
1874 -> 1873;
1874 -> 1837;
1875 -> 1837;
1876 -> 1837;
1877 -> 1837;
1878 -> 1837;
1879 -> 1837;
1880 -> 1837;
1881 -> 1880;
1882 -> 1881;
1883 -> 1837;
1883 -> 1880;
1884 -> 1882;
1884 -> 1883;
1884 -> 1880;
1885 -> 1884;
1886 -> 1884;
1887 -> 1884;
1888 -> 1884;
1889 -> 1884;
1890 -> 1884;
1891 -> 1884;
1892 -> 1884;
1893 -> 1884;
1894 -> 1884;
1895 -> 1884;
1896 -> 1874;
1896 -> 1837;
1897 -> 1837;
1898 -> 1884;
1898 -> 1897;
1898 -> 1837;
1899 -> 1837;
1900 -> 1884;
1900 -> 1899;
1901 -> 1899;
1902 -> 1900;
1902 -> 1884;
1902 -> 1901;
1902 -> 1899;
1903 -> 1837;
1904 -> 1837;
1905 -> 1662;
1905 -> 1884;
1906 -> 1905;
1906 -> 1884;
1907 -> 1884;
1908 -> 1884;
1909 -> 1884;
1910 -> 1884;
1911 -> 1884;
1912 -> 1906;
1912 -> 1884;
1913 -> 1884;
1914 -> 1884;
1915 -> 1884;
1915 -> 1914;
1916 -> 1914;
1917 -> 1915;
1917 -> 1884;
1917 -> 1916;
1917 -> 1914;
1918 -> 1884;
1919 -> 1884;
1920 -> 1660;
1921 -> 1660;
1922 -> 1662;
1922 -> 1921;
1923 -> 1922;
1923 -> 1884;
1923 -> 1921;
1924 -> 1923;
1924 -> 1660;
1925 -> 1660;
1926 -> 1660;
1927 -> 1924;
1927 -> 1926;
1928 -> 1926;
1929 -> 1927;
1929 -> 1928;
1930 -> 1928;
1931 -> 1929;
1931 -> 1924;
1931 -> 1930;
1931 -> 1928;
1932 -> 1926;
1933 -> 1927;
1933 -> 1924;
1933 -> 1926;
1934 -> 1661;
1934 -> 1660;
1935 -> 1664;
1935 -> 1924;
1935 -> 1934;
1936 -> 1935;
1936 -> 1924;
1936 -> 1934;
1937 -> 1935;
1937 -> 1924;
1937 -> 1934;
1938 -> 1663;
1938 -> 1934;
1938 -> 1924;
1939 -> 1934;
1940 -> 1938;
1940 -> 1939;
1941 -> 1920;
1941 -> 1934;
1942 -> 1663;
1942 -> 1934;
1942 -> 1940;
1943 -> 1934;
1944 -> 1942;
1944 -> 1943;
1945 -> 1935;
1945 -> 1924;
1945 -> 1934;
1946 -> 1945;
1946 -> 1942;
1946 -> 1934;
1947 -> 1934;
1948 -> 1920;
1948 -> 1941;
1948 -> 1947;
1948 -> 1934;
1949 -> 1671;
1949 -> 1934;
1950 -> 1934;
1951 -> 1949;
1951 -> 1950;
1952 -> 1935;
1952 -> 1924;
1952 -> 1950;
1953 -> 1950;
1954 -> 1952;
1954 -> 1942;
1954 -> 1953;
1954 -> 1950;
1955 -> 1951;
1955 -> 1952;
1955 -> 1950;
1956 -> 1934;
1957 -> 1664;
1957 -> 1942;
1957 -> 1955;
1957 -> 1934;
1958 -> 1957;
1958 -> 1942;
1958 -> 1934;
1959 -> 1957;
1959 -> 1942;
1959 -> 1934;
1960 -> 1663;
1960 -> 1934;
1960 -> 1942;
1960 -> 1955;
1961 -> 1960;
1961 -> 1943;
1962 -> 1957;
1962 -> 1942;
1962 -> 1934;
1963 -> 1663;
1963 -> 1962;
1963 -> 1960;
1964 -> 1962;
1965 -> 1963;
1965 -> 1964;
1966 -> 1957;
1966 -> 1963;
1966 -> 1953;
1966 -> 1950;
1967 -> 1963;
1967 -> 1934;
1968 -> 1963;
1968 -> 1934;
1969 -> 1963;
1969 -> 1943;
1970 -> 1963;
1971 -> 1963;
1971 -> 1953;
1971 -> 1950;
1972 -> 1920;
1972 -> 1941;
1972 -> 1660;
1973 -> 1660;
1974 -> 1884;
1974 -> 1973;
1974 -> 1660;
1975 -> 1884;
1975 -> 1963;
1975 -> 1974;
1976 -> 1671;
1976 -> 1975;
1977 -> 1975;
1978 -> 1976;
1978 -> 1977;
1979 -> 1977;
1980 -> 1975;
1981 -> 1978;
1982 -> 1654;
1983 -> 966;
1983 -> 1963;
1983 -> 965;
1984 -> 966;
1984 -> 1963;
1984 -> 1983;
1985 -> 967;
1985 -> 1963;
1985 -> 1984;
1986 -> 1201;
1986 -> 1984;
1987 -> 1177;
1987 -> 1984;
1988 -> 1984;
1989 -> 1986;
1989 -> 1988;
1990 -> 1987;
1990 -> 1988;
1991 -> 1987;
1991 -> 1988;
1992 -> 1989;
1992 -> 1988;
1993 -> 1991;
1993 -> 1963;
1993 -> 1978;
1993 -> 1992;
1994 -> 1993;
1994 -> 1963;
1994 -> 1992;
1995 -> 1990;
1995 -> 1992;
1995 -> 1963;
1995 -> 1978;
1996 -> 1992;
1997 -> 1995;
1997 -> 1996;
1997 -> 1992;
1998 -> 1990;
1998 -> 1992;
1998 -> 1995;
1998 -> 1997;
1999 -> 1993;
1999 -> 1963;
1999 -> 1997;
2000 -> 1998;
2000 -> 1999;
2000 -> 1997;
2001 -> 2000;
2001 -> 1992;
2002 -> 1984;
2003 -> 1200;
2003 -> 1984;
2004 -> 1097;
2004 -> 1984;
2005 -> 1177;
2005 -> 1984;
2006 -> 968;
2006 -> 2000;
2006 -> 1984;
2007 -> 1537;
2007 -> 1984;
2008 -> 1431;
2008 -> 1984;
2009 -> 2007;
2009 -> 1984;
2010 -> 1651;
2010 -> 1984;
2011 -> 1984;
2012 -> 1431;
2012 -> 2011;
2013 -> 2011;
2014 -> 2012;
2014 -> 2013;
2015 -> 2014;
2015 -> 2006;
2015 -> 2013;
2016 -> 2015;
2016 -> 2011;
2017 -> 2011;
2018 -> 1984;
2019 -> 2016;
2019 -> 2018;
2020 -> 2018;
2021 -> 2019;
2021 -> 2020;
2022 -> 2020;
2023 -> 2021;
2023 -> 2016;
2023 -> 2022;
2023 -> 2020;
2024 -> 2018;
2025 -> 2019;
2025 -> 2016;
2025 -> 2018;
2026 -> 1984;
2027 -> 1431;
2027 -> 2026;
2028 -> 2026;
2029 -> 2027;
2029 -> 2028;
2030 -> 2029;
2030 -> 2016;
2030 -> 2028;
2031 -> 2026;
2032 -> 1984;
2033 -> 2030;
2033 -> 2032;
2034 -> 2032;
2035 -> 2033;
2035 -> 2034;
2036 -> 2034;
2037 -> 2035;
2037 -> 2030;
2037 -> 2036;
2037 -> 2034;
2038 -> 2032;
2039 -> 2033;
2039 -> 2030;
2039 -> 2032;
2040 -> 967;
2040 -> 2003;
2040 -> 2004;
2040 -> 2005;
2040 -> 2006;
2040 -> 2009;
2040 -> 2010;
2040 -> 2025;
2040 -> 2039;
2040 -> 2030;
2040 -> 2016;
2040 -> 1097;
2040 -> 2000;
2040 -> 1651;
2040 -> 1200;
2040 -> 1984;
2041 -> 966;
2041 -> 2040;
2041 -> 1984;
2042 -> 967;
2042 -> 1984;
2043 -> 967;
2043 -> 966;
2043 -> 1984;
2044 -> 1431;
2044 -> 966;
2044 -> 1984;
2045 -> 965;
2046 -> 968;
2046 -> 2040;
2046 -> 2043;
2046 -> 2044;
2046 -> 965;
2047 -> 969;
2047 -> 2046;
2047 -> 965;
2048 -> 2045;
2048 -> 961;
2049 -> 963;
2049 -> 2047;
2049 -> 2048;
2049 -> 961;
2050 -> 963;
2050 -> 2047;
2050 -> 961;
2051 -> 962;
2051 -> 2050;
2051 -> 961;
2052 -> 959;
2053 -> 958;
2053 -> 2050;
2053 -> 959;
2054 -> 958;
2054 -> 2050;
2054 -> 957;
2055 -> 2054;
2055 -> 955;
2056 -> 956;
2056 -> 2050;
2056 -> 955;
2057 -> 956;
2057 -> 2056;
2057 -> 955;
2058 -> 2057;
2058 -> 953;
2059 -> 2058;
2059 -> 951;
2060 -> 951;
2061 -> 2059;
2061 -> 2060;
2062 -> 951;
2063 -> 2061;
2063 -> 1;
2064 -> 1;
2065 -> 2063;
2065 -> 2064;
2066 -> 2064;
2067 -> 2065;
2067 -> 2061;
2067 -> 2066;
2067 -> 2064;
2068 -> 2067;
2069 -> 2065;
2069 -> 2067;
2070 -> 2067;
2071 -> 2065;
2071 -> 2070;
2072 -> 2070;
2073 -> 2071;
2073 -> 2061;
2073 -> 2072;
2074 -> 2073;
2074 -> 2061;
2074 -> 2072;
2075 -> 2074;
2075 -> 2070;
2076 -> 2075;
2076 -> 2067;
2077 -> 2067;
2078 -> 2076;
2078 -> 2077;
2079 -> 2077;
2080 -> 2078;
2080 -> 2079;
2081 -> 2080;
2081 -> 2077;
2082 -> 2078;
2082 -> 2077;
2083 -> 2077;
2085 -> 2084;
2087 -> 2086;
2088 -> 2068;
2088 -> 2067;
2089 -> 2067;
2090 -> 2067;
2091 -> 2069;
2091 -> 2090;
2092 -> 2069;
2092 -> 2090;
2093 -> 2081;
2093 -> 2090;
2094 -> 2088;
2094 -> 2090;
2095 -> 2089;
2095 -> 2090;
2096 -> 2090;
2097 -> 2095;
2097 -> 2090;
2098 -> 2095;
2098 -> 2090;
2099 -> 2095;
2099 -> 2090;
2100 -> 2095;
2100 -> 2090;
2101 -> 2095;
2101 -> 2090;
2102 -> 2095;
2102 -> 2090;
2105 -> 2104;
2105 -> 2103;
2107 -> 2106;
2107 -> 2103;
2108 -> 2103;
2111 -> 2110;
2111 -> 2109;
2113 -> 2112;
2113 -> 2109;
2114 -> 2109;
2116 -> 0;
2116 -> 2115;
2118 -> 0;
2118 -> 2117;
2119 -> 2118;
2119 -> 2115;
2120 -> 2115;
2122 -> 0;
2122 -> 2121;
2123 -> 0;
2123 -> 2121;
2124 -> 2121;
2125 -> 2114;
2125 -> 2095;
2125 -> 2090;
2126 -> 2090;
2127 -> 2093;
2127 -> 2126;
2127 -> 2090;
2128 -> 2091;
2128 -> 2095;
2128 -> 2090;
2129 -> 2092;
2129 -> 2095;
2129 -> 2090;
2130 -> 2093;
2130 -> 2095;
2130 -> 2090;
2131 -> 2093;
2131 -> 2081;
2131 -> 2090;
2132 -> 2131;
2132 -> 2081;
2133 -> 2094;
2133 -> 2132;
2133 -> 2068;
2133 -> 2081;
2133 -> 2131;
2134 -> 2068;
2134 -> 2133;
2134 -> 2067;
2135 -> 2068;
2135 -> 2133;
2135 -> 2067;
2136 -> 2065;
2136 -> 2135;
2136 -> 2067;
2137 -> 2089;
2137 -> 2067;
2138 -> 2067;
2139 -> 2136;
2139 -> 2137;
2139 -> 2138;
2139 -> 2095;
2139 -> 2128;
2139 -> 2129;
2139 -> 2130;
2139 -> 2100;
2139 -> 2101;
2139 -> 2102;
2139 -> 2125;
2139 -> 2135;
2139 -> 2111;
2139 -> 2113;
2139 -> 2109;
2139 -> 2067;
2140 -> 2065;
2140 -> 2139;
2140 -> 2064;
2141 -> 1;
2142 -> 1;
2143 -> 2141;
2143 -> 2142;
2144 -> 2140;
2144 -> 2142;
2145 -> 2142;
2146 -> 2145;
2146 -> 2142;
2147 -> 2142;
2148 -> 2144;
2148 -> 2147;
2149 -> 2147;
2150 -> 2148;
2150 -> 2139;
2150 -> 2149;
2150 -> 2147;
2151 -> 2148;
2151 -> 2139;
2151 -> 2150;
2152 -> 2150;
2153 -> 2148;
2153 -> 2152;
2154 -> 2152;
2155 -> 2153;
2155 -> 2139;
2155 -> 2154;
2155 -> 2152;
2156 -> 2155;
2157 -> 2153;
2157 -> 2139;
2157 -> 2155;
2158 -> 2156;
2158 -> 2155;
2159 -> 2155;
2160 -> 2158;
2160 -> 2159;
2161 -> 2153;
2161 -> 2159;
2162 -> 2161;
2162 -> 2139;
2162 -> 2159;
2163 -> 2159;
2164 -> 2162;
2164 -> 2163;
2165 -> 2162;
2165 -> 2163;
2166 -> 2164;
2166 -> 2163;
2167 -> 0;
2167 -> 2163;
2168 -> 2166;
2168 -> 2165;
2168 -> 2163;
2169 -> 2161;
2169 -> 2168;
2169 -> 2159;
2170 -> 2169;
2171 -> 2160;
2171 -> 2169;
2172 -> 2169;
2173 -> 2170;
2173 -> 2172;
2174 -> 2171;
2174 -> 2172;
2175 -> 2161;
2175 -> 2172;
2176 -> 2173;
2176 -> 2168;
2176 -> 2172;
2177 -> 2175;
2177 -> 2176;
2178 -> 2173;
2178 -> 2176;
2179 -> 2174;
2179 -> 2176;
2180 -> 2176;
2181 -> 2176;
2182 -> 2177;
2182 -> 2181;
2183 -> 2178;
2183 -> 2181;
2184 -> 2179;
2184 -> 2181;
2185 -> 2180;
2185 -> 2181;
2186 -> 2180;
2186 -> 2181;
2188 -> 2187;
2190 -> 2189;
2192 -> 2191;
2194 -> 2193;
2196 -> 2195;
2198 -> 2197;
2199 -> 0;
2201 -> 2188;
2201 -> 2200;
2202 -> 2190;
2202 -> 2200;
2203 -> 2192;
2203 -> 2200;
2204 -> 2194;
2204 -> 2200;
2205 -> 2196;
2205 -> 2200;
2206 -> 2198;
2206 -> 2200;
2207 -> 2199;
2207 -> 2200;
2208 -> 2200;
2209 -> 2208;
2209 -> 2200;
2210 -> 2208;
2210 -> 2200;
2211 -> 2208;
2211 -> 2200;
2212 -> 2208;
2212 -> 2200;
2213 -> 2208;
2213 -> 2200;
2214 -> 2208;
2214 -> 2200;
2215 -> 2208;
2215 -> 2200;
2216 -> 2202;
2216 -> 2200;
2217 -> 2200;
2218 -> 2201;
2218 -> 2208;
2218 -> 2200;
2219 -> 2202;
2219 -> 2208;
2219 -> 2200;
2220 -> 2203;
2220 -> 2208;
2220 -> 2200;
2221 -> 2204;
2221 -> 2208;
2221 -> 2200;
2222 -> 2205;
2222 -> 2208;
2222 -> 2200;
2223 -> 2206;
2223 -> 2208;
2223 -> 2200;
2224 -> 2207;
2224 -> 2208;
2224 -> 2200;
2225 -> 2208;
2225 -> 2224;
2225 -> 0;
2225 -> 2200;
2226 -> 2200;
2227 -> 2206;
2227 -> 2200;
2228 -> 2200;
2230 -> 2229;
2232 -> 2231;
2234 -> 2233;
2236 -> 2235;
2238 -> 2237;
2240 -> 2239;
2241 -> 0;
2243 -> 2230;
2243 -> 2242;
2244 -> 2232;
2244 -> 2242;
2245 -> 2234;
2245 -> 2242;
2246 -> 2236;
2246 -> 2242;
2247 -> 2238;
2247 -> 2242;
2248 -> 2240;
2248 -> 2242;
2249 -> 2241;
2249 -> 2242;
2250 -> 2242;
2251 -> 2250;
2251 -> 2242;
2252 -> 2250;
2252 -> 2242;
2253 -> 2250;
2253 -> 2242;
2254 -> 2250;
2254 -> 2242;
2255 -> 2250;
2255 -> 2242;
2256 -> 2250;
2256 -> 2242;
2257 -> 2250;
2257 -> 2242;
2258 -> 2244;
2258 -> 2243;
2258 -> 2242;
2259 -> 2242;
2260 -> 2243;
2260 -> 2250;
2260 -> 2242;
2261 -> 2244;
2261 -> 2250;
2261 -> 2242;
2262 -> 2245;
2262 -> 2250;
2262 -> 2242;
2263 -> 2246;
2263 -> 2250;
2263 -> 2242;
2264 -> 2247;
2264 -> 2250;
2264 -> 2242;
2265 -> 2248;
2265 -> 2250;
2265 -> 2242;
2266 -> 2249;
2266 -> 2250;
2266 -> 2242;
2267 -> 2250;
2267 -> 2266;
2267 -> 0;
2267 -> 2242;
2268 -> 2242;
2269 -> 2248;
2269 -> 2242;
2270 -> 2242;
2272 -> 2271;
2274 -> 2273;
2276 -> 2275;
2278 -> 2277;
2280 -> 2279;
2282 -> 2281;
2283 -> 0;
2285 -> 2272;
2285 -> 2284;
2286 -> 2274;
2286 -> 2284;
2287 -> 2276;
2287 -> 2284;
2288 -> 2278;
2288 -> 2284;
2289 -> 2280;
2289 -> 2284;
2290 -> 2282;
2290 -> 2284;
2291 -> 2283;
2291 -> 2284;
2292 -> 2284;
2293 -> 2292;
2293 -> 2284;
2294 -> 2292;
2294 -> 2284;
2295 -> 2292;
2295 -> 2284;
2296 -> 2292;
2296 -> 2284;
2297 -> 2292;
2297 -> 2284;
2298 -> 2292;
2298 -> 2284;
2299 -> 2292;
2299 -> 2284;
2300 -> 2286;
2300 -> 2285;
2300 -> 2284;
2301 -> 2284;
2302 -> 2285;
2302 -> 2292;
2302 -> 2284;
2303 -> 2286;
2303 -> 2292;
2303 -> 2284;
2304 -> 2287;
2304 -> 2292;
2304 -> 2284;
2305 -> 2288;
2305 -> 2292;
2305 -> 2284;
2306 -> 2289;
2306 -> 2292;
2306 -> 2284;
2307 -> 2290;
2307 -> 2292;
2307 -> 2284;
2308 -> 2291;
2308 -> 2292;
2308 -> 2284;
2309 -> 2292;
2309 -> 2308;
2309 -> 0;
2309 -> 2284;
2310 -> 2284;
2311 -> 2290;
2311 -> 2284;
2312 -> 2284;
2314 -> 2313;
2316 -> 2315;
2318 -> 2317;
2320 -> 2319;
2322 -> 2321;
2324 -> 2323;
2325 -> 0;
2327 -> 2314;
2327 -> 2326;
2328 -> 2316;
2328 -> 2326;
2329 -> 2318;
2329 -> 2326;
2330 -> 2320;
2330 -> 2326;
2331 -> 2322;
2331 -> 2326;
2332 -> 2324;
2332 -> 2326;
2333 -> 2325;
2333 -> 2326;
2334 -> 2326;
2335 -> 2334;
2335 -> 2326;
2336 -> 2334;
2336 -> 2326;
2337 -> 2334;
2337 -> 2326;
2338 -> 2334;
2338 -> 2326;
2339 -> 2334;
2339 -> 2326;
2340 -> 2334;
2340 -> 2326;
2341 -> 2334;
2341 -> 2326;
2342 -> 2328;
2342 -> 2327;
2342 -> 2326;
2343 -> 2326;
2344 -> 2327;
2344 -> 2334;
2344 -> 2326;
2345 -> 2328;
2345 -> 2334;
2345 -> 2326;
2346 -> 2329;
2346 -> 2334;
2346 -> 2326;
2347 -> 2330;
2347 -> 2334;
2347 -> 2326;
2348 -> 2331;
2348 -> 2334;
2348 -> 2326;
2349 -> 2332;
2349 -> 2334;
2349 -> 2326;
2350 -> 2333;
2350 -> 2334;
2350 -> 2326;
2351 -> 2334;
2351 -> 2350;
2351 -> 0;
2351 -> 2326;
2352 -> 2326;
2353 -> 2332;
2353 -> 2326;
2354 -> 2334;
2354 -> 2350;
2354 -> 0;
2354 -> 2353;
2355 -> 2354;
2355 -> 2334;
2355 -> 2353;
2356 -> 2326;
2358 -> 2357;
2360 -> 2359;
2362 -> 2361;
2364 -> 2363;
2366 -> 2365;
2368 -> 2367;
2369 -> 0;
2371 -> 2358;
2371 -> 2370;
2372 -> 2360;
2372 -> 2370;
2373 -> 2362;
2373 -> 2370;
2374 -> 2364;
2374 -> 2370;
2375 -> 2366;
2375 -> 2370;
2376 -> 2368;
2376 -> 2370;
2377 -> 2369;
2377 -> 2370;
2378 -> 2370;
2379 -> 2378;
2379 -> 2370;
2380 -> 2378;
2380 -> 2370;
2381 -> 2378;
2381 -> 2370;
2382 -> 2378;
2382 -> 2370;
2383 -> 2378;
2383 -> 2370;
2384 -> 2378;
2384 -> 2370;
2385 -> 2378;
2385 -> 2370;
2386 -> 2372;
2386 -> 2371;
2386 -> 2370;
2387 -> 2370;
2388 -> 2371;
2388 -> 2378;
2388 -> 2370;
2389 -> 2372;
2389 -> 2378;
2389 -> 2370;
2390 -> 2373;
2390 -> 2378;
2390 -> 2370;
2391 -> 2374;
2391 -> 2378;
2391 -> 2370;
2392 -> 2375;
2392 -> 2378;
2392 -> 2370;
2393 -> 2376;
2393 -> 2378;
2393 -> 2370;
2394 -> 2377;
2394 -> 2378;
2394 -> 2370;
2395 -> 2378;
2395 -> 2394;
2395 -> 0;
2395 -> 2370;
2396 -> 2370;
2397 -> 2376;
2397 -> 2370;
2398 -> 2370;
2400 -> 2399;
2402 -> 2401;
2404 -> 2403;
2406 -> 2405;
2408 -> 2407;
2410 -> 2409;
2411 -> 0;
2413 -> 2400;
2413 -> 2412;
2414 -> 2402;
2414 -> 2412;
2415 -> 2404;
2415 -> 2412;
2416 -> 2406;
2416 -> 2412;
2417 -> 2408;
2417 -> 2412;
2418 -> 2410;
2418 -> 2412;
2419 -> 2411;
2419 -> 2412;
2420 -> 2412;
2421 -> 2420;
2421 -> 2412;
2422 -> 2420;
2422 -> 2412;
2423 -> 2420;
2423 -> 2412;
2424 -> 2420;
2424 -> 2412;
2425 -> 2420;
2425 -> 2412;
2426 -> 2420;
2426 -> 2412;
2427 -> 2420;
2427 -> 2412;
2428 -> 2414;
2428 -> 2413;
2428 -> 2412;
2429 -> 2412;
2430 -> 2413;
2430 -> 2420;
2430 -> 2412;
2431 -> 2414;
2431 -> 2420;
2431 -> 2412;
2432 -> 2415;
2432 -> 2420;
2432 -> 2412;
2433 -> 2416;
2433 -> 2420;
2433 -> 2412;
2434 -> 2417;
2434 -> 2420;
2434 -> 2412;
2435 -> 2418;
2435 -> 2420;
2435 -> 2412;
2436 -> 2419;
2436 -> 2420;
2436 -> 2412;
2437 -> 2420;
2437 -> 2436;
2437 -> 0;
2437 -> 2412;
2438 -> 2412;
2439 -> 2418;
2439 -> 2412;
2440 -> 2412;
2442 -> 2441;
2444 -> 2443;
2446 -> 2445;
2448 -> 2447;
2450 -> 2449;
2452 -> 2451;
2453 -> 0;
2455 -> 2442;
2455 -> 2454;
2456 -> 2444;
2456 -> 2454;
2457 -> 2446;
2457 -> 2454;
2458 -> 2448;
2458 -> 2454;
2459 -> 2450;
2459 -> 2454;
2460 -> 2452;
2460 -> 2454;
2461 -> 2453;
2461 -> 2454;
2462 -> 2454;
2463 -> 2462;
2463 -> 2454;
2464 -> 2462;
2464 -> 2454;
2465 -> 2462;
2465 -> 2454;
2466 -> 2462;
2466 -> 2454;
2467 -> 2462;
2467 -> 2454;
2468 -> 2462;
2468 -> 2454;
2469 -> 2462;
2469 -> 2454;
2470 -> 2456;
2470 -> 2454;
2471 -> 2454;
2472 -> 2455;
2472 -> 2462;
2472 -> 2454;
2473 -> 2456;
2473 -> 2462;
2473 -> 2454;
2474 -> 2457;
2474 -> 2462;
2474 -> 2454;
2475 -> 2458;
2475 -> 2462;
2475 -> 2454;
2476 -> 2459;
2476 -> 2462;
2476 -> 2454;
2477 -> 2460;
2477 -> 2462;
2477 -> 2454;
2478 -> 2461;
2478 -> 2462;
2478 -> 2454;
2479 -> 2462;
2479 -> 2478;
2479 -> 0;
2479 -> 2454;
2480 -> 2454;
2481 -> 2460;
2481 -> 2454;
2482 -> 2454;
2484 -> 2483;
2486 -> 2485;
2488 -> 2487;
2490 -> 2489;
2492 -> 2491;
2494 -> 2493;
2495 -> 0;
2496 -> 2495;
2498 -> 2484;
2498 -> 2497;
2499 -> 2486;
2499 -> 2497;
2500 -> 2488;
2500 -> 2497;
2501 -> 2490;
2501 -> 2497;
2502 -> 2492;
2502 -> 2497;
2503 -> 2494;
2503 -> 2497;
2504 -> 2496;
2504 -> 2497;
2505 -> 2497;
2506 -> 2505;
2506 -> 2497;
2507 -> 2505;
2507 -> 2497;
2508 -> 2505;
2508 -> 2497;
2509 -> 2505;
2509 -> 2497;
2510 -> 2505;
2510 -> 2497;
2511 -> 2505;
2511 -> 2497;
2512 -> 2505;
2512 -> 2497;
2513 -> 2499;
2513 -> 2497;
2514 -> 2497;
2515 -> 2498;
2515 -> 2505;
2515 -> 2497;
2516 -> 2499;
2516 -> 2505;
2516 -> 2497;
2517 -> 2500;
2517 -> 2505;
2517 -> 2497;
2518 -> 2501;
2518 -> 2505;
2518 -> 2497;
2519 -> 2502;
2519 -> 2505;
2519 -> 2497;
2520 -> 2503;
2520 -> 2505;
2520 -> 2497;
2521 -> 2504;
2521 -> 2505;
2521 -> 2497;
2522 -> 2505;
2522 -> 2521;
2522 -> 0;
2522 -> 2497;
2523 -> 2497;
2524 -> 2503;
2524 -> 2497;
2525 -> 2505;
2525 -> 2521;
2525 -> 0;
2525 -> 2524;
2526 -> 2525;
2526 -> 2505;
2526 -> 2524;
2527 -> 2497;
2529 -> 2528;
2531 -> 2530;
2533 -> 2532;
2535 -> 2534;
2537 -> 2536;
2539 -> 2538;
2540 -> 0;
2542 -> 2529;
2542 -> 2541;
2543 -> 2531;
2543 -> 2541;
2544 -> 2533;
2544 -> 2541;
2545 -> 2535;
2545 -> 2541;
2546 -> 2537;
2546 -> 2541;
2547 -> 2539;
2547 -> 2541;
2548 -> 2540;
2548 -> 2541;
2549 -> 2541;
2550 -> 2549;
2550 -> 2541;
2551 -> 2549;
2551 -> 2541;
2552 -> 2549;
2552 -> 2541;
2553 -> 2549;
2553 -> 2541;
2554 -> 2549;
2554 -> 2541;
2555 -> 2549;
2555 -> 2541;
2556 -> 2549;
2556 -> 2541;
2557 -> 2543;
2557 -> 2541;
2558 -> 2541;
2559 -> 2542;
2559 -> 2549;
2559 -> 2541;
2560 -> 2543;
2560 -> 2549;
2560 -> 2541;
2561 -> 2544;
2561 -> 2549;
2561 -> 2541;
2562 -> 2545;
2562 -> 2549;
2562 -> 2541;
2563 -> 2546;
2563 -> 2549;
2563 -> 2541;
2564 -> 2547;
2564 -> 2549;
2564 -> 2541;
2565 -> 2548;
2565 -> 2549;
2565 -> 2541;
2566 -> 2549;
2566 -> 2565;
2566 -> 0;
2566 -> 2541;
2567 -> 2541;
2568 -> 2547;
2568 -> 2541;
2569 -> 2549;
2569 -> 2565;
2569 -> 0;
2569 -> 2568;
2570 -> 2569;
2570 -> 2549;
2570 -> 2568;
2571 -> 2541;
2573 -> 2572;
2575 -> 2574;
2577 -> 2576;
2579 -> 2578;
2581 -> 2580;
2583 -> 2582;
2584 -> 0;
2586 -> 2573;
2586 -> 2585;
2587 -> 2575;
2587 -> 2585;
2588 -> 2577;
2588 -> 2585;
2589 -> 2579;
2589 -> 2585;
2590 -> 2581;
2590 -> 2585;
2591 -> 2583;
2591 -> 2585;
2592 -> 2584;
2592 -> 2585;
2593 -> 2585;
2594 -> 2593;
2594 -> 2585;
2595 -> 2593;
2595 -> 2585;
2596 -> 2593;
2596 -> 2585;
2597 -> 2593;
2597 -> 2585;
2598 -> 2593;
2598 -> 2585;
2599 -> 2593;
2599 -> 2585;
2600 -> 2593;
2600 -> 2585;
2601 -> 2587;
2601 -> 2585;
2602 -> 2585;
2603 -> 2586;
2603 -> 2593;
2603 -> 2585;
2604 -> 2587;
2604 -> 2593;
2604 -> 2585;
2605 -> 2588;
2605 -> 2593;
2605 -> 2585;
2606 -> 2589;
2606 -> 2593;
2606 -> 2585;
2607 -> 2590;
2607 -> 2593;
2607 -> 2585;
2608 -> 2591;
2608 -> 2593;
2608 -> 2585;
2609 -> 2592;
2609 -> 2593;
2609 -> 2585;
2610 -> 2593;
2610 -> 2609;
2610 -> 0;
2610 -> 2585;
2611 -> 2585;
2612 -> 2591;
2612 -> 2585;
2613 -> 2585;
2615 -> 2614;
2617 -> 2616;
2619 -> 2618;
2621 -> 2620;
2623 -> 2622;
2625 -> 2624;
2626 -> 0;
2627 -> 2626;
2627 -> 0;
2628 -> 2627;
2630 -> 2615;
2630 -> 2629;
2631 -> 2617;
2631 -> 2629;
2632 -> 2619;
2632 -> 2629;
2633 -> 2621;
2633 -> 2629;
2634 -> 2623;
2634 -> 2629;
2635 -> 2625;
2635 -> 2629;
2636 -> 2628;
2636 -> 2629;
2637 -> 2629;
2638 -> 2637;
2638 -> 2629;
2639 -> 2637;
2639 -> 2629;
2640 -> 2637;
2640 -> 2629;
2641 -> 2637;
2641 -> 2629;
2642 -> 2637;
2642 -> 2629;
2643 -> 2637;
2643 -> 2629;
2644 -> 2637;
2644 -> 2629;
2645 -> 2631;
2645 -> 2629;
2646 -> 2629;
2647 -> 2630;
2647 -> 2637;
2647 -> 2629;
2648 -> 2631;
2648 -> 2637;
2648 -> 2629;
2649 -> 2632;
2649 -> 2637;
2649 -> 2629;
2650 -> 2633;
2650 -> 2637;
2650 -> 2629;
2651 -> 2634;
2651 -> 2637;
2651 -> 2629;
2652 -> 2635;
2652 -> 2637;
2652 -> 2629;
2653 -> 2636;
2653 -> 2637;
2653 -> 2629;
2654 -> 2637;
2654 -> 2653;
2654 -> 0;
2654 -> 2629;
2655 -> 2629;
2656 -> 2635;
2656 -> 2629;
2657 -> 2629;
2659 -> 2658;
2661 -> 2660;
2663 -> 2662;
2665 -> 2664;
2667 -> 2666;
2669 -> 2668;
2670 -> 0;
2671 -> 2670;
2671 -> 0;
2672 -> 2671;
2674 -> 2659;
2674 -> 2673;
2675 -> 2661;
2675 -> 2673;
2676 -> 2663;
2676 -> 2673;
2677 -> 2665;
2677 -> 2673;
2678 -> 2667;
2678 -> 2673;
2679 -> 2669;
2679 -> 2673;
2680 -> 2672;
2680 -> 2673;
2681 -> 2673;
2682 -> 2681;
2682 -> 2673;
2683 -> 2681;
2683 -> 2673;
2684 -> 2681;
2684 -> 2673;
2685 -> 2681;
2685 -> 2673;
2686 -> 2681;
2686 -> 2673;
2687 -> 2681;
2687 -> 2673;
2688 -> 2681;
2688 -> 2673;
2689 -> 2675;
2689 -> 2673;
2690 -> 2673;
2691 -> 2674;
2691 -> 2681;
2691 -> 2673;
2692 -> 2675;
2692 -> 2681;
2692 -> 2673;
2693 -> 2676;
2693 -> 2681;
2693 -> 2673;
2694 -> 2677;
2694 -> 2681;
2694 -> 2673;
2695 -> 2678;
2695 -> 2681;
2695 -> 2673;
2696 -> 2679;
2696 -> 2681;
2696 -> 2673;
2697 -> 2680;
2697 -> 2681;
2697 -> 2673;
2698 -> 2681;
2698 -> 2697;
2698 -> 0;
2698 -> 2673;
2699 -> 2673;
2700 -> 2679;
2700 -> 2673;
2701 -> 2681;
2701 -> 2697;
2701 -> 0;
2701 -> 2700;
2702 -> 2701;
2702 -> 2681;
2702 -> 2700;
2703 -> 2673;
2705 -> 2704;
2707 -> 2706;
2709 -> 2708;
2711 -> 2710;
2713 -> 2712;
2715 -> 2714;
2716 -> 0;
2717 -> 2716;
2717 -> 0;
2718 -> 2717;
2720 -> 2705;
2720 -> 2719;
2721 -> 2707;
2721 -> 2719;
2722 -> 2709;
2722 -> 2719;
2723 -> 2711;
2723 -> 2719;
2724 -> 2713;
2724 -> 2719;
2725 -> 2715;
2725 -> 2719;
2726 -> 2718;
2726 -> 2719;
2727 -> 2719;
2728 -> 2727;
2728 -> 2719;
2729 -> 2727;
2729 -> 2719;
2730 -> 2727;
2730 -> 2719;
2731 -> 2727;
2731 -> 2719;
2732 -> 2727;
2732 -> 2719;
2733 -> 2727;
2733 -> 2719;
2734 -> 2727;
2734 -> 2719;
2735 -> 2721;
2735 -> 2719;
2736 -> 2719;
2737 -> 2720;
2737 -> 2727;
2737 -> 2719;
2738 -> 2721;
2738 -> 2727;
2738 -> 2719;
2739 -> 2722;
2739 -> 2727;
2739 -> 2719;
2740 -> 2723;
2740 -> 2727;
2740 -> 2719;
2741 -> 2724;
2741 -> 2727;
2741 -> 2719;
2742 -> 2725;
2742 -> 2727;
2742 -> 2719;
2743 -> 2726;
2743 -> 2727;
2743 -> 2719;
2744 -> 2727;
2744 -> 2743;
2744 -> 0;
2744 -> 2719;
2745 -> 2719;
2746 -> 2725;
2746 -> 2719;
2747 -> 2727;
2747 -> 2743;
2747 -> 0;
2747 -> 2746;
2748 -> 2747;
2748 -> 2727;
2748 -> 2746;
2749 -> 2719;
2751 -> 2750;
2753 -> 2752;
2755 -> 2754;
2757 -> 2756;
2759 -> 2758;
2761 -> 2760;
2762 -> 0;
2763 -> 2762;
2763 -> 0;
2764 -> 2763;
2766 -> 2751;
2766 -> 2765;
2767 -> 2753;
2767 -> 2765;
2768 -> 2755;
2768 -> 2765;
2769 -> 2757;
2769 -> 2765;
2770 -> 2759;
2770 -> 2765;
2771 -> 2761;
2771 -> 2765;
2772 -> 2764;
2772 -> 2765;
2773 -> 2765;
2774 -> 2773;
2774 -> 2765;
2775 -> 2773;
2775 -> 2765;
2776 -> 2773;
2776 -> 2765;
2777 -> 2773;
2777 -> 2765;
2778 -> 2773;
2778 -> 2765;
2779 -> 2773;
2779 -> 2765;
2780 -> 2773;
2780 -> 2765;
2781 -> 2767;
2781 -> 2765;
2782 -> 2765;
2783 -> 2766;
2783 -> 2773;
2783 -> 2765;
2784 -> 2767;
2784 -> 2773;
2784 -> 2765;
2785 -> 2768;
2785 -> 2773;
2785 -> 2765;
2786 -> 2769;
2786 -> 2773;
2786 -> 2765;
2787 -> 2770;
2787 -> 2773;
2787 -> 2765;
2788 -> 2771;
2788 -> 2773;
2788 -> 2765;
2789 -> 2772;
2789 -> 2773;
2789 -> 2765;
2790 -> 2773;
2790 -> 2789;
2790 -> 0;
2790 -> 2765;
2791 -> 2765;
2792 -> 2771;
2792 -> 2765;
2793 -> 2765;
2795 -> 2794;
2797 -> 2796;
2799 -> 2798;
2801 -> 2800;
2803 -> 2802;
2805 -> 2804;
2806 -> 0;
2807 -> 2806;
2807 -> 0;
2808 -> 2807;
2810 -> 2795;
2810 -> 2809;
2811 -> 2797;
2811 -> 2809;
2812 -> 2799;
2812 -> 2809;
2813 -> 2801;
2813 -> 2809;
2814 -> 2803;
2814 -> 2809;
2815 -> 2805;
2815 -> 2809;
2816 -> 2808;
2816 -> 2809;
2817 -> 2809;
2818 -> 2817;
2818 -> 2809;
2819 -> 2817;
2819 -> 2809;
2820 -> 2817;
2820 -> 2809;
2821 -> 2817;
2821 -> 2809;
2822 -> 2817;
2822 -> 2809;
2823 -> 2817;
2823 -> 2809;
2824 -> 2817;
2824 -> 2809;
2825 -> 2811;
2825 -> 2810;
2825 -> 2809;
2826 -> 2809;
2827 -> 2810;
2827 -> 2817;
2827 -> 2809;
2828 -> 2811;
2828 -> 2817;
2828 -> 2809;
2829 -> 2812;
2829 -> 2817;
2829 -> 2809;
2830 -> 2813;
2830 -> 2817;
2830 -> 2809;
2831 -> 2814;
2831 -> 2817;
2831 -> 2809;
2832 -> 2815;
2832 -> 2817;
2832 -> 2809;
2833 -> 2816;
2833 -> 2817;
2833 -> 2809;
2834 -> 2817;
2834 -> 2833;
2834 -> 0;
2834 -> 2809;
2835 -> 2809;
2836 -> 2815;
2836 -> 2809;
2837 -> 2817;
2837 -> 2833;
2837 -> 0;
2837 -> 2836;
2838 -> 2837;
2838 -> 2817;
2838 -> 2836;
2839 -> 2809;
2841 -> 2840;
2843 -> 2842;
2845 -> 2844;
2847 -> 2846;
2849 -> 2848;
2851 -> 2850;
2852 -> 0;
2853 -> 2852;
2853 -> 0;
2854 -> 2853;
2856 -> 2841;
2856 -> 2855;
2857 -> 2843;
2857 -> 2855;
2858 -> 2845;
2858 -> 2855;
2859 -> 2847;
2859 -> 2855;
2860 -> 2849;
2860 -> 2855;
2861 -> 2851;
2861 -> 2855;
2862 -> 2854;
2862 -> 2855;
2863 -> 2855;
2864 -> 2863;
2864 -> 2855;
2865 -> 2863;
2865 -> 2855;
2866 -> 2863;
2866 -> 2855;
2867 -> 2863;
2867 -> 2855;
2868 -> 2863;
2868 -> 2855;
2869 -> 2863;
2869 -> 2855;
2870 -> 2863;
2870 -> 2855;
2871 -> 2857;
2871 -> 2856;
2871 -> 2855;
2872 -> 2855;
2873 -> 2856;
2873 -> 2863;
2873 -> 2855;
2874 -> 2857;
2874 -> 2863;
2874 -> 2855;
2875 -> 2858;
2875 -> 2863;
2875 -> 2855;
2876 -> 2859;
2876 -> 2863;
2876 -> 2855;
2877 -> 2860;
2877 -> 2863;
2877 -> 2855;
2878 -> 2861;
2878 -> 2863;
2878 -> 2855;
2879 -> 2862;
2879 -> 2863;
2879 -> 2855;
2880 -> 2863;
2880 -> 2879;
2880 -> 0;
2880 -> 2855;
2881 -> 2855;
2882 -> 2861;
2882 -> 2855;
2883 -> 2855;
2885 -> 2884;
2887 -> 2886;
2889 -> 2888;
2891 -> 2890;
2893 -> 2892;
2895 -> 2894;
2896 -> 0;
2897 -> 2896;
2897 -> 0;
2898 -> 2897;
2900 -> 2885;
2900 -> 2899;
2901 -> 2887;
2901 -> 2899;
2902 -> 2889;
2902 -> 2899;
2903 -> 2891;
2903 -> 2899;
2904 -> 2893;
2904 -> 2899;
2905 -> 2895;
2905 -> 2899;
2906 -> 2898;
2906 -> 2899;
2907 -> 2899;
2908 -> 2907;
2908 -> 2899;
2909 -> 2907;
2909 -> 2899;
2910 -> 2907;
2910 -> 2899;
2911 -> 2907;
2911 -> 2899;
2912 -> 2907;
2912 -> 2899;
2913 -> 2907;
2913 -> 2899;
2914 -> 2907;
2914 -> 2899;
2915 -> 2901;
2915 -> 2899;
2916 -> 2899;
2917 -> 2900;
2917 -> 2907;
2917 -> 2899;
2918 -> 2901;
2918 -> 2907;
2918 -> 2899;
2919 -> 2902;
2919 -> 2907;
2919 -> 2899;
2920 -> 2903;
2920 -> 2907;
2920 -> 2899;
2921 -> 2904;
2921 -> 2907;
2921 -> 2899;
2922 -> 2905;
2922 -> 2907;
2922 -> 2899;
2923 -> 2906;
2923 -> 2907;
2923 -> 2899;
2924 -> 2907;
2924 -> 2923;
2924 -> 0;
2924 -> 2899;
2925 -> 2899;
2926 -> 2905;
2926 -> 2899;
2927 -> 2899;
2929 -> 2928;
2931 -> 2930;
2933 -> 2932;
2935 -> 2934;
2937 -> 2936;
2939 -> 2938;
2940 -> 0;
2941 -> 2940;
2941 -> 0;
2942 -> 2941;
2944 -> 2929;
2944 -> 2943;
2945 -> 2931;
2945 -> 2943;
2946 -> 2933;
2946 -> 2943;
2947 -> 2935;
2947 -> 2943;
2948 -> 2937;
2948 -> 2943;
2949 -> 2939;
2949 -> 2943;
2950 -> 2942;
2950 -> 2943;
2951 -> 2943;
2952 -> 2951;
2952 -> 2943;
2953 -> 2951;
2953 -> 2943;
2954 -> 2951;
2954 -> 2943;
2955 -> 2951;
2955 -> 2943;
2956 -> 2951;
2956 -> 2943;
2957 -> 2951;
2957 -> 2943;
2958 -> 2951;
2958 -> 2943;
2959 -> 2945;
2959 -> 2943;
2960 -> 2943;
2961 -> 2944;
2961 -> 2951;
2961 -> 2943;
2962 -> 2945;
2962 -> 2951;
2962 -> 2943;
2963 -> 2946;
2963 -> 2951;
2963 -> 2943;
2964 -> 2947;
2964 -> 2951;
2964 -> 2943;
2965 -> 2948;
2965 -> 2951;
2965 -> 2943;
2966 -> 2949;
2966 -> 2951;
2966 -> 2943;
2967 -> 2950;
2967 -> 2951;
2967 -> 2943;
2968 -> 2951;
2968 -> 2967;
2968 -> 0;
2968 -> 2943;
2969 -> 2943;
2970 -> 2949;
2970 -> 2943;
2971 -> 2943;
2972 -> 2398;
2973 -> 2972;
2973 -> 2388;
2973 -> 2389;
2973 -> 2390;
2973 -> 2391;
2973 -> 2392;
2973 -> 2393;
2973 -> 2394;
2974 -> 2973;
2975 -> 0;
2976 -> 2975;
2977 -> 2976;
2978 -> 0;
2979 -> 2978;
2980 -> 0;
2981 -> 2980;
2982 -> 2182;
2982 -> 2181;
2983 -> 2183;
2983 -> 2181;
2984 -> 2184;
2984 -> 2181;
2985 -> 2185;
2985 -> 2181;
2986 -> 2181;
2987 -> 2982;
2987 -> 2986;
2988 -> 2983;
2988 -> 2986;
2989 -> 2984;
2989 -> 2986;
2990 -> 2985;
2990 -> 2986;
2991 -> 2186;
2991 -> 2986;
2993 -> 2992;
2995 -> 2994;
2997 -> 2996;
2999 -> 2998;
3001 -> 2999;
3001 -> 3000;
3002 -> 3001;
3004 -> 3003;
3006 -> 3005;
3008 -> 3007;
3010 -> 3009;
3020 -> 3012;
3020 -> 3011;
3021 -> 3013;
3021 -> 3011;
3022 -> 3014;
3022 -> 3011;
3023 -> 3015;
3023 -> 3011;
3024 -> 3016;
3024 -> 3011;
3025 -> 3017;
3025 -> 3011;
3026 -> 3018;
3026 -> 3011;
3027 -> 3019;
3027 -> 3011;
3028 -> 3011;
3029 -> 2990;
3029 -> 2986;
3030 -> 2986;
3031 -> 3029;
3031 -> 3030;
3032 -> 2991;
3032 -> 3030;
3034 -> 3033;
3036 -> 0;
3038 -> 3036;
3038 -> 3037;
3039 -> 3037;
3040 -> 3039;
3040 -> 3037;
3041 -> 3038;
3041 -> 3039;
3041 -> 3037;
3042 -> 3037;
3043 -> 0;
3045 -> 3043;
3045 -> 3044;
3046 -> 3044;
3047 -> 3046;
3047 -> 3044;
3048 -> 3045;
3048 -> 3046;
3048 -> 3044;
3049 -> 3044;
3050 -> 0;
3052 -> 3050;
3052 -> 3051;
3053 -> 3051;
3054 -> 3053;
3054 -> 3051;
3055 -> 3052;
3055 -> 3053;
3055 -> 3051;
3056 -> 3051;
3057 -> 0;
3059 -> 3057;
3059 -> 3058;
3060 -> 3058;
3061 -> 3060;
3061 -> 3058;
3062 -> 3059;
3062 -> 3060;
3062 -> 3058;
3063 -> 3058;
3064 -> 0;
3066 -> 3064;
3066 -> 3065;
3067 -> 3065;
3068 -> 3067;
3068 -> 3065;
3069 -> 3066;
3069 -> 3067;
3069 -> 3065;
3070 -> 3065;
3071 -> 0;
3073 -> 3071;
3073 -> 3072;
3074 -> 3072;
3075 -> 3074;
3075 -> 3072;
3076 -> 3073;
3076 -> 3074;
3076 -> 3072;
3077 -> 3072;
3078 -> 0;
3080 -> 3078;
3080 -> 3079;
3081 -> 3079;
3082 -> 3081;
3082 -> 3079;
3083 -> 3080;
3083 -> 3081;
3083 -> 3079;
3084 -> 3079;
3085 -> 0;
3087 -> 3085;
3087 -> 3086;
3088 -> 3086;
3089 -> 3088;
3089 -> 3086;
3090 -> 3087;
3090 -> 3088;
3090 -> 3086;
3091 -> 3086;
3092 -> 3091;
3094 -> 3035;
3094 -> 3092;
3094 -> 3093;
3094 -> 3088;
3094 -> 3089;
3094 -> 3090;
3095 -> 3094;
3097 -> 3096;
3098 -> 3097;
3098 -> 3096;
3099 -> 3097;
3099 -> 3096;
3100 -> 3097;
3100 -> 3096;
3101 -> 3096;
3103 -> 3102;
3104 -> 3030;
3105 -> 3032;
3105 -> 3104;
3106 -> 3104;
3107 -> 3105;
3107 -> 3104;
3108 -> 3105;
3108 -> 3104;
3109 -> 3032;
3109 -> 3030;
3110 -> 3032;
3110 -> 3030;
3111 -> 3032;
3111 -> 3030;
3112 -> 3031;
3112 -> 3032;
3112 -> 3030;
3113 -> 2991;
3113 -> 2986;
3114 -> 2991;
3114 -> 2986;
3115 -> 2991;
3115 -> 2986;
3117 -> 3116;
3118 -> 3117;
3118 -> 3116;
3119 -> 3117;
3119 -> 3116;
3120 -> 3117;
3120 -> 3116;
3121 -> 3117;
3121 -> 3116;
3122 -> 3117;
3122 -> 3116;
3123 -> 3117;
3123 -> 3116;
3124 -> 3116;
3125 -> 3124;
3125 -> 2991;
3125 -> 2986;
3126 -> 2991;
3126 -> 2986;
3127 -> 2991;
3127 -> 2986;
3128 -> 2991;
3128 -> 2986;
3129 -> 2991;
3129 -> 2986;
3130 -> 2991;
3130 -> 2986;
3131 -> 2114;
3131 -> 2991;
3131 -> 2986;
3132 -> 2991;
3132 -> 2986;
3133 -> 2991;
3133 -> 2986;
3134 -> 2987;
3134 -> 2991;
3134 -> 2986;
3135 -> 2988;
3135 -> 2991;
3135 -> 2986;
3136 -> 2988;
3136 -> 2168;
3136 -> 2986;
3137 -> 2986;
3138 -> 3136;
3138 -> 3137;
3139 -> 3138;
3139 -> 3137;
3140 -> 0;
3140 -> 3139;
3141 -> 3140;
3141 -> 2986;
3142 -> 2989;
3142 -> 2986;
3143 -> 2986;
3144 -> 3141;
3144 -> 3143;
3145 -> 3142;
3145 -> 3143;
3146 -> 2991;
3146 -> 3143;
3147 -> 3143;
3148 -> 3146;
3148 -> 3147;
3149 -> 3148;
3149 -> 3134;
3149 -> 3147;
3150 -> 3149;
3150 -> 3143;
3151 -> 3143;
3152 -> 0;
3152 -> 3143;
3153 -> 3143;
3154 -> 3150;
3154 -> 3153;
3155 -> 0;
3155 -> 3153;
3156 -> 3155;
3156 -> 3143;
3157 -> 0;
3157 -> 3156;
3158 -> 3144;
3158 -> 3143;
3159 -> 0;
3159 -> 3158;
3160 -> 3152;
3160 -> 3159;
3160 -> 3158;
3161 -> 3158;
3162 -> 3146;
3162 -> 3161;
3163 -> 3161;
3164 -> 3162;
3164 -> 3135;
3164 -> 2168;
3164 -> 3163;
3164 -> 3161;
3165 -> 3164;
3165 -> 3158;
3166 -> 3160;
3166 -> 0;
3166 -> 3165;
3167 -> 3143;
3168 -> 3157;
3168 -> 3143;
3169 -> 3166;
3169 -> 3143;
3170 -> 3145;
3170 -> 3143;
3171 -> 3167;
3171 -> 3143;
3172 -> 3143;
3173 -> 3168;
3173 -> 3172;
3174 -> 3169;
3174 -> 3172;
3175 -> 3170;
3175 -> 3172;
3176 -> 3171;
3176 -> 3172;
3177 -> 3146;
3177 -> 3172;
3178 -> 3172;
3179 -> 0;
3179 -> 3172;
3180 -> 3177;
3180 -> 3135;
3180 -> 3164;
3180 -> 3172;
3181 -> 3172;
3182 -> 3172;
3183 -> 3182;
3183 -> 3180;
3183 -> 3172;
3184 -> 3177;
3184 -> 3135;
3184 -> 3164;
3184 -> 3182;
3184 -> 3183;
3185 -> 3184;
3185 -> 3183;
3186 -> 3183;
3187 -> 3178;
3187 -> 3183;
3188 -> 3185;
3188 -> 3187;
3189 -> 3174;
3189 -> 3187;
3190 -> 3177;
3190 -> 3135;
3190 -> 3184;
3190 -> 3182;
3190 -> 3187;
3191 -> 3175;
3191 -> 3187;
3192 -> 3187;
3193 -> 3178;
3193 -> 3187;
3194 -> 3187;
3195 -> 3188;
3195 -> 3194;
3196 -> 3189;
3196 -> 3194;
3197 -> 3190;
3197 -> 3194;
3198 -> 3191;
3198 -> 3194;
3199 -> 3192;
3199 -> 3194;
3200 -> 3193;
3200 -> 3194;
3201 -> 3194;
3202 -> 3195;
3202 -> 3196;
3202 -> 3194;
3203 -> 3195;
3203 -> 3196;
3203 -> 3194;
3204 -> 3202;
3204 -> 0;
3204 -> 3194;
3205 -> 3203;
3205 -> 0;
3205 -> 3194;
3206 -> 3194;
3207 -> 3203;
3207 -> 3194;
3208 -> 3201;
3208 -> 3187;
3209 -> 3207;
3209 -> 3208;
3210 -> 3177;
3210 -> 3208;
3211 -> 3208;
3212 -> 3208;
3213 -> 3209;
3213 -> 3212;
3214 -> 3210;
3214 -> 3212;
3215 -> 3211;
3215 -> 3212;
3216 -> 3213;
3216 -> 3212;
3217 -> 3212;
3218 -> 3216;
3218 -> 3217;
3219 -> 3218;
3219 -> 0;
3219 -> 3217;
3220 -> 3219;
3221 -> 3212;
3222 -> 3214;
3222 -> 3221;
3223 -> 0;
3223 -> 3221;
3224 -> 3223;
3224 -> 3212;
3225 -> 3215;
3225 -> 3224;
3225 -> 3212;
3226 -> 3213;
3226 -> 0;
3226 -> 3212;
3227 -> 3212;
3228 -> 3225;
3228 -> 3226;
3228 -> 3212;
3229 -> 3213;
3229 -> 0;
3229 -> 3228;
3230 -> 3212;
3231 -> 3230;
3231 -> 3208;
3232 -> 3208;
3233 -> 3231;
3233 -> 3232;
3233 -> 3208;
3234 -> 3179;
3234 -> 0;
3234 -> 3183;
3235 -> 3207;
3235 -> 3234;
3236 -> 3235;
3236 -> 0;
3236 -> 3172;
3237 -> 3172;
3238 -> 3181;
3238 -> 3172;
3239 -> 3172;
3240 -> 3177;
3240 -> 3239;
3241 -> 3240;
3241 -> 3135;
3241 -> 3190;
3241 -> 3239;
3242 -> 3241;
3242 -> 3172;
3243 -> 0;
3243 -> 3172;
3244 -> 3235;
3244 -> 3172;
3246 -> 3245;
3247 -> 3146;
3247 -> 3143;
3248 -> 3244;
3248 -> 3143;
3249 -> 3145;
3249 -> 3143;
3250 -> 3143;
3251 -> 3247;
3251 -> 3250;
3252 -> 3248;
3252 -> 3250;
3253 -> 3249;
3253 -> 3250;
3254 -> 3251;
3254 -> 3250;
3255 -> 3252;
3255 -> 3250;
3256 -> 3250;
3257 -> 3251;
3257 -> 3256;
3258 -> 3257;
3258 -> 3135;
3258 -> 3190;
3258 -> 3256;
3259 -> 3258;
3259 -> 3250;
3260 -> 3250;
3261 -> 3253;
3261 -> 3250;
3262 -> 3250;
3263 -> 3254;
3263 -> 3262;
3264 -> 3255;
3264 -> 3262;
3265 -> 3259;
3265 -> 3262;
3266 -> 3261;
3266 -> 3262;
3267 -> 3264;
3267 -> 0;
3267 -> 3262;
3268 -> 3143;
3269 -> 3244;
3269 -> 0;
3269 -> 3143;
3270 -> 3143;
3271 -> 3201;
3271 -> 3269;
3271 -> 3143;
3272 -> 0;
3272 -> 3143;
3273 -> 3244;
3273 -> 3272;
3273 -> 3143;
3274 -> 3201;
3274 -> 3273;
3274 -> 3143;
3275 -> 3144;
3275 -> 3143;
3276 -> 3244;
3276 -> 3143;
3277 -> 2988;
3277 -> 3259;
3277 -> 2986;
3278 -> 3277;
3278 -> 3259;
3279 -> 2989;
3279 -> 3278;
3279 -> 2156;
3279 -> 3259;
3279 -> 3277;
3280 -> 3276;
3280 -> 0;
3280 -> 2986;
3281 -> 2986;
3282 -> 3280;
3282 -> 3281;
3282 -> 2986;
3283 -> 3276;
3283 -> 2991;
3283 -> 2986;
3284 -> 3280;
3284 -> 0;
3284 -> 2986;
3285 -> 3284;
3285 -> 2986;
3286 -> 3285;
3287 -> 2991;
3287 -> 3286;
3288 -> 3286;
3289 -> 3287;
3289 -> 3288;
3290 -> 3289;
3290 -> 3134;
3290 -> 3288;
3291 -> 3290;
3291 -> 3286;
3292 -> 3286;
3293 -> 3291;
3293 -> 3292;
3294 -> 0;
3294 -> 3292;
3295 -> 3294;
3295 -> 3286;
3296 -> 3286;
3297 -> 3287;
3297 -> 3296;
3298 -> 3297;
3298 -> 3134;
3298 -> 3296;
3299 -> 3298;
3299 -> 3286;
3300 -> 3286;
3301 -> 3299;
3301 -> 3300;
3302 -> 3300;
3303 -> 3301;
3303 -> 3279;
3303 -> 3302;
3304 -> 3303;
3304 -> 3279;
3304 -> 3302;
3305 -> 3286;
3306 -> 3304;
3306 -> 3305;
3307 -> 3305;
3308 -> 3306;
3308 -> 3307;
3309 -> 3308;
3309 -> 3305;
3310 -> 3306;
3310 -> 3305;
3311 -> 3295;
3311 -> 3309;
3311 -> 3286;
3312 -> 0;
3312 -> 3311;
3314 -> 3313;
3316 -> 3315;
3317 -> 3314;
3317 -> 3316;
3318 -> 3317;
3320 -> 3319;
3321 -> 3318;
3321 -> 3320;
3322 -> 3321;
3324 -> 3323;
3325 -> 3322;
3325 -> 3324;
3326 -> 3325;
3328 -> 3327;
3329 -> 3326;
3329 -> 3328;
3330 -> 3329;
3332 -> 3331;
3333 -> 3330;
3333 -> 3332;
3334 -> 3333;
3336 -> 3335;
3338 -> 3337;
3338 -> 3316;
3340 -> 3338;
3340 -> 3339;
3341 -> 3340;
3343 -> 3342;
3343 -> 3320;
3345 -> 3343;
3345 -> 3344;
3346 -> 3345;
3348 -> 3347;
3348 -> 3332;
3350 -> 3348;
3350 -> 3349;
3351 -> 3350;
3353 -> 3352;
3353 -> 3336;
3355 -> 3353;
3355 -> 3354;
3356 -> 3355;
3358 -> 3357;
3358 -> 3322;
3359 -> 3358;
3361 -> 3360;
3361 -> 3326;
3362 -> 3361;
3363 -> 3341;
3364 -> 3356;
3365 -> 3312;
3365 -> 2986;
3366 -> 3140;
3366 -> 2986;
3367 -> 2986;
3368 -> 2986;
3369 -> 3365;
3369 -> 3368;
3370 -> 3366;
3370 -> 3368;
3371 -> 3367;
3371 -> 3368;
3372 -> 3369;
3372 -> 3341;
3372 -> 3368;
3373 -> 3372;
3373 -> 3314;
3373 -> 3368;
3374 -> 3370;
3374 -> 3351;
3374 -> 3368;
3375 -> 3374;
3375 -> 3330;
3375 -> 3368;
3376 -> 3373;
3376 -> 3375;
3376 -> 3368;
3377 -> 3376;
3377 -> 3371;
3377 -> 3368;
3378 -> 3367;
3378 -> 2991;
3378 -> 2986;
3379 -> 2986;
3380 -> 2991;
3380 -> 3379;
3381 -> 3380;
3381 -> 3134;
3381 -> 3379;
3382 -> 3381;
3382 -> 2986;
3383 -> 3382;
3383 -> 2986;
3384 -> 2986;
3385 -> 0;
3385 -> 2986;
3386 -> 2986;
3387 -> 3385;
3387 -> 3386;
3388 -> 2991;
3388 -> 3386;
3389 -> 3388;
3389 -> 3386;
3390 -> 3387;
3390 -> 3386;
3391 -> 3389;
3391 -> 3390;
3391 -> 3386;
3392 -> 2186;
3392 -> 2181;
3393 -> 2186;
3393 -> 2181;
3394 -> 2186;
3394 -> 2181;
3395 -> 0;
3395 -> 2186;
3395 -> 2181;
3396 -> 2186;
3396 -> 2181;
3398 -> 3397;
3399 -> 3397;
3400 -> 3399;
3401 -> 3399;
3402 -> 3401;
3402 -> 3399;
3403 -> 3402;
3403 -> 3400;
3404 -> 3400;
3405 -> 3404;
3406 -> 3405;
3407 -> 3406;
3408 -> 3407;
3408 -> 3406;
3409 -> 3405;
3409 -> 3404;
3410 -> 3405;
3410 -> 3404;
3411 -> 3404;
3411 -> 3400;
3412 -> 3404;
3412 -> 3400;
3413 -> 3404;
3413 -> 3400;
3414 -> 3403;
3414 -> 3404;
3414 -> 3400;
3415 -> 3399;
3415 -> 3397;
3416 -> 3398;
3416 -> 3399;
3416 -> 3397;
3417 -> 3397;
3418 -> 3417;
3418 -> 2186;
3418 -> 2181;
3419 -> 2186;
3419 -> 2181;
3420 -> 3417;
3420 -> 2186;
3420 -> 2181;
3421 -> 2183;
3421 -> 3279;
3421 -> 2181;
3422 -> 2181;
3423 -> 2182;
3423 -> 3422;
3424 -> 0;
3424 -> 3422;
3425 -> 3424;
3425 -> 2181;
3426 -> 2169;
3427 -> 2180;
3427 -> 3426;
3428 -> 2168;
3428 -> 3426;
3429 -> 3426;
3430 -> 3427;
3430 -> 3429;
3431 -> 3430;
3431 -> 3135;
3431 -> 3279;
3431 -> 3429;
3432 -> 3431;
3432 -> 3426;
3433 -> 3426;
3434 -> 3432;
3434 -> 3426;
3435 -> 3433;
3435 -> 3426;
3436 -> 3428;
3436 -> 2168;
3436 -> 3434;
3436 -> 3435;
3436 -> 3426;
3437 -> 3427;
3437 -> 3432;
3437 -> 3428;
3437 -> 3436;
3438 -> 2159;
3439 -> 2168;
3439 -> 3438;
3440 -> 3439;
3440 -> 2168;
3440 -> 3437;
3440 -> 3436;
3440 -> 3438;
3441 -> 0;
3441 -> 3438;
3442 -> 3439;
3442 -> 2168;
3442 -> 3437;
3442 -> 3438;
3443 -> 3442;
3443 -> 3436;
3444 -> 3442;
3445 -> 3444;
3445 -> 3442;
3446 -> 3443;
3446 -> 3442;
3447 -> 3442;
3448 -> 3446;
3448 -> 3447;
3448 -> 3442;
3449 -> 3443;
3449 -> 3448;
3450 -> 3448;
3451 -> 3449;
3451 -> 3450;
3452 -> 0;
3452 -> 3450;
3453 -> 3452;
3453 -> 3448;
3454 -> 3453;
3454 -> 3448;
3455 -> 3449;
3455 -> 3454;
3456 -> 3442;
3456 -> 3436;
3457 -> 3455;
3457 -> 3442;
3458 -> 3440;
3458 -> 3456;
3458 -> 3457;
3458 -> 3442;
3459 -> 3440;
3459 -> 3438;
3460 -> 3459;
3460 -> 2159;
3461 -> 2161;
3461 -> 2159;
3462 -> 3460;
3462 -> 2159;
3463 -> 2160;
3463 -> 2159;
3464 -> 2159;
3465 -> 3461;
3465 -> 3464;
3466 -> 3462;
3466 -> 3464;
3467 -> 3463;
3467 -> 3464;
3468 -> 3464;
3469 -> 3464;
3470 -> 3464;
3471 -> 3465;
3471 -> 3470;
3472 -> 3470;
3473 -> 3471;
3473 -> 3279;
3473 -> 3472;
3474 -> 3473;
3474 -> 3279;
3474 -> 3472;
3475 -> 3474;
3475 -> 3464;
3476 -> 3464;
3477 -> 3475;
3477 -> 3476;
3478 -> 3464;
3479 -> 3466;
3479 -> 3440;
3479 -> 3464;
3480 -> 3479;
3480 -> 3440;
3480 -> 3458;
3480 -> 3464;
3481 -> 3468;
3481 -> 3480;
3482 -> 3480;
3483 -> 3466;
3483 -> 3480;
3483 -> 3440;
3483 -> 3458;
3483 -> 3279;
3483 -> 3455;
3484 -> 3483;
3485 -> 3483;
3486 -> 3484;
3486 -> 3485;
3486 -> 3483;
3487 -> 3486;
3487 -> 3483;
3488 -> 3487;
3489 -> 3484;
3489 -> 3488;
3490 -> 3489;
3490 -> 3483;
3490 -> 3488;
3491 -> 3490;
3491 -> 3468;
3491 -> 3481;
3491 -> 3483;
3492 -> 3468;
3492 -> 3481;
3492 -> 3490;
3492 -> 3483;
3493 -> 3483;
3494 -> 3492;
3494 -> 3493;
3494 -> 3483;
3495 -> 3469;
3495 -> 3493;
3495 -> 3483;
3496 -> 3494;
3496 -> 3495;
3496 -> 3483;
3497 -> 3483;
3498 -> 3492;
3498 -> 3497;
3498 -> 3483;
3499 -> 3483;
3499 -> 3490;
3499 -> 3468;
3500 -> 3483;
3501 -> 3484;
3501 -> 3500;
3501 -> 3483;
3502 -> 3501;
3503 -> 3484;
3503 -> 3502;
3504 -> 3503;
3504 -> 3483;
3504 -> 3502;
3505 -> 3502;
3506 -> 3504;
3506 -> 3505;
3507 -> 3506;
3507 -> 0;
3507 -> 3505;
3508 -> 0;
3508 -> 3507;
3509 -> 3508;
3509 -> 3501;
3510 -> 3509;
3510 -> 0;
3510 -> 3501;
3511 -> 2159;
3512 -> 3460;
3512 -> 2159;
3513 -> 2155;
3514 -> 2157;
3514 -> 3512;
3514 -> 3513;
3514 -> 3483;
3514 -> 2155;
3515 -> 3514;
3516 -> 2153;
3516 -> 3515;
3517 -> 3515;
3518 -> 3516;
3518 -> 3517;
3519 -> 0;
3519 -> 3517;
3520 -> 3519;
3520 -> 3515;
3521 -> 3515;
3522 -> 3516;
3522 -> 3521;
3523 -> 3522;
3523 -> 3514;
3523 -> 3521;
3524 -> 3523;
3524 -> 3515;
3525 -> 3515;
3526 -> 3524;
3526 -> 3525;
3526 -> 3515;
3527 -> 3526;
3527 -> 3515;
3528 -> 3527;
3529 -> 3528;
3529 -> 3514;
3530 -> 3514;
3531 -> 3529;
3531 -> 3530;
3532 -> 3531;
3532 -> 3514;
3532 -> 3530;
3533 -> 3530;
3534 -> 3531;
3534 -> 3514;
3534 -> 3533;
3534 -> 3530;
3535 -> 3534;
3536 -> 3531;
3536 -> 3514;
3536 -> 3534;
3537 -> 3535;
3537 -> 3534;
3538 -> 3534;
3539 -> 3531;
3539 -> 3537;
3539 -> 3530;
3540 -> 2156;
3540 -> 3514;
3541 -> 3514;
3542 -> 2153;
3542 -> 3541;
3543 -> 3541;
3544 -> 3542;
3544 -> 3543;
3545 -> 3543;
3546 -> 3544;
3546 -> 3539;
3546 -> 3545;
3547 -> 3546;
3547 -> 3539;
3547 -> 3545;
3548 -> 3547;
3548 -> 3541;
3549 -> 3541;
3550 -> 3548;
3550 -> 3549;
3551 -> 3549;
3552 -> 3550;
3552 -> 3551;
3553 -> 3552;
3553 -> 3549;
3554 -> 3550;
3554 -> 3549;
3555 -> 3553;
3555 -> 3541;
3556 -> 3514;
3557 -> 3514;
3558 -> 2153;
3558 -> 3557;
3559 -> 3557;
3560 -> 3558;
3560 -> 3559;
3561 -> 0;
3561 -> 3559;
3562 -> 3561;
3562 -> 3557;
3563 -> 3557;
3564 -> 3558;
3564 -> 3563;
3565 -> 3564;
3565 -> 3539;
3565 -> 3563;
3566 -> 3557;
3567 -> 3565;
3567 -> 3514;
3568 -> 2153;
3568 -> 3514;
3569 -> 3514;
3570 -> 3568;
3570 -> 3569;
3571 -> 3567;
3571 -> 3569;
3572 -> 3571;
3572 -> 3569;
3573 -> 3570;
3573 -> 3569;
3574 -> 3573;
3574 -> 3539;
3574 -> 3569;
3575 -> 3569;
3576 -> 3572;
3576 -> 3574;
3576 -> 3575;
3576 -> 3569;
3577 -> 3514;
3578 -> 0;
3578 -> 3514;
3579 -> 3514;
3580 -> 3578;
3580 -> 3579;
3581 -> 2153;
3581 -> 3576;
3581 -> 3579;
3582 -> 3581;
3582 -> 3576;
3582 -> 3579;
3583 -> 3580;
3583 -> 3579;
3584 -> 3582;
3584 -> 3583;
3584 -> 3579;
3585 -> 3584;
3585 -> 3514;
3586 -> 2156;
3586 -> 3576;
3586 -> 3584;
3586 -> 2155;
3587 -> 2153;
3587 -> 3586;
3587 -> 2152;
3588 -> 3587;
3588 -> 2150;
3589 -> 2150;
3590 -> 3588;
3590 -> 3589;
3591 -> 0;
3591 -> 3589;
3592 -> 3590;
3592 -> 3589;
3593 -> 3592;
3593 -> 3586;
3594 -> 3592;
3595 -> 3592;
3596 -> 3593;
3596 -> 3592;
3597 -> 3596;
3598 -> 3596;
3598 -> 3597;
3599 -> 3597;
3599 -> 3596;
3600 -> 3599;
3601 -> 3595;
3601 -> 3599;
3602 -> 3600;
3602 -> 3592;
3603 -> 3595;
3603 -> 3602;
3604 -> 3592;
3604 -> 3586;
3604 -> 3603;
3605 -> 3593;
3605 -> 3586;
3605 -> 3603;
3606 -> 3591;
3606 -> 3604;
3606 -> 3605;
3606 -> 3603;
3607 -> 3591;
3607 -> 3589;
3608 -> 3607;
3608 -> 2150;
3609 -> 2150;
3610 -> 2151;
3610 -> 3608;
3610 -> 3609;
3610 -> 3591;
3610 -> 3605;
3610 -> 3606;
3610 -> 2150;
3611 -> 2148;
3611 -> 3610;
3611 -> 2147;
3612 -> 3611;
3612 -> 2142;
3613 -> 2143;
3613 -> 2142;
3614 -> 2145;
3614 -> 2142;
3615 -> 3612;
3615 -> 3613;
3615 -> 3614;
3615 -> 3610;
3615 -> 2146;
3615 -> 2142;
3616 -> 3615;
3616 -> 2142;
3617 -> 1;
3618 -> 3616;
3618 -> 3617;
3619 -> 3617;
3620 -> 3618;
3620 -> 3615;
3620 -> 3616;
3620 -> 3619;
3621 -> 3620;
3621 -> 3615;
3621 -> 3616;
3621 -> 3362;
3621 -> 3619;
3622 -> 3619;
3623 -> 3621;
3623 -> 3617;
3624 -> 3623;
3625 -> 3618;
3625 -> 3624;
3626 -> 3625;
3626 -> 3615;
3626 -> 3616;
3626 -> 3624;
3627 -> 3626;
3627 -> 3615;
3627 -> 3616;
3627 -> 3624;
3628 -> 3627;
3629 -> 3625;
3629 -> 3628;
3630 -> 0;
3630 -> 3628;
3631 -> 3628;
3632 -> 3630;
3632 -> 3631;
3633 -> 3629;
3633 -> 3615;
3633 -> 3616;
3633 -> 3631;
3634 -> 3633;
3634 -> 3615;
3634 -> 3616;
3634 -> 3632;
3634 -> 3631;
3635 -> 3628;
3636 -> 3629;
3636 -> 3635;
3637 -> 3635;
3638 -> 3636;
3638 -> 3615;
3638 -> 3616;
3638 -> 3637;
3638 -> 3635;
3639 -> 3638;
3640 -> 3639;
3640 -> 3638;
3641 -> 3638;
3642 -> 3640;
3642 -> 3641;
3643 -> 3636;
3643 -> 3641;
3644 -> 3641;
3645 -> 3641;
3646 -> 3643;
3646 -> 3645;
3647 -> 3646;
3647 -> 3615;
3647 -> 3616;
3647 -> 3645;
3648 -> 3645;
3649 -> 3647;
3649 -> 3648;
3649 -> 3645;
3650 -> 3645;
3651 -> 3650;
3651 -> 3645;
3652 -> 3645;
3653 -> 3651;
3653 -> 3652;
3654 -> 3646;
3654 -> 3652;
3655 -> 3652;
3656 -> 3654;
3656 -> 3655;
3657 -> 3656;
3657 -> 3615;
3657 -> 3616;
3657 -> 3655;
3658 -> 3657;
3658 -> 3124;
3658 -> 3655;
3659 -> 3656;
3659 -> 3615;
3659 -> 3616;
3659 -> 3655;
3660 -> 3655;
3661 -> 3660;
3661 -> 3655;
3662 -> 3655;
3663 -> 3661;
3663 -> 3662;
3664 -> 3656;
3664 -> 3662;
3665 -> 3662;
3666 -> 3662;
3667 -> 3665;
3667 -> 3666;
3668 -> 3666;
3669 -> 3668;
3669 -> 3667;
3669 -> 3666;
3670 -> 3666;
3671 -> 3670;
3671 -> 3667;
3671 -> 3666;
3672 -> 3666;
3673 -> 3672;
3673 -> 3667;
3673 -> 3666;
3674 -> 3667;
3674 -> 3666;
3675 -> 3667;
3675 -> 3666;
3676 -> 3667;
3676 -> 3666;
3677 -> 3666;
3678 -> 3677;
3678 -> 3667;
3678 -> 3666;
3679 -> 3667;
3679 -> 3666;
3680 -> 3667;
3680 -> 3666;
3681 -> 3665;
3681 -> 3662;
3682 -> 3663;
3682 -> 3662;
3683 -> 3662;
3684 -> 3681;
3684 -> 3683;
3685 -> 3682;
3685 -> 3683;
3686 -> 3664;
3686 -> 3683;
3687 -> 3686;
3687 -> 3659;
3687 -> 3683;
3688 -> 3687;
3688 -> 3659;
3689 -> 3687;
3690 -> 3687;
3691 -> 3690;
3691 -> 3687;
3692 -> 3690;
3692 -> 3691;
3693 -> 3684;
3693 -> 3691;
3694 -> 3691;
3695 -> 3692;
3695 -> 3691;
3696 -> 3685;
3696 -> 3691;
3697 -> 3691;
3698 -> 3693;
3698 -> 3697;
3699 -> 3694;
3699 -> 3697;
3700 -> 3695;
3700 -> 3697;
3701 -> 3696;
3701 -> 3697;
3702 -> 3686;
3702 -> 3697;
3703 -> 3697;
3704 -> 3700;
3704 -> 3691;
3704 -> 3703;
3704 -> 3697;
3705 -> 3697;
3706 -> 3700;
3706 -> 3705;
3706 -> 3691;
3706 -> 3697;
3707 -> 3706;
3707 -> 3697;
3708 -> 3697;
3709 -> 3707;
3709 -> 3708;
3710 -> 3702;
3710 -> 3708;
3711 -> 3708;
3712 -> 3710;
3712 -> 3711;
3713 -> 3711;
3714 -> 3712;
3714 -> 3713;
3715 -> 3713;
3715 -> 3711;
3716 -> 3712;
3716 -> 3711;
3717 -> 3711;
3718 -> 3716;
3718 -> 3717;
3719 -> 3718;
3719 -> 3706;
3719 -> 3717;
3720 -> 3719;
3720 -> 3711;
3721 -> 3711;
3722 -> 3720;
3722 -> 3721;
3722 -> 3711;
3723 -> 3722;
3723 -> 3711;
3724 -> 3723;
3725 -> 3724;
3725 -> 3708;
3726 -> 3709;
3726 -> 3708;
3727 -> 3708;
3728 -> 3726;
3728 -> 3727;
3729 -> 3725;
3729 -> 3727;
3730 -> 3728;
3730 -> 3706;
3730 -> 3727;
3731 -> 3727;
3732 -> 3727;
3733 -> 3730;
3733 -> 3732;
3734 -> 3731;
3734 -> 3732;
3735 -> 3729;
3735 -> 3732;
3736 -> 3734;
3736 -> 3732;
3737 -> 3733;
3737 -> 3732;
3738 -> 3732;
3739 -> 3735;
3739 -> 3706;
3739 -> 3732;
3740 -> 3732;
3741 -> 3737;
3741 -> 3740;
3742 -> 3738;
3742 -> 3740;
3743 -> 3739;
3743 -> 3740;
3744 -> 3735;
3744 -> 3740;
3745 -> 3743;
3745 -> 3740;
3746 -> 3742;
3746 -> 3740;
3747 -> 3744;
3747 -> 3706;
3747 -> 3746;
3748 -> 3744;
3748 -> 3706;
3748 -> 3747;
3748 -> 3740;
3749 -> 3745;
3749 -> 3748;
3749 -> 3706;
3749 -> 3747;
3749 -> 3740;
3750 -> 3741;
3750 -> 3740;
3751 -> 3740;
3752 -> 3750;
3752 -> 3751;
3753 -> 3744;
3753 -> 3751;
3754 -> 3752;
3754 -> 3751;
3755 -> 3751;
3756 -> 3754;
3756 -> 3755;
3757 -> 3753;
3757 -> 3755;
3758 -> 3755;
3759 -> 3756;
3759 -> 3758;
3759 -> 3755;
3760 -> 3757;
3760 -> 3749;
3760 -> 3755;
3761 -> 3756;
3761 -> 3755;
3762 -> 3760;
3762 -> 3761;
3762 -> 3755;
3763 -> 3753;
3763 -> 3762;
3763 -> 3751;
3764 -> 3749;
3764 -> 3740;
3765 -> 3740;
3766 -> 3764;
3766 -> 3765;
3766 -> 3740;
3767 -> 3766;
3768 -> 3767;
3768 -> 3763;
3769 -> 3768;
3769 -> 3766;
3770 -> 3749;
3770 -> 3766;
3771 -> 3769;
3771 -> 3766;
3772 -> 3766;
3773 -> 3740;
3774 -> 3771;
3774 -> 3763;
3774 -> 3740;
3775 -> 3740;
3776 -> 3774;
3776 -> 3775;
3776 -> 3740;
3777 -> 3741;
3777 -> 3740;
3778 -> 3742;
3778 -> 3740;
3779 -> 3771;
3779 -> 3763;
3779 -> 3740;
3780 -> 3740;
3781 -> 3777;
3781 -> 3780;
3782 -> 3778;
3782 -> 3780;
3783 -> 3779;
3783 -> 3780;
3784 -> 3744;
3784 -> 3780;
3785 -> 3784;
3785 -> 3780;
3786 -> 3781;
3786 -> 3780;
3787 -> 3782;
3787 -> 3780;
3788 -> 3780;
3789 -> 3780;
3790 -> 3785;
3790 -> 3789;
3791 -> 3786;
3791 -> 3789;
3792 -> 3787;
3792 -> 3789;
3793 -> 3788;
3793 -> 3789;
3794 -> 3793;
3794 -> 3789;
3795 -> 3793;
3795 -> 3789;
3796 -> 3793;
3796 -> 3789;
3797 -> 3793;
3797 -> 3789;
3798 -> 3793;
3798 -> 3789;
3799 -> 3793;
3799 -> 3789;
3800 -> 3790;
3800 -> 3793;
3800 -> 3789;
3801 -> 3791;
3801 -> 3793;
3801 -> 3789;
3802 -> 3792;
3802 -> 3793;
3802 -> 3789;
3803 -> 3793;
3803 -> 3789;
3804 -> 3789;
3805 -> 3803;
3805 -> 3804;
3805 -> 3794;
3805 -> 3800;
3805 -> 3801;
3805 -> 3797;
3805 -> 3802;
3805 -> 3799;
3805 -> 3771;
3805 -> 3789;
3806 -> 3805;
3806 -> 3793;
3806 -> 3789;
3807 -> 3789;
3808 -> 3807;
3808 -> 3793;
3808 -> 3789;
3809 -> 3790;
3809 -> 3789;
3810 -> 3789;
3811 -> 3789;
3812 -> 3809;
3812 -> 3811;
3813 -> 3810;
3813 -> 3811;
3815 -> 3814;
3817 -> 3816;
3819 -> 3818;
3822 -> 3821;
3823 -> 0;
3824 -> 0;
3825 -> 0;
3826 -> 3825;
3828 -> 3823;
3828 -> 3824;
3828 -> 3826;
3828 -> 3827;
3829 -> 3828;
3831 -> 3830;
3833 -> 3832;
3835 -> 3834;
3837 -> 3836;
3838 -> 3812;
3838 -> 3811;
3839 -> 3811;
3840 -> 3838;
3840 -> 3839;
3841 -> 3813;
3841 -> 3839;
3842 -> 3841;
3842 -> 3839;
3843 -> 3841;
3843 -> 3839;
3844 -> 3841;
3844 -> 3839;
3845 -> 3841;
3845 -> 3839;
3846 -> 3841;
3846 -> 3839;
3847 -> 3839;
3848 -> 3840;
3848 -> 3847;
3848 -> 3839;
3849 -> 3841;
3849 -> 3839;
3850 -> 3849;
3850 -> 3842;
3850 -> 3843;
3850 -> 3844;
3850 -> 3845;
3850 -> 3846;
3850 -> 3839;
3851 -> 3839;
3852 -> 3840;
3852 -> 3851;
3853 -> 3852;
3853 -> 3805;
3853 -> 3851;
3854 -> 3853;
3854 -> 3839;
3855 -> 3854;
3855 -> 3805;
3855 -> 3841;
3855 -> 3839;
3856 -> 3840;
3856 -> 3841;
3856 -> 3839;
3857 -> 3810;
3857 -> 3793;
3857 -> 3789;
3858 -> 3788;
3858 -> 3780;
3859 -> 3858;
3859 -> 3805;
3859 -> 3806;
3859 -> 3808;
3859 -> 3857;
3859 -> 3807;
3859 -> 3850;
3859 -> 3855;
3859 -> 3856;
3859 -> 3780;
3860 -> 3780;
3861 -> 3860;
3862 -> 3783;
3862 -> 3860;
3863 -> 3860;
3864 -> 3862;
3864 -> 3863;
3864 -> 3860;
3865 -> 3783;
3865 -> 3860;
3866 -> 3859;
3866 -> 3860;
3867 -> 3862;
3867 -> 3860;
3868 -> 3865;
3868 -> 3866;
3868 -> 3867;
3868 -> 3859;
3868 -> 3860;
3869 -> 3788;
3869 -> 3868;
3870 -> 3728;
3870 -> 3727;
3871 -> 3727;
3872 -> 3870;
3872 -> 3871;
3873 -> 3731;
3873 -> 3871;
3874 -> 3731;
3874 -> 3871;
3875 -> 3869;
3875 -> 3871;
3876 -> 3872;
3876 -> 3868;
3876 -> 3871;
3877 -> 3871;
3878 -> 3875;
3878 -> 3877;
3879 -> 3878;
3879 -> 3868;
3879 -> 3771;
3879 -> 0;
3879 -> 3877;
3880 -> 3879;
3880 -> 3871;
3881 -> 3871;
3882 -> 3872;
3882 -> 3868;
3882 -> 3881;
3882 -> 3871;
3883 -> 3880;
3883 -> 3882;
3883 -> 3871;
3884 -> 3872;
3884 -> 3868;
3884 -> 3883;
3885 -> 3884;
3885 -> 3871;
3886 -> 3876;
3886 -> 3871;
3887 -> 3873;
3887 -> 3871;
3888 -> 3874;
3888 -> 3871;
3889 -> 3871;
3890 -> 3885;
3890 -> 3889;
3891 -> 3886;
3891 -> 3889;
3892 -> 3887;
3892 -> 3889;
3893 -> 3888;
3893 -> 3889;
3894 -> 3875;
3894 -> 3889;
3895 -> 3889;
3896 -> 3890;
3896 -> 3895;
3896 -> 3889;
3897 -> 3893;
3897 -> 3889;
3898 -> 3894;
3898 -> 3868;
3898 -> 3889;
3899 -> 3894;
3899 -> 3868;
3899 -> 3771;
3899 -> 3889;
3900 -> 3889;
3901 -> 3899;
3901 -> 3900;
3902 -> 3898;
3902 -> 3900;
3903 -> 3900;
3904 -> 3903;
3904 -> 3900;
3905 -> 3903;
3905 -> 3900;
3906 -> 3903;
3906 -> 3900;
3907 -> 3903;
3907 -> 3900;
3908 -> 3901;
3908 -> 3903;
3908 -> 3900;
3909 -> 3899;
3909 -> 3898;
3909 -> 3903;
3909 -> 3904;
3909 -> 3905;
3909 -> 3906;
3909 -> 3907;
3909 -> 3908;
3909 -> 3889;
3910 -> 3891;
3910 -> 3889;
3911 -> 3892;
3911 -> 3889;
3912 -> 3893;
3912 -> 3889;
3913 -> 3889;
3914 -> 3910;
3914 -> 3913;
3915 -> 3911;
3915 -> 3913;
3916 -> 3912;
3916 -> 3913;
3917 -> 3909;
3917 -> 3913;
3918 -> 3913;
3919 -> 3913;
3920 -> 3915;
3920 -> 3919;
3921 -> 3918;
3921 -> 3919;
3922 -> 3921;
3922 -> 3919;
3923 -> 3920;
3923 -> 3922;
3924 -> 3915;
3924 -> 3918;
3924 -> 3913;
3925 -> 3916;
3925 -> 3918;
3925 -> 3913;
3926 -> 3924;
3926 -> 3925;
3926 -> 3913;
3927 -> 3914;
3927 -> 3917;
3927 -> 3913;
3928 -> 3915;
3928 -> 3917;
3928 -> 3913;
3929 -> 3916;
3929 -> 3917;
3929 -> 3913;
3930 -> 3889;
3931 -> 3890;
3931 -> 3889;
3932 -> 3889;
3933 -> 3931;
3933 -> 3932;
3934 -> 3909;
3934 -> 3932;
3935 -> 3933;
3935 -> 3932;
3936 -> 3932;
3937 -> 3935;
3937 -> 3936;
3938 -> 3934;
3938 -> 3936;
3939 -> 3938;
3939 -> 3936;
3940 -> 3939;
3940 -> 3937;
3940 -> 3909;
3940 -> 3927;
3940 -> 3928;
3940 -> 3929;
3940 -> 3936;
3941 -> 3936;
3942 -> 3940;
3942 -> 3941;
3943 -> 3940;
3943 -> 3941;
3944 -> 3942;
3944 -> 3941;
3945 -> 3941;
3946 -> 3944;
3946 -> 3945;
3947 -> 3943;
3947 -> 3945;
3948 -> 3947;
3948 -> 3940;
3948 -> 3945;
3949 -> 3946;
3949 -> 3945;
3950 -> 3948;
3950 -> 3949;
3950 -> 3940;
3950 -> 3945;
3951 -> 0;
3951 -> 3945;
3952 -> 3945;
3953 -> 3946;
3953 -> 3950;
3953 -> 3952;
3953 -> 3945;
3954 -> 3947;
3954 -> 3950;
3954 -> 3945;
3955 -> 3946;
3955 -> 3950;
3955 -> 3945;
3956 -> 0;
3956 -> 3953;
3957 -> 3946;
3957 -> 3945;
3958 -> 3956;
3958 -> 3945;
3959 -> 3945;
3960 -> 3957;
3960 -> 3959;
3961 -> 3958;
3961 -> 3959;
3962 -> 3947;
3962 -> 3959;
3963 -> 3960;
3963 -> 3959;
3964 -> 3961;
3964 -> 3959;
3965 -> 3959;
3966 -> 3963;
3966 -> 3965;
3967 -> 3964;
3967 -> 3965;
3968 -> 3967;
3968 -> 3965;
3969 -> 3965;
3970 -> 3966;
3970 -> 3965;
3971 -> 3967;
3971 -> 3965;
3972 -> 3965;
3973 -> 3965;
3974 -> 3970;
3974 -> 3973;
3975 -> 3971;
3975 -> 3973;
3976 -> 3972;
3976 -> 3973;
3977 -> 3974;
3977 -> 3976;
3977 -> 3973;
3978 -> 3975;
3978 -> 3976;
3978 -> 3973;
3979 -> 3972;
3979 -> 3959;
3980 -> 3959;
3981 -> 3959;
3982 -> 3962;
3982 -> 3981;
3983 -> 3982;
3983 -> 3954;
3983 -> 3981;
3984 -> 3983;
3984 -> 3959;
3985 -> 3979;
3985 -> 3959;
3986 -> 3980;
3986 -> 3959;
3987 -> 3985;
3987 -> 3986;
3987 -> 3984;
3987 -> 3977;
3987 -> 3978;
3987 -> 3954;
3987 -> 3959;
3988 -> 3959;
3989 -> 3987;
3989 -> 3988;
3990 -> 3989;
3990 -> 3987;
3990 -> 3988;
3991 -> 3960;
3991 -> 3990;
3992 -> 3990;
3993 -> 3991;
3993 -> 3992;
3994 -> 3993;
3994 -> 3992;
3995 -> 3993;
3995 -> 3992;
3996 -> 3994;
3996 -> 3992;
3997 -> 3992;
3998 -> 3996;
3998 -> 3997;
3999 -> 3995;
3999 -> 3997;
4000 -> 3998;
4000 -> 3993;
4000 -> 3997;
4001 -> 3997;
4002 -> 4001;
4002 -> 3997;
4003 -> 3998;
4003 -> 3993;
4003 -> 3997;
4004 -> 3999;
4004 -> 4003;
4004 -> 4000;
4004 -> 3993;
4005 -> 3999;
4005 -> 4003;
4005 -> 4004;
4006 -> 4004;
4007 -> 4005;
4007 -> 3997;
4008 -> 3997;
4009 -> 4007;
4009 -> 4008;
4009 -> 3997;
4010 -> 4007;
4010 -> 3998;
4010 -> 3997;
4011 -> 4007;
4011 -> 4009;
4012 -> 0;
4012 -> 4009;
4013 -> 4007;
4013 -> 4011;
4013 -> 4009;
4014 -> 3997;
4015 -> 4014;
4015 -> 3992;
4016 -> 3992;
4017 -> 3995;
4017 -> 4016;
4018 -> 4016;
4019 -> 4017;
4019 -> 4013;
4019 -> 4018;
4020 -> 4019;
4020 -> 4016;
4021 -> 3992;
4022 -> 3996;
4022 -> 4021;
4023 -> 4015;
4023 -> 4021;
4024 -> 4020;
4024 -> 4021;
4025 -> 3995;
4025 -> 4021;
4026 -> 4021;
4027 -> 4025;
4027 -> 4026;
4028 -> 4027;
4028 -> 4013;
4028 -> 4026;
4029 -> 4028;
4029 -> 4021;
4030 -> 4021;
4031 -> 4022;
4031 -> 4029;
4031 -> 4021;
4032 -> 4023;
4032 -> 4021;
4033 -> 4024;
4033 -> 4032;
4034 -> 0;
4034 -> 4033;
4035 -> 4022;
4035 -> 4021;
4036 -> 4034;
4036 -> 4021;
4037 -> 4021;
4038 -> 4035;
4038 -> 4037;
4039 -> 4036;
4039 -> 4037;
4040 -> 4039;
4040 -> 4037;
4041 -> 4037;
4042 -> 4037;
4042 -> 4021;
4043 -> 4021;
4044 -> 4021;
4045 -> 4025;
4045 -> 4044;
4046 -> 4045;
4046 -> 4013;
4046 -> 4044;
4047 -> 4046;
4047 -> 4021;
4048 -> 4042;
4048 -> 4021;
4049 -> 4043;
4049 -> 4021;
4050 -> 4048;
4050 -> 4049;
4050 -> 4047;
4050 -> 4038;
4050 -> 4039;
4050 -> 4013;
4050 -> 4021;
4051 -> 4021;
4052 -> 4050;
4053 -> 4025;
4053 -> 4052;
4054 -> 4053;
4054 -> 4050;
4054 -> 4052;
4055 -> 4054;
4055 -> 4050;
4056 -> 4024;
4056 -> 4050;
4057 -> 4056;
4058 -> 4025;
4058 -> 4057;
4059 -> 4058;
4059 -> 4050;
4059 -> 4057;
4060 -> 4059;
4060 -> 4056;
4061 -> 4056;
4062 -> 4060;
4062 -> 4061;
4063 -> 4062;
4063 -> 4050;
4063 -> 4061;
4064 -> 4063;
4065 -> 4064;
4065 -> 4063;
4066 -> 4063;
4067 -> 4065;
4067 -> 4066;
4068 -> 4062;
4068 -> 4066;
4069 -> 4066;
4070 -> 4068;
4070 -> 4069;
4071 -> 4070;
4071 -> 4050;
4071 -> 4069;
4072 -> 4071;
4072 -> 4069;
4073 -> 4070;
4073 -> 4066;
4074 -> 4066;
4075 -> 4073;
4075 -> 4074;
4076 -> 4067;
4076 -> 4075;
4076 -> 4064;
4076 -> 4070;
4076 -> 4066;
4077 -> 4066;
4078 -> 4068;
4078 -> 4077;
4079 -> 4078;
4079 -> 4076;
4079 -> 4077;
4080 -> 4078;
4080 -> 4076;
4080 -> 4077;
4081 -> 4080;
4081 -> 4066;
4082 -> 4066;
4083 -> 4082;
4083 -> 4081;
4083 -> 4076;
4083 -> 4066;
4084 -> 4082;
4084 -> 4083;
4085 -> 4081;
4085 -> 4084;
4085 -> 4082;
4086 -> 4084;
4087 -> 4085;
4087 -> 4086;
4088 -> 4063;
4089 -> 4062;
4089 -> 4063;
4090 -> 4063;
4091 -> 4063;
4092 -> 4089;
4092 -> 4091;
4093 -> 4090;
4093 -> 4091;
4094 -> 0;
4094 -> 4093;
4094 -> 4091;
4095 -> 4092;
4095 -> 4093;
4095 -> 4091;
4096 -> 4090;
4096 -> 4064;
4096 -> 4087;
4096 -> 4063;
4097 -> 4096;
4097 -> 4090;
4098 -> 4097;
4098 -> 4090;
4099 -> 4096;
4099 -> 4090;
4100 -> 4099;
4100 -> 4098;
4100 -> 4090;
4101 -> 4063;
4102 -> 4090;
4102 -> 4101;
4103 -> 4090;
4103 -> 4101;
4104 -> 4100;
4104 -> 4101;
4105 -> 4090;
4105 -> 4101;
4106 -> 4101;
4107 -> 4104;
4107 -> 4100;
4107 -> 4106;
4107 -> 4101;
4108 -> 4101;
4109 -> 4104;
4109 -> 4100;
4109 -> 4108;
4109 -> 4101;
4110 -> 4109;
4110 -> 4101;
4111 -> 4102;
4111 -> 4110;
4112 -> 4103;
4112 -> 4110;
4113 -> 4105;
4113 -> 4110;
4114 -> 4110;
4115 -> 4111;
4115 -> 4114;
4116 -> 4112;
4116 -> 4114;
4117 -> 4110;
4117 -> 4114;
4118 -> 4113;
4118 -> 4114;
4119 -> 4110;
4119 -> 4114;
4120 -> 4114;
4121 -> 4119;
4121 -> 4114;
4122 -> 4119;
4122 -> 4114;
4123 -> 4119;
4123 -> 4114;
4124 -> 4115;
4124 -> 4119;
4124 -> 4114;
4125 -> 4117;
4125 -> 4119;
4125 -> 4114;
4126 -> 4116;
4126 -> 4119;
4126 -> 4114;
4127 -> 4119;
4127 -> 4114;
4128 -> 0;
4128 -> 4114;
4129 -> 4127;
4129 -> 4119;
4129 -> 4114;
4130 -> 4118;
4130 -> 4119;
4130 -> 4114;
4131 -> 4117;
4131 -> 4114;
4132 -> 4131;
4133 -> 4131;
4133 -> 4132;
4134 -> 4133;
4134 -> 4132;
4135 -> 4134;
4135 -> 4131;
4136 -> 4131;
4137 -> 4064;
4137 -> 4100;
4137 -> 4063;
4138 -> 4062;
4138 -> 4137;
4138 -> 4063;
4139 -> 4110;
4139 -> 4063;
4140 -> 4063;
4141 -> 4138;
4141 -> 4139;
4141 -> 4140;
4141 -> 4119;
4141 -> 4126;
4141 -> 4130;
4141 -> 4129;
4141 -> 4124;
4141 -> 4125;
4141 -> 4137;
4141 -> 4094;
4141 -> 4095;
4141 -> 4100;
4141 -> 4127;
4141 -> 4063;
4142 -> 4062;
4142 -> 4141;
4142 -> 4061;
4143 -> 4055;
4143 -> 4056;
4144 -> 4022;
4144 -> 4056;
4145 -> 4023;
4145 -> 4056;
4146 -> 4056;
4147 -> 4056;
4148 -> 4142;
4148 -> 4147;
4149 -> 4143;
4149 -> 4147;
4150 -> 4144;
4150 -> 4147;
4151 -> 4145;
4151 -> 4147;
4152 -> 4146;
4152 -> 4147;
4153 -> 4149;
4153 -> 4147;
4154 -> 4147;
4155 -> 4153;
4155 -> 4154;
4156 -> 4152;
4156 -> 4154;
4157 -> 4154;
4158 -> 4154;
4159 -> 4155;
4159 -> 4158;
4159 -> 4154;
4160 -> 4155;
4160 -> 4156;
4160 -> 4154;
4161 -> 4155;
4161 -> 4141;
4161 -> 4156;
4161 -> 4154;
4162 -> 4155;
4162 -> 4141;
4162 -> 4156;
4162 -> 4154;
4163 -> 4157;
4163 -> 4156;
4163 -> 4154;
4164 -> 4152;
4164 -> 4147;
4165 -> 4152;
4165 -> 4147;
4166 -> 4152;
4166 -> 4147;
4167 -> 4152;
4167 -> 4147;
4168 -> 4152;
4168 -> 4147;
4169 -> 4147;
4170 -> 4148;
4170 -> 4169;
4170 -> 4147;
4171 -> 4147;
4172 -> 4150;
4172 -> 4171;
4172 -> 4147;
4173 -> 4148;
4173 -> 4152;
4173 -> 4147;
4174 -> 4150;
4174 -> 4152;
4174 -> 4151;
4174 -> 4147;
4175 -> 4174;
4175 -> 4152;
4175 -> 4147;
4176 -> 4151;
4176 -> 4147;
4177 -> 4150;
4177 -> 4141;
4177 -> 4176;
4178 -> 4150;
4178 -> 4177;
4179 -> 4178;
4179 -> 4177;
4179 -> 4152;
4180 -> 4056;
4181 -> 4025;
4181 -> 4180;
4182 -> 4181;
4182 -> 4177;
4182 -> 4180;
4183 -> 4182;
4183 -> 4056;
4184 -> 4022;
4184 -> 4056;
4185 -> 4056;
4186 -> 4056;
4187 -> 4183;
4187 -> 4186;
4188 -> 4184;
4188 -> 4186;
4189 -> 4185;
4189 -> 4186;
4190 -> 4187;
4190 -> 4186;
4191 -> 4186;
4192 -> 4190;
4192 -> 4191;
4193 -> 4191;
4194 -> 4192;
4194 -> 4193;
4195 -> 4194;
4195 -> 4193;
4196 -> 4194;
4196 -> 4191;
4197 -> 4191;
4198 -> 4196;
4198 -> 4197;
4199 -> 0;
4199 -> 4191;
4200 -> 4191;
4201 -> 4199;
4201 -> 4200;
4202 -> 4198;
4202 -> 4200;
4203 -> 4202;
4203 -> 4186;
4204 -> 4203;
4205 -> 4050;
4206 -> 4205;
4206 -> 4202;
4207 -> 4206;
4207 -> 4050;
4208 -> 4042;
4208 -> 4050;
4209 -> 4146;
4209 -> 4050;
4210 -> 4208;
4210 -> 4209;
4210 -> 4207;
4210 -> 4038;
4210 -> 4039;
4210 -> 4162;
4210 -> 4161;
4210 -> 4160;
4210 -> 4163;
4210 -> 4156;
4210 -> 4173;
4210 -> 4175;
4210 -> 4166;
4210 -> 4167;
4210 -> 4168;
4210 -> 4179;
4210 -> 4202;
4210 -> 4174;
4210 -> 4177;
4210 -> 4050;
4211 -> 4050;
4212 -> 4146;
4212 -> 4021;
4213 -> 3993;
4213 -> 4212;
4213 -> 4210;
4213 -> 3992;
4214 -> 3961;
4214 -> 4034;
4214 -> 3990;
4215 -> 4214;
4216 -> 4213;
4216 -> 4215;
4217 -> 4216;
4217 -> 4213;
4217 -> 4215;
4218 -> 4215;
4219 -> 4217;
4219 -> 4218;
4219 -> 4215;
4220 -> 4219;
4220 -> 4215;
4221 -> 4220;
4222 -> 4220;
4222 -> 4221;
4223 -> 4217;
4223 -> 4221;
4224 -> 4223;
4224 -> 4213;
4224 -> 4221;
4225 -> 4222;
4225 -> 4224;
4226 -> 4224;
4227 -> 4225;
4227 -> 4226;
4228 -> 4224;
4228 -> 4226;
4229 -> 4226;
4230 -> 4227;
4230 -> 4229;
4230 -> 4226;
4231 -> 4226;
4232 -> 4228;
4232 -> 4231;
4233 -> 4231;
4234 -> 4232;
4234 -> 4233;
4235 -> 0;
4235 -> 4233;
4236 -> 4235;
4236 -> 4231;
4237 -> 4232;
4237 -> 4226;
4238 -> 4227;
4238 -> 4237;
4238 -> 4226;
4239 -> 4224;
4239 -> 4238;
4240 -> 4239;
4240 -> 4214;
4241 -> 3960;
4241 -> 4214;
4242 -> 4214;
4243 -> 4241;
4243 -> 4242;
4244 -> 4240;
4244 -> 4242;
4245 -> 4243;
4245 -> 4213;
4245 -> 4242;
4246 -> 4243;
4246 -> 4242;
4247 -> 4242;
4248 -> 4245;
4248 -> 4247;
4249 -> 4245;
4249 -> 4247;
4250 -> 4245;
4250 -> 4247;
4251 -> 4246;
4251 -> 4247;
4252 -> 4244;
4252 -> 4247;
4253 -> 4250;
4253 -> 4247;
4254 -> 4247;
4255 -> 4253;
4255 -> 4254;
4256 -> 4248;
4256 -> 4247;
4257 -> 4249;
4257 -> 4247;
4258 -> 4247;
4259 -> 4256;
4259 -> 4258;
4260 -> 4257;
4260 -> 4258;
4261 -> 4252;
4261 -> 4258;
4262 -> 4259;
4262 -> 4258;
4263 -> 4258;
4264 -> 4262;
4264 -> 4263;
4265 -> 4261;
4265 -> 4263;
4266 -> 4265;
4266 -> 4245;
4266 -> 4263;
4267 -> 4265;
4267 -> 4245;
4267 -> 4263;
4268 -> 4267;
4268 -> 4264;
4268 -> 4263;
4268 -> 4245;
4269 -> 4258;
4270 -> 4260;
4270 -> 4258;
4271 -> 4268;
4271 -> 4269;
4271 -> 4270;
4271 -> 4258;
4272 -> 4271;
4272 -> 4269;
4273 -> 4272;
4273 -> 4271;
4273 -> 4269;
4274 -> 4273;
4275 -> 4273;
4276 -> 4274;
4276 -> 4275;
4276 -> 4273;
4277 -> 4273;
4278 -> 4274;
4278 -> 4277;
4279 -> 4277;
4280 -> 4278;
4280 -> 4273;
4280 -> 4279;
4281 -> 4280;
4281 -> 4273;
4281 -> 3330;
4281 -> 4279;
4282 -> 4281;
4282 -> 3351;
4282 -> 4279;
4283 -> 4282;
4283 -> 4277;
4284 -> 4283;
4284 -> 4273;
4285 -> 4284;
4285 -> 4255;
4285 -> 4273;
4286 -> 4285;
4287 -> 4251;
4287 -> 4286;
4287 -> 4285;
4288 -> 4287;
4289 -> 4288;
4289 -> 4287;
4290 -> 4289;
4290 -> 4288;
4290 -> 4251;
4291 -> 4289;
4291 -> 4288;
4292 -> 4274;
4292 -> 4290;
4293 -> 3961;
4293 -> 0;
4293 -> 4214;
4294 -> 4292;
4294 -> 4293;
4295 -> 4213;
4295 -> 4293;
4296 -> 4293;
4297 -> 4293;
4298 -> 4294;
4298 -> 4297;
4299 -> 4295;
4299 -> 4297;
4300 -> 4296;
4300 -> 4297;
4301 -> 4296;
4301 -> 4297;
4302 -> 4299;
4302 -> 4297;
4303 -> 4297;
4304 -> 4302;
4304 -> 4303;
4305 -> 4301;
4305 -> 4303;
4306 -> 4303;
4307 -> 4303;
4308 -> 4304;
4308 -> 4307;
4308 -> 4303;
4309 -> 4304;
4309 -> 4291;
4309 -> 4305;
4309 -> 4303;
4310 -> 4304;
4310 -> 4291;
4310 -> 4305;
4310 -> 4303;
4311 -> 4306;
4311 -> 4305;
4311 -> 4303;
4312 -> 4301;
4312 -> 4297;
4313 -> 4301;
4313 -> 4297;
4314 -> 4301;
4314 -> 4297;
4315 -> 4301;
4315 -> 4297;
4316 -> 4301;
4316 -> 4297;
4317 -> 4297;
4318 -> 4298;
4318 -> 4317;
4318 -> 4297;
4319 -> 4298;
4319 -> 4301;
4319 -> 4297;
4321 -> 0;
4322 -> 0;
4323 -> 0;
4326 -> 4320;
4326 -> 4325;
4327 -> 4321;
4327 -> 4325;
4328 -> 4322;
4328 -> 4325;
4329 -> 4323;
4329 -> 4325;
4330 -> 4324;
4330 -> 4325;
4331 -> 4325;
4332 -> 4331;
4332 -> 4325;
4333 -> 4331;
4333 -> 4325;
4334 -> 4331;
4334 -> 4325;
4335 -> 4325;
4336 -> 4327;
4336 -> 4335;
4336 -> 4325;
4337 -> 4328;
4337 -> 0;
4337 -> 4325;
4338 -> 4329;
4338 -> 0;
4338 -> 4325;
4339 -> 4326;
4339 -> 4331;
4339 -> 4325;
4340 -> 4327;
4340 -> 4331;
4340 -> 4325;
4341 -> 4328;
4341 -> 4331;
4341 -> 4325;
4342 -> 4330;
4342 -> 4331;
4342 -> 4325;
4343 -> 4329;
4343 -> 4331;
4343 -> 4325;
4344 -> 4325;
4345 -> 4344;
4345 -> 4297;
4346 -> 4345;
4346 -> 4300;
4346 -> 4297;
4347 -> 4346;
4347 -> 4301;
4347 -> 4297;
4348 -> 4293;
4349 -> 3960;
4349 -> 4291;
4349 -> 4348;
4349 -> 4293;
4350 -> 3960;
4350 -> 4291;
4350 -> 3990;
4351 -> 3990;
4352 -> 4350;
4352 -> 4351;
4353 -> 4296;
4353 -> 4351;
4354 -> 4353;
4354 -> 4309;
4354 -> 4351;
4355 -> 0;
4355 -> 4351;
4356 -> 4351;
4357 -> 4354;
4357 -> 4356;
4358 -> 4355;
4358 -> 4356;
4359 -> 4357;
4359 -> 4358;
4359 -> 4356;
4360 -> 4352;
4360 -> 4351;
4361 -> 4359;
4361 -> 4360;
4361 -> 4351;
4362 -> 4361;
4362 -> 4351;
4363 -> 3990;
4364 -> 4363;
4364 -> 4360;
4365 -> 4364;
4365 -> 3990;
4366 -> 3979;
4366 -> 3990;
4367 -> 4362;
4367 -> 3990;
4368 -> 4366;
4368 -> 4367;
4368 -> 4365;
4368 -> 3977;
4368 -> 3978;
4368 -> 4310;
4368 -> 4309;
4368 -> 4304;
4368 -> 4311;
4368 -> 4305;
4368 -> 4319;
4368 -> 4313;
4368 -> 4347;
4368 -> 4315;
4368 -> 4316;
4368 -> 4360;
4368 -> 4273;
4368 -> 4339;
4368 -> 4342;
4368 -> 4340;
4368 -> 4341;
4368 -> 4343;
4368 -> 0;
4368 -> 3990;
4369 -> 3990;
4370 -> 4362;
4370 -> 3959;
4371 -> 3940;
4371 -> 4370;
4371 -> 4368;
4371 -> 3936;
4372 -> 3909;
4372 -> 3889;
4373 -> 3894;
4373 -> 4371;
4373 -> 4372;
4373 -> 3889;
4374 -> 4371;
4374 -> 3889;
4375 -> 3697;
4376 -> 3697;
4377 -> 3702;
4377 -> 4376;
4378 -> 4376;
4379 -> 4377;
4379 -> 4378;
4380 -> 4378;
4380 -> 4376;
4381 -> 4377;
4381 -> 4376;
4382 -> 4376;
4383 -> 4381;
4383 -> 4382;
4384 -> 4383;
4384 -> 4373;
4384 -> 4382;
4385 -> 4376;
4386 -> 4384;
4386 -> 3697;
4387 -> 3700;
4387 -> 3697;
4388 -> 4387;
4388 -> 4373;
4388 -> 3697;
4389 -> 4388;
4390 -> 4388;
4390 -> 4373;
4391 -> 4388;
4391 -> 4373;
4392 -> 4388;
4392 -> 4391;
4393 -> 4391;
4394 -> 3702;
4394 -> 4393;
4395 -> 4393;
4396 -> 4394;
4396 -> 4391;
4396 -> 4395;
4396 -> 4393;
4397 -> 4396;
4397 -> 4391;
4398 -> 4391;
4399 -> 3702;
4399 -> 4391;
4400 -> 4391;
4401 -> 4392;
4401 -> 4396;
4401 -> 4400;
4401 -> 4391;
4402 -> 3701;
4402 -> 4391;
4403 -> 4398;
4403 -> 4391;
4404 -> 4391;
4405 -> 4399;
4405 -> 4404;
4406 -> 4401;
4406 -> 4404;
4407 -> 4401;
4407 -> 4404;
4408 -> 4402;
4408 -> 4404;
4409 -> 4403;
4409 -> 4404;
4410 -> 4404;
4411 -> 4405;
4411 -> 4410;
4412 -> 4410;
4413 -> 4411;
4413 -> 4412;
4414 -> 4413;
4414 -> 4401;
4414 -> 4412;
4415 -> 4414;
4415 -> 4410;
4416 -> 4415;
4416 -> 4404;
4417 -> 4416;
4417 -> 4404;
4418 -> 0;
4418 -> 4404;
4419 -> 4406;
4419 -> 4404;
4420 -> 4407;
4420 -> 4404;
4421 -> 4417;
4421 -> 4404;
4422 -> 4418;
4422 -> 4404;
4423 -> 4419;
4423 -> 4404;
4424 -> 4408;
4424 -> 4404;
4425 -> 4409;
4425 -> 4404;
4426 -> 4404;
4427 -> 4420;
4427 -> 4426;
4428 -> 4421;
4428 -> 4426;
4429 -> 4422;
4429 -> 4426;
4430 -> 4423;
4430 -> 4426;
4431 -> 4424;
4431 -> 4426;
4432 -> 4425;
4432 -> 4426;
4433 -> 4427;
4433 -> 4426;
4434 -> 4431;
4434 -> 4426;
4435 -> 4426;
4436 -> 4433;
4436 -> 4435;
4437 -> 4434;
4437 -> 4435;
4438 -> 4435;
4439 -> 4435;
4440 -> 4436;
4440 -> 4401;
4440 -> 4419;
4441 -> 4436;
4442 -> 4440;
4442 -> 4436;
4443 -> 4435;
4443 -> 4436;
4444 -> 4438;
4444 -> 4436;
4445 -> 4439;
4445 -> 4436;
4446 -> 4437;
4446 -> 4436;
4447 -> 4436;
4448 -> 4441;
4448 -> 4447;
4449 -> 4442;
4449 -> 4447;
4450 -> 4443;
4450 -> 4447;
4451 -> 4444;
4451 -> 4447;
4452 -> 4445;
4452 -> 4447;
4453 -> 4446;
4453 -> 4447;
4454 -> 4450;
4454 -> 4449;
4454 -> 4447;
4455 -> 4447;
4456 -> 4440;
4456 -> 0;
4456 -> 4435;
4457 -> 4440;
4457 -> 4426;
4458 -> 4429;
4458 -> 4426;
4459 -> 4430;
4459 -> 4426;
4460 -> 4431;
4460 -> 4426;
4461 -> 4427;
4461 -> 4426;
4462 -> 4432;
4462 -> 4426;
4463 -> 4426;
4464 -> 4457;
4464 -> 4463;
4465 -> 4458;
4465 -> 4463;
4466 -> 4459;
4466 -> 4463;
4467 -> 4460;
4467 -> 4463;
4468 -> 4461;
4468 -> 4463;
4469 -> 4462;
4469 -> 4463;
4470 -> 4463;
4471 -> 4464;
4471 -> 4465;
4471 -> 4463;
4472 -> 4464;
4472 -> 4465;
4472 -> 4463;
4473 -> 4471;
4473 -> 0;
4473 -> 4463;
4474 -> 4472;
4474 -> 0;
4474 -> 4463;
4475 -> 4463;
4476 -> 4472;
4476 -> 4463;
4477 -> 4476;
4477 -> 0;
4477 -> 4426;
4478 -> 4426;
4479 -> 4476;
4479 -> 4426;
4480 -> 4479;
4480 -> 0;
4480 -> 4404;
4481 -> 4404;
4482 -> 4479;
4482 -> 0;
4482 -> 4404;
4483 -> 4404;
4484 -> 4479;
4484 -> 0;
4484 -> 4404;
4485 -> 4404;
4486 -> 4405;
4486 -> 4484;
4487 -> 4479;
4487 -> 4484;
4488 -> 4419;
4488 -> 4484;
4489 -> 4408;
4489 -> 4484;
4490 -> 4484;
4491 -> 4486;
4491 -> 4490;
4492 -> 4487;
4492 -> 4490;
4493 -> 4488;
4493 -> 4490;
4494 -> 4489;
4494 -> 4490;
4495 -> 4492;
4495 -> 0;
4495 -> 4490;
4496 -> 4484;
4497 -> 4479;
4497 -> 4404;
4498 -> 4392;
4498 -> 4440;
4498 -> 4391;
4499 -> 4497;
4499 -> 0;
4499 -> 4498;
4500 -> 4498;
4501 -> 4499;
4501 -> 4498;
4502 -> 4470;
4502 -> 4501;
4503 -> 3701;
4503 -> 4501;
4504 -> 4501;
4505 -> 4501;
4505 -> 4504;
4506 -> 4501;
4506 -> 4504;
4507 -> 4501;
4507 -> 4504;
4508 -> 4502;
4508 -> 4504;
4509 -> 4503;
4509 -> 4504;
4510 -> 4501;
4510 -> 4504;
4511 -> 4505;
4511 -> 4504;
4512 -> 4507;
4512 -> 4504;
4513 -> 4506;
4513 -> 4440;
4513 -> 4504;
4514 -> 4506;
4514 -> 4440;
4514 -> 4504;
4515 -> 4506;
4515 -> 4514;
4515 -> 4504;
4516 -> 4504;
4517 -> 4515;
4517 -> 4516;
4518 -> 4515;
4518 -> 4516;
4519 -> 4515;
4519 -> 4516;
4520 -> 4515;
4520 -> 4516;
4521 -> 4515;
4521 -> 4516;
4522 -> 4515;
4522 -> 4516;
4523 -> 4517;
4523 -> 4516;
4524 -> 4519;
4524 -> 4516;
4525 -> 4520;
4525 -> 4516;
4526 -> 4521;
4526 -> 4516;
4527 -> 4516;
4528 -> 4523;
4528 -> 4527;
4529 -> 4524;
4529 -> 4527;
4530 -> 4525;
4530 -> 4527;
4531 -> 4526;
4531 -> 4527;
4532 -> 4522;
4532 -> 4527;
4533 -> 4528;
4533 -> 4527;
4534 -> 4527;
4535 -> 4533;
4535 -> 4534;
4536 -> 4532;
4536 -> 4534;
4537 -> 4534;
4538 -> 4536;
4538 -> 4537;
4539 -> 4537;
4540 -> 4538;
4540 -> 4539;
4541 -> 4539;
4542 -> 4540;
4542 -> 4539;
4543 -> 4538;
4543 -> 4537;
4544 -> 4536;
4544 -> 4534;
4545 -> 4534;
4546 -> 4535;
4546 -> 4545;
4546 -> 4534;
4547 -> 4535;
4547 -> 4536;
4547 -> 4534;
4548 -> 4532;
4548 -> 4527;
4549 -> 4532;
4549 -> 4527;
4550 -> 4532;
4550 -> 4527;
4551 -> 4532;
4551 -> 4527;
4552 -> 4532;
4552 -> 4527;
4553 -> 0;
4553 -> 4532;
4553 -> 4527;
4554 -> 0;
4554 -> 4532;
4554 -> 4527;
4555 -> 4527;
4556 -> 4529;
4556 -> 4555;
4556 -> 4527;
4557 -> 4527;
4558 -> 4530;
4558 -> 4557;
4558 -> 4527;
4559 -> 4527;
4560 -> 4531;
4560 -> 4559;
4560 -> 4527;
4561 -> 4529;
4561 -> 4532;
4561 -> 4527;
4562 -> 4530;
4562 -> 4532;
4562 -> 4527;
4563 -> 4531;
4563 -> 4532;
4563 -> 4527;
4564 -> 4522;
4564 -> 4516;
4565 -> 4518;
4565 -> 4522;
4565 -> 4516;
4566 -> 4515;
4566 -> 4540;
4566 -> 4542;
4566 -> 4543;
4566 -> 4547;
4566 -> 4561;
4566 -> 4563;
4566 -> 4562;
4566 -> 4551;
4566 -> 4552;
4566 -> 4553;
4566 -> 4554;
4566 -> 4565;
4566 -> 0;
4566 -> 4504;
4567 -> 4506;
4567 -> 4566;
4567 -> 4504;
4568 -> 4504;
4569 -> 4568;
4569 -> 4511;
4569 -> 4512;
4569 -> 4513;
4569 -> 4514;
4569 -> 4567;
4569 -> 4504;
4570 -> 4568;
4570 -> 4504;
4571 -> 4568;
4571 -> 4504;
4572 -> 4568;
4572 -> 4504;
4573 -> 4504;
4574 -> 4506;
4574 -> 4569;
4574 -> 4573;
4574 -> 4504;
4575 -> 4574;
4575 -> 4568;
4575 -> 4504;
4576 -> 4509;
4576 -> 4504;
4577 -> 4504;
4578 -> 4576;
4578 -> 4577;
4579 -> 4568;
4579 -> 4577;
4580 -> 4577;
4581 -> 4579;
4581 -> 4580;
4582 -> 4581;
4582 -> 4569;
4582 -> 4580;
4583 -> 4582;
4583 -> 4577;
4584 -> 4579;
4584 -> 4577;
4585 -> 4577;
4586 -> 4577;
4587 -> 4583;
4587 -> 4586;
4588 -> 4584;
4588 -> 4586;
4589 -> 4585;
4589 -> 4586;
4590 -> 4587;
4590 -> 4586;
4591 -> 4586;
4592 -> 4590;
4592 -> 4591;
4593 -> 4592;
4593 -> 0;
4593 -> 4591;
4594 -> 4593;
4595 -> 4586;
4596 -> 4588;
4596 -> 4595;
4597 -> 0;
4597 -> 4595;
4598 -> 4597;
4598 -> 4586;
4599 -> 4589;
4599 -> 4598;
4599 -> 4586;
4600 -> 4587;
4600 -> 0;
4600 -> 4586;
4601 -> 4586;
4602 -> 4599;
4602 -> 4600;
4602 -> 4586;
4603 -> 4587;
4603 -> 0;
4603 -> 4602;
4604 -> 4586;
4605 -> 4604;
4605 -> 4577;
4606 -> 4577;
4607 -> 4605;
4607 -> 4606;
4607 -> 4577;
4608 -> 4504;
4609 -> 4508;
4609 -> 4504;
4610 -> 4509;
4610 -> 4609;
4611 -> 4609;
4612 -> 4610;
4612 -> 4611;
4613 -> 4568;
4613 -> 4611;
4614 -> 4611;
4615 -> 4613;
4615 -> 4614;
4616 -> 4615;
4616 -> 4569;
4616 -> 4614;
4617 -> 4616;
4617 -> 4611;
4618 -> 4611;
4619 -> 4617;
4619 -> 4618;
4620 -> 0;
4620 -> 4618;
4621 -> 4618;
4622 -> 4620;
4622 -> 4621;
4623 -> 4619;
4623 -> 4621;
4624 -> 4623;
4624 -> 4569;
4624 -> 4622;
4624 -> 4621;
4625 -> 4621;
4626 -> 4624;
4626 -> 4625;
4626 -> 4621;
4627 -> 4626;
4628 -> 4613;
4628 -> 4627;
4629 -> 4627;
4630 -> 4628;
4630 -> 4629;
4631 -> 4630;
4631 -> 4569;
4631 -> 4629;
4632 -> 4631;
4632 -> 0;
4632 -> 4627;
4633 -> 4627;
4634 -> 4632;
4634 -> 4633;
4634 -> 4627;
4635 -> 4634;
4635 -> 4626;
4636 -> 4635;
4637 -> 4613;
4637 -> 4569;
4637 -> 4636;
4638 -> 0;
4638 -> 4636;
4639 -> 4636;
4640 -> 4638;
4640 -> 4639;
4641 -> 4637;
4641 -> 4639;
4642 -> 4641;
4642 -> 4569;
4642 -> 4640;
4642 -> 4639;
4643 -> 4642;
4643 -> 4635;
4644 -> 4643;
4645 -> 4613;
4645 -> 4644;
4646 -> 4644;
4647 -> 4645;
4647 -> 4646;
4648 -> 4647;
4648 -> 0;
4648 -> 4644;
4649 -> 4644;
4650 -> 4648;
4650 -> 4649;
4650 -> 4644;
4651 -> 4650;
4651 -> 4643;
4652 -> 4643;
4653 -> 4613;
4653 -> 4652;
4654 -> 4652;
4655 -> 4653;
4655 -> 4654;
4656 -> 4655;
4656 -> 0;
4656 -> 4652;
4657 -> 4652;
4658 -> 4656;
4658 -> 4657;
4658 -> 4652;
4659 -> 4658;
4659 -> 4643;
4660 -> 4651;
4660 -> 4659;
4660 -> 4643;
4661 -> 4643;
4662 -> 4613;
4662 -> 4569;
4662 -> 4661;
4663 -> 0;
4663 -> 4661;
4664 -> 4661;
4665 -> 4663;
4665 -> 4664;
4666 -> 4662;
4666 -> 4664;
4667 -> 4666;
4667 -> 4569;
4667 -> 4665;
4667 -> 4664;
4668 -> 4667;
4668 -> 4643;
4669 -> 4660;
4669 -> 4668;
4669 -> 4643;
4670 -> 4609;
4671 -> 4504;
4672 -> 4505;
4672 -> 4671;
4673 -> 4671;
4674 -> 4672;
4674 -> 4673;
4675 -> 4674;
4675 -> 4569;
4675 -> 4673;
4676 -> 4675;
4676 -> 4671;
4677 -> 4676;
4677 -> 4504;
4678 -> 4501;
4678 -> 4498;
4679 -> 3698;
4679 -> 3669;
4679 -> 4678;
4679 -> 3668;
4679 -> 4569;
4679 -> 4570;
4679 -> 4575;
4679 -> 4571;
4679 -> 4572;
4679 -> 4498;
4680 -> 4498;
4681 -> 4501;
4681 -> 4680;
4682 -> 4680;
4683 -> 4681;
4683 -> 4682;
4684 -> 4683;
4684 -> 4679;
4684 -> 4682;
4685 -> 4684;
4685 -> 0;
4685 -> 4680;
4686 -> 4680;
4687 -> 4685;
4687 -> 4686;
4687 -> 4680;
4688 -> 4687;
4688 -> 4498;
4689 -> 4386;
4689 -> 4498;
4690 -> 4498;
4691 -> 4498;
4692 -> 4688;
4692 -> 4691;
4693 -> 4689;
4693 -> 4691;
4694 -> 4690;
4694 -> 4691;
4695 -> 3698;
4695 -> 4691;
4696 -> 4692;
4696 -> 4691;
4697 -> 4691;
4698 -> 4696;
4698 -> 4697;
4699 -> 4695;
4699 -> 4697;
4700 -> 4698;
4700 -> 4697;
4701 -> 4699;
4701 -> 3679;
4701 -> 4700;
4702 -> 4699;
4702 -> 4701;
4702 -> 4697;
4703 -> 4694;
4703 -> 4691;
4704 -> 4691;
4705 -> 4703;
4705 -> 4704;
4706 -> 4693;
4706 -> 4704;
4707 -> 4705;
4707 -> 4679;
4707 -> 4704;
4708 -> 4704;
4709 -> 4707;
4709 -> 4708;
4710 -> 4707;
4710 -> 4708;
4711 -> 4706;
4711 -> 4708;
4712 -> 4708;
4713 -> 4711;
4713 -> 4712;
4714 -> 4712;
4715 -> 4713;
4715 -> 4714;
4715 -> 4679;
4715 -> 4712;
4716 -> 4715;
4716 -> 4712;
4717 -> 4716;
4717 -> 4708;
4718 -> 4710;
4718 -> 4708;
4719 -> 4709;
4719 -> 4718;
4719 -> 4715;
4719 -> 4679;
4719 -> 4708;
4720 -> 4708;
4721 -> 4711;
4721 -> 4720;
4722 -> 4721;
4722 -> 4719;
4722 -> 4720;
4723 -> 4708;
4724 -> 4722;
4724 -> 4717;
4724 -> 4708;
4725 -> 4702;
4725 -> 4724;
4725 -> 4691;
4726 -> 4498;
4727 -> 3702;
4727 -> 4726;
4728 -> 4726;
4729 -> 4727;
4729 -> 4719;
4729 -> 4728;
4729 -> 4726;
4730 -> 4729;
4730 -> 0;
4730 -> 4726;
4731 -> 4730;
4731 -> 4498;
4732 -> 4498;
4733 -> 4498;
4733 -> 4729;
4733 -> 4732;
4734 -> 4729;
4735 -> 4729;
4736 -> 4729;
4737 -> 4729;
4738 -> 3701;
4738 -> 4729;
4739 -> 4729;
4740 -> 4738;
4740 -> 4729;
4741 -> 4737;
4741 -> 4729;
4742 -> 4729;
4743 -> 4739;
4743 -> 4742;
4744 -> 4742;
4745 -> 4743;
4745 -> 4744;
4746 -> 4745;
4746 -> 4742;
4747 -> 4746;
4747 -> 4729;
4748 -> 4747;
4748 -> 4729;
4749 -> 4748;
4749 -> 4729;
4750 -> 4729;
4751 -> 4740;
4751 -> 4729;
4752 -> 4741;
4752 -> 4729;
4753 -> 4751;
4753 -> 4729;
4754 -> 4729;
4755 -> 4729;
4756 -> 0;
4756 -> 4729;
4757 -> 4729;
4758 -> 4756;
4758 -> 4729;
4759 -> 4754;
4759 -> 4729;
4760 -> 4755;
4760 -> 4729;
4761 -> 4753;
4761 -> 4729;
4762 -> 4729;
4763 -> 4757;
4763 -> 4762;
4764 -> 4758;
4764 -> 4762;
4765 -> 4757;
4765 -> 4762;
4766 -> 4759;
4766 -> 4762;
4767 -> 4760;
4767 -> 4762;
4768 -> 4761;
4768 -> 4762;
4769 -> 4765;
4769 -> 4764;
4769 -> 4762;
4770 -> 4762;
4771 -> 4756;
4771 -> 0;
4771 -> 4729;
4772 -> 4750;
4772 -> 4729;
4773 -> 4751;
4773 -> 4729;
4774 -> 4750;
4774 -> 4729;
4775 -> 4752;
4775 -> 4729;
4776 -> 4729;
4777 -> 4756;
4777 -> 4729;
4778 -> 4777;
4778 -> 0;
4778 -> 4729;
4779 -> 4756;
4779 -> 0;
4779 -> 4729;
4780 -> 4729;
4781 -> 4756;
4781 -> 0;
4781 -> 4729;
4782 -> 4729;
4783 -> 4756;
4783 -> 4749;
4783 -> 4781;
4784 -> 4783;
4784 -> 0;
4784 -> 4729;
4785 -> 4729;
4786 -> 4783;
4786 -> 0;
4786 -> 4729;
4787 -> 4729;
4788 -> 4783;
4788 -> 0;
4788 -> 4729;
4789 -> 4729;
4790 -> 4739;
4790 -> 4788;
4791 -> 4783;
4791 -> 4788;
4792 -> 4729;
4792 -> 4788;
4793 -> 4740;
4793 -> 4788;
4794 -> 4788;
4795 -> 4790;
4795 -> 4794;
4796 -> 4791;
4796 -> 4794;
4797 -> 4792;
4797 -> 4794;
4798 -> 4793;
4798 -> 4794;
4799 -> 4796;
4799 -> 0;
4799 -> 4794;
4800 -> 4788;
4801 -> 4776;
4801 -> 4783;
4802 -> 3701;
4802 -> 4783;
4803 -> 4801;
4803 -> 4783;
4804 -> 4802;
4804 -> 4783;
4805 -> 4783;
4806 -> 4783;
4807 -> 4783;
4808 -> 4783;
4809 -> 4783;
4810 -> 4783;
4811 -> 4783;
4812 -> 4783;
4813 -> 4783;
4814 -> 4804;
4814 -> 4783;
4815 -> 4783;
4816 -> 4814;
4816 -> 4815;
4817 -> 4783;
4817 -> 4815;
4818 -> 4815;
4819 -> 4817;
4819 -> 4818;
4820 -> 4819;
4820 -> 4783;
4820 -> 4818;
4821 -> 4820;
4821 -> 4815;
4822 -> 4817;
4822 -> 4815;
4823 -> 4815;
4824 -> 4815;
4825 -> 4821;
4825 -> 4824;
4826 -> 4822;
4826 -> 4824;
4827 -> 4823;
4827 -> 4824;
4828 -> 4825;
4828 -> 4824;
4829 -> 4824;
4830 -> 4828;
4830 -> 4829;
4831 -> 4830;
4831 -> 0;
4831 -> 4829;
4832 -> 4831;
4833 -> 4824;
4834 -> 4826;
4834 -> 4833;
4835 -> 0;
4835 -> 4833;
4836 -> 4835;
4836 -> 4824;
4837 -> 4827;
4837 -> 4836;
4837 -> 4824;
4838 -> 4825;
4838 -> 0;
4838 -> 4824;
4839 -> 4824;
4840 -> 4837;
4840 -> 4838;
4840 -> 4824;
4841 -> 4824;
4842 -> 4841;
4842 -> 4815;
4843 -> 4815;
4844 -> 4842;
4844 -> 4843;
4844 -> 4815;
4845 -> 4783;
4846 -> 4803;
4846 -> 4783;
4847 -> 4804;
4847 -> 4846;
4848 -> 4846;
4849 -> 4847;
4849 -> 4848;
4850 -> 4783;
4850 -> 4848;
4851 -> 4848;
4852 -> 4850;
4852 -> 4851;
4853 -> 4852;
4853 -> 4783;
4853 -> 4851;
4854 -> 4853;
4854 -> 4848;
4855 -> 4848;
4856 -> 4854;
4856 -> 4855;
4857 -> 0;
4857 -> 4855;
4858 -> 4855;
4859 -> 4857;
4859 -> 4858;
4860 -> 4856;
4860 -> 4858;
4861 -> 4860;
4861 -> 4783;
4861 -> 4859;
4861 -> 4858;
4862 -> 4858;
4863 -> 4861;
4863 -> 4862;
4863 -> 4858;
4864 -> 4863;
4865 -> 4850;
4865 -> 4864;
4866 -> 4864;
4867 -> 4865;
4867 -> 4866;
4868 -> 4867;
4868 -> 4783;
4868 -> 4866;
4869 -> 4868;
4869 -> 0;
4869 -> 4864;
4870 -> 4864;
4871 -> 4869;
4871 -> 4870;
4871 -> 4864;
4872 -> 4871;
4872 -> 4863;
4873 -> 4872;
4874 -> 4850;
4874 -> 4783;
4874 -> 4873;
4875 -> 0;
4875 -> 4873;
4876 -> 4873;
4877 -> 4875;
4877 -> 4876;
4878 -> 4874;
4878 -> 4876;
4879 -> 4878;
4879 -> 4783;
4879 -> 4877;
4879 -> 4876;
4880 -> 4879;
4880 -> 4872;
4881 -> 4880;
4882 -> 4850;
4882 -> 4881;
4883 -> 4881;
4884 -> 4882;
4884 -> 4883;
4885 -> 4884;
4885 -> 0;
4885 -> 4881;
4886 -> 4881;
4887 -> 4885;
4887 -> 4886;
4887 -> 4881;
4888 -> 4887;
4888 -> 4880;
4889 -> 4846;
4890 -> 4783;
4891 -> 4890;
4891 -> 4783;
4892 -> 4729;
4893 -> 4783;
4893 -> 4892;
4894 -> 4892;
4895 -> 4893;
4895 -> 4894;
4896 -> 4895;
4896 -> 4783;
4896 -> 4894;
4897 -> 4896;
4897 -> 0;
4897 -> 4892;
4898 -> 4892;
4899 -> 4897;
4899 -> 4898;
4899 -> 4892;
4900 -> 4899;
4900 -> 4729;
4901 -> 3698;
4901 -> 4729;
4902 -> 4900;
4902 -> 4729;
4903 -> 4729;
4904 -> 4902;
4904 -> 4903;
4905 -> 4901;
4905 -> 4903;
4906 -> 4904;
4906 -> 4903;
4907 -> 4905;
4907 -> 3680;
4907 -> 4906;
4908 -> 4905;
4908 -> 4907;
4908 -> 4903;
4909 -> 4783;
4909 -> 4729;
4910 -> 4729;
4911 -> 4910;
4911 -> 4909;
4912 -> 4908;
4912 -> 4911;
4912 -> 4729;
4913 -> 4909;
4913 -> 0;
4913 -> 4729;
4914 -> 4913;
4914 -> 4729;
4915 -> 4729;
4916 -> 4729;
4916 -> 4909;
4916 -> 4915;
4917 -> 4909;
4918 -> 4909;
4919 -> 4909;
4920 -> 4909;
4921 -> 3701;
4921 -> 4909;
4922 -> 4921;
4922 -> 4909;
4923 -> 4920;
4923 -> 4909;
4924 -> 4909;
4925 -> 4922;
4925 -> 4909;
4926 -> 4923;
4926 -> 4909;
4927 -> 4925;
4927 -> 4909;
4928 -> 4909;
4929 -> 4909;
4930 -> 4909;
4931 -> 4909;
4932 -> 4930;
4932 -> 4909;
4933 -> 4928;
4933 -> 4909;
4934 -> 4929;
4934 -> 4909;
4935 -> 4927;
4935 -> 4909;
4936 -> 4909;
4937 -> 4931;
4937 -> 4936;
4938 -> 4932;
4938 -> 4936;
4939 -> 4931;
4939 -> 4936;
4940 -> 4933;
4940 -> 4936;
4941 -> 4934;
4941 -> 4936;
4942 -> 4935;
4942 -> 4936;
4943 -> 4939;
4943 -> 4938;
4943 -> 4936;
4944 -> 4936;
4945 -> 4930;
4945 -> 0;
4945 -> 4909;
4946 -> 4924;
4946 -> 4909;
4947 -> 4925;
4947 -> 4909;
4948 -> 4930;
4948 -> 4909;
4949 -> 4926;
4949 -> 4909;
4950 -> 4909;
4951 -> 4930;
4951 -> 4909;
4952 -> 4951;
4952 -> 0;
4952 -> 4909;
4953 -> 4930;
4953 -> 0;
4953 -> 4909;
4954 -> 4909;
4955 -> 4930;
4955 -> 0;
4955 -> 4909;
4956 -> 4909;
4957 -> 4930;
4957 -> 0;
4957 -> 4909;
4958 -> 4909;
4959 -> 4930;
4959 -> 0;
4959 -> 4909;
4960 -> 4909;
4961 -> 4909;
4961 -> 4959;
4962 -> 4930;
4962 -> 4959;
4963 -> 4922;
4963 -> 4959;
4964 -> 4959;
4965 -> 4961;
4965 -> 4964;
4966 -> 4962;
4966 -> 4964;
4967 -> 4961;
4967 -> 4964;
4968 -> 4963;
4968 -> 4964;
4969 -> 4966;
4969 -> 0;
4969 -> 4964;
4970 -> 4959;
4971 -> 4950;
4971 -> 4930;
4972 -> 3701;
4972 -> 4930;
4973 -> 4971;
4973 -> 4930;
4974 -> 4972;
4974 -> 4930;
4975 -> 4930;
4976 -> 4930;
4977 -> 4930;
4978 -> 4930;
4979 -> 4930;
4980 -> 4930;
4981 -> 4930;
4982 -> 4930;
4983 -> 4930;
4984 -> 4974;
4984 -> 4930;
4985 -> 4930;
4986 -> 4984;
4986 -> 4985;
4987 -> 4930;
4987 -> 4985;
4988 -> 4985;
4989 -> 4987;
4989 -> 4988;
4990 -> 4989;
4990 -> 4930;
4990 -> 4988;
4991 -> 4990;
4991 -> 4985;
4992 -> 4987;
4992 -> 4985;
4993 -> 4985;
4994 -> 4985;
4995 -> 4991;
4995 -> 4994;
4996 -> 4992;
4996 -> 4994;
4997 -> 4993;
4997 -> 4994;
4998 -> 4995;
4998 -> 4994;
4999 -> 4994;
5000 -> 4998;
5000 -> 4999;
5001 -> 5000;
5001 -> 0;
5001 -> 4999;
5002 -> 5001;
5003 -> 4994;
5004 -> 4996;
5004 -> 5003;
5005 -> 0;
5005 -> 5003;
5006 -> 5005;
5006 -> 4994;
5007 -> 4997;
5007 -> 5006;
5007 -> 4994;
5008 -> 4995;
5008 -> 0;
5008 -> 4994;
5009 -> 4994;
5010 -> 5007;
5010 -> 5008;
5010 -> 4994;
5011 -> 4995;
5011 -> 0;
5011 -> 5010;
5012 -> 4994;
5013 -> 5012;
5013 -> 4985;
5014 -> 4985;
5015 -> 5013;
5015 -> 5014;
5015 -> 4985;
5016 -> 4930;
5017 -> 4973;
5017 -> 4930;
5018 -> 4974;
5018 -> 5017;
5019 -> 5017;
5020 -> 5018;
5020 -> 5019;
5021 -> 4930;
5021 -> 5019;
5022 -> 5019;
5023 -> 5021;
5023 -> 5022;
5024 -> 5023;
5024 -> 4930;
5024 -> 5022;
5025 -> 5024;
5025 -> 5019;
5026 -> 5019;
5027 -> 5025;
5027 -> 5026;
5028 -> 0;
5028 -> 5026;
5029 -> 5026;
5030 -> 5028;
5030 -> 5029;
5031 -> 5027;
5031 -> 5029;
5032 -> 5031;
5032 -> 4930;
5032 -> 5030;
5032 -> 5029;
5033 -> 5029;
5034 -> 5032;
5034 -> 5033;
5034 -> 5029;
5035 -> 5034;
5036 -> 5021;
5036 -> 5035;
5037 -> 5035;
5038 -> 5036;
5038 -> 5037;
5039 -> 5038;
5039 -> 4930;
5039 -> 5037;
5040 -> 5039;
5040 -> 0;
5040 -> 5035;
5041 -> 5035;
5042 -> 5040;
5042 -> 5041;
5042 -> 5035;
5043 -> 5042;
5043 -> 5034;
5044 -> 5043;
5045 -> 5021;
5045 -> 4930;
5045 -> 5044;
5046 -> 0;
5046 -> 5044;
5047 -> 5044;
5048 -> 5046;
5048 -> 5047;
5049 -> 5045;
5049 -> 5047;
5050 -> 5049;
5050 -> 4930;
5050 -> 5048;
5050 -> 5047;
5051 -> 5050;
5051 -> 5043;
5052 -> 5051;
5053 -> 5021;
5053 -> 5052;
5054 -> 5052;
5055 -> 5053;
5055 -> 5054;
5056 -> 5055;
5056 -> 0;
5056 -> 5052;
5057 -> 5052;
5058 -> 5056;
5058 -> 5057;
5058 -> 5052;
5059 -> 5058;
5059 -> 5051;
5060 -> 5051;
5061 -> 5021;
5061 -> 5060;
5062 -> 5060;
5063 -> 5061;
5063 -> 5062;
5064 -> 5063;
5064 -> 0;
5064 -> 5060;
5065 -> 5060;
5066 -> 5064;
5066 -> 5065;
5066 -> 5060;
5067 -> 5066;
5067 -> 5051;
5068 -> 5059;
5068 -> 5067;
5068 -> 5051;
5069 -> 5051;
5070 -> 5021;
5070 -> 4930;
5070 -> 5069;
5071 -> 0;
5071 -> 5069;
5072 -> 5069;
5073 -> 5071;
5073 -> 5072;
5074 -> 5070;
5074 -> 5072;
5075 -> 5074;
5075 -> 4930;
5075 -> 5073;
5075 -> 5072;
5076 -> 5075;
5076 -> 5051;
5077 -> 5068;
5077 -> 5076;
5077 -> 5051;
5078 -> 5017;
5079 -> 4930;
5080 -> 5079;
5080 -> 4930;
5081 -> 4909;
5082 -> 4930;
5082 -> 5081;
5083 -> 5081;
5084 -> 5082;
5084 -> 5083;
5085 -> 5084;
5085 -> 4930;
5085 -> 5083;
5086 -> 5085;
5086 -> 0;
5086 -> 5081;
5087 -> 5081;
5088 -> 5086;
5088 -> 5087;
5088 -> 5081;
5089 -> 5088;
5089 -> 4909;
5090 -> 3698;
5090 -> 4909;
5091 -> 5089;
5091 -> 4909;
5092 -> 4909;
5093 -> 5091;
5093 -> 5092;
5094 -> 5090;
5094 -> 5092;
5095 -> 5093;
5095 -> 5092;
5096 -> 5094;
5096 -> 4701;
5096 -> 5095;
5097 -> 5094;
5097 -> 5096;
5097 -> 5092;
5098 -> 4909;
5099 -> 5098;
5099 -> 4930;
5100 -> 5097;
5100 -> 5099;
5100 -> 4909;
5101 -> 4930;
5101 -> 0;
5101 -> 4909;
5102 -> 5101;
5102 -> 4909;
5103 -> 4909;
5104 -> 4909;
5104 -> 4930;
5104 -> 5103;
5105 -> 4930;
5106 -> 4930;
5107 -> 4930;
5108 -> 4930;
5109 -> 5108;
5109 -> 4930;
5110 -> 5107;
5110 -> 4930;
5111 -> 4930;
5112 -> 5110;
5112 -> 5111;
5113 -> 5112;
5113 -> 5108;
5113 -> 5111;
5114 -> 5111;
5114 -> 5108;
5115 -> 5111;
5116 -> 5115;
5116 -> 5113;
5117 -> 3702;
5117 -> 4930;
5118 -> 5107;
5118 -> 4930;
5119 -> 5116;
5119 -> 4930;
5120 -> 3701;
5120 -> 4930;
5121 -> 4930;
5122 -> 5117;
5122 -> 5121;
5123 -> 5118;
5123 -> 5121;
5124 -> 5119;
5124 -> 5121;
5125 -> 5120;
5125 -> 5121;
5126 -> 5123;
5126 -> 5113;
5126 -> 5121;
5127 -> 0;
5127 -> 5121;
5128 -> 5126;
5128 -> 5121;
5129 -> 5122;
5129 -> 5121;
5130 -> 5123;
5130 -> 5126;
5130 -> 5121;
5131 -> 5121;
5132 -> 5130;
5132 -> 5131;
5133 -> 5130;
5133 -> 5131;
5134 -> 5130;
5134 -> 5131;
5135 -> 5130;
5135 -> 5131;
5136 -> 5130;
5136 -> 5131;
5137 -> 5130;
5137 -> 5131;
5138 -> 5130;
5138 -> 5131;
5139 -> 5132;
5139 -> 5131;
5140 -> 5133;
5140 -> 5131;
5141 -> 5134;
5141 -> 5131;
5142 -> 5134;
5142 -> 5131;
5143 -> 5142;
5143 -> 5130;
5143 -> 5131;
5144 -> 5131;
5145 -> 5139;
5145 -> 5144;
5146 -> 5140;
5146 -> 5144;
5147 -> 5141;
5147 -> 5144;
5148 -> 5143;
5148 -> 5144;
5149 -> 5138;
5149 -> 5144;
5150 -> 5145;
5150 -> 5144;
5151 -> 5147;
5151 -> 5143;
5151 -> 5144;
5152 -> 5146;
5152 -> 5144;
5153 -> 5152;
5153 -> 5151;
5153 -> 5144;
5154 -> 5148;
5154 -> 5144;
5155 -> 5144;
5156 -> 5150;
5156 -> 5155;
5157 -> 5151;
5157 -> 5155;
5158 -> 5153;
5158 -> 5155;
5159 -> 5154;
5159 -> 5155;
5160 -> 5149;
5160 -> 5155;
5161 -> 5157;
5161 -> 5155;
5162 -> 5155;
5163 -> 5161;
5163 -> 5162;
5164 -> 5160;
5164 -> 5162;
5165 -> 5162;
5166 -> 5164;
5166 -> 5165;
5168 -> 5167;
5169 -> 5165;
5170 -> 5166;
5170 -> 5169;
5171 -> 5169;
5172 -> 5170;
5172 -> 5169;
5173 -> 5170;
5173 -> 5169;
5174 -> 5164;
5174 -> 5162;
5175 -> 5164;
5175 -> 5162;
5176 -> 5164;
5176 -> 5162;
5177 -> 5163;
5177 -> 5164;
5177 -> 5162;
5178 -> 5160;
5178 -> 5155;
5179 -> 5160;
5179 -> 5155;
5180 -> 5160;
5180 -> 5155;
5181 -> 5160;
5181 -> 5155;
5182 -> 5160;
5182 -> 5155;
5183 -> 5160;
5183 -> 5155;
5184 -> 5160;
5184 -> 5155;
5185 -> 5155;
5186 -> 5156;
5186 -> 5185;
5186 -> 5155;
5187 -> 5158;
5187 -> 5151;
5187 -> 5153;
5187 -> 5155;
5188 -> 5156;
5188 -> 5160;
5188 -> 5155;
5189 -> 5158;
5189 -> 5160;
5189 -> 5155;
5190 -> 5159;
5190 -> 5155;
5191 -> 5149;
5191 -> 5144;
5192 -> 5147;
5192 -> 5144;
5193 -> 0;
5193 -> 5144;
5194 -> 5192;
5194 -> 5193;
5194 -> 5151;
5194 -> 5144;
5195 -> 5138;
5195 -> 5131;
5196 -> 5138;
5196 -> 5131;
5197 -> 5131;
5198 -> 5134;
5198 -> 5194;
5198 -> 5197;
5198 -> 5131;
5199 -> 5198;
5199 -> 5131;
5200 -> 5199;
5200 -> 5138;
5200 -> 5131;
5201 -> 5198;
5201 -> 5131;
5202 -> 5134;
5202 -> 5194;
5202 -> 5131;
5203 -> 5202;
5203 -> 5138;
5203 -> 5131;
5204 -> 5131;
5205 -> 5134;
5205 -> 5194;
5205 -> 5131;
5206 -> 5135;
5206 -> 5131;
5207 -> 5201;
5207 -> 5131;
5208 -> 5133;
5208 -> 5131;
5209 -> 5137;
5209 -> 5131;
5210 -> 5204;
5210 -> 5131;
5211 -> 5131;
5212 -> 5205;
5212 -> 5211;
5213 -> 5206;
5213 -> 5211;
5214 -> 5207;
5214 -> 5211;
5215 -> 5208;
5215 -> 5211;
5216 -> 5209;
5216 -> 5211;
5217 -> 5210;
5217 -> 5211;
5218 -> 5138;
5218 -> 5211;
5219 -> 5213;
5219 -> 0;
5219 -> 5211;
5220 -> 5219;
5220 -> 5211;
5221 -> 0;
5221 -> 5211;
5222 -> 5212;
5222 -> 5211;
5223 -> 5220;
5223 -> 5211;
5224 -> 5221;
5224 -> 5211;
5225 -> 5215;
5225 -> 5211;
5226 -> 5216;
5226 -> 5211;
5227 -> 5217;
5227 -> 5211;
5228 -> 5211;
5229 -> 5222;
5229 -> 5228;
5230 -> 5223;
5230 -> 5228;
5231 -> 5224;
5231 -> 5228;
5232 -> 5225;
5232 -> 5228;
5233 -> 5226;
5233 -> 5228;
5234 -> 5227;
5234 -> 5228;
5235 -> 5233;
5235 -> 5228;
5236 -> 5228;
5237 -> 5228;
5238 -> 5228;
5238 -> 0;
5239 -> 5232;
5239 -> 5228;
5240 -> 5233;
5240 -> 5228;
5241 -> 5229;
5241 -> 5228;
5242 -> 5234;
5242 -> 5228;
5243 -> 5228;
5244 -> 5228;
5244 -> 5231;
5245 -> 5244;
5245 -> 0;
5245 -> 5228;
5246 -> 5231;
5246 -> 0;
5246 -> 5228;
5247 -> 5228;
5248 -> 5231;
5248 -> 5230;
5249 -> 5218;
5249 -> 5211;
5250 -> 5248;
5250 -> 5211;
5251 -> 5216;
5251 -> 5211;
5252 -> 5211;
5253 -> 5249;
5253 -> 5252;
5254 -> 5250;
5254 -> 5252;
5255 -> 5251;
5255 -> 5252;
5256 -> 5253;
5256 -> 5252;
5257 -> 5256;
5257 -> 5189;
5257 -> 5252;
5258 -> 5257;
5258 -> 5252;
5258 -> 5151;
5258 -> 5153;
5258 -> 5194;
5259 -> 5252;
5260 -> 5253;
5260 -> 5259;
5261 -> 5254;
5261 -> 5259;
5262 -> 5258;
5262 -> 5259;
5263 -> 5255;
5263 -> 5259;
5264 -> 5261;
5264 -> 0;
5264 -> 5259;
5265 -> 5211;
5266 -> 5213;
5266 -> 0;
5266 -> 5211;
5267 -> 5248;
5267 -> 5211;
5268 -> 5135;
5268 -> 5131;
5269 -> 5267;
5269 -> 5131;
5270 -> 5131;
5271 -> 5136;
5271 -> 5131;
5272 -> 5131;
5273 -> 5268;
5273 -> 5272;
5274 -> 5269;
5274 -> 5272;
5275 -> 5270;
5275 -> 5272;
5276 -> 5270;
5276 -> 5272;
5277 -> 5271;
5277 -> 5272;
5278 -> 5270;
5278 -> 5272;
5279 -> 5138;
5279 -> 5272;
5280 -> 5274;
5280 -> 5279;
5280 -> 5272;
5282 -> 5281;
5284 -> 5283;
5285 -> 5282;
5285 -> 5284;
5286 -> 5285;
5288 -> 5287;
5289 -> 5286;
5289 -> 5288;
5290 -> 5289;
5292 -> 5291;
5293 -> 5290;
5293 -> 5292;
5294 -> 5293;
5296 -> 5295;
5297 -> 5294;
5297 -> 5296;
5298 -> 5297;
5300 -> 5299;
5301 -> 5298;
5301 -> 5300;
5302 -> 5301;
5304 -> 5303;
5305 -> 5302;
5305 -> 5304;
5306 -> 5305;
5308 -> 5307;
5309 -> 5306;
5309 -> 5308;
5310 -> 5309;
5312 -> 5311;
5314 -> 5313;
5314 -> 5284;
5316 -> 5314;
5316 -> 5315;
5317 -> 5316;
5319 -> 5318;
5319 -> 5286;
5320 -> 5319;
5322 -> 5321;
5322 -> 5290;
5323 -> 5322;
5325 -> 5324;
5325 -> 5290;
5326 -> 5325;
5328 -> 5327;
5328 -> 5298;
5329 -> 5328;
5331 -> 5330;
5331 -> 5302;
5332 -> 5331;
5335 -> 5302;
5335 -> 5334;
5336 -> 5333;
5336 -> 5335;
5337 -> 5336;
5339 -> 5338;
5339 -> 5308;
5341 -> 5339;
5341 -> 5340;
5342 -> 5341;
5344 -> 5343;
5344 -> 5310;
5345 -> 5344;
5346 -> 5317;
5347 -> 5342;
5348 -> 5273;
5348 -> 5272;
5349 -> 5274;
5349 -> 5272;
5350 -> 5275;
5350 -> 5272;
5351 -> 5276;
5351 -> 5272;
5352 -> 5277;
5352 -> 5272;
5353 -> 5278;
5353 -> 5272;
5354 -> 5272;
5355 -> 5272;
5356 -> 5348;
5356 -> 5355;
5357 -> 5349;
5357 -> 5355;
5358 -> 5350;
5358 -> 5355;
5359 -> 5351;
5359 -> 5355;
5360 -> 5352;
5360 -> 5355;
5361 -> 5353;
5361 -> 5355;
5362 -> 5354;
5362 -> 5355;
5363 -> 5357;
5363 -> 5355;
5364 -> 5355;
5365 -> 5363;
5365 -> 5364;
5366 -> 0;
5366 -> 5364;
5367 -> 5365;
5367 -> 5366;
5367 -> 5364;
5368 -> 5364;
5369 -> 5361;
5369 -> 5367;
5369 -> 5355;
5370 -> 5356;
5370 -> 5317;
5370 -> 5355;
5371 -> 5370;
5371 -> 5282;
5371 -> 5355;
5372 -> 5359;
5372 -> 5355;
5373 -> 5372;
5374 -> 5360;
5374 -> 5355;
5375 -> 5374;
5376 -> 5369;
5376 -> 5355;
5377 -> 5376;
5378 -> 5369;
5378 -> 5355;
5379 -> 5378;
5380 -> 5371;
5380 -> 5373;
5380 -> 5355;
5381 -> 5380;
5381 -> 5375;
5381 -> 5355;
5382 -> 5381;
5382 -> 5377;
5382 -> 5355;
5383 -> 5382;
5383 -> 5379;
5383 -> 5355;
5384 -> 5358;
5384 -> 5355;
5385 -> 5332;
5385 -> 5384;
5386 -> 5383;
5386 -> 5385;
5386 -> 5355;
5387 -> 5386;
5387 -> 5337;
5387 -> 5355;
5388 -> 5387;
5388 -> 5362;
5388 -> 5355;
5389 -> 5354;
5389 -> 5279;
5389 -> 5272;
5390 -> 5134;
5390 -> 5258;
5390 -> 5131;
5391 -> 5131;
5392 -> 5390;
5392 -> 5391;
5393 -> 5134;
5393 -> 5392;
5393 -> 5132;
5393 -> 5131;
5394 -> 5131;
5395 -> 5138;
5395 -> 5394;
5396 -> 5394;
5397 -> 5395;
5397 -> 5396;
5398 -> 5397;
5398 -> 5280;
5398 -> 0;
5398 -> 5396;
5399 -> 5396;
5400 -> 5398;
5400 -> 5394;
5401 -> 5400;
5401 -> 5131;
5402 -> 5135;
5402 -> 0;
5402 -> 5131;
5403 -> 5138;
5403 -> 5280;
5403 -> 5131;
5404 -> 5138;
5404 -> 5131;
5405 -> 5131;
5406 -> 5131;
5407 -> 5403;
5407 -> 5406;
5408 -> 5404;
5408 -> 5406;
5409 -> 5405;
5409 -> 5406;
5410 -> 5407;
5410 -> 5406;
5411 -> 5406;
5412 -> 5410;
5412 -> 5411;
5413 -> 5412;
5413 -> 0;
5413 -> 5411;
5414 -> 5413;
5415 -> 5406;
5416 -> 5408;
5416 -> 5415;
5417 -> 0;
5417 -> 5415;
5418 -> 5417;
5418 -> 5406;
5419 -> 5407;
5419 -> 0;
5419 -> 5406;
5420 -> 5406;
5421 -> 5418;
5421 -> 5419;
5421 -> 5406;
5422 -> 5409;
5422 -> 5421;
5422 -> 5406;
5423 -> 5407;
5423 -> 0;
5423 -> 5422;
5424 -> 5406;
5425 -> 5424;
5425 -> 5131;
5426 -> 5131;
5427 -> 5425;
5427 -> 5426;
5427 -> 5131;
5428 -> 5243;
5428 -> 5131;
5429 -> 5135;
5429 -> 5428;
5430 -> 5201;
5430 -> 5428;
5431 -> 5133;
5431 -> 5428;
5432 -> 5137;
5432 -> 5428;
5433 -> 5428;
5434 -> 5429;
5434 -> 5433;
5435 -> 5430;
5435 -> 5433;
5436 -> 5431;
5436 -> 5433;
5437 -> 5432;
5437 -> 5433;
5438 -> 5138;
5438 -> 5433;
5439 -> 5435;
5439 -> 5433;
5440 -> 5439;
5441 -> 5438;
5441 -> 5440;
5442 -> 5441;
5442 -> 5188;
5442 -> 5440;
5443 -> 5442;
5443 -> 5439;
5444 -> 5439;
5445 -> 5443;
5445 -> 5444;
5446 -> 0;
5446 -> 5444;
5447 -> 5444;
5448 -> 5446;
5448 -> 5447;
5449 -> 5445;
5449 -> 5447;
5450 -> 5449;
5450 -> 5392;
5450 -> 5448;
5450 -> 5447;
5451 -> 5447;
5452 -> 5450;
5452 -> 5451;
5452 -> 5447;
5453 -> 5452;
5454 -> 5453;
5454 -> 5452;
5455 -> 5452;
5456 -> 5454;
5456 -> 5455;
5457 -> 0;
5457 -> 5455;
5458 -> 5455;
5459 -> 5457;
5459 -> 5458;
5460 -> 5456;
5460 -> 5458;
5461 -> 5460;
5461 -> 5392;
5461 -> 5459;
5461 -> 5458;
5462 -> 5428;
5463 -> 5134;
5463 -> 5392;
5463 -> 5131;
5464 -> 5134;
5464 -> 5131;
5465 -> 5137;
5465 -> 5131;
5466 -> 5131;
5467 -> 5463;
5467 -> 5466;
5468 -> 5463;
5468 -> 5466;
5469 -> 5464;
5469 -> 5466;
5470 -> 5465;
5470 -> 5466;
5471 -> 5466;
5472 -> 5467;
5472 -> 5471;
5472 -> 5466;
5473 -> 5468;
5473 -> 5471;
5473 -> 5466;
5474 -> 5472;
5474 -> 5473;
5474 -> 5466;
5475 -> 5131;
5476 -> 5130;
5476 -> 5392;
5476 -> 5170;
5476 -> 5172;
5476 -> 5173;
5476 -> 5174;
5476 -> 5175;
5476 -> 5177;
5476 -> 5280;
5476 -> 5188;
5476 -> 5180;
5476 -> 5181;
5476 -> 5182;
5476 -> 5183;
5476 -> 5184;
5476 -> 5189;
5476 -> 5191;
5476 -> 5200;
5476 -> 5203;
5476 -> 5389;
5476 -> 5151;
5476 -> 5153;
5476 -> 5388;
5476 -> 5121;
5477 -> 5123;
5477 -> 5121;
5478 -> 5128;
5478 -> 5121;
5479 -> 5124;
5479 -> 5121;
5480 -> 5125;
5480 -> 5121;
5481 -> 5129;
5481 -> 5476;
5481 -> 5477;
5481 -> 5478;
5481 -> 5479;
5481 -> 5480;
5481 -> 3660;
5481 -> 5121;
5482 -> 5481;
5482 -> 4930;
5483 -> 5107;
5483 -> 5482;
5483 -> 4930;
5484 -> 5483;
5485 -> 5481;
5485 -> 5484;
5486 -> 5485;
5486 -> 5482;
5486 -> 0;
5486 -> 5484;
5487 -> 5484;
5488 -> 5486;
5488 -> 5483;
5489 -> 5116;
5489 -> 5483;
5490 -> 5483;
5491 -> 5488;
5491 -> 5490;
5492 -> 5489;
5492 -> 5490;
5493 -> 3698;
5493 -> 5490;
5494 -> 5491;
5494 -> 5490;
5495 -> 5490;
5496 -> 5494;
5496 -> 5495;
5497 -> 5493;
5497 -> 5495;
5498 -> 5496;
5498 -> 5495;
5499 -> 5497;
5499 -> 5096;
5499 -> 5498;
5500 -> 5497;
5500 -> 5499;
5500 -> 5495;
5501 -> 5500;
5501 -> 5492;
5501 -> 5490;
5502 -> 5483;
5503 -> 3698;
5503 -> 3673;
5503 -> 3697;
5504 -> 3699;
5504 -> 3697;
5505 -> 3697;
5506 -> 5503;
5506 -> 5505;
5507 -> 5504;
5507 -> 5505;
5508 -> 5505;
5509 -> 5507;
5509 -> 5508;
5509 -> 5505;
5510 -> 3697;
5511 -> 3698;
5511 -> 3671;
5511 -> 3697;
5512 -> 4375;
5512 -> 3697;
5513 -> 3697;
5514 -> 5511;
5514 -> 5513;
5515 -> 5512;
5515 -> 5513;
5516 -> 5513;
5517 -> 5515;
5517 -> 5516;
5517 -> 5513;
5518 -> 3697;
5519 -> 3662;
5520 -> 3662;
5521 -> 3664;
5521 -> 5520;
5522 -> 5520;
5523 -> 5521;
5523 -> 5482;
5523 -> 5522;
5524 -> 5523;
5524 -> 3662;
5525 -> 3662;
5526 -> 3664;
5526 -> 5525;
5527 -> 5525;
5528 -> 5527;
5528 -> 5525;
5529 -> 5525;
5530 -> 5528;
5530 -> 5529;
5531 -> 5526;
5531 -> 5529;
5532 -> 5529;
5533 -> 5531;
5533 -> 5532;
5534 -> 5532;
5535 -> 5534;
5535 -> 5529;
5536 -> 5529;
5537 -> 5531;
5537 -> 5536;
5538 -> 5537;
5538 -> 5482;
5538 -> 5536;
5539 -> 5538;
5539 -> 5529;
5540 -> 5529;
5541 -> 5539;
5541 -> 5540;
5542 -> 0;
5542 -> 5540;
5543 -> 5542;
5543 -> 5529;
5544 -> 5535;
5544 -> 5543;
5544 -> 5529;
5545 -> 5529;
5546 -> 5531;
5546 -> 5545;
5547 -> 5545;
5548 -> 5546;
5548 -> 5547;
5549 -> 5548;
5549 -> 5482;
5549 -> 5547;
5550 -> 5549;
5550 -> 5545;
5551 -> 5545;
5552 -> 5550;
5553 -> 5550;
5554 -> 5552;
5554 -> 5553;
5554 -> 5550;
5555 -> 5552;
5555 -> 5554;
5556 -> 5555;
5556 -> 5529;
5557 -> 5529;
5558 -> 5556;
5558 -> 5557;
5559 -> 5557;
5560 -> 5558;
5560 -> 5559;
5561 -> 5560;
5561 -> 5482;
5561 -> 5559;
5562 -> 5557;
5563 -> 5561;
5564 -> 5561;
5564 -> 5563;
5565 -> 5564;
5565 -> 5482;
5565 -> 5563;
5566 -> 5565;
5567 -> 5565;
5568 -> 5557;
5569 -> 5568;
5569 -> 5529;
5570 -> 5529;
5571 -> 5544;
5571 -> 5569;
5571 -> 5529;
5572 -> 5529;
5573 -> 5529;
5574 -> 5573;
5574 -> 3662;
5575 -> 3664;
5575 -> 5482;
5575 -> 3662;
5576 -> 5575;
5576 -> 3124;
5576 -> 3662;
5577 -> 3662;
5578 -> 3665;
5578 -> 5577;
5579 -> 5578;
5579 -> 3669;
5579 -> 5575;
5579 -> 5577;
5580 -> 5578;
5580 -> 3671;
5580 -> 5577;
5581 -> 5577;
5582 -> 5580;
5582 -> 5581;
5583 -> 5581;
5584 -> 5582;
5584 -> 3670;
5584 -> 5583;
5584 -> 5581;
5585 -> 5582;
5585 -> 3670;
5585 -> 5584;
5586 -> 0;
5586 -> 5584;
5587 -> 5578;
5587 -> 3673;
5587 -> 5577;
5588 -> 5577;
5589 -> 5587;
5589 -> 5588;
5590 -> 5588;
5591 -> 5589;
5591 -> 3672;
5591 -> 5590;
5591 -> 5588;
5592 -> 5589;
5592 -> 3672;
5592 -> 5591;
5593 -> 0;
5593 -> 5591;
5594 -> 5578;
5594 -> 3674;
5594 -> 5577;
5595 -> 5578;
5595 -> 3675;
5595 -> 5577;
5596 -> 5578;
5596 -> 3676;
5596 -> 5577;
5597 -> 5578;
5597 -> 3678;
5597 -> 5577;
5598 -> 5578;
5598 -> 5499;
5598 -> 5577;
5599 -> 5578;
5599 -> 4907;
5599 -> 5577;
5600 -> 5577;
5601 -> 5577;
5602 -> 5579;
5602 -> 5601;
5603 -> 5586;
5603 -> 5601;
5604 -> 5593;
5604 -> 5601;
5605 -> 5594;
5605 -> 5601;
5606 -> 5595;
5606 -> 5601;
5607 -> 5596;
5607 -> 5601;
5608 -> 5597;
5608 -> 5601;
5609 -> 5598;
5609 -> 5601;
5610 -> 5599;
5610 -> 5601;
5611 -> 5600;
5611 -> 5601;
5612 -> 5611;
5612 -> 5601;
5613 -> 5611;
5613 -> 5601;
5614 -> 5611;
5614 -> 5601;
5615 -> 5611;
5615 -> 5601;
5616 -> 5611;
5616 -> 5601;
5617 -> 5611;
5617 -> 5601;
5618 -> 5602;
5618 -> 5579;
5618 -> 5601;
5619 -> 5603;
5619 -> 0;
5619 -> 5601;
5620 -> 5604;
5620 -> 0;
5620 -> 5601;
5621 -> 5602;
5621 -> 5601;
5622 -> 5601;
5623 -> 5606;
5623 -> 5607;
5623 -> 5601;
5624 -> 5602;
5624 -> 5611;
5624 -> 5601;
5625 -> 5603;
5625 -> 5611;
5625 -> 5601;
5626 -> 5604;
5626 -> 5611;
5626 -> 5601;
5627 -> 5605;
5627 -> 5611;
5627 -> 5601;
5628 -> 5606;
5628 -> 5611;
5628 -> 5601;
5629 -> 5607;
5629 -> 5611;
5629 -> 5601;
5630 -> 5608;
5630 -> 5611;
5630 -> 5601;
5631 -> 5609;
5631 -> 5611;
5631 -> 5601;
5632 -> 5610;
5632 -> 5611;
5632 -> 5601;
5633 -> 5600;
5633 -> 3662;
5634 -> 5633;
5634 -> 3655;
5635 -> 3656;
5635 -> 5621;
5635 -> 3655;
5636 -> 5634;
5636 -> 3655;
5637 -> 3124;
5637 -> 3655;
5638 -> 5635;
5638 -> 5636;
5638 -> 5637;
5638 -> 5627;
5638 -> 5628;
5638 -> 5629;
5638 -> 5630;
5638 -> 5631;
5638 -> 5632;
5638 -> 5624;
5638 -> 5625;
5638 -> 5626;
5638 -> 3118;
5638 -> 3119;
5638 -> 3120;
5638 -> 3121;
5638 -> 3122;
5638 -> 3123;
5638 -> 5621;
5638 -> 5579;
5638 -> 0;
5638 -> 3655;
5639 -> 5638;
5639 -> 3124;
5639 -> 3655;
5640 -> 3660;
5640 -> 3655;
5641 -> 3655;
5642 -> 5640;
5642 -> 5641;
5643 -> 3656;
5643 -> 5641;
5644 -> 5641;
5645 -> 5643;
5645 -> 5644;
5646 -> 5645;
5646 -> 5638;
5646 -> 5644;
5647 -> 5646;
5647 -> 5641;
5648 -> 5642;
5648 -> 5638;
5648 -> 5641;
5649 -> 3655;
5650 -> 3660;
5650 -> 5638;
5650 -> 3655;
5651 -> 5634;
5651 -> 3655;
5652 -> 5651;
5652 -> 3652;
5653 -> 5652;
5653 -> 3652;
5654 -> 5652;
5654 -> 3652;
5655 -> 3652;
5656 -> 3652;
5657 -> 5654;
5657 -> 5656;
5658 -> 5655;
5658 -> 5656;
5659 -> 5658;
5659 -> 5656;
5660 -> 5658;
5660 -> 5656;
5661 -> 5658;
5661 -> 5656;
5662 -> 5658;
5662 -> 5656;
5663 -> 5657;
5663 -> 3124;
5663 -> 5656;
5664 -> 5657;
5664 -> 5650;
5664 -> 5658;
5664 -> 5656;
5665 -> 5657;
5665 -> 5650;
5665 -> 5658;
5665 -> 5656;
5666 -> 5655;
5666 -> 3652;
5667 -> 5652;
5667 -> 3652;
5668 -> 3653;
5668 -> 3652;
5669 -> 3652;
5670 -> 5666;
5670 -> 5669;
5671 -> 5667;
5671 -> 5669;
5672 -> 5668;
5672 -> 5669;
5673 -> 3654;
5673 -> 5669;
5674 -> 5669;
5675 -> 5673;
5675 -> 5674;
5676 -> 5674;
5677 -> 5675;
5677 -> 5650;
5677 -> 5676;
5678 -> 5677;
5678 -> 5669;
5679 -> 5670;
5679 -> 5678;
5680 -> 5671;
5680 -> 5678;
5681 -> 5672;
5681 -> 5678;
5682 -> 5678;
5683 -> 5679;
5683 -> 5682;
5684 -> 5680;
5684 -> 5682;
5685 -> 5681;
5685 -> 5682;
5686 -> 5673;
5686 -> 5682;
5687 -> 5686;
5687 -> 5650;
5687 -> 0;
5687 -> 5682;
5688 -> 5687;
5689 -> 5678;
5690 -> 5670;
5690 -> 5678;
5691 -> 5671;
5691 -> 5678;
5692 -> 5672;
5692 -> 5678;
5693 -> 5678;
5694 -> 5690;
5694 -> 5693;
5695 -> 5691;
5695 -> 5693;
5696 -> 5692;
5696 -> 5693;
5697 -> 5673;
5697 -> 5693;
5698 -> 5693;
5699 -> 5693;
5700 -> 5693;
5701 -> 5695;
5701 -> 5693;
5702 -> 5693;
5703 -> 5701;
5703 -> 5702;
5704 -> 5694;
5704 -> 5702;
5705 -> 5703;
5705 -> 5650;
5705 -> 5702;
5706 -> 5705;
5706 -> 5704;
5706 -> 5659;
5706 -> 5702;
5707 -> 5706;
5707 -> 5693;
5708 -> 5707;
5709 -> 5707;
5709 -> 5708;
5710 -> 0;
5710 -> 5708;
5711 -> 5710;
5711 -> 5707;
5712 -> 5698;
5712 -> 5707;
5713 -> 5707;
5713 -> 5708;
5714 -> 0;
5714 -> 5708;
5715 -> 5714;
5715 -> 5707;
5716 -> 5707;
5716 -> 5715;
5717 -> 5715;
5718 -> 5716;
5718 -> 5717;
5719 -> 5717;
5720 -> 5718;
5720 -> 5650;
5720 -> 5719;
5721 -> 5720;
5721 -> 5650;
5721 -> 5282;
5721 -> 5719;
5722 -> 5721;
5722 -> 5717;
5723 -> 5722;
5723 -> 5715;
5724 -> 5723;
5725 -> 5697;
5725 -> 5724;
5726 -> 5725;
5726 -> 5723;
5727 -> 5726;
5728 -> 5726;
5729 -> 5716;
5729 -> 5728;
5730 -> 5729;
5730 -> 5650;
5730 -> 5725;
5730 -> 5728;
5731 -> 5728;
5732 -> 5729;
5732 -> 5731;
5733 -> 5731;
5734 -> 5732;
5734 -> 5733;
5735 -> 5733;
5736 -> 5734;
5736 -> 5650;
5736 -> 5725;
5736 -> 5735;
5736 -> 5733;
5737 -> 5733;
5738 -> 5734;
5738 -> 5650;
5738 -> 5725;
5738 -> 5737;
5738 -> 5733;
5739 -> 5738;
5739 -> 5731;
5740 -> 5739;
5740 -> 5728;
5741 -> 5740;
5741 -> 5726;
5742 -> 5726;
5743 -> 5699;
5743 -> 5741;
5743 -> 5726;
5744 -> 5727;
5744 -> 5700;
5744 -> 5707;
5745 -> 5743;
5745 -> 5693;
5746 -> 5727;
5746 -> 5693;
5747 -> 5745;
5747 -> 5746;
5747 -> 5693;
5748 -> 5695;
5748 -> 5738;
5748 -> 5693;
5749 -> 5693;
5750 -> 5748;
5750 -> 5749;
5751 -> 5750;
5751 -> 5749;
5752 -> 5749;
5753 -> 5700;
5753 -> 5751;
5753 -> 5693;
5754 -> 5693;
5755 -> 5697;
5755 -> 5754;
5756 -> 5755;
5756 -> 5751;
5756 -> 5754;
5757 -> 5756;
5757 -> 0;
5757 -> 5754;
5758 -> 5757;
5758 -> 5693;
5759 -> 5678;
5760 -> 3652;
5761 -> 3654;
5761 -> 5756;
5761 -> 3652;
5762 -> 3652;
5763 -> 5652;
5763 -> 3652;
5764 -> 3652;
5765 -> 5763;
5765 -> 5764;
5766 -> 5655;
5766 -> 5764;
5767 -> 5766;
5767 -> 5659;
5767 -> 5764;
5768 -> 5765;
5768 -> 5761;
5768 -> 5764;
5769 -> 5768;
5769 -> 5767;
5769 -> 5764;
5770 -> 5766;
5770 -> 5660;
5770 -> 5764;
5771 -> 5770;
5771 -> 5764;
5772 -> 5765;
5772 -> 5761;
5772 -> 5771;
5773 -> 5769;
5773 -> 5764;
5774 -> 5765;
5774 -> 5761;
5774 -> 5764;
5775 -> 5772;
5775 -> 5764;
5776 -> 5766;
5776 -> 5664;
5776 -> 5764;
5777 -> 5766;
5777 -> 5665;
5777 -> 5764;
5778 -> 5764;
5779 -> 5764;
5780 -> 5773;
5780 -> 5779;
5781 -> 5774;
5781 -> 5779;
5782 -> 5775;
5782 -> 5779;
5783 -> 5774;
5783 -> 5779;
5784 -> 5776;
5784 -> 5779;
5785 -> 5777;
5785 -> 5779;
5786 -> 5778;
5786 -> 5779;
5787 -> 5786;
5787 -> 5779;
5788 -> 5786;
5788 -> 5779;
5789 -> 5786;
5789 -> 5779;
5790 -> 5780;
5790 -> 5761;
5790 -> 5779;
5791 -> 5781;
5791 -> 5761;
5791 -> 5779;
5792 -> 5781;
5792 -> 5779;
5793 -> 5779;
5794 -> 5792;
5794 -> 5793;
5794 -> 5761;
5794 -> 5772;
5794 -> 5779;
5795 -> 5782;
5795 -> 5761;
5795 -> 5779;
5796 -> 5782;
5796 -> 5779;
5797 -> 5779;
5798 -> 5796;
5798 -> 5797;
5798 -> 5761;
5798 -> 5772;
5798 -> 5794;
5798 -> 5779;
5799 -> 5780;
5799 -> 5779;
5800 -> 5779;
5801 -> 5799;
5801 -> 5800;
5801 -> 5761;
5801 -> 5798;
5801 -> 5779;
5802 -> 5780;
5802 -> 5779;
5803 -> 5779;
5804 -> 5802;
5804 -> 5803;
5804 -> 5761;
5804 -> 5801;
5804 -> 5779;
5805 -> 5783;
5805 -> 5804;
5805 -> 5779;
5806 -> 5805;
5806 -> 5803;
5807 -> 5803;
5808 -> 5806;
5808 -> 5807;
5809 -> 0;
5809 -> 5807;
5810 -> 5809;
5810 -> 5803;
5811 -> 5805;
5811 -> 5810;
5811 -> 5779;
5812 -> 5806;
5812 -> 5807;
5813 -> 0;
5813 -> 5807;
5814 -> 5813;
5814 -> 5803;
5815 -> 5805;
5815 -> 5810;
5815 -> 5814;
5815 -> 5779;
5816 -> 5780;
5816 -> 5786;
5816 -> 5779;
5817 -> 5781;
5817 -> 5786;
5817 -> 5779;
5818 -> 5782;
5818 -> 5786;
5818 -> 5779;
5819 -> 5783;
5819 -> 5786;
5819 -> 5779;
5820 -> 5784;
5820 -> 5786;
5820 -> 5779;
5821 -> 5785;
5821 -> 5786;
5821 -> 5779;
5822 -> 5778;
5822 -> 3652;
5823 -> 5822;
5823 -> 3645;
5824 -> 3646;
5824 -> 5804;
5824 -> 3645;
5825 -> 5823;
5825 -> 3645;
5826 -> 3645;
5827 -> 5824;
5827 -> 5825;
5827 -> 5826;
5827 -> 5819;
5827 -> 5820;
5827 -> 5821;
5827 -> 5816;
5827 -> 5817;
5827 -> 5818;
5827 -> 5804;
5827 -> 5761;
5827 -> 5772;
5827 -> 3645;
5828 -> 3645;
5829 -> 5827;
5829 -> 5828;
5829 -> 3645;
5830 -> 3650;
5830 -> 3645;
5831 -> 3645;
5832 -> 5830;
5832 -> 5831;
5833 -> 3646;
5833 -> 5831;
5834 -> 5831;
5835 -> 5833;
5835 -> 5834;
5836 -> 5835;
5836 -> 5827;
5836 -> 5834;
5837 -> 5836;
5837 -> 5831;
5838 -> 5832;
5838 -> 3650;
5838 -> 5831;
5839 -> 3645;
5840 -> 3650;
5840 -> 3645;
5841 -> 3645;
5842 -> 5841;
5842 -> 3646;
5842 -> 3645;
5843 -> 5823;
5843 -> 3645;
5844 -> 5843;
5844 -> 3641;
5845 -> 3641;
5846 -> 3643;
5846 -> 5845;
5847 -> 5845;
5848 -> 5847;
5848 -> 5845;
5849 -> 5845;
5850 -> 5848;
5850 -> 5849;
5851 -> 5846;
5851 -> 5849;
5852 -> 5849;
5853 -> 5851;
5853 -> 5852;
5854 -> 5852;
5855 -> 5854;
5855 -> 5849;
5856 -> 5849;
5857 -> 5851;
5857 -> 5856;
5858 -> 5857;
5858 -> 5827;
5858 -> 5856;
5859 -> 5858;
5859 -> 5849;
5860 -> 5849;
5861 -> 5859;
5861 -> 5860;
5862 -> 0;
5862 -> 5860;
5863 -> 5862;
5863 -> 5849;
5864 -> 5855;
5864 -> 5863;
5864 -> 5849;
5865 -> 5849;
5866 -> 5851;
5866 -> 5865;
5867 -> 5865;
5868 -> 5866;
5868 -> 5867;
5869 -> 5868;
5869 -> 5827;
5869 -> 5867;
5870 -> 5869;
5870 -> 5865;
5871 -> 5865;
5872 -> 5870;
5873 -> 5870;
5874 -> 5872;
5874 -> 5873;
5874 -> 5870;
5875 -> 5872;
5875 -> 5874;
5876 -> 5875;
5876 -> 5849;
5877 -> 5849;
5878 -> 5876;
5878 -> 5877;
5879 -> 5877;
5880 -> 5878;
5880 -> 5879;
5881 -> 5880;
5881 -> 5827;
5881 -> 5879;
5882 -> 5877;
5883 -> 5881;
5884 -> 5881;
5884 -> 5883;
5885 -> 5884;
5885 -> 5827;
5885 -> 5883;
5886 -> 5885;
5887 -> 5885;
5888 -> 5877;
5889 -> 5888;
5889 -> 5849;
5890 -> 5849;
5891 -> 5864;
5891 -> 5889;
5891 -> 5849;
5892 -> 5849;
5893 -> 5849;
5894 -> 5893;
5894 -> 3641;
5895 -> 5844;
5895 -> 5827;
5895 -> 5894;
5895 -> 3641;
5896 -> 5844;
5896 -> 5827;
5896 -> 5895;
5897 -> 5895;
5898 -> 0;
5898 -> 5895;
5899 -> 5896;
5899 -> 5897;
5899 -> 5898;
5899 -> 5827;
5899 -> 5842;
5899 -> 5895;
5900 -> 5899;
5900 -> 5897;
5901 -> 5900;
5901 -> 5899;
5901 -> 5897;
5902 -> 5899;
5902 -> 5897;
5903 -> 5897;
5904 -> 5902;
5904 -> 5903;
5905 -> 5904;
5905 -> 5901;
5905 -> 0;
5905 -> 5903;
5906 -> 5905;
5906 -> 5897;
5907 -> 5906;
5907 -> 5895;
5908 -> 5895;
5909 -> 3643;
5909 -> 5908;
5910 -> 5908;
5911 -> 5909;
5911 -> 5906;
5911 -> 5910;
5911 -> 5908;
5912 -> 5911;
5913 -> 5909;
5913 -> 5906;
5913 -> 5911;
5914 -> 5912;
5914 -> 5911;
5915 -> 5911;
5916 -> 5914;
5916 -> 5915;
5917 -> 5909;
5917 -> 5915;
5918 -> 5915;
5919 -> 5915;
5920 -> 5917;
5920 -> 5906;
5920 -> 5915;
5921 -> 5915;
5922 -> 5917;
5922 -> 5921;
5923 -> 5922;
5923 -> 5915;
5924 -> 5915;
5925 -> 2977;
5925 -> 2976;
5925 -> 5924;
5925 -> 5915;
5926 -> 5915;
5927 -> 5918;
5927 -> 5926;
5927 -> 5915;
5928 -> 5927;
5928 -> 5915;
5929 -> 2977;
5929 -> 5928;
5930 -> 5918;
5930 -> 5915;
5931 -> 5929;
5931 -> 5911;
5932 -> 5911;
5933 -> 5912;
5933 -> 5931;
5934 -> 5931;
5935 -> 5933;
5935 -> 5934;
5936 -> 5909;
5936 -> 5934;
5937 -> 5934;
5938 -> 5936;
5938 -> 5937;
5939 -> 5938;
5939 -> 5934;
5940 -> 5935;
5940 -> 5912;
5940 -> 5934;
5941 -> 5931;
5942 -> 0;
5942 -> 5931;
5943 -> 5931;
5944 -> 5942;
5944 -> 5943;
5945 -> 5912;
5945 -> 5911;
5946 -> 5909;
5946 -> 5931;
5946 -> 5908;
5947 -> 5946;
5947 -> 5895;
5948 -> 5895;
5949 -> 5907;
5949 -> 5948;
5950 -> 5947;
5950 -> 5948;
5951 -> 5950;
5951 -> 5948;
5952 -> 5951;
5952 -> 5931;
5952 -> 5944;
5952 -> 5948;
5953 -> 5895;
5954 -> 5906;
5954 -> 3641;
5955 -> 3642;
5955 -> 3641;
5956 -> 3641;
5957 -> 5954;
5957 -> 5956;
5958 -> 5955;
5958 -> 5956;
5959 -> 3643;
5959 -> 5956;
5960 -> 5957;
5960 -> 5931;
5960 -> 5956;
5961 -> 5957;
5961 -> 5931;
5961 -> 5956;
5962 -> 5960;
5962 -> 5961;
5962 -> 5931;
5962 -> 5944;
5962 -> 5956;
5963 -> 2440;
5963 -> 5956;
5964 -> 5960;
5964 -> 5956;
5965 -> 5964;
5965 -> 5962;
5965 -> 5956;
5966 -> 5963;
5966 -> 2430;
5966 -> 2431;
5966 -> 2432;
5966 -> 2433;
5966 -> 2434;
5966 -> 2435;
5966 -> 2436;
5966 -> 5965;
5967 -> 5957;
5967 -> 5965;
5967 -> 5962;
5968 -> 5967;
5969 -> 5968;
5969 -> 5967;
5970 -> 5963;
5970 -> 5966;
5970 -> 5967;
5971 -> 5963;
5971 -> 5966;
5971 -> 5967;
5972 -> 5963;
5972 -> 5971;
5972 -> 5967;
5973 -> 5967;
5974 -> 5968;
5974 -> 5973;
5975 -> 5974;
5975 -> 5967;
5975 -> 0;
5975 -> 5973;
5976 -> 5973;
5977 -> 5975;
5977 -> 5967;
5978 -> 5960;
5978 -> 5967;
5979 -> 3641;
5980 -> 5957;
5980 -> 3641;
5981 -> 5980;
5981 -> 3638;
5982 -> 3636;
5982 -> 5978;
5982 -> 3638;
5983 -> 5981;
5983 -> 3638;
5984 -> 3638;
5985 -> 5982;
5985 -> 5983;
5985 -> 5984;
5985 -> 5978;
5985 -> 3638;
5986 -> 3639;
5986 -> 5985;
5987 -> 5985;
5988 -> 5986;
5988 -> 5987;
5989 -> 3636;
5989 -> 5987;
5990 -> 5987;
5991 -> 5989;
5991 -> 5990;
5992 -> 5991;
5992 -> 5987;
5993 -> 5988;
5993 -> 3639;
5993 -> 5987;
5994 -> 5985;
5995 -> 0;
5995 -> 5985;
5996 -> 5985;
5997 -> 5995;
5997 -> 5996;
5998 -> 3639;
5998 -> 3638;
5999 -> 0;
5999 -> 3635;
6000 -> 3635;
6001 -> 3635;
6002 -> 5999;
6002 -> 6001;
6003 -> 6000;
6003 -> 6001;
6004 -> 3636;
6004 -> 5985;
6004 -> 6001;
6005 -> 6002;
6005 -> 6001;
6006 -> 6001;
6007 -> 6005;
6007 -> 6006;
6008 -> 6004;
6008 -> 6006;
6009 -> 6008;
6009 -> 5985;
6009 -> 5997;
6009 -> 6007;
6009 -> 6006;
6010 -> 6009;
6011 -> 3636;
6011 -> 5985;
6011 -> 3635;
6012 -> 6011;
6012 -> 3628;
6013 -> 6012;
6013 -> 3627;
6014 -> 3627;
6015 -> 6013;
6015 -> 6014;
6015 -> 5985;
6015 -> 5997;
6015 -> 3627;
6016 -> 3625;
6016 -> 6015;
6016 -> 3627;
6017 -> 6015;
6017 -> 3627;
6018 -> 3625;
6018 -> 6016;
6018 -> 3627;
6019 -> 6018;
6019 -> 3624;
6020 -> 6019;
6020 -> 3623;
6021 -> 3623;
6022 -> 6020;
6022 -> 6019;
6022 -> 6021;
6022 -> 3623;
6023 -> 0;
6023 -> 6022;
6024 -> 6022;
6025 -> 6023;
6025 -> 6024;
6026 -> 6023;
6026 -> 6024;
6027 -> 6026;
6027 -> 6024;
6028 -> 6025;
6028 -> 6026;
6028 -> 6024;
6029 -> 6025;
6029 -> 6024;
6030 -> 6024;
6031 -> 6029;
6031 -> 6030;
6032 -> 6026;
6032 -> 6030;
6033 -> 6031;
6033 -> 6030;
6034 -> 6030;
6035 -> 6030;
6036 -> 6033;
6036 -> 6035;
6037 -> 6034;
6037 -> 6035;
6038 -> 6032;
6038 -> 6035;
6039 -> 6036;
6039 -> 6035;
6040 -> 6036;
6040 -> 6035;
6041 -> 6037;
6041 -> 6035;
6042 -> 6035;
6043 -> 6040;
6043 -> 6042;
6044 -> 6041;
6044 -> 6042;
6045 -> 6038;
6045 -> 6042;
6046 -> 6045;
6046 -> 6043;
6046 -> 6042;
6047 -> 6023;
6047 -> 6024;
6048 -> 6024;
6049 -> 6047;
6049 -> 6048;
6050 -> 6049;
6050 -> 6046;
6050 -> 6048;
6051 -> 6050;
6051 -> 6024;
6052 -> 6024;
6053 -> 6047;
6053 -> 6052;
6054 -> 6052;
6055 -> 6053;
6055 -> 6054;
6056 -> 6054;
6056 -> 6052;
6057 -> 6053;
6057 -> 6052;
6058 -> 6057;
6058 -> 6046;
6058 -> 6052;
6059 -> 6058;
6059 -> 6024;
6060 -> 6024;
6061 -> 6059;
6061 -> 6060;
6061 -> 6024;
6062 -> 6024;
6063 -> 6051;
6063 -> 6046;
6063 -> 6062;
6063 -> 6024;
6064 -> 6063;
6064 -> 6024;
6065 -> 6059;
6065 -> 6064;
6066 -> 6064;
6067 -> 6064;
6067 -> 6066;
6068 -> 6065;
6068 -> 6066;
6069 -> 6064;
6069 -> 6066;
6070 -> 6067;
6070 -> 6064;
6070 -> 6066;
6071 -> 6067;
6071 -> 6064;
6071 -> 6066;
6072 -> 6068;
6072 -> 6066;
6073 -> 6066;
6074 -> 6070;
6074 -> 6073;
6075 -> 6071;
6075 -> 6073;
6076 -> 6072;
6076 -> 6073;
6077 -> 6069;
6077 -> 6073;
6078 -> 6073;
6079 -> 6074;
6079 -> 6078;
6079 -> 6073;
6080 -> 6074;
6080 -> 6079;
6081 -> 6079;
6082 -> 6080;
6082 -> 6081;
6083 -> 6076;
6083 -> 6081;
6084 -> 6083;
6084 -> 6082;
6084 -> 6081;
6085 -> 6075;
6085 -> 6073;
6086 -> 6084;
6086 -> 6073;
6087 -> 6085;
6087 -> 6073;
6088 -> 6077;
6088 -> 6073;
6089 -> 6073;
6090 -> 6087;
6090 -> 6089;
6090 -> 6073;
6091 -> 6073;
6092 -> 6086;
6092 -> 6091;
6092 -> 6073;
6093 -> 6086;
6093 -> 6088;
6093 -> 6073;
6094 -> 6087;
6094 -> 6088;
6094 -> 6073;
6095 -> 6023;
6095 -> 6064;
6095 -> 6084;
6095 -> 6093;
6095 -> 6094;
6095 -> 6022;
6096 -> 6023;
6096 -> 6024;
6097 -> 6096;
6097 -> 6095;
6097 -> 6024;
6098 -> 6024;
6099 -> 6096;
6099 -> 6098;
6100 -> 6098;
6101 -> 6099;
6101 -> 6100;
6102 -> 0;
6102 -> 6100;
6103 -> 6102;
6103 -> 6098;
6104 -> 6099;
6104 -> 6098;
6105 -> 6104;
6105 -> 6095;
6105 -> 6098;
6106 -> 6105;
6106 -> 6024;
6107 -> 6024;
6108 -> 6024;
6109 -> 6097;
6109 -> 6108;
6110 -> 6106;
6110 -> 6108;
6111 -> 6107;
6111 -> 6108;
6112 -> 6108;
6113 -> 6111;
6113 -> 6112;
6114 -> 6112;
6115 -> 6113;
6115 -> 6112;
6116 -> 6112;
6117 -> 6109;
6117 -> 6116;
6117 -> 6112;
6118 -> 6112;
6119 -> 6110;
6119 -> 6118;
6119 -> 6112;
6120 -> 6024;
6121 -> 6023;
6121 -> 6120;
6122 -> 6120;
6122 -> 6024;
6123 -> 6052;
6124 -> 6023;
6124 -> 6120;
6125 -> 0;
6125 -> 6120;
6126 -> 6125;
6126 -> 6024;
6127 -> 6052;
6128 -> 6023;
6128 -> 6024;
6129 -> 6023;
6129 -> 6024;
6130 -> 6024;
6131 -> 6024;
6132 -> 6128;
6132 -> 6131;
6133 -> 6132;
6133 -> 6110;
6133 -> 6131;
6134 -> 6133;
6134 -> 6024;
6135 -> 6024;
6136 -> 6129;
6136 -> 6135;
6137 -> 6136;
6137 -> 6110;
6137 -> 6135;
6138 -> 6137;
6138 -> 6024;
6139 -> 6134;
6139 -> 6138;
6139 -> 6024;
6140 -> 6024;
6141 -> 6128;
6141 -> 6140;
6142 -> 6141;
6142 -> 6110;
6142 -> 6140;
6143 -> 6142;
6143 -> 6024;
6144 -> 6024;
6145 -> 6129;
6145 -> 6144;
6146 -> 6145;
6146 -> 6110;
6146 -> 6144;
6147 -> 6146;
6147 -> 6024;
6148 -> 6143;
6148 -> 6147;
6148 -> 6024;
6149 -> 6033;
6149 -> 6035;
6150 -> 6034;
6150 -> 6035;
6151 -> 6032;
6151 -> 6035;
6152 -> 6149;
6152 -> 6035;
6153 -> 6149;
6153 -> 6035;
6154 -> 6149;
6154 -> 6035;
6155 -> 6150;
6155 -> 6035;
6156 -> 6035;
6157 -> 6154;
6157 -> 6156;
6158 -> 6155;
6158 -> 6156;
6159 -> 6151;
6159 -> 6156;
6160 -> 6159;
6160 -> 6157;
6160 -> 6156;
6161 -> 6023;
6161 -> 6160;
6161 -> 6148;
6161 -> 6022;
6162 -> 6161;
6162 -> 6116;
6162 -> 6112;
6163 -> 6161;
6163 -> 6118;
6163 -> 6112;
6164 -> 6161;
6164 -> 6060;
6164 -> 6024;
6165 -> 6161;
6166 -> 6161;
6167 -> 6132;
6167 -> 6161;
6167 -> 6131;
6168 -> 6167;
6168 -> 6024;
6169 -> 6136;
6169 -> 6161;
6169 -> 6135;
6170 -> 6169;
6170 -> 6024;
6171 -> 6168;
6171 -> 6170;
6171 -> 6024;
6172 -> 3618;
6172 -> 6161;
6172 -> 6022;
6173 -> 6161;
6173 -> 6022;
6174 -> 3623;
6175 -> 3618;
6175 -> 6172;
6175 -> 6174;
6176 -> 6175;
6176 -> 6172;
6176 -> 6174;
6177 -> 3362;
6177 -> 6174;
6178 -> 3623;
6179 -> 6161;
6179 -> 3623;
6180 -> 6179;
6180 -> 1;
6181 -> 6180;
6181 -> 6161;
6181 -> 6172;
6181 -> 6176;
6181 -> 1;
6182 -> 1;
6183 -> 6181;
6183 -> 6182;
6184 -> 6182;
6185 -> 6183;
6185 -> 6184;
6186 -> 0;
6186 -> 6184;
6187 -> 6184;
6188 -> 6186;
6188 -> 6187;
6189 -> 6185;
6189 -> 6187;
6190 -> 6187;
6191 -> 6188;
6191 -> 6190;
6191 -> 6187;
6192 -> 6187;
6193 -> 6189;
6193 -> 6181;
6193 -> 6192;
6193 -> 6187;
6194 -> 6187;
6195 -> 6189;
6195 -> 6194;
6196 -> 6194;
6197 -> 6195;
6197 -> 6196;
6198 -> 6196;
6199 -> 6197;
6199 -> 6181;
6199 -> 6198;
6199 -> 6196;
6200 -> 6199;
6200 -> 6194;
6201 -> 6200;
6201 -> 6187;
6202 -> 6201;
6202 -> 6187;
6203 -> 6187;
6204 -> 6202;
6204 -> 6203;
6205 -> 6204;
6205 -> 6199;
6205 -> 6203;
6206 -> 6205;
6206 -> 6199;
6206 -> 6187;
6207 -> 6187;
6208 -> 6189;
6208 -> 6207;
6209 -> 6207;
6210 -> 6208;
6210 -> 6209;
6211 -> 0;
6211 -> 6209;
6212 -> 6211;
6212 -> 6207;
6213 -> 6207;
6214 -> 6213;
6215 -> 6208;
6215 -> 6199;
6215 -> 6214;
6216 -> 6213;
6217 -> 6207;
6218 -> 6215;
6218 -> 6187;
6219 -> 6187;
6220 -> 6187;
6221 -> 6220;
6221 -> 6187;
6222 -> 6187;
6223 -> 6187;
6224 -> 6189;
6224 -> 6223;
6225 -> 6223;
6226 -> 6225;
6226 -> 6187;
6227 -> 6187;
6228 -> 6226;
6228 -> 6227;
6228 -> 6187;
6229 -> 6228;
6230 -> 6189;
6230 -> 6229;
6231 -> 6230;
6231 -> 6199;
6231 -> 6229;
6232 -> 6231;
6232 -> 6228;
6233 -> 6228;
6234 -> 6228;
6235 -> 6232;
6235 -> 6234;
6236 -> 6233;
6236 -> 6234;
6237 -> 6218;
6237 -> 6234;
6238 -> 6236;
6238 -> 6234;
6239 -> 6234;
6240 -> 6234;
6241 -> 6239;
6241 -> 6240;
6242 -> 6241;
6242 -> 6240;
6243 -> 6240;
6244 -> 6243;
6245 -> 6244;
6246 -> 6237;
6246 -> 6235;
6246 -> 6244;
6247 -> 6240;
6248 -> 6240;
6249 -> 6237;
6249 -> 6246;
6249 -> 6240;
6250 -> 6240;
6251 -> 6249;
6251 -> 6250;
6251 -> 6240;
6252 -> 6248;
6252 -> 6240;
6253 -> 6249;
6253 -> 6252;
6253 -> 6246;
6253 -> 6240;
6254 -> 6241;
6254 -> 6240;
6255 -> 6240;
6256 -> 6254;
6256 -> 6255;
6257 -> 6256;
6257 -> 6255;
6258 -> 6255;
6259 -> 6255;
6260 -> 6257;
6260 -> 6259;
6261 -> 6258;
6261 -> 6259;
6262 -> 6261;
6262 -> 6259;
6263 -> 6261;
6263 -> 6259;
6264 -> 6261;
6264 -> 6259;
6265 -> 6261;
6265 -> 6259;
6266 -> 6261;
6266 -> 6259;
6267 -> 6261;
6267 -> 6259;
6268 -> 6260;
6268 -> 6261;
6268 -> 6259;
6269 -> 6261;
6269 -> 6259;
6270 -> 6259;
6271 -> 6259;
6272 -> 6271;
6272 -> 6261;
6272 -> 6259;
6273 -> 6259;
6274 -> 6259;
6275 -> 6273;
6275 -> 6274;
6276 -> 6274;
6277 -> 6275;
6277 -> 6276;
6278 -> 6277;
6278 -> 6276;
6279 -> 6277;
6279 -> 6276;
6280 -> 6277;
6280 -> 6276;
6281 -> 6277;
6281 -> 6276;
6282 -> 6277;
6282 -> 6276;
6283 -> 6276;
6284 -> 6237;
6284 -> 6283;
6284 -> 6276;
6285 -> 6277;
6285 -> 6276;
6286 -> 6285;
6286 -> 6278;
6286 -> 6279;
6286 -> 6280;
6286 -> 6281;
6286 -> 6282;
6286 -> 6276;
6287 -> 6276;
6288 -> 6273;
6288 -> 6261;
6288 -> 6259;
6289 -> 6258;
6289 -> 6255;
6290 -> 6255;
6291 -> 6290;
6292 -> 6290;
6293 -> 6253;
6293 -> 6292;
6293 -> 6290;
6294 -> 6291;
6294 -> 6290;
6295 -> 6253;
6295 -> 6294;
6295 -> 6290;
6296 -> 6206;
6296 -> 6228;
6297 -> 6228;
6298 -> 6228;
6299 -> 6296;
6299 -> 6298;
6300 -> 6297;
6300 -> 6298;
6301 -> 6297;
6301 -> 6298;
6302 -> 6295;
6302 -> 6298;
6303 -> 6299;
6303 -> 6295;
6303 -> 6298;
6304 -> 6298;
6305 -> 6298;
6306 -> 6299;
6306 -> 6295;
6306 -> 6305;
6306 -> 6298;
6307 -> 6300;
6307 -> 6298;
6308 -> 6301;
6308 -> 6298;
6309 -> 6298;
6310 -> 6307;
6310 -> 6309;
6311 -> 6308;
6311 -> 6309;
6312 -> 6309;
6313 -> 6306;
6313 -> 6312;
6313 -> 6309;
6314 -> 6311;
6314 -> 6309;
6315 -> 6309;
6316 -> 6315;
6317 -> 6316;
6317 -> 6315;
6318 -> 6316;
6318 -> 6315;
6319 -> 6316;
6319 -> 6315;
6320 -> 6316;
6320 -> 6315;
6321 -> 6310;
6321 -> 6309;
6322 -> 6311;
6322 -> 6309;
6323 -> 6309;
6324 -> 6321;
6324 -> 6323;
6325 -> 6322;
6325 -> 6323;
6326 -> 6323;
6327 -> 6323;
6328 -> 6324;
6328 -> 6327;
6329 -> 6326;
6329 -> 6327;
6330 -> 6329;
6330 -> 6327;
6331 -> 6328;
6331 -> 6330;
6332 -> 6324;
6332 -> 6326;
6332 -> 6323;
6333 -> 6325;
6333 -> 6326;
6333 -> 6323;
6334 -> 6332;
6334 -> 6333;
6334 -> 6323;
6335 -> 6324;
6335 -> 6302;
6335 -> 6323;
6336 -> 6325;
6336 -> 6302;
6336 -> 6323;
6337 -> 6309;
6338 -> 6309;
6339 -> 6338;
6340 -> 6339;
6341 -> 6306;
6341 -> 6340;
6342 -> 6306;
6342 -> 6340;
6343 -> 6341;
6343 -> 6306;
6343 -> 6340;
6344 -> 6340;
6345 -> 6343;
6345 -> 6344;
6346 -> 6342;
6346 -> 6344;
6347 -> 6346;
6347 -> 6345;
6347 -> 6306;
6347 -> 6344;
6348 -> 6347;
6348 -> 6344;
6349 -> 6347;
6349 -> 6344;
6350 -> 6348;
6350 -> 6347;
6350 -> 6344;
6351 -> 6344;
6352 -> 6350;
6352 -> 6351;
6353 -> 6349;
6353 -> 6351;
6354 -> 6353;
6354 -> 6352;
6354 -> 6347;
6354 -> 6351;
6355 -> 6351;
6356 -> 4034;
6356 -> 6355;
6357 -> 6355;
6358 -> 6355;
6359 -> 6358;
6360 -> 6354;
6360 -> 6359;
6361 -> 6359;
6362 -> 6359;
6363 -> 6359;
6364 -> 6362;
6364 -> 6363;
6365 -> 6362;
6365 -> 6358;
6366 -> 6358;
6367 -> 6358;
6368 -> 6365;
6368 -> 6358;
6369 -> 6366;
6369 -> 6358;
6370 -> 6358;
6371 -> 6354;
6372 -> 6371;
6372 -> 6354;
6373 -> 6354;
6374 -> 6354;
6374 -> 6373;
6375 -> 6374;
6375 -> 6354;
6375 -> 6373;
6376 -> 6375;
6376 -> 6354;
6377 -> 6354;
6378 -> 6354;
6379 -> 6354;
6380 -> 6354;
6381 -> 6354;
6382 -> 6354;
6383 -> 6354;
6384 -> 6354;
6385 -> 6354;
6386 -> 6354;
6387 -> 6386;
6388 -> 6354;
6389 -> 6354;
6390 -> 6354;
6390 -> 6389;
6391 -> 0;
6391 -> 6389;
6392 -> 6391;
6392 -> 6354;
6393 -> 6354;
6394 -> 6354;
6395 -> 6344;
6396 -> 6354;
6396 -> 6395;
6397 -> 6354;
6397 -> 6395;
6398 -> 0;
6398 -> 6395;
6399 -> 6395;
6400 -> 6398;
6400 -> 6399;
6401 -> 6397;
6401 -> 6309;
6402 -> 0;
6402 -> 6228;
6403 -> 6189;
6403 -> 6228;
6404 -> 6228;
6405 -> 6402;
6405 -> 6404;
6406 -> 6403;
6406 -> 6404;
6407 -> 6401;
6407 -> 6404;
6408 -> 6404;
6409 -> 6406;
6409 -> 6408;
6409 -> 6404;
6410 -> 6407;
6410 -> 6404;
6411 -> 6407;
6411 -> 6397;
6411 -> 6405;
6411 -> 6404;
6412 -> 6406;
6412 -> 6404;
6413 -> 6404;
6414 -> 6404;
6415 -> 6410;
6415 -> 6414;
6416 -> 6411;
6416 -> 6414;
6417 -> 6412;
6417 -> 6414;
6418 -> 6413;
6418 -> 6414;
6419 -> 6415;
6419 -> 6414;
6420 -> 6416;
6420 -> 6414;
6421 -> 6414;
6422 -> 6419;
6422 -> 6421;
6423 -> 6420;
6423 -> 6421;
6424 -> 6418;
6424 -> 6421;
6425 -> 6424;
6425 -> 6421;
6426 -> 6424;
6426 -> 6421;
6427 -> 6424;
6427 -> 6421;
6428 -> 6424;
6428 -> 6421;
6429 -> 6424;
6429 -> 6421;
6430 -> 6421;
6431 -> 6422;
6431 -> 6430;
6431 -> 6421;
6432 -> 6423;
6432 -> 6421;
6433 -> 0;
6433 -> 6421;
6434 -> 6421;
6435 -> 6432;
6435 -> 6434;
6436 -> 6433;
6436 -> 6434;
6437 -> 6423;
6437 -> 6421;
6438 -> 0;
6438 -> 6421;
6439 -> 6421;
6440 -> 6437;
6440 -> 6439;
6441 -> 6438;
6441 -> 6439;
6442 -> 6422;
6442 -> 6424;
6442 -> 6421;
6443 -> 6423;
6443 -> 6424;
6443 -> 6421;
6444 -> 6422;
6444 -> 6397;
6444 -> 6424;
6444 -> 6421;
6445 -> 6418;
6445 -> 6414;
6446 -> 6414;
6447 -> 6414;
6448 -> 6417;
6448 -> 6447;
6449 -> 6446;
6449 -> 6447;
6450 -> 6449;
6450 -> 6447;
6451 -> 6448;
6451 -> 6450;
6452 -> 6417;
6452 -> 6446;
6452 -> 6414;
6453 -> 6417;
6453 -> 6418;
6453 -> 6414;
6454 -> 6413;
6454 -> 6228;
6455 -> 6228;
6456 -> 6189;
6456 -> 6455;
6457 -> 6456;
6457 -> 6397;
6457 -> 6455;
6458 -> 6457;
6458 -> 6228;
6459 -> 6228;
6460 -> 6458;
6460 -> 6459;
6461 -> 6459;
6462 -> 6460;
6462 -> 0;
6462 -> 6459;
6463 -> 6206;
6463 -> 6462;
6464 -> 6222;
6464 -> 6462;
6465 -> 6462;
6466 -> 6462;
6467 -> 6463;
6467 -> 6466;
6468 -> 6464;
6468 -> 6466;
6469 -> 6465;
6469 -> 6466;
6470 -> 6465;
6470 -> 6466;
6471 -> 6454;
6471 -> 6466;
6472 -> 6467;
6472 -> 6466;
6473 -> 6468;
6473 -> 6466;
6474 -> 6469;
6474 -> 6466;
6475 -> 6470;
6475 -> 6466;
6476 -> 6466;
6477 -> 6472;
6477 -> 6476;
6478 -> 6473;
6478 -> 6476;
6479 -> 6474;
6479 -> 6476;
6480 -> 6475;
6480 -> 6476;
6481 -> 6471;
6481 -> 6476;
6482 -> 6476;
6483 -> 6478;
6483 -> 6482;
6483 -> 6476;
6484 -> 6477;
6484 -> 6476;
6485 -> 6478;
6485 -> 6476;
6486 -> 6479;
6486 -> 6476;
6487 -> 6476;
6488 -> 6479;
6488 -> 6487;
6488 -> 6476;
6489 -> 6488;
6489 -> 6480;
6489 -> 6476;
6490 -> 6476;
6491 -> 6484;
6491 -> 6490;
6492 -> 6485;
6492 -> 6490;
6493 -> 6486;
6493 -> 6490;
6494 -> 6489;
6494 -> 6490;
6495 -> 6481;
6495 -> 6490;
6496 -> 6491;
6496 -> 6460;
6496 -> 6490;
6497 -> 6491;
6497 -> 6496;
6498 -> 6492;
6498 -> 6496;
6499 -> 6496;
6500 -> 6493;
6500 -> 6496;
6501 -> 6496;
6502 -> 6497;
6502 -> 6501;
6503 -> 6498;
6503 -> 6501;
6504 -> 6499;
6504 -> 6501;
6505 -> 6500;
6505 -> 6501;
6506 -> 6499;
6506 -> 6501;
6507 -> 6495;
6507 -> 6501;
6508 -> 6502;
6508 -> 6496;
6508 -> 6501;
6509 -> 6503;
6509 -> 6501;
6510 -> 6505;
6510 -> 6501;
6511 -> 6501;
6512 -> 6501;
6513 -> 6508;
6513 -> 6512;
6514 -> 6509;
6514 -> 6512;
6515 -> 6510;
6515 -> 6512;
6516 -> 6511;
6516 -> 6512;
6517 -> 6507;
6517 -> 6512;
6518 -> 6516;
6518 -> 6512;
6519 -> 6512;
6520 -> 6514;
6520 -> 6519;
6520 -> 6512;
6521 -> 6515;
6521 -> 6518;
6521 -> 6512;
6522 -> 6521;
6522 -> 6512;
6523 -> 6513;
6524 -> 6514;
6524 -> 6513;
6525 -> 6513;
6526 -> 6523;
6526 -> 6525;
6527 -> 6524;
6527 -> 6525;
6528 -> 6517;
6528 -> 6525;
6529 -> 6526;
6529 -> 6525;
6530 -> 6529;
6530 -> 6525;
6531 -> 6527;
6531 -> 6525;
6532 -> 6525;
6533 -> 6530;
6533 -> 6532;
6534 -> 6531;
6534 -> 6532;
6535 -> 6528;
6535 -> 6532;
6536 -> 6533;
6536 -> 6513;
6536 -> 6532;
6537 -> 6534;
6537 -> 6532;
6538 -> 6533;
6538 -> 6532;
6539 -> 6532;
6540 -> 6536;
6540 -> 6539;
6541 -> 6537;
6541 -> 6539;
6542 -> 6538;
6542 -> 6539;
6543 -> 6535;
6543 -> 6539;
6544 -> 6543;
6544 -> 6444;
6544 -> 6539;
6545 -> 6540;
6545 -> 6539;
6546 -> 6542;
6546 -> 6539;
6547 -> 6541;
6547 -> 6539;
6548 -> 6539;
6549 -> 6544;
6549 -> 6548;
6550 -> 6545;
6550 -> 6548;
6551 -> 6546;
6551 -> 6548;
6552 -> 6547;
6552 -> 6548;
6553 -> 6550;
6553 -> 6548;
6554 -> 6548;
6555 -> 6553;
6555 -> 6554;
6556 -> 6549;
6556 -> 6554;
6557 -> 6555;
6557 -> 0;
6557 -> 6554;
6558 -> 6554;
6559 -> 6555;
6559 -> 6554;
6560 -> 6556;
6560 -> 6559;
6560 -> 6536;
6560 -> 6554;
6561 -> 6560;
6562 -> 6561;
6563 -> 6561;
6563 -> 6560;
6564 -> 6555;
6564 -> 6560;
6565 -> 6560;
6566 -> 6564;
6566 -> 6565;
6567 -> 6563;
6567 -> 6565;
6568 -> 6565;
6569 -> 6567;
6569 -> 6568;
6570 -> 6569;
6570 -> 6565;
6571 -> 6566;
6571 -> 6565;
6572 -> 6565;
6573 -> 6571;
6573 -> 6572;
6574 -> 6570;
6574 -> 6572;
6575 -> 6572;
6576 -> 6574;
6576 -> 6575;
6577 -> 6576;
6577 -> 6572;
6578 -> 6577;
6579 -> 6577;
6579 -> 6578;
6580 -> 6578;
6581 -> 6579;
6581 -> 6580;
6582 -> 6580;
6583 -> 6581;
6583 -> 6561;
6583 -> 6582;
6583 -> 6580;
6584 -> 6578;
6585 -> 6579;
6585 -> 6561;
6585 -> 6578;
6586 -> 6585;
6586 -> 6577;
6587 -> 6577;
6588 -> 6572;
6589 -> 6574;
6589 -> 6561;
6589 -> 6588;
6589 -> 6572;
6590 -> 6573;
6590 -> 6589;
6591 -> 6589;
6592 -> 6589;
6593 -> 6592;
6593 -> 6589;
6594 -> 6589;
6595 -> 6590;
6595 -> 6589;
6596 -> 6589;
6597 -> 6595;
6597 -> 6596;
6598 -> 6593;
6598 -> 6596;
6599 -> 6596;
6600 -> 6596;
6601 -> 6598;
6601 -> 6600;
6602 -> 6601;
6602 -> 6596;
6603 -> 6597;
6603 -> 6590;
6603 -> 6596;
6604 -> 6596;
6605 -> 6603;
6605 -> 6604;
6606 -> 6602;
6606 -> 6604;
6607 -> 6606;
6607 -> 6604;
6608 -> 6605;
6608 -> 6604;
6609 -> 6608;
6610 -> 6608;
6611 -> 6608;
6612 -> 6610;
6612 -> 6611;
6613 -> 6607;
6613 -> 6611;
6614 -> 6611;
6615 -> 6613;
6615 -> 6614;
6616 -> 6614;
6617 -> 6615;
6617 -> 6593;
6617 -> 6616;
6617 -> 6614;
6618 -> 6617;
6619 -> 6617;
6620 -> 6615;
6620 -> 6593;
6620 -> 6619;
6621 -> 6620;
6621 -> 6593;
6621 -> 6619;
6622 -> 6621;
6622 -> 6617;
6623 -> 0;
6623 -> 6617;
6624 -> 6622;
6624 -> 6617;
6625 -> 6617;
6626 -> 6624;
6626 -> 6625;
6627 -> 6615;
6627 -> 6625;
6628 -> 6625;
6629 -> 6626;
6629 -> 6628;
6629 -> 6625;
6630 -> 6625;
6631 -> 6625;
6632 -> 6625;
6633 -> 6627;
6633 -> 6632;
6634 -> 6632;
6635 -> 6634;
6635 -> 6625;
6636 -> 6635;
6636 -> 6625;
6637 -> 6635;
6637 -> 6625;
6638 -> 6637;
6639 -> 6626;
6639 -> 6625;
6640 -> 0;
6640 -> 6625;
6641 -> 6630;
6641 -> 6625;
6642 -> 6631;
6642 -> 6625;
6643 -> 6636;
6643 -> 6638;
6643 -> 6639;
6643 -> 6640;
6643 -> 6641;
6643 -> 6642;
6643 -> 6622;
6643 -> 6625;
6644 -> 6643;
6644 -> 6625;
6645 -> 6625;
6646 -> 6644;
6646 -> 6645;
6647 -> 6627;
6647 -> 6645;
6648 -> 6645;
6649 -> 6647;
6649 -> 6643;
6649 -> 6648;
6649 -> 6645;
6650 -> 0;
6650 -> 6649;
6651 -> 6646;
6651 -> 6649;
6652 -> 6651;
6652 -> 6643;
6653 -> 6647;
6653 -> 6651;
6654 -> 6651;
6655 -> 6651;
6656 -> 6652;
6656 -> 6655;
6657 -> 6653;
6657 -> 6655;
6658 -> 6652;
6658 -> 6655;
6659 -> 6654;
6659 -> 6655;
6660 -> 6655;
6661 -> 6659;
6661 -> 6655;
6662 -> 6659;
6662 -> 6655;
6663 -> 6659;
6663 -> 6655;
6664 -> 6655;
6665 -> 6656;
6665 -> 6664;
6665 -> 6655;
6666 -> 6655;
6667 -> 6657;
6667 -> 6666;
6667 -> 6655;
6668 -> 6655;
6669 -> 6658;
6669 -> 6668;
6669 -> 6655;
6670 -> 6657;
6670 -> 6659;
6670 -> 6655;
6671 -> 6656;
6671 -> 6659;
6671 -> 6655;
6672 -> 6658;
6672 -> 6659;
6672 -> 6655;
6673 -> 6651;
6674 -> 6654;
6674 -> 6673;
6675 -> 6674;
6675 -> 6671;
6675 -> 6673;
6676 -> 6675;
6676 -> 6651;
6677 -> 6654;
6677 -> 6651;
6678 -> 6650;
6678 -> 6676;
6678 -> 6677;
6678 -> 6651;
6679 -> 6647;
6679 -> 6643;
6679 -> 6649;
6680 -> 6650;
6680 -> 6649;
6681 -> 6649;
6682 -> 6679;
6682 -> 6680;
6682 -> 6681;
6682 -> 6650;
6682 -> 6643;
6682 -> 6678;
6682 -> 6659;
6682 -> 6670;
6682 -> 6671;
6682 -> 6672;
6682 -> 6649;
6683 -> 6625;
6684 -> 6643;
6684 -> 6625;
6685 -> 6625;
6686 -> 6684;
6686 -> 6685;
6687 -> 6627;
6687 -> 6685;
6688 -> 6685;
6689 -> 6687;
6689 -> 6682;
6689 -> 6688;
6689 -> 6685;
6690 -> 6689;
6691 -> 6687;
6691 -> 6690;
6692 -> 6691;
6692 -> 6682;
6692 -> 6690;
6693 -> 6692;
6693 -> 6689;
6694 -> 6689;
6695 -> 6689;
6696 -> 6693;
6696 -> 6695;
6697 -> 6696;
6697 -> 6689;
6698 -> 6689;
6699 -> 6686;
6699 -> 6689;
6700 -> 6699;
6700 -> 6697;
6700 -> 6689;
6701 -> 6700;
6702 -> 6697;
6702 -> 6701;
6703 -> 6693;
6703 -> 6702;
6704 -> 6687;
6704 -> 6702;
6705 -> 6701;
6705 -> 6702;
6706 -> 0;
6707 -> 6706;
6708 -> 6707;
6710 -> 6709;
6711 -> 6710;
6711 -> 6709;
6712 -> 0;
6712 -> 6710;
6712 -> 6709;
6713 -> 0;
6713 -> 6710;
6713 -> 6709;
6714 -> 6710;
6714 -> 6709;
6715 -> 6710;
6715 -> 6709;
6716 -> 6710;
6716 -> 6709;
6717 -> 6710;
6717 -> 6709;
6718 -> 3417;
6718 -> 6710;
6718 -> 6709;
6719 -> 0;
6719 -> 6710;
6719 -> 6709;
6720 -> 6709;
6721 -> 6700;
6721 -> 6697;
6721 -> 6702;
6722 -> 6702;
6723 -> 6703;
6723 -> 6722;
6724 -> 6704;
6724 -> 6722;
6725 -> 6705;
6725 -> 6722;
6726 -> 6721;
6726 -> 6722;
6727 -> 6722;
6728 -> 6727;
6728 -> 6722;
6729 -> 6722;
6730 -> 6722;
6731 -> 6723;
6731 -> 6722;
6732 -> 6725;
6732 -> 6722;
6733 -> 6727;
6733 -> 6722;
6734 -> 6729;
6734 -> 6722;
6735 -> 6730;
6735 -> 6722;
6736 -> 6722;
6737 -> 6731;
6737 -> 6736;
6738 -> 6732;
6738 -> 6736;
6739 -> 6733;
6739 -> 6736;
6740 -> 6734;
6740 -> 6736;
6741 -> 6735;
6741 -> 6736;
6742 -> 6736;
6743 -> 6737;
6743 -> 6742;
6744 -> 6743;
6744 -> 6736;
6745 -> 6738;
6745 -> 6736;
6746 -> 6744;
6746 -> 6745;
6746 -> 6697;
6746 -> 6736;
6747 -> 6746;
6747 -> 6736;
6748 -> 6736;
6749 -> 6722;
6750 -> 6722;
6751 -> 6722;
6752 -> 6722;
6753 -> 6747;
6753 -> 6752;
6753 -> 6722;
6754 -> 6723;
6754 -> 6753;
6755 -> 6724;
6755 -> 6753;
6756 -> 6725;
6756 -> 6753;
6757 -> 6726;
6757 -> 6753;
6758 -> 6750;
6758 -> 6753;
6759 -> 6753;
6760 -> 6753;
6761 -> 6754;
6761 -> 6760;
6762 -> 6755;
6762 -> 6760;
6763 -> 6756;
6763 -> 6760;
6764 -> 6757;
6764 -> 6760;
6765 -> 6758;
6765 -> 6760;
6766 -> 6759;
6766 -> 6760;
6767 -> 6761;
6767 -> 6760;
6768 -> 6762;
6768 -> 6760;
6769 -> 6763;
6769 -> 6760;
6770 -> 6764;
6770 -> 6760;
6771 -> 6760;
6772 -> 6765;
6772 -> 6760;
6773 -> 6760;
6774 -> 6767;
6774 -> 6773;
6775 -> 6768;
6775 -> 6773;
6776 -> 6769;
6776 -> 6773;
6777 -> 6770;
6777 -> 6773;
6778 -> 6771;
6778 -> 6773;
6779 -> 6772;
6779 -> 6773;
6780 -> 6766;
6780 -> 6773;
6781 -> 6773;
6782 -> 6780;
6782 -> 6781;
6783 -> 6781;
6784 -> 6781;
6785 -> 6782;
6785 -> 6784;
6786 -> 6784;
6787 -> 6785;
6787 -> 6784;
6788 -> 6785;
6788 -> 6784;
6789 -> 6782;
6789 -> 6781;
6790 -> 6782;
6790 -> 6781;
6791 -> 6782;
6791 -> 6781;
6792 -> 6783;
6792 -> 6782;
6792 -> 6781;
6793 -> 6780;
6793 -> 6773;
6794 -> 6780;
6794 -> 6773;
6795 -> 6780;
6795 -> 6773;
6796 -> 6780;
6796 -> 6773;
6797 -> 6780;
6797 -> 6773;
6798 -> 6780;
6798 -> 6773;
6799 -> 6780;
6799 -> 6773;
6800 -> 6780;
6800 -> 6773;
6801 -> 6780;
6801 -> 6773;
6802 -> 3417;
6802 -> 6780;
6802 -> 6773;
6803 -> 6773;
6804 -> 6803;
6804 -> 6780;
6804 -> 6773;
6805 -> 3417;
6805 -> 6780;
6805 -> 6773;
6806 -> 6773;
6807 -> 6806;
6807 -> 6780;
6807 -> 6773;
6808 -> 6780;
6808 -> 6773;
6809 -> 0;
6809 -> 6780;
6809 -> 6773;
6810 -> 6780;
6810 -> 6773;
6811 -> 6780;
6811 -> 6773;
6812 -> 6776;
6812 -> 6697;
6812 -> 6773;
6813 -> 6773;
6814 -> 6775;
6814 -> 6813;
6814 -> 6773;
6815 -> 6773;
6816 -> 6778;
6816 -> 6815;
6816 -> 6773;
6817 -> 6773;
6818 -> 6773;
6819 -> 6773;
6820 -> 6774;
6820 -> 6819;
6821 -> 6820;
6821 -> 6773;
6822 -> 6776;
6822 -> 6773;
6823 -> 6821;
6823 -> 6822;
6823 -> 6746;
6823 -> 6697;
6823 -> 6773;
6824 -> 6776;
6824 -> 6780;
6824 -> 6773;
6825 -> 6775;
6825 -> 6780;
6825 -> 6773;
6826 -> 6773;
6827 -> 6774;
6827 -> 6826;
6828 -> 6827;
6828 -> 6823;
6828 -> 6826;
6829 -> 6828;
6829 -> 6773;
6830 -> 6776;
6830 -> 6773;
6831 -> 6829;
6831 -> 6780;
6831 -> 6773;
6832 -> 6773;
6833 -> 6778;
6833 -> 6832;
6833 -> 6773;
6834 -> 6823;
6834 -> 6780;
6834 -> 6833;
6835 -> 6833;
6836 -> 6773;
6837 -> 6777;
6837 -> 6836;
6837 -> 6773;
6838 -> 6773;
6839 -> 6774;
6839 -> 6838;
6840 -> 6839;
6840 -> 6829;
6840 -> 6838;
6841 -> 6840;
6841 -> 6773;
6842 -> 6773;
6843 -> 6841;
6843 -> 6842;
6844 -> 6842;
6845 -> 6843;
6845 -> 6844;
6846 -> 6845;
6846 -> 6842;
6847 -> 6843;
6847 -> 6842;
6848 -> 6843;
6848 -> 6829;
6848 -> 0;
6848 -> 6842;
6849 -> 6837;
6849 -> 6846;
6849 -> 6773;
6850 -> 6773;
6851 -> 6780;
6851 -> 6850;
6852 -> 0;
6852 -> 6850;
6853 -> 6851;
6853 -> 6831;
6853 -> 0;
6853 -> 6850;
6854 -> 0;
6854 -> 6853;
6855 -> 6854;
6855 -> 6850;
6856 -> 6855;
6856 -> 6773;
6857 -> 6849;
6857 -> 6856;
6857 -> 6773;
6858 -> 0;
6858 -> 6780;
6858 -> 6857;
6859 -> 6818;
6859 -> 6773;
6860 -> 6722;
6861 -> 6748;
6861 -> 6860;
6861 -> 6722;
6862 -> 6759;
6862 -> 6722;
6863 -> 6694;
6863 -> 6862;
6863 -> 6785;
6863 -> 6787;
6863 -> 6788;
6863 -> 6789;
6863 -> 6790;
6863 -> 6792;
6863 -> 6825;
6863 -> 6834;
6863 -> 6831;
6863 -> 6858;
6863 -> 6797;
6863 -> 6798;
6863 -> 6799;
6863 -> 6800;
6863 -> 6801;
6863 -> 6802;
6863 -> 6804;
6863 -> 6805;
6863 -> 6807;
6863 -> 6808;
6863 -> 6809;
6863 -> 6810;
6863 -> 6811;
6863 -> 6824;
6863 -> 3408;
6863 -> 3409;
6863 -> 3410;
6863 -> 3411;
6863 -> 3412;
6863 -> 3414;
6863 -> 3416;
6863 -> 6803;
6863 -> 6806;
6863 -> 0;
6863 -> 6697;
6863 -> 6829;
6863 -> 6702;
6864 -> 6863;
6865 -> 6864;
6865 -> 6863;
6866 -> 6863;
6867 -> 6863;
6868 -> 6864;
6868 -> 6863;
6869 -> 6866;
6869 -> 6863;
6870 -> 6867;
6870 -> 6863;
6871 -> 6863;
6872 -> 6863;
6873 -> 6863;
6874 -> 6863;
6875 -> 6872;
6875 -> 6863;
6876 -> 6863;
6877 -> 6874;
6877 -> 6876;
6878 -> 6874;
6878 -> 6876;
6879 -> 6874;
6879 -> 6876;
6880 -> 6874;
6880 -> 6876;
6881 -> 6874;
6881 -> 6876;
6882 -> 6874;
6882 -> 6876;
6883 -> 6875;
6883 -> 6876;
6884 -> 6874;
6884 -> 6876;
6885 -> 6877;
6885 -> 6876;
6886 -> 6878;
6886 -> 6876;
6887 -> 6879;
6887 -> 6876;
6888 -> 6880;
6888 -> 6876;
6889 -> 6882;
6889 -> 6876;
6890 -> 6883;
6890 -> 6876;
6891 -> 6876;
6892 -> 6885;
6892 -> 6891;
6893 -> 6886;
6893 -> 6891;
6894 -> 6887;
6894 -> 6891;
6895 -> 6888;
6895 -> 6891;
6896 -> 6889;
6896 -> 6891;
6897 -> 6890;
6897 -> 6891;
6898 -> 6884;
6898 -> 6891;
6899 -> 6884;
6899 -> 6891;
6900 -> 6884;
6900 -> 6891;
6901 -> 6884;
6901 -> 6891;
6902 -> 6884;
6902 -> 6891;
6903 -> 6894;
6903 -> 6863;
6903 -> 6891;
6904 -> 6891;
6905 -> 6893;
6905 -> 6904;
6905 -> 6891;
6906 -> 6891;
6907 -> 6896;
6907 -> 6906;
6907 -> 6891;
6908 -> 6891;
6909 -> 6891;
6910 -> 6892;
6910 -> 6894;
6910 -> 6863;
6910 -> 6891;
6911 -> 6910;
6911 -> 6896;
6912 -> 6896;
6913 -> 6911;
6913 -> 6884;
6913 -> 6896;
6914 -> 6884;
6914 -> 6913;
6914 -> 6896;
6915 -> 6910;
6915 -> 6896;
6916 -> 6884;
6916 -> 6913;
6916 -> 6910;
6916 -> 6896;
6917 -> 6884;
6917 -> 6913;
6917 -> 6896;
6918 -> 6910;
6918 -> 6896;
6919 -> 6895;
6919 -> 6910;
6919 -> 6891;
6920 -> 0;
6920 -> 6891;
6921 -> 6909;
6921 -> 6891;
6922 -> 6884;
6922 -> 6876;
6923 -> 6884;
6923 -> 6876;
6924 -> 6876;
6925 -> 6881;
6925 -> 6863;
6925 -> 6924;
6925 -> 6876;
6926 -> 6882;
6926 -> 6884;
6926 -> 6876;
6927 -> 6881;
6927 -> 6884;
6927 -> 6876;
6928 -> 6917;
6928 -> 6884;
6928 -> 6876;
6929 -> 6863;
6930 -> 6871;
6930 -> 6929;
6930 -> 6863;
6931 -> 6694;
6931 -> 6874;
6931 -> 6910;
6931 -> 6884;
6931 -> 6893;
6931 -> 6913;
6931 -> 6919;
6931 -> 6894;
6931 -> 6926;
6931 -> 6928;
6931 -> 6927;
6931 -> 6891;
6931 -> 6863;
6932 -> 6931;
6933 -> 6932;
6933 -> 6931;
6934 -> 6931;
6935 -> 6931;
6936 -> 6932;
6936 -> 6931;
6937 -> 6934;
6937 -> 6931;
6938 -> 6935;
6938 -> 6931;
6939 -> 6931;
6940 -> 6931;
6941 -> 6931;
6942 -> 6940;
6942 -> 6931;
6943 -> 6942;
6943 -> 6931;
6944 -> 6943;
6944 -> 6940;
6945 -> 6940;
6946 -> 6940;
6947 -> 6940;
6948 -> 6940;
6949 -> 6940;
6950 -> 6940;
6950 -> 6931;
6951 -> 6940;
6952 -> 6940;
6953 -> 6940;
6954 -> 6940;
6955 -> 6940;
6956 -> 0;
6956 -> 6940;
6957 -> 6954;
6957 -> 6940;
6958 -> 6940;
6958 -> 6931;
6959 -> 6940;
6959 -> 6931;
6960 -> 6931;
6961 -> 6931;
6962 -> 6939;
6962 -> 6961;
6962 -> 6931;
6963 -> 6940;
6964 -> 6963;
6964 -> 6940;
6965 -> 6940;
6966 -> 6940;
6967 -> 6963;
6967 -> 6940;
6968 -> 6965;
6968 -> 6940;
6969 -> 6966;
6969 -> 6940;
6970 -> 6940;
6971 -> 6940;
6972 -> 6940;
6973 -> 6972;
6973 -> 6940;
6974 -> 6973;
6974 -> 6940;
6975 -> 6940;
6976 -> 6940;
6977 -> 6940;
6978 -> 6970;
6978 -> 6977;
6978 -> 6940;
6979 -> 6963;
6980 -> 6979;
6980 -> 6963;
6981 -> 6980;
6981 -> 6963;
6982 -> 6963;
6983 -> 6963;
6984 -> 6963;
6985 -> 6963;
6986 -> 6963;
6987 -> 6963;
6987 -> 6940;
6988 -> 6963;
6989 -> 6963;
6990 -> 6963;
6991 -> 6963;
6992 -> 6963;
6993 -> 0;
6993 -> 6963;
6994 -> 6991;
6994 -> 6963;
6995 -> 6963;
6996 -> 6963;
6997 -> 6963;
6998 -> 6963;
6999 -> 6996;
6999 -> 6963;
7000 -> 6997;
7000 -> 6963;
7001 -> 6963;
7002 -> 6963;
7003 -> 6963;
7004 -> 6963;
7005 -> 7001;
7005 -> 7004;
7005 -> 6963;
7006 -> 6996;
7006 -> 6963;
7007 -> 6996;
7008 -> 7007;
7008 -> 6996;
7009 -> 7008;
7009 -> 6996;
7010 -> 6996;
7011 -> 6996;
7012 -> 6996;
7013 -> 6996;
7014 -> 6996;
7015 -> 6996;
7015 -> 6963;
7016 -> 6996;
7017 -> 6996;
7018 -> 6996;
7019 -> 6996;
7020 -> 6996;
7021 -> 0;
7021 -> 6996;
7022 -> 7019;
7022 -> 6996;
7023 -> 6689;
7024 -> 0;
7024 -> 6689;
7025 -> 7023;
7025 -> 7024;
7025 -> 6694;
7025 -> 6996;
7025 -> 6689;
7026 -> 7025;
7026 -> 7023;
7027 -> 7026;
7027 -> 7025;
7027 -> 7023;
7028 -> 6694;
7028 -> 7027;
7028 -> 6689;
7029 -> 6689;
7030 -> 6698;
7030 -> 7029;
7030 -> 6689;
7031 -> 6687;
7031 -> 7028;
7031 -> 6689;
7032 -> 7027;
7032 -> 6689;
7033 -> 6689;
7034 -> 6689;
7035 -> 7031;
7035 -> 7034;
7035 -> 6689;
7036 -> 7027;
7036 -> 7035;
7037 -> 7035;
7038 -> 7036;
7038 -> 7037;
7039 -> 6693;
7039 -> 7037;
7040 -> 7037;
7041 -> 7039;
7041 -> 7031;
7041 -> 7040;
7041 -> 7037;
7042 -> 7037;
7043 -> 7039;
7043 -> 7031;
7043 -> 7042;
7044 -> 7043;
7044 -> 7037;
7045 -> 7038;
7045 -> 7031;
7045 -> 7037;
7046 -> 7045;
7047 -> 7046;
7048 -> 7046;
7049 -> 7046;
7049 -> 7048;
7050 -> 7049;
7050 -> 7031;
7050 -> 7048;
7051 -> 7050;
7051 -> 7046;
7052 -> 7046;
7053 -> 7039;
7053 -> 7031;
7053 -> 7051;
7053 -> 7052;
7053 -> 7046;
7054 -> 7053;
7054 -> 7046;
7055 -> 7046;
7056 -> 7046;
7056 -> 7055;
7057 -> 7056;
7057 -> 7053;
7057 -> 7055;
7058 -> 7057;
7058 -> 7046;
7059 -> 7044;
7059 -> 7058;
7059 -> 7046;
7060 -> 7053;
7061 -> 7053;
7062 -> 7053;
7063 -> 7053;
7063 -> 7062;
7064 -> 7063;
7064 -> 7053;
7064 -> 7062;
7065 -> 7064;
7065 -> 7053;
7066 -> 7044;
7066 -> 7065;
7066 -> 7053;
7067 -> 7035;
7068 -> 6625;
7069 -> 6617;
7070 -> 6611;
7071 -> 6611;
7072 -> 6611;
7073 -> 7072;
7073 -> 6611;
7074 -> 6612;
7074 -> 6611;
7075 -> 7071;
7075 -> 6611;
7076 -> 6613;
7076 -> 7053;
7076 -> 7074;
7076 -> 7075;
7076 -> 6611;
7077 -> 6612;
7077 -> 7076;
7078 -> 7072;
7078 -> 7076;
7079 -> 6613;
7079 -> 7076;
7079 -> 7077;
7079 -> 7078;
7079 -> 7073;
7080 -> 7076;
7080 -> 7079;
7081 -> 7080;
7082 -> 7080;
7083 -> 7081;
7083 -> 7082;
7083 -> 7080;
7084 -> 7083;
7085 -> 6609;
7085 -> 7084;
7085 -> 7083;
7086 -> 7081;
7086 -> 7083;
7087 -> 7086;
7087 -> 6608;
7088 -> 6608;
7089 -> 7087;
7089 -> 7088;
7089 -> 6608;
7090 -> 7087;
7090 -> 6604;
7091 -> 6596;
7092 -> 7090;
7092 -> 7091;
7092 -> 6596;
7093 -> 6597;
7093 -> 7092;
7094 -> 7092;
7095 -> 7093;
7095 -> 7094;
7096 -> 7090;
7096 -> 7094;
7097 -> 7095;
7097 -> 6590;
7097 -> 7094;
7098 -> 7096;
7098 -> 7094;
7099 -> 7094;
7100 -> 7098;
7100 -> 7099;
7101 -> 0;
7101 -> 7099;
7102 -> 7101;
7102 -> 7094;
7103 -> 7094;
7104 -> 7094;
7105 -> 7104;
7105 -> 7094;
7106 -> 7094;
7107 -> 7098;
7107 -> 7106;
7108 -> 7106;
7109 -> 7107;
7109 -> 7108;
7110 -> 0;
7110 -> 7108;
7111 -> 7110;
7111 -> 7106;
7112 -> 7111;
7112 -> 7094;
7113 -> 0;
7113 -> 7094;
7114 -> 7094;
7115 -> 7113;
7115 -> 7114;
7116 -> 7098;
7116 -> 7114;
7117 -> 7114;
7118 -> 7116;
7118 -> 7117;
7119 -> 7118;
7119 -> 7080;
7119 -> 7079;
7119 -> 7117;
7120 -> 7118;
7120 -> 7080;
7120 -> 7079;
7120 -> 7119;
7121 -> 7119;
7122 -> 7118;
7122 -> 7121;
7123 -> 7122;
7123 -> 7121;
7124 -> 7121;
7125 -> 7121;
7126 -> 7123;
7126 -> 7125;
7127 -> 7124;
7127 -> 7125;
7128 -> 7125;
7129 -> 7127;
7129 -> 7128;
7130 -> 7128;
7131 -> 7129;
7131 -> 7130;
7132 -> 7127;
7132 -> 7125;
7133 -> 7126;
7133 -> 7125;
7134 -> 7126;
7134 -> 7127;
7134 -> 7125;
7135 -> 7124;
7135 -> 7119;
7136 -> 7119;
7137 -> 7120;
7137 -> 7135;
7137 -> 7136;
7137 -> 7134;
7137 -> 7079;
7137 -> 7080;
7137 -> 7119;
7138 -> 7118;
7138 -> 7137;
7138 -> 7117;
7139 -> 7138;
7139 -> 7114;
7140 -> 7115;
7140 -> 7114;
7141 -> 7114;
7142 -> 7139;
7142 -> 7141;
7143 -> 7140;
7143 -> 7141;
7144 -> 7142;
7144 -> 7141;
7145 -> 7143;
7145 -> 7141;
7146 -> 7141;
7147 -> 7144;
7147 -> 7146;
7148 -> 7145;
7148 -> 7146;
7149 -> 7148;
7149 -> 7146;
7150 -> 7147;
7150 -> 7146;
7151 -> 7146;
7152 -> 7149;
7152 -> 7146;
7153 -> 7146;
7154 -> 7150;
7154 -> 7153;
7155 -> 7151;
7155 -> 7153;
7156 -> 7151;
7156 -> 7153;
7157 -> 7152;
7157 -> 7153;
7158 -> 7151;
7158 -> 7153;
7159 -> 7153;
7160 -> 7154;
7160 -> 7159;
7160 -> 7153;
7161 -> 7158;
7161 -> 7153;
7162 -> 7161;
7163 -> 7155;
7163 -> 7162;
7163 -> 7161;
7164 -> 7161;
7165 -> 7156;
7165 -> 7164;
7165 -> 7161;
7166 -> 7154;
7166 -> 7153;
7167 -> 7153;
7169 -> 7168;
7171 -> 7170;
7172 -> 7167;
7172 -> 7153;
7173 -> 7157;
7173 -> 7153;
7174 -> 7155;
7174 -> 7153;
7175 -> 7156;
7175 -> 7153;
7176 -> 7153;
7177 -> 7153;
7178 -> 7172;
7178 -> 7177;
7179 -> 7173;
7179 -> 7177;
7180 -> 7174;
7180 -> 7177;
7181 -> 7175;
7181 -> 7177;
7182 -> 7176;
7182 -> 7177;
7183 -> 7178;
7183 -> 7177;
7184 -> 7179;
7184 -> 7177;
7185 -> 7177;
7186 -> 7180;
7186 -> 7177;
7187 -> 7181;
7187 -> 7177;
7188 -> 7177;
7189 -> 7188;
7189 -> 7183;
7189 -> 7184;
7189 -> 7185;
7189 -> 7186;
7189 -> 7187;
7189 -> 7167;
7189 -> 0;
7189 -> 7177;
7190 -> 7188;
7190 -> 7177;
7191 -> 7188;
7191 -> 7177;
7192 -> 7179;
7192 -> 7189;
7192 -> 7177;
7193 -> 0;
7193 -> 7177;
7194 -> 7192;
7194 -> 7188;
7194 -> 7177;
7195 -> 7176;
7195 -> 7153;
7196 -> 7153;
7197 -> 7195;
7197 -> 7196;
7198 -> 7154;
7198 -> 7196;
7199 -> 7197;
7199 -> 7196;
7200 -> 7196;
7201 -> 7199;
7201 -> 7200;
7202 -> 7198;
7202 -> 7200;
7203 -> 7202;
7203 -> 7200;
7204 -> 7200;
7205 -> 7203;
7205 -> 7204;
7206 -> 7201;
7206 -> 7204;
7207 -> 7206;
7207 -> 7189;
7207 -> 7204;
7208 -> 7206;
7208 -> 7189;
7208 -> 7190;
7208 -> 7194;
7208 -> 7191;
7208 -> 7204;
7209 -> 0;
7209 -> 7204;
7210 -> 7206;
7210 -> 7189;
7210 -> 7190;
7210 -> 7194;
7210 -> 7191;
7210 -> 0;
7210 -> 7204;
7211 -> 7210;
7212 -> 7205;
7212 -> 7211;
7213 -> 7211;
7214 -> 7212;
7214 -> 7213;
7215 -> 7214;
7215 -> 7137;
7215 -> 7213;
7216 -> 7211;
7217 -> 7215;
7217 -> 7216;
7218 -> 7216;
7219 -> 7217;
7219 -> 7218;
7220 -> 7219;
7220 -> 7137;
7220 -> 7218;
7221 -> 7220;
7221 -> 7216;
7222 -> 7216;
7223 -> 7221;
7224 -> 7221;
7225 -> 7223;
7225 -> 7224;
7225 -> 7221;
7226 -> 7223;
7226 -> 7225;
7227 -> 7211;
7228 -> 7226;
7228 -> 7227;
7229 -> 7228;
7229 -> 7227;
7230 -> 7227;
7231 -> 7229;
7231 -> 7230;
7232 -> 7230;
7233 -> 7231;
7233 -> 7232;
7234 -> 7233;
7235 -> 7234;
7236 -> 7233;
7237 -> 7233;
7238 -> 7233;
7238 -> 7230;
7239 -> 7238;
7239 -> 7210;
7240 -> 7239;
7240 -> 7210;
7241 -> 7210;
7242 -> 7240;
7242 -> 7241;
7243 -> 7206;
7243 -> 7241;
7244 -> 7242;
7244 -> 7241;
7245 -> 7241;
7246 -> 7244;
7246 -> 7245;
7246 -> 7241;
7247 -> 7243;
7247 -> 7189;
7247 -> 7190;
7247 -> 7194;
7247 -> 7191;
7247 -> 0;
7247 -> 7241;
7248 -> 7241;
7249 -> 7244;
7249 -> 7248;
7250 -> 7248;
7251 -> 7249;
7251 -> 7233;
7251 -> 7250;
7252 -> 7250;
7252 -> 7241;
7253 -> 7243;
7253 -> 7189;
7253 -> 7190;
7253 -> 7194;
7253 -> 7191;
7253 -> 0;
7253 -> 7241;
7254 -> 7252;
7254 -> 7253;
7254 -> 7241;
7255 -> 7254;
7255 -> 7210;
7256 -> 7204;
7257 -> 7205;
7257 -> 7256;
7258 -> 7256;
7259 -> 7257;
7259 -> 7233;
7259 -> 7258;
7260 -> 7258;
7261 -> 7260;
7261 -> 7204;
7262 -> 0;
7262 -> 7261;
7263 -> 7205;
7263 -> 7261;
7264 -> 7261;
7265 -> 7205;
7265 -> 7264;
7266 -> 7264;
7267 -> 7265;
7267 -> 7266;
7268 -> 7267;
7268 -> 7233;
7268 -> 7266;
7269 -> 7264;
7270 -> 7268;
7270 -> 7269;
7271 -> 7270;
7271 -> 7261;
7272 -> 7261;
7273 -> 7262;
7273 -> 7272;
7274 -> 7263;
7274 -> 7272;
7275 -> 7271;
7275 -> 7272;
7276 -> 7206;
7276 -> 7272;
7277 -> 7272;
7278 -> 7275;
7278 -> 7277;
7278 -> 7272;
7279 -> 7278;
7279 -> 7272;
7280 -> 7276;
7280 -> 7189;
7280 -> 7190;
7280 -> 7194;
7280 -> 7279;
7281 -> 7280;
7281 -> 7279;
7282 -> 7273;
7282 -> 7272;
7283 -> 7274;
7283 -> 7272;
7284 -> 7281;
7284 -> 7272;
7285 -> 7282;
7285 -> 7283;
7285 -> 7284;
7285 -> 7233;
7285 -> 7272;
7286 -> 7200;
7287 -> 7196;
7288 -> 7153;
7289 -> 7167;
7289 -> 7285;
7289 -> 7153;
7290 -> 7289;
7290 -> 7095;
7290 -> 6590;
7290 -> 7094;
7291 -> 7112;
7291 -> 7290;
7291 -> 7094;
7292 -> 7095;
7292 -> 6590;
7292 -> 7094;
7293 -> 7095;
7293 -> 6590;
7293 -> 7292;
7294 -> 7292;
7295 -> 7095;
7295 -> 6590;
7295 -> 7094;
7296 -> 7095;
7296 -> 6590;
7296 -> 7094;
7297 -> 7296;
7298 -> 7297;
7299 -> 7295;
7299 -> 7298;
7299 -> 7297;
7300 -> 7299;
7301 -> 7095;
7301 -> 6590;
7301 -> 7094;
7302 -> 7094;
7303 -> 7301;
7303 -> 7302;
7304 -> 7098;
7304 -> 7302;
7305 -> 7302;
7306 -> 7304;
7306 -> 7305;
7307 -> 7306;
7307 -> 7289;
7307 -> 7305;
7308 -> 7305;
7309 -> 7306;
7309 -> 7289;
7309 -> 7308;
7309 -> 7305;
7310 -> 7309;
7311 -> 7307;
7311 -> 7310;
7311 -> 7309;
7312 -> 7307;
7312 -> 7309;
7313 -> 7309;
7314 -> 7312;
7314 -> 7313;
7315 -> 7313;
7316 -> 7314;
7316 -> 7315;
7316 -> 7313;
7317 -> 7313;
7318 -> 7313;
7319 -> 7313;
7319 -> 7318;
7320 -> 7318;
7321 -> 7319;
7321 -> 7320;
7322 -> 7321;
7322 -> 7318;
7323 -> 7318;
7324 -> 7319;
7324 -> 7323;
7325 -> 7324;
7325 -> 7318;
7326 -> 7318;
7327 -> 7325;
7327 -> 7326;
7328 -> 7326;
7328 -> 7318;
7329 -> 7318;
7330 -> 7322;
7330 -> 7318;
7331 -> 7313;
7331 -> 7330;
7331 -> 7314;
7331 -> 7289;
7332 -> 7331;
7333 -> 7331;
7334 -> 7331;
7335 -> 7331;
7336 -> 7331;
7337 -> 7331;
7338 -> 7313;
7338 -> 7331;
7339 -> 7331;
7340 -> 7338;
7340 -> 7331;
7340 -> 7339;
7341 -> 7340;
7341 -> 7331;
7342 -> 7331;
7343 -> 7341;
7344 -> 7341;
7345 -> 7341;
7346 -> 7341;
7347 -> 7344;
7347 -> 7341;
7348 -> 7341;
7349 -> 7341;
7350 -> 7341;
7351 -> 7350;
7351 -> 7341;
7352 -> 7351;
7352 -> 7341;
7353 -> 7341;
7354 -> 7341;
7355 -> 7341;
7356 -> 7341;
7357 -> 7341;
7358 -> 7341;
7359 -> 7341;
7360 -> 7341;
7361 -> 7341;
7362 -> 7341;
7363 -> 7341;
7364 -> 0;
7364 -> 7341;
7365 -> 0;
7365 -> 7341;
7366 -> 7341;
7366 -> 7365;
7367 -> 7366;
7367 -> 7341;
7367 -> 7365;
7368 -> 7362;
7368 -> 7341;
7369 -> 7341;
7370 -> 7348;
7370 -> 7369;
7370 -> 7341;
7371 -> 7367;
7372 -> 7367;
7373 -> 7367;
7374 -> 7367;
7375 -> 7372;
7375 -> 7367;
7376 -> 7367;
7377 -> 7367;
7378 -> 7367;
7379 -> 7378;
7379 -> 7367;
7380 -> 7379;
7380 -> 7367;
7381 -> 7367;
7382 -> 7367;
7383 -> 7367;
7384 -> 7367;
7385 -> 7367;
7386 -> 7367;
7387 -> 7367;
7388 -> 7367;
7389 -> 7367;
7390 -> 7367;
7391 -> 7367;
7392 -> 0;
7392 -> 7367;
7393 -> 7390;
7393 -> 7367;
7394 -> 7367;
7395 -> 7376;
7395 -> 7394;
7395 -> 7367;
7396 -> 7372;
7396 -> 7367;
7397 -> 7372;
7397 -> 7367;
7398 -> 7372;
7399 -> 7398;
7399 -> 7372;
7400 -> 7399;
7400 -> 7372;
7401 -> 7372;
7402 -> 7372;
7403 -> 7372;
7404 -> 7372;
7405 -> 7372;
7406 -> 7372;
7406 -> 7367;
7407 -> 7372;
7408 -> 7372;
7409 -> 7372;
7410 -> 7372;
7411 -> 7372;
7412 -> 0;
7412 -> 7372;
7413 -> 7410;
7413 -> 7372;
7414 -> 7372;
7415 -> 7372;
7416 -> 7372;
7417 -> 7372;
7418 -> 7372;
7419 -> 7372;
7420 -> 7372;
7421 -> 7372;
7422 -> 7418;
7422 -> 7421;
7422 -> 7372;
7423 -> 7372;
7424 -> 7423;
7424 -> 7372;
7425 -> 7424;
7425 -> 7372;
7426 -> 7372;
7427 -> 7372;
7428 -> 7372;
7429 -> 7372;
7430 -> 7331;
7431 -> 7342;
7431 -> 7430;
7431 -> 7331;
7432 -> 7372;
7433 -> 7372;
7434 -> 7433;
7434 -> 7372;
7435 -> 7372;
7436 -> 7372;
7437 -> 7372;
7438 -> 7372;
7438 -> 7437;
7439 -> 7438;
7439 -> 7372;
7439 -> 7437;
7440 -> 7439;
7440 -> 7372;
7441 -> 7434;
7441 -> 7440;
7441 -> 7372;
7442 -> 7372;
7442 -> 7441;
7443 -> 7441;
7444 -> 7442;
7444 -> 7443;
7445 -> 7372;
7445 -> 7443;
7446 -> 7443;
7447 -> 7444;
7447 -> 7446;
7448 -> 7447;
7448 -> 7443;
7449 -> 7448;
7449 -> 0;
7449 -> 7443;
7450 -> 7443;
7451 -> 7444;
7451 -> 7450;
7452 -> 7450;
7453 -> 7451;
7453 -> 7452;
7454 -> 7453;
7454 -> 7372;
7454 -> 7452;
7455 -> 7454;
7455 -> 7450;
7456 -> 7450;
7457 -> 7455;
7457 -> 7456;
7457 -> 7450;
7458 -> 7457;
7458 -> 7450;
7459 -> 7458;
7460 -> 7455;
7460 -> 7459;
7461 -> 7459;
7462 -> 7460;
7462 -> 7461;
7463 -> 7462;
7463 -> 7459;
7464 -> 7459;
7465 -> 7463;
7465 -> 7464;
7466 -> 7465;
7466 -> 7443;
7467 -> 7445;
7467 -> 7443;
7468 -> 7466;
7468 -> 7467;
7468 -> 7443;
7469 -> 7443;
7470 -> 7444;
7470 -> 7469;
7471 -> 7469;
7472 -> 7470;
7472 -> 7471;
7473 -> 7472;
7473 -> 7372;
7473 -> 7471;
7474 -> 7471;
7475 -> 7473;
7475 -> 7474;
7476 -> 0;
7476 -> 7474;
7477 -> 7476;
7477 -> 7471;
7478 -> 7471;
7479 -> 7473;
7479 -> 7478;
7480 -> 7479;
7480 -> 7471;
7481 -> 7480;
7481 -> 7469;
7482 -> 7481;
7482 -> 7443;
7483 -> 7443;
7484 -> 7482;
7484 -> 7483;
7485 -> 7484;
7485 -> 7372;
7485 -> 7483;
7486 -> 7443;
7487 -> 7443;
7488 -> 7445;
7488 -> 7487;
7489 -> 7488;
7489 -> 7443;
7490 -> 7445;
7490 -> 7443;
7491 -> 7443;
7492 -> 7445;
7492 -> 7372;
7492 -> 7491;
7492 -> 7443;
7493 -> 7445;
7493 -> 7372;
7493 -> 7492;
7494 -> 7492;
7495 -> 7445;
7495 -> 7493;
7495 -> 7448;
7495 -> 7443;
7496 -> 7444;
7496 -> 7443;
7497 -> 7443;
7498 -> 7445;
7498 -> 7495;
7499 -> 7495;
7500 -> 7445;
7500 -> 7495;
7500 -> 7498;
7500 -> 7499;
7501 -> 7445;
7501 -> 7495;
7501 -> 7498;
7501 -> 0;
7502 -> 7441;
7503 -> 7441;
7504 -> 7372;
7504 -> 7495;
7504 -> 7503;
7505 -> 7504;
7505 -> 7495;
7505 -> 7498;
7505 -> 0;
7505 -> 7503;
7506 -> 7505;
7506 -> 7441;
7507 -> 7498;
7508 -> 7498;
7509 -> 7506;
7509 -> 0;
7510 -> 7506;
7511 -> 7506;
7511 -> 7510;
7512 -> 7510;
7513 -> 7511;
7513 -> 7512;
7514 -> 7513;
7514 -> 7498;
7514 -> 7512;
7515 -> 7514;
7515 -> 7510;
7516 -> 7510;
7517 -> 7515;
7517 -> 7516;
7517 -> 7510;
7518 -> 7517;
7518 -> 7510;
7519 -> 7518;
7520 -> 7515;
7520 -> 7519;
7521 -> 7519;
7522 -> 7520;
7522 -> 7521;
7523 -> 7522;
7523 -> 7519;
7524 -> 7519;
7525 -> 7523;
7525 -> 7524;
7526 -> 7525;
7526 -> 7506;
7527 -> 7506;
7528 -> 7506;
7529 -> 7506;
7529 -> 7528;
7530 -> 7528;
7531 -> 7529;
7531 -> 7530;
7532 -> 7531;
7532 -> 7498;
7532 -> 7530;
7533 -> 7530;
7534 -> 7532;
7534 -> 7533;
7535 -> 0;
7535 -> 7533;
7536 -> 7535;
7536 -> 7530;
7537 -> 7530;
7538 -> 7532;
7538 -> 7537;
7539 -> 7538;
7539 -> 7530;
7540 -> 7539;
7540 -> 7528;
7541 -> 7540;
7541 -> 7506;
7542 -> 7506;
7543 -> 7541;
7543 -> 7542;
7544 -> 7543;
7544 -> 7498;
7544 -> 7542;
7545 -> 7506;
7546 -> 7506;
7547 -> 7546;
7547 -> 7506;
7548 -> 7506;
7549 -> 7506;
7550 -> 7506;
7550 -> 0;
7551 -> 7506;
7552 -> 7506;
7553 -> 7546;
7553 -> 0;
7554 -> 7546;
7555 -> 7546;
7555 -> 7554;
7556 -> 7554;
7557 -> 7555;
7557 -> 7556;
7558 -> 7557;
7558 -> 7506;
7558 -> 7556;
7559 -> 7558;
7559 -> 7554;
7560 -> 7554;
7561 -> 7559;
7561 -> 7560;
7561 -> 7554;
7562 -> 7561;
7562 -> 7554;
7563 -> 7562;
7564 -> 7559;
7564 -> 7563;
7565 -> 7563;
7566 -> 7564;
7566 -> 7565;
7567 -> 7566;
7567 -> 7563;
7568 -> 7563;
7569 -> 7567;
7569 -> 7568;
7570 -> 7569;
7570 -> 7546;
7571 -> 7546;
7572 -> 7546;
7573 -> 7546;
7573 -> 7572;
7574 -> 7572;
7575 -> 7573;
7575 -> 7574;
7576 -> 7575;
7576 -> 7506;
7576 -> 7574;
7577 -> 7574;
7578 -> 7576;
7578 -> 7577;
7579 -> 0;
7579 -> 7577;
7580 -> 7579;
7580 -> 7574;
7581 -> 7574;
7582 -> 7576;
7582 -> 7581;
7583 -> 7582;
7583 -> 7574;
7584 -> 7583;
7584 -> 7572;
7585 -> 7584;
7585 -> 7546;
7586 -> 7546;
7587 -> 7585;
7587 -> 7586;
7588 -> 7587;
7588 -> 7506;
7588 -> 7586;
7589 -> 7546;
7590 -> 7546;
7591 -> 7546;
7592 -> 7546;
7592 -> 0;
7593 -> 7546;
7594 -> 7546;
7595 -> 7557;
7595 -> 7546;
7595 -> 7556;
7596 -> 7595;
7596 -> 7554;
7597 -> 7596;
7597 -> 7560;
7597 -> 7554;
7598 -> 7597;
7598 -> 7554;
7599 -> 7598;
7600 -> 7596;
7600 -> 7599;
7601 -> 7599;
7602 -> 7600;
7602 -> 7601;
7603 -> 7602;
7603 -> 7599;
7604 -> 7599;
7605 -> 7603;
7605 -> 7604;
7606 -> 7605;
7606 -> 7546;
7607 -> 7575;
7607 -> 7546;
7607 -> 7574;
7608 -> 7607;
7608 -> 7577;
7609 -> 7607;
7609 -> 7581;
7610 -> 7609;
7610 -> 7574;
7611 -> 7610;
7611 -> 7572;
7612 -> 7611;
7612 -> 7546;
7613 -> 7612;
7613 -> 7586;
7614 -> 7613;
7614 -> 7546;
7614 -> 7586;
7615 -> 7309;
7616 -> 7306;
7616 -> 7546;
7616 -> 7309;
7617 -> 7309;
7618 -> 7302;
7619 -> 7302;
7620 -> 7619;
7620 -> 7302;
7621 -> 7303;
7621 -> 7302;
7622 -> 7619;
7622 -> 7302;
7623 -> 7304;
7623 -> 7616;
7623 -> 7621;
7623 -> 7622;
7623 -> 7620;
7623 -> 7302;
7624 -> 7623;
7624 -> 7302;
7625 -> 7624;
7625 -> 7094;
7626 -> 7625;
7627 -> 7625;
7627 -> 7626;
7628 -> 7626;
7629 -> 7628;
7629 -> 7625;
7630 -> 7625;
7631 -> 7300;
7631 -> 7630;
7631 -> 7625;
7632 -> 7625;
7633 -> 7625;
7633 -> 7632;
7634 -> 7632;
7635 -> 7634;
7635 -> 7625;
7636 -> 7300;
7636 -> 7635;
7636 -> 7625;
7637 -> 7629;
7637 -> 7636;
7637 -> 7625;
7638 -> 7637;
7639 -> 7103;
7639 -> 7638;
7639 -> 7637;
7640 -> 7625;
7640 -> 7637;
7641 -> 7094;
7642 -> 7640;
7642 -> 7641;
7642 -> 7094;
7643 -> 7640;
7643 -> 7094;
7644 -> 6596;
7645 -> 7643;
7645 -> 7644;
7645 -> 6596;
7646 -> 7643;
7646 -> 6596;
7647 -> 6589;
7648 -> 7646;
7648 -> 7647;
7649 -> 7647;
7649 -> 6589;
7650 -> 6589;
7651 -> 7646;
7651 -> 7650;
7652 -> 0;
7652 -> 7650;
7653 -> 7651;
7653 -> 6589;
7654 -> 7649;
7654 -> 7653;
7654 -> 6589;
7655 -> 7646;
7655 -> 6589;
7656 -> 6589;
7657 -> 7655;
7657 -> 7656;
7658 -> 6574;
7658 -> 7656;
7659 -> 7656;
7660 -> 7657;
7660 -> 0;
7660 -> 7656;
7661 -> 7656;
7662 -> 7657;
7662 -> 7661;
7663 -> 7661;
7664 -> 7662;
7664 -> 7663;
7665 -> 7664;
7665 -> 7624;
7665 -> 7663;
7666 -> 7665;
7666 -> 7661;
7667 -> 7661;
7668 -> 7666;
7668 -> 7667;
7668 -> 7661;
7669 -> 7668;
7669 -> 7661;
7670 -> 7669;
7671 -> 7666;
7671 -> 7670;
7672 -> 7670;
7673 -> 7671;
7673 -> 7672;
7674 -> 7673;
7674 -> 7670;
7675 -> 7670;
7676 -> 7674;
7676 -> 7675;
7677 -> 7676;
7677 -> 7656;
7678 -> 7658;
7678 -> 7656;
7679 -> 7656;
7680 -> 7657;
7680 -> 7679;
7681 -> 7679;
7682 -> 7680;
7682 -> 7681;
7683 -> 7682;
7683 -> 7624;
7683 -> 7681;
7684 -> 7681;
7685 -> 7683;
7685 -> 7684;
7686 -> 0;
7686 -> 7684;
7687 -> 7686;
7687 -> 7681;
7688 -> 7681;
7689 -> 7683;
7689 -> 7688;
7690 -> 7688;
7691 -> 7689;
7691 -> 7681;
7692 -> 7691;
7692 -> 7679;
7693 -> 7692;
7693 -> 7656;
7694 -> 7656;
7695 -> 7693;
7695 -> 7694;
7696 -> 7695;
7696 -> 7624;
7696 -> 7694;
7697 -> 7656;
7698 -> 7656;
7699 -> 7658;
7699 -> 7698;
7700 -> 7699;
7700 -> 7624;
7700 -> 7698;
7701 -> 7700;
7701 -> 7656;
7702 -> 7658;
7702 -> 7656;
7703 -> 7656;
7704 -> 7658;
7704 -> 7624;
7704 -> 7703;
7704 -> 7656;
7705 -> 7656;
7706 -> 7657;
7707 -> 7658;
7707 -> 7657;
7708 -> 6589;
7709 -> 6574;
7709 -> 7657;
7709 -> 6573;
7709 -> 6572;
7710 -> 6554;
7711 -> 7709;
7711 -> 7710;
7712 -> 7711;
7712 -> 6554;
7713 -> 7709;
7713 -> 6554;
7714 -> 6548;
7715 -> 7713;
7715 -> 7714;
7715 -> 6548;
7716 -> 7713;
7716 -> 6548;
7717 -> 6552;
7717 -> 6548;
7718 -> 6551;
7718 -> 6548;
7719 -> 6548;
7720 -> 7716;
7720 -> 7719;
7721 -> 7717;
7721 -> 7719;
7722 -> 7718;
7722 -> 7719;
7723 -> 7719;
7724 -> 7720;
7724 -> 7723;
7725 -> 7724;
7725 -> 7657;
7725 -> 7723;
7726 -> 0;
7726 -> 7723;
7727 -> 7725;
7728 -> 7724;
7728 -> 7727;
7729 -> 7727;
7730 -> 7729;
7730 -> 7727;
7731 -> 7727;
7732 -> 7728;
7732 -> 7731;
7733 -> 7731;
7734 -> 7733;
7734 -> 7731;
7735 -> 7731;
7736 -> 7732;
7736 -> 7735;
7737 -> 7735;
7738 -> 7736;
7738 -> 7737;
7739 -> 7738;
7739 -> 7657;
7739 -> 7737;
7740 -> 3417;
7740 -> 7737;
7741 -> 7738;
7741 -> 7657;
7741 -> 7739;
7742 -> 7739;
7743 -> 7738;
7743 -> 7742;
7744 -> 7742;
7745 -> 7742;
7746 -> 7744;
7746 -> 7745;
7747 -> 7743;
7747 -> 7745;
7748 -> 7745;
7749 -> 7745;
7750 -> 7748;
7750 -> 7749;
7751 -> 7747;
7751 -> 7749;
7752 -> 7751;
7752 -> 7657;
7752 -> 7749;
7753 -> 3417;
7753 -> 7749;
7754 -> 7752;
7755 -> 7751;
7755 -> 7754;
7756 -> 7755;
7756 -> 7657;
7756 -> 7754;
7757 -> 7756;
7758 -> 7755;
7758 -> 7757;
7759 -> 7758;
7759 -> 7657;
7759 -> 7757;
7760 -> 7757;
7761 -> 7759;
7761 -> 7760;
7762 -> 0;
7762 -> 7760;
7763 -> 7762;
7763 -> 7757;
7764 -> 7757;
7765 -> 7759;
7765 -> 7764;
7766 -> 7765;
7766 -> 7757;
7767 -> 7766;
7767 -> 7756;
7768 -> 7756;
7769 -> 7767;
7769 -> 7768;
7770 -> 7769;
7770 -> 7756;
7771 -> 7755;
7771 -> 7657;
7771 -> 7756;
7772 -> 7770;
7772 -> 7756;
7773 -> 7767;
7773 -> 7772;
7774 -> 7755;
7774 -> 7772;
7775 -> 7772;
7776 -> 7772;
7777 -> 7773;
7777 -> 7776;
7778 -> 7774;
7778 -> 7776;
7779 -> 7775;
7779 -> 7776;
7780 -> 7777;
7780 -> 7776;
7781 -> 7778;
7781 -> 7776;
7782 -> 7776;
7783 -> 7776;
7784 -> 7780;
7784 -> 7783;
7785 -> 7781;
7785 -> 7783;
7786 -> 7782;
7786 -> 7783;
7787 -> 7779;
7787 -> 7783;
7788 -> 7783;
7789 -> 7784;
7789 -> 7788;
7790 -> 7783;
7791 -> 7784;
7791 -> 7790;
7792 -> 7791;
7792 -> 7783;
7793 -> 7792;
7794 -> 7792;
7795 -> 7793;
7795 -> 7794;
7796 -> 7795;
7796 -> 7770;
7796 -> 7794;
7798 -> 7797;
7799 -> 7797;
7800 -> 7799;
7800 -> 7783;
7801 -> 7784;
7801 -> 7783;
7802 -> 7783;
7803 -> 7802;
7803 -> 7789;
7803 -> 7796;
7803 -> 7800;
7803 -> 7801;
7803 -> 7770;
7803 -> 7798;
7803 -> 7783;
7804 -> 7802;
7804 -> 7783;
7805 -> 7802;
7805 -> 7783;
7806 -> 7783;
7807 -> 7784;
7807 -> 7806;
7807 -> 7783;
7808 -> 7785;
7808 -> 7802;
7808 -> 7783;
7809 -> 7786;
7809 -> 7802;
7809 -> 7783;
7810 -> 7770;
7810 -> 7772;
7811 -> 7810;
7811 -> 7775;
7811 -> 7770;
7811 -> 7803;
7811 -> 7804;
7811 -> 7808;
7811 -> 7805;
7811 -> 7809;
7811 -> 7772;
7812 -> 7811;
7812 -> 7775;
7813 -> 7812;
7813 -> 7811;
7813 -> 7775;
7814 -> 7813;
7814 -> 7752;
7815 -> 7814;
7815 -> 7752;
7816 -> 7750;
7816 -> 7815;
7817 -> 7815;
7818 -> 7817;
7819 -> 7817;
7819 -> 7818;
7820 -> 0;
7820 -> 7818;
7821 -> 7820;
7821 -> 7817;
7822 -> 7817;
7822 -> 7815;
7823 -> 7814;
7823 -> 7815;
7824 -> 7815;
7825 -> 7751;
7825 -> 7813;
7825 -> 7815;
7826 -> 7822;
7826 -> 7815;
7827 -> 7815;
7828 -> 7823;
7828 -> 7827;
7829 -> 7824;
7829 -> 7827;
7830 -> 7825;
7830 -> 7827;
7831 -> 7826;
7831 -> 7827;
7832 -> 7824;
7832 -> 7827;
7833 -> 7827;
7834 -> 7828;
7834 -> 7833;
7834 -> 7827;
7835 -> 7827;
7836 -> 7835;
7836 -> 7827;
7837 -> 7827;
7838 -> 7831;
7838 -> 7837;
7839 -> 7838;
7839 -> 7827;
7840 -> 7830;
7840 -> 7827;
7841 -> 7835;
7841 -> 7827;
7842 -> 7839;
7842 -> 7840;
7842 -> 7841;
7842 -> 7813;
7842 -> 7836;
7842 -> 7827;
7843 -> 7828;
7843 -> 7827;
7844 -> 7843;
7844 -> 7815;
7845 -> 7751;
7845 -> 7842;
7845 -> 7815;
7846 -> 7822;
7846 -> 7815;
7847 -> 7815;
7848 -> 7844;
7848 -> 7847;
7849 -> 7845;
7849 -> 7847;
7850 -> 7846;
7850 -> 7847;
7851 -> 7847;
7852 -> 7850;
7852 -> 7851;
7853 -> 7852;
7853 -> 7842;
7853 -> 7851;
7854 -> 7853;
7854 -> 7847;
7855 -> 7849;
7855 -> 7847;
7856 -> 7847;
7857 -> 7854;
7857 -> 7855;
7857 -> 7856;
7857 -> 7842;
7857 -> 7847;
7858 -> 7857;
7858 -> 7847;
7859 -> 7848;
7859 -> 7858;
7860 -> 7859;
7860 -> 7815;
7861 -> 7751;
7861 -> 7857;
7861 -> 7815;
7862 -> 7822;
7862 -> 7815;
7863 -> 7815;
7864 -> 7860;
7864 -> 7863;
7865 -> 7861;
7865 -> 7863;
7866 -> 7862;
7866 -> 7863;
7867 -> 7863;
7868 -> 7867;
7868 -> 7863;
7869 -> 7863;
7870 -> 7866;
7870 -> 7869;
7871 -> 7870;
7871 -> 7857;
7871 -> 7869;
7872 -> 7871;
7872 -> 7863;
7873 -> 7865;
7873 -> 7863;
7874 -> 7867;
7874 -> 7863;
7875 -> 7872;
7875 -> 7873;
7875 -> 7874;
7875 -> 7857;
7875 -> 7868;
7875 -> 7863;
7876 -> 7875;
7876 -> 7863;
7877 -> 7864;
7877 -> 7863;
7878 -> 7875;
7878 -> 7863;
7879 -> 7863;
7880 -> 7877;
7880 -> 7879;
7881 -> 7878;
7881 -> 7879;
7882 -> 7878;
7882 -> 7879;
7883 -> 7880;
7883 -> 7879;
7884 -> 7883;
7884 -> 7875;
7884 -> 7879;
7885 -> 7881;
7885 -> 7879;
7886 -> 7879;
7887 -> 7879;
7888 -> 7885;
7888 -> 7887;
7889 -> 7886;
7889 -> 7887;
7890 -> 7888;
7890 -> 7889;
7890 -> 7887;
7891 -> 7888;
7891 -> 7875;
7891 -> 7887;
7892 -> 7891;
7893 -> 7892;
7893 -> 7889;
7893 -> 7887;
7894 -> 7887;
7895 -> 7894;
7895 -> 7889;
7895 -> 7887;
7896 -> 7887;
7897 -> 7896;
7897 -> 7889;
7897 -> 7887;
7898 -> 7880;
7898 -> 7879;
7899 -> 7879;
7900 -> 7898;
7900 -> 7899;
7901 -> 7886;
7901 -> 7899;
7902 -> 7899;
7903 -> 7900;
7903 -> 7902;
7904 -> 7902;
7904 -> 7899;
7905 -> 7900;
7905 -> 7904;
7906 -> 7904;
7907 -> 7905;
7907 -> 7906;
7908 -> 7901;
7908 -> 7906;
7909 -> 7906;
7910 -> 7907;
7910 -> 7909;
7911 -> 0;
7911 -> 7909;
7912 -> 7911;
7912 -> 7906;
7913 -> 7912;
7913 -> 7906;
7914 -> 7906;
7915 -> 7913;
7915 -> 7914;
7916 -> 7908;
7916 -> 7914;
7917 -> 7915;
7917 -> 0;
7917 -> 7914;
7918 -> 7915;
7918 -> 7917;
7919 -> 7907;
7919 -> 7906;
7920 -> 7906;
7921 -> 7907;
7921 -> 7920;
7922 -> 7921;
7922 -> 7884;
7922 -> 7920;
7923 -> 7922;
7923 -> 7906;
7924 -> 7906;
7925 -> 7923;
7925 -> 7906;
7926 -> 7923;
7926 -> 7925;
7927 -> 7926;
7927 -> 7906;
7928 -> 7923;
7928 -> 7906;
7929 -> 7912;
7929 -> 7918;
7929 -> 7906;
7930 -> 7929;
7930 -> 7927;
7930 -> 7906;
7931 -> 7906;
7932 -> 7919;
7932 -> 7931;
7933 -> 7931;
7934 -> 7933;
7934 -> 7931;
7935 -> 7934;
7935 -> 7931;
7936 -> 7932;
7936 -> 7931;
7937 -> 7931;
7938 -> 7936;
7938 -> 7937;
7939 -> 7937;
7940 -> 7939;
7940 -> 7931;
7941 -> 7931;
7942 -> 7936;
7942 -> 7941;
7943 -> 7942;
7943 -> 7884;
7943 -> 7941;
7944 -> 7943;
7944 -> 7931;
7945 -> 7931;
7946 -> 7944;
7946 -> 7945;
7947 -> 0;
7947 -> 7945;
7948 -> 7947;
7948 -> 7931;
7949 -> 7940;
7949 -> 7948;
7949 -> 7931;
7950 -> 7931;
7951 -> 7936;
7951 -> 7950;
7952 -> 7951;
7952 -> 7950;
7953 -> 7952;
7953 -> 7884;
7953 -> 7950;
7954 -> 7953;
7954 -> 7931;
7955 -> 7931;
7956 -> 7954;
7956 -> 7955;
7957 -> 7931;
7958 -> 7956;
7958 -> 7957;
7959 -> 7957;
7959 -> 7931;
7960 -> 7931;
7961 -> 7949;
7961 -> 7959;
7961 -> 7931;
7962 -> 7931;
7963 -> 7936;
7963 -> 7962;
7964 -> 7963;
7964 -> 7884;
7964 -> 7962;
7965 -> 7964;
7965 -> 7931;
7966 -> 7965;
7966 -> 3004;
7966 -> 7931;
7967 -> 7961;
7967 -> 7966;
7967 -> 7931;
7968 -> 7931;
7969 -> 7931;
7969 -> 7906;
7970 -> 7919;
7970 -> 7906;
7971 -> 7886;
7971 -> 7895;
7971 -> 7879;
7972 -> 7882;
7972 -> 7971;
7973 -> 7970;
7973 -> 7972;
7974 -> 0;
7975 -> 0;
7976 -> 0;
7977 -> 7976;
7979 -> 7974;
7979 -> 7975;
7979 -> 7977;
7979 -> 7978;
7980 -> 7979;
7981 -> 0;
7982 -> 0;
7983 -> 0;
7984 -> 7983;
7984 -> 0;
7985 -> 7984;
7987 -> 7981;
7987 -> 7982;
7987 -> 7985;
7987 -> 7986;
7988 -> 7987;
7989 -> 7973;
7989 -> 7815;
7990 -> 7815;
7991 -> 7815;
7992 -> 7989;
7992 -> 7991;
7993 -> 7990;
7993 -> 7991;
7994 -> 7990;
7994 -> 7991;
7995 -> 7992;
7995 -> 7991;
7996 -> 7993;
7996 -> 0;
7996 -> 7991;
7997 -> 7993;
7997 -> 7991;
7998 -> 7992;
7998 -> 7997;
8003 -> 7999;
8003 -> 8002;
8004 -> 8000;
8004 -> 8002;
8005 -> 8001;
8005 -> 8002;
8006 -> 8002;
8007 -> 0;
8008 -> 8007;
8009 -> 0;
8010 -> 8009;
8011 -> 0;
8012 -> 8011;
8013 -> 0;
8014 -> 8013;
8015 -> 7997;
8016 -> 7998;
8016 -> 8015;
8017 -> 8015;
8018 -> 8016;
8018 -> 8017;
8019 -> 8017;
8020 -> 8018;
8020 -> 8019;
8021 -> 8019;
8022 -> 8020;
8022 -> 8021;
8023 -> 8022;
8023 -> 8021;
8024 -> 8023;
8024 -> 8019;
8025 -> 8024;
8025 -> 8017;
8026 -> 8025;
8026 -> 8015;
8027 -> 8015;
8028 -> 8026;
8028 -> 8027;
8029 -> 8028;
8029 -> 7884;
8029 -> 8027;
8030 -> 7992;
8030 -> 7991;
8031 -> 7993;
8031 -> 7991;
8032 -> 7994;
8032 -> 7991;
8033 -> 7991;
8034 -> 8030;
8034 -> 8033;
8035 -> 8031;
8035 -> 8033;
8036 -> 8032;
8036 -> 8033;
8037 -> 0;
8039 -> 8037;
8039 -> 8038;
8040 -> 8038;
8041 -> 8040;
8042 -> 8039;
8042 -> 0;
8042 -> 8038;
8043 -> 8039;
8043 -> 8040;
8043 -> 8038;
8044 -> 8038;
8045 -> 8034;
8045 -> 8033;
8046 -> 8035;
8046 -> 8033;
8047 -> 8036;
8047 -> 8033;
8048 -> 8033;
8049 -> 8047;
8049 -> 8048;
8050 -> 8049;
8050 -> 8032;
8050 -> 8048;
8051 -> 8044;
8051 -> 8050;
8052 -> 8033;
8053 -> 8033;
8054 -> 8045;
8054 -> 8053;
8055 -> 8046;
8055 -> 8053;
8056 -> 8051;
8056 -> 8053;
8057 -> 8052;
8057 -> 8053;
8058 -> 8054;
8058 -> 8053;
8059 -> 8058;
8059 -> 8053;
8060 -> 8054;
8060 -> 8059;
8061 -> 8059;
8062 -> 8060;
8062 -> 8061;
8063 -> 8061;
8064 -> 8062;
8064 -> 8063;
8065 -> 8063;
8066 -> 8064;
8066 -> 8065;
8067 -> 8065;
8068 -> 8066;
8068 -> 8067;
8069 -> 8068;
8069 -> 8067;
8070 -> 8069;
8070 -> 8065;
8071 -> 8070;
8071 -> 8063;
8072 -> 8071;
8072 -> 8061;
8073 -> 8061;
8074 -> 8072;
8074 -> 8073;
8075 -> 8074;
8075 -> 7884;
8075 -> 8073;
8076 -> 8055;
8076 -> 0;
8076 -> 8053;
8077 -> 8053;
8078 -> 8075;
8078 -> 8077;
8078 -> 8053;
8079 -> 8053;
8080 -> 8056;
8080 -> 8079;
8080 -> 8053;
8081 -> 8054;
8081 -> 8057;
8081 -> 8053;
8082 -> 8055;
8082 -> 8057;
8082 -> 8053;
8083 -> 8056;
8083 -> 8057;
8083 -> 8053;
8084 -> 8052;
8084 -> 7991;
8085 -> 8084;
8085 -> 7815;
8086 -> 7751;
8086 -> 7884;
8086 -> 7815;
8087 -> 7822;
8087 -> 7815;
8088 -> 7751;
8088 -> 7815;
8089 -> 7815;
8090 -> 8085;
8090 -> 8089;
8091 -> 8086;
8091 -> 8089;
8092 -> 8087;
8092 -> 8089;
8093 -> 8088;
8093 -> 8089;
8094 -> 8088;
8094 -> 8089;
8095 -> 8089;
8096 -> 8090;
8096 -> 8095;
8097 -> 8096;
8097 -> 8081;
8097 -> 8095;
8098 -> 8097;
8098 -> 8095;
8099 -> 8098;
8099 -> 8089;
8100 -> 8089;
8101 -> 8093;
8101 -> 8100;
8102 -> 8100;
8103 -> 8101;
8103 -> 8102;
8104 -> 8102;
8105 -> 8103;
8105 -> 8104;
8106 -> 8104;
8107 -> 8105;
8107 -> 8106;
8108 -> 8106;
8109 -> 8107;
8109 -> 8108;
8110 -> 8109;
8110 -> 8108;
8111 -> 8110;
8111 -> 8106;
8112 -> 8111;
8112 -> 8104;
8113 -> 8112;
8113 -> 8102;
8114 -> 8113;
8114 -> 8100;
8115 -> 8114;
8115 -> 8089;
8116 -> 8089;
8117 -> 8093;
8117 -> 8116;
8118 -> 8116;
8119 -> 8117;
8119 -> 8118;
8120 -> 8119;
8120 -> 7884;
8120 -> 8118;
8121 -> 8118;
8122 -> 8120;
8122 -> 8121;
8123 -> 0;
8123 -> 8121;
8124 -> 8123;
8124 -> 8118;
8125 -> 8120;
8125 -> 8116;
8126 -> 8125;
8126 -> 8089;
8127 -> 8126;
8127 -> 8092;
8127 -> 8089;
8128 -> 8089;
8129 -> 8093;
8129 -> 8089;
8130 -> 8089;
8131 -> 8129;
8131 -> 8130;
8132 -> 8128;
8132 -> 8130;
8133 -> 8131;
8133 -> 8130;
8134 -> 8130;
8135 -> 8131;
8135 -> 8134;
8136 -> 8134;
8136 -> 8130;
8137 -> 8130;
8138 -> 8130;
8139 -> 8131;
8139 -> 8138;
8140 -> 0;
8140 -> 8138;
8141 -> 8139;
8141 -> 7884;
8141 -> 0;
8141 -> 8138;
8142 -> 8141;
8142 -> 8130;
8143 -> 8130;
8144 -> 8131;
8144 -> 8143;
8145 -> 8144;
8145 -> 7884;
8145 -> 8143;
8146 -> 8145;
8146 -> 8130;
8147 -> 8146;
8147 -> 8130;
8148 -> 8130;
8149 -> 8148;
8149 -> 8089;
8150 -> 8089;
8151 -> 8089;
8152 -> 8151;
8152 -> 8089;
8153 -> 8089;
8154 -> 8092;
8154 -> 8153;
8155 -> 8154;
8155 -> 7884;
8155 -> 8153;
8156 -> 8155;
8156 -> 8089;
8157 -> 8091;
8157 -> 8089;
8158 -> 8150;
8158 -> 8089;
8159 -> 8151;
8159 -> 8089;
8160 -> 8156;
8160 -> 8157;
8160 -> 8158;
8160 -> 8159;
8160 -> 7884;
8160 -> 8152;
8160 -> 8089;
8161 -> 8160;
8162 -> 8094;
8162 -> 8161;
8163 -> 8161;
8164 -> 8162;
8164 -> 8160;
8164 -> 8161;
8165 -> 8163;
8165 -> 8161;
8166 -> 8161;
8167 -> 8164;
8167 -> 8166;
8168 -> 8165;
8168 -> 8166;
8169 -> 8167;
8169 -> 8166;
8170 -> 8169;
8171 -> 8169;
8172 -> 8171;
8173 -> 8172;
8174 -> 8172;
8174 -> 8173;
8175 -> 0;
8175 -> 8173;
8176 -> 8175;
8176 -> 8172;
8177 -> 8172;
8177 -> 8171;
8178 -> 8171;
8179 -> 8177;
8179 -> 8178;
8180 -> 8162;
8180 -> 8160;
8180 -> 8171;
8181 -> 8171;
8182 -> 8179;
8182 -> 8171;
8183 -> 8182;
8184 -> 8162;
8184 -> 8179;
8184 -> 8183;
8185 -> 8183;
8186 -> 8184;
8186 -> 8185;
8187 -> 8185;
8188 -> 8187;
8188 -> 8183;
8189 -> 8183;
8190 -> 8184;
8190 -> 8189;
8191 -> 8190;
8191 -> 8183;
8192 -> 8183;
8193 -> 8191;
8193 -> 8192;
8194 -> 8192;
8195 -> 8193;
8195 -> 8194;
8196 -> 8194;
8197 -> 8196;
8197 -> 8192;
8198 -> 8192;
8199 -> 8193;
8199 -> 8198;
8200 -> 8199;
8200 -> 8179;
8200 -> 8198;
8201 -> 8200;
8201 -> 8194;
8202 -> 8200;
8202 -> 8198;
8203 -> 8202;
8203 -> 8179;
8203 -> 8198;
8204 -> 8203;
8204 -> 8194;
8205 -> 8203;
8205 -> 8198;
8206 -> 8198;
8207 -> 8206;
8207 -> 8192;
8208 -> 8207;
8208 -> 8197;
8208 -> 8192;
8209 -> 8208;
8209 -> 8171;
8210 -> 8171;
8211 -> 8209;
8211 -> 8210;
8212 -> 8211;
8212 -> 8210;
8213 -> 0;
8213 -> 8212;
8214 -> 8213;
8214 -> 8162;
8214 -> 8171;
8215 -> 8208;
8215 -> 8161;
8216 -> 8215;
8216 -> 8160;
8217 -> 8160;
8218 -> 8216;
8218 -> 8217;
8218 -> 8160;
8219 -> 8090;
8219 -> 8218;
8220 -> 7815;
8221 -> 8219;
8221 -> 8220;
8222 -> 8221;
8222 -> 8081;
8222 -> 8220;
8223 -> 8220;
8224 -> 8222;
8224 -> 8223;
8225 -> 8221;
8225 -> 8083;
8225 -> 8223;
8226 -> 8224;
8226 -> 8223;
8227 -> 8226;
8227 -> 8220;
8228 -> 7751;
8228 -> 8179;
8228 -> 7752;
8229 -> 8227;
8229 -> 7752;
8230 -> 3417;
8230 -> 7752;
8231 -> 8228;
8231 -> 8229;
8231 -> 8230;
8231 -> 8179;
8231 -> 8214;
8231 -> 7752;
8232 -> 7751;
8232 -> 8231;
8232 -> 7749;
8233 -> 8232;
8233 -> 7745;
8234 -> 8233;
8234 -> 7742;
8235 -> 7742;
8236 -> 8234;
8236 -> 8235;
8236 -> 7742;
8237 -> 8234;
8237 -> 7742;
8238 -> 7743;
8238 -> 7742;
8239 -> 7742;
8240 -> 8237;
8240 -> 8239;
8241 -> 8238;
8241 -> 8239;
8242 -> 8239;
8243 -> 8240;
8243 -> 8242;
8243 -> 8239;
8244 -> 8239;
8245 -> 8241;
8245 -> 8244;
8245 -> 8239;
8246 -> 8239;
8247 -> 8241;
8247 -> 8246;
8248 -> 8246;
8249 -> 8247;
8249 -> 8248;
8250 -> 8248;
8251 -> 8249;
8251 -> 8250;
8252 -> 8250;
8253 -> 8251;
8253 -> 8252;
8254 -> 8252;
8255 -> 8253;
8255 -> 8254;
8256 -> 8255;
8256 -> 8254;
8257 -> 8256;
8257 -> 8252;
8258 -> 8257;
8258 -> 8250;
8259 -> 8258;
8259 -> 8248;
8260 -> 8259;
8260 -> 8246;
8261 -> 8260;
8261 -> 8239;
8262 -> 8239;
8263 -> 8240;
8263 -> 8239;
8264 -> 8239;
8265 -> 8240;
8265 -> 8264;
8266 -> 8264;
8267 -> 8266;
8267 -> 8239;
8268 -> 8262;
8268 -> 8239;
8269 -> 8239;
8270 -> 8263;
8270 -> 8269;
8271 -> 8267;
8271 -> 8269;
8272 -> 8268;
8272 -> 8269;
8273 -> 8269;
8274 -> 8270;
8274 -> 8273;
8274 -> 8269;
8275 -> 8269;
8276 -> 8270;
8276 -> 8275;
8277 -> 8276;
8277 -> 8275;
8278 -> 8277;
8278 -> 8269;
8279 -> 8278;
8279 -> 8269;
8280 -> 8279;
8280 -> 8272;
8280 -> 8231;
8280 -> 8262;
8280 -> 8269;
8281 -> 8269;
8282 -> 8280;
8282 -> 8281;
8283 -> 8281;
8284 -> 8282;
8284 -> 8283;
8285 -> 8284;
8285 -> 8281;
8286 -> 8281;
8287 -> 8282;
8287 -> 8286;
8288 -> 8287;
8288 -> 8281;
8289 -> 8288;
8290 -> 8278;
8290 -> 8289;
8291 -> 8290;
8291 -> 8288;
8291 -> 8289;
8292 -> 8291;
8292 -> 8288;
8293 -> 8292;
8294 -> 8292;
8295 -> 8293;
8295 -> 8294;
8296 -> 8294;
8297 -> 8294;
8298 -> 8294;
8298 -> 8297;
8299 -> 0;
8299 -> 8297;
8300 -> 8299;
8300 -> 8294;
8301 -> 8294;
8302 -> 8296;
8302 -> 8294;
8303 -> 8294;
8304 -> 8294;
8305 -> 8294;
8306 -> 8294;
8307 -> 8294;
8308 -> 8307;
8308 -> 8294;
8309 -> 8308;
8309 -> 8307;
8309 -> 8294;
8310 -> 8308;
8310 -> 8294;
8311 -> 8310;
8312 -> 8311;
8312 -> 8307;
8312 -> 8294;
8313 -> 8294;
8314 -> 8313;
8314 -> 8307;
8314 -> 8294;
8315 -> 8307;
8315 -> 8294;
8316 -> 8294;
8317 -> 8315;
8317 -> 8294;
8318 -> 8294;
8319 -> 8294;
8319 -> 8318;
8320 -> 0;
8320 -> 8318;
8321 -> 8320;
8321 -> 8294;
8322 -> 8321;
8322 -> 8294;
8323 -> 8294;
8324 -> 8322;
8324 -> 8323;
8325 -> 8317;
8325 -> 8323;
8326 -> 8324;
8326 -> 0;
8326 -> 8323;
8327 -> 8324;
8327 -> 8326;
8328 -> 8294;
8329 -> 8294;
8329 -> 8328;
8330 -> 8329;
8330 -> 8294;
8330 -> 8328;
8331 -> 8330;
8331 -> 8294;
8332 -> 8294;
8333 -> 8331;
8333 -> 8294;
8334 -> 8331;
8334 -> 8333;
8335 -> 8334;
8335 -> 8294;
8336 -> 8331;
8336 -> 8294;
8337 -> 8321;
8337 -> 8327;
8337 -> 8294;
8338 -> 8337;
8338 -> 8335;
8338 -> 8294;
8339 -> 8294;
8340 -> 8294;
8340 -> 8339;
8341 -> 8339;
8342 -> 8341;
8342 -> 8339;
8343 -> 8342;
8343 -> 8339;
8344 -> 8340;
8344 -> 8339;
8345 -> 8339;
8346 -> 8344;
8346 -> 8345;
8347 -> 8345;
8348 -> 8347;
8348 -> 8339;
8349 -> 8339;
8350 -> 8344;
8350 -> 8349;
8351 -> 8350;
8351 -> 8294;
8351 -> 8349;
8352 -> 8351;
8352 -> 8339;
8353 -> 8339;
8354 -> 8352;
8354 -> 8353;
8355 -> 0;
8355 -> 8353;
8356 -> 8355;
8356 -> 8339;
8357 -> 8348;
8357 -> 8356;
8357 -> 8339;
8358 -> 8339;
8359 -> 8344;
8359 -> 8358;
8360 -> 8359;
8360 -> 8358;
8361 -> 8360;
8361 -> 8294;
8361 -> 8358;
8362 -> 8361;
8362 -> 8339;
8363 -> 8339;
8364 -> 8362;
8364 -> 8363;
8365 -> 8339;
8366 -> 8364;
8366 -> 8365;
8367 -> 8365;
8367 -> 8339;
8368 -> 8339;
8369 -> 8357;
8369 -> 8367;
8369 -> 8339;
8370 -> 8339;
8371 -> 8344;
8371 -> 8370;
8372 -> 8371;
8372 -> 8339;
8373 -> 8372;
8373 -> 3004;
8373 -> 8339;
8374 -> 8369;
8374 -> 8373;
8374 -> 8339;
8375 -> 8339;
8376 -> 8339;
8376 -> 8294;
8377 -> 8307;
8377 -> 8294;
8378 -> 8307;
8378 -> 8294;
8379 -> 8307;
8379 -> 8294;
8380 -> 8377;
8380 -> 0;
8380 -> 8294;
8381 -> 8377;
8381 -> 8294;
8382 -> 8307;
8382 -> 8381;
8383 -> 8381;
8384 -> 8382;
8384 -> 8383;
8385 -> 8383;
8386 -> 8384;
8386 -> 8385;
8387 -> 8385;
8388 -> 8386;
8388 -> 8387;
8389 -> 8387;
8390 -> 8388;
8390 -> 8389;
8391 -> 8390;
8391 -> 8387;
8392 -> 8391;
8392 -> 8385;
8393 -> 8392;
8393 -> 8383;
8394 -> 8383;
8395 -> 8393;
8395 -> 8394;
8396 -> 8377;
8396 -> 8294;
8397 -> 8378;
8397 -> 8294;
8398 -> 8294;
8399 -> 8397;
8399 -> 8398;
8400 -> 8399;
8400 -> 8378;
8400 -> 8398;
8401 -> 8044;
8401 -> 8400;
8402 -> 8396;
8402 -> 8294;
8403 -> 8401;
8403 -> 8294;
8404 -> 8307;
8404 -> 8294;
8405 -> 8404;
8405 -> 8294;
8406 -> 8307;
8406 -> 8405;
8407 -> 8405;
8408 -> 8406;
8408 -> 8407;
8409 -> 8407;
8410 -> 8408;
8410 -> 8409;
8411 -> 8409;
8412 -> 8410;
8412 -> 8411;
8413 -> 8411;
8414 -> 8412;
8414 -> 8413;
8415 -> 8414;
8415 -> 8411;
8416 -> 8415;
8416 -> 8409;
8417 -> 8416;
8417 -> 8407;
8418 -> 8407;
8419 -> 8417;
8419 -> 8418;
8420 -> 8402;
8420 -> 0;
8420 -> 8294;
8421 -> 8294;
8422 -> 8419;
8422 -> 8421;
8422 -> 8294;
8423 -> 8294;
8424 -> 8403;
8424 -> 8423;
8424 -> 8294;
8425 -> 8402;
8425 -> 8307;
8425 -> 8294;
8426 -> 8403;
8426 -> 8307;
8426 -> 8294;
8427 -> 8307;
8427 -> 8294;
8428 -> 8294;
8429 -> 8307;
8429 -> 8428;
8430 -> 8429;
8430 -> 8307;
8430 -> 8428;
8431 -> 8430;
8431 -> 8428;
8432 -> 8431;
8432 -> 8294;
8433 -> 8294;
8434 -> 8427;
8434 -> 8433;
8435 -> 8433;
8436 -> 8434;
8436 -> 8435;
8437 -> 8435;
8438 -> 8436;
8438 -> 8437;
8439 -> 8437;
8440 -> 8438;
8440 -> 8439;
8441 -> 8439;
8442 -> 8440;
8442 -> 8441;
8443 -> 8442;
8443 -> 8439;
8444 -> 8443;
8444 -> 8437;
8445 -> 8444;
8445 -> 8435;
8446 -> 8445;
8446 -> 8433;
8447 -> 8446;
8447 -> 8294;
8448 -> 8294;
8449 -> 8427;
8449 -> 8448;
8450 -> 8448;
8451 -> 8449;
8451 -> 8450;
8452 -> 8450;
8453 -> 8451;
8453 -> 8452;
8454 -> 0;
8454 -> 8452;
8455 -> 8454;
8455 -> 8450;
8456 -> 8451;
8456 -> 8448;
8457 -> 8456;
8457 -> 8294;
8458 -> 8294;
8459 -> 8427;
8459 -> 8294;
8460 -> 8294;
8461 -> 8459;
8461 -> 8460;
8462 -> 8458;
8462 -> 8460;
8463 -> 8461;
8463 -> 8460;
8464 -> 8460;
8465 -> 8461;
8465 -> 8464;
8466 -> 8464;
8466 -> 8460;
8467 -> 8460;
8468 -> 8460;
8469 -> 8461;
8469 -> 8468;
8470 -> 0;
8470 -> 8468;
8471 -> 8469;
8471 -> 8460;
8472 -> 8460;
8473 -> 8461;
8473 -> 8472;
8474 -> 8473;
8474 -> 8294;
8474 -> 8472;
8475 -> 8474;
8475 -> 8460;
8476 -> 8475;
8476 -> 8460;
8477 -> 8460;
8478 -> 8477;
8478 -> 8294;
8479 -> 8307;
8480 -> 8479;
8480 -> 8307;
8481 -> 8307;
8482 -> 8479;
8483 -> 8479;
8483 -> 8482;
8484 -> 0;
8484 -> 8482;
8485 -> 8484;
8485 -> 8479;
8486 -> 8307;
8486 -> 8479;
8487 -> 8486;
8487 -> 8479;
8488 -> 8486;
8488 -> 8479;
8489 -> 8488;
8489 -> 8479;
8490 -> 8489;
8490 -> 8479;
8491 -> 8489;
8491 -> 8479;
8492 -> 8491;
8492 -> 8479;
8493 -> 8492;
8493 -> 8479;
8494 -> 8492;
8494 -> 8479;
8495 -> 8479;
8495 -> 8426;
8495 -> 8294;
8496 -> 8479;
8496 -> 8292;
8497 -> 8271;
8497 -> 8292;
8498 -> 8272;
8498 -> 8292;
8499 -> 8292;
8500 -> 8496;
8500 -> 8499;
8501 -> 8497;
8501 -> 8499;
8502 -> 8498;
8502 -> 8499;
8503 -> 8499;
8504 -> 8500;
8504 -> 8503;
8504 -> 8499;
8505 -> 8499;
8506 -> 8500;
8506 -> 8505;
8507 -> 8506;
8507 -> 8499;
8508 -> 0;
8508 -> 8507;
8509 -> 8508;
8510 -> 8508;
8511 -> 8508;
8512 -> 8508;
8512 -> 8511;
8513 -> 0;
8513 -> 8511;
8514 -> 8513;
8514 -> 8508;
8515 -> 8508;
8516 -> 8501;
8516 -> 8508;
8517 -> 8508;
8518 -> 8515;
8518 -> 8517;
8518 -> 8508;
8519 -> 8518;
8520 -> 8508;
8521 -> 8501;
8521 -> 8520;
8521 -> 8508;
8522 -> 8288;
8523 -> 8271;
8523 -> 8522;
8523 -> 8288;
8524 -> 8239;
8525 -> 8241;
8525 -> 8239;
8526 -> 8525;
8526 -> 8262;
8526 -> 8515;
8526 -> 8239;
8527 -> 8239;
8528 -> 8527;
8529 -> 8527;
8530 -> 8262;
8530 -> 8526;
8530 -> 8239;
8531 -> 8526;
8531 -> 8239;
8532 -> 7742;
8533 -> 7743;
8533 -> 8532;
8534 -> 8532;
8535 -> 8534;
8535 -> 8533;
8535 -> 8532;
8536 -> 7742;
8537 -> 8234;
8537 -> 7742;
8538 -> 8537;
8538 -> 7739;
8539 -> 3417;
8539 -> 7739;
8540 -> 7741;
8540 -> 8538;
8540 -> 8539;
8540 -> 8530;
8540 -> 8535;
8540 -> 7739;
8541 -> 7738;
8541 -> 8540;
8541 -> 7737;
8542 -> 8541;
8542 -> 7735;
8543 -> 7735;
8544 -> 8542;
8544 -> 8543;
8544 -> 7735;
8545 -> 8542;
8545 -> 8544;
8546 -> 8544;
8547 -> 8545;
8547 -> 8546;
8548 -> 8546;
8549 -> 8547;
8549 -> 8548;
8549 -> 8546;
8550 -> 8546;
8551 -> 8547;
8551 -> 8550;
8552 -> 8550;
8552 -> 8546;
8553 -> 8552;
8553 -> 8544;
8554 -> 8544;
8555 -> 8554;
8556 -> 8554;
8557 -> 8554;
8558 -> 8554;
8559 -> 8554;
8560 -> 8554;
8561 -> 8554;
8561 -> 8560;
8562 -> 8560;
8563 -> 8561;
8563 -> 8562;
8564 -> 8562;
8565 -> 8563;
8565 -> 8564;
8566 -> 8564;
8567 -> 8565;
8567 -> 8566;
8568 -> 8566;
8569 -> 8567;
8569 -> 8568;
8570 -> 8569;
8570 -> 8566;
8571 -> 8570;
8571 -> 8564;
8572 -> 8571;
8572 -> 8562;
8573 -> 8572;
8573 -> 8560;
8574 -> 8573;
8574 -> 8554;
8575 -> 8554;
8576 -> 8554;
8576 -> 8575;
8577 -> 8575;
8578 -> 8577;
8578 -> 8554;
8579 -> 8554;
8580 -> 8579;
8581 -> 8554;
8582 -> 8578;
8582 -> 8581;
8582 -> 8554;
8583 -> 8554;
8584 -> 8554;
8585 -> 8554;
8585 -> 8544;
8586 -> 8585;
8587 -> 8585;
8588 -> 8586;
8588 -> 8587;
8589 -> 8587;
8590 -> 8588;
8590 -> 8589;
8590 -> 8587;
8591 -> 8587;
8592 -> 8588;
8592 -> 8591;
8593 -> 8591;
8593 -> 8587;
8594 -> 8593;
8594 -> 8585;
8595 -> 8585;
8596 -> 8585;
8597 -> 8585;
8598 -> 8597;
8599 -> 7735;
8600 -> 8599;
8600 -> 7731;
8601 -> 7731;
8602 -> 7734;
8602 -> 8601;
8603 -> 8600;
8603 -> 8601;
8604 -> 7732;
8604 -> 8601;
8605 -> 8601;
8606 -> 8603;
8606 -> 8605;
8606 -> 8601;
8607 -> 8606;
8608 -> 7731;
8609 -> 7732;
8609 -> 8608;
8610 -> 8608;
8611 -> 8609;
8611 -> 8610;
8612 -> 8611;
8612 -> 8598;
8612 -> 8610;
8613 -> 8610;
8614 -> 8612;
8614 -> 8613;
8615 -> 0;
8615 -> 8613;
8616 -> 8615;
8616 -> 8610;
8617 -> 8610;
8618 -> 8612;
8618 -> 8608;
8619 -> 8618;
8619 -> 7731;
8620 -> 7731;
8621 -> 8619;
8621 -> 8620;
8622 -> 8620;
8623 -> 8621;
8623 -> 8622;
8624 -> 8622;
8625 -> 8623;
8625 -> 8624;
8626 -> 8624;
8627 -> 8625;
8627 -> 8598;
8627 -> 8626;
8627 -> 8624;
8628 -> 8622;
8629 -> 8623;
8629 -> 8620;
8630 -> 8620;
8631 -> 8602;
8631 -> 7731;
8632 -> 8631;
8632 -> 7727;
8633 -> 7727;
8634 -> 7730;
8634 -> 8633;
8635 -> 8632;
8635 -> 8633;
8636 -> 7728;
8636 -> 8633;
8637 -> 8633;
8638 -> 8635;
8638 -> 8637;
8638 -> 8633;
8639 -> 8638;
8640 -> 8639;
8641 -> 7728;
8641 -> 8640;
8642 -> 8641;
8642 -> 8598;
8642 -> 8640;
8643 -> 8640;
8644 -> 8642;
8644 -> 8643;
8645 -> 0;
8645 -> 8643;
8646 -> 8645;
8646 -> 8640;
8647 -> 8640;
8648 -> 8642;
8648 -> 8639;
8649 -> 8639;
8650 -> 8648;
8650 -> 8649;
8651 -> 7728;
8651 -> 8598;
8651 -> 8639;
8652 -> 8650;
8653 -> 7728;
8653 -> 8652;
8654 -> 8653;
8654 -> 8650;
8654 -> 8652;
8655 -> 8654;
8655 -> 0;
8655 -> 8652;
8656 -> 8653;
8656 -> 8650;
8656 -> 8655;
8657 -> 8656;
8658 -> 8656;
8659 -> 8657;
8659 -> 8658;
8660 -> 8658;
8660 -> 8656;
8661 -> 0;
8661 -> 8656;
8662 -> 8656;
8663 -> 8660;
8663 -> 8662;
8663 -> 8656;
8664 -> 8663;
8665 -> 8664;
8665 -> 8663;
8666 -> 8665;
8666 -> 8663;
8667 -> 8666;
8668 -> 8667;
8668 -> 8666;
8669 -> 0;
8669 -> 8668;
8670 -> 8669;
8670 -> 8653;
8670 -> 8655;
8671 -> 8669;
8671 -> 8652;
8672 -> 8671;
8672 -> 8650;
8673 -> 8634;
8673 -> 7727;
8674 -> 8673;
8674 -> 7725;
8675 -> 8674;
8675 -> 7724;
8675 -> 7725;
8676 -> 7724;
8676 -> 8650;
8676 -> 8675;
8676 -> 7723;
8677 -> 8676;
8677 -> 7719;
8678 -> 7719;
8679 -> 8677;
8679 -> 8678;
8679 -> 7719;
8680 -> 7713;
8680 -> 6548;
8681 -> 6529;
8681 -> 8650;
8681 -> 6525;
8682 -> 6525;
8683 -> 8681;
8683 -> 8682;
8684 -> 6528;
8684 -> 8682;
8685 -> 8683;
8685 -> 8650;
8685 -> 8682;
8686 -> 8685;
8686 -> 8650;
8686 -> 8670;
8686 -> 8675;
8686 -> 8682;
8687 -> 8683;
8687 -> 8650;
8687 -> 8682;
8688 -> 8682;
8689 -> 8687;
8689 -> 8688;
8690 -> 8687;
8690 -> 8688;
8691 -> 8684;
8691 -> 8688;
8692 -> 8689;
8692 -> 8688;
8693 -> 8690;
8693 -> 8688;
8694 -> 8692;
8694 -> 8693;
8694 -> 8686;
8694 -> 8688;
8695 -> 8694;
8695 -> 8688;
8696 -> 8695;
8697 -> 8691;
8697 -> 6444;
8697 -> 8696;
8698 -> 8697;
8698 -> 8695;
8699 -> 0;
8699 -> 8695;
8700 -> 8695;
8701 -> 8691;
8701 -> 8700;
8702 -> 8701;
8702 -> 6442;
8702 -> 8700;
8703 -> 8702;
8703 -> 8698;
8703 -> 8700;
8704 -> 8700;
8705 -> 8701;
8705 -> 6442;
8705 -> 8704;
8706 -> 8705;
8706 -> 8703;
8706 -> 8704;
8707 -> 8706;
8707 -> 8704;
8708 -> 8704;
8709 -> 8707;
8709 -> 8708;
8710 -> 8708;
8711 -> 8709;
8711 -> 8706;
8711 -> 8710;
8712 -> 8711;
8712 -> 8708;
8713 -> 8712;
8714 -> 8713;
8714 -> 8704;
8715 -> 8714;
8715 -> 8704;
8716 -> 8680;
8716 -> 6525;
8717 -> 6525;
8718 -> 6525;
8719 -> 8715;
8719 -> 8718;
8720 -> 8716;
8720 -> 8718;
8721 -> 8717;
8721 -> 8718;
8722 -> 8720;
8722 -> 8718;
8723 -> 8720;
8723 -> 8718;
8724 -> 8721;
8724 -> 8718;
8725 -> 8719;
8725 -> 8724;
8726 -> 0;
8726 -> 8725;
8727 -> 8718;
8728 -> 8718;
8729 -> 8723;
8729 -> 8728;
8730 -> 8726;
8730 -> 8728;
8731 -> 8727;
8731 -> 8728;
8732 -> 8729;
8732 -> 8728;
8733 -> 8730;
8733 -> 0;
8733 -> 8728;
8734 -> 8730;
8734 -> 8728;
8735 -> 8729;
8735 -> 8734;
8736 -> 8734;
8737 -> 8735;
8737 -> 8736;
8738 -> 8736;
8739 -> 8737;
8739 -> 8738;
8740 -> 8738;
8741 -> 8739;
8741 -> 8740;
8742 -> 8740;
8743 -> 8741;
8743 -> 8742;
8744 -> 8743;
8744 -> 8740;
8745 -> 8744;
8745 -> 8738;
8746 -> 8745;
8746 -> 8736;
8747 -> 8736;
8748 -> 8746;
8748 -> 8747;
8749 -> 8729;
8749 -> 8728;
8750 -> 8731;
8750 -> 8728;
8751 -> 8728;
8752 -> 8749;
8752 -> 8751;
8753 -> 8730;
8753 -> 8751;
8754 -> 8750;
8754 -> 8751;
8755 -> 8752;
8755 -> 8751;
8756 -> 8754;
8756 -> 8751;
8757 -> 8751;
8758 -> 8756;
8758 -> 8757;
8759 -> 8758;
8759 -> 8750;
8759 -> 8757;
8760 -> 8044;
8760 -> 8759;
8761 -> 8751;
8762 -> 8751;
8763 -> 8755;
8763 -> 8762;
8764 -> 8753;
8764 -> 8762;
8765 -> 8760;
8765 -> 8762;
8766 -> 8761;
8766 -> 8762;
8767 -> 8763;
8767 -> 8762;
8768 -> 8767;
8768 -> 8762;
8769 -> 8763;
8769 -> 8768;
8770 -> 8768;
8771 -> 8769;
8771 -> 8770;
8772 -> 8770;
8773 -> 8771;
8773 -> 8772;
8774 -> 8772;
8775 -> 8773;
8775 -> 8774;
8776 -> 8774;
8777 -> 8775;
8777 -> 8776;
8778 -> 8777;
8778 -> 8776;
8779 -> 8778;
8779 -> 8774;
8780 -> 8779;
8780 -> 8772;
8781 -> 8780;
8781 -> 8770;
8782 -> 8770;
8783 -> 8781;
8783 -> 8782;
8784 -> 8783;
8784 -> 8706;
8784 -> 8782;
8785 -> 8764;
8785 -> 0;
8785 -> 8762;
8786 -> 8762;
8787 -> 8784;
8787 -> 8786;
8787 -> 8762;
8788 -> 8762;
8789 -> 8765;
8789 -> 8788;
8789 -> 8762;
8790 -> 8763;
8790 -> 8766;
8790 -> 8762;
8791 -> 8764;
8791 -> 8766;
8791 -> 8762;
8792 -> 8765;
8792 -> 8766;
8792 -> 8762;
8793 -> 8761;
8793 -> 8728;
8794 -> 8793;
8794 -> 8718;
8795 -> 8794;
8795 -> 6525;
8796 -> 8795;
8796 -> 8718;
8797 -> 8796;
8797 -> 8718;
8798 -> 8718;
8799 -> 8718;
8800 -> 8797;
8800 -> 8799;
8801 -> 8798;
8801 -> 8799;
8802 -> 8799;
8803 -> 8800;
8803 -> 8802;
8804 -> 8803;
8804 -> 8790;
8804 -> 8802;
8805 -> 8804;
8805 -> 8802;
8806 -> 8805;
8806 -> 8799;
8807 -> 8800;
8807 -> 8801;
8807 -> 8799;
8808 -> 8799;
8809 -> 8808;
8809 -> 8801;
8809 -> 8799;
8810 -> 8799;
8811 -> 8810;
8811 -> 8801;
8811 -> 8799;
8812 -> 8798;
8812 -> 6525;
8813 -> 8812;
8813 -> 6513;
8814 -> 6512;
8815 -> 8813;
8815 -> 8814;
8816 -> 8814;
8817 -> 8815;
8817 -> 8807;
8817 -> 8816;
8818 -> 8817;
8818 -> 8790;
8818 -> 8816;
8819 -> 8818;
8819 -> 8816;
8820 -> 8819;
8820 -> 8816;
8821 -> 8820;
8821 -> 8814;
8822 -> 8821;
8822 -> 6512;
8823 -> 8822;
8824 -> 8823;
8824 -> 8822;
8825 -> 8824;
8826 -> 8813;
8826 -> 8825;
8827 -> 8826;
8827 -> 8807;
8827 -> 8825;
8828 -> 8827;
8828 -> 8824;
8829 -> 6517;
8829 -> 8824;
8830 -> 6513;
8830 -> 8824;
8831 -> 6514;
8831 -> 8824;
8832 -> 8824;
8833 -> 8829;
8833 -> 8832;
8834 -> 8830;
8834 -> 8832;
8835 -> 8831;
8835 -> 8832;
8836 -> 8828;
8836 -> 8832;
8837 -> 8836;
8837 -> 8832;
8838 -> 8833;
8838 -> 8832;
8839 -> 8834;
8839 -> 8832;
8840 -> 8835;
8840 -> 8832;
8841 -> 8832;
8842 -> 8837;
8842 -> 8841;
8843 -> 8838;
8843 -> 8841;
8844 -> 8839;
8844 -> 8841;
8845 -> 8840;
8845 -> 8841;
8846 -> 8836;
8846 -> 8792;
8846 -> 8841;
8847 -> 8843;
8847 -> 8841;
8848 -> 8844;
8848 -> 8841;
8849 -> 8845;
8849 -> 8841;
8850 -> 8841;
8851 -> 8847;
8851 -> 8850;
8852 -> 8848;
8852 -> 8850;
8853 -> 8849;
8853 -> 8850;
8854 -> 8842;
8854 -> 8850;
8855 -> 8853;
8855 -> 8850;
8856 -> 8850;
8857 -> 8854;
8857 -> 8856;
8858 -> 8857;
8858 -> 8790;
8858 -> 8856;
8859 -> 8856;
8860 -> 8858;
8860 -> 8859;
8861 -> 8857;
8861 -> 8792;
8861 -> 8859;
8862 -> 8860;
8862 -> 8859;
8863 -> 8862;
8863 -> 8856;
8864 -> 8863;
8864 -> 8850;
8865 -> 8852;
8865 -> 8850;
8866 -> 8850;
8867 -> 8850;
8868 -> 8855;
8868 -> 8867;
8869 -> 8864;
8869 -> 8867;
8870 -> 8865;
8870 -> 8867;
8871 -> 8866;
8871 -> 8867;
8872 -> 8851;
8872 -> 8867;
8873 -> 8868;
8873 -> 8867;
8874 -> 8869;
8874 -> 8867;
8875 -> 8870;
8875 -> 8867;
8876 -> 8871;
8876 -> 8867;
8877 -> 8867;
8878 -> 8873;
8878 -> 8877;
8879 -> 8874;
8879 -> 8877;
8880 -> 8875;
8880 -> 8877;
8881 -> 8876;
8881 -> 8877;
8882 -> 8872;
8882 -> 8877;
8883 -> 8877;
8884 -> 8879;
8884 -> 8883;
8885 -> 8883;
8885 -> 8877;
8886 -> 8878;
8886 -> 8885;
8887 -> 8879;
8887 -> 8885;
8888 -> 8880;
8888 -> 8885;
8889 -> 8881;
8889 -> 8885;
8890 -> 8885;
8891 -> 8882;
8891 -> 8890;
8892 -> 8891;
8892 -> 6453;
8892 -> 8890;
8893 -> 8892;
8893 -> 8885;
8894 -> 8885;
8895 -> 8882;
8895 -> 8894;
8896 -> 8894;
8897 -> 8895;
8897 -> 8896;
8898 -> 8897;
8898 -> 6453;
8898 -> 8896;
8899 -> 8898;
8899 -> 8894;
8900 -> 8899;
8900 -> 8894;
8901 -> 8894;
8902 -> 8899;
8902 -> 8901;
8903 -> 0;
8903 -> 8901;
8904 -> 8903;
8904 -> 8894;
8905 -> 8900;
8905 -> 8904;
8905 -> 8894;
8906 -> 8899;
8906 -> 8894;
8907 -> 8906;
8908 -> 8907;
8908 -> 8706;
8909 -> 8908;
8909 -> 8906;
8910 -> 8909;
8910 -> 8885;
8911 -> 8882;
8911 -> 6443;
8911 -> 8885;
8912 -> 8885;
8913 -> 8886;
8913 -> 8912;
8914 -> 8887;
8914 -> 8912;
8915 -> 8888;
8915 -> 8912;
8916 -> 8889;
8916 -> 8912;
8917 -> 8893;
8917 -> 8912;
8918 -> 8910;
8918 -> 8912;
8919 -> 8911;
8919 -> 8912;
8920 -> 8914;
8920 -> 8912;
8921 -> 8920;
8921 -> 8706;
8921 -> 8912;
8922 -> 8912;
8923 -> 8914;
8923 -> 8922;
8924 -> 8922;
8924 -> 8912;
8925 -> 8912;
8926 -> 8914;
8926 -> 8925;
8927 -> 8925;
8927 -> 8912;
8928 -> 8914;
8928 -> 8912;
8929 -> 8918;
8929 -> 8912;
8930 -> 8912;
8931 -> 8928;
8931 -> 8930;
8932 -> 8929;
8932 -> 8930;
8933 -> 8930;
8934 -> 8931;
8934 -> 8933;
8935 -> 8933;
8935 -> 8930;
8936 -> 8931;
8936 -> 8935;
8937 -> 8916;
8937 -> 8912;
8938 -> 8937;
8938 -> 8912;
8939 -> 8913;
8939 -> 8912;
8940 -> 8936;
8940 -> 8912;
8941 -> 8915;
8941 -> 8912;
8942 -> 8917;
8942 -> 8912;
8943 -> 8919;
8943 -> 8912;
8944 -> 8912;
8945 -> 8939;
8945 -> 8944;
8946 -> 8940;
8946 -> 8944;
8947 -> 8941;
8947 -> 8944;
8948 -> 8942;
8948 -> 8944;
8949 -> 8943;
8949 -> 8944;
8950 -> 8944;
8951 -> 8945;
8951 -> 8950;
8951 -> 8944;
8952 -> 8946;
8952 -> 8944;
8953 -> 8948;
8953 -> 8944;
8954 -> 8944;
8955 -> 8944;
8956 -> 8952;
8956 -> 8955;
8957 -> 8953;
8957 -> 8955;
8958 -> 8954;
8958 -> 8955;
8959 -> 8955;
8960 -> 8956;
8960 -> 8959;
8961 -> 8959;
8962 -> 8960;
8962 -> 8961;
8963 -> 8961;
8964 -> 8962;
8964 -> 8963;
8965 -> 8964;
8965 -> 8921;
8965 -> 8963;
8966 -> 8963;
8967 -> 8965;
8967 -> 8966;
8967 -> 8963;
8968 -> 8963;
8969 -> 8964;
8969 -> 8968;
8970 -> 8968;
8971 -> 8969;
8971 -> 8970;
8972 -> 8971;
8972 -> 8921;
8972 -> 8970;
8973 -> 8970;
8974 -> 8972;
8974 -> 8973;
8975 -> 0;
8975 -> 8973;
8976 -> 8975;
8976 -> 8970;
8977 -> 8970;
8978 -> 8972;
8978 -> 8968;
8979 -> 8969;
8979 -> 8921;
8979 -> 8968;
8980 -> 8968;
8981 -> 8979;
8981 -> 8980;
8982 -> 8978;
8982 -> 8980;
8983 -> 8981;
8983 -> 8980;
8984 -> 8982;
8984 -> 8921;
8984 -> 8983;
8984 -> 8980;
8985 -> 8984;
8986 -> 8985;
8987 -> 8986;
8987 -> 8963;
8988 -> 8987;
8989 -> 8987;
8990 -> 8988;
8990 -> 8989;
8991 -> 8990;
8991 -> 8989;
8992 -> 0;
8992 -> 8990;
8992 -> 8989;
8993 -> 0;
8993 -> 8990;
8993 -> 8989;
8994 -> 8990;
8994 -> 8989;
8995 -> 8990;
8995 -> 8989;
8996 -> 8990;
8996 -> 8989;
8997 -> 8990;
8997 -> 8989;
8998 -> 3417;
8998 -> 8990;
8998 -> 8989;
8999 -> 0;
8999 -> 8990;
8999 -> 8989;
9000 -> 8964;
9000 -> 8984;
9000 -> 8987;
9001 -> 8988;
9001 -> 8987;
9002 -> 8987;
9003 -> 9000;
9003 -> 9001;
9003 -> 9002;
9003 -> 8991;
9003 -> 8992;
9003 -> 8993;
9003 -> 8994;
9003 -> 8995;
9003 -> 8996;
9003 -> 8997;
9003 -> 8998;
9003 -> 8999;
9003 -> 8984;
9003 -> 0;
9003 -> 8987;
9004 -> 9003;
9004 -> 8961;
9005 -> 9004;
9005 -> 6720;
9005 -> 8961;
9006 -> 8961;
9007 -> 8962;
9007 -> 9006;
9008 -> 9006;
9009 -> 9007;
9009 -> 9008;
9010 -> 9009;
9010 -> 9003;
9010 -> 9008;
9011 -> 9008;
9012 -> 9010;
9012 -> 9011;
9012 -> 9008;
9013 -> 9010;
9013 -> 6720;
9013 -> 9012;
9014 -> 9012;
9015 -> 9010;
9015 -> 9012;
9016 -> 9015;
9016 -> 9006;
9017 -> 9016;
9017 -> 6720;
9017 -> 9006;
9018 -> 9016;
9018 -> 9003;
9018 -> 9006;
9019 -> 0;
9019 -> 9018;
9020 -> 9018;
9021 -> 9020;
9022 -> 9021;
9022 -> 9018;
9023 -> 9022;
9024 -> 9023;
9025 -> 9023;
9025 -> 9024;
9026 -> 0;
9026 -> 9024;
9027 -> 9026;
9027 -> 9023;
9028 -> 9023;
9028 -> 9022;
9029 -> 9022;
9030 -> 9028;
9030 -> 9029;
9031 -> 9030;
9031 -> 9022;
9032 -> 9007;
9032 -> 9003;
9032 -> 9022;
9033 -> 9031;
9033 -> 9032;
9033 -> 9003;
9033 -> 9022;
9034 -> 9033;
9034 -> 9016;
9034 -> 9018;
9035 -> 9016;
9035 -> 9033;
9035 -> 9034;
9035 -> 9006;
9036 -> 9035;
9036 -> 8961;
9037 -> 9004;
9037 -> 9033;
9037 -> 8961;
9038 -> 8962;
9038 -> 9033;
9038 -> 8961;
9039 -> 8961;
9040 -> 8962;
9040 -> 9039;
9041 -> 9040;
9041 -> 9033;
9041 -> 9039;
9042 -> 9039;
9043 -> 9041;
9043 -> 9042;
9044 -> 0;
9044 -> 9042;
9045 -> 9044;
9045 -> 9039;
9046 -> 9039;
9047 -> 9041;
9047 -> 8961;
9048 -> 9036;
9048 -> 8961;
9049 -> 8961;
9050 -> 9037;
9050 -> 9049;
9051 -> 9038;
9051 -> 9049;
9052 -> 9047;
9052 -> 9049;
9053 -> 9048;
9053 -> 9049;
9054 -> 9050;
9054 -> 9049;
9055 -> 0;
9055 -> 9049;
9056 -> 9051;
9056 -> 9054;
9057 -> 9052;
9057 -> 9054;
9058 -> 9053;
9058 -> 9054;
9059 -> 9054;
9060 -> 9056;
9060 -> 9059;
9061 -> 9057;
9061 -> 9059;
9062 -> 9058;
9062 -> 9059;
9063 -> 9059;
9064 -> 9061;
9064 -> 9063;
9065 -> 9064;
9065 -> 9059;
9066 -> 9060;
9066 -> 9059;
9067 -> 9061;
9067 -> 9059;
9068 -> 9059;
9069 -> 9059;
9070 -> 9067;
9070 -> 9069;
9071 -> 9068;
9071 -> 9069;
9072 -> 9070;
9072 -> 9069;
9073 -> 9069;
9074 -> 9069;
9075 -> 9069;
9076 -> 9072;
9076 -> 9075;
9077 -> 9073;
9077 -> 9075;
9078 -> 9074;
9078 -> 9075;
9079 -> 9076;
9079 -> 9033;
9079 -> 9034;
9080 -> 9075;
9081 -> 9076;
9081 -> 9080;
9081 -> 9075;
9082 -> 9062;
9082 -> 9059;
9083 -> 9065;
9083 -> 9066;
9083 -> 9068;
9083 -> 9082;
9083 -> 9079;
9083 -> 9075;
9083 -> 9077;
9083 -> 9078;
9083 -> 9033;
9083 -> 9034;
9083 -> 9059;
9084 -> 9059;
9085 -> 9083;
9085 -> 9084;
9085 -> 9059;
9086 -> 9083;
9086 -> 9059;
9087 -> 9050;
9087 -> 9054;
9088 -> 9086;
9088 -> 9054;
9089 -> 0;
9089 -> 9054;
9090 -> 8961;
9091 -> 9004;
9091 -> 9088;
9091 -> 8961;
9092 -> 9091;
9092 -> 8959;
9093 -> 8959;
9094 -> 9092;
9094 -> 9093;
9094 -> 8959;
9095 -> 9094;
9095 -> 8959;
9096 -> 9095;
9096 -> 8955;
9097 -> 0;
9097 -> 9096;
9098 -> 8944;
9099 -> 9097;
9099 -> 8944;
9100 -> 8944;
9101 -> 9098;
9101 -> 9100;
9101 -> 8944;
9102 -> 9097;
9102 -> 8944;
9103 -> 9102;
9103 -> 8912;
9104 -> 8937;
9104 -> 9103;
9105 -> 8885;
9106 -> 8867;
9107 -> 8841;
9108 -> 8824;
9109 -> 8813;
9109 -> 8822;
9110 -> 9109;
9110 -> 6512;
9111 -> 6514;
9111 -> 6512;
9112 -> 6513;
9112 -> 6512;
9113 -> 6515;
9113 -> 6512;
9114 -> 6512;
9115 -> 9110;
9115 -> 9114;
9116 -> 9111;
9116 -> 9114;
9117 -> 9112;
9117 -> 9114;
9118 -> 9113;
9118 -> 9114;
9119 -> 6517;
9119 -> 9114;
9120 -> 9114;
9121 -> 9115;
9121 -> 9120;
9122 -> 9121;
9122 -> 8809;
9122 -> 9120;
9123 -> 9122;
9123 -> 0;
9123 -> 9120;
9124 -> 9123;
9124 -> 9114;
9125 -> 9115;
9125 -> 9114;
9126 -> 6512;
9127 -> 9125;
9127 -> 9126;
9128 -> 9127;
9128 -> 8807;
9128 -> 9126;
9129 -> 6501;
9130 -> 9128;
9130 -> 9129;
9131 -> 9130;
9131 -> 8790;
9131 -> 9129;
9132 -> 9129;
9133 -> 9131;
9133 -> 9132;
9134 -> 9130;
9134 -> 8792;
9134 -> 9132;
9135 -> 9132;
9136 -> 9133;
9136 -> 9135;
9137 -> 9136;
9137 -> 9088;
9137 -> 0;
9137 -> 9135;
9138 -> 9135;
9139 -> 9137;
9139 -> 6501;
9140 -> 6506;
9140 -> 6501;
9141 -> 9140;
9142 -> 6507;
9142 -> 9141;
9143 -> 9142;
9143 -> 6443;
9143 -> 9141;
9144 -> 0;
9144 -> 9141;
9145 -> 9141;
9146 -> 9143;
9146 -> 9145;
9147 -> 9144;
9147 -> 9145;
9148 -> 9146;
9148 -> 9140;
9149 -> 6503;
9149 -> 9148;
9150 -> 9128;
9150 -> 9148;
9151 -> 9150;
9151 -> 8790;
9151 -> 8791;
9151 -> 8792;
9151 -> 9088;
9151 -> 8043;
9151 -> 0;
9151 -> 9148;
9152 -> 9149;
9152 -> 9151;
9152 -> 6222;
9152 -> 9148;
9153 -> 6501;
9154 -> 6502;
9154 -> 9152;
9154 -> 9153;
9154 -> 6501;
9155 -> 6502;
9155 -> 9152;
9155 -> 9154;
9156 -> 9155;
9156 -> 9154;
9157 -> 9154;
9158 -> 9156;
9158 -> 9155;
9158 -> 9157;
9158 -> 9154;
9159 -> 6504;
9159 -> 9158;
9159 -> 9154;
9160 -> 9154;
9161 -> 9160;
9161 -> 9158;
9162 -> 9160;
9162 -> 9158;
9163 -> 9162;
9163 -> 9160;
9164 -> 9160;
9164 -> 9158;
9165 -> 9164;
9165 -> 9154;
9166 -> 9128;
9166 -> 9154;
9167 -> 9155;
9167 -> 9164;
9167 -> 9154;
9168 -> 9154;
9169 -> 9165;
9169 -> 9168;
9170 -> 9166;
9170 -> 9168;
9171 -> 9167;
9171 -> 9168;
9172 -> 9168;
9173 -> 9171;
9173 -> 9172;
9173 -> 9168;
9174 -> 9169;
9174 -> 9173;
9175 -> 9170;
9175 -> 9173;
9176 -> 9173;
9177 -> 9174;
9177 -> 9176;
9178 -> 9175;
9178 -> 9176;
9179 -> 9178;
9179 -> 9176;
9180 -> 0;
9180 -> 9176;
9181 -> 9176;
9182 -> 9180;
9182 -> 9181;
9183 -> 9177;
9183 -> 9181;
9184 -> 9181;
9185 -> 9183;
9185 -> 9184;
9186 -> 9185;
9186 -> 9181;
9187 -> 9186;
9188 -> 9186;
9188 -> 9187;
9189 -> 9187;
9190 -> 9188;
9190 -> 9189;
9191 -> 9189;
9192 -> 9190;
9192 -> 9164;
9192 -> 9191;
9192 -> 9189;
9193 -> 9187;
9194 -> 9188;
9194 -> 9164;
9194 -> 9187;
9195 -> 9194;
9195 -> 9186;
9196 -> 9186;
9197 -> 9183;
9197 -> 9164;
9197 -> 9182;
9197 -> 9181;
9198 -> 9183;
9198 -> 9164;
9198 -> 9182;
9198 -> 9181;
9199 -> 9177;
9199 -> 9176;
9200 -> 9176;
9201 -> 9179;
9201 -> 9200;
9202 -> 9199;
9202 -> 9200;
9203 -> 9200;
9204 -> 0;
9204 -> 9200;
9205 -> 9200;
9206 -> 9204;
9206 -> 9205;
9207 -> 9202;
9207 -> 9205;
9208 -> 9205;
9209 -> 9207;
9209 -> 9208;
9210 -> 9209;
9210 -> 9205;
9211 -> 9210;
9212 -> 9210;
9212 -> 9211;
9213 -> 9211;
9214 -> 9212;
9214 -> 9213;
9215 -> 9213;
9216 -> 9214;
9216 -> 9164;
9216 -> 9215;
9216 -> 9213;
9217 -> 9211;
9218 -> 9212;
9218 -> 9164;
9218 -> 9211;
9219 -> 9218;
9219 -> 9210;
9220 -> 9210;
9221 -> 9207;
9221 -> 9164;
9221 -> 9206;
9221 -> 9205;
9222 -> 9221;
9223 -> 9221;
9224 -> 9221;
9225 -> 9221;
9226 -> 9223;
9226 -> 9225;
9226 -> 9221;
9227 -> 9221;
9228 -> 9221;
9229 -> 9221;
9230 -> 9221;
9231 -> 9221;
9232 -> 9231;
9232 -> 9221;
9233 -> 9221;
9234 -> 9232;
9234 -> 9233;
9235 -> 9233;
9235 -> 9221;
9236 -> 9221;
9237 -> 9235;
9238 -> 9232;
9238 -> 9237;
9239 -> 9238;
9239 -> 9235;
9240 -> 9235;
9241 -> 9235;
9242 -> 9232;
9242 -> 9241;
9243 -> 9242;
9243 -> 9235;
9244 -> 9243;
9244 -> 9233;
9245 -> 9239;
9246 -> 9239;
9247 -> 9239;
9248 -> 9239;
9249 -> 9239;
9250 -> 9239;
9251 -> 9239;
9252 -> 9239;
9253 -> 9239;
9254 -> 9239;
9255 -> 9239;
9256 -> 9239;
9257 -> 9239;
9258 -> 9239;
9259 -> 9258;
9259 -> 9239;
9260 -> 9259;
9260 -> 9239;
9261 -> 9239;
9262 -> 9239;
9263 -> 9239;
9264 -> 9239;
9265 -> 9239;
9266 -> 9239;
9267 -> 9239;
9268 -> 9239;
9269 -> 9239;
9270 -> 9239;
9271 -> 9239;
9272 -> 0;
9272 -> 9239;
9273 -> 9270;
9273 -> 9239;
9274 -> 9239;
9275 -> 9256;
9275 -> 9274;
9275 -> 9239;
9276 -> 9239;
9277 -> 9251;
9277 -> 9276;
9277 -> 9239;
9278 -> 9239;
9279 -> 9239;
9280 -> 9239;
9280 -> 0;
9281 -> 9239;
9282 -> 9239;
9282 -> 9281;
9283 -> 9281;
9284 -> 9282;
9284 -> 9283;
9285 -> 9284;
9285 -> 9239;
9285 -> 9283;
9286 -> 9285;
9286 -> 9281;
9287 -> 9281;
9288 -> 9286;
9288 -> 9287;
9288 -> 9281;
9289 -> 9288;
9289 -> 9281;
9290 -> 9289;
9291 -> 9286;
9291 -> 9290;
9292 -> 9290;
9293 -> 9291;
9293 -> 9292;
9294 -> 9293;
9294 -> 9290;
9295 -> 9290;
9296 -> 9294;
9296 -> 9295;
9297 -> 9296;
9297 -> 9239;
9298 -> 9239;
9299 -> 9239;
9300 -> 9239;
9300 -> 9299;
9301 -> 9299;
9302 -> 9300;
9302 -> 9301;
9303 -> 9301;
9304 -> 9302;
9304 -> 9303;
9305 -> 0;
9305 -> 9303;
9306 -> 9305;
9306 -> 9301;
9307 -> 9302;
9307 -> 9299;
9308 -> 9307;
9308 -> 9239;
9309 -> 9239;
9310 -> 9308;
9310 -> 9309;
9311 -> 9310;
9311 -> 9239;
9311 -> 9309;
9312 -> 9239;
9313 -> 9239;
9314 -> 9239;
9315 -> 9239;
9315 -> 0;
9316 -> 9239;
9317 -> 9223;
9317 -> 9316;
9317 -> 9239;
9318 -> 9239;
9318 -> 9227;
9318 -> 9221;
9319 -> 9239;
9319 -> 9221;
9320 -> 9239;
9321 -> 9239;
9321 -> 9320;
9322 -> 0;
9322 -> 9320;
9323 -> 9322;
9323 -> 9239;
9324 -> 9239;
9325 -> 9239;
9326 -> 9325;
9326 -> 9239;
9327 -> 9239;
9328 -> 9239;
9328 -> 9327;
9329 -> 9327;
9330 -> 9328;
9330 -> 9329;
9331 -> 0;
9331 -> 9329;
9332 -> 9331;
9332 -> 9327;
9333 -> 9332;
9333 -> 9239;
9334 -> 9239;
9335 -> 9334;
9336 -> 9239;
9337 -> 9239;
9338 -> 9239;
9339 -> 9239;
9340 -> 9338;
9340 -> 9239;
9341 -> 9340;
9342 -> 9340;
9343 -> 9239;
9344 -> 9239;
9345 -> 9239;
9346 -> 0;
9346 -> 9239;
9347 -> 9239;
9348 -> 9347;
9348 -> 9239;
9349 -> 9348;
9349 -> 9239;
9350 -> 9239;
9351 -> 9349;
9351 -> 9350;
9352 -> 9239;
9352 -> 9350;
9353 -> 9351;
9353 -> 9350;
9354 -> 9350;
9355 -> 9353;
9355 -> 9354;
9355 -> 9350;
9356 -> 9352;
9356 -> 9239;
9356 -> 0;
9356 -> 9350;
9357 -> 9350;
9358 -> 9353;
9358 -> 9357;
9359 -> 9358;
9359 -> 9239;
9359 -> 9357;
9360 -> 9357;
9360 -> 9350;
9361 -> 9360;
9361 -> 9239;
9362 -> 9239;
9362 -> 9361;
9363 -> 9361;
9364 -> 9362;
9364 -> 9363;
9365 -> 9362;
9365 -> 9363;
9366 -> 9365;
9366 -> 9362;
9366 -> 9363;
9367 -> 9363;
9368 -> 9364;
9368 -> 9363;
9369 -> 9363;
9370 -> 9366;
9370 -> 9369;
9371 -> 9366;
9371 -> 9369;
9372 -> 9366;
9372 -> 9369;
9373 -> 9366;
9373 -> 9369;
9374 -> 9366;
9374 -> 9369;
9375 -> 9366;
9375 -> 9369;
9376 -> 9367;
9376 -> 9369;
9377 -> 9368;
9377 -> 9369;
9378 -> 9367;
9378 -> 9369;
9379 -> 9370;
9379 -> 9369;
9380 -> 9371;
9380 -> 9369;
9381 -> 9376;
9381 -> 9369;
9382 -> 9372;
9382 -> 9369;
9383 -> 9373;
9383 -> 9369;
9384 -> 9377;
9384 -> 9369;
9385 -> 9369;
9386 -> 9385;
9386 -> 9379;
9386 -> 9380;
9386 -> 9381;
9386 -> 9382;
9386 -> 9383;
9386 -> 9384;
9386 -> 9362;
9386 -> 9369;
9387 -> 9374;
9387 -> 9385;
9387 -> 9369;
9388 -> 9375;
9388 -> 9385;
9388 -> 9369;
9389 -> 9367;
9389 -> 9361;
9390 -> 9362;
9390 -> 9389;
9390 -> 9386;
9390 -> 9385;
9390 -> 9387;
9390 -> 9388;
9390 -> 9361;
9391 -> 9361;
9392 -> 9390;
9392 -> 9391;
9393 -> 9348;
9393 -> 9391;
9394 -> 9392;
9394 -> 9390;
9394 -> 9391;
9395 -> 9392;
9395 -> 9390;
9395 -> 9391;
9396 -> 9393;
9396 -> 9392;
9397 -> 9396;
9397 -> 9392;
9398 -> 9392;
9399 -> 9397;
9399 -> 9392;
9400 -> 9392;
9401 -> 9399;
9401 -> 9400;
9401 -> 9392;
9402 -> 9398;
9402 -> 9390;
9402 -> 0;
9402 -> 9392;
9403 -> 9399;
9403 -> 9392;
9404 -> 9403;
9404 -> 9390;
9404 -> 9392;
9405 -> 9392;
9405 -> 9390;
9406 -> 9392;
9406 -> 9390;
9407 -> 9403;
9407 -> 9390;
9407 -> 9392;
9408 -> 9396;
9408 -> 9392;
9409 -> 9408;
9409 -> 9390;
9409 -> 9392;
9410 -> 9392;
9411 -> 9396;
9411 -> 9410;
9412 -> 9411;
9412 -> 9396;
9412 -> 9410;
9413 -> 9410;
9413 -> 9392;
9414 -> 9392;
9415 -> 9413;
9415 -> 9414;
9416 -> 9392;
9416 -> 9414;
9417 -> 0;
9417 -> 9414;
9418 -> 9414;
9419 -> 9415;
9419 -> 9414;
9420 -> 9414;
9421 -> 9417;
9421 -> 9420;
9422 -> 9418;
9422 -> 9420;
9423 -> 9419;
9423 -> 9420;
9424 -> 9416;
9424 -> 9420;
9425 -> 9424;
9425 -> 9396;
9425 -> 9423;
9426 -> 9392;
9427 -> 9393;
9427 -> 9391;
9428 -> 9427;
9428 -> 9425;
9428 -> 9391;
9429 -> 9361;
9430 -> 9361;
9431 -> 9348;
9431 -> 9430;
9432 -> 9431;
9432 -> 9425;
9432 -> 9430;
9433 -> 9430;
9433 -> 9361;
9434 -> 9361;
9435 -> 9413;
9435 -> 9434;
9436 -> 9239;
9436 -> 9434;
9437 -> 0;
9437 -> 9434;
9438 -> 9434;
9439 -> 9435;
9439 -> 9434;
9440 -> 9434;
9441 -> 9437;
9441 -> 9440;
9442 -> 9438;
9442 -> 9440;
9443 -> 9439;
9443 -> 9440;
9444 -> 9436;
9444 -> 9440;
9445 -> 9361;
9446 -> 9239;
9447 -> 9446;
9447 -> 9425;
9447 -> 9239;
9448 -> 9333;
9448 -> 9425;
9448 -> 9239;
9449 -> 9239;
9449 -> 9221;
9450 -> 9239;
9450 -> 9221;
9450 -> 9449;
9451 -> 9449;
9452 -> 9449;
9453 -> 9239;
9453 -> 9221;
9453 -> 9452;
9454 -> 9452;
9455 -> 9453;
9455 -> 9454;
9456 -> 9454;
9456 -> 9425;
9457 -> 9454;
9457 -> 9425;
9458 -> 9457;
9459 -> 9457;
9460 -> 9457;
9461 -> 9457;
9462 -> 9461;
9462 -> 9457;
9463 -> 9462;
9463 -> 9457;
9464 -> 9462;
9464 -> 9457;
9465 -> 9462;
9466 -> 9462;
9467 -> 9462;
9468 -> 9462;
9469 -> 9462;
9470 -> 9462;
9471 -> 9462;
9472 -> 9462;
9473 -> 9472;
9473 -> 9462;
9474 -> 9473;
9474 -> 9462;
9475 -> 9462;
9476 -> 9462;
9477 -> 9462;
9478 -> 9462;
9479 -> 9462;
9480 -> 9462;
9481 -> 9462;
9482 -> 9462;
9483 -> 9462;
9484 -> 9462;
9485 -> 9462;
9486 -> 0;
9486 -> 9462;
9487 -> 9484;
9487 -> 9462;
9488 -> 9462;
9489 -> 9462;
9490 -> 9462;
9491 -> 9462;
9492 -> 9470;
9492 -> 9491;
9492 -> 9462;
9493 -> 9462;
9494 -> 9493;
9494 -> 9462;
9495 -> 9494;
9495 -> 9462;
9496 -> 9462;
9497 -> 9462;
9498 -> 9465;
9498 -> 9497;
9498 -> 9462;
9499 -> 9462;
9500 -> 9462;
9501 -> 9462;
9501 -> 0;
9502 -> 9462;
9503 -> 9462;
9503 -> 9502;
9504 -> 9502;
9505 -> 9503;
9505 -> 9504;
9506 -> 9505;
9506 -> 9462;
9506 -> 9504;
9507 -> 9506;
9507 -> 9502;
9508 -> 9502;
9509 -> 9507;
9509 -> 9508;
9509 -> 9502;
9510 -> 9509;
9510 -> 9502;
9511 -> 9510;
9512 -> 9507;
9512 -> 9511;
9513 -> 9511;
9514 -> 9512;
9514 -> 9513;
9515 -> 9514;
9515 -> 9511;
9516 -> 9511;
9517 -> 9515;
9517 -> 9516;
9518 -> 9517;
9518 -> 9462;
9519 -> 9462;
9520 -> 9462;
9521 -> 9462;
9521 -> 9520;
9522 -> 9520;
9523 -> 9521;
9523 -> 9522;
9524 -> 9522;
9525 -> 9523;
9525 -> 9524;
9526 -> 0;
9526 -> 9524;
9527 -> 9526;
9527 -> 9522;
9528 -> 9523;
9528 -> 9520;
9529 -> 9528;
9529 -> 9462;
9530 -> 9462;
9531 -> 9529;
9531 -> 9530;
9532 -> 9531;
9532 -> 9462;
9532 -> 9530;
9533 -> 9462;
9534 -> 9462;
9535 -> 9462;
9536 -> 9462;
9536 -> 0;
9537 -> 9454;
9538 -> 9454;
9538 -> 9462;
9538 -> 9455;
9539 -> 9538;
9539 -> 9452;
9540 -> 9539;
9541 -> 9539;
9541 -> 9540;
9542 -> 9541;
9542 -> 9538;
9542 -> 9540;
9543 -> 9542;
9543 -> 9539;
9544 -> 9539;
9545 -> 9539;
9545 -> 9544;
9546 -> 9545;
9546 -> 9538;
9546 -> 9544;
9547 -> 9546;
9547 -> 9539;
9548 -> 9543;
9548 -> 9547;
9548 -> 9539;
9549 -> 9548;
9550 -> 9324;
9550 -> 9549;
9550 -> 9548;
9551 -> 9539;
9551 -> 9548;
9552 -> 9239;
9553 -> 9551;
9553 -> 9552;
9553 -> 9239;
9554 -> 9221;
9555 -> 9551;
9555 -> 9554;
9555 -> 9221;
9556 -> 9221;
9557 -> 9551;
9557 -> 9556;
9558 -> 9556;
9558 -> 9221;
9559 -> 9221;
9560 -> 9551;
9560 -> 9559;
9561 -> 0;
9561 -> 9559;
9562 -> 9560;
9562 -> 9221;
9563 -> 9558;
9563 -> 9562;
9563 -> 9221;
9564 -> 9551;
9564 -> 0;
9564 -> 9221;
9565 -> 9221;
9566 -> 9551;
9566 -> 9565;
9567 -> 9565;
9568 -> 9566;
9568 -> 9567;
9569 -> 9568;
9569 -> 9538;
9569 -> 9567;
9570 -> 9569;
9570 -> 9565;
9571 -> 9565;
9572 -> 9570;
9572 -> 9571;
9572 -> 9565;
9573 -> 9572;
9573 -> 9565;
9574 -> 9573;
9575 -> 9570;
9575 -> 9574;
9576 -> 9574;
9577 -> 9575;
9577 -> 9576;
9578 -> 9577;
9578 -> 9574;
9579 -> 9574;
9580 -> 9578;
9580 -> 9579;
9581 -> 9580;
9581 -> 9221;
9582 -> 9221;
9583 -> 9221;
9584 -> 9551;
9584 -> 9583;
9585 -> 9583;
9586 -> 9584;
9586 -> 9585;
9587 -> 9585;
9588 -> 9586;
9588 -> 9587;
9589 -> 0;
9589 -> 9587;
9590 -> 9589;
9590 -> 9585;
9591 -> 9586;
9591 -> 9583;
9592 -> 9591;
9592 -> 9221;
9593 -> 9221;
9594 -> 9592;
9594 -> 9593;
9595 -> 9594;
9595 -> 9538;
9595 -> 9593;
9596 -> 9221;
9597 -> 9538;
9597 -> 9221;
9598 -> 9221;
9599 -> 9551;
9600 -> 9221;
9600 -> 9551;
9601 -> 9551;
9601 -> 9200;
9602 -> 9200;
9603 -> 9601;
9603 -> 9602;
9604 -> 9602;
9605 -> 9603;
9605 -> 9604;
9605 -> 9602;
9606 -> 9602;
9607 -> 9603;
9607 -> 9606;
9608 -> 9606;
9608 -> 9602;
9609 -> 9608;
9609 -> 9200;
9610 -> 9551;
9610 -> 9609;
9611 -> 9201;
9611 -> 9609;
9612 -> 9611;
9612 -> 8790;
9612 -> 8791;
9612 -> 8792;
9612 -> 9551;
9612 -> 9609;
9613 -> 9609;
9614 -> 9609;
9615 -> 9610;
9615 -> 9614;
9616 -> 9612;
9616 -> 9614;
9617 -> 9613;
9617 -> 9614;
9618 -> 9613;
9618 -> 9614;
9619 -> 9613;
9619 -> 9614;
9620 -> 9614;
9621 -> 9615;
9621 -> 9620;
9622 -> 9621;
9622 -> 9551;
9622 -> 9620;
9623 -> 9614;
9624 -> 9615;
9624 -> 9623;
9625 -> 9624;
9625 -> 9551;
9625 -> 9623;
9626 -> 9614;
9627 -> 9615;
9627 -> 9626;
9628 -> 9614;
9629 -> 9627;
9629 -> 9628;
9630 -> 9628;
9631 -> 9629;
9631 -> 9630;
9632 -> 9631;
9632 -> 9551;
9632 -> 9630;
9633 -> 9632;
9634 -> 9633;
9635 -> 9633;
9635 -> 9634;
9636 -> 0;
9636 -> 9634;
9637 -> 9636;
9637 -> 9633;
9638 -> 9633;
9638 -> 9632;
9639 -> 9631;
9639 -> 9551;
9639 -> 9632;
9640 -> 9631;
9640 -> 9551;
9640 -> 9632;
9641 -> 9632;
9642 -> 9641;
9642 -> 9640;
9642 -> 9632;
9643 -> 9638;
9643 -> 9642;
9644 -> 9631;
9644 -> 9642;
9645 -> 9641;
9645 -> 9642;
9646 -> 9639;
9646 -> 9641;
9646 -> 9642;
9647 -> 9642;
9648 -> 9642;
9649 -> 9643;
9649 -> 9648;
9650 -> 9644;
9650 -> 9648;
9651 -> 9645;
9651 -> 9648;
9652 -> 9646;
9652 -> 9648;
9653 -> 9647;
9653 -> 9648;
9654 -> 9649;
9654 -> 9648;
9655 -> 9650;
9655 -> 9648;
9656 -> 9651;
9656 -> 9648;
9657 -> 9652;
9657 -> 9648;
9658 -> 9648;
9659 -> 9654;
9659 -> 9658;
9660 -> 9655;
9660 -> 9658;
9661 -> 9656;
9661 -> 9658;
9662 -> 9657;
9662 -> 9658;
9663 -> 9653;
9663 -> 9658;
9664 -> 9658;
9665 -> 9663;
9665 -> 9664;
9666 -> 9664;
9667 -> 9665;
9667 -> 9664;
9668 -> 9663;
9668 -> 9658;
9669 -> 9663;
9669 -> 9658;
9670 -> 9663;
9670 -> 9658;
9671 -> 0;
9671 -> 9663;
9671 -> 9658;
9672 -> 9663;
9672 -> 9658;
9673 -> 9663;
9673 -> 9658;
9675 -> 9674;
9676 -> 9675;
9676 -> 9674;
9677 -> 9675;
9677 -> 9674;
9678 -> 9674;
9679 -> 9678;
9679 -> 9675;
9679 -> 9674;
9680 -> 9674;
9681 -> 9680;
9681 -> 9675;
9681 -> 9674;
9682 -> 9674;
9683 -> 9682;
9683 -> 9663;
9683 -> 9658;
9684 -> 9658;
9685 -> 9659;
9685 -> 9684;
9685 -> 9658;
9686 -> 9658;
9687 -> 9660;
9687 -> 9686;
9687 -> 9658;
9688 -> 9658;
9689 -> 9661;
9689 -> 9688;
9689 -> 9658;
9690 -> 9662;
9690 -> 9646;
9690 -> 9658;
9691 -> 9660;
9691 -> 9663;
9691 -> 9658;
9692 -> 9658;
9693 -> 9658;
9694 -> 9659;
9694 -> 9693;
9695 -> 9694;
9695 -> 9646;
9695 -> 9693;
9696 -> 9695;
9696 -> 9658;
9697 -> 9662;
9697 -> 9658;
9698 -> 9663;
9698 -> 9669;
9698 -> 9658;
9699 -> 9692;
9699 -> 9658;
9700 -> 9696;
9700 -> 9697;
9700 -> 9698;
9700 -> 9699;
9700 -> 9646;
9700 -> 9658;
9701 -> 9700;
9701 -> 0;
9701 -> 9658;
9702 -> 9658;
9703 -> 9701;
9703 -> 9658;
9704 -> 9703;
9704 -> 9663;
9704 -> 9658;
9705 -> 9661;
9705 -> 9663;
9705 -> 9658;
9706 -> 9662;
9706 -> 9663;
9706 -> 9658;
9707 -> 9647;
9707 -> 9641;
9707 -> 9640;
9707 -> 9642;
9708 -> 9631;
9708 -> 9700;
9708 -> 9632;
9709 -> 9640;
9709 -> 9632;
9710 -> 9709;
9710 -> 9640;
9710 -> 9707;
9710 -> 9665;
9710 -> 9667;
9710 -> 9691;
9710 -> 9700;
9710 -> 9705;
9710 -> 9671;
9710 -> 9704;
9710 -> 9673;
9710 -> 9683;
9710 -> 9706;
9710 -> 9679;
9710 -> 9681;
9710 -> 9646;
9710 -> 9632;
9711 -> 9628;
9712 -> 9629;
9712 -> 9710;
9712 -> 9628;
9714 -> 9713;
9715 -> 0;
9716 -> 9715;
9716 -> 0;
9717 -> 9716;
9719 -> 9718;
9720 -> 9717;
9720 -> 9718;
9721 -> 9720;
9721 -> 9719;
9722 -> 9719;
9723 -> 9722;
9724 -> 9722;
9724 -> 9719;
9725 -> 9721;
9725 -> 9722;
9725 -> 9719;
9726 -> 9717;
9726 -> 9718;
9727 -> 9718;
9728 -> 9616;
9728 -> 9614;
9729 -> 9614;
9730 -> 9625;
9730 -> 9729;
9731 -> 9712;
9731 -> 9729;
9732 -> 9728;
9732 -> 9729;
9733 -> 9729;
9734 -> 9730;
9734 -> 9729;
9735 -> 9729;
9736 -> 9734;
9736 -> 9735;
9737 -> 9736;
9737 -> 9735;
9738 -> 9735;
9739 -> 9737;
9739 -> 9738;
9739 -> 9735;
9740 -> 9739;
9740 -> 9735;
9741 -> 9740;
9741 -> 9726;
9742 -> 9741;
9742 -> 9733;
9743 -> 9733;
9744 -> 9743;
9745 -> 9743;
9745 -> 9733;
9746 -> 9742;
9746 -> 9743;
9746 -> 9733;
9747 -> 9729;
9748 -> 9747;
9748 -> 9731;
9748 -> 9710;
9748 -> 9729;
9749 -> 9731;
9749 -> 9747;
9749 -> 9710;
9749 -> 9748;
9750 -> 9732;
9750 -> 9747;
9750 -> 9551;
9750 -> 8790;
9750 -> 8791;
9750 -> 8792;
9750 -> 9612;
9750 -> 9749;
9750 -> 9748;
9751 -> 9749;
9751 -> 9748;
9752 -> 9748;
9753 -> 9751;
9753 -> 9752;
9754 -> 9750;
9754 -> 9752;
9756 -> 9755;
9758 -> 9757;
9760 -> 9759;
9761 -> 9754;
9761 -> 9750;
9761 -> 9752;
9762 -> 9752;
9763 -> 9761;
9763 -> 9762;
9764 -> 9763;
9764 -> 8726;
9764 -> 9762;
9765 -> 9754;
9765 -> 9750;
9765 -> 9753;
9765 -> 9752;
9766 -> 9764;
9766 -> 9765;
9766 -> 9752;
9767 -> 9749;
9767 -> 9766;
9768 -> 9750;
9768 -> 9766;
9769 -> 9733;
9769 -> 9746;
9769 -> 9767;
9769 -> 9768;
9769 -> 9741;
9769 -> 9750;
9769 -> 9766;
9770 -> 9614;
9771 -> 9615;
9771 -> 9770;
9772 -> 0;
9773 -> 9615;
9773 -> 9614;
9774 -> 9617;
9774 -> 9614;
9775 -> 9618;
9775 -> 9614;
9776 -> 9614;
9777 -> 9622;
9777 -> 9776;
9778 -> 9729;
9778 -> 9776;
9779 -> 9771;
9779 -> 9776;
9780 -> 9773;
9780 -> 9776;
9781 -> 9774;
9781 -> 9776;
9782 -> 9775;
9782 -> 9776;
9783 -> 9619;
9783 -> 9776;
9784 -> 9779;
9784 -> 9776;
9785 -> 9782;
9785 -> 9776;
9786 -> 9776;
9787 -> 9784;
9787 -> 9786;
9788 -> 9785;
9788 -> 9786;
9789 -> 9783;
9789 -> 9786;
9790 -> 9788;
9790 -> 9786;
9791 -> 9786;
9792 -> 9790;
9792 -> 9791;
9793 -> 9789;
9793 -> 9791;
9794 -> 9789;
9794 -> 9786;
9795 -> 9786;
9796 -> 9787;
9796 -> 9795;
9796 -> 9786;
9797 -> 9787;
9797 -> 9789;
9797 -> 9786;
9798 -> 9783;
9798 -> 9776;
9799 -> 9783;
9799 -> 9776;
9800 -> 9783;
9800 -> 9776;
9801 -> 9783;
9801 -> 9776;
9802 -> 9783;
9802 -> 9776;
9803 -> 9783;
9803 -> 9776;
9804 -> 9776;
9805 -> 9779;
9805 -> 9804;
9806 -> 9804;
9807 -> 9805;
9807 -> 9806;
9808 -> 9806;
9809 -> 9807;
9809 -> 9808;
9810 -> 9808;
9811 -> 9809;
9811 -> 9810;
9812 -> 9810;
9813 -> 9811;
9813 -> 9812;
9814 -> 9813;
9814 -> 9810;
9815 -> 9814;
9815 -> 9808;
9816 -> 9815;
9816 -> 9806;
9817 -> 9816;
9817 -> 9804;
9818 -> 9817;
9818 -> 9776;
9819 -> 9779;
9819 -> 9776;
9820 -> 9776;
9821 -> 9819;
9821 -> 9820;
9822 -> 9820;
9823 -> 9821;
9823 -> 9822;
9823 -> 9820;
9824 -> 9821;
9824 -> 9820;
9825 -> 9820;
9825 -> 9776;
9826 -> 9777;
9826 -> 9783;
9826 -> 9776;
9827 -> 9778;
9827 -> 9783;
9827 -> 9776;
9828 -> 9781;
9828 -> 9783;
9828 -> 9776;
9829 -> 9776;
9830 -> 9780;
9830 -> 9829;
9830 -> 9776;
9831 -> 9830;
9832 -> 9780;
9832 -> 9831;
9833 -> 9832;
9833 -> 9831;
9834 -> 9833;
9834 -> 9830;
9835 -> 9780;
9835 -> 9830;
9836 -> 9830;
9837 -> 9780;
9837 -> 9836;
9838 -> 9836;
9839 -> 9837;
9839 -> 9838;
9840 -> 9839;
9840 -> 9769;
9840 -> 9838;
9841 -> 9836;
9842 -> 9837;
9842 -> 9769;
9842 -> 9836;
9843 -> 9842;
9843 -> 9830;
9844 -> 9843;
9844 -> 9783;
9844 -> 9830;
9845 -> 9778;
9845 -> 9783;
9845 -> 9830;
9846 -> 9619;
9846 -> 9614;
9847 -> 9616;
9847 -> 9619;
9847 -> 9614;
9848 -> 9615;
9848 -> 9619;
9848 -> 9614;
9849 -> 9614;
9850 -> 9615;
9850 -> 9849;
9851 -> 9850;
9851 -> 9769;
9851 -> 9849;
9852 -> 9851;
9852 -> 9614;
9853 -> 9614;
9854 -> 9615;
9854 -> 9853;
9855 -> 9854;
9855 -> 9769;
9855 -> 9853;
9856 -> 9855;
9856 -> 9614;
9857 -> 9614;
9858 -> 9203;
9858 -> 9613;
9858 -> 9789;
9858 -> 9792;
9858 -> 9797;
9858 -> 9828;
9858 -> 9827;
9858 -> 9826;
9858 -> 9845;
9858 -> 9802;
9858 -> 9803;
9858 -> 9844;
9858 -> 9848;
9858 -> 9847;
9858 -> 9769;
9858 -> 9746;
9858 -> 9551;
9858 -> 8790;
9858 -> 8791;
9858 -> 8792;
9858 -> 9612;
9858 -> 9609;
9859 -> 0;
9859 -> 9200;
9860 -> 9200;
9861 -> 9859;
9861 -> 9860;
9862 -> 9202;
9862 -> 9860;
9863 -> 9862;
9863 -> 9858;
9863 -> 9860;
9864 -> 9860;
9865 -> 9863;
9865 -> 9864;
9866 -> 9865;
9866 -> 9860;
9867 -> 9866;
9868 -> 9866;
9868 -> 9867;
9869 -> 9867;
9870 -> 9868;
9870 -> 9869;
9871 -> 9869;
9872 -> 9870;
9872 -> 9858;
9872 -> 9871;
9872 -> 9869;
9873 -> 9867;
9874 -> 9868;
9874 -> 9858;
9874 -> 9867;
9875 -> 9874;
9875 -> 9866;
9876 -> 9866;
9877 -> 9863;
9877 -> 9858;
9877 -> 9861;
9877 -> 9860;
9878 -> 9863;
9878 -> 9858;
9878 -> 9861;
9878 -> 9860;
9879 -> 9878;
9879 -> 9200;
9880 -> 9200;
9881 -> 9879;
9881 -> 9880;
9882 -> 9880;
9883 -> 9881;
9883 -> 9882;
9883 -> 9880;
9884 -> 9880;
9885 -> 9881;
9885 -> 9884;
9886 -> 9884;
9886 -> 9880;
9887 -> 9886;
9887 -> 9200;
9888 -> 9878;
9888 -> 9887;
9889 -> 9201;
9889 -> 9887;
9890 -> 9889;
9890 -> 8790;
9890 -> 8791;
9890 -> 8792;
9890 -> 9858;
9890 -> 9887;
9891 -> 9887;
9892 -> 9887;
9893 -> 9888;
9893 -> 9892;
9894 -> 9890;
9894 -> 9892;
9895 -> 9891;
9895 -> 9892;
9896 -> 9891;
9896 -> 9892;
9897 -> 9891;
9897 -> 9892;
9898 -> 9892;
9899 -> 9892;
9900 -> 9892;
9901 -> 9892;
9902 -> 9901;
9903 -> 9893;
9904 -> 9893;
9904 -> 9903;
9905 -> 0;
9905 -> 9903;
9906 -> 9905;
9906 -> 9893;
9907 -> 9893;
9908 -> 9893;
9909 -> 9893;
9910 -> 9893;
9911 -> 9893;
9912 -> 9893;
9913 -> 9893;
9914 -> 9901;
9915 -> 9892;
9916 -> 9915;
9917 -> 9915;
9918 -> 9917;
9919 -> 9916;
9920 -> 9919;
9921 -> 9919;
9921 -> 9916;
9922 -> 9915;
9923 -> 9892;
9924 -> 9895;
9924 -> 9892;
9925 -> 9896;
9925 -> 9892;
9926 -> 9892;
9927 -> 9915;
9927 -> 9926;
9928 -> 9924;
9928 -> 9926;
9929 -> 9925;
9929 -> 9926;
9930 -> 9897;
9930 -> 9926;
9931 -> 9929;
9931 -> 9926;
9932 -> 9926;
9933 -> 9931;
9933 -> 9932;
9934 -> 9930;
9934 -> 9932;
9935 -> 9933;
9935 -> 9932;
9936 -> 9932;
9937 -> 9935;
9937 -> 9936;
9938 -> 9934;
9938 -> 9936;
9939 -> 9934;
9939 -> 9932;
9940 -> 9932;
9941 -> 9893;
9941 -> 9940;
9941 -> 9932;
9942 -> 9930;
9942 -> 9926;
9943 -> 9930;
9943 -> 9926;
9944 -> 9930;
9944 -> 9926;
9945 -> 9930;
9945 -> 9926;
9946 -> 9930;
9946 -> 9926;
9947 -> 9930;
9947 -> 9926;
9948 -> 9926;
9949 -> 9893;
9949 -> 9948;
9950 -> 9948;
9951 -> 9949;
9951 -> 9950;
9952 -> 9950;
9953 -> 9951;
9953 -> 9952;
9954 -> 9952;
9955 -> 9953;
9955 -> 9954;
9956 -> 9954;
9957 -> 9955;
9957 -> 9956;
9958 -> 9957;
9958 -> 9954;
9959 -> 9958;
9959 -> 9952;
9960 -> 9959;
9960 -> 9950;
9961 -> 9960;
9961 -> 9948;
9962 -> 9961;
9962 -> 9926;
9963 -> 9893;
9963 -> 9926;
9964 -> 9926;
9965 -> 9963;
9965 -> 9964;
9966 -> 9964;
9967 -> 9965;
9967 -> 9966;
9967 -> 9964;
9968 -> 9965;
9968 -> 9964;
9969 -> 9964;
9969 -> 9926;
9970 -> 9927;
9970 -> 9930;
9970 -> 9926;
9971 -> 9928;
9971 -> 9930;
9971 -> 9926;
9972 -> 9926;
9973 -> 9893;
9974 -> 9893;
9974 -> 9973;
9975 -> 9974;
9975 -> 9973;
9976 -> 9975;
9976 -> 9893;
9977 -> 9893;
9978 -> 9893;
9979 -> 9897;
9979 -> 9892;
9980 -> 9892;
9981 -> 9893;
9981 -> 9980;
9982 -> 9981;
9982 -> 9892;
9983 -> 9892;
9984 -> 9893;
9984 -> 9983;
9985 -> 9984;
9985 -> 9892;
9986 -> 9892;
9987 -> 9203;
9987 -> 9893;
9987 -> 9200;
9988 -> 9176;
9989 -> 9179;
9989 -> 9988;
9990 -> 9198;
9990 -> 9988;
9991 -> 9987;
9991 -> 9988;
9992 -> 9989;
9992 -> 9988;
9993 -> 9990;
9993 -> 9988;
9994 -> 9991;
9994 -> 9988;
9995 -> 9988;
9996 -> 9988;
9997 -> 9992;
9997 -> 9996;
9998 -> 9993;
9998 -> 9996;
9999 -> 9994;
9999 -> 9996;
10000 -> 9995;
10000 -> 9996;
10001 -> 9997;
10001 -> 9996;
10002 -> 9998;
10002 -> 9996;
10003 -> 9996;
10004 -> 10001;
10004 -> 10003;
10005 -> 10002;
10005 -> 10003;
10006 -> 10000;
10006 -> 10003;
10007 -> 10003;
10008 -> 10006;
10008 -> 10003;
10009 -> 10006;
10009 -> 10003;
10010 -> 10003;
10011 -> 10004;
10011 -> 10010;
10012 -> 10011;
10012 -> 8790;
10012 -> 10010;
10013 -> 10012;
10013 -> 10010;
10014 -> 10013;
10014 -> 10003;
10015 -> 10003;
10016 -> 10005;
10016 -> 10015;
10016 -> 10003;
10017 -> 10004;
10017 -> 10006;
10017 -> 10003;
10018 -> 10005;
10018 -> 10006;
10018 -> 10003;
10019 -> 9996;
10020 -> 9999;
10020 -> 9987;
10020 -> 10019;
10020 -> 9996;
10021 -> 9999;
10021 -> 10000;
10021 -> 9996;
10022 -> 9995;
10022 -> 9176;
10023 -> 10022;
10023 -> 9173;
10024 -> 9155;
10024 -> 9893;
10024 -> 9154;
10025 -> 9154;
10026 -> 10024;
10026 -> 10025;
10027 -> 10023;
10027 -> 9154;
10028 -> 9154;
10029 -> 9154;
10030 -> 10026;
10030 -> 10029;
10031 -> 10027;
10031 -> 10029;
10032 -> 10028;
10032 -> 10029;
10033 -> 10031;
10033 -> 10029;
10034 -> 10031;
10034 -> 10029;
10035 -> 10030;
10035 -> 0;
10035 -> 10029;
10036 -> 10030;
10036 -> 10029;
10037 -> 10031;
10037 -> 10036;
10038 -> 10036;
10039 -> 10037;
10039 -> 10038;
10040 -> 10038;
10041 -> 10039;
10041 -> 10040;
10042 -> 10040;
10043 -> 10041;
10043 -> 10042;
10044 -> 10043;
10044 -> 10042;
10045 -> 10044;
10045 -> 10040;
10046 -> 10045;
10046 -> 10038;
10047 -> 10038;
10048 -> 10046;
10048 -> 10047;
10049 -> 0;
10049 -> 10047;
10050 -> 10049;
10050 -> 10038;
10051 -> 10050;
10051 -> 10036;
10052 -> 10037;
10052 -> 10051;
10052 -> 10036;
10053 -> 10031;
10053 -> 10029;
10054 -> 10053;
10054 -> 10029;
10055 -> 10031;
10055 -> 10054;
10056 -> 10054;
10057 -> 10055;
10057 -> 10056;
10058 -> 10056;
10059 -> 10057;
10059 -> 10058;
10060 -> 10058;
10061 -> 10059;
10061 -> 10060;
10062 -> 10061;
10062 -> 10060;
10063 -> 10062;
10063 -> 10058;
10064 -> 10063;
10064 -> 10056;
10065 -> 10056;
10066 -> 10064;
10066 -> 10065;
10067 -> 0;
10067 -> 10065;
10068 -> 10067;
10068 -> 10056;
10069 -> 10068;
10069 -> 10054;
10070 -> 10030;
10070 -> 0;
10070 -> 10029;
10071 -> 10029;
10072 -> 10069;
10072 -> 10071;
10072 -> 10029;
10073 -> 10029;
10074 -> 10029;
10074 -> 9154;
10075 -> 10074;
10075 -> 6501;
10076 -> 6501;
10077 -> 6501;
10078 -> 10076;
10078 -> 10077;
10079 -> 10077;
10080 -> 10075;
10080 -> 10079;
10081 -> 10080;
10081 -> 10031;
10081 -> 10079;
10082 -> 10081;
10082 -> 10079;
10083 -> 10082;
10083 -> 10077;
10084 -> 10077;
10085 -> 10084;
10085 -> 10078;
10085 -> 10077;
10086 -> 10077;
10087 -> 10086;
10087 -> 10078;
10087 -> 10077;
10088 -> 10076;
10088 -> 6496;
10089 -> 6476;
10090 -> 10088;
10090 -> 10089;
10091 -> 10089;
10092 -> 10075;
10092 -> 10031;
10092 -> 10091;
10093 -> 10092;
10094 -> 10092;
10095 -> 10092;
10096 -> 10093;
10096 -> 10092;
10097 -> 10094;
10097 -> 10092;
10098 -> 10095;
10098 -> 10092;
10099 -> 10096;
10099 -> 10092;
10100 -> 10097;
10100 -> 10092;
10101 -> 10098;
10101 -> 10092;
10102 -> 10092;
10102 -> 10029;
10103 -> 10099;
10103 -> 10092;
10104 -> 10100;
10104 -> 10092;
10105 -> 10101;
10105 -> 10092;
10106 -> 10103;
10106 -> 10092;
10107 -> 10104;
10107 -> 10092;
10108 -> 10105;
10108 -> 10092;
10109 -> 10092;
10109 -> 10029;
10110 -> 10108;
10110 -> 10092;
10111 -> 10107;
10111 -> 10092;
10112 -> 10092;
10113 -> 10106;
10113 -> 10092;
10114 -> 10110;
10114 -> 10092;
10115 -> 10111;
10115 -> 10092;
10116 -> 10112;
10116 -> 10092;
10117 -> 10113;
10117 -> 10092;
10118 -> 10092;
10119 -> 0;
10119 -> 10092;
10120 -> 10092;
10121 -> 6468;
10121 -> 6466;
10122 -> 6467;
10122 -> 6466;
10123 -> 6469;
10123 -> 6466;
10124 -> 6466;
10125 -> 10121;
10125 -> 10124;
10126 -> 10122;
10126 -> 10124;
10127 -> 10123;
10127 -> 10124;
10128 -> 6471;
10128 -> 10124;
10129 -> 10124;
10130 -> 10092;
10130 -> 10129;
10131 -> 10130;
10131 -> 10085;
10131 -> 10129;
10132 -> 10131;
10132 -> 0;
10132 -> 10129;
10133 -> 10132;
10133 -> 10124;
10134 -> 6466;
10135 -> 6228;
10136 -> 6189;
10136 -> 10135;
10137 -> 10135;
10138 -> 10136;
10138 -> 10137;
10139 -> 10138;
10139 -> 10026;
10139 -> 10137;
10140 -> 10139;
10140 -> 0;
10140 -> 10135;
10141 -> 10135;
10142 -> 10140;
10142 -> 10141;
10142 -> 10135;
10143 -> 10142;
10143 -> 6228;
10144 -> 6189;
10144 -> 10026;
10144 -> 6187;
10145 -> 6187;
10146 -> 6189;
10146 -> 10145;
10147 -> 10145;
10148 -> 10146;
10148 -> 10147;
10149 -> 10147;
10150 -> 10148;
10150 -> 10149;
10151 -> 10150;
10151 -> 10026;
10151 -> 10149;
10152 -> 10151;
10152 -> 0;
10152 -> 10147;
10153 -> 10147;
10154 -> 10152;
10154 -> 10153;
10154 -> 10147;
10155 -> 10154;
10155 -> 10145;
10156 -> 0;
10156 -> 10155;
10157 -> 10156;
10157 -> 6187;
10158 -> 6187;
10159 -> 10157;
10159 -> 10158;
10160 -> 10092;
10160 -> 10158;
10161 -> 10160;
10161 -> 10158;
10162 -> 10159;
10162 -> 10158;
10163 -> 10158;
10164 -> 10161;
10164 -> 10163;
10165 -> 10162;
10165 -> 10163;
10166 -> 10160;
10166 -> 10029;
10166 -> 10163;
10167 -> 10164;
10167 -> 10031;
10167 -> 10163;
10168 -> 10164;
10168 -> 10030;
10168 -> 10163;
10169 -> 10165;
10169 -> 10163;
10170 -> 10163;
10171 -> 10167;
10171 -> 10170;
10172 -> 10168;
10172 -> 10170;
10173 -> 10169;
10173 -> 10170;
10174 -> 10170;
10175 -> 10170;
10176 -> 10170;
10177 -> 10175;
10177 -> 10176;
10178 -> 10171;
10178 -> 10176;
10179 -> 10178;
10179 -> 10176;
10180 -> 10171;
10180 -> 10179;
10181 -> 10179;
10182 -> 10180;
10182 -> 10181;
10183 -> 10181;
10184 -> 10182;
10184 -> 10183;
10185 -> 10183;
10186 -> 10184;
10186 -> 10185;
10187 -> 10186;
10187 -> 10185;
10188 -> 10187;
10188 -> 10183;
10189 -> 10188;
10189 -> 10181;
10190 -> 10181;
10191 -> 10189;
10191 -> 10190;
10192 -> 0;
10192 -> 10190;
10193 -> 10192;
10193 -> 10181;
10194 -> 10193;
10194 -> 10179;
10195 -> 10172;
10195 -> 0;
10195 -> 10176;
10196 -> 10176;
10197 -> 10194;
10197 -> 10196;
10197 -> 10176;
10198 -> 10176;
10199 -> 10173;
10199 -> 10198;
10199 -> 10176;
10200 -> 10175;
10200 -> 10163;
10201 -> 10200;
10201 -> 6187;
10204 -> 10202;
10204 -> 10203;
10205 -> 10203;
10206 -> 10204;
10206 -> 10205;
10206 -> 10203;
10207 -> 10203;
10208 -> 6187;
10209 -> 6187;
10210 -> 10201;
10210 -> 10209;
10211 -> 10208;
10211 -> 10209;
10212 -> 10210;
10212 -> 10211;
10212 -> 10209;
10213 -> 10144;
10213 -> 10208;
10213 -> 10212;
10213 -> 10026;
10213 -> 10171;
10213 -> 10172;
10213 -> 10173;
10213 -> 10006;
10213 -> 10008;
10213 -> 10018;
10213 -> 10017;
10213 -> 10021;
10213 -> 8790;
10213 -> 8791;
10213 -> 8792;
10213 -> 9987;
10213 -> 6187;
10214 -> 10213;
10215 -> 10214;
10215 -> 10029;
10216 -> 10214;
10216 -> 10213;
10217 -> 6219;
10217 -> 10213;
10218 -> 10213;
10219 -> 10216;
10219 -> 10218;
10220 -> 10217;
10220 -> 10218;
10221 -> 6189;
10221 -> 10218;
10222 -> 10218;
10223 -> 10219;
10223 -> 10222;
10224 -> 10222;
10225 -> 10224;
10225 -> 10218;
10226 -> 10219;
10226 -> 10225;
10227 -> 10225;
10228 -> 10226;
10228 -> 10227;
10229 -> 10227;
10230 -> 10228;
10230 -> 10229;
10231 -> 0;
10231 -> 10229;
10232 -> 10231;
10232 -> 10227;
10233 -> 10232;
10233 -> 10225;
10234 -> 10219;
10234 -> 10233;
10235 -> 10233;
10236 -> 10233;
10237 -> 10234;
10237 -> 10236;
10238 -> 10235;
10238 -> 10236;
10239 -> 10236;
10240 -> 10237;
10240 -> 10239;
10240 -> 10236;
10241 -> 10236;
10242 -> 10237;
10242 -> 10241;
10243 -> 10241;
10243 -> 10236;
10244 -> 10238;
10244 -> 10236;
10245 -> 10244;
10246 -> 10245;
10247 -> 10219;
10247 -> 10246;
10248 -> 10246;
10249 -> 10248;
10249 -> 10245;
10250 -> 10249;
10251 -> 10221;
10251 -> 10250;
10252 -> 10250;
10253 -> 10251;
10253 -> 10252;
10254 -> 10253;
10254 -> 0;
10254 -> 10250;
10255 -> 10250;
10256 -> 10254;
10256 -> 10255;
10256 -> 10250;
10257 -> 10256;
10257 -> 10249;
10258 -> 10257;
10259 -> 10258;
10259 -> 10257;
10260 -> 10218;
10261 -> 10221;
10261 -> 10218;
10262 -> 10219;
10262 -> 10218;
10263 -> 10260;
10263 -> 10218;
10264 -> 10218;
10265 -> 10261;
10265 -> 10264;
10266 -> 10262;
10266 -> 10264;
10267 -> 10263;
10267 -> 10264;
10268 -> 10266;
10268 -> 10264;
10269 -> 10265;
10269 -> 10264;
10270 -> 10267;
10270 -> 10264;
10271 -> 10264;
10272 -> 10268;
10272 -> 10271;
10273 -> 10269;
10273 -> 10271;
10274 -> 10270;
10274 -> 10271;
10275 -> 10274;
10275 -> 10271;
10276 -> 10272;
10276 -> 10271;
10277 -> 10275;
10277 -> 10271;
10278 -> 10273;
10278 -> 10271;
10279 -> 10271;
10280 -> 10271;
10281 -> 10276;
10281 -> 10280;
10282 -> 10277;
10282 -> 10280;
10283 -> 10278;
10283 -> 10280;
10284 -> 10279;
10284 -> 10280;
10285 -> 10280;
10286 -> 10281;
10286 -> 10280;
10287 -> 10282;
10287 -> 10280;
10288 -> 10283;
10288 -> 10280;
10289 -> 10284;
10289 -> 10280;
10290 -> 10280;
10291 -> 10285;
10291 -> 10290;
10292 -> 10286;
10292 -> 10290;
10293 -> 10285;
10293 -> 10290;
10294 -> 10287;
10294 -> 10290;
10295 -> 10288;
10295 -> 10290;
10296 -> 10289;
10296 -> 10290;
10297 -> 10285;
10297 -> 10290;
10298 -> 10290;
10299 -> 10291;
10299 -> 10298;
10300 -> 10299;
10300 -> 10285;
10300 -> 10298;
10301 -> 10300;
10301 -> 10298;
10302 -> 10301;
10302 -> 10290;
10303 -> 10292;
10303 -> 10290;
10304 -> 10302;
10304 -> 10303;
10304 -> 10290;
10305 -> 10290;
10306 -> 10296;
10306 -> 10305;
10306 -> 10290;
10307 -> 10297;
10307 -> 10305;
10307 -> 10290;
10308 -> 10306;
10308 -> 10307;
10308 -> 10290;
10309 -> 10290;
10310 -> 10292;
10310 -> 10309;
10311 -> 10309;
10312 -> 10309;
10313 -> 10310;
10313 -> 10312;
10314 -> 0;
10314 -> 10312;
10315 -> 10314;
10315 -> 10309;
10316 -> 10309;
10317 -> 10291;
10317 -> 10316;
10318 -> 10317;
10318 -> 10285;
10318 -> 10316;
10319 -> 10318;
10319 -> 10316;
10320 -> 10319;
10320 -> 10309;
10321 -> 10320;
10322 -> 10294;
10322 -> 10321;
10322 -> 10320;
10323 -> 10310;
10323 -> 10322;
10324 -> 10295;
10324 -> 10322;
10325 -> 10311;
10325 -> 10322;
10326 -> 10323;
10326 -> 10324;
10326 -> 10325;
10326 -> 10294;
10326 -> 10213;
10326 -> 10277;
10326 -> 10322;
10327 -> 10322;
10328 -> 10326;
10328 -> 10327;
10329 -> 10326;
10329 -> 10327;
10330 -> 10326;
10330 -> 10327;
10331 -> 10327;
10332 -> 10328;
10332 -> 10331;
10333 -> 0;
10333 -> 10331;
10334 -> 10333;
10334 -> 10327;
10335 -> 10334;
10336 -> 10330;
10336 -> 10335;
10336 -> 10326;
10336 -> 10322;
10337 -> 10309;
10338 -> 10337;
10338 -> 10309;
10339 -> 10309;
10340 -> 10310;
10340 -> 10339;
10341 -> 0;
10341 -> 10339;
10342 -> 10341;
10342 -> 10309;
10343 -> 10342;
10344 -> 10310;
10344 -> 10343;
10345 -> 10344;
10345 -> 10336;
10345 -> 10343;
10346 -> 10345;
10346 -> 10342;
10347 -> 10296;
10347 -> 10309;
10348 -> 10347;
10349 -> 10296;
10349 -> 10309;
10350 -> 10349;
10351 -> 10346;
10351 -> 10350;
10352 -> 10351;
10352 -> 10336;
10352 -> 10350;
10353 -> 10350;
10354 -> 10352;
10354 -> 10353;
10355 -> 10351;
10355 -> 10336;
10355 -> 10353;
10356 -> 10354;
10356 -> 10353;
10357 -> 10353;
10358 -> 10356;
10358 -> 10357;
10359 -> 10358;
10359 -> 10357;
10360 -> 10357;
10361 -> 10359;
10361 -> 10360;
10362 -> 10360;
10363 -> 10361;
10363 -> 10362;
10364 -> 10362;
10365 -> 10363;
10365 -> 10364;
10366 -> 10364;
10367 -> 10365;
10367 -> 10366;
10368 -> 10367;
10368 -> 10364;
10369 -> 10368;
10369 -> 10362;
10370 -> 10369;
10370 -> 10360;
10371 -> 10360;
10372 -> 10370;
10372 -> 10371;
10373 -> 10372;
10373 -> 10349;
10374 -> 10373;
10374 -> 10312;
10375 -> 10374;
10375 -> 10309;
10376 -> 10375;
10377 -> 10376;
10377 -> 10375;
10378 -> 10375;
10379 -> 10377;
10379 -> 10378;
10379 -> 10375;
10380 -> 10348;
10380 -> 10316;
10381 -> 10380;
10381 -> 10348;
10381 -> 10316;
10382 -> 10381;
10382 -> 10316;
10383 -> 10382;
10383 -> 10309;
10384 -> 10383;
10385 -> 10294;
10385 -> 10384;
10385 -> 10383;
10386 -> 10373;
10386 -> 10385;
10387 -> 10295;
10387 -> 10385;
10388 -> 10311;
10388 -> 10385;
10389 -> 10385;
10390 -> 10386;
10390 -> 10389;
10391 -> 10386;
10391 -> 10389;
10392 -> 10389;
10393 -> 10390;
10394 -> 10391;
10394 -> 10390;
10395 -> 10386;
10395 -> 10390;
10396 -> 10390;
10397 -> 10393;
10397 -> 10396;
10398 -> 10394;
10398 -> 10396;
10399 -> 10395;
10399 -> 10396;
10400 -> 10396;
10401 -> 10397;
10401 -> 10400;
10402 -> 0;
10402 -> 10400;
10403 -> 10401;
10403 -> 10396;
10404 -> 10403;
10404 -> 0;
10404 -> 10396;
10405 -> 10404;
10406 -> 10399;
10406 -> 10405;
10406 -> 10386;
10406 -> 10385;
10407 -> 10406;
10408 -> 10373;
10408 -> 10407;
10409 -> 0;
10409 -> 10407;
10410 -> 10409;
10410 -> 10406;
10411 -> 10410;
10411 -> 0;
10411 -> 10406;
10412 -> 10411;
10413 -> 10275;
10413 -> 10271;
10414 -> 10412;
10414 -> 10271;
10415 -> 10220;
10415 -> 10218;
10416 -> 10218;
10417 -> 10221;
10417 -> 10416;
10418 -> 10417;
10418 -> 10406;
10418 -> 10416;
10419 -> 10418;
10419 -> 10218;
10420 -> 10413;
10420 -> 10218;
10421 -> 10415;
10421 -> 10419;
10421 -> 10420;
10421 -> 6219;
10421 -> 10406;
10421 -> 10218;
10422 -> 10213;
10423 -> 10213;
10424 -> 10423;
10424 -> 10421;
10425 -> 10423;
10425 -> 10421;
10426 -> 10423;
10426 -> 10421;
10427 -> 10426;
10427 -> 10213;
10428 -> 6219;
10428 -> 10213;
10429 -> 10213;
10430 -> 6205;
10430 -> 10427;
10430 -> 10429;
10430 -> 10213;
10431 -> 10430;
10431 -> 10213;
10432 -> 10431;
10433 -> 10432;
10433 -> 10430;
10434 -> 10432;
10434 -> 10431;
10435 -> 6222;
10435 -> 10431;
10436 -> 0;
10436 -> 10213;
10437 -> 10213;
10438 -> 10436;
10438 -> 10437;
10439 -> 6189;
10439 -> 10434;
10439 -> 10437;
10440 -> 10439;
10440 -> 10438;
10440 -> 10437;
10441 -> 6219;
10441 -> 10434;
10441 -> 10440;
10441 -> 6187;
10442 -> 6222;
10442 -> 10441;
10442 -> 6187;
10443 -> 6189;
10443 -> 10442;
10443 -> 6187;
10444 -> 10443;
10444 -> 6184;
10445 -> 6182;
10446 -> 10444;
10446 -> 10445;
10447 -> 10445;
10448 -> 10446;
10448 -> 10442;
10448 -> 10447;
10449 -> 0;
10449 -> 1;
10450 -> 1;
10451 -> 10446;
10451 -> 10450;
10452 -> 0;
10452 -> 10450;
10453 -> 10452;
10453 -> 1;
10454 -> 1;
10455 -> 10446;
10455 -> 10454;
10456 -> 10454;
10457 -> 10455;
10457 -> 10454;
10458 -> 10454;
10459 -> 10457;
10459 -> 10458;
10460 -> 0;
10460 -> 10458;
10461 -> 10460;
10461 -> 10454;
10462 -> 10457;
10462 -> 10461;
10463 -> 10461;
10464 -> 10462;
10464 -> 10463;
10465 -> 10463;
10466 -> 10465;
10466 -> 10461;
10467 -> 10456;
10467 -> 10461;
10468 -> 10466;
10468 -> 10467;
10468 -> 10461;
10469 -> 10461;
10470 -> 10462;
10470 -> 10469;
10471 -> 10469;
10472 -> 10470;
10472 -> 10442;
10472 -> 10471;
10473 -> 10471;
10474 -> 10472;
10474 -> 10442;
10474 -> 10473;
10475 -> 10472;
10475 -> 10469;
10476 -> 10475;
10476 -> 10461;
10477 -> 10476;
10477 -> 10454;
10478 -> 10468;
10478 -> 10454;
10479 -> 10477;
10479 -> 10478;
10479 -> 10442;
10479 -> 10454;
10480 -> 10454;
10481 -> 10480;
10482 -> 10480;
10483 -> 10479;
10483 -> 1;
10484 -> 1;
10485 -> 10446;
10485 -> 10484;
10486 -> 10484;
10487 -> 10485;
10487 -> 10484;
10488 -> 10484;
10489 -> 10487;
10489 -> 10488;
10490 -> 0;
10490 -> 10488;
10491 -> 10490;
10491 -> 10484;
10492 -> 10487;
10492 -> 10491;
10493 -> 10491;
10494 -> 10492;
10494 -> 10493;
10495 -> 10493;
10496 -> 10495;
10496 -> 10491;
10497 -> 10486;
10497 -> 10491;
10498 -> 10496;
10498 -> 10497;
10498 -> 10491;
10499 -> 10491;
10500 -> 10492;
10500 -> 10499;
10501 -> 10499;
10502 -> 10500;
10502 -> 10479;
10502 -> 10501;
10503 -> 10501;
10504 -> 10502;
10504 -> 10479;
10504 -> 10503;
10505 -> 10498;
10505 -> 10484;
10506 -> 10484;
10507 -> 10506;
10508 -> 10506;
10509 -> 10502;
10509 -> 1;
10510 -> 10483;
10510 -> 1;
10511 -> 10509;
10511 -> 1;
10512 -> 10510;
10512 -> 10511;
10512 -> 1;
10513 -> 1;
10514 -> 1;
10515 -> 10513;
10515 -> 10514;
10516 -> 3616;
10516 -> 10514;
10517 -> 10514;
10518 -> 10517;
10518 -> 10514;
10519 -> 10514;
10520 -> 10516;
10520 -> 10519;
10521 -> 0;
10521 -> 10519;
10522 -> 10519;
10523 -> 10521;
10523 -> 10522;
10524 -> 10520;
10524 -> 10502;
10524 -> 10522;
10525 -> 10524;
10525 -> 10502;
10525 -> 10523;
10525 -> 10522;
10526 -> 10520;
10526 -> 10502;
10526 -> 10525;
10527 -> 10526;
10527 -> 10514;
10528 -> 10515;
10528 -> 10514;
10529 -> 10517;
10529 -> 10514;
10530 -> 10527;
10530 -> 10528;
10530 -> 10529;
10530 -> 10502;
10530 -> 10518;
10530 -> 10514;
10531 -> 10530;
10532 -> 1;
10533 -> 10531;
10533 -> 10532;
10534 -> 10532;
10535 -> 0;
10535 -> 10534;
10536 -> 10534;
10537 -> 10535;
10537 -> 10536;
10538 -> 10536;
10539 -> 10537;
10539 -> 10538;
10539 -> 10536;
10540 -> 10536;
10541 -> 10533;
10541 -> 10531;
10541 -> 10540;
10541 -> 10536;
10542 -> 10536;
10543 -> 10542;
10544 -> 10543;
10545 -> 10536;
10546 -> 10536;
10547 -> 10546;
10548 -> 10533;
10548 -> 10547;
10549 -> 0;
10549 -> 10547;
10550 -> 10549;
10550 -> 10546;
10551 -> 10546;
10552 -> 10551;
10553 -> 10551;
10554 -> 10546;
10555 -> 10536;
10556 -> 10536;
10557 -> 10556;
10557 -> 10536;
10558 -> 10536;
10559 -> 10536;
10560 -> 10533;
10560 -> 10559;
10561 -> 10559;
10562 -> 10561;
10562 -> 10536;
10563 -> 10536;
10564 -> 10562;
10564 -> 10563;
10564 -> 10536;
10565 -> 10564;
10566 -> 10564;
10567 -> 10564;
10568 -> 10566;
10568 -> 10567;
10569 -> 10568;
10569 -> 10567;
10570 -> 10567;
10571 -> 10567;
10572 -> 10570;
10572 -> 10571;
10573 -> 10572;
10573 -> 10571;
10574 -> 10571;
10575 -> 10574;
10576 -> 10575;
10577 -> 10571;
10578 -> 10571;
10579 -> 10571;
10580 -> 10578;
10580 -> 10571;
10581 -> 10533;
10582 -> 10564;
10583 -> 10564;
10584 -> 10582;
10584 -> 10583;
10585 -> 10582;
10585 -> 10583;
10586 -> 10583;
10587 -> 10583;
10588 -> 10584;
10588 -> 10583;
10589 -> 10585;
10589 -> 10583;
10590 -> 10583;
10591 -> 10588;
10591 -> 10590;
10592 -> 10589;
10592 -> 10590;
10593 -> 10590;
10594 -> 10581;
10594 -> 10593;
10594 -> 10590;
10595 -> 10592;
10595 -> 10590;
10596 -> 10591;
10596 -> 10590;
10597 -> 10592;
10597 -> 10590;
10598 -> 10590;
10599 -> 10596;
10599 -> 10598;
10600 -> 10597;
10600 -> 10598;
10601 -> 10598;
10602 -> 10598;
10603 -> 10599;
10603 -> 10602;
10604 -> 10601;
10604 -> 10602;
10605 -> 10604;
10605 -> 10602;
10606 -> 10603;
10606 -> 10605;
10607 -> 10599;
10607 -> 10601;
10607 -> 10598;
10608 -> 10600;
10608 -> 10601;
10608 -> 10598;
10609 -> 10607;
10609 -> 10608;
10609 -> 10598;
10610 -> 10590;
10611 -> 10590;
10612 -> 10611;
10613 -> 10612;
10614 -> 10613;
10615 -> 10614;
10616 -> 10615;
10617 -> 6354;
10617 -> 10616;
10618 -> 10616;
10619 -> 10616;
10620 -> 10619;
10621 -> 10581;
10621 -> 10620;
10622 -> 10620;
10623 -> 10620;
10624 -> 10620;
10625 -> 10623;
10625 -> 10624;
10626 -> 10623;
10626 -> 10619;
10627 -> 10619;
10628 -> 10619;
10629 -> 10626;
10629 -> 10619;
10630 -> 10627;
10630 -> 10619;
10631 -> 10619;
10632 -> 10581;
10632 -> 10631;
10633 -> 10581;
10633 -> 10631;
10634 -> 10633;
10634 -> 10581;
10634 -> 10632;
10634 -> 10631;
10635 -> 10614;
10636 -> 0;
10636 -> 10635;
10637 -> 10635;
10638 -> 10636;
10638 -> 10637;
10639 -> 0;
10639 -> 10564;
10640 -> 10564;
10641 -> 10639;
10641 -> 10640;
10642 -> 10533;
10642 -> 10640;
10643 -> 10640;
10644 -> 10642;
10644 -> 10643;
10644 -> 10640;
10645 -> 10640;
10646 -> 10640;
10647 -> 10642;
10647 -> 10646;
10648 -> 10645;
10648 -> 10646;
10649 -> 10646;
10650 -> 10648;
10650 -> 10649;
10651 -> 10650;
10651 -> 10649;
10652 -> 10650;
10652 -> 10649;
10653 -> 10650;
10653 -> 10649;
10654 -> 10650;
10654 -> 10649;
10655 -> 10650;
10655 -> 10649;
10656 -> 10649;
10657 -> 10634;
10657 -> 10656;
10657 -> 10649;
10658 -> 10634;
10658 -> 10649;
10659 -> 0;
10659 -> 10649;
10660 -> 10649;
10661 -> 10658;
10661 -> 10660;
10662 -> 10659;
10662 -> 10660;
10663 -> 10634;
10663 -> 10649;
10664 -> 0;
10664 -> 10649;
10665 -> 10649;
10666 -> 10663;
10666 -> 10665;
10667 -> 10664;
10667 -> 10665;
10668 -> 10648;
10668 -> 10646;
10669 -> 10646;
10670 -> 10646;
10671 -> 10647;
10671 -> 10670;
10672 -> 10669;
10672 -> 10670;
10673 -> 10672;
10673 -> 10670;
10674 -> 10671;
10674 -> 10673;
10675 -> 10647;
10675 -> 10669;
10675 -> 10646;
10676 -> 10647;
10676 -> 10648;
10676 -> 10646;
10677 -> 10645;
10677 -> 10564;
10678 -> 10564;
10679 -> 10564;
10680 -> 10679;
10681 -> 10634;
10682 -> 10634;
10683 -> 10681;
10683 -> 10634;
10684 -> 10682;
10684 -> 10634;
10685 -> 10634;
10686 -> 10683;
10686 -> 10684;
10686 -> 10634;
10687 -> 10683;
10687 -> 10634;
10688 -> 10686;
10688 -> 10634;
10689 -> 10634;
10690 -> 10687;
10690 -> 10634;
10691 -> 10681;
10691 -> 10685;
10691 -> 10634;
10692 -> 10690;
10692 -> 10684;
10692 -> 10634;
10693 -> 10692;
10693 -> 10634;
10694 -> 10683;
10695 -> 10694;
10695 -> 10683;
10696 -> 10694;
10696 -> 10683;
10697 -> 10696;
10697 -> 10683;
10698 -> 10695;
10698 -> 10683;
10699 -> 10683;
10699 -> 0;
10700 -> 10683;
10701 -> 10683;
10702 -> 10683;
10703 -> 10702;
10703 -> 10683;
10704 -> 10703;
10705 -> 10703;
10705 -> 10704;
10706 -> 10704;
10707 -> 10705;
10707 -> 10706;
10708 -> 10706;
10709 -> 10707;
10709 -> 10683;
10709 -> 10708;
10709 -> 10706;
10710 -> 10704;
10711 -> 10705;
10711 -> 10683;
10711 -> 10704;
10712 -> 10711;
10712 -> 10703;
10713 -> 10703;
10714 -> 10683;
10715 -> 10714;
10715 -> 10683;
10716 -> 10683;
10717 -> 10698;
10717 -> 10683;
10718 -> 10697;
10718 -> 10683;
10719 -> 10683;
10720 -> 10683;
10721 -> 10683;
10722 -> 10683;
10722 -> 10721;
10723 -> 0;
10723 -> 10721;
10724 -> 10723;
10724 -> 10683;
10725 -> 10683;
10726 -> 10720;
10726 -> 10683;
10727 -> 10683;
10728 -> 10683;
10729 -> 10683;
10730 -> 10683;
10731 -> 10683;
10732 -> 10731;
10732 -> 10683;
10733 -> 10731;
10733 -> 10683;
10734 -> 10733;
10735 -> 10734;
10735 -> 10683;
10736 -> 10683;
10737 -> 10736;
10737 -> 10683;
10738 -> 10683;
10739 -> 10683;
10740 -> 10738;
10740 -> 10683;
10741 -> 10683;
10742 -> 10683;
10742 -> 10741;
10743 -> 0;
10743 -> 10741;
10744 -> 10743;
10744 -> 10683;
10745 -> 10744;
10745 -> 10683;
10746 -> 10683;
10747 -> 10745;
10747 -> 10746;
10748 -> 10740;
10748 -> 10746;
10749 -> 10747;
10749 -> 0;
10749 -> 10746;
10750 -> 10747;
10750 -> 10749;
10751 -> 10683;
10752 -> 10751;
10752 -> 10683;
10753 -> 10683;
10754 -> 10752;
10754 -> 10683;
10755 -> 10752;
10755 -> 10754;
10756 -> 10755;
10756 -> 10683;
10757 -> 10752;
10757 -> 10683;
10758 -> 10744;
10758 -> 10750;
10758 -> 10683;
10759 -> 10758;
10759 -> 10756;
10759 -> 10683;
10760 -> 10683;
10761 -> 10683;
10761 -> 10760;
10762 -> 10760;
10763 -> 10762;
10763 -> 10760;
10764 -> 10763;
10764 -> 10760;
10765 -> 10761;
10765 -> 10760;
10766 -> 10760;
10767 -> 10765;
10767 -> 10766;
10768 -> 10766;
10769 -> 10768;
10769 -> 10760;
10770 -> 10760;
10771 -> 10765;
10771 -> 10770;
10772 -> 10771;
10772 -> 10760;
10773 -> 10760;
10774 -> 10772;
10774 -> 10773;
10775 -> 0;
10775 -> 10773;
10776 -> 10775;
10776 -> 10760;
10777 -> 10769;
10777 -> 10776;
10777 -> 10760;
10778 -> 10760;
10779 -> 10765;
10779 -> 10778;
10780 -> 10779;
10780 -> 10760;
10781 -> 10760;
10782 -> 10780;
10782 -> 10781;
10783 -> 10760;
10784 -> 10782;
10784 -> 10783;
10785 -> 10783;
10785 -> 10760;
10786 -> 10760;
10787 -> 10777;
10787 -> 10785;
10787 -> 10760;
10788 -> 10760;
10789 -> 10765;
10789 -> 10788;
10790 -> 10789;
10790 -> 10760;
10791 -> 10790;
10791 -> 3004;
10791 -> 10760;
10792 -> 10787;
10792 -> 10791;
10792 -> 10760;
10793 -> 10760;
10794 -> 10760;
10794 -> 10683;
10795 -> 10683;
10796 -> 10683;
10796 -> 0;
10797 -> 10683;
10798 -> 10683;
10798 -> 10797;
10799 -> 10797;
10800 -> 10798;
10800 -> 10799;
10801 -> 10683;
10802 -> 10801;
10802 -> 10683;
10803 -> 10683;
10803 -> 10802;
10804 -> 10802;
10805 -> 10803;
10805 -> 10804;
10806 -> 10683;
10806 -> 0;
10807 -> 10683;
10808 -> 10805;
10808 -> 10807;
10808 -> 10683;
10809 -> 10683;
10810 -> 10683;
10811 -> 10683;
10812 -> 10811;
10812 -> 10683;
10813 -> 10683;
10814 -> 10810;
10814 -> 10813;
10815 -> 10813;
10816 -> 10814;
10816 -> 10815;
10817 -> 10815;
10818 -> 10816;
10818 -> 10817;
10819 -> 10817;
10820 -> 10818;
10820 -> 10819;
10821 -> 10820;
10821 -> 10817;
10822 -> 10821;
10822 -> 10815;
10823 -> 10822;
10823 -> 10813;
10824 -> 10823;
10824 -> 10683;
10825 -> 10683;
10826 -> 10810;
10826 -> 10825;
10827 -> 10825;
10828 -> 10826;
10828 -> 10827;
10829 -> 10827;
10830 -> 10828;
10830 -> 10829;
10831 -> 0;
10831 -> 10829;
10832 -> 10831;
10832 -> 10827;
10833 -> 10828;
10833 -> 10825;
10834 -> 10833;
10834 -> 10683;
10835 -> 10683;
10836 -> 10810;
10836 -> 10683;
10837 -> 10683;
10838 -> 10836;
10838 -> 10837;
10839 -> 10835;
10839 -> 10837;
10840 -> 10838;
10840 -> 10837;
10841 -> 10837;
10842 -> 10838;
10842 -> 10841;
10843 -> 10841;
10843 -> 10837;
10844 -> 10837;
10845 -> 10837;
10846 -> 10838;
10846 -> 10845;
10847 -> 0;
10847 -> 10845;
10848 -> 10846;
10848 -> 10837;
10849 -> 10837;
10850 -> 10838;
10850 -> 10849;
10851 -> 10850;
10851 -> 10837;
10852 -> 10851;
10852 -> 10837;
10853 -> 10837;
10854 -> 10853;
10854 -> 10683;
10855 -> 10683;
10856 -> 10683;
10857 -> 10683;
10858 -> 10857;
10858 -> 10683;
10859 -> 10857;
10859 -> 10683;
10860 -> 10859;
10860 -> 10683;
10861 -> 10860;
10861 -> 10683;
10862 -> 10860;
10862 -> 10683;
10863 -> 10862;
10863 -> 10683;
10864 -> 10863;
10864 -> 10683;
10865 -> 10863;
10865 -> 10683;
10866 -> 10857;
10866 -> 10683;
10867 -> 10683;
10868 -> 10857;
10868 -> 10867;
10868 -> 10683;
10869 -> 10683;
10870 -> 10857;
10870 -> 10869;
10870 -> 10683;
10871 -> 10683;
10872 -> 10857;
10872 -> 10871;
10873 -> 10871;
10874 -> 10872;
10874 -> 10873;
10875 -> 10873;
10876 -> 10874;
10876 -> 10875;
10877 -> 10875;
10878 -> 10876;
10878 -> 10877;
10879 -> 10878;
10879 -> 10875;
10880 -> 10879;
10880 -> 10873;
10881 -> 10880;
10881 -> 10871;
10882 -> 10881;
10882 -> 10683;
10883 -> 10683;
10884 -> 10857;
10884 -> 10883;
10885 -> 10883;
10886 -> 10885;
10886 -> 10683;
10887 -> 10683;
10888 -> 10857;
10888 -> 10887;
10888 -> 10683;
10889 -> 10857;
10890 -> 10857;
10891 -> 10886;
10891 -> 10857;
10892 -> 10857;
10893 -> 10892;
10894 -> 10857;
10895 -> 10886;
10895 -> 10894;
10895 -> 10857;
10896 -> 10857;
10896 -> 10683;
10897 -> 10683;
10898 -> 10857;
10899 -> 10857;
10900 -> 10898;
10900 -> 10899;
10901 -> 10899;
10902 -> 10900;
10902 -> 10901;
10902 -> 10899;
10903 -> 10900;
10903 -> 10899;
10904 -> 10899;
10904 -> 10857;
10905 -> 10683;
10906 -> 10683;
10907 -> 10683;
10908 -> 10683;
10908 -> 10907;
10909 -> 10907;
10910 -> 10908;
10910 -> 10909;
10911 -> 10910;
10911 -> 10857;
10911 -> 10909;
10912 -> 10909;
10913 -> 10911;
10913 -> 10912;
10914 -> 0;
10914 -> 10912;
10915 -> 10914;
10915 -> 10909;
10916 -> 10911;
10916 -> 10907;
10917 -> 10916;
10917 -> 10683;
10918 -> 10683;
10919 -> 10917;
10919 -> 10918;
10920 -> 10918;
10921 -> 10919;
10921 -> 10920;
10922 -> 10920;
10923 -> 10921;
10923 -> 10922;
10924 -> 10922;
10925 -> 10923;
10925 -> 10857;
10925 -> 10924;
10925 -> 10922;
10926 -> 10920;
10927 -> 10921;
10927 -> 10918;
10928 -> 10918;
10929 -> 10905;
10929 -> 10857;
10930 -> 10905;
10931 -> 10929;
10931 -> 10930;
10932 -> 0;
10932 -> 10930;
10933 -> 10932;
10933 -> 10905;
10934 -> 10683;
10934 -> 10857;
10934 -> 10905;
10935 -> 10929;
10936 -> 0;
10936 -> 10929;
10937 -> 10936;
10937 -> 10929;
10938 -> 10929;
10939 -> 10938;
10939 -> 10929;
10940 -> 10937;
10940 -> 10939;
10940 -> 10929;
10941 -> 10940;
10942 -> 10940;
10943 -> 10941;
10943 -> 10942;
10944 -> 10942;
10945 -> 10942;
10945 -> 10940;
10946 -> 10940;
10947 -> 10945;
10947 -> 10946;
10948 -> 10947;
10948 -> 10940;
10949 -> 10683;
10949 -> 10929;
10950 -> 10949;
10950 -> 10683;
10951 -> 10683;
10952 -> 10950;
10952 -> 10951;
10952 -> 10683;
10953 -> 10694;
10953 -> 10683;
10954 -> 10936;
10954 -> 10694;
10955 -> 10694;
10955 -> 10683;
10956 -> 10954;
10956 -> 0;
10956 -> 10683;
10957 -> 10954;
10957 -> 10683;
10958 -> 10694;
10958 -> 10957;
10959 -> 10957;
10960 -> 10958;
10960 -> 10959;
10961 -> 10694;
10961 -> 10683;
10962 -> 10961;
10962 -> 10683;
10963 -> 10694;
10963 -> 10962;
10964 -> 10962;
10965 -> 10963;
10965 -> 10964;
10966 -> 10965;
10966 -> 10936;
10966 -> 10964;
10967 -> 10954;
10967 -> 0;
10967 -> 10683;
10968 -> 10966;
10968 -> 10807;
10968 -> 10683;
10969 -> 10694;
10969 -> 10809;
10969 -> 10683;
10970 -> 10683;
10971 -> 10694;
10971 -> 10970;
10972 -> 10971;
10972 -> 10683;
10973 -> 10683;
10974 -> 10973;
10974 -> 10694;
10974 -> 10683;
10975 -> 10683;
10976 -> 10975;
10976 -> 10694;
10976 -> 10683;
10977 -> 10694;
10978 -> 10694;
10979 -> 10694;
10980 -> 10977;
10980 -> 10694;
10981 -> 10978;
10981 -> 10694;
10982 -> 10979;
10982 -> 10694;
10983 -> 10980;
10983 -> 10694;
10984 -> 10981;
10984 -> 10694;
10985 -> 10982;
10985 -> 10694;
10986 -> 10694;
10987 -> 10983;
10987 -> 10694;
10988 -> 10984;
10988 -> 10694;
10989 -> 10985;
10989 -> 10694;
10990 -> 10987;
10990 -> 10694;
10991 -> 10988;
10991 -> 10694;
10992 -> 10989;
10992 -> 10694;
10993 -> 10694;
10994 -> 10992;
10994 -> 10694;
10995 -> 10991;
10995 -> 10694;
10996 -> 10694;
10997 -> 10990;
10997 -> 10694;
10998 -> 10994;
10998 -> 10694;
10999 -> 10995;
10999 -> 10694;
11000 -> 10996;
11000 -> 10694;
11001 -> 10997;
11001 -> 10694;
11002 -> 10694;
11003 -> 10694;
11004 -> 11001;
11004 -> 11003;
11005 -> 11004;
11005 -> 10676;
11005 -> 11003;
11006 -> 10694;
11007 -> 11001;
11007 -> 11006;
11008 -> 11006;
11009 -> 11007;
11009 -> 11008;
11010 -> 11009;
11010 -> 10676;
11010 -> 11008;
11011 -> 11010;
11011 -> 11006;
11012 -> 11011;
11012 -> 11006;
11013 -> 11006;
11014 -> 11011;
11014 -> 11013;
11015 -> 0;
11015 -> 11013;
11016 -> 11015;
11016 -> 11006;
11017 -> 11012;
11017 -> 11016;
11017 -> 11006;
11018 -> 11011;
11018 -> 11006;
11019 -> 11018;
11020 -> 11019;
11020 -> 10936;
11021 -> 11020;
11021 -> 11018;
11022 -> 10998;
11022 -> 10694;
11023 -> 10999;
11023 -> 10694;
11024 -> 11000;
11024 -> 10694;
11025 -> 11005;
11025 -> 10694;
11026 -> 11021;
11026 -> 10694;
11027 -> 11001;
11027 -> 10694;
11028 -> 10694;
11028 -> 10936;
11029 -> 10694;
11030 -> 10694;
11030 -> 11029;
11031 -> 11029;
11031 -> 10694;
11032 -> 10694;
11033 -> 10694;
11033 -> 11032;
11034 -> 11032;
11034 -> 10694;
11035 -> 11026;
11035 -> 10694;
11036 -> 11024;
11036 -> 10694;
11037 -> 11036;
11037 -> 10694;
11038 -> 11022;
11038 -> 10694;
11039 -> 11023;
11039 -> 10694;
11040 -> 11025;
11040 -> 10694;
11041 -> 11027;
11041 -> 10694;
11042 -> 10694;
11043 -> 11038;
11043 -> 11042;
11043 -> 10694;
11044 -> 11040;
11044 -> 10694;
11045 -> 10694;
11046 -> 10694;
11047 -> 11028;
11047 -> 11046;
11048 -> 0;
11048 -> 11046;
11049 -> 11048;
11049 -> 10694;
11050 -> 11028;
11050 -> 6720;
11050 -> 10694;
11051 -> 11028;
11051 -> 6720;
11052 -> 11028;
11053 -> 11028;
11053 -> 6720;
11053 -> 10694;
11054 -> 0;
11054 -> 11028;
11055 -> 11028;
11056 -> 11028;
11057 -> 11054;
11057 -> 11056;
11057 -> 11028;
11058 -> 11028;
11058 -> 11054;
11058 -> 10694;
11059 -> 11058;
11059 -> 10694;
11060 -> 10694;
11061 -> 11059;
11061 -> 11060;
11061 -> 10694;
11062 -> 11061;
11062 -> 10694;
11063 -> 11062;
11063 -> 10694;
11064 -> 0;
11064 -> 11063;
11065 -> 10694;
11066 -> 11064;
11066 -> 10694;
11067 -> 10694;
11068 -> 11065;
11068 -> 11067;
11068 -> 10694;
11069 -> 11064;
11069 -> 10694;
11070 -> 11069;
11070 -> 10694;
11071 -> 11036;
11071 -> 11070;
11072 -> 10694;
11073 -> 10634;
11074 -> 10634;
11075 -> 10690;
11075 -> 10634;
11076 -> 10634;
11077 -> 10634;
11078 -> 10694;
11078 -> 11077;
11079 -> 11078;
11079 -> 10974;
11079 -> 11077;
11080 -> 11079;
11080 -> 0;
11080 -> 11077;
11081 -> 11080;
11081 -> 10634;
11082 -> 10634;
11083 -> 10694;
11083 -> 11082;
11084 -> 11083;
11084 -> 10694;
11084 -> 11082;
11085 -> 11082;
11086 -> 11084;
11086 -> 11085;
11087 -> 11083;
11087 -> 10694;
11087 -> 11085;
11088 -> 11085;
11089 -> 11086;
11089 -> 11088;
11090 -> 11089;
11090 -> 11054;
11090 -> 0;
11090 -> 11088;
11091 -> 11088;
11092 -> 11090;
11092 -> 10634;
11093 -> 10689;
11093 -> 11054;
11094 -> 11054;
11095 -> 11054;
11096 -> 11095;
11096 -> 11054;
11097 -> 11096;
11098 -> 11096;
11098 -> 11097;
11099 -> 11097;
11100 -> 11098;
11100 -> 11099;
11101 -> 11099;
11102 -> 11100;
11102 -> 11054;
11102 -> 11101;
11102 -> 11099;
11103 -> 11097;
11104 -> 11098;
11104 -> 11054;
11104 -> 11097;
11105 -> 11104;
11105 -> 11096;
11106 -> 11096;
11107 -> 11054;
11108 -> 11054;
11109 -> 11107;
11109 -> 11108;
11109 -> 11054;
11110 -> 11107;
11110 -> 11054;
11111 -> 11054;
11112 -> 11054;
11113 -> 11054;
11114 -> 11054;
11115 -> 11054;
11116 -> 11054;
11117 -> 11054;
11118 -> 11054;
11119 -> 11054;
11120 -> 11054;
11121 -> 11054;
11122 -> 11054;
11122 -> 11121;
11123 -> 11121;
11124 -> 11122;
11124 -> 11123;
11125 -> 11123;
11126 -> 11124;
11126 -> 11125;
11127 -> 11125;
11128 -> 11126;
11128 -> 11127;
11129 -> 11128;
11129 -> 11125;
11130 -> 11129;
11130 -> 11123;
11131 -> 11130;
11131 -> 11121;
11132 -> 11131;
11132 -> 11054;
11133 -> 11054;
11134 -> 11054;
11135 -> 11133;
11135 -> 11134;
11136 -> 11134;
11137 -> 11135;
11137 -> 11136;
11137 -> 11134;
11138 -> 11135;
11138 -> 11134;
11139 -> 11134;
11139 -> 11054;
11140 -> 11054;
11141 -> 11054;
11141 -> 11140;
11142 -> 11141;
11142 -> 11140;
11143 -> 11142;
11143 -> 11054;
11144 -> 11054;
11145 -> 11054;
11146 -> 11054;
11147 -> 11146;
11147 -> 11054;
11148 -> 11054;
11149 -> 11148;
11149 -> 11054;
11150 -> 11054;
11151 -> 11107;
11151 -> 11134;
11152 -> 11134;
11153 -> 11134;
11154 -> 11134;
11155 -> 11134;
11156 -> 11134;
11157 -> 11134;
11158 -> 11134;
11159 -> 11134;
11160 -> 11134;
11161 -> 11134;
11162 -> 11134;
11163 -> 11134;
11163 -> 11162;
11164 -> 11162;
11165 -> 11163;
11165 -> 11164;
11166 -> 11164;
11167 -> 11165;
11167 -> 11166;
11168 -> 11166;
11169 -> 11167;
11169 -> 11168;
11170 -> 11169;
11170 -> 11166;
11171 -> 11170;
11171 -> 11164;
11172 -> 11171;
11172 -> 11162;
11173 -> 11172;
11173 -> 11134;
11174 -> 11134;
11175 -> 11174;
11175 -> 11134;
11176 -> 11175;
11176 -> 11136;
11176 -> 11134;
11177 -> 11175;
11177 -> 11134;
11178 -> 11134;
11179 -> 11134;
11179 -> 11178;
11180 -> 11179;
11180 -> 11178;
11181 -> 11180;
11181 -> 11134;
11182 -> 11134;
11183 -> 11134;
11184 -> 11134;
11185 -> 11184;
11185 -> 11134;
11186 -> 11134;
11187 -> 11186;
11187 -> 11134;
11188 -> 11134;
11189 -> 11134;
11190 -> 11134;
11191 -> 11190;
11191 -> 11134;
11192 -> 11134;
11193 -> 11054;
11194 -> 11134;
11194 -> 11193;
11194 -> 11054;
11195 -> 11134;
11195 -> 11054;
11196 -> 11134;
11196 -> 11054;
11197 -> 11134;
11197 -> 0;
11197 -> 11054;
11198 -> 11134;
11198 -> 11054;
11199 -> 11134;
11199 -> 11198;
11200 -> 11198;
11201 -> 11199;
11201 -> 11200;
11202 -> 11201;
11202 -> 11200;
11203 -> 11202;
11203 -> 11200;
11204 -> 11203;
11204 -> 11200;
11205 -> 0;
11205 -> 11200;
11206 -> 11205;
11206 -> 11198;
11207 -> 11134;
11207 -> 11054;
11208 -> 11207;
11208 -> 11054;
11209 -> 11134;
11209 -> 11208;
11210 -> 11208;
11211 -> 11209;
11211 -> 11210;
11212 -> 11211;
11212 -> 11210;
11213 -> 11212;
11213 -> 11210;
11214 -> 11213;
11214 -> 11210;
11215 -> 0;
11215 -> 11210;
11216 -> 11215;
11216 -> 11208;
11217 -> 11134;
11217 -> 0;
11217 -> 11054;
11218 -> 11054;
11219 -> 11216;
11219 -> 11218;
11219 -> 11054;
11220 -> 11054;
11221 -> 11134;
11221 -> 11220;
11221 -> 11054;
11222 -> 10689;
11222 -> 11134;
11222 -> 11054;
11223 -> 11134;
11223 -> 11054;
11224 -> 11134;
11225 -> 11224;
11225 -> 11134;
11226 -> 11225;
11227 -> 11225;
11227 -> 11226;
11228 -> 11226;
11229 -> 11227;
11229 -> 11228;
11230 -> 11228;
11231 -> 11229;
11231 -> 11134;
11231 -> 11230;
11231 -> 11228;
11232 -> 11226;
11233 -> 11227;
11233 -> 11134;
11233 -> 11226;
11234 -> 11233;
11234 -> 11225;
11235 -> 11225;
11236 -> 11134;
11237 -> 11236;
11237 -> 11136;
11237 -> 11134;
11238 -> 11236;
11238 -> 11134;
11239 -> 11134;
11240 -> 10634;
11241 -> 11134;
11241 -> 11240;
11242 -> 11241;
11242 -> 10634;
11243 -> 10634;
11244 -> 11243;
11244 -> 10634;
11245 -> 10634;
11246 -> 11245;
11246 -> 10634;
11247 -> 11134;
11248 -> 11134;
11249 -> 11134;
11250 -> 11247;
11250 -> 11134;
11251 -> 11248;
11251 -> 11134;
11252 -> 11249;
11252 -> 11134;
11253 -> 11250;
11253 -> 11134;
11254 -> 11251;
11254 -> 11134;
11255 -> 11252;
11255 -> 11134;
11256 -> 11134;
11257 -> 11253;
11257 -> 11134;
11258 -> 11254;
11258 -> 11134;
11259 -> 11255;
11259 -> 11134;
11260 -> 11257;
11260 -> 11134;
11261 -> 11258;
11261 -> 11134;
11262 -> 11259;
11262 -> 11134;
11263 -> 11134;
11264 -> 11262;
11264 -> 11134;
11265 -> 11261;
11265 -> 11134;
11266 -> 11134;
11267 -> 11260;
11267 -> 11134;
11268 -> 11264;
11268 -> 11134;
11269 -> 11265;
11269 -> 11134;
11270 -> 11266;
11270 -> 11134;
11271 -> 11267;
11271 -> 11134;
11272 -> 11134;
11273 -> 0;
11273 -> 11134;
11274 -> 11134;
11275 -> 10681;
11275 -> 10634;
11276 -> 11134;
11276 -> 11077;
11277 -> 11276;
11277 -> 11244;
11277 -> 11077;
11278 -> 11277;
11278 -> 0;
11278 -> 11077;
11279 -> 11278;
11279 -> 10634;
11280 -> 10564;
11281 -> 10533;
11281 -> 11280;
11282 -> 11280;
11283 -> 11281;
11283 -> 11282;
11284 -> 11283;
11284 -> 11134;
11284 -> 11282;
11285 -> 11284;
11285 -> 0;
11285 -> 11280;
11286 -> 11280;
11287 -> 11285;
11287 -> 11286;
11287 -> 11280;
11288 -> 11287;
11288 -> 10564;
11289 -> 10536;
11290 -> 11289;
11291 -> 11290;
11292 -> 11290;
11293 -> 10536;
11294 -> 11293;
11295 -> 11134;
11295 -> 11294;
11296 -> 11294;
11297 -> 11296;
11298 -> 11296;
11299 -> 11296;
11300 -> 11298;
11300 -> 11299;
11301 -> 11134;
11301 -> 11299;
11302 -> 11301;
11302 -> 11299;
11303 -> 11134;
11303 -> 11302;
11304 -> 11302;
11305 -> 11303;
11305 -> 11304;
11306 -> 11305;
11306 -> 11304;
11307 -> 11306;
11307 -> 11304;
11308 -> 11307;
11308 -> 11304;
11309 -> 0;
11309 -> 11304;
11310 -> 11309;
11310 -> 11302;
11311 -> 11134;
11311 -> 0;
11311 -> 11299;
11312 -> 11299;
11313 -> 11310;
11313 -> 11312;
11313 -> 11299;
11314 -> 11299;
11315 -> 11134;
11315 -> 11314;
11315 -> 11299;
11316 -> 11298;
11316 -> 11294;
11317 -> 11316;
11317 -> 10536;
11318 -> 10536;
11319 -> 10536;
11320 -> 11317;
11320 -> 11319;
11321 -> 11318;
11321 -> 11319;
11322 -> 11320;
11322 -> 11321;
11322 -> 11319;
11323 -> 11134;
11324 -> 11134;
11324 -> 11323;
11325 -> 11323;
11326 -> 11325;
11326 -> 11134;
11327 -> 11134;
11327 -> 11326;
11328 -> 11326;
11329 -> 11327;
11329 -> 11328;
11330 -> 11328;
11331 -> 11329;
11331 -> 11330;
11332 -> 0;
11332 -> 11330;
11333 -> 11332;
11333 -> 11328;
11334 -> 11333;
11334 -> 11326;
11335 -> 11134;
11335 -> 11334;
11336 -> 11334;
11337 -> 11334;
11338 -> 11335;
11338 -> 11337;
11339 -> 11336;
11339 -> 11337;
11340 -> 11337;
11341 -> 11338;
11341 -> 11340;
11341 -> 11337;
11342 -> 11337;
11343 -> 11338;
11343 -> 11342;
11344 -> 11342;
11344 -> 11337;
11345 -> 11339;
11345 -> 11337;
11346 -> 11345;
11347 -> 11346;
11348 -> 11134;
11348 -> 11347;
11349 -> 11347;
11350 -> 11349;
11350 -> 11346;
11351 -> 11350;
11352 -> 11134;
11352 -> 11351;
11353 -> 11351;
11354 -> 11352;
11354 -> 11353;
11355 -> 11354;
11355 -> 0;
11355 -> 11351;
11356 -> 11351;
11357 -> 11355;
11357 -> 11356;
11357 -> 11351;
11358 -> 11357;
11358 -> 11350;
11359 -> 11358;
11360 -> 11359;
11360 -> 11358;
11361 -> 11134;
11362 -> 11134;
11363 -> 11134;
11364 -> 11363;
11364 -> 11134;
11365 -> 11134;
11366 -> 11134;
11367 -> 11362;
11367 -> 11366;
11367 -> 11134;
11368 -> 11134;
11369 -> 11134;
11369 -> 11368;
11370 -> 11368;
11370 -> 11134;
11371 -> 11190;
11372 -> 11190;
11373 -> 11134;
11374 -> 11373;
11374 -> 11134;
11375 -> 11134;
11376 -> 11190;
11376 -> 11134;
11377 -> 11190;
11377 -> 11134;
11378 -> 11377;
11378 -> 11134;
11379 -> 11378;
11379 -> 11134;
11380 -> 0;
11380 -> 11134;
11381 -> 11190;
11381 -> 11380;
11382 -> 11381;
11382 -> 11368;
11383 -> 11381;
11383 -> 11190;
11384 -> 11381;
11384 -> 11190;
11385 -> 11381;
11385 -> 11134;
11386 -> 11381;
11386 -> 11134;
11387 -> 11381;
11387 -> 11368;
11388 -> 11387;
11388 -> 11134;
11389 -> 11388;
11390 -> 11389;
11390 -> 11388;
11391 -> 11388;
11392 -> 11390;
11392 -> 11391;
11392 -> 11388;
11393 -> 11383;
11393 -> 11381;
11394 -> 0;
11394 -> 11381;
11395 -> 11381;
11396 -> 11381;
11396 -> 11395;
11397 -> 0;
11397 -> 11395;
11398 -> 11397;
11398 -> 11381;
11399 -> 11398;
11399 -> 0;
11399 -> 11381;
11400 -> 11399;
11401 -> 11400;
11401 -> 11134;
11402 -> 11134;
11402 -> 11381;
11403 -> 11381;
11404 -> 10532;
11405 -> 11404;
11406 -> 11381;
11406 -> 11405;
11407 -> 0;
11407 -> 1;
11408 -> 1;
11409 -> 11381;
11409 -> 11408;
11410 -> 0;
11410 -> 11408;
11411 -> 11410;
11411 -> 1;
11412 -> 1;
11413 -> 11381;
11413 -> 11412;
11414 -> 11412;
11415 -> 11412;
11416 -> 11413;
11416 -> 11415;
11417 -> 0;
11417 -> 11415;
11418 -> 11417;
11418 -> 11412;
11419 -> 11418;
11420 -> 11413;
11420 -> 11419;
11421 -> 11419;
11422 -> 11421;
11422 -> 11418;
11423 -> 11414;
11423 -> 11418;
11424 -> 11422;
11424 -> 11423;
11424 -> 11418;
11425 -> 11418;
11426 -> 11425;
11427 -> 11426;
11428 -> 11413;
11428 -> 11381;
11428 -> 11427;
11429 -> 11424;
11429 -> 11412;
11430 -> 11412;
11431 -> 11430;
11432 -> 11430;
11433 -> 11413;
11433 -> 1;
11434 -> 1;
11435 -> 11381;
11435 -> 11434;
11436 -> 11434;
11437 -> 11434;
11438 -> 11435;
11438 -> 11437;
11439 -> 0;
11439 -> 11437;
11440 -> 11439;
11440 -> 11434;
11441 -> 11440;
11442 -> 11435;
11442 -> 11441;
11443 -> 11441;
11444 -> 11443;
11444 -> 11440;
11445 -> 11436;
11445 -> 11440;
11446 -> 11444;
11446 -> 11445;
11446 -> 11440;
11447 -> 11440;
11448 -> 11447;
11449 -> 11435;
11449 -> 11413;
11449 -> 11448;
11450 -> 11448;
11451 -> 11449;
11451 -> 11413;
11451 -> 11450;
11452 -> 11449;
11452 -> 11437;
11453 -> 11449;
11453 -> 11441;
11454 -> 11446;
11454 -> 11434;
11455 -> 11434;
11456 -> 11455;
11457 -> 11455;
11458 -> 11449;
11458 -> 1;
11459 -> 11433;
11459 -> 1;
11460 -> 11458;
11460 -> 1;
11461 -> 11459;
11461 -> 11460;
11461 -> 1;
11462 -> 1;
11463 -> 1;
11464 -> 11462;
11464 -> 11463;
11465 -> 3616;
11465 -> 11463;
11466 -> 11463;
11467 -> 11466;
11467 -> 11463;
11468 -> 11463;
11469 -> 11465;
11469 -> 11468;
11470 -> 0;
11470 -> 11468;
11471 -> 11468;
11472 -> 11470;
11472 -> 11471;
11473 -> 11469;
11473 -> 11449;
11473 -> 11471;
11474 -> 11464;
11474 -> 11463;
11475 -> 11466;
11475 -> 11463;
11476 -> 11473;
11476 -> 11474;
11476 -> 11475;
11476 -> 11449;
11476 -> 11467;
11476 -> 11463;
11477 -> 1;
11478 -> 11476;
11478 -> 11477;
11479 -> 11477;
11480 -> 0;
11480 -> 11479;
11481 -> 11479;
11482 -> 11480;
11482 -> 11481;
11483 -> 11481;
11484 -> 11482;
11484 -> 11483;
11484 -> 11481;
11485 -> 11481;
11486 -> 11478;
11486 -> 11476;
11486 -> 11485;
11486 -> 11481;
11487 -> 11481;
11488 -> 11487;
11489 -> 11488;
11490 -> 11481;
11491 -> 11481;
11492 -> 11491;
11493 -> 11478;
11493 -> 11492;
11494 -> 0;
11494 -> 11492;
11495 -> 11494;
11495 -> 11491;
11496 -> 11491;
11497 -> 11496;
11498 -> 11496;
11499 -> 11491;
11500 -> 11481;
11501 -> 11481;
11502 -> 11501;
11502 -> 11481;
11503 -> 11481;
11504 -> 11481;
11505 -> 11478;
11505 -> 11504;
11506 -> 11504;
11507 -> 11506;
11507 -> 11481;
11508 -> 11481;
11509 -> 11507;
11509 -> 11508;
11509 -> 11481;
11510 -> 11509;
11511 -> 11509;
11512 -> 11509;
11513 -> 11511;
11513 -> 11512;
11514 -> 11513;
11514 -> 11512;
11515 -> 11512;
11516 -> 11512;
11517 -> 11515;
11517 -> 11516;
11518 -> 11517;
11518 -> 11516;
11519 -> 11516;
11520 -> 11519;
11521 -> 11520;
11522 -> 11516;
11523 -> 11516;
11524 -> 11516;
11525 -> 11523;
11525 -> 11516;
11526 -> 11509;
11527 -> 11509;
11528 -> 11526;
11528 -> 11527;
11529 -> 11526;
11529 -> 11527;
11530 -> 11527;
11531 -> 11527;
11532 -> 11528;
11532 -> 11527;
11533 -> 11529;
11533 -> 11527;
11534 -> 11527;
11535 -> 11532;
11535 -> 11534;
11536 -> 11533;
11536 -> 11534;
11537 -> 11534;
11538 -> 11478;
11538 -> 11537;
11538 -> 11534;
11539 -> 11536;
11539 -> 11534;
11540 -> 11535;
11540 -> 11534;
11541 -> 11536;
11541 -> 11534;
11542 -> 11534;
11543 -> 11540;
11543 -> 11542;
11544 -> 11541;
11544 -> 11542;
11545 -> 11542;
11546 -> 11542;
11547 -> 11543;
11547 -> 11546;
11548 -> 11545;
11548 -> 11546;
11549 -> 11548;
11549 -> 11546;
11550 -> 11547;
11550 -> 11549;
11551 -> 11543;
11551 -> 11545;
11551 -> 11542;
11552 -> 11544;
11552 -> 11545;
11552 -> 11542;
11553 -> 11551;
11553 -> 11552;
11553 -> 11542;
11554 -> 11534;
11555 -> 11534;
11556 -> 11555;
11557 -> 11556;
11558 -> 11557;
11559 -> 11558;
11560 -> 11559;
11561 -> 6354;
11561 -> 11560;
11562 -> 11560;
11563 -> 11560;
11564 -> 11563;
11565 -> 11478;
11565 -> 11564;
11566 -> 11564;
11567 -> 11564;
11568 -> 11564;
11569 -> 11567;
11569 -> 11568;
11570 -> 11567;
11570 -> 11563;
11571 -> 11563;
11572 -> 11563;
11573 -> 11570;
11573 -> 11563;
11574 -> 11571;
11574 -> 11563;
11575 -> 11563;
11576 -> 11558;
11577 -> 0;
11577 -> 11576;
11578 -> 11576;
11579 -> 11577;
11579 -> 11578;
11580 -> 0;
11580 -> 11509;
11581 -> 11509;
11582 -> 11580;
11582 -> 11581;
11583 -> 11478;
11583 -> 11581;
11584 -> 11581;
11585 -> 11583;
11585 -> 11584;
11585 -> 11581;
11586 -> 11581;
11587 -> 11581;
11588 -> 11583;
11588 -> 11587;
11589 -> 11586;
11589 -> 11587;
11590 -> 11587;
11591 -> 11589;
11591 -> 11590;
11592 -> 11591;
11592 -> 11590;
11593 -> 11591;
11593 -> 11590;
11594 -> 11591;
11594 -> 11590;
11595 -> 11591;
11595 -> 11590;
11596 -> 11591;
11596 -> 11590;
11597 -> 11590;
11598 -> 11478;
11598 -> 11597;
11598 -> 11590;
11599 -> 11478;
11599 -> 11590;
11600 -> 0;
11600 -> 11590;
11601 -> 11590;
11602 -> 11599;
11602 -> 11601;
11603 -> 11600;
11603 -> 11601;
11604 -> 11478;
11604 -> 11590;
11605 -> 0;
11605 -> 11590;
11606 -> 11590;
11607 -> 11604;
11607 -> 11606;
11608 -> 11605;
11608 -> 11606;
11609 -> 11589;
11609 -> 11587;
11610 -> 11587;
11611 -> 11587;
11612 -> 11588;
11612 -> 11611;
11613 -> 11610;
11613 -> 11611;
11614 -> 11613;
11614 -> 11611;
11615 -> 11612;
11615 -> 11614;
11616 -> 11588;
11616 -> 11610;
11616 -> 11587;
11617 -> 11588;
11617 -> 11589;
11617 -> 11587;
11618 -> 11586;
11618 -> 11509;
11619 -> 11509;
11620 -> 11509;
11621 -> 11620;
11622 -> 11478;
11623 -> 11622;
11623 -> 11478;
11624 -> 11478;
11625 -> 11478;
11626 -> 11623;
11626 -> 11478;
11627 -> 11478;
11628 -> 11625;
11628 -> 11478;
11629 -> 11622;
11629 -> 11624;
11629 -> 11478;
11630 -> 11628;
11630 -> 11623;
11630 -> 11478;
11631 -> 11630;
11631 -> 11478;
11632 -> 11623;
11633 -> 11623;
11634 -> 11633;
11634 -> 11623;
11635 -> 11632;
11635 -> 11623;
11636 -> 11623;
11636 -> 0;
11637 -> 11623;
11638 -> 11623;
11639 -> 11623;
11640 -> 11639;
11640 -> 11623;
11641 -> 11640;
11642 -> 11640;
11642 -> 11641;
11643 -> 11641;
11644 -> 11642;
11644 -> 11643;
11645 -> 11643;
11646 -> 11644;
11646 -> 11623;
11646 -> 11645;
11646 -> 11643;
11647 -> 11641;
11648 -> 11642;
11648 -> 11623;
11648 -> 11641;
11649 -> 11648;
11649 -> 11640;
11650 -> 11640;
11651 -> 11623;
11652 -> 11651;
11652 -> 11623;
11653 -> 11623;
11654 -> 11635;
11654 -> 11623;
11655 -> 11634;
11655 -> 11623;
11656 -> 11623;
11657 -> 11623;
11658 -> 11623;
11659 -> 11623;
11659 -> 11658;
11660 -> 0;
11660 -> 11658;
11661 -> 11660;
11661 -> 11623;
11662 -> 11623;
11663 -> 11657;
11663 -> 11623;
11664 -> 11623;
11665 -> 11623;
11666 -> 11623;
11667 -> 11623;
11668 -> 11623;
11669 -> 11668;
11669 -> 11623;
11670 -> 11668;
11670 -> 11623;
11671 -> 11670;
11672 -> 11671;
11672 -> 11623;
11673 -> 11623;
11674 -> 11673;
11674 -> 11623;
11675 -> 11623;
11676 -> 11623;
11677 -> 11675;
11677 -> 11623;
11678 -> 11623;
11679 -> 11623;
11679 -> 11678;
11680 -> 0;
11680 -> 11678;
11681 -> 11680;
11681 -> 11623;
11682 -> 11681;
11682 -> 11623;
11683 -> 11623;
11684 -> 11682;
11684 -> 11683;
11685 -> 11677;
11685 -> 11683;
11686 -> 11684;
11686 -> 0;
11686 -> 11683;
11687 -> 11684;
11687 -> 11686;
11688 -> 11623;
11689 -> 11688;
11689 -> 11623;
11690 -> 11623;
11691 -> 11689;
11691 -> 11623;
11692 -> 11689;
11692 -> 11691;
11693 -> 11692;
11693 -> 11623;
11694 -> 11689;
11694 -> 11623;
11695 -> 11681;
11695 -> 11687;
11695 -> 11623;
11696 -> 11695;
11696 -> 11693;
11696 -> 11623;
11697 -> 11623;
11698 -> 11623;
11698 -> 11697;
11699 -> 11697;
11700 -> 11699;
11700 -> 11697;
11701 -> 11700;
11701 -> 11697;
11702 -> 11698;
11702 -> 11697;
11703 -> 11697;
11704 -> 11702;
11704 -> 11703;
11705 -> 11703;
11706 -> 11705;
11706 -> 11697;
11707 -> 11697;
11708 -> 11702;
11708 -> 11707;
11709 -> 11708;
11709 -> 11697;
11710 -> 11697;
11711 -> 11709;
11711 -> 11710;
11712 -> 0;
11712 -> 11710;
11713 -> 11712;
11713 -> 11697;
11714 -> 11706;
11714 -> 11713;
11714 -> 11697;
11715 -> 11697;
11716 -> 11702;
11716 -> 11715;
11717 -> 11716;
11717 -> 11697;
11718 -> 11697;
11719 -> 11717;
11719 -> 11718;
11720 -> 11697;
11721 -> 11719;
11721 -> 11720;
11722 -> 11720;
11722 -> 11697;
11723 -> 11697;
11724 -> 11714;
11724 -> 11722;
11724 -> 11697;
11725 -> 11697;
11726 -> 11702;
11726 -> 11725;
11727 -> 11726;
11727 -> 11697;
11728 -> 11727;
11728 -> 3004;
11728 -> 11697;
11729 -> 11724;
11729 -> 11728;
11729 -> 11697;
11730 -> 11697;
11731 -> 11697;
11731 -> 11623;
11732 -> 11623;
11733 -> 11623;
11733 -> 0;
11734 -> 11623;
11735 -> 11623;
11735 -> 11734;
11736 -> 11734;
11737 -> 11735;
11737 -> 11736;
11738 -> 11623;
11739 -> 11738;
11739 -> 11623;
11740 -> 11623;
11740 -> 11739;
11741 -> 11739;
11742 -> 11740;
11742 -> 11741;
11743 -> 11623;
11743 -> 0;
11744 -> 11623;
11745 -> 11742;
11745 -> 11744;
11745 -> 11623;
11746 -> 11623;
11747 -> 11623;
11748 -> 11623;
11749 -> 11748;
11749 -> 11623;
11750 -> 11623;
11751 -> 11747;
11751 -> 11750;
11752 -> 11750;
11753 -> 11751;
11753 -> 11752;
11754 -> 11752;
11755 -> 11753;
11755 -> 11754;
11756 -> 11754;
11757 -> 11755;
11757 -> 11756;
11758 -> 11757;
11758 -> 11754;
11759 -> 11758;
11759 -> 11752;
11760 -> 11759;
11760 -> 11750;
11761 -> 11760;
11761 -> 11623;
11762 -> 11623;
11763 -> 11747;
11763 -> 11762;
11764 -> 11762;
11765 -> 11763;
11765 -> 11764;
11766 -> 11764;
11767 -> 11765;
11767 -> 11766;
11768 -> 0;
11768 -> 11766;
11769 -> 11768;
11769 -> 11764;
11770 -> 11765;
11770 -> 11762;
11771 -> 11770;
11771 -> 11623;
11772 -> 11623;
11773 -> 11747;
11773 -> 11623;
11774 -> 11623;
11775 -> 11773;
11775 -> 11774;
11776 -> 11772;
11776 -> 11774;
11777 -> 11775;
11777 -> 11774;
11778 -> 11774;
11779 -> 11775;
11779 -> 11778;
11780 -> 11778;
11780 -> 11774;
11781 -> 11774;
11782 -> 11774;
11783 -> 11775;
11783 -> 11782;
11784 -> 0;
11784 -> 11782;
11785 -> 11783;
11785 -> 11774;
11786 -> 11774;
11787 -> 11775;
11787 -> 11786;
11788 -> 11787;
11788 -> 11774;
11789 -> 11788;
11789 -> 11774;
11790 -> 11774;
11791 -> 11790;
11791 -> 11623;
11792 -> 11623;
11793 -> 11623;
11794 -> 11623;
11795 -> 11623;
11796 -> 11795;
11796 -> 11623;
11797 -> 11796;
11797 -> 11623;
11798 -> 11796;
11798 -> 11623;
11799 -> 11798;
11799 -> 11623;
11800 -> 11799;
11800 -> 11623;
11801 -> 11799;
11801 -> 11623;
11802 -> 11623;
11803 -> 11623;
11804 -> 11623;
11805 -> 11623;
11806 -> 11623;
11806 -> 11805;
11807 -> 11805;
11808 -> 11806;
11808 -> 11807;
11809 -> 11807;
11810 -> 11808;
11810 -> 11809;
11811 -> 11809;
11812 -> 11810;
11812 -> 11811;
11813 -> 11812;
11813 -> 11809;
11814 -> 11813;
11814 -> 11807;
11815 -> 11814;
11815 -> 11805;
11816 -> 11815;
11816 -> 11623;
11817 -> 11623;
11818 -> 11623;
11818 -> 11817;
11819 -> 11817;
11820 -> 11819;
11820 -> 11623;
11821 -> 11623;
11822 -> 11651;
11823 -> 11651;
11824 -> 11820;
11824 -> 11651;
11825 -> 11651;
11826 -> 11825;
11827 -> 11651;
11828 -> 11820;
11828 -> 11827;
11828 -> 11651;
11829 -> 11623;
11830 -> 11820;
11830 -> 11829;
11830 -> 11623;
11831 -> 11651;
11831 -> 11623;
11832 -> 11623;
11833 -> 11651;
11834 -> 11651;
11835 -> 11833;
11835 -> 11834;
11836 -> 11834;
11837 -> 11835;
11837 -> 11836;
11837 -> 11834;
11838 -> 11835;
11838 -> 11834;
11839 -> 11834;
11839 -> 11651;
11840 -> 11623;
11841 -> 11623;
11842 -> 11623;
11842 -> 11841;
11843 -> 11841;
11844 -> 11842;
11844 -> 11843;
11845 -> 11844;
11845 -> 11651;
11845 -> 11843;
11846 -> 11843;
11847 -> 11845;
11847 -> 11846;
11848 -> 0;
11848 -> 11846;
11849 -> 11848;
11849 -> 11843;
11850 -> 11845;
11850 -> 11841;
11851 -> 11850;
11851 -> 11623;
11852 -> 11623;
11853 -> 11851;
11853 -> 11852;
11854 -> 11852;
11855 -> 11853;
11855 -> 11854;
11856 -> 11854;
11857 -> 11855;
11857 -> 11856;
11858 -> 11856;
11859 -> 11857;
11859 -> 11651;
11859 -> 11858;
11859 -> 11856;
11860 -> 11854;
11861 -> 11855;
11861 -> 11852;
11862 -> 11852;
11863 -> 11651;
11863 -> 11658;
11864 -> 11651;
11865 -> 11623;
11865 -> 11651;
11866 -> 11865;
11866 -> 11623;
11867 -> 11623;
11868 -> 11866;
11868 -> 11867;
11868 -> 11623;
11869 -> 11633;
11869 -> 11623;
11870 -> 11633;
11870 -> 11623;
11871 -> 11651;
11871 -> 0;
11871 -> 11623;
11872 -> 11651;
11872 -> 11623;
11873 -> 11633;
11873 -> 11872;
11874 -> 11872;
11875 -> 11873;
11875 -> 11874;
11876 -> 11633;
11876 -> 11623;
11877 -> 11876;
11877 -> 11623;
11878 -> 11633;
11878 -> 11877;
11879 -> 11877;
11880 -> 11878;
11880 -> 11879;
11881 -> 11880;
11881 -> 11651;
11881 -> 11879;
11882 -> 11651;
11882 -> 0;
11882 -> 11623;
11883 -> 11881;
11883 -> 11744;
11883 -> 11623;
11884 -> 11633;
11884 -> 11746;
11884 -> 11623;
11885 -> 11651;
11885 -> 11633;
11885 -> 11623;
11886 -> 11623;
11887 -> 11633;
11887 -> 11886;
11888 -> 11887;
11888 -> 11623;
11889 -> 11623;
11890 -> 11889;
11890 -> 11633;
11890 -> 11623;
11891 -> 11623;
11892 -> 11891;
11892 -> 11633;
11892 -> 11623;
11893 -> 11633;
11894 -> 11633;
11895 -> 11633;
11896 -> 11893;
11896 -> 11633;
11897 -> 11894;
11897 -> 11633;
11898 -> 11895;
11898 -> 11633;
11899 -> 11896;
11899 -> 11633;
11900 -> 11897;
11900 -> 11633;
11901 -> 11898;
11901 -> 11633;
11902 -> 11633;
11903 -> 11899;
11903 -> 11633;
11904 -> 11900;
11904 -> 11633;
11905 -> 11901;
11905 -> 11633;
11906 -> 11903;
11906 -> 11633;
11907 -> 11904;
11907 -> 11633;
11908 -> 11905;
11908 -> 11633;
11909 -> 11633;
11910 -> 11908;
11910 -> 11633;
11911 -> 11907;
11911 -> 11633;
11912 -> 11633;
11913 -> 11906;
11913 -> 11633;
11914 -> 11910;
11914 -> 11633;
11915 -> 11911;
11915 -> 11633;
11916 -> 11912;
11916 -> 11633;
11917 -> 11913;
11917 -> 11633;
11918 -> 11633;
11919 -> 11633;
11920 -> 11917;
11920 -> 11919;
11921 -> 11920;
11921 -> 11617;
11921 -> 11919;
11922 -> 11633;
11923 -> 11917;
11923 -> 11922;
11924 -> 11922;
11925 -> 11923;
11925 -> 11924;
11926 -> 11925;
11926 -> 11617;
11926 -> 11924;
11927 -> 11926;
11927 -> 11922;
11928 -> 11927;
11928 -> 11922;
11929 -> 11922;
11930 -> 11927;
11930 -> 11929;
11931 -> 0;
11931 -> 11929;
11932 -> 11931;
11932 -> 11922;
11933 -> 11928;
11933 -> 11932;
11933 -> 11922;
11934 -> 11927;
11934 -> 11922;
11935 -> 11934;
11936 -> 11935;
11936 -> 11651;
11937 -> 11936;
11937 -> 11934;
11938 -> 11914;
11938 -> 11633;
11939 -> 11915;
11939 -> 11633;
11940 -> 11916;
11940 -> 11633;
11941 -> 11921;
11941 -> 11633;
11942 -> 11937;
11942 -> 11633;
11943 -> 11917;
11943 -> 11633;
11944 -> 11633;
11944 -> 11651;
11945 -> 11633;
11946 -> 11633;
11946 -> 11945;
11947 -> 11945;
11947 -> 11633;
11948 -> 11633;
11949 -> 11633;
11949 -> 11948;
11950 -> 11948;
11950 -> 11633;
11951 -> 11942;
11951 -> 11633;
11952 -> 11940;
11952 -> 11633;
11953 -> 11952;
11953 -> 11633;
11954 -> 11938;
11954 -> 11633;
11955 -> 11939;
11955 -> 11633;
11956 -> 11941;
11956 -> 11633;
11957 -> 11943;
11957 -> 11633;
11958 -> 11633;
11959 -> 11954;
11959 -> 11958;
11959 -> 11633;
11960 -> 11956;
11960 -> 11633;
11961 -> 11633;
11962 -> 11633;
11963 -> 11944;
11963 -> 11962;
11964 -> 0;
11964 -> 11962;
11965 -> 11964;
11965 -> 11633;
11966 -> 11944;
11966 -> 6720;
11966 -> 11633;
11967 -> 11944;
11967 -> 6720;
11968 -> 11944;
11969 -> 11944;
11969 -> 6720;
11969 -> 11633;
11970 -> 11944;
11971 -> 11944;
11971 -> 11970;
11972 -> 0;
11972 -> 11970;
11973 -> 11972;
11973 -> 11944;
11974 -> 11944;
11975 -> 11944;
11976 -> 11944;
11976 -> 11633;
11977 -> 11976;
11977 -> 11633;
11978 -> 11633;
11979 -> 11977;
11979 -> 11978;
11979 -> 11633;
11980 -> 11979;
11980 -> 11633;
11981 -> 11980;
11981 -> 11633;
11982 -> 0;
11982 -> 11981;
11983 -> 11633;
11984 -> 11982;
11984 -> 11633;
11985 -> 11633;
11986 -> 11983;
11986 -> 11985;
11986 -> 11633;
11987 -> 11982;
11987 -> 11633;
11988 -> 11987;
11988 -> 11633;
11989 -> 11952;
11989 -> 11988;
11990 -> 11633;
11991 -> 11478;
11992 -> 11478;
11993 -> 11628;
11993 -> 11478;
11994 -> 11478;
11995 -> 11478;
11996 -> 11633;
11996 -> 11995;
11997 -> 11996;
11997 -> 11890;
11997 -> 11995;
11998 -> 11997;
11998 -> 0;
11998 -> 11995;
11999 -> 11998;
11999 -> 11478;
12000 -> 11478;
12001 -> 11633;
12001 -> 12000;
12002 -> 12001;
12002 -> 11633;
12002 -> 12000;
12003 -> 12000;
12004 -> 12002;
12004 -> 12003;
12005 -> 12001;
12005 -> 11633;
12005 -> 12003;
12006 -> 12003;
12007 -> 12004;
12007 -> 12006;
12008 -> 12007;
12008 -> 11944;
12008 -> 0;
12008 -> 12006;
12009 -> 12006;
12010 -> 12008;
12010 -> 11478;
12011 -> 11633;
12011 -> 11625;
12012 -> 12011;
12012 -> 11633;
12012 -> 11885;
12012 -> 11944;
12012 -> 11625;
12013 -> 11627;
12013 -> 12012;
12014 -> 12012;
12015 -> 12012;
12016 -> 12012;
12017 -> 12015;
12017 -> 12016;
12018 -> 12015;
12018 -> 12016;
12019 -> 12015;
12019 -> 12016;
12020 -> 12015;
12020 -> 12016;
12021 -> 12015;
12021 -> 12016;
12022 -> 12018;
12022 -> 12016;
12023 -> 12019;
12023 -> 12016;
12024 -> 12020;
12024 -> 12016;
12025 -> 12021;
12025 -> 12016;
12026 -> 0;
12026 -> 12016;
12027 -> 12016;
12028 -> 12026;
12028 -> 12027;
12029 -> 12017;
12029 -> 12027;
12030 -> 12027;
12031 -> 12029;
12031 -> 12030;
12032 -> 12031;
12032 -> 12027;
12033 -> 12032;
12034 -> 12032;
12034 -> 12033;
12035 -> 12033;
12036 -> 12034;
12036 -> 12035;
12037 -> 12035;
12038 -> 12036;
12038 -> 12012;
12038 -> 12037;
12038 -> 12035;
12039 -> 12033;
12040 -> 12034;
12040 -> 12012;
12040 -> 12033;
12041 -> 12040;
12041 -> 12032;
12042 -> 12032;
12043 -> 12029;
12043 -> 12012;
12043 -> 12028;
12043 -> 12027;
12044 -> 12029;
12044 -> 12012;
12044 -> 12028;
12044 -> 12027;
12045 -> 12016;
12046 -> 12022;
12046 -> 12045;
12047 -> 12023;
12047 -> 12045;
12048 -> 12024;
12048 -> 12045;
12049 -> 12025;
12049 -> 12045;
12050 -> 12044;
12050 -> 12045;
12051 -> 12048;
12051 -> 12015;
12051 -> 12049;
12051 -> 12045;
12052 -> 12046;
12052 -> 12051;
12053 -> 12047;
12053 -> 12051;
12054 -> 12050;
12054 -> 12051;
12055 -> 12051;
12056 -> 12051;
12057 -> 12052;
12057 -> 12056;
12058 -> 12053;
12058 -> 12056;
12059 -> 12054;
12059 -> 12056;
12060 -> 12055;
12060 -> 12056;
12061 -> 12057;
12061 -> 12056;
12062 -> 12058;
12062 -> 12056;
12063 -> 12059;
12063 -> 12056;
12064 -> 12056;
12065 -> 12061;
12065 -> 12064;
12066 -> 12062;
12066 -> 12064;
12067 -> 12063;
12067 -> 12064;
12068 -> 12060;
12068 -> 12064;
12069 -> 12065;
12069 -> 12064;
12070 -> 12067;
12070 -> 12064;
12071 -> 12064;
12072 -> 12069;
12072 -> 12071;
12073 -> 12070;
12073 -> 12071;
12074 -> 12068;
12074 -> 12071;
12075 -> 12072;
12075 -> 12071;
12076 -> 12071;
12077 -> 12073;
12077 -> 12076;
12077 -> 12071;
12078 -> 12068;
12078 -> 12064;
12079 -> 12064;
12080 -> 12066;
12080 -> 12079;
12080 -> 12064;
12081 -> 12066;
12081 -> 12068;
12081 -> 12064;
12082 -> 12055;
12082 -> 12012;
12083 -> 12055;
12083 -> 12012;
12084 -> 12012;
12084 -> 0;
12085 -> 12012;
12086 -> 12055;
12086 -> 12085;
12087 -> 12085;
12088 -> 12086;
12088 -> 12087;
12089 -> 12088;
12089 -> 12087;
12090 -> 12089;
12090 -> 12087;
12091 -> 12090;
12091 -> 12087;
12092 -> 12087;
12092 -> 12085;
12093 -> 12086;
12093 -> 12092;
12093 -> 12085;
12094 -> 12055;
12094 -> 12012;
12095 -> 12094;
12095 -> 12012;
12096 -> 12055;
12096 -> 12095;
12097 -> 12095;
12098 -> 12096;
12098 -> 12097;
12099 -> 12098;
12099 -> 12097;
12100 -> 12099;
12100 -> 12097;
12101 -> 12100;
12101 -> 12097;
12102 -> 12097;
12102 -> 12095;
12103 -> 12012;
12103 -> 0;
12104 -> 12012;
12105 -> 12102;
12105 -> 12104;
12105 -> 12012;
12106 -> 12012;
12107 -> 11478;
12108 -> 12012;
12108 -> 12107;
12109 -> 12108;
12109 -> 12055;
12109 -> 12107;
12110 -> 12109;
12110 -> 11478;
12111 -> 11478;
12112 -> 12111;
12112 -> 11478;
12113 -> 11478;
12114 -> 12113;
12114 -> 11478;
12115 -> 11628;
12115 -> 12012;
12115 -> 11478;
12116 -> 12115;
12116 -> 12055;
12116 -> 11478;
12117 -> 12116;
12118 -> 12116;
12119 -> 12116;
12120 -> 12117;
12120 -> 12116;
12121 -> 12118;
12121 -> 12116;
12122 -> 12119;
12122 -> 12116;
12123 -> 12120;
12123 -> 12116;
12124 -> 12121;
12124 -> 12116;
12125 -> 12122;
12125 -> 12116;
12126 -> 12116;
12126 -> 12012;
12127 -> 12123;
12127 -> 12116;
12128 -> 12124;
12128 -> 12116;
12129 -> 12125;
12129 -> 12116;
12130 -> 12127;
12130 -> 12116;
12131 -> 12128;
12131 -> 12116;
12132 -> 12129;
12132 -> 12116;
12133 -> 12116;
12133 -> 12012;
12134 -> 12132;
12134 -> 12116;
12135 -> 12131;
12135 -> 12116;
12136 -> 12116;
12137 -> 12130;
12137 -> 12116;
12138 -> 12134;
12138 -> 12116;
12139 -> 12135;
12139 -> 12116;
12140 -> 12136;
12140 -> 12116;
12141 -> 12137;
12141 -> 12116;
12142 -> 12116;
12143 -> 0;
12143 -> 12116;
12144 -> 12116;
12145 -> 11478;
12146 -> 12116;
12146 -> 11995;
12147 -> 12146;
12147 -> 12112;
12147 -> 11995;
12148 -> 12147;
12148 -> 0;
12148 -> 11995;
12149 -> 12148;
12149 -> 11478;
12150 -> 11509;
12151 -> 11478;
12151 -> 12150;
12152 -> 12150;
12153 -> 12151;
12153 -> 12152;
12154 -> 12153;
12154 -> 12012;
12154 -> 12152;
12155 -> 12154;
12155 -> 0;
12155 -> 12150;
12156 -> 12150;
12157 -> 12155;
12157 -> 12156;
12157 -> 12150;
12158 -> 12157;
12158 -> 11509;
12159 -> 11481;
12160 -> 12159;
12161 -> 12160;
12162 -> 12160;
12163 -> 11481;
12164 -> 12163;
12165 -> 12116;
12165 -> 12012;
12165 -> 12164;
12166 -> 12164;
12167 -> 12166;
12168 -> 12166;
12169 -> 12166;
12170 -> 12168;
12170 -> 12169;
12171 -> 12116;
12171 -> 12169;
12172 -> 12171;
12172 -> 12169;
12173 -> 12116;
12173 -> 12172;
12174 -> 12172;
12175 -> 12173;
12175 -> 12174;
12176 -> 12175;
12176 -> 12174;
12177 -> 12176;
12177 -> 12174;
12178 -> 12177;
12178 -> 12174;
12179 -> 12174;
12179 -> 12172;
12180 -> 12116;
12180 -> 0;
12180 -> 12169;
12181 -> 12169;
12182 -> 12179;
12182 -> 12181;
12182 -> 12169;
12183 -> 12169;
12184 -> 12012;
12184 -> 12183;
12184 -> 12169;
12185 -> 12168;
12185 -> 12164;
12186 -> 12185;
12186 -> 11481;
12187 -> 11481;
12188 -> 11481;
12189 -> 12186;
12189 -> 12188;
12190 -> 12187;
12190 -> 12188;
12191 -> 12189;
12191 -> 12190;
12191 -> 12188;
12192 -> 12012;
12192 -> 12187;
12192 -> 12191;
12192 -> 12116;
12192 -> 12068;
12192 -> 12073;
12192 -> 12072;
12192 -> 12081;
12192 -> 11633;
12192 -> 11885;
12192 -> 11481;
12193 -> 12192;
12193 -> 12012;
12194 -> 12192;
12195 -> 12192;
12195 -> 12194;
12196 -> 12194;
12197 -> 12196;
12197 -> 12192;
12198 -> 12192;
12198 -> 12197;
12199 -> 12197;
12200 -> 12198;
12200 -> 12199;
12201 -> 12199;
12202 -> 12200;
12202 -> 12201;
12203 -> 12201;
12203 -> 12199;
12204 -> 12203;
12204 -> 12197;
12205 -> 12192;
12205 -> 12204;
12206 -> 12204;
12207 -> 12204;
12208 -> 12205;
12208 -> 12207;
12209 -> 12206;
12209 -> 12207;
12210 -> 12207;
12211 -> 12208;
12211 -> 12210;
12211 -> 12207;
12212 -> 12207;
12213 -> 12208;
12213 -> 12212;
12214 -> 12212;
12214 -> 12207;
12215 -> 12209;
12215 -> 12207;
12216 -> 12215;
12217 -> 12216;
12218 -> 12192;
12218 -> 12217;
12219 -> 12217;
12220 -> 12219;
12220 -> 12216;
12221 -> 12220;
12222 -> 12192;
12222 -> 12221;
12223 -> 12221;
12224 -> 12222;
12224 -> 12223;
12225 -> 12224;
12225 -> 0;
12225 -> 12221;
12226 -> 12221;
12227 -> 12225;
12227 -> 12226;
12227 -> 12221;
12228 -> 12227;
12228 -> 12220;
12229 -> 12228;
12230 -> 12229;
12230 -> 12228;
12231 -> 12192;
12232 -> 12192;
12233 -> 12192;
12234 -> 12233;
12234 -> 12192;
12235 -> 12192;
12236 -> 12192;
12237 -> 12232;
12237 -> 12236;
12237 -> 12192;
12238 -> 12192;
12239 -> 12192;
12239 -> 12238;
12240 -> 12238;
12240 -> 12192;
12241 -> 12233;
12242 -> 12233;
12243 -> 12192;
12244 -> 12243;
12244 -> 12192;
12245 -> 12192;
12246 -> 12233;
12246 -> 12192;
12247 -> 12233;
12247 -> 12238;
12248 -> 12247;
12248 -> 12192;
12249 -> 12248;
12250 -> 12249;
12250 -> 12248;
12251 -> 12248;
12252 -> 12250;
12252 -> 12251;
12252 -> 12248;
12253 -> 12241;
12253 -> 12233;
12254 -> 0;
12254 -> 12233;
12255 -> 12241;
12256 -> 12233;
12256 -> 12255;
12257 -> 0;
12257 -> 12255;
12258 -> 12257;
12258 -> 12241;
12259 -> 12258;
12259 -> 0;
12259 -> 12241;
12260 -> 12259;
12261 -> 12260;
12261 -> 12192;
12262 -> 12192;
12262 -> 12241;
12263 -> 12241;
12264 -> 11477;
12265 -> 12264;
12266 -> 12241;
12266 -> 12265;
12267 -> 0;
12267 -> 1;
12268 -> 1;
12269 -> 12241;
12269 -> 12268;
12270 -> 0;
12270 -> 12268;
12271 -> 12270;
12271 -> 1;
12272 -> 1;
12273 -> 12241;
12273 -> 12272;
12274 -> 12272;
12275 -> 12272;
12276 -> 12273;
12276 -> 12275;
12277 -> 0;
12277 -> 12275;
12278 -> 12277;
12278 -> 12272;
12279 -> 12278;
12280 -> 12273;
12280 -> 12279;
12281 -> 12280;
12281 -> 12241;
12281 -> 12279;
12282 -> 12274;
12282 -> 12278;
12283 -> 12278;
12284 -> 12283;
12285 -> 12284;
12286 -> 12273;
12286 -> 12241;
12286 -> 12285;
12287 -> 12272;
12288 -> 12287;
12289 -> 12287;
12290 -> 12281;
12290 -> 1;
12291 -> 1;
12292 -> 12241;
12292 -> 12291;
12293 -> 12291;
12294 -> 12291;
12295 -> 12292;
12295 -> 12294;
12296 -> 0;
12296 -> 12294;
12297 -> 12296;
12297 -> 12291;
12298 -> 12297;
12299 -> 12292;
12299 -> 12298;
12300 -> 12299;
12300 -> 12281;
12300 -> 12298;
12301 -> 12293;
12301 -> 12297;
12302 -> 12297;
12303 -> 12302;
12304 -> 12292;
12304 -> 12281;
12304 -> 12303;
12305 -> 12303;
12306 -> 12304;
12306 -> 12281;
12306 -> 12305;
12307 -> 12291;
12308 -> 12307;
12309 -> 12307;
12310 -> 12304;
12310 -> 1;
12311 -> 12290;
12311 -> 1;
12312 -> 12310;
12312 -> 1;
12313 -> 12311;
12313 -> 12312;
12313 -> 1;
}