digraph G {
0 [label="EXTERNAL"];
1 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 151648"];
2 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 151649"];
3 [label="RuntimeHelpers.RunModuleConstructor(typeof(TestBase).Module.ModuleHandle); 151650"];
4 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 151651"];
5 [label="NullableAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 151652"];
6 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 151653"];
7 [label="NullableContextAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 151654"];
8 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 151655"];
9 [label="NullablePublicOnlyAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 151656"];
10 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 151657"];
11 [label="AllowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 151658"];
12 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 151659"];
13 [label="DisallowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 151660"];
14 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 151661"];
15 [label="MaybeNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 151662"];
16 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 151663"];
17 [label="MaybeNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 151664"];
18 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 151665"];
19 [label="NotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 151666"];
20 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 151667"];
21 [label="NotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 151668"];
22 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 151669"];
23 [label="MemberNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 151670"];
24 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 151671"];
25 [label="MemberNotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 151672"];
26 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 151673"];
27 [label="DoesNotReturnIfAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 151674"];
28 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 151675"];
29 [label="DoesNotReturnAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 151676"];
30 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 151677"];
31 [label="NotNullIfNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 151678"];
32 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 151679"];
33 [label="IsExternalInitTypeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 151680"];
34 [label="@'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 151681"];
35 [label="IAsyncDisposableDefinition = @'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 151682"];
36 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 151683"];
37 [label="AsyncStreamsTypes = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 151684"];
38 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 151685"];
39 [label="EnumeratorCancellationAttributeType = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 151686"];
40 [label="@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 151687"];
41 [label="NativeIntegerAttributeDefinition =\n@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 151688"];
42 [label="() => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic } 151689"];
43 [label="LazyThreadSafetyMode.PublicationOnly 151690"];
44 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 151691"];
45 [label="s_lazyDefaultVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 151692"];
46 [label="() => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic } 151693"];
47 [label="LazyThreadSafetyMode.PublicationOnly 151694"];
48 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 151695"];
49 [label="s_lazyLatestVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 151696"];
50 [label="RuntimeUtilities.IsCoreClrRuntime 151697"];
51 [label="'netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' 151698"];
52 [label="new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51') 151699"];
53 [label="RuntimeCorLibName = RuntimeUtilities.IsCoreClrRuntime\n            ? new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51')\n            : new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 151700"];
54 [label="() =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            } 151701"];
55 [label="LazyThreadSafetyMode.PublicationOnly 151702"];
56 [label="new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 151703"];
57 [label="s_winRtRefs = new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 151704"];
58 [label="() => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref } 151705"];
59 [label="LazyThreadSafetyMode.PublicationOnly 151706"];
60 [label="new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 151707"];
61 [label="s_portableRefsMinimal = new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 151708"];
62 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll') 151709"];
63 [label="LazyThreadSafetyMode.PublicationOnly 151710"];
64 [label="new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 151711"];
65 [label="s_systemCoreRef =\n            new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 151712"];
66 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll') 151713"];
67 [label="LazyThreadSafetyMode.PublicationOnly 151714"];
68 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151715"];
69 [label="s_systemCoreRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151716"];
70 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll') 151717"];
71 [label="LazyThreadSafetyMode.PublicationOnly 151718"];
72 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151719"];
73 [label="s_systemCoreRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151720"];
74 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll') 151721"];
75 [label="LazyThreadSafetyMode.PublicationOnly 151722"];
76 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151723"];
77 [label="s_systemWindowsFormsRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151724"];
78 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll') 151725"];
79 [label="LazyThreadSafetyMode.PublicationOnly 151726"];
80 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151727"];
81 [label="s_systemDrawingRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151728"];
82 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll') 151729"];
83 [label="LazyThreadSafetyMode.PublicationOnly 151730"];
84 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151731"];
85 [label="s_systemDataRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151732"];
86 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll') 151733"];
87 [label="LazyThreadSafetyMode.PublicationOnly 151734"];
88 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151735"];
89 [label="s_mscorlibRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151736"];
90 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll') 151737"];
91 [label="LazyThreadSafetyMode.PublicationOnly 151738"];
92 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151739"];
93 [label="s_mscorlibRefPortable = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151740"];
94 [label="() =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            } 151741"];
95 [label="LazyThreadSafetyMode.PublicationOnly 151742"];
96 [label="new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 151743"];
97 [label="s_aacorlibRef = new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 151744"];
98 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri') 151745"];
99 [label="LazyThreadSafetyMode.PublicationOnly 151746"];
100 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 151747"];
101 [label="s_mscorlibRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 151748"];
102 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll') 151749"];
103 [label="LazyThreadSafetyMode.PublicationOnly 151750"];
104 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151751"];
105 [label="s_mscorlibRef_silverlight = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151752"];
106 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll') 151753"];
107 [label="LazyThreadSafetyMode.PublicationOnly 151754"];
108 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151755"];
109 [label="s_desktopCSharpRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151756"];
110 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll') 151757"];
111 [label="LazyThreadSafetyMode.PublicationOnly 151758"];
112 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151759"];
113 [label="s_std20Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151760"];
114 [label="() => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll') 151761"];
115 [label="LazyThreadSafetyMode.PublicationOnly 151762"];
116 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151763"];
117 [label="s_46NetStandardFacade = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151764"];
118 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)') 151765"];
119 [label="LazyThreadSafetyMode.PublicationOnly 151766"];
120 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 151767"];
121 [label="s_systemDynamicRuntimeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 151768"];
122 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll') 151769"];
123 [label="LazyThreadSafetyMode.PublicationOnly 151770"];
124 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151771"];
125 [label="s_systemRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151772"];
126 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll') 151773"];
127 [label="LazyThreadSafetyMode.PublicationOnly 151774"];
128 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151775"];
129 [label="s_systemRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151776"];
130 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll') 151777"];
131 [label="LazyThreadSafetyMode.PublicationOnly 151778"];
132 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151779"];
133 [label="s_systemRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151780"];
134 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll') 151781"];
135 [label="LazyThreadSafetyMode.PublicationOnly 151782"];
136 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151783"];
137 [label="s_systemRef_v20 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151784"];
138 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll') 151785"];
139 [label="LazyThreadSafetyMode.PublicationOnly 151786"];
140 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151787"];
141 [label="s_systemXmlRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151788"];
142 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll') 151789"];
143 [label="LazyThreadSafetyMode.PublicationOnly 151790"];
144 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151791"];
145 [label="s_systemXmlLinqRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151792"];
146 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll') 151793"];
147 [label="LazyThreadSafetyMode.PublicationOnly 151794"];
148 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151795"];
149 [label="s_mscorlibFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151796"];
150 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll') 151797"];
151 [label="LazyThreadSafetyMode.PublicationOnly 151798"];
152 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151799"];
153 [label="s_systemRuntimeFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151800"];
154 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll') 151801"];
155 [label="LazyThreadSafetyMode.PublicationOnly 151802"];
156 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151803"];
157 [label="s_systemThreadingFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151804"];
158 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll') 151805"];
159 [label="LazyThreadSafetyMode.PublicationOnly 151806"];
160 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151807"];
161 [label="s_systemThreadingTasksFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151808"];
162 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll') 151809"];
163 [label="LazyThreadSafetyMode.PublicationOnly 151810"];
164 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151811"];
165 [label="s_mscorlibPP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151812"];
166 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll') 151813"];
167 [label="LazyThreadSafetyMode.PublicationOnly 151814"];
168 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151815"];
169 [label="s_systemRuntimePP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151816"];
170 [label="() => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll') 151817"];
171 [label="LazyThreadSafetyMode.PublicationOnly 151818"];
172 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151819"];
173 [label="s_FSharpTestLibraryRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 151820"];
174 [label="@'R:\\Invalid.dll' 151821"];
175 [label="fullPath: @'R:\\Invalid.dll' 151822"];
176 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 151823"];
177 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 151824"];
178 [label="InvalidRef = new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 151825"];
179 [label="MscorlibRef_v4_0_30316_17626 151826"];
180 [label="Net451.mscorlib 151827"];
181 [label="ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 151828"];
182 [label="s_scriptRefs = ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 151829"];
183 [label="'/*<bind>*/' 151830"];
184 [label="StartString = '/*<bind>*/' 151831"];
185 [label="'/*</bind>*/' 151832"];
186 [label="EndString = '/*</bind>*/' 151833"];
187 [label="@'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 151834"];
188 [label="SpanSource = @'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 151835"];
189 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 151836"];
190 [label="s_IAsyncEnumerable = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 151837"];
191 [label="param StatementParsingTests(ITestOutputHelper output) 151838"];
192 [label="param StatementParsingTests(this) 151839"];
193 [label="output 151840"];
194 [label="param ParsingTests(ITestOutputHelper output) 151841"];
195 [label="param ParsingTests(this) 151842"];
196 [label="param CSharpTestBase(this) 151843"];
197 [label="param CommonTestBase(this) 151844"];
198 [label="param TestBase(this) 151845"];
199 [label="_temp 151846"];
200 [label="_node 151847"];
201 [label="_treeEnumerator 151848"];
202 [label="_output 151849"];
203 [label="this._output 151850"];
204 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 151851"];
205 [label="param TestSwitchWithMultipleCases(this) 151852"];
206 [label="var text = 'switch (a) { case b:; case c:; }'; 151853"];
207 [label="var statement = this.ParseStatement(text); 151854"];
208 [label="var statement = this.ParseStatement(text); 151855"];
209 [label="this.ParseStatement(text) 151856"];
210 [label="param ParseStatement(string text) 151857"];
211 [label="param ParseStatement(int offset = 0) 151858"];
212 [label="param ParseStatement(ParseOptions options = null) 151859"];
213 [label="param ParseStatement(this) 151860"];
214 [label="'\\r\\n' 151861"];
215 [label="CrLf = '\\r\\n' 151862"];
216 [label="CrLf 151863"];
217 [label="EndOfLine(CrLf) 151864"];
218 [label="param EndOfLine(string text) 151865"];
219 [label="param EndOfLine(bool elastic = false) 151866"];
220 [label="SyntaxTrivia trivia = null; 151867"];
221 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 151868"];
222 [label="elastic 151869"];
223 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 151870"];
224 [label="if (trivia != null)\n            {\n                return trivia;\n            } 151871"];
225 [label="if (trivia != null)\n            {\n                return trivia;\n            } 151872"];
226 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTrivia), r => new SyntaxTrivia(r)); 151873"];
227 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 151874"];
228 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 151875"];
229 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 151876"];
230 [label="param Create(SyntaxKind kind) 151877"];
231 [label="param Create(string text) 151878"];
232 [label="return new SyntaxTrivia(kind, text); 151879"];
233 [label="return new SyntaxTrivia(kind, text); 151880"];
234 [label="return new SyntaxTrivia(kind, text); 151881"];
235 [label="new SyntaxTrivia(kind, text) 151882"];
236 [label="param SyntaxTrivia(SyntaxKind kind) 151883"];
237 [label="param SyntaxTrivia(string text) 151884"];
238 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 151885"];
239 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 151886"];
240 [label="param SyntaxTrivia(this) 151887"];
241 [label="kind 151888"];
242 [label="diagnostics 151889"];
243 [label="annotations 151890"];
244 [label="new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 151891"];
245 [label="s_structuresTable\n            = new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 151892"];
246 [label="text 151893"];
247 [label="param SyntaxTrivia(this) 151894"];
248 [label="param CSharpSyntaxNode(SyntaxKind kind) 151895"];
249 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 151896"];
250 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 151897"];
251 [label="param CSharpSyntaxNode(int fullWidth) 151898"];
252 [label="param CSharpSyntaxNode(this) 151899"];
253 [label="kind 151900"];
254 [label="diagnostics 151901"];
255 [label="annotations 151902"];
256 [label="fullWidth 151903"];
257 [label="param CSharpSyntaxNode(this) 151904"];
258 [label="param CSharpSyntaxNode(this) 151905"];
259 [label="GreenStats.NoteGreen(this); 151906"];
260 [label="GreenStats.NoteGreen(this); 151907"];
261 [label="Text 151908"];
262 [label="this.Text 151909"];
263 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 151910"];
264 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 151911"];
265 [label="if (!elastic)\n            {\n                return trivia;\n            } 151912"];
266 [label="return trivia; 151913"];
267 [label="CarriageReturnLineFeed = EndOfLine(CrLf) 151914"];
268 [label="'\\n' 151915"];
269 [label="EndOfLine('\\n') 151916"];
270 [label="param EndOfLine(string text) 151917"];
271 [label="param EndOfLine(bool elastic = false) 151918"];
272 [label="SyntaxTrivia trivia = null; 151919"];
273 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 151920"];
274 [label="elastic 151921"];
275 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 151922"];
276 [label="if (trivia != null)\n            {\n                return trivia;\n            } 151923"];
277 [label="if (trivia != null)\n            {\n                return trivia;\n            } 151924"];
278 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 151925"];
279 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 151926"];
280 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 151927"];
281 [label="param Create(SyntaxKind kind) 151928"];
282 [label="param Create(string text) 151929"];
283 [label="return new SyntaxTrivia(kind, text); 151930"];
284 [label="return new SyntaxTrivia(kind, text); 151931"];
285 [label="return new SyntaxTrivia(kind, text); 151932"];
286 [label="new SyntaxTrivia(kind, text) 151933"];
287 [label="param SyntaxTrivia(SyntaxKind kind) 151934"];
288 [label="param SyntaxTrivia(string text) 151935"];
289 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 151936"];
290 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 151937"];
291 [label="param SyntaxTrivia(this) 151938"];
292 [label="kind 151939"];
293 [label="diagnostics 151940"];
294 [label="annotations 151941"];
295 [label="text 151942"];
296 [label="param SyntaxTrivia(this) 151943"];
297 [label="param CSharpSyntaxNode(SyntaxKind kind) 151944"];
298 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 151945"];
299 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 151946"];
300 [label="param CSharpSyntaxNode(int fullWidth) 151947"];
301 [label="param CSharpSyntaxNode(this) 151948"];
302 [label="kind 151949"];
303 [label="diagnostics 151950"];
304 [label="annotations 151951"];
305 [label="fullWidth 151952"];
306 [label="param CSharpSyntaxNode(this) 151953"];
307 [label="param CSharpSyntaxNode(this) 151954"];
308 [label="GreenStats.NoteGreen(this); 151955"];
309 [label="GreenStats.NoteGreen(this); 151956"];
310 [label="Text 151957"];
311 [label="this.Text 151958"];
312 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 151959"];
313 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 151960"];
314 [label="if (!elastic)\n            {\n                return trivia;\n            } 151961"];
315 [label="return trivia; 151962"];
316 [label="LineFeed = EndOfLine('\\n') 151963"];
317 [label="'\\r' 151964"];
318 [label="EndOfLine('\\r') 151965"];
319 [label="param EndOfLine(string text) 151966"];
320 [label="param EndOfLine(bool elastic = false) 151967"];
321 [label="SyntaxTrivia trivia = null; 151968"];
322 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 151969"];
323 [label="elastic 151970"];
324 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 151971"];
325 [label="if (trivia != null)\n            {\n                return trivia;\n            } 151972"];
326 [label="if (trivia != null)\n            {\n                return trivia;\n            } 151973"];
327 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 151974"];
328 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 151975"];
329 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 151976"];
330 [label="param Create(SyntaxKind kind) 151977"];
331 [label="param Create(string text) 151978"];
332 [label="return new SyntaxTrivia(kind, text); 151979"];
333 [label="return new SyntaxTrivia(kind, text); 151980"];
334 [label="return new SyntaxTrivia(kind, text); 151981"];
335 [label="new SyntaxTrivia(kind, text) 151982"];
336 [label="param SyntaxTrivia(SyntaxKind kind) 151983"];
337 [label="param SyntaxTrivia(string text) 151984"];
338 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 151985"];
339 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 151986"];
340 [label="param SyntaxTrivia(this) 151987"];
341 [label="kind 151988"];
342 [label="diagnostics 151989"];
343 [label="annotations 151990"];
344 [label="text 151991"];
345 [label="param SyntaxTrivia(this) 151992"];
346 [label="param CSharpSyntaxNode(SyntaxKind kind) 151993"];
347 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 151994"];
348 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 151995"];
349 [label="param CSharpSyntaxNode(int fullWidth) 151996"];
350 [label="param CSharpSyntaxNode(this) 151997"];
351 [label="kind 151998"];
352 [label="diagnostics 151999"];
353 [label="annotations 152000"];
354 [label="fullWidth 152001"];
355 [label="param CSharpSyntaxNode(this) 152002"];
356 [label="param CSharpSyntaxNode(this) 152003"];
357 [label="GreenStats.NoteGreen(this); 152004"];
358 [label="GreenStats.NoteGreen(this); 152005"];
359 [label="Text 152006"];
360 [label="this.Text 152007"];
361 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152008"];
362 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152009"];
363 [label="if (!elastic)\n            {\n                return trivia;\n            } 152010"];
364 [label="return trivia; 152011"];
365 [label="CarriageReturn = EndOfLine('\\r') 152012"];
366 [label="' ' 152013"];
367 [label="Whitespace(' ') 152014"];
368 [label="param Whitespace(string text) 152015"];
369 [label="param Whitespace(bool elastic = false) 152016"];
370 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152017"];
371 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152018"];
372 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 152019"];
373 [label="param Create(SyntaxKind kind) 152020"];
374 [label="param Create(string text) 152021"];
375 [label="return new SyntaxTrivia(kind, text); 152022"];
376 [label="return new SyntaxTrivia(kind, text); 152023"];
377 [label="return new SyntaxTrivia(kind, text); 152024"];
378 [label="new SyntaxTrivia(kind, text) 152025"];
379 [label="param SyntaxTrivia(SyntaxKind kind) 152026"];
380 [label="param SyntaxTrivia(string text) 152027"];
381 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152028"];
382 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152029"];
383 [label="param SyntaxTrivia(this) 152030"];
384 [label="kind 152031"];
385 [label="diagnostics 152032"];
386 [label="annotations 152033"];
387 [label="text 152034"];
388 [label="param SyntaxTrivia(this) 152035"];
389 [label="param CSharpSyntaxNode(SyntaxKind kind) 152036"];
390 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152037"];
391 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152038"];
392 [label="param CSharpSyntaxNode(int fullWidth) 152039"];
393 [label="param CSharpSyntaxNode(this) 152040"];
394 [label="kind 152041"];
395 [label="diagnostics 152042"];
396 [label="annotations 152043"];
397 [label="fullWidth 152044"];
398 [label="param CSharpSyntaxNode(this) 152045"];
399 [label="param CSharpSyntaxNode(this) 152046"];
400 [label="GreenStats.NoteGreen(this); 152047"];
401 [label="GreenStats.NoteGreen(this); 152048"];
402 [label="Text 152049"];
403 [label="this.Text 152050"];
404 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152051"];
405 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152052"];
406 [label="if (!elastic)\n            {\n                return trivia;\n            } 152053"];
407 [label="return trivia; 152054"];
408 [label="Space = Whitespace(' ') 152055"];
409 [label="'\\t' 152056"];
410 [label="Whitespace('\\t') 152057"];
411 [label="param Whitespace(string text) 152058"];
412 [label="param Whitespace(bool elastic = false) 152059"];
413 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152060"];
414 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152061"];
415 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 152062"];
416 [label="param Create(SyntaxKind kind) 152063"];
417 [label="param Create(string text) 152064"];
418 [label="return new SyntaxTrivia(kind, text); 152065"];
419 [label="return new SyntaxTrivia(kind, text); 152066"];
420 [label="return new SyntaxTrivia(kind, text); 152067"];
421 [label="new SyntaxTrivia(kind, text) 152068"];
422 [label="param SyntaxTrivia(SyntaxKind kind) 152069"];
423 [label="param SyntaxTrivia(string text) 152070"];
424 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152071"];
425 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152072"];
426 [label="param SyntaxTrivia(this) 152073"];
427 [label="kind 152074"];
428 [label="diagnostics 152075"];
429 [label="annotations 152076"];
430 [label="text 152077"];
431 [label="param SyntaxTrivia(this) 152078"];
432 [label="param CSharpSyntaxNode(SyntaxKind kind) 152079"];
433 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152080"];
434 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152081"];
435 [label="param CSharpSyntaxNode(int fullWidth) 152082"];
436 [label="param CSharpSyntaxNode(this) 152083"];
437 [label="kind 152084"];
438 [label="diagnostics 152085"];
439 [label="annotations 152086"];
440 [label="fullWidth 152087"];
441 [label="param CSharpSyntaxNode(this) 152088"];
442 [label="param CSharpSyntaxNode(this) 152089"];
443 [label="GreenStats.NoteGreen(this); 152090"];
444 [label="GreenStats.NoteGreen(this); 152091"];
445 [label="Text 152092"];
446 [label="this.Text 152093"];
447 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152094"];
448 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152095"];
449 [label="if (!elastic)\n            {\n                return trivia;\n            } 152096"];
450 [label="return trivia; 152097"];
451 [label="Tab = Whitespace('\\t') 152098"];
452 [label="CrLf 152099"];
453 [label="true 152100"];
454 [label="elastic: true 152101"];
455 [label="EndOfLine(CrLf, elastic: true) 152102"];
456 [label="param EndOfLine(string text) 152103"];
457 [label="param EndOfLine(bool elastic = false) 152104"];
458 [label="SyntaxTrivia trivia = null; 152105"];
459 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 152106"];
460 [label="elastic 152107"];
461 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 152108"];
462 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152109"];
463 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152110"];
464 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152111"];
465 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152112"];
466 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 152113"];
467 [label="param Create(SyntaxKind kind) 152114"];
468 [label="param Create(string text) 152115"];
469 [label="return new SyntaxTrivia(kind, text); 152116"];
470 [label="return new SyntaxTrivia(kind, text); 152117"];
471 [label="return new SyntaxTrivia(kind, text); 152118"];
472 [label="new SyntaxTrivia(kind, text) 152119"];
473 [label="param SyntaxTrivia(SyntaxKind kind) 152120"];
474 [label="param SyntaxTrivia(string text) 152121"];
475 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152122"];
476 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152123"];
477 [label="param SyntaxTrivia(this) 152124"];
478 [label="kind 152125"];
479 [label="diagnostics 152126"];
480 [label="annotations 152127"];
481 [label="text 152128"];
482 [label="param SyntaxTrivia(this) 152129"];
483 [label="param CSharpSyntaxNode(SyntaxKind kind) 152130"];
484 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152131"];
485 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152132"];
486 [label="param CSharpSyntaxNode(int fullWidth) 152133"];
487 [label="param CSharpSyntaxNode(this) 152134"];
488 [label="kind 152135"];
489 [label="diagnostics 152136"];
490 [label="annotations 152137"];
491 [label="fullWidth 152138"];
492 [label="param CSharpSyntaxNode(this) 152139"];
493 [label="param CSharpSyntaxNode(this) 152140"];
494 [label="GreenStats.NoteGreen(this); 152141"];
495 [label="GreenStats.NoteGreen(this); 152142"];
496 [label="Text 152143"];
497 [label="this.Text 152144"];
498 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152145"];
499 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152146"];
500 [label="if (!elastic)\n            {\n                return trivia;\n            } 152147"];
501 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152148"];
502 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152149"];
503 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 152150"];
504 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152151"];
505 [label="param SetAnnotations(SyntaxAnnotation[]? annotations) 152152"];
506 [label="param SetAnnotations(this) 152153"];
507 [label="this.Kind 152154"];
508 [label="get { return (SyntaxKind)this.RawKind; } 152155"];
509 [label="return (SyntaxKind)this.RawKind; 152156"];
510 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152157"];
511 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152158"];
512 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152159"];
513 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152160"];
514 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 152161"];
515 [label="param SyntaxTrivia(SyntaxKind kind) 152162"];
516 [label="param SyntaxTrivia(string text) 152163"];
517 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152164"];
518 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152165"];
519 [label="param SyntaxTrivia(this) 152166"];
520 [label="param SyntaxTrivia(this) 152167"];
521 [label="param CSharpSyntaxNode(this) 152168"];
522 [label="param CSharpSyntaxNode(this) 152169"];
523 [label="param CSharpSyntaxNode(this) 152170"];
524 [label="GreenStats.NoteGreen(this); 152171"];
525 [label="Text 152172"];
526 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152173"];
527 [label="ElasticCarriageReturnLineFeed = EndOfLine(CrLf, elastic: true) 152174"];
528 [label="'\\n' 152175"];
529 [label="true 152176"];
530 [label="elastic: true 152177"];
531 [label="EndOfLine('\\n', elastic: true) 152178"];
532 [label="param EndOfLine(string text) 152179"];
533 [label="param EndOfLine(bool elastic = false) 152180"];
534 [label="SyntaxTrivia trivia = null; 152181"];
535 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 152182"];
536 [label="elastic 152183"];
537 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 152184"];
538 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152185"];
539 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152186"];
540 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152187"];
541 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152188"];
542 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 152189"];
543 [label="param Create(SyntaxKind kind) 152190"];
544 [label="param Create(string text) 152191"];
545 [label="return new SyntaxTrivia(kind, text); 152192"];
546 [label="return new SyntaxTrivia(kind, text); 152193"];
547 [label="return new SyntaxTrivia(kind, text); 152194"];
548 [label="new SyntaxTrivia(kind, text) 152195"];
549 [label="param SyntaxTrivia(SyntaxKind kind) 152196"];
550 [label="param SyntaxTrivia(string text) 152197"];
551 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152198"];
552 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152199"];
553 [label="param SyntaxTrivia(this) 152200"];
554 [label="kind 152201"];
555 [label="diagnostics 152202"];
556 [label="annotations 152203"];
557 [label="text 152204"];
558 [label="param SyntaxTrivia(this) 152205"];
559 [label="param CSharpSyntaxNode(SyntaxKind kind) 152206"];
560 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152207"];
561 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152208"];
562 [label="param CSharpSyntaxNode(int fullWidth) 152209"];
563 [label="param CSharpSyntaxNode(this) 152210"];
564 [label="kind 152211"];
565 [label="diagnostics 152212"];
566 [label="annotations 152213"];
567 [label="fullWidth 152214"];
568 [label="param CSharpSyntaxNode(this) 152215"];
569 [label="param CSharpSyntaxNode(this) 152216"];
570 [label="GreenStats.NoteGreen(this); 152217"];
571 [label="GreenStats.NoteGreen(this); 152218"];
572 [label="Text 152219"];
573 [label="this.Text 152220"];
574 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152221"];
575 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152222"];
576 [label="if (!elastic)\n            {\n                return trivia;\n            } 152223"];
577 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152224"];
578 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152225"];
579 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 152226"];
580 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152227"];
581 [label="this.Kind 152228"];
582 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152229"];
583 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 152230"];
584 [label="param SyntaxTrivia(this) 152231"];
585 [label="param SyntaxTrivia(this) 152232"];
586 [label="param CSharpSyntaxNode(this) 152233"];
587 [label="param CSharpSyntaxNode(this) 152234"];
588 [label="GreenStats.NoteGreen(this); 152235"];
589 [label="Text 152236"];
590 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152237"];
591 [label="ElasticLineFeed = EndOfLine('\\n', elastic: true) 152238"];
592 [label="'\\r' 152239"];
593 [label="true 152240"];
594 [label="elastic: true 152241"];
595 [label="EndOfLine('\\r', elastic: true) 152242"];
596 [label="param EndOfLine(string text) 152243"];
597 [label="param EndOfLine(bool elastic = false) 152244"];
598 [label="SyntaxTrivia trivia = null; 152245"];
599 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 152246"];
600 [label="elastic 152247"];
601 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 152248"];
602 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152249"];
603 [label="if (trivia != null)\n            {\n                return trivia;\n            } 152250"];
604 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152251"];
605 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152252"];
606 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 152253"];
607 [label="param Create(SyntaxKind kind) 152254"];
608 [label="param Create(string text) 152255"];
609 [label="return new SyntaxTrivia(kind, text); 152256"];
610 [label="return new SyntaxTrivia(kind, text); 152257"];
611 [label="return new SyntaxTrivia(kind, text); 152258"];
612 [label="new SyntaxTrivia(kind, text) 152259"];
613 [label="param SyntaxTrivia(SyntaxKind kind) 152260"];
614 [label="param SyntaxTrivia(string text) 152261"];
615 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152262"];
616 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152263"];
617 [label="param SyntaxTrivia(this) 152264"];
618 [label="kind 152265"];
619 [label="diagnostics 152266"];
620 [label="annotations 152267"];
621 [label="text 152268"];
622 [label="param SyntaxTrivia(this) 152269"];
623 [label="param CSharpSyntaxNode(SyntaxKind kind) 152270"];
624 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152271"];
625 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152272"];
626 [label="param CSharpSyntaxNode(int fullWidth) 152273"];
627 [label="param CSharpSyntaxNode(this) 152274"];
628 [label="kind 152275"];
629 [label="diagnostics 152276"];
630 [label="annotations 152277"];
631 [label="fullWidth 152278"];
632 [label="param CSharpSyntaxNode(this) 152279"];
633 [label="param CSharpSyntaxNode(this) 152280"];
634 [label="GreenStats.NoteGreen(this); 152281"];
635 [label="GreenStats.NoteGreen(this); 152282"];
636 [label="Text 152283"];
637 [label="this.Text 152284"];
638 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152285"];
639 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 152286"];
640 [label="if (!elastic)\n            {\n                return trivia;\n            } 152287"];
641 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152288"];
642 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152289"];
643 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 152290"];
644 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152291"];
645 [label="this.Kind 152292"];
646 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152293"];
647 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 152294"];
648 [label="param SyntaxTrivia(this) 152295"];
649 [label="param SyntaxTrivia(this) 152296"];
650 [label="param CSharpSyntaxNode(this) 152297"];
651 [label="param CSharpSyntaxNode(this) 152298"];
652 [label="GreenStats.NoteGreen(this); 152299"];
653 [label="Text 152300"];
654 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152301"];
655 [label="ElasticCarriageReturn = EndOfLine('\\r', elastic: true) 152302"];
656 [label="' ' 152303"];
657 [label="true 152304"];
658 [label="elastic: true 152305"];
659 [label="Whitespace(' ', elastic: true) 152306"];
660 [label="param Whitespace(string text) 152307"];
661 [label="param Whitespace(bool elastic = false) 152308"];
662 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152309"];
663 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152310"];
664 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 152311"];
665 [label="param Create(SyntaxKind kind) 152312"];
666 [label="param Create(string text) 152313"];
667 [label="return new SyntaxTrivia(kind, text); 152314"];
668 [label="return new SyntaxTrivia(kind, text); 152315"];
669 [label="return new SyntaxTrivia(kind, text); 152316"];
670 [label="new SyntaxTrivia(kind, text) 152317"];
671 [label="param SyntaxTrivia(SyntaxKind kind) 152318"];
672 [label="param SyntaxTrivia(string text) 152319"];
673 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152320"];
674 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152321"];
675 [label="param SyntaxTrivia(this) 152322"];
676 [label="kind 152323"];
677 [label="diagnostics 152324"];
678 [label="annotations 152325"];
679 [label="text 152326"];
680 [label="param SyntaxTrivia(this) 152327"];
681 [label="param CSharpSyntaxNode(SyntaxKind kind) 152328"];
682 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152329"];
683 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152330"];
684 [label="param CSharpSyntaxNode(int fullWidth) 152331"];
685 [label="param CSharpSyntaxNode(this) 152332"];
686 [label="kind 152333"];
687 [label="diagnostics 152334"];
688 [label="annotations 152335"];
689 [label="fullWidth 152336"];
690 [label="param CSharpSyntaxNode(this) 152337"];
691 [label="param CSharpSyntaxNode(this) 152338"];
692 [label="GreenStats.NoteGreen(this); 152339"];
693 [label="GreenStats.NoteGreen(this); 152340"];
694 [label="Text 152341"];
695 [label="this.Text 152342"];
696 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152343"];
697 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152344"];
698 [label="if (!elastic)\n            {\n                return trivia;\n            } 152345"];
699 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152346"];
700 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152347"];
701 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 152348"];
702 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152349"];
703 [label="this.Kind 152350"];
704 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152351"];
705 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 152352"];
706 [label="param SyntaxTrivia(this) 152353"];
707 [label="param SyntaxTrivia(this) 152354"];
708 [label="param CSharpSyntaxNode(this) 152355"];
709 [label="param CSharpSyntaxNode(this) 152356"];
710 [label="GreenStats.NoteGreen(this); 152357"];
711 [label="Text 152358"];
712 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152359"];
713 [label="ElasticSpace = Whitespace(' ', elastic: true) 152360"];
714 [label="'\\t' 152361"];
715 [label="true 152362"];
716 [label="elastic: true 152363"];
717 [label="Whitespace('\\t', elastic: true) 152364"];
718 [label="param Whitespace(string text) 152365"];
719 [label="param Whitespace(bool elastic = false) 152366"];
720 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152367"];
721 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152368"];
722 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 152369"];
723 [label="param Create(SyntaxKind kind) 152370"];
724 [label="param Create(string text) 152371"];
725 [label="return new SyntaxTrivia(kind, text); 152372"];
726 [label="return new SyntaxTrivia(kind, text); 152373"];
727 [label="return new SyntaxTrivia(kind, text); 152374"];
728 [label="new SyntaxTrivia(kind, text) 152375"];
729 [label="param SyntaxTrivia(SyntaxKind kind) 152376"];
730 [label="param SyntaxTrivia(string text) 152377"];
731 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152378"];
732 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152379"];
733 [label="param SyntaxTrivia(this) 152380"];
734 [label="kind 152381"];
735 [label="diagnostics 152382"];
736 [label="annotations 152383"];
737 [label="text 152384"];
738 [label="param SyntaxTrivia(this) 152385"];
739 [label="param CSharpSyntaxNode(SyntaxKind kind) 152386"];
740 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152387"];
741 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152388"];
742 [label="param CSharpSyntaxNode(int fullWidth) 152389"];
743 [label="param CSharpSyntaxNode(this) 152390"];
744 [label="kind 152391"];
745 [label="diagnostics 152392"];
746 [label="annotations 152393"];
747 [label="fullWidth 152394"];
748 [label="param CSharpSyntaxNode(this) 152395"];
749 [label="param CSharpSyntaxNode(this) 152396"];
750 [label="GreenStats.NoteGreen(this); 152397"];
751 [label="GreenStats.NoteGreen(this); 152398"];
752 [label="Text 152399"];
753 [label="this.Text 152400"];
754 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152401"];
755 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152402"];
756 [label="if (!elastic)\n            {\n                return trivia;\n            } 152403"];
757 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152404"];
758 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152405"];
759 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 152406"];
760 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152407"];
761 [label="this.Kind 152408"];
762 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152409"];
763 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 152410"];
764 [label="param SyntaxTrivia(this) 152411"];
765 [label="param SyntaxTrivia(this) 152412"];
766 [label="param CSharpSyntaxNode(this) 152413"];
767 [label="param CSharpSyntaxNode(this) 152414"];
768 [label="GreenStats.NoteGreen(this); 152415"];
769 [label="Text 152416"];
770 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152417"];
771 [label="ElasticTab = Whitespace('\\t', elastic: true) 152418"];
772 [label="string.Empty 152419"];
773 [label="true 152420"];
774 [label="elastic: true 152421"];
775 [label="Whitespace(string.Empty, elastic: true) 152422"];
776 [label="param Whitespace(string text) 152423"];
777 [label="param Whitespace(bool elastic = false) 152424"];
778 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152425"];
779 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152426"];
780 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 152427"];
781 [label="param Create(SyntaxKind kind) 152428"];
782 [label="param Create(string text) 152429"];
783 [label="return new SyntaxTrivia(kind, text); 152430"];
784 [label="return new SyntaxTrivia(kind, text); 152431"];
785 [label="return new SyntaxTrivia(kind, text); 152432"];
786 [label="new SyntaxTrivia(kind, text) 152433"];
787 [label="param SyntaxTrivia(SyntaxKind kind) 152434"];
788 [label="param SyntaxTrivia(string text) 152435"];
789 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 152436"];
790 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 152437"];
791 [label="param SyntaxTrivia(this) 152438"];
792 [label="kind 152439"];
793 [label="diagnostics 152440"];
794 [label="annotations 152441"];
795 [label="text 152442"];
796 [label="param SyntaxTrivia(this) 152443"];
797 [label="param CSharpSyntaxNode(SyntaxKind kind) 152444"];
798 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 152445"];
799 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 152446"];
800 [label="param CSharpSyntaxNode(int fullWidth) 152447"];
801 [label="param CSharpSyntaxNode(this) 152448"];
802 [label="kind 152449"];
803 [label="diagnostics 152450"];
804 [label="annotations 152451"];
805 [label="fullWidth 152452"];
806 [label="param CSharpSyntaxNode(this) 152453"];
807 [label="param CSharpSyntaxNode(this) 152454"];
808 [label="GreenStats.NoteGreen(this); 152455"];
809 [label="GreenStats.NoteGreen(this); 152456"];
810 [label="Text 152457"];
811 [label="this.Text 152458"];
812 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152459"];
813 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 152460"];
814 [label="if (!elastic)\n            {\n                return trivia;\n            } 152461"];
815 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152462"];
816 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152463"];
817 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 152464"];
818 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 152465"];
819 [label="this.Kind 152466"];
820 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 152467"];
821 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 152468"];
822 [label="param SyntaxTrivia(this) 152469"];
823 [label="param SyntaxTrivia(this) 152470"];
824 [label="param CSharpSyntaxNode(this) 152471"];
825 [label="param CSharpSyntaxNode(this) 152472"];
826 [label="GreenStats.NoteGreen(this); 152473"];
827 [label="Text 152474"];
828 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 152475"];
829 [label="ElasticZeroSpace = Whitespace(string.Empty, elastic: true) 152476"];
830 [label="s_xmlCarriageReturnLineFeed 152477"];
831 [label="public static SyntaxTrivia CarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturnLineFeed; 152478"];
832 [label="param operator(SyntaxTrivia trivia) 152479"];
833 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152480"];
834 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152481"];
835 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152482"];
836 [label="public static SyntaxTrivia LineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.LineFeed; 152483"];
837 [label="param operator(SyntaxTrivia trivia) 152484"];
838 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152485"];
839 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152486"];
840 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152487"];
841 [label="public static SyntaxTrivia CarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturn; 152488"];
842 [label="param operator(SyntaxTrivia trivia) 152489"];
843 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152490"];
844 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152491"];
845 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152492"];
846 [label="public static SyntaxTrivia Space { get; } = Syntax.InternalSyntax.SyntaxFactory.Space; 152493"];
847 [label="param operator(SyntaxTrivia trivia) 152494"];
848 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152495"];
849 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152496"];
850 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152497"];
851 [label="public static SyntaxTrivia Tab { get; } = Syntax.InternalSyntax.SyntaxFactory.Tab; 152498"];
852 [label="param operator(SyntaxTrivia trivia) 152499"];
853 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152500"];
854 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152501"];
855 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152502"];
856 [label="public static SyntaxTrivia ElasticCarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturnLineFeed; 152503"];
857 [label="param operator(SyntaxTrivia trivia) 152504"];
858 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152505"];
859 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152506"];
860 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152507"];
861 [label="public static SyntaxTrivia ElasticLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticLineFeed; 152508"];
862 [label="param operator(SyntaxTrivia trivia) 152509"];
863 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152510"];
864 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152511"];
865 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152512"];
866 [label="public static SyntaxTrivia ElasticCarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturn; 152513"];
867 [label="param operator(SyntaxTrivia trivia) 152514"];
868 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152515"];
869 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152516"];
870 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152517"];
871 [label="public static SyntaxTrivia ElasticSpace { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticSpace; 152518"];
872 [label="param operator(SyntaxTrivia trivia) 152519"];
873 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152520"];
874 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152521"];
875 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152522"];
876 [label="public static SyntaxTrivia ElasticTab { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticTab; 152523"];
877 [label="param operator(SyntaxTrivia trivia) 152524"];
878 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152525"];
879 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152526"];
880 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152527"];
881 [label="public static SyntaxTrivia ElasticMarker { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticZeroSpace; 152528"];
882 [label="param operator(SyntaxTrivia trivia) 152529"];
883 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152530"];
884 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152531"];
885 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 152532"];
886 [label="return SyntaxFactory.ParseStatement(text, offset, options); 152533"];
887 [label="return SyntaxFactory.ParseStatement(text, offset, options); 152534"];
888 [label="return SyntaxFactory.ParseStatement(text, offset, options); 152535"];
889 [label="return SyntaxFactory.ParseStatement(text, offset, options); 152536"];
890 [label="SyntaxFactory.ParseStatement(text, offset, options) 152537"];
891 [label="param ParseStatement(string text) 152538"];
892 [label="param ParseStatement(int offset = 0) 152539"];
893 [label="param ParseStatement(ParseOptions? options = null) 152540"];
894 [label="param ParseStatement(bool consumeFullText = true) 152541"];
895 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 152542"];
896 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 152543"];
897 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 152544"];
898 [label="MakeLexer(text, offset, (CSharpParseOptions?)options) 152545"];
899 [label="param MakeLexer(string text) 152546"];
900 [label="param MakeLexer(int offset) 152547"];
901 [label="param MakeLexer(CSharpParseOptions? options = null) 152548"];
902 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 152549"];
903 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 152550"];
904 [label="MakeSourceText(text, offset) 152551"];
905 [label="param MakeSourceText(string text) 152552"];
906 [label="param MakeSourceText(int offset) 152553"];
907 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 152554"];
908 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 152555"];
909 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 152556"];
910 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 152557"];
911 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 152558"];
912 [label="new CSharpParseOptions() 152559"];
913 [label="param CSharpParseOptions(LanguageVersion languageVersion = LanguageVersion.Default) 152560"];
914 [label="param CSharpParseOptions(DocumentationMode documentationMode = DocumentationMode.Parse) 152561"];
915 [label="param CSharpParseOptions(SourceCodeKind kind = SourceCodeKind.Regular) 152562"];
916 [label="param CSharpParseOptions(IEnumerable<string>? preprocessorSymbols = null) 152563"];
917 [label="param CSharpParseOptions(this) 152564"];
918 [label="languageVersion 152565"];
919 [label="documentationMode 152566"];
920 [label="kind 152567"];
921 [label="preprocessorSymbols 152568"];
922 [label="preprocessorSymbols.ToImmutableArrayOrEmpty() 152569"];
923 [label="ImmutableDictionary<string, string>.Empty 152570"];
924 [label="param CSharpParseOptions(LanguageVersion languageVersion) 152571"];
925 [label="param CSharpParseOptions(DocumentationMode documentationMode) 152572"];
926 [label="param CSharpParseOptions(SourceCodeKind kind) 152573"];
927 [label="param CSharpParseOptions(ImmutableArray<string> preprocessorSymbols) 152574"];
928 [label="param CSharpParseOptions(IReadOnlyDictionary<string, string>? features) 152575"];
929 [label="param CSharpParseOptions(this) 152576"];
930 [label="kind 152577"];
931 [label="documentationMode 152578"];
932 [label="param CSharpParseOptions(this) 152579"];
933 [label="_features 152580"];
934 [label="public LanguageVersion LanguageVersion { get; private set; } 152581"];
935 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 152582"];
936 [label="this.SpecifiedLanguageVersion 152583"];
937 [label="this.LanguageVersion = languageVersion.MapSpecifiedToEffectiveVersion(); 152584"];
938 [label="languageVersion.MapSpecifiedToEffectiveVersion() 152585"];
939 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 152586"];
940 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 152587"];
941 [label="return LanguageVersion.CSharp9; 152588"];
942 [label="this.LanguageVersion 152589"];
943 [label="this.PreprocessorSymbols = preprocessorSymbols.ToImmutableArrayOrEmpty(); 152590"];
944 [label="this.PreprocessorSymbols 152591"];
945 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 152592"];
946 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 152593"];
947 [label="_features 152594"];
948 [label="public static CSharpParseOptions Default { get; } = new CSharpParseOptions(); 152595"];
949 [label="8 152596"];
950 [label="TriviaListInitialCapacity = 8 152597"];
951 [label="TokensLexed 152598"];
952 [label="'<<<<<<<' 152599"];
953 [label="s_conflictMarkerLength = '<<<<<<<'.Length 152600"];
954 [label="42 152601"];
955 [label="MaxCachedTokenSize = 42 152602"];
956 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 152603"];
957 [label="{\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            } 152604"];
958 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 152605"];
959 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 152606"];
960 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 152607"];
961 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 152608"];
962 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 152609"];
963 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 152610"];
964 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 152611"];
965 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 152612"];
966 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 152613"];
967 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 152614"];
968 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 152615"];
969 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 152616"];
970 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 152617"];
971 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 152618"];
972 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 152619"];
973 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 152620"];
974 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 152621"];
975 [label="s_stateTransitions = new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 152622"];
976 [label="new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 152623"];
977 [label="s_charProperties = new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 152624"];
978 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 152625"];
979 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 152626"];
980 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 152627"];
981 [label="new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default) 152628"];
982 [label="param Lexer(SourceText text) 152629"];
983 [label="param Lexer(CSharpParseOptions options) 152630"];
984 [label="param Lexer(bool allowPreprocessorDirectives = true) 152631"];
985 [label="param Lexer(bool interpolationFollowedByColon = false) 152632"];
986 [label="param Lexer(this) 152633"];
987 [label="text 152634"];
988 [label="param Lexer(this) 152635"];
989 [label="param AbstractLexer(SourceText text) 152636"];
990 [label="param AbstractLexer(this) 152637"];
991 [label="TextWindow 152638"];
992 [label="_errors 152639"];
993 [label="InvalidCharacter = char.MaxValue 152640"];
994 [label="2048 152641"];
995 [label="DefaultWindowLength = 2048 152642"];
996 [label="() => new char[DefaultWindowLength] 152643"];
997 [label="new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 152644"];
998 [label="s_windowPool = new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 152645"];
999 [label="this.TextWindow = new SlidingTextWindow(text); 152646"];
1000 [label="this.TextWindow = new SlidingTextWindow(text); 152647"];
1001 [label="new SlidingTextWindow(text) 152648"];
1002 [label="param SlidingTextWindow(SourceText text) 152649"];
1003 [label="param SlidingTextWindow(this) 152650"];
1004 [label="_text 152651"];
1005 [label="_basis 152652"];
1006 [label="_offset 152653"];
1007 [label="_textEnd 152654"];
1008 [label="_characterWindow 152655"];
1009 [label="_characterWindowCount 152656"];
1010 [label="_lexemeStart 152657"];
1011 [label="_strings 152658"];
1012 [label="_text 152659"];
1013 [label="_basis = 0; 152660"];
1014 [label="_basis 152661"];
1015 [label="_offset = 0; 152662"];
1016 [label="_offset 152663"];
1017 [label="_textEnd 152664"];
1018 [label="_strings = StringTable.GetInstance(); 152665"];
1019 [label="_strings 152666"];
1020 [label="_characterWindow = s_windowPool.Allocate(); 152667"];
1021 [label="_characterWindow 152668"];
1022 [label="_lexemeStart = 0; 152669"];
1023 [label="_lexemeStart 152670"];
1024 [label="this.TextWindow 152671"];
1025 [label="_options 152672"];
1026 [label="_mode 152673"];
1027 [label="_builder 152674"];
1028 [label="_identBuffer 152675"];
1029 [label="_identLen 152676"];
1030 [label="_cache 152677"];
1031 [label="_allowPreprocessorDirectives 152678"];
1032 [label="_interpolationFollowedByColon 152679"];
1033 [label="_xmlParser 152680"];
1034 [label="_badTokenCount 152681"];
1035 [label="10 152682"];
1036 [label="new SyntaxListBuilder(10) 152683"];
1037 [label="_leadingTriviaCache = new SyntaxListBuilder(10) 152684"];
1038 [label="10 152685"];
1039 [label="new SyntaxListBuilder(10) 152686"];
1040 [label="_trailingTriviaCache = new SyntaxListBuilder(10) 152687"];
1041 [label="_createWhitespaceTriviaFunction 152688"];
1042 [label="_createQuickTokenFunction 152689"];
1043 [label="Debug.Assert(options != null); 152690"];
1044 [label="Debug.Assert(options != null); 152691"];
1045 [label="_options 152692"];
1046 [label="_builder = new StringBuilder(); 152693"];
1047 [label="_builder 152694"];
1048 [label="_identBuffer = new char[32]; 152695"];
1049 [label="_identBuffer 152696"];
1050 [label="512 152697"];
1051 [label="(key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            } 152698"];
1052 [label="CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 152699"];
1053 [label="s_keywordKindPool =\n            CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 152700"];
1054 [label="10 152701"];
1055 [label="MaxKeywordLength = 10 152702"];
1056 [label="_cache = new LexerCache(); 152703"];
1057 [label="new LexerCache() 152704"];
1058 [label="param LexerCache(this) 152705"];
1059 [label="_triviaMap 152706"];
1060 [label="_tokenMap 152707"];
1061 [label="_keywordKindMap 152708"];
1062 [label="_triviaMap = TextKeyedCache<SyntaxTrivia>.GetInstance(); 152709"];
1063 [label="_triviaMap 152710"];
1064 [label="_tokenMap = TextKeyedCache<SyntaxToken>.GetInstance(); 152711"];
1065 [label="_tokenMap 152712"];
1066 [label="_keywordKindMap = s_keywordKindPool.Allocate(); 152713"];
1067 [label="_keywordKindMap 152714"];
1068 [label="_cache 152715"];
1069 [label="_createQuickTokenFunction 152716"];
1070 [label="_allowPreprocessorDirectives 152717"];
1071 [label="_interpolationFollowedByColon 152718"];
1072 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 152719"];
1073 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 152720"];
1074 [label="MakeParser(lexer) 152721"];
1075 [label="param MakeParser(InternalSyntax.Lexer lexer) 152722"];
1076 [label="LastTerminatorState = (int)TerminatorState.IsEndOfRecordSignature 152723"];
1077 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 152724"];
1078 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 152725"];
1079 [label="new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null) 152726"];
1080 [label="param LanguageParser(Lexer lexer) 152727"];
1081 [label="param LanguageParser(CSharp.CSharpSyntaxNode oldTree) 152728"];
1082 [label="param LanguageParser(IEnumerable<TextChangeRange> changes) 152729"];
1083 [label="param LanguageParser(LexerMode lexerMode = LexerMode.Syntax) 152730"];
1084 [label="param LanguageParser(CancellationToken cancellationToken = default(CancellationToken)) 152731"];
1085 [label="param LanguageParser(this) 152732"];
1086 [label="() => new BlendedNode[32] 152733"];
1087 [label="2 152734"];
1088 [label="new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 152735"];
1089 [label="s_blendedNodesPool = new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 152736"];
1090 [label="lexer 152737"];
1091 [label="lexerMode 152738"];
1092 [label="oldTree 152739"];
1093 [label="changes 152740"];
1094 [label="false 152741"];
1095 [label="true 152742"];
1096 [label="cancellationToken 152743"];
1097 [label="param LanguageParser(this) 152744"];
1098 [label="param SyntaxParser(Lexer lexer) 152745"];
1099 [label="param SyntaxParser(LexerMode mode) 152746"];
1100 [label="param SyntaxParser(CSharp.CSharpSyntaxNode oldTree) 152747"];
1101 [label="param SyntaxParser(IEnumerable<TextChangeRange> changes) 152748"];
1102 [label="param SyntaxParser(bool allowModeReset) 152749"];
1103 [label="param SyntaxParser(bool preLexIfNotIncremental = false) 152750"];
1104 [label="param SyntaxParser(CancellationToken cancellationToken = default(CancellationToken)) 152751"];
1105 [label="param SyntaxParser(this) 152752"];
1106 [label="lexer 152753"];
1107 [label="_isIncremental 152754"];
1108 [label="_allowModeReset 152755"];
1109 [label="_mode 152756"];
1110 [label="_currentToken 152757"];
1111 [label="_lexedTokens 152758"];
1112 [label="_prevTokenTrailingTrivia 152759"];
1113 [label="_firstToken 152760"];
1114 [label="_tokenOffset 152761"];
1115 [label="_tokenCount 152762"];
1116 [label="_resetCount 152763"];
1117 [label="_resetStart 152764"];
1118 [label="_blendedTokens 152765"];
1119 [label="this.lexer 152766"];
1120 [label="_mode 152767"];
1121 [label="_allowModeReset 152768"];
1122 [label="this.cancellationToken 152769"];
1123 [label="_currentNode = default(BlendedNode); 152770"];
1124 [label="_currentNode 152771"];
1125 [label="_isIncremental = oldTree != null; 152772"];
1126 [label="_isIncremental = oldTree != null; 152773"];
1127 [label="_isIncremental 152774"];
1128 [label="this.IsIncremental 152775"];
1129 [label="get\n            {\n                return _isIncremental;\n            } 152776"];
1130 [label="return _isIncremental; 152777"];
1131 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 152778"];
1132 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 152779"];
1133 [label="_firstBlender = default(Blender); 152780"];
1134 [label="_firstBlender 152781"];
1135 [label="_lexedTokens = new ArrayElement<SyntaxToken>[32]; 152782"];
1136 [label="_lexedTokens 152783"];
1137 [label="this.IsIncremental 152784"];
1138 [label="get\n            {\n                return _isIncremental;\n            } 152785"];
1139 [label="return _isIncremental; 152786"];
1140 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 152787"];
1141 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 152788"];
1142 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 152789"];
1143 [label="this.PreLex() 152790"];
1144 [label="param PreLex(this) 152791"];
1145 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 152792"];
1146 [label="this.lexer.TextWindow.Text 152793"];
1147 [label="=> _text 152794"];
1148 [label="_text 152795"];
1149 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 152796"];
1150 [label="_lexedTokens = new ArrayElement<SyntaxToken>[size]; 152797"];
1151 [label="_lexedTokens 152798"];
1152 [label="var lexer = this.lexer; 152799"];
1153 [label="var mode = _mode; 152800"];
1154 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 152801"];
1155 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 152802"];
1156 [label="var token = lexer.Lex(mode); 152803"];
1157 [label="lexer.Lex(mode) 152804"];
1158 [label="param Lex(LexerMode mode) 152805"];
1159 [label="param Lex(this) 152806"];
1160 [label="TokensLexed++; 152807"];
1161 [label="_mode 152808"];
1162 [label="switch (_mode)\n            {\n                case LexerMode.Syntax:\n                case LexerMode.DebuggerSyntax:\n                    return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken();\n                case LexerMode.Directive:\n                    return this.LexDirectiveToken();\n            } 152809"];
1163 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 152810"];
1164 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 152811"];
1165 [label="param Start(this) 152812"];
1166 [label="TextWindow.Start() 152813"];
1167 [label="param Start(this) 152814"];
1168 [label="_lexemeStart 152815"];
1169 [label="TextWindow.Start(); 152816"];
1170 [label="_errors = null; 152817"];
1171 [label="_errors 152818"];
1172 [label="get\n            {\n                return _offset;\n            } 152819"];
1173 [label="return _offset; 152820"];
1174 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 152821"];
1175 [label="get\n            {\n                return _characterWindowCount;\n            } 152822"];
1176 [label="return _characterWindowCount; 152823"];
1177 [label="get\n            {\n                return _characterWindow;\n            } 152824"];
1178 [label="return _characterWindow; 152825"];
1179 [label="param AdvanceChar(int n) 152826"];
1180 [label="param AdvanceChar(this) 152827"];
1181 [label="_offset += n; 152828"];
1182 [label="_offset 152829"];
1183 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 152830"];
1184 [label="return _basis + _lexemeStart; 152831"];
1185 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 152832"];
1186 [label="param Reset(int position) 152833"];
1187 [label="param Reset(this) 152834"];
1188 [label="int relative = position - _basis; 152835"];
1189 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 152836"];
1190 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 152837"];
1191 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 152838"];
1192 [label="_offset 152839"];
1193 [label="this.LexSyntaxToken() 152840"];
1194 [label="param LexSyntaxToken(this) 152841"];
1195 [label="_leadingTriviaCache.Clear(); 152842"];
1196 [label="TextWindow.Position 152843"];
1197 [label="get\n            {\n                return _basis + _offset;\n            } 152844"];
1198 [label="return _basis + _offset; 152845"];
1199 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 152846"];
1200 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 152847"];
1201 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 152848"];
1202 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache) 152849"];
1203 [label="param LexSyntaxTrivia(bool afterFirstToken) 152850"];
1204 [label="param LexSyntaxTrivia(bool isTrailing) 152851"];
1205 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 152852"];
1206 [label="param LexSyntaxTrivia(this) 152853"];
1207 [label="bool onlyWhitespaceOnLine = !isTrailing; 152854"];
1208 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 152855"];
1209 [label="this.Start() 152856"];
1210 [label="param Start(this) 152857"];
1211 [label="TextWindow.Start() 152858"];
1212 [label="param Start(this) 152859"];
1213 [label="TextWindow.Start(); 152860"];
1214 [label="_errors = null; 152861"];
1215 [label="_errors 152862"];
1216 [label="this.Start(); 152863"];
1217 [label="TextWindow.PeekChar() 152864"];
1218 [label="param PeekChar(this) 152865"];
1219 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 152866"];
1220 [label="MoreChars() 152867"];
1221 [label="param MoreChars(this) 152868"];
1222 [label="if (_offset >= _characterWindowCount)\n            {\n                if (this.Position >= _textEnd)\n                {\n                    return false;\n                }\n\n                // if lexeme scanning is sufficiently into the char buffer, \n                // then refocus the window onto the lexeme\n                if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                }\n\n                if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                }\n\n                int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount);\n                _text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead);\n                _characterWindowCount += amountToRead;\n                return amountToRead > 0;\n            } 152869"];
1223 [label="this.Position 152870"];
1224 [label="get\n            {\n                return _basis + _offset;\n            } 152871"];
1225 [label="return _basis + _offset; 152872"];
1226 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 152873"];
1227 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 152874"];
1228 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 152875"];
1229 [label="if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                } 152876"];
1230 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 152877"];
1231 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 152878"];
1232 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 152879"];
1233 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 152880"];
1234 [label="_characterWindowCount += amountToRead; 152881"];
1235 [label="_characterWindowCount 152882"];
1236 [label="return amountToRead > 0; 152883"];
1237 [label="return amountToRead > 0; 152884"];
1238 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 152885"];
1239 [label="return _characterWindow[_offset]; 152886"];
1240 [label="char ch = TextWindow.PeekChar(); 152887"];
1241 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 152888"];
1242 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 152889"];
1243 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 152890"];
1244 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 152891"];
1245 [label="return; 152892"];
1246 [label="var leading = _leadingTriviaCache; 152893"];
1247 [label="var tokenInfo = default(TokenInfo); 152894"];
1248 [label="this.Start() 152895"];
1249 [label="param Start(this) 152896"];
1250 [label="TextWindow.Start() 152897"];
1251 [label="param Start(this) 152898"];
1252 [label="TextWindow.Start(); 152899"];
1253 [label="_errors = null; 152900"];
1254 [label="_errors 152901"];
1255 [label="this.Start(); 152902"];
1256 [label="this.ScanSyntaxToken(ref tokenInfo); 152903"];
1257 [label="this.ScanSyntaxToken(ref tokenInfo); 152904"];
1258 [label="this.ScanSyntaxToken(ref tokenInfo); 152905"];
1259 [label="get\n            {\n                return _basis + _offset;\n            } 152906"];
1260 [label="return _basis + _offset; 152907"];
1261 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 152908"];
1262 [label="return _characterWindow[_offset]; 152909"];
1263 [label="param ScanIdentifierOrKeyword(ref TokenInfo info) 152910"];
1264 [label="param ScanIdentifierOrKeyword(this) 152911"];
1265 [label="info.ContextualKind 152912"];
1266 [label="if (this.ScanIdentifier(ref info))\n            {\n                // check to see if it is an actual keyword\n                if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                }\n\n                return true;\n            }\n            else\n            {\n                info.Kind = SyntaxKind.None;\n                return false;\n            } 152913"];
1267 [label="this.ScanIdentifier(ref info) 152914"];
1268 [label="param ScanIdentifier(ref TokenInfo info) 152915"];
1269 [label="param ScanIdentifier(this) 152916"];
1270 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 152917"];
1271 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 152918"];
1272 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 152919"];
1273 [label="param Intern(char[] array) 152920"];
1274 [label="param Intern(int start) 152921"];
1275 [label="param Intern(int length) 152922"];
1276 [label="param Intern(this) 152923"];
1277 [label="return _strings.Add(array, start, length); 152924"];
1278 [label="return _strings.Add(array, start, length); 152925"];
1279 [label="return _strings.Add(array, start, length); 152926"];
1280 [label="return _strings.Add(array, start, length); 152927"];
1281 [label="if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                } 152928"];
1282 [label="if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    } 152929"];
1283 [label="this.ModeIs(LexerMode.Directive) 152930"];
1284 [label="param ModeIs(LexerMode mode) 152931"];
1285 [label="param ModeIs(this) 152932"];
1286 [label="return ModeOf(_mode) == mode; 152933"];
1287 [label="ModeOf(_mode) 152934"];
1288 [label="param ModeOf(LexerMode mode) 152935"];
1289 [label="return mode & LexerMode.MaskLexMode; 152936"];
1290 [label="return ModeOf(_mode) == mode; 152937"];
1291 [label="if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 152938"];
1292 [label="_cache.TryGetKeywordKind(info.Text, out info.Kind) 152939"];
1293 [label="param TryGetKeywordKind(string key) 152940"];
1294 [label="param TryGetKeywordKind(out SyntaxKind kind) 152941"];
1295 [label="param TryGetKeywordKind(this) 152942"];
1296 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 152943"];
1297 [label="new SyntaxKindEqualityComparer() 152944"];
1298 [label="param SyntaxKindEqualityComparer(this) 152945"];
1299 [label="public static IEqualityComparer<SyntaxKind> EqualityComparer { get; } = new SyntaxKindEqualityComparer(); 152946"];
1300 [label="kind = _keywordKindMap.GetOrMakeValue(key); 152947"];
1301 [label="kind = _keywordKindMap.GetOrMakeValue(key); 152948"];
1302 [label="kind = _keywordKindMap.GetOrMakeValue(key); 152949"];
1303 [label="param GetKeywordKind(string text) 152950"];
1304 [label="switch (text)\n            {\n                case 'bool':\n                    return SyntaxKind.BoolKeyword;\n                case 'byte':\n                    return SyntaxKind.ByteKeyword;\n                case 'sbyte':\n                    return SyntaxKind.SByteKeyword;\n                case 'short':\n                    return SyntaxKind.ShortKeyword;\n                case 'ushort':\n                    return SyntaxKind.UShortKeyword;\n                case 'int':\n                    return SyntaxKind.IntKeyword;\n                case 'uint':\n                    return SyntaxKind.UIntKeyword;\n                case 'long':\n                    return SyntaxKind.LongKeyword;\n                case 'ulong':\n                    return SyntaxKind.ULongKeyword;\n                case 'double':\n                    return SyntaxKind.DoubleKeyword;\n                case 'float':\n                    return SyntaxKind.FloatKeyword;\n                case 'decimal':\n                    return SyntaxKind.DecimalKeyword;\n                case 'string':\n                    return SyntaxKind.StringKeyword;\n                case 'char':\n                    return SyntaxKind.CharKeyword;\n                case 'void':\n                    return SyntaxKind.VoidKeyword;\n                case 'object':\n                    return SyntaxKind.ObjectKeyword;\n                case 'typeof':\n                    return SyntaxKind.TypeOfKeyword;\n                case 'sizeof':\n                    return SyntaxKind.SizeOfKeyword;\n                case 'null':\n                    return SyntaxKind.NullKeyword;\n                case 'true':\n                    return SyntaxKind.TrueKeyword;\n                case 'false':\n                    return SyntaxKind.FalseKeyword;\n                case 'if':\n                    return SyntaxKind.IfKeyword;\n                case 'else':\n                    return SyntaxKind.ElseKeyword;\n                case 'while':\n                    return SyntaxKind.WhileKeyword;\n                case 'for':\n                    return SyntaxKind.ForKeyword;\n                case 'foreach':\n                    return SyntaxKind.ForEachKeyword;\n                case 'do':\n                    return SyntaxKind.DoKeyword;\n                case 'switch':\n                    return SyntaxKind.SwitchKeyword;\n                case 'case':\n                    return SyntaxKind.CaseKeyword;\n                case 'default':\n                    return SyntaxKind.DefaultKeyword;\n                case 'lock':\n                    return SyntaxKind.LockKeyword;\n                case 'try':\n                    return SyntaxKind.TryKeyword;\n                case 'throw':\n                    return SyntaxKind.ThrowKeyword;\n                case 'catch':\n                    return SyntaxKind.CatchKeyword;\n                case 'finally':\n                    return SyntaxKind.FinallyKeyword;\n                case 'goto':\n                    return SyntaxKind.GotoKeyword;\n                case 'break':\n                    return SyntaxKind.BreakKeyword;\n                case 'continue':\n                    return SyntaxKind.ContinueKeyword;\n                case 'return':\n                    return SyntaxKind.ReturnKeyword;\n                case 'public':\n                    return SyntaxKind.PublicKeyword;\n                case 'private':\n                    return SyntaxKind.PrivateKeyword;\n                case 'internal':\n                    return SyntaxKind.InternalKeyword;\n                case 'protected':\n                    return SyntaxKind.ProtectedKeyword;\n                case 'static':\n                    return SyntaxKind.StaticKeyword;\n                case 'readonly':\n                    return SyntaxKind.ReadOnlyKeyword;\n                case 'sealed':\n                    return SyntaxKind.SealedKeyword;\n                case 'const':\n                    return SyntaxKind.ConstKeyword;\n                case 'fixed':\n                    return SyntaxKind.FixedKeyword;\n                case 'stackalloc':\n                    return SyntaxKind.StackAllocKeyword;\n                case 'volatile':\n                    return SyntaxKind.VolatileKeyword;\n                case 'new':\n                    return SyntaxKind.NewKeyword;\n                case 'override':\n                    return SyntaxKind.OverrideKeyword;\n                case 'abstract':\n                    return SyntaxKind.AbstractKeyword;\n                case 'virtual':\n                    return SyntaxKind.VirtualKeyword;\n                case 'event':\n                    return SyntaxKind.EventKeyword;\n                case 'extern':\n                    return SyntaxKind.ExternKeyword;\n                case 'ref':\n                    return SyntaxKind.RefKeyword;\n                case 'out':\n                    return SyntaxKind.OutKeyword;\n                case 'in':\n                    return SyntaxKind.InKeyword;\n                case 'is':\n                    return SyntaxKind.IsKeyword;\n                case 'as':\n                    return SyntaxKind.AsKeyword;\n                case 'params':\n                    return SyntaxKind.ParamsKeyword;\n                case '__arglist':\n                    return SyntaxKind.ArgListKeyword;\n                case '__makeref':\n                    return SyntaxKind.MakeRefKeyword;\n                case '__reftype':\n                    return SyntaxKind.RefTypeKeyword;\n                case '__refvalue':\n                    return SyntaxKind.RefValueKeyword;\n                case 'this':\n                    return SyntaxKind.ThisKeyword;\n                case 'base':\n                    return SyntaxKind.BaseKeyword;\n                case 'namespace':\n                    return SyntaxKind.NamespaceKeyword;\n                case 'using':\n                    return SyntaxKind.UsingKeyword;\n                case 'class':\n                    return SyntaxKind.ClassKeyword;\n                case 'struct':\n                    return SyntaxKind.StructKeyword;\n                case 'interface':\n                    return SyntaxKind.InterfaceKeyword;\n                case 'enum':\n                    return SyntaxKind.EnumKeyword;\n                case 'delegate':\n                    return SyntaxKind.DelegateKeyword;\n                case 'checked':\n                    return SyntaxKind.CheckedKeyword;\n                case 'unchecked':\n                    return SyntaxKind.UncheckedKeyword;\n                case 'unsafe':\n                    return SyntaxKind.UnsafeKeyword;\n                case 'operator':\n                    return SyntaxKind.OperatorKeyword;\n                case 'implicit':\n                    return SyntaxKind.ImplicitKeyword;\n                case 'explicit':\n                    return SyntaxKind.ExplicitKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 152951"];
1305 [label="return SyntaxKind.SwitchKeyword; 152952"];
1306 [label="return kind != SyntaxKind.None; 152953"];
1307 [label="if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 152954"];
1308 [label="SyntaxFacts.IsContextualKeyword(info.Kind) 152955"];
1309 [label="param IsContextualKeyword(SyntaxKind kind) 152956"];
1310 [label="switch (kind)\n            {\n                case SyntaxKind.YieldKeyword:\n                case SyntaxKind.PartialKeyword:\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.LetKeyword:\n                case SyntaxKind.ByKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                case SyntaxKind.AddKeyword:\n                case SyntaxKind.RemoveKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.AliasKeyword:\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.AssemblyKeyword:\n                case SyntaxKind.ModuleKeyword:\n                case SyntaxKind.TypeKeyword:\n                case SyntaxKind.GlobalKeyword:\n                case SyntaxKind.FieldKeyword:\n                case SyntaxKind.MethodKeyword:\n                case SyntaxKind.ParamKeyword:\n                case SyntaxKind.PropertyKeyword:\n                case SyntaxKind.TypeVarKeyword:\n                case SyntaxKind.NameOfKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.AwaitKeyword:\n                case SyntaxKind.WhenKeyword:\n                case SyntaxKind.UnderscoreToken:\n                case SyntaxKind.VarKeyword:\n                case SyntaxKind.OrKeyword:\n                case SyntaxKind.AndKeyword:\n                case SyntaxKind.NotKeyword:\n                case SyntaxKind.DataKeyword:\n                case SyntaxKind.WithKeyword:\n                case SyntaxKind.InitKeyword:\n                case SyntaxKind.RecordKeyword:\n                case SyntaxKind.ManagedKeyword:\n                case SyntaxKind.UnmanagedKeyword:\n                    return true;\n                default:\n                    return false;\n            } 152957"];
1311 [label="return false; 152958"];
1312 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 152959"];
1313 [label="return true; 152960"];
1314 [label="this.ScanSyntaxToken(ref tokenInfo); 152961"];
1315 [label="var errors = this.GetErrors(GetFullWidth(leading)); 152962"];
1316 [label="GetFullWidth(leading) 152963"];
1317 [label="param GetFullWidth(SyntaxListBuilder builder) 152964"];
1318 [label="int width = 0; 152965"];
1319 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 152966"];
1320 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 152967"];
1321 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 152968"];
1322 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 152969"];
1323 [label="return width; 152970"];
1324 [label="var errors = this.GetErrors(GetFullWidth(leading)); 152971"];
1325 [label="this.GetErrors(GetFullWidth(leading)) 152972"];
1326 [label="param GetErrors(int leadingTriviaWidth) 152973"];
1327 [label="param GetErrors(this) 152974"];
1328 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 152975"];
1329 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 152976"];
1330 [label="return null; 152977"];
1331 [label="var errors = this.GetErrors(GetFullWidth(leading)); 152978"];
1332 [label="_trailingTriviaCache.Clear(); 152979"];
1333 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 152980"];
1334 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 152981"];
1335 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache) 152982"];
1336 [label="param LexSyntaxTrivia(bool afterFirstToken) 152983"];
1337 [label="param LexSyntaxTrivia(bool isTrailing) 152984"];
1338 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 152985"];
1339 [label="param LexSyntaxTrivia(this) 152986"];
1340 [label="bool onlyWhitespaceOnLine = !isTrailing; 152987"];
1341 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 152988"];
1342 [label="this.Start() 152989"];
1343 [label="param Start(this) 152990"];
1344 [label="TextWindow.Start() 152991"];
1345 [label="param Start(this) 152992"];
1346 [label="TextWindow.Start(); 152993"];
1347 [label="_errors = null; 152994"];
1348 [label="_errors 152995"];
1349 [label="this.Start(); 152996"];
1350 [label="TextWindow.PeekChar() 152997"];
1351 [label="param PeekChar(this) 152998"];
1352 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 152999"];
1353 [label="char ch = TextWindow.PeekChar(); 153000"];
1354 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 153001"];
1355 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 153002"];
1356 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 153003"];
1357 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 153004"];
1358 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 153005"];
1359 [label="param AdvanceChar(this) 153006"];
1360 [label="_offset 153007"];
1361 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 153008"];
1362 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 153009"];
1363 [label="return _offset - _lexemeStart; 153010"];
1364 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 153011"];
1365 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList) 153012"];
1366 [label="param AddTrivia(CSharpSyntaxNode trivia) 153013"];
1367 [label="param AddTrivia(ref SyntaxListBuilder list) 153014"];
1368 [label="param AddTrivia(this) 153015"];
1369 [label="this.HasErrors 153016"];
1370 [label="get { return _errors != null; } 153017"];
1371 [label="return _errors != null; 153018"];
1372 [label="return _errors != null; 153019"];
1373 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 153020"];
1374 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 153021"];
1375 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 153022"];
1376 [label="list.Add(trivia); 153023"];
1377 [label="list.Add(trivia); 153024"];
1378 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 153025"];
1379 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 153026"];
1380 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 153027"];
1381 [label="return; 153028"];
1382 [label="var trailing = _trailingTriviaCache; 153029"];
1383 [label="return Create(ref tokenInfo, leading, trailing, errors); 153030"];
1384 [label="return Create(ref tokenInfo, leading, trailing, errors); 153031"];
1385 [label="return Create(ref tokenInfo, leading, trailing, errors); 153032"];
1386 [label="return Create(ref tokenInfo, leading, trailing, errors); 153033"];
1387 [label="Create(ref tokenInfo, leading, trailing, errors) 153034"];
1388 [label="param Create(ref TokenInfo info) 153035"];
1389 [label="param Create(SyntaxListBuilder leading) 153036"];
1390 [label="param Create(SyntaxListBuilder trailing) 153037"];
1391 [label="param Create(SyntaxDiagnosticInfo[] errors) 153038"];
1392 [label="param Create(this) 153039"];
1393 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 153040"];
1394 [label="var leadingNode = leading?.ToListNode(); 153041"];
1395 [label="var trailingNode = trailing?.ToListNode(); 153042"];
1396 [label="SyntaxToken token; 153043"];
1397 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 153044"];
1398 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 153045"];
1399 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 153046"];
1400 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 153047"];
1401 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 153048"];
1402 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 153049"];
1403 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 153050"];
1404 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 153051"];
1405 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 153052"];
1406 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 153053"];
1407 [label="param Token(GreenNode leading) 153054"];
1408 [label="param Token(SyntaxKind kind) 153055"];
1409 [label="param Token(GreenNode trailing) 153056"];
1410 [label="FirstTokenWithWellKnownText = SyntaxKind.TildeToken 153057"];
1411 [label="LastTokenWithWellKnownText = SyntaxKind.EndOfFileToken 153058"];
1412 [label="1 153059"];
1413 [label="(int)LastTokenWithWellKnownText + 1 153060"];
1414 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 153061"];
1415 [label="s_tokensWithNoTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 153062"];
1416 [label="1 153063"];
1417 [label="(int)LastTokenWithWellKnownText + 1 153064"];
1418 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 153065"];
1419 [label="s_tokensWithElasticTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 153066"];
1420 [label="1 153067"];
1421 [label="(int)LastTokenWithWellKnownText + 1 153068"];
1422 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 153069"];
1423 [label="s_tokensWithSingleTrailingSpace = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 153070"];
1424 [label="1 153071"];
1425 [label="(int)LastTokenWithWellKnownText + 1 153072"];
1426 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 153073"];
1427 [label="s_tokensWithSingleTrailingCRLF = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 153074"];
1428 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxToken), r => new SyntaxToken(r)); 153075"];
1429 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 153076"];
1430 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 153077"];
1431 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 153078"];
1432 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 153079"];
1433 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 153080"];
1434 [label="new SyntaxToken(kind) 153081"];
1435 [label="param SyntaxToken(SyntaxKind kind) 153082"];
1436 [label="param SyntaxToken(this) 153083"];
1437 [label="kind 153084"];
1438 [label="param SyntaxToken(this) 153085"];
1439 [label="param CSharpSyntaxNode(SyntaxKind kind) 153086"];
1440 [label="param CSharpSyntaxNode(this) 153087"];
1441 [label="kind 153088"];
1442 [label="param CSharpSyntaxNode(this) 153089"];
1443 [label="param CSharpSyntaxNode(this) 153090"];
1444 [label="GreenStats.NoteGreen(this); 153091"];
1445 [label="GreenStats.NoteGreen(this); 153092"];
1446 [label="this.Text 153093"];
1447 [label="get { return SyntaxFacts.GetText(this.Kind); } 153094"];
1448 [label="this.Kind 153095"];
1449 [label="get { return (SyntaxKind)this.RawKind; } 153096"];
1450 [label="return (SyntaxKind)this.RawKind; 153097"];
1451 [label="return SyntaxFacts.GetText(this.Kind); 153098"];
1452 [label="SyntaxFacts.GetText(this.Kind) 153099"];
1453 [label="param GetText(SyntaxKind kind) 153100"];
1454 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 153101"];
1455 [label="return '~'; 153102"];
1456 [label="FullWidth = this.Text.Length; 153103"];
1457 [label="FullWidth 153104"];
1458 [label="this.flags |= NodeFlags.IsNotMissing; 153105"];
1459 [label="this.flags 153106"];
1460 [label="s_tokensWithNoTrivia[(int)kind].Value 153107"];
1461 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithTrivia), r => new SyntaxTokenWithTrivia(r)); 153108"];
1462 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 153109"];
1463 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 153110"];
1464 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 153111"];
1465 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 153112"];
1466 [label="new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace) 153113"];
1467 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 153114"];
1468 [label="param SyntaxTokenWithTrivia(GreenNode leading) 153115"];
1469 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 153116"];
1470 [label="param SyntaxTokenWithTrivia(this) 153117"];
1471 [label="kind 153118"];
1472 [label="param SyntaxTokenWithTrivia(this) 153119"];
1473 [label="param SyntaxToken(SyntaxKind kind) 153120"];
1474 [label="param SyntaxToken(this) 153121"];
1475 [label="kind 153122"];
1476 [label="param SyntaxToken(this) 153123"];
1477 [label="param CSharpSyntaxNode(SyntaxKind kind) 153124"];
1478 [label="param CSharpSyntaxNode(this) 153125"];
1479 [label="kind 153126"];
1480 [label="param CSharpSyntaxNode(this) 153127"];
1481 [label="param CSharpSyntaxNode(this) 153128"];
1482 [label="GreenStats.NoteGreen(this); 153129"];
1483 [label="GreenStats.NoteGreen(this); 153130"];
1484 [label="this.Text 153131"];
1485 [label="get { return SyntaxFacts.GetText(this.Kind); } 153132"];
1486 [label="this.Kind 153133"];
1487 [label="get { return (SyntaxKind)this.RawKind; } 153134"];
1488 [label="return (SyntaxKind)this.RawKind; 153135"];
1489 [label="return SyntaxFacts.GetText(this.Kind); 153136"];
1490 [label="SyntaxFacts.GetText(this.Kind) 153137"];
1491 [label="param GetText(SyntaxKind kind) 153138"];
1492 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 153139"];
1493 [label="return '~'; 153140"];
1494 [label="FullWidth = this.Text.Length; 153141"];
1495 [label="FullWidth 153142"];
1496 [label="this.flags |= NodeFlags.IsNotMissing; 153143"];
1497 [label="this.flags 153144"];
1498 [label="LeadingField 153145"];
1499 [label="TrailingField 153146"];
1500 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 153147"];
1501 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 153148"];
1502 [label="this.AdjustFlagsAndWidth(leading); 153149"];
1503 [label="this.AdjustFlagsAndWidth(leading); 153150"];
1504 [label="this.LeadingField 153151"];
1505 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 153152"];
1506 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 153153"];
1507 [label="this.AdjustFlagsAndWidth(trailing); 153154"];
1508 [label="this.AdjustFlagsAndWidth(trailing); 153155"];
1509 [label="this.TrailingField 153156"];
1510 [label="s_tokensWithElasticTrivia[(int)kind].Value 153157"];
1511 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 153158"];
1512 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 153159"];
1513 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 153160"];
1514 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 153161"];
1515 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space) 153162"];
1516 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 153163"];
1517 [label="param SyntaxTokenWithTrivia(GreenNode leading) 153164"];
1518 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 153165"];
1519 [label="param SyntaxTokenWithTrivia(this) 153166"];
1520 [label="kind 153167"];
1521 [label="param SyntaxTokenWithTrivia(this) 153168"];
1522 [label="param SyntaxToken(SyntaxKind kind) 153169"];
1523 [label="param SyntaxToken(this) 153170"];
1524 [label="kind 153171"];
1525 [label="param SyntaxToken(this) 153172"];
1526 [label="param CSharpSyntaxNode(SyntaxKind kind) 153173"];
1527 [label="param CSharpSyntaxNode(this) 153174"];
1528 [label="kind 153175"];
1529 [label="param CSharpSyntaxNode(this) 153176"];
1530 [label="param CSharpSyntaxNode(this) 153177"];
1531 [label="GreenStats.NoteGreen(this); 153178"];
1532 [label="GreenStats.NoteGreen(this); 153179"];
1533 [label="this.Text 153180"];
1534 [label="get { return SyntaxFacts.GetText(this.Kind); } 153181"];
1535 [label="this.Kind 153182"];
1536 [label="get { return (SyntaxKind)this.RawKind; } 153183"];
1537 [label="return (SyntaxKind)this.RawKind; 153184"];
1538 [label="return SyntaxFacts.GetText(this.Kind); 153185"];
1539 [label="SyntaxFacts.GetText(this.Kind) 153186"];
1540 [label="param GetText(SyntaxKind kind) 153187"];
1541 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 153188"];
1542 [label="return '~'; 153189"];
1543 [label="FullWidth = this.Text.Length; 153190"];
1544 [label="FullWidth 153191"];
1545 [label="this.flags |= NodeFlags.IsNotMissing; 153192"];
1546 [label="this.flags 153193"];
1547 [label="LeadingField 153194"];
1548 [label="TrailingField 153195"];
1549 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 153196"];
1550 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 153197"];
1551 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 153198"];
1552 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 153199"];
1553 [label="this.AdjustFlagsAndWidth(trailing); 153200"];
1554 [label="this.AdjustFlagsAndWidth(trailing); 153201"];
1555 [label="this.TrailingField 153202"];
1556 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 153203"];
1557 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 153204"];
1558 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 153205"];
1559 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 153206"];
1560 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 153207"];
1561 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed) 153208"];
1562 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 153209"];
1563 [label="param SyntaxTokenWithTrivia(GreenNode leading) 153210"];
1564 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 153211"];
1565 [label="param SyntaxTokenWithTrivia(this) 153212"];
1566 [label="kind 153213"];
1567 [label="param SyntaxTokenWithTrivia(this) 153214"];
1568 [label="param SyntaxToken(SyntaxKind kind) 153215"];
1569 [label="param SyntaxToken(this) 153216"];
1570 [label="kind 153217"];
1571 [label="param SyntaxToken(this) 153218"];
1572 [label="param CSharpSyntaxNode(SyntaxKind kind) 153219"];
1573 [label="param CSharpSyntaxNode(this) 153220"];
1574 [label="kind 153221"];
1575 [label="param CSharpSyntaxNode(this) 153222"];
1576 [label="param CSharpSyntaxNode(this) 153223"];
1577 [label="GreenStats.NoteGreen(this); 153224"];
1578 [label="GreenStats.NoteGreen(this); 153225"];
1579 [label="this.Text 153226"];
1580 [label="get { return SyntaxFacts.GetText(this.Kind); } 153227"];
1581 [label="this.Kind 153228"];
1582 [label="get { return (SyntaxKind)this.RawKind; } 153229"];
1583 [label="return (SyntaxKind)this.RawKind; 153230"];
1584 [label="return SyntaxFacts.GetText(this.Kind); 153231"];
1585 [label="SyntaxFacts.GetText(this.Kind) 153232"];
1586 [label="param GetText(SyntaxKind kind) 153233"];
1587 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 153234"];
1588 [label="return '~'; 153235"];
1589 [label="FullWidth = this.Text.Length; 153236"];
1590 [label="FullWidth 153237"];
1591 [label="this.flags |= NodeFlags.IsNotMissing; 153238"];
1592 [label="this.flags 153239"];
1593 [label="LeadingField 153240"];
1594 [label="TrailingField 153241"];
1595 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 153242"];
1596 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 153243"];
1597 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 153244"];
1598 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 153245"];
1599 [label="this.AdjustFlagsAndWidth(trailing); 153246"];
1600 [label="this.AdjustFlagsAndWidth(trailing); 153247"];
1601 [label="this.TrailingField 153248"];
1602 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 153249"];
1603 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 153250"];
1604 [label="param SyntaxToken(SyntaxKind kind) 153251"];
1605 [label="kind 153252"];
1606 [label="param CSharpSyntaxNode(SyntaxKind kind) 153253"];
1607 [label="kind 153254"];
1608 [label="param CSharpSyntaxNode(this) 153255"];
1609 [label="GreenStats.NoteGreen(this); 153256"];
1610 [label="return (SyntaxKind)this.RawKind; 153257"];
1611 [label="return SyntaxFacts.GetText(this.Kind); 153258"];
1612 [label="param GetText(SyntaxKind kind) 153259"];
1613 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 153260"];
1614 [label="return '!'; 153261"];
1615 [label="FullWidth = this.Text.Length; 153262"];
1616 [label="FullWidth 153263"];
1617 [label="this.flags |= NodeFlags.IsNotMissing; 153264"];
1618 [label="this.flags 153265"];
1619 [label="s_tokensWithNoTrivia[(int)kind].Value 153266"];
1620 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 153267"];
1621 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 153268"];
1622 [label="kind 153269"];
1623 [label="param SyntaxToken(SyntaxKind kind) 153270"];
1624 [label="kind 153271"];
1625 [label="param CSharpSyntaxNode(SyntaxKind kind) 153272"];
1626 [label="kind 153273"];
1627 [label="param CSharpSyntaxNode(this) 153274"];
1628 [label="GreenStats.NoteGreen(this); 153275"];
1629 [label="return (SyntaxKind)this.RawKind; 153276"];
1630 [label="return SyntaxFacts.GetText(this.Kind); 153277"];
1631 [label="param GetText(SyntaxKind kind) 153278"];
1632 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 153279"];
1633 [label="return '!'; 153280"];
1634 [label="FullWidth = this.Text.Length; 153281"];
1635 [label="FullWidth 153282"];
1636 [label="this.flags |= NodeFlags.IsNotMissing; 153283"];
1637 [label="this.flags 153284"];
1638 [label="this.AdjustFlagsAndWidth(leading); 153285"];
1639 [label="s_tokensWithElasticTrivia[(int)kind].Value 153286"];
1640 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 153287"];
1641 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 153288"];
1642 [label="kind 153289"];
1643 [label="param SyntaxToken(SyntaxKind kind) 153290"];
1644 [label="kind 153291"];
1645 [label="param CSharpSyntaxNode(SyntaxKind kind) 153292"];
1646 [label="kind 153293"];
1647 [label="param CSharpSyntaxNode(this) 153294"];
1648 [label="GreenStats.NoteGreen(this); 153295"];
1649 [label="return (SyntaxKind)this.RawKind; 153296"];
1650 [label="return SyntaxFacts.GetText(this.Kind); 153297"];
1651 [label="param GetText(SyntaxKind kind) 153298"];
1652 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 153299"];
1653 [label="return '!'; 153300"];
1654 [label="FullWidth = this.Text.Length; 153301"];
1655 [label="FullWidth 153302"];
1656 [label="this.flags |= NodeFlags.IsNotMissing; 153303"];
1657 [label="this.flags 153304"];
1658 [label="this.AdjustFlagsAndWidth(trailing); 153305"];
1659 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 153306"];
1660 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 153307"];
1661 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 153308"];
1662 [label="kind 153309"];
1663 [label="param SyntaxToken(SyntaxKind kind) 153310"];
1664 [label="kind 153311"];
1665 [label="param CSharpSyntaxNode(SyntaxKind kind) 153312"];
1666 [label="kind 153313"];
1667 [label="param CSharpSyntaxNode(this) 153314"];
1668 [label="GreenStats.NoteGreen(this); 153315"];
1669 [label="return (SyntaxKind)this.RawKind; 153316"];
1670 [label="return SyntaxFacts.GetText(this.Kind); 153317"];
1671 [label="param GetText(SyntaxKind kind) 153318"];
1672 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 153319"];
1673 [label="return '!'; 153320"];
1674 [label="FullWidth = this.Text.Length; 153321"];
1675 [label="FullWidth 153322"];
1676 [label="this.flags |= NodeFlags.IsNotMissing; 153323"];
1677 [label="this.flags 153324"];
1678 [label="this.AdjustFlagsAndWidth(trailing); 153325"];
1679 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 153326"];
1680 [label="return '$'; 153327"];
1681 [label="FullWidth = this.Text.Length; 153328"];
1682 [label="FullWidth 153329"];
1683 [label="return '$'; 153330"];
1684 [label="FullWidth = this.Text.Length; 153331"];
1685 [label="FullWidth 153332"];
1686 [label="this.AdjustFlagsAndWidth(leading); 153333"];
1687 [label="return '$'; 153334"];
1688 [label="FullWidth = this.Text.Length; 153335"];
1689 [label="FullWidth 153336"];
1690 [label="this.AdjustFlagsAndWidth(trailing); 153337"];
1691 [label="return '$'; 153338"];
1692 [label="FullWidth = this.Text.Length; 153339"];
1693 [label="FullWidth 153340"];
1694 [label="this.AdjustFlagsAndWidth(trailing); 153341"];
1695 [label="return '%'; 153342"];
1696 [label="FullWidth = this.Text.Length; 153343"];
1697 [label="FullWidth 153344"];
1698 [label="return '%'; 153345"];
1699 [label="FullWidth = this.Text.Length; 153346"];
1700 [label="FullWidth 153347"];
1701 [label="this.AdjustFlagsAndWidth(leading); 153348"];
1702 [label="return '%'; 153349"];
1703 [label="FullWidth = this.Text.Length; 153350"];
1704 [label="FullWidth 153351"];
1705 [label="this.AdjustFlagsAndWidth(trailing); 153352"];
1706 [label="return '%'; 153353"];
1707 [label="FullWidth = this.Text.Length; 153354"];
1708 [label="FullWidth 153355"];
1709 [label="this.AdjustFlagsAndWidth(trailing); 153356"];
1710 [label="return '^'; 153357"];
1711 [label="FullWidth = this.Text.Length; 153358"];
1712 [label="FullWidth 153359"];
1713 [label="return '^'; 153360"];
1714 [label="FullWidth = this.Text.Length; 153361"];
1715 [label="FullWidth 153362"];
1716 [label="this.AdjustFlagsAndWidth(leading); 153363"];
1717 [label="return '^'; 153364"];
1718 [label="FullWidth = this.Text.Length; 153365"];
1719 [label="FullWidth 153366"];
1720 [label="this.AdjustFlagsAndWidth(trailing); 153367"];
1721 [label="return '^'; 153368"];
1722 [label="FullWidth = this.Text.Length; 153369"];
1723 [label="FullWidth 153370"];
1724 [label="this.AdjustFlagsAndWidth(trailing); 153371"];
1725 [label="return '&'; 153372"];
1726 [label="FullWidth = this.Text.Length; 153373"];
1727 [label="FullWidth 153374"];
1728 [label="return '&'; 153375"];
1729 [label="FullWidth = this.Text.Length; 153376"];
1730 [label="FullWidth 153377"];
1731 [label="this.AdjustFlagsAndWidth(leading); 153378"];
1732 [label="return '&'; 153379"];
1733 [label="FullWidth = this.Text.Length; 153380"];
1734 [label="FullWidth 153381"];
1735 [label="this.AdjustFlagsAndWidth(trailing); 153382"];
1736 [label="return '&'; 153383"];
1737 [label="FullWidth = this.Text.Length; 153384"];
1738 [label="FullWidth 153385"];
1739 [label="this.AdjustFlagsAndWidth(trailing); 153386"];
1740 [label="return '*'; 153387"];
1741 [label="FullWidth = this.Text.Length; 153388"];
1742 [label="FullWidth 153389"];
1743 [label="return '*'; 153390"];
1744 [label="FullWidth = this.Text.Length; 153391"];
1745 [label="FullWidth 153392"];
1746 [label="this.AdjustFlagsAndWidth(leading); 153393"];
1747 [label="return '*'; 153394"];
1748 [label="FullWidth = this.Text.Length; 153395"];
1749 [label="FullWidth 153396"];
1750 [label="this.AdjustFlagsAndWidth(trailing); 153397"];
1751 [label="return '*'; 153398"];
1752 [label="FullWidth = this.Text.Length; 153399"];
1753 [label="FullWidth 153400"];
1754 [label="this.AdjustFlagsAndWidth(trailing); 153401"];
1755 [label="return '('; 153402"];
1756 [label="FullWidth = this.Text.Length; 153403"];
1757 [label="FullWidth 153404"];
1758 [label="return '('; 153405"];
1759 [label="FullWidth = this.Text.Length; 153406"];
1760 [label="FullWidth 153407"];
1761 [label="this.AdjustFlagsAndWidth(leading); 153408"];
1762 [label="return '('; 153409"];
1763 [label="FullWidth = this.Text.Length; 153410"];
1764 [label="FullWidth 153411"];
1765 [label="this.AdjustFlagsAndWidth(trailing); 153412"];
1766 [label="return '('; 153413"];
1767 [label="FullWidth = this.Text.Length; 153414"];
1768 [label="FullWidth 153415"];
1769 [label="this.AdjustFlagsAndWidth(trailing); 153416"];
1770 [label="return ')'; 153417"];
1771 [label="FullWidth = this.Text.Length; 153418"];
1772 [label="FullWidth 153419"];
1773 [label="return ')'; 153420"];
1774 [label="FullWidth = this.Text.Length; 153421"];
1775 [label="FullWidth 153422"];
1776 [label="this.AdjustFlagsAndWidth(leading); 153423"];
1777 [label="return ')'; 153424"];
1778 [label="FullWidth = this.Text.Length; 153425"];
1779 [label="FullWidth 153426"];
1780 [label="this.AdjustFlagsAndWidth(trailing); 153427"];
1781 [label="return ')'; 153428"];
1782 [label="FullWidth = this.Text.Length; 153429"];
1783 [label="FullWidth 153430"];
1784 [label="this.AdjustFlagsAndWidth(trailing); 153431"];
1785 [label="return '-'; 153432"];
1786 [label="FullWidth = this.Text.Length; 153433"];
1787 [label="FullWidth 153434"];
1788 [label="return '-'; 153435"];
1789 [label="FullWidth = this.Text.Length; 153436"];
1790 [label="FullWidth 153437"];
1791 [label="this.AdjustFlagsAndWidth(leading); 153438"];
1792 [label="return '-'; 153439"];
1793 [label="FullWidth = this.Text.Length; 153440"];
1794 [label="FullWidth 153441"];
1795 [label="this.AdjustFlagsAndWidth(trailing); 153442"];
1796 [label="return '-'; 153443"];
1797 [label="FullWidth = this.Text.Length; 153444"];
1798 [label="FullWidth 153445"];
1799 [label="this.AdjustFlagsAndWidth(trailing); 153446"];
1800 [label="return '+'; 153447"];
1801 [label="FullWidth = this.Text.Length; 153448"];
1802 [label="FullWidth 153449"];
1803 [label="return '+'; 153450"];
1804 [label="FullWidth = this.Text.Length; 153451"];
1805 [label="FullWidth 153452"];
1806 [label="this.AdjustFlagsAndWidth(leading); 153453"];
1807 [label="return '+'; 153454"];
1808 [label="FullWidth = this.Text.Length; 153455"];
1809 [label="FullWidth 153456"];
1810 [label="this.AdjustFlagsAndWidth(trailing); 153457"];
1811 [label="return '+'; 153458"];
1812 [label="FullWidth = this.Text.Length; 153459"];
1813 [label="FullWidth 153460"];
1814 [label="this.AdjustFlagsAndWidth(trailing); 153461"];
1815 [label="return '='; 153462"];
1816 [label="FullWidth = this.Text.Length; 153463"];
1817 [label="FullWidth 153464"];
1818 [label="return '='; 153465"];
1819 [label="FullWidth = this.Text.Length; 153466"];
1820 [label="FullWidth 153467"];
1821 [label="this.AdjustFlagsAndWidth(leading); 153468"];
1822 [label="return '='; 153469"];
1823 [label="FullWidth = this.Text.Length; 153470"];
1824 [label="FullWidth 153471"];
1825 [label="this.AdjustFlagsAndWidth(trailing); 153472"];
1826 [label="return '='; 153473"];
1827 [label="FullWidth = this.Text.Length; 153474"];
1828 [label="FullWidth 153475"];
1829 [label="this.AdjustFlagsAndWidth(trailing); 153476"];
1830 [label="return '{'; 153477"];
1831 [label="FullWidth = this.Text.Length; 153478"];
1832 [label="FullWidth 153479"];
1833 [label="return '{'; 153480"];
1834 [label="FullWidth = this.Text.Length; 153481"];
1835 [label="FullWidth 153482"];
1836 [label="this.AdjustFlagsAndWidth(leading); 153483"];
1837 [label="return '{'; 153484"];
1838 [label="FullWidth = this.Text.Length; 153485"];
1839 [label="FullWidth 153486"];
1840 [label="this.AdjustFlagsAndWidth(trailing); 153487"];
1841 [label="return '{'; 153488"];
1842 [label="FullWidth = this.Text.Length; 153489"];
1843 [label="FullWidth 153490"];
1844 [label="this.AdjustFlagsAndWidth(trailing); 153491"];
1845 [label="return '}'; 153492"];
1846 [label="FullWidth = this.Text.Length; 153493"];
1847 [label="FullWidth 153494"];
1848 [label="return '}'; 153495"];
1849 [label="FullWidth = this.Text.Length; 153496"];
1850 [label="FullWidth 153497"];
1851 [label="this.AdjustFlagsAndWidth(leading); 153498"];
1852 [label="return '}'; 153499"];
1853 [label="FullWidth = this.Text.Length; 153500"];
1854 [label="FullWidth 153501"];
1855 [label="this.AdjustFlagsAndWidth(trailing); 153502"];
1856 [label="return '}'; 153503"];
1857 [label="FullWidth = this.Text.Length; 153504"];
1858 [label="FullWidth 153505"];
1859 [label="this.AdjustFlagsAndWidth(trailing); 153506"];
1860 [label="return '['; 153507"];
1861 [label="FullWidth = this.Text.Length; 153508"];
1862 [label="FullWidth 153509"];
1863 [label="return '['; 153510"];
1864 [label="FullWidth = this.Text.Length; 153511"];
1865 [label="FullWidth 153512"];
1866 [label="this.AdjustFlagsAndWidth(leading); 153513"];
1867 [label="return '['; 153514"];
1868 [label="FullWidth = this.Text.Length; 153515"];
1869 [label="FullWidth 153516"];
1870 [label="this.AdjustFlagsAndWidth(trailing); 153517"];
1871 [label="return '['; 153518"];
1872 [label="FullWidth = this.Text.Length; 153519"];
1873 [label="FullWidth 153520"];
1874 [label="this.AdjustFlagsAndWidth(trailing); 153521"];
1875 [label="return ']'; 153522"];
1876 [label="FullWidth = this.Text.Length; 153523"];
1877 [label="FullWidth 153524"];
1878 [label="return ']'; 153525"];
1879 [label="FullWidth = this.Text.Length; 153526"];
1880 [label="FullWidth 153527"];
1881 [label="this.AdjustFlagsAndWidth(leading); 153528"];
1882 [label="return ']'; 153529"];
1883 [label="FullWidth = this.Text.Length; 153530"];
1884 [label="FullWidth 153531"];
1885 [label="this.AdjustFlagsAndWidth(trailing); 153532"];
1886 [label="return ']'; 153533"];
1887 [label="FullWidth = this.Text.Length; 153534"];
1888 [label="FullWidth 153535"];
1889 [label="this.AdjustFlagsAndWidth(trailing); 153536"];
1890 [label="return '|'; 153537"];
1891 [label="FullWidth = this.Text.Length; 153538"];
1892 [label="FullWidth 153539"];
1893 [label="return '|'; 153540"];
1894 [label="FullWidth = this.Text.Length; 153541"];
1895 [label="FullWidth 153542"];
1896 [label="this.AdjustFlagsAndWidth(leading); 153543"];
1897 [label="return '|'; 153544"];
1898 [label="FullWidth = this.Text.Length; 153545"];
1899 [label="FullWidth 153546"];
1900 [label="this.AdjustFlagsAndWidth(trailing); 153547"];
1901 [label="return '|'; 153548"];
1902 [label="FullWidth = this.Text.Length; 153549"];
1903 [label="FullWidth 153550"];
1904 [label="this.AdjustFlagsAndWidth(trailing); 153551"];
1905 [label="return '\\\\'; 153552"];
1906 [label="FullWidth = this.Text.Length; 153553"];
1907 [label="FullWidth 153554"];
1908 [label="return '\\\\'; 153555"];
1909 [label="FullWidth = this.Text.Length; 153556"];
1910 [label="FullWidth 153557"];
1911 [label="this.AdjustFlagsAndWidth(leading); 153558"];
1912 [label="return '\\\\'; 153559"];
1913 [label="FullWidth = this.Text.Length; 153560"];
1914 [label="FullWidth 153561"];
1915 [label="this.AdjustFlagsAndWidth(trailing); 153562"];
1916 [label="return '\\\\'; 153563"];
1917 [label="FullWidth = this.Text.Length; 153564"];
1918 [label="FullWidth 153565"];
1919 [label="this.AdjustFlagsAndWidth(trailing); 153566"];
1920 [label="return ':'; 153567"];
1921 [label="FullWidth = this.Text.Length; 153568"];
1922 [label="FullWidth 153569"];
1923 [label="return ':'; 153570"];
1924 [label="FullWidth = this.Text.Length; 153571"];
1925 [label="FullWidth 153572"];
1926 [label="this.AdjustFlagsAndWidth(leading); 153573"];
1927 [label="return ':'; 153574"];
1928 [label="FullWidth = this.Text.Length; 153575"];
1929 [label="FullWidth 153576"];
1930 [label="this.AdjustFlagsAndWidth(trailing); 153577"];
1931 [label="return ':'; 153578"];
1932 [label="FullWidth = this.Text.Length; 153579"];
1933 [label="FullWidth 153580"];
1934 [label="this.AdjustFlagsAndWidth(trailing); 153581"];
1935 [label="return ';'; 153582"];
1936 [label="FullWidth = this.Text.Length; 153583"];
1937 [label="FullWidth 153584"];
1938 [label="return ';'; 153585"];
1939 [label="FullWidth = this.Text.Length; 153586"];
1940 [label="FullWidth 153587"];
1941 [label="this.AdjustFlagsAndWidth(leading); 153588"];
1942 [label="return ';'; 153589"];
1943 [label="FullWidth = this.Text.Length; 153590"];
1944 [label="FullWidth 153591"];
1945 [label="this.AdjustFlagsAndWidth(trailing); 153592"];
1946 [label="return ';'; 153593"];
1947 [label="FullWidth = this.Text.Length; 153594"];
1948 [label="FullWidth 153595"];
1949 [label="this.AdjustFlagsAndWidth(trailing); 153596"];
1950 [label="return '\\''; 153597"];
1951 [label="FullWidth = this.Text.Length; 153598"];
1952 [label="FullWidth 153599"];
1953 [label="return '\\''; 153600"];
1954 [label="FullWidth = this.Text.Length; 153601"];
1955 [label="FullWidth 153602"];
1956 [label="this.AdjustFlagsAndWidth(leading); 153603"];
1957 [label="return '\\''; 153604"];
1958 [label="FullWidth = this.Text.Length; 153605"];
1959 [label="FullWidth 153606"];
1960 [label="this.AdjustFlagsAndWidth(trailing); 153607"];
1961 [label="return '\\''; 153608"];
1962 [label="FullWidth = this.Text.Length; 153609"];
1963 [label="FullWidth 153610"];
1964 [label="this.AdjustFlagsAndWidth(trailing); 153611"];
1965 [label="return '''; 153612"];
1966 [label="FullWidth = this.Text.Length; 153613"];
1967 [label="FullWidth 153614"];
1968 [label="return '''; 153615"];
1969 [label="FullWidth = this.Text.Length; 153616"];
1970 [label="FullWidth 153617"];
1971 [label="this.AdjustFlagsAndWidth(leading); 153618"];
1972 [label="return '''; 153619"];
1973 [label="FullWidth = this.Text.Length; 153620"];
1974 [label="FullWidth 153621"];
1975 [label="this.AdjustFlagsAndWidth(trailing); 153622"];
1976 [label="return '''; 153623"];
1977 [label="FullWidth = this.Text.Length; 153624"];
1978 [label="FullWidth 153625"];
1979 [label="this.AdjustFlagsAndWidth(trailing); 153626"];
1980 [label="return '<'; 153627"];
1981 [label="FullWidth = this.Text.Length; 153628"];
1982 [label="FullWidth 153629"];
1983 [label="return '<'; 153630"];
1984 [label="FullWidth = this.Text.Length; 153631"];
1985 [label="FullWidth 153632"];
1986 [label="this.AdjustFlagsAndWidth(leading); 153633"];
1987 [label="return '<'; 153634"];
1988 [label="FullWidth = this.Text.Length; 153635"];
1989 [label="FullWidth 153636"];
1990 [label="this.AdjustFlagsAndWidth(trailing); 153637"];
1991 [label="return '<'; 153638"];
1992 [label="FullWidth = this.Text.Length; 153639"];
1993 [label="FullWidth 153640"];
1994 [label="this.AdjustFlagsAndWidth(trailing); 153641"];
1995 [label="return ','; 153642"];
1996 [label="FullWidth = this.Text.Length; 153643"];
1997 [label="FullWidth 153644"];
1998 [label="return ','; 153645"];
1999 [label="FullWidth = this.Text.Length; 153646"];
2000 [label="FullWidth 153647"];
2001 [label="this.AdjustFlagsAndWidth(leading); 153648"];
2002 [label="return ','; 153649"];
2003 [label="FullWidth = this.Text.Length; 153650"];
2004 [label="FullWidth 153651"];
2005 [label="this.AdjustFlagsAndWidth(trailing); 153652"];
2006 [label="return ','; 153653"];
2007 [label="FullWidth = this.Text.Length; 153654"];
2008 [label="FullWidth 153655"];
2009 [label="this.AdjustFlagsAndWidth(trailing); 153656"];
2010 [label="return '>'; 153657"];
2011 [label="FullWidth = this.Text.Length; 153658"];
2012 [label="FullWidth 153659"];
2013 [label="return '>'; 153660"];
2014 [label="FullWidth = this.Text.Length; 153661"];
2015 [label="FullWidth 153662"];
2016 [label="this.AdjustFlagsAndWidth(leading); 153663"];
2017 [label="return '>'; 153664"];
2018 [label="FullWidth = this.Text.Length; 153665"];
2019 [label="FullWidth 153666"];
2020 [label="this.AdjustFlagsAndWidth(trailing); 153667"];
2021 [label="return '>'; 153668"];
2022 [label="FullWidth = this.Text.Length; 153669"];
2023 [label="FullWidth 153670"];
2024 [label="this.AdjustFlagsAndWidth(trailing); 153671"];
2025 [label="return '.'; 153672"];
2026 [label="FullWidth = this.Text.Length; 153673"];
2027 [label="FullWidth 153674"];
2028 [label="return '.'; 153675"];
2029 [label="FullWidth = this.Text.Length; 153676"];
2030 [label="FullWidth 153677"];
2031 [label="this.AdjustFlagsAndWidth(leading); 153678"];
2032 [label="return '.'; 153679"];
2033 [label="FullWidth = this.Text.Length; 153680"];
2034 [label="FullWidth 153681"];
2035 [label="this.AdjustFlagsAndWidth(trailing); 153682"];
2036 [label="return '.'; 153683"];
2037 [label="FullWidth = this.Text.Length; 153684"];
2038 [label="FullWidth 153685"];
2039 [label="this.AdjustFlagsAndWidth(trailing); 153686"];
2040 [label="return '?'; 153687"];
2041 [label="FullWidth = this.Text.Length; 153688"];
2042 [label="FullWidth 153689"];
2043 [label="return '?'; 153690"];
2044 [label="FullWidth = this.Text.Length; 153691"];
2045 [label="FullWidth 153692"];
2046 [label="this.AdjustFlagsAndWidth(leading); 153693"];
2047 [label="return '?'; 153694"];
2048 [label="FullWidth = this.Text.Length; 153695"];
2049 [label="FullWidth 153696"];
2050 [label="this.AdjustFlagsAndWidth(trailing); 153697"];
2051 [label="return '?'; 153698"];
2052 [label="FullWidth = this.Text.Length; 153699"];
2053 [label="FullWidth 153700"];
2054 [label="this.AdjustFlagsAndWidth(trailing); 153701"];
2055 [label="return '#'; 153702"];
2056 [label="FullWidth = this.Text.Length; 153703"];
2057 [label="FullWidth 153704"];
2058 [label="return '#'; 153705"];
2059 [label="FullWidth = this.Text.Length; 153706"];
2060 [label="FullWidth 153707"];
2061 [label="this.AdjustFlagsAndWidth(leading); 153708"];
2062 [label="return '#'; 153709"];
2063 [label="FullWidth = this.Text.Length; 153710"];
2064 [label="FullWidth 153711"];
2065 [label="this.AdjustFlagsAndWidth(trailing); 153712"];
2066 [label="return '#'; 153713"];
2067 [label="FullWidth = this.Text.Length; 153714"];
2068 [label="FullWidth 153715"];
2069 [label="this.AdjustFlagsAndWidth(trailing); 153716"];
2070 [label="return '/'; 153717"];
2071 [label="FullWidth = this.Text.Length; 153718"];
2072 [label="FullWidth 153719"];
2073 [label="return '/'; 153720"];
2074 [label="FullWidth = this.Text.Length; 153721"];
2075 [label="FullWidth 153722"];
2076 [label="this.AdjustFlagsAndWidth(leading); 153723"];
2077 [label="return '/'; 153724"];
2078 [label="FullWidth = this.Text.Length; 153725"];
2079 [label="FullWidth 153726"];
2080 [label="this.AdjustFlagsAndWidth(trailing); 153727"];
2081 [label="return '/'; 153728"];
2082 [label="FullWidth = this.Text.Length; 153729"];
2083 [label="FullWidth 153730"];
2084 [label="this.AdjustFlagsAndWidth(trailing); 153731"];
2085 [label="return '..'; 153732"];
2086 [label="FullWidth = this.Text.Length; 153733"];
2087 [label="FullWidth 153734"];
2088 [label="return '..'; 153735"];
2089 [label="FullWidth = this.Text.Length; 153736"];
2090 [label="FullWidth 153737"];
2091 [label="this.AdjustFlagsAndWidth(leading); 153738"];
2092 [label="return '..'; 153739"];
2093 [label="FullWidth = this.Text.Length; 153740"];
2094 [label="FullWidth 153741"];
2095 [label="this.AdjustFlagsAndWidth(trailing); 153742"];
2096 [label="return '..'; 153743"];
2097 [label="FullWidth = this.Text.Length; 153744"];
2098 [label="FullWidth 153745"];
2099 [label="this.AdjustFlagsAndWidth(trailing); 153746"];
2100 [label="return string.Empty; 153747"];
2101 [label="FullWidth = this.Text.Length; 153748"];
2102 [label="FullWidth 153749"];
2103 [label="return string.Empty; 153750"];
2104 [label="FullWidth = this.Text.Length; 153751"];
2105 [label="FullWidth 153752"];
2106 [label="this.AdjustFlagsAndWidth(leading); 153753"];
2107 [label="return string.Empty; 153754"];
2108 [label="FullWidth = this.Text.Length; 153755"];
2109 [label="FullWidth 153756"];
2110 [label="this.AdjustFlagsAndWidth(trailing); 153757"];
2111 [label="return string.Empty; 153758"];
2112 [label="FullWidth = this.Text.Length; 153759"];
2113 [label="FullWidth 153760"];
2114 [label="this.AdjustFlagsAndWidth(trailing); 153761"];
2115 [label="return '/>'; 153762"];
2116 [label="FullWidth = this.Text.Length; 153763"];
2117 [label="FullWidth 153764"];
2118 [label="return '/>'; 153765"];
2119 [label="FullWidth = this.Text.Length; 153766"];
2120 [label="FullWidth 153767"];
2121 [label="this.AdjustFlagsAndWidth(leading); 153768"];
2122 [label="return '/>'; 153769"];
2123 [label="FullWidth = this.Text.Length; 153770"];
2124 [label="FullWidth 153771"];
2125 [label="this.AdjustFlagsAndWidth(trailing); 153772"];
2126 [label="return '/>'; 153773"];
2127 [label="FullWidth = this.Text.Length; 153774"];
2128 [label="FullWidth 153775"];
2129 [label="this.AdjustFlagsAndWidth(trailing); 153776"];
2130 [label="return '</'; 153777"];
2131 [label="FullWidth = this.Text.Length; 153778"];
2132 [label="FullWidth 153779"];
2133 [label="return '</'; 153780"];
2134 [label="FullWidth = this.Text.Length; 153781"];
2135 [label="FullWidth 153782"];
2136 [label="this.AdjustFlagsAndWidth(leading); 153783"];
2137 [label="return '</'; 153784"];
2138 [label="FullWidth = this.Text.Length; 153785"];
2139 [label="FullWidth 153786"];
2140 [label="this.AdjustFlagsAndWidth(trailing); 153787"];
2141 [label="return '</'; 153788"];
2142 [label="FullWidth = this.Text.Length; 153789"];
2143 [label="FullWidth 153790"];
2144 [label="this.AdjustFlagsAndWidth(trailing); 153791"];
2145 [label="return '<!--'; 153792"];
2146 [label="FullWidth = this.Text.Length; 153793"];
2147 [label="FullWidth 153794"];
2148 [label="return '<!--'; 153795"];
2149 [label="FullWidth = this.Text.Length; 153796"];
2150 [label="FullWidth 153797"];
2151 [label="this.AdjustFlagsAndWidth(leading); 153798"];
2152 [label="return '<!--'; 153799"];
2153 [label="FullWidth = this.Text.Length; 153800"];
2154 [label="FullWidth 153801"];
2155 [label="this.AdjustFlagsAndWidth(trailing); 153802"];
2156 [label="return '<!--'; 153803"];
2157 [label="FullWidth = this.Text.Length; 153804"];
2158 [label="FullWidth 153805"];
2159 [label="this.AdjustFlagsAndWidth(trailing); 153806"];
2160 [label="return '-->'; 153807"];
2161 [label="FullWidth = this.Text.Length; 153808"];
2162 [label="FullWidth 153809"];
2163 [label="return '-->'; 153810"];
2164 [label="FullWidth = this.Text.Length; 153811"];
2165 [label="FullWidth 153812"];
2166 [label="this.AdjustFlagsAndWidth(leading); 153813"];
2167 [label="return '-->'; 153814"];
2168 [label="FullWidth = this.Text.Length; 153815"];
2169 [label="FullWidth 153816"];
2170 [label="this.AdjustFlagsAndWidth(trailing); 153817"];
2171 [label="return '-->'; 153818"];
2172 [label="FullWidth = this.Text.Length; 153819"];
2173 [label="FullWidth 153820"];
2174 [label="this.AdjustFlagsAndWidth(trailing); 153821"];
2175 [label="return '<![CDATA['; 153822"];
2176 [label="FullWidth = this.Text.Length; 153823"];
2177 [label="FullWidth 153824"];
2178 [label="return '<![CDATA['; 153825"];
2179 [label="FullWidth = this.Text.Length; 153826"];
2180 [label="FullWidth 153827"];
2181 [label="this.AdjustFlagsAndWidth(leading); 153828"];
2182 [label="return '<![CDATA['; 153829"];
2183 [label="FullWidth = this.Text.Length; 153830"];
2184 [label="FullWidth 153831"];
2185 [label="this.AdjustFlagsAndWidth(trailing); 153832"];
2186 [label="return '<![CDATA['; 153833"];
2187 [label="FullWidth = this.Text.Length; 153834"];
2188 [label="FullWidth 153835"];
2189 [label="this.AdjustFlagsAndWidth(trailing); 153836"];
2190 [label="return ']]>'; 153837"];
2191 [label="FullWidth = this.Text.Length; 153838"];
2192 [label="FullWidth 153839"];
2193 [label="return ']]>'; 153840"];
2194 [label="FullWidth = this.Text.Length; 153841"];
2195 [label="FullWidth 153842"];
2196 [label="this.AdjustFlagsAndWidth(leading); 153843"];
2197 [label="return ']]>'; 153844"];
2198 [label="FullWidth = this.Text.Length; 153845"];
2199 [label="FullWidth 153846"];
2200 [label="this.AdjustFlagsAndWidth(trailing); 153847"];
2201 [label="return ']]>'; 153848"];
2202 [label="FullWidth = this.Text.Length; 153849"];
2203 [label="FullWidth 153850"];
2204 [label="this.AdjustFlagsAndWidth(trailing); 153851"];
2205 [label="return '<?'; 153852"];
2206 [label="FullWidth = this.Text.Length; 153853"];
2207 [label="FullWidth 153854"];
2208 [label="return '<?'; 153855"];
2209 [label="FullWidth = this.Text.Length; 153856"];
2210 [label="FullWidth 153857"];
2211 [label="this.AdjustFlagsAndWidth(leading); 153858"];
2212 [label="return '<?'; 153859"];
2213 [label="FullWidth = this.Text.Length; 153860"];
2214 [label="FullWidth 153861"];
2215 [label="this.AdjustFlagsAndWidth(trailing); 153862"];
2216 [label="return '<?'; 153863"];
2217 [label="FullWidth = this.Text.Length; 153864"];
2218 [label="FullWidth 153865"];
2219 [label="this.AdjustFlagsAndWidth(trailing); 153866"];
2220 [label="return '?>'; 153867"];
2221 [label="FullWidth = this.Text.Length; 153868"];
2222 [label="FullWidth 153869"];
2223 [label="return '?>'; 153870"];
2224 [label="FullWidth = this.Text.Length; 153871"];
2225 [label="FullWidth 153872"];
2226 [label="this.AdjustFlagsAndWidth(leading); 153873"];
2227 [label="return '?>'; 153874"];
2228 [label="FullWidth = this.Text.Length; 153875"];
2229 [label="FullWidth 153876"];
2230 [label="this.AdjustFlagsAndWidth(trailing); 153877"];
2231 [label="return '?>'; 153878"];
2232 [label="FullWidth = this.Text.Length; 153879"];
2233 [label="FullWidth 153880"];
2234 [label="this.AdjustFlagsAndWidth(trailing); 153881"];
2235 [label="return '||'; 153882"];
2236 [label="FullWidth = this.Text.Length; 153883"];
2237 [label="FullWidth 153884"];
2238 [label="return '||'; 153885"];
2239 [label="FullWidth = this.Text.Length; 153886"];
2240 [label="FullWidth 153887"];
2241 [label="this.AdjustFlagsAndWidth(leading); 153888"];
2242 [label="return '||'; 153889"];
2243 [label="FullWidth = this.Text.Length; 153890"];
2244 [label="FullWidth 153891"];
2245 [label="this.AdjustFlagsAndWidth(trailing); 153892"];
2246 [label="return '||'; 153893"];
2247 [label="FullWidth = this.Text.Length; 153894"];
2248 [label="FullWidth 153895"];
2249 [label="this.AdjustFlagsAndWidth(trailing); 153896"];
2250 [label="return '&&'; 153897"];
2251 [label="FullWidth = this.Text.Length; 153898"];
2252 [label="FullWidth 153899"];
2253 [label="return '&&'; 153900"];
2254 [label="FullWidth = this.Text.Length; 153901"];
2255 [label="FullWidth 153902"];
2256 [label="this.AdjustFlagsAndWidth(leading); 153903"];
2257 [label="return '&&'; 153904"];
2258 [label="FullWidth = this.Text.Length; 153905"];
2259 [label="FullWidth 153906"];
2260 [label="this.AdjustFlagsAndWidth(trailing); 153907"];
2261 [label="return '&&'; 153908"];
2262 [label="FullWidth = this.Text.Length; 153909"];
2263 [label="FullWidth 153910"];
2264 [label="this.AdjustFlagsAndWidth(trailing); 153911"];
2265 [label="return '--'; 153912"];
2266 [label="FullWidth = this.Text.Length; 153913"];
2267 [label="FullWidth 153914"];
2268 [label="return '--'; 153915"];
2269 [label="FullWidth = this.Text.Length; 153916"];
2270 [label="FullWidth 153917"];
2271 [label="this.AdjustFlagsAndWidth(leading); 153918"];
2272 [label="return '--'; 153919"];
2273 [label="FullWidth = this.Text.Length; 153920"];
2274 [label="FullWidth 153921"];
2275 [label="this.AdjustFlagsAndWidth(trailing); 153922"];
2276 [label="return '--'; 153923"];
2277 [label="FullWidth = this.Text.Length; 153924"];
2278 [label="FullWidth 153925"];
2279 [label="this.AdjustFlagsAndWidth(trailing); 153926"];
2280 [label="return '++'; 153927"];
2281 [label="FullWidth = this.Text.Length; 153928"];
2282 [label="FullWidth 153929"];
2283 [label="return '++'; 153930"];
2284 [label="FullWidth = this.Text.Length; 153931"];
2285 [label="FullWidth 153932"];
2286 [label="this.AdjustFlagsAndWidth(leading); 153933"];
2287 [label="return '++'; 153934"];
2288 [label="FullWidth = this.Text.Length; 153935"];
2289 [label="FullWidth 153936"];
2290 [label="this.AdjustFlagsAndWidth(trailing); 153937"];
2291 [label="return '++'; 153938"];
2292 [label="FullWidth = this.Text.Length; 153939"];
2293 [label="FullWidth 153940"];
2294 [label="this.AdjustFlagsAndWidth(trailing); 153941"];
2295 [label="return '::'; 153942"];
2296 [label="FullWidth = this.Text.Length; 153943"];
2297 [label="FullWidth 153944"];
2298 [label="return '::'; 153945"];
2299 [label="FullWidth = this.Text.Length; 153946"];
2300 [label="FullWidth 153947"];
2301 [label="this.AdjustFlagsAndWidth(leading); 153948"];
2302 [label="return '::'; 153949"];
2303 [label="FullWidth = this.Text.Length; 153950"];
2304 [label="FullWidth 153951"];
2305 [label="this.AdjustFlagsAndWidth(trailing); 153952"];
2306 [label="return '::'; 153953"];
2307 [label="FullWidth = this.Text.Length; 153954"];
2308 [label="FullWidth 153955"];
2309 [label="this.AdjustFlagsAndWidth(trailing); 153956"];
2310 [label="return '??'; 153957"];
2311 [label="FullWidth = this.Text.Length; 153958"];
2312 [label="FullWidth 153959"];
2313 [label="return '??'; 153960"];
2314 [label="FullWidth = this.Text.Length; 153961"];
2315 [label="FullWidth 153962"];
2316 [label="this.AdjustFlagsAndWidth(leading); 153963"];
2317 [label="return '??'; 153964"];
2318 [label="FullWidth = this.Text.Length; 153965"];
2319 [label="FullWidth 153966"];
2320 [label="this.AdjustFlagsAndWidth(trailing); 153967"];
2321 [label="return '??'; 153968"];
2322 [label="FullWidth = this.Text.Length; 153969"];
2323 [label="FullWidth 153970"];
2324 [label="this.AdjustFlagsAndWidth(trailing); 153971"];
2325 [label="return '->'; 153972"];
2326 [label="FullWidth = this.Text.Length; 153973"];
2327 [label="FullWidth 153974"];
2328 [label="return '->'; 153975"];
2329 [label="FullWidth = this.Text.Length; 153976"];
2330 [label="FullWidth 153977"];
2331 [label="this.AdjustFlagsAndWidth(leading); 153978"];
2332 [label="return '->'; 153979"];
2333 [label="FullWidth = this.Text.Length; 153980"];
2334 [label="FullWidth 153981"];
2335 [label="this.AdjustFlagsAndWidth(trailing); 153982"];
2336 [label="return '->'; 153983"];
2337 [label="FullWidth = this.Text.Length; 153984"];
2338 [label="FullWidth 153985"];
2339 [label="this.AdjustFlagsAndWidth(trailing); 153986"];
2340 [label="return '!='; 153987"];
2341 [label="FullWidth = this.Text.Length; 153988"];
2342 [label="FullWidth 153989"];
2343 [label="return '!='; 153990"];
2344 [label="FullWidth = this.Text.Length; 153991"];
2345 [label="FullWidth 153992"];
2346 [label="this.AdjustFlagsAndWidth(leading); 153993"];
2347 [label="return '!='; 153994"];
2348 [label="FullWidth = this.Text.Length; 153995"];
2349 [label="FullWidth 153996"];
2350 [label="this.AdjustFlagsAndWidth(trailing); 153997"];
2351 [label="return '!='; 153998"];
2352 [label="FullWidth = this.Text.Length; 153999"];
2353 [label="FullWidth 154000"];
2354 [label="this.AdjustFlagsAndWidth(trailing); 154001"];
2355 [label="return '=='; 154002"];
2356 [label="FullWidth = this.Text.Length; 154003"];
2357 [label="FullWidth 154004"];
2358 [label="return '=='; 154005"];
2359 [label="FullWidth = this.Text.Length; 154006"];
2360 [label="FullWidth 154007"];
2361 [label="this.AdjustFlagsAndWidth(leading); 154008"];
2362 [label="return '=='; 154009"];
2363 [label="FullWidth = this.Text.Length; 154010"];
2364 [label="FullWidth 154011"];
2365 [label="this.AdjustFlagsAndWidth(trailing); 154012"];
2366 [label="return '=='; 154013"];
2367 [label="FullWidth = this.Text.Length; 154014"];
2368 [label="FullWidth 154015"];
2369 [label="this.AdjustFlagsAndWidth(trailing); 154016"];
2370 [label="return '=>'; 154017"];
2371 [label="FullWidth = this.Text.Length; 154018"];
2372 [label="FullWidth 154019"];
2373 [label="return '=>'; 154020"];
2374 [label="FullWidth = this.Text.Length; 154021"];
2375 [label="FullWidth 154022"];
2376 [label="this.AdjustFlagsAndWidth(leading); 154023"];
2377 [label="return '=>'; 154024"];
2378 [label="FullWidth = this.Text.Length; 154025"];
2379 [label="FullWidth 154026"];
2380 [label="this.AdjustFlagsAndWidth(trailing); 154027"];
2381 [label="return '=>'; 154028"];
2382 [label="FullWidth = this.Text.Length; 154029"];
2383 [label="FullWidth 154030"];
2384 [label="this.AdjustFlagsAndWidth(trailing); 154031"];
2385 [label="return '<='; 154032"];
2386 [label="FullWidth = this.Text.Length; 154033"];
2387 [label="FullWidth 154034"];
2388 [label="return '<='; 154035"];
2389 [label="FullWidth = this.Text.Length; 154036"];
2390 [label="FullWidth 154037"];
2391 [label="this.AdjustFlagsAndWidth(leading); 154038"];
2392 [label="return '<='; 154039"];
2393 [label="FullWidth = this.Text.Length; 154040"];
2394 [label="FullWidth 154041"];
2395 [label="this.AdjustFlagsAndWidth(trailing); 154042"];
2396 [label="return '<='; 154043"];
2397 [label="FullWidth = this.Text.Length; 154044"];
2398 [label="FullWidth 154045"];
2399 [label="this.AdjustFlagsAndWidth(trailing); 154046"];
2400 [label="return '<<'; 154047"];
2401 [label="FullWidth = this.Text.Length; 154048"];
2402 [label="FullWidth 154049"];
2403 [label="return '<<'; 154050"];
2404 [label="FullWidth = this.Text.Length; 154051"];
2405 [label="FullWidth 154052"];
2406 [label="this.AdjustFlagsAndWidth(leading); 154053"];
2407 [label="return '<<'; 154054"];
2408 [label="FullWidth = this.Text.Length; 154055"];
2409 [label="FullWidth 154056"];
2410 [label="this.AdjustFlagsAndWidth(trailing); 154057"];
2411 [label="return '<<'; 154058"];
2412 [label="FullWidth = this.Text.Length; 154059"];
2413 [label="FullWidth 154060"];
2414 [label="this.AdjustFlagsAndWidth(trailing); 154061"];
2415 [label="return '<<='; 154062"];
2416 [label="FullWidth = this.Text.Length; 154063"];
2417 [label="FullWidth 154064"];
2418 [label="return '<<='; 154065"];
2419 [label="FullWidth = this.Text.Length; 154066"];
2420 [label="FullWidth 154067"];
2421 [label="this.AdjustFlagsAndWidth(leading); 154068"];
2422 [label="return '<<='; 154069"];
2423 [label="FullWidth = this.Text.Length; 154070"];
2424 [label="FullWidth 154071"];
2425 [label="this.AdjustFlagsAndWidth(trailing); 154072"];
2426 [label="return '<<='; 154073"];
2427 [label="FullWidth = this.Text.Length; 154074"];
2428 [label="FullWidth 154075"];
2429 [label="this.AdjustFlagsAndWidth(trailing); 154076"];
2430 [label="return '>='; 154077"];
2431 [label="FullWidth = this.Text.Length; 154078"];
2432 [label="FullWidth 154079"];
2433 [label="return '>='; 154080"];
2434 [label="FullWidth = this.Text.Length; 154081"];
2435 [label="FullWidth 154082"];
2436 [label="this.AdjustFlagsAndWidth(leading); 154083"];
2437 [label="return '>='; 154084"];
2438 [label="FullWidth = this.Text.Length; 154085"];
2439 [label="FullWidth 154086"];
2440 [label="this.AdjustFlagsAndWidth(trailing); 154087"];
2441 [label="return '>='; 154088"];
2442 [label="FullWidth = this.Text.Length; 154089"];
2443 [label="FullWidth 154090"];
2444 [label="this.AdjustFlagsAndWidth(trailing); 154091"];
2445 [label="return '>>'; 154092"];
2446 [label="FullWidth = this.Text.Length; 154093"];
2447 [label="FullWidth 154094"];
2448 [label="return '>>'; 154095"];
2449 [label="FullWidth = this.Text.Length; 154096"];
2450 [label="FullWidth 154097"];
2451 [label="this.AdjustFlagsAndWidth(leading); 154098"];
2452 [label="return '>>'; 154099"];
2453 [label="FullWidth = this.Text.Length; 154100"];
2454 [label="FullWidth 154101"];
2455 [label="this.AdjustFlagsAndWidth(trailing); 154102"];
2456 [label="return '>>'; 154103"];
2457 [label="FullWidth = this.Text.Length; 154104"];
2458 [label="FullWidth 154105"];
2459 [label="this.AdjustFlagsAndWidth(trailing); 154106"];
2460 [label="return '>>='; 154107"];
2461 [label="FullWidth = this.Text.Length; 154108"];
2462 [label="FullWidth 154109"];
2463 [label="return '>>='; 154110"];
2464 [label="FullWidth = this.Text.Length; 154111"];
2465 [label="FullWidth 154112"];
2466 [label="this.AdjustFlagsAndWidth(leading); 154113"];
2467 [label="return '>>='; 154114"];
2468 [label="FullWidth = this.Text.Length; 154115"];
2469 [label="FullWidth 154116"];
2470 [label="this.AdjustFlagsAndWidth(trailing); 154117"];
2471 [label="return '>>='; 154118"];
2472 [label="FullWidth = this.Text.Length; 154119"];
2473 [label="FullWidth 154120"];
2474 [label="this.AdjustFlagsAndWidth(trailing); 154121"];
2475 [label="return '/='; 154122"];
2476 [label="FullWidth = this.Text.Length; 154123"];
2477 [label="FullWidth 154124"];
2478 [label="return '/='; 154125"];
2479 [label="FullWidth = this.Text.Length; 154126"];
2480 [label="FullWidth 154127"];
2481 [label="this.AdjustFlagsAndWidth(leading); 154128"];
2482 [label="return '/='; 154129"];
2483 [label="FullWidth = this.Text.Length; 154130"];
2484 [label="FullWidth 154131"];
2485 [label="this.AdjustFlagsAndWidth(trailing); 154132"];
2486 [label="return '/='; 154133"];
2487 [label="FullWidth = this.Text.Length; 154134"];
2488 [label="FullWidth 154135"];
2489 [label="this.AdjustFlagsAndWidth(trailing); 154136"];
2490 [label="return '*='; 154137"];
2491 [label="FullWidth = this.Text.Length; 154138"];
2492 [label="FullWidth 154139"];
2493 [label="return '*='; 154140"];
2494 [label="FullWidth = this.Text.Length; 154141"];
2495 [label="FullWidth 154142"];
2496 [label="this.AdjustFlagsAndWidth(leading); 154143"];
2497 [label="return '*='; 154144"];
2498 [label="FullWidth = this.Text.Length; 154145"];
2499 [label="FullWidth 154146"];
2500 [label="this.AdjustFlagsAndWidth(trailing); 154147"];
2501 [label="return '*='; 154148"];
2502 [label="FullWidth = this.Text.Length; 154149"];
2503 [label="FullWidth 154150"];
2504 [label="this.AdjustFlagsAndWidth(trailing); 154151"];
2505 [label="return '|='; 154152"];
2506 [label="FullWidth = this.Text.Length; 154153"];
2507 [label="FullWidth 154154"];
2508 [label="return '|='; 154155"];
2509 [label="FullWidth = this.Text.Length; 154156"];
2510 [label="FullWidth 154157"];
2511 [label="this.AdjustFlagsAndWidth(leading); 154158"];
2512 [label="return '|='; 154159"];
2513 [label="FullWidth = this.Text.Length; 154160"];
2514 [label="FullWidth 154161"];
2515 [label="this.AdjustFlagsAndWidth(trailing); 154162"];
2516 [label="return '|='; 154163"];
2517 [label="FullWidth = this.Text.Length; 154164"];
2518 [label="FullWidth 154165"];
2519 [label="this.AdjustFlagsAndWidth(trailing); 154166"];
2520 [label="return '&='; 154167"];
2521 [label="FullWidth = this.Text.Length; 154168"];
2522 [label="FullWidth 154169"];
2523 [label="return '&='; 154170"];
2524 [label="FullWidth = this.Text.Length; 154171"];
2525 [label="FullWidth 154172"];
2526 [label="this.AdjustFlagsAndWidth(leading); 154173"];
2527 [label="return '&='; 154174"];
2528 [label="FullWidth = this.Text.Length; 154175"];
2529 [label="FullWidth 154176"];
2530 [label="this.AdjustFlagsAndWidth(trailing); 154177"];
2531 [label="return '&='; 154178"];
2532 [label="FullWidth = this.Text.Length; 154179"];
2533 [label="FullWidth 154180"];
2534 [label="this.AdjustFlagsAndWidth(trailing); 154181"];
2535 [label="return '+='; 154182"];
2536 [label="FullWidth = this.Text.Length; 154183"];
2537 [label="FullWidth 154184"];
2538 [label="return '+='; 154185"];
2539 [label="FullWidth = this.Text.Length; 154186"];
2540 [label="FullWidth 154187"];
2541 [label="this.AdjustFlagsAndWidth(leading); 154188"];
2542 [label="return '+='; 154189"];
2543 [label="FullWidth = this.Text.Length; 154190"];
2544 [label="FullWidth 154191"];
2545 [label="this.AdjustFlagsAndWidth(trailing); 154192"];
2546 [label="return '+='; 154193"];
2547 [label="FullWidth = this.Text.Length; 154194"];
2548 [label="FullWidth 154195"];
2549 [label="this.AdjustFlagsAndWidth(trailing); 154196"];
2550 [label="return '-='; 154197"];
2551 [label="FullWidth = this.Text.Length; 154198"];
2552 [label="FullWidth 154199"];
2553 [label="return '-='; 154200"];
2554 [label="FullWidth = this.Text.Length; 154201"];
2555 [label="FullWidth 154202"];
2556 [label="this.AdjustFlagsAndWidth(leading); 154203"];
2557 [label="return '-='; 154204"];
2558 [label="FullWidth = this.Text.Length; 154205"];
2559 [label="FullWidth 154206"];
2560 [label="this.AdjustFlagsAndWidth(trailing); 154207"];
2561 [label="return '-='; 154208"];
2562 [label="FullWidth = this.Text.Length; 154209"];
2563 [label="FullWidth 154210"];
2564 [label="this.AdjustFlagsAndWidth(trailing); 154211"];
2565 [label="return '^='; 154212"];
2566 [label="FullWidth = this.Text.Length; 154213"];
2567 [label="FullWidth 154214"];
2568 [label="return '^='; 154215"];
2569 [label="FullWidth = this.Text.Length; 154216"];
2570 [label="FullWidth 154217"];
2571 [label="this.AdjustFlagsAndWidth(leading); 154218"];
2572 [label="return '^='; 154219"];
2573 [label="FullWidth = this.Text.Length; 154220"];
2574 [label="FullWidth 154221"];
2575 [label="this.AdjustFlagsAndWidth(trailing); 154222"];
2576 [label="return '^='; 154223"];
2577 [label="FullWidth = this.Text.Length; 154224"];
2578 [label="FullWidth 154225"];
2579 [label="this.AdjustFlagsAndWidth(trailing); 154226"];
2580 [label="return '%='; 154227"];
2581 [label="FullWidth = this.Text.Length; 154228"];
2582 [label="FullWidth 154229"];
2583 [label="return '%='; 154230"];
2584 [label="FullWidth = this.Text.Length; 154231"];
2585 [label="FullWidth 154232"];
2586 [label="this.AdjustFlagsAndWidth(leading); 154233"];
2587 [label="return '%='; 154234"];
2588 [label="FullWidth = this.Text.Length; 154235"];
2589 [label="FullWidth 154236"];
2590 [label="this.AdjustFlagsAndWidth(trailing); 154237"];
2591 [label="return '%='; 154238"];
2592 [label="FullWidth = this.Text.Length; 154239"];
2593 [label="FullWidth 154240"];
2594 [label="this.AdjustFlagsAndWidth(trailing); 154241"];
2595 [label="return '??='; 154242"];
2596 [label="FullWidth = this.Text.Length; 154243"];
2597 [label="FullWidth 154244"];
2598 [label="return '??='; 154245"];
2599 [label="FullWidth = this.Text.Length; 154246"];
2600 [label="FullWidth 154247"];
2601 [label="this.AdjustFlagsAndWidth(leading); 154248"];
2602 [label="return '??='; 154249"];
2603 [label="FullWidth = this.Text.Length; 154250"];
2604 [label="FullWidth 154251"];
2605 [label="this.AdjustFlagsAndWidth(trailing); 154252"];
2606 [label="return '??='; 154253"];
2607 [label="FullWidth = this.Text.Length; 154254"];
2608 [label="FullWidth 154255"];
2609 [label="this.AdjustFlagsAndWidth(trailing); 154256"];
2610 [label="return 'bool'; 154257"];
2611 [label="FullWidth = this.Text.Length; 154258"];
2612 [label="FullWidth 154259"];
2613 [label="return 'bool'; 154260"];
2614 [label="FullWidth = this.Text.Length; 154261"];
2615 [label="FullWidth 154262"];
2616 [label="this.AdjustFlagsAndWidth(leading); 154263"];
2617 [label="return 'bool'; 154264"];
2618 [label="FullWidth = this.Text.Length; 154265"];
2619 [label="FullWidth 154266"];
2620 [label="this.AdjustFlagsAndWidth(trailing); 154267"];
2621 [label="return 'bool'; 154268"];
2622 [label="FullWidth = this.Text.Length; 154269"];
2623 [label="FullWidth 154270"];
2624 [label="this.AdjustFlagsAndWidth(trailing); 154271"];
2625 [label="return 'byte'; 154272"];
2626 [label="FullWidth = this.Text.Length; 154273"];
2627 [label="FullWidth 154274"];
2628 [label="return 'byte'; 154275"];
2629 [label="FullWidth = this.Text.Length; 154276"];
2630 [label="FullWidth 154277"];
2631 [label="this.AdjustFlagsAndWidth(leading); 154278"];
2632 [label="return 'byte'; 154279"];
2633 [label="FullWidth = this.Text.Length; 154280"];
2634 [label="FullWidth 154281"];
2635 [label="this.AdjustFlagsAndWidth(trailing); 154282"];
2636 [label="return 'byte'; 154283"];
2637 [label="FullWidth = this.Text.Length; 154284"];
2638 [label="FullWidth 154285"];
2639 [label="this.AdjustFlagsAndWidth(trailing); 154286"];
2640 [label="return 'sbyte'; 154287"];
2641 [label="FullWidth = this.Text.Length; 154288"];
2642 [label="FullWidth 154289"];
2643 [label="return 'sbyte'; 154290"];
2644 [label="FullWidth = this.Text.Length; 154291"];
2645 [label="FullWidth 154292"];
2646 [label="this.AdjustFlagsAndWidth(leading); 154293"];
2647 [label="return 'sbyte'; 154294"];
2648 [label="FullWidth = this.Text.Length; 154295"];
2649 [label="FullWidth 154296"];
2650 [label="this.AdjustFlagsAndWidth(trailing); 154297"];
2651 [label="return 'sbyte'; 154298"];
2652 [label="FullWidth = this.Text.Length; 154299"];
2653 [label="FullWidth 154300"];
2654 [label="this.AdjustFlagsAndWidth(trailing); 154301"];
2655 [label="return 'short'; 154302"];
2656 [label="FullWidth = this.Text.Length; 154303"];
2657 [label="FullWidth 154304"];
2658 [label="return 'short'; 154305"];
2659 [label="FullWidth = this.Text.Length; 154306"];
2660 [label="FullWidth 154307"];
2661 [label="this.AdjustFlagsAndWidth(leading); 154308"];
2662 [label="return 'short'; 154309"];
2663 [label="FullWidth = this.Text.Length; 154310"];
2664 [label="FullWidth 154311"];
2665 [label="this.AdjustFlagsAndWidth(trailing); 154312"];
2666 [label="return 'short'; 154313"];
2667 [label="FullWidth = this.Text.Length; 154314"];
2668 [label="FullWidth 154315"];
2669 [label="this.AdjustFlagsAndWidth(trailing); 154316"];
2670 [label="return 'ushort'; 154317"];
2671 [label="FullWidth = this.Text.Length; 154318"];
2672 [label="FullWidth 154319"];
2673 [label="return 'ushort'; 154320"];
2674 [label="FullWidth = this.Text.Length; 154321"];
2675 [label="FullWidth 154322"];
2676 [label="this.AdjustFlagsAndWidth(leading); 154323"];
2677 [label="return 'ushort'; 154324"];
2678 [label="FullWidth = this.Text.Length; 154325"];
2679 [label="FullWidth 154326"];
2680 [label="this.AdjustFlagsAndWidth(trailing); 154327"];
2681 [label="return 'ushort'; 154328"];
2682 [label="FullWidth = this.Text.Length; 154329"];
2683 [label="FullWidth 154330"];
2684 [label="this.AdjustFlagsAndWidth(trailing); 154331"];
2685 [label="return 'int'; 154332"];
2686 [label="FullWidth = this.Text.Length; 154333"];
2687 [label="FullWidth 154334"];
2688 [label="return 'int'; 154335"];
2689 [label="FullWidth = this.Text.Length; 154336"];
2690 [label="FullWidth 154337"];
2691 [label="this.AdjustFlagsAndWidth(leading); 154338"];
2692 [label="return 'int'; 154339"];
2693 [label="FullWidth = this.Text.Length; 154340"];
2694 [label="FullWidth 154341"];
2695 [label="this.AdjustFlagsAndWidth(trailing); 154342"];
2696 [label="return 'int'; 154343"];
2697 [label="FullWidth = this.Text.Length; 154344"];
2698 [label="FullWidth 154345"];
2699 [label="this.AdjustFlagsAndWidth(trailing); 154346"];
2700 [label="return 'uint'; 154347"];
2701 [label="FullWidth = this.Text.Length; 154348"];
2702 [label="FullWidth 154349"];
2703 [label="return 'uint'; 154350"];
2704 [label="FullWidth = this.Text.Length; 154351"];
2705 [label="FullWidth 154352"];
2706 [label="this.AdjustFlagsAndWidth(leading); 154353"];
2707 [label="return 'uint'; 154354"];
2708 [label="FullWidth = this.Text.Length; 154355"];
2709 [label="FullWidth 154356"];
2710 [label="this.AdjustFlagsAndWidth(trailing); 154357"];
2711 [label="return 'uint'; 154358"];
2712 [label="FullWidth = this.Text.Length; 154359"];
2713 [label="FullWidth 154360"];
2714 [label="this.AdjustFlagsAndWidth(trailing); 154361"];
2715 [label="return 'long'; 154362"];
2716 [label="FullWidth = this.Text.Length; 154363"];
2717 [label="FullWidth 154364"];
2718 [label="return 'long'; 154365"];
2719 [label="FullWidth = this.Text.Length; 154366"];
2720 [label="FullWidth 154367"];
2721 [label="this.AdjustFlagsAndWidth(leading); 154368"];
2722 [label="return 'long'; 154369"];
2723 [label="FullWidth = this.Text.Length; 154370"];
2724 [label="FullWidth 154371"];
2725 [label="this.AdjustFlagsAndWidth(trailing); 154372"];
2726 [label="return 'long'; 154373"];
2727 [label="FullWidth = this.Text.Length; 154374"];
2728 [label="FullWidth 154375"];
2729 [label="this.AdjustFlagsAndWidth(trailing); 154376"];
2730 [label="return 'ulong'; 154377"];
2731 [label="FullWidth = this.Text.Length; 154378"];
2732 [label="FullWidth 154379"];
2733 [label="return 'ulong'; 154380"];
2734 [label="FullWidth = this.Text.Length; 154381"];
2735 [label="FullWidth 154382"];
2736 [label="this.AdjustFlagsAndWidth(leading); 154383"];
2737 [label="return 'ulong'; 154384"];
2738 [label="FullWidth = this.Text.Length; 154385"];
2739 [label="FullWidth 154386"];
2740 [label="this.AdjustFlagsAndWidth(trailing); 154387"];
2741 [label="return 'ulong'; 154388"];
2742 [label="FullWidth = this.Text.Length; 154389"];
2743 [label="FullWidth 154390"];
2744 [label="this.AdjustFlagsAndWidth(trailing); 154391"];
2745 [label="return 'double'; 154392"];
2746 [label="FullWidth = this.Text.Length; 154393"];
2747 [label="FullWidth 154394"];
2748 [label="return 'double'; 154395"];
2749 [label="FullWidth = this.Text.Length; 154396"];
2750 [label="FullWidth 154397"];
2751 [label="this.AdjustFlagsAndWidth(leading); 154398"];
2752 [label="return 'double'; 154399"];
2753 [label="FullWidth = this.Text.Length; 154400"];
2754 [label="FullWidth 154401"];
2755 [label="this.AdjustFlagsAndWidth(trailing); 154402"];
2756 [label="return 'double'; 154403"];
2757 [label="FullWidth = this.Text.Length; 154404"];
2758 [label="FullWidth 154405"];
2759 [label="this.AdjustFlagsAndWidth(trailing); 154406"];
2760 [label="return 'float'; 154407"];
2761 [label="FullWidth = this.Text.Length; 154408"];
2762 [label="FullWidth 154409"];
2763 [label="return 'float'; 154410"];
2764 [label="FullWidth = this.Text.Length; 154411"];
2765 [label="FullWidth 154412"];
2766 [label="this.AdjustFlagsAndWidth(leading); 154413"];
2767 [label="return 'float'; 154414"];
2768 [label="FullWidth = this.Text.Length; 154415"];
2769 [label="FullWidth 154416"];
2770 [label="this.AdjustFlagsAndWidth(trailing); 154417"];
2771 [label="return 'float'; 154418"];
2772 [label="FullWidth = this.Text.Length; 154419"];
2773 [label="FullWidth 154420"];
2774 [label="this.AdjustFlagsAndWidth(trailing); 154421"];
2775 [label="return 'decimal'; 154422"];
2776 [label="FullWidth = this.Text.Length; 154423"];
2777 [label="FullWidth 154424"];
2778 [label="return 'decimal'; 154425"];
2779 [label="FullWidth = this.Text.Length; 154426"];
2780 [label="FullWidth 154427"];
2781 [label="this.AdjustFlagsAndWidth(leading); 154428"];
2782 [label="return 'decimal'; 154429"];
2783 [label="FullWidth = this.Text.Length; 154430"];
2784 [label="FullWidth 154431"];
2785 [label="this.AdjustFlagsAndWidth(trailing); 154432"];
2786 [label="return 'decimal'; 154433"];
2787 [label="FullWidth = this.Text.Length; 154434"];
2788 [label="FullWidth 154435"];
2789 [label="this.AdjustFlagsAndWidth(trailing); 154436"];
2790 [label="return 'string'; 154437"];
2791 [label="FullWidth = this.Text.Length; 154438"];
2792 [label="FullWidth 154439"];
2793 [label="return 'string'; 154440"];
2794 [label="FullWidth = this.Text.Length; 154441"];
2795 [label="FullWidth 154442"];
2796 [label="this.AdjustFlagsAndWidth(leading); 154443"];
2797 [label="return 'string'; 154444"];
2798 [label="FullWidth = this.Text.Length; 154445"];
2799 [label="FullWidth 154446"];
2800 [label="this.AdjustFlagsAndWidth(trailing); 154447"];
2801 [label="return 'string'; 154448"];
2802 [label="FullWidth = this.Text.Length; 154449"];
2803 [label="FullWidth 154450"];
2804 [label="this.AdjustFlagsAndWidth(trailing); 154451"];
2805 [label="return 'char'; 154452"];
2806 [label="FullWidth = this.Text.Length; 154453"];
2807 [label="FullWidth 154454"];
2808 [label="return 'char'; 154455"];
2809 [label="FullWidth = this.Text.Length; 154456"];
2810 [label="FullWidth 154457"];
2811 [label="this.AdjustFlagsAndWidth(leading); 154458"];
2812 [label="return 'char'; 154459"];
2813 [label="FullWidth = this.Text.Length; 154460"];
2814 [label="FullWidth 154461"];
2815 [label="this.AdjustFlagsAndWidth(trailing); 154462"];
2816 [label="return 'char'; 154463"];
2817 [label="FullWidth = this.Text.Length; 154464"];
2818 [label="FullWidth 154465"];
2819 [label="this.AdjustFlagsAndWidth(trailing); 154466"];
2820 [label="return 'void'; 154467"];
2821 [label="FullWidth = this.Text.Length; 154468"];
2822 [label="FullWidth 154469"];
2823 [label="return 'void'; 154470"];
2824 [label="FullWidth = this.Text.Length; 154471"];
2825 [label="FullWidth 154472"];
2826 [label="this.AdjustFlagsAndWidth(leading); 154473"];
2827 [label="return 'void'; 154474"];
2828 [label="FullWidth = this.Text.Length; 154475"];
2829 [label="FullWidth 154476"];
2830 [label="this.AdjustFlagsAndWidth(trailing); 154477"];
2831 [label="return 'void'; 154478"];
2832 [label="FullWidth = this.Text.Length; 154479"];
2833 [label="FullWidth 154480"];
2834 [label="this.AdjustFlagsAndWidth(trailing); 154481"];
2835 [label="return 'object'; 154482"];
2836 [label="FullWidth = this.Text.Length; 154483"];
2837 [label="FullWidth 154484"];
2838 [label="return 'object'; 154485"];
2839 [label="FullWidth = this.Text.Length; 154486"];
2840 [label="FullWidth 154487"];
2841 [label="this.AdjustFlagsAndWidth(leading); 154488"];
2842 [label="return 'object'; 154489"];
2843 [label="FullWidth = this.Text.Length; 154490"];
2844 [label="FullWidth 154491"];
2845 [label="this.AdjustFlagsAndWidth(trailing); 154492"];
2846 [label="return 'object'; 154493"];
2847 [label="FullWidth = this.Text.Length; 154494"];
2848 [label="FullWidth 154495"];
2849 [label="this.AdjustFlagsAndWidth(trailing); 154496"];
2850 [label="return 'typeof'; 154497"];
2851 [label="FullWidth = this.Text.Length; 154498"];
2852 [label="FullWidth 154499"];
2853 [label="return 'typeof'; 154500"];
2854 [label="FullWidth = this.Text.Length; 154501"];
2855 [label="FullWidth 154502"];
2856 [label="this.AdjustFlagsAndWidth(leading); 154503"];
2857 [label="return 'typeof'; 154504"];
2858 [label="FullWidth = this.Text.Length; 154505"];
2859 [label="FullWidth 154506"];
2860 [label="this.AdjustFlagsAndWidth(trailing); 154507"];
2861 [label="return 'typeof'; 154508"];
2862 [label="FullWidth = this.Text.Length; 154509"];
2863 [label="FullWidth 154510"];
2864 [label="this.AdjustFlagsAndWidth(trailing); 154511"];
2865 [label="return 'sizeof'; 154512"];
2866 [label="FullWidth = this.Text.Length; 154513"];
2867 [label="FullWidth 154514"];
2868 [label="return 'sizeof'; 154515"];
2869 [label="FullWidth = this.Text.Length; 154516"];
2870 [label="FullWidth 154517"];
2871 [label="this.AdjustFlagsAndWidth(leading); 154518"];
2872 [label="return 'sizeof'; 154519"];
2873 [label="FullWidth = this.Text.Length; 154520"];
2874 [label="FullWidth 154521"];
2875 [label="this.AdjustFlagsAndWidth(trailing); 154522"];
2876 [label="return 'sizeof'; 154523"];
2877 [label="FullWidth = this.Text.Length; 154524"];
2878 [label="FullWidth 154525"];
2879 [label="this.AdjustFlagsAndWidth(trailing); 154526"];
2880 [label="return 'null'; 154527"];
2881 [label="FullWidth = this.Text.Length; 154528"];
2882 [label="FullWidth 154529"];
2883 [label="return 'null'; 154530"];
2884 [label="FullWidth = this.Text.Length; 154531"];
2885 [label="FullWidth 154532"];
2886 [label="this.AdjustFlagsAndWidth(leading); 154533"];
2887 [label="return 'null'; 154534"];
2888 [label="FullWidth = this.Text.Length; 154535"];
2889 [label="FullWidth 154536"];
2890 [label="this.AdjustFlagsAndWidth(trailing); 154537"];
2891 [label="return 'null'; 154538"];
2892 [label="FullWidth = this.Text.Length; 154539"];
2893 [label="FullWidth 154540"];
2894 [label="this.AdjustFlagsAndWidth(trailing); 154541"];
2895 [label="return 'true'; 154542"];
2896 [label="FullWidth = this.Text.Length; 154543"];
2897 [label="FullWidth 154544"];
2898 [label="return 'true'; 154545"];
2899 [label="FullWidth = this.Text.Length; 154546"];
2900 [label="FullWidth 154547"];
2901 [label="this.AdjustFlagsAndWidth(leading); 154548"];
2902 [label="return 'true'; 154549"];
2903 [label="FullWidth = this.Text.Length; 154550"];
2904 [label="FullWidth 154551"];
2905 [label="this.AdjustFlagsAndWidth(trailing); 154552"];
2906 [label="return 'true'; 154553"];
2907 [label="FullWidth = this.Text.Length; 154554"];
2908 [label="FullWidth 154555"];
2909 [label="this.AdjustFlagsAndWidth(trailing); 154556"];
2910 [label="return 'false'; 154557"];
2911 [label="FullWidth = this.Text.Length; 154558"];
2912 [label="FullWidth 154559"];
2913 [label="return 'false'; 154560"];
2914 [label="FullWidth = this.Text.Length; 154561"];
2915 [label="FullWidth 154562"];
2916 [label="this.AdjustFlagsAndWidth(leading); 154563"];
2917 [label="return 'false'; 154564"];
2918 [label="FullWidth = this.Text.Length; 154565"];
2919 [label="FullWidth 154566"];
2920 [label="this.AdjustFlagsAndWidth(trailing); 154567"];
2921 [label="return 'false'; 154568"];
2922 [label="FullWidth = this.Text.Length; 154569"];
2923 [label="FullWidth 154570"];
2924 [label="this.AdjustFlagsAndWidth(trailing); 154571"];
2925 [label="return 'if'; 154572"];
2926 [label="FullWidth = this.Text.Length; 154573"];
2927 [label="FullWidth 154574"];
2928 [label="return 'if'; 154575"];
2929 [label="FullWidth = this.Text.Length; 154576"];
2930 [label="FullWidth 154577"];
2931 [label="this.AdjustFlagsAndWidth(leading); 154578"];
2932 [label="return 'if'; 154579"];
2933 [label="FullWidth = this.Text.Length; 154580"];
2934 [label="FullWidth 154581"];
2935 [label="this.AdjustFlagsAndWidth(trailing); 154582"];
2936 [label="return 'if'; 154583"];
2937 [label="FullWidth = this.Text.Length; 154584"];
2938 [label="FullWidth 154585"];
2939 [label="this.AdjustFlagsAndWidth(trailing); 154586"];
2940 [label="return 'else'; 154587"];
2941 [label="FullWidth = this.Text.Length; 154588"];
2942 [label="FullWidth 154589"];
2943 [label="return 'else'; 154590"];
2944 [label="FullWidth = this.Text.Length; 154591"];
2945 [label="FullWidth 154592"];
2946 [label="this.AdjustFlagsAndWidth(leading); 154593"];
2947 [label="return 'else'; 154594"];
2948 [label="FullWidth = this.Text.Length; 154595"];
2949 [label="FullWidth 154596"];
2950 [label="this.AdjustFlagsAndWidth(trailing); 154597"];
2951 [label="return 'else'; 154598"];
2952 [label="FullWidth = this.Text.Length; 154599"];
2953 [label="FullWidth 154600"];
2954 [label="this.AdjustFlagsAndWidth(trailing); 154601"];
2955 [label="return 'while'; 154602"];
2956 [label="FullWidth = this.Text.Length; 154603"];
2957 [label="FullWidth 154604"];
2958 [label="return 'while'; 154605"];
2959 [label="FullWidth = this.Text.Length; 154606"];
2960 [label="FullWidth 154607"];
2961 [label="this.AdjustFlagsAndWidth(leading); 154608"];
2962 [label="return 'while'; 154609"];
2963 [label="FullWidth = this.Text.Length; 154610"];
2964 [label="FullWidth 154611"];
2965 [label="this.AdjustFlagsAndWidth(trailing); 154612"];
2966 [label="return 'while'; 154613"];
2967 [label="FullWidth = this.Text.Length; 154614"];
2968 [label="FullWidth 154615"];
2969 [label="this.AdjustFlagsAndWidth(trailing); 154616"];
2970 [label="return 'for'; 154617"];
2971 [label="FullWidth = this.Text.Length; 154618"];
2972 [label="FullWidth 154619"];
2973 [label="return 'for'; 154620"];
2974 [label="FullWidth = this.Text.Length; 154621"];
2975 [label="FullWidth 154622"];
2976 [label="this.AdjustFlagsAndWidth(leading); 154623"];
2977 [label="return 'for'; 154624"];
2978 [label="FullWidth = this.Text.Length; 154625"];
2979 [label="FullWidth 154626"];
2980 [label="this.AdjustFlagsAndWidth(trailing); 154627"];
2981 [label="return 'for'; 154628"];
2982 [label="FullWidth = this.Text.Length; 154629"];
2983 [label="FullWidth 154630"];
2984 [label="this.AdjustFlagsAndWidth(trailing); 154631"];
2985 [label="return 'foreach'; 154632"];
2986 [label="FullWidth = this.Text.Length; 154633"];
2987 [label="FullWidth 154634"];
2988 [label="return 'foreach'; 154635"];
2989 [label="FullWidth = this.Text.Length; 154636"];
2990 [label="FullWidth 154637"];
2991 [label="this.AdjustFlagsAndWidth(leading); 154638"];
2992 [label="return 'foreach'; 154639"];
2993 [label="FullWidth = this.Text.Length; 154640"];
2994 [label="FullWidth 154641"];
2995 [label="this.AdjustFlagsAndWidth(trailing); 154642"];
2996 [label="return 'foreach'; 154643"];
2997 [label="FullWidth = this.Text.Length; 154644"];
2998 [label="FullWidth 154645"];
2999 [label="this.AdjustFlagsAndWidth(trailing); 154646"];
3000 [label="return 'do'; 154647"];
3001 [label="FullWidth = this.Text.Length; 154648"];
3002 [label="FullWidth 154649"];
3003 [label="return 'do'; 154650"];
3004 [label="FullWidth = this.Text.Length; 154651"];
3005 [label="FullWidth 154652"];
3006 [label="this.AdjustFlagsAndWidth(leading); 154653"];
3007 [label="return 'do'; 154654"];
3008 [label="FullWidth = this.Text.Length; 154655"];
3009 [label="FullWidth 154656"];
3010 [label="this.AdjustFlagsAndWidth(trailing); 154657"];
3011 [label="return 'do'; 154658"];
3012 [label="FullWidth = this.Text.Length; 154659"];
3013 [label="FullWidth 154660"];
3014 [label="this.AdjustFlagsAndWidth(trailing); 154661"];
3015 [label="return 'switch'; 154662"];
3016 [label="FullWidth = this.Text.Length; 154663"];
3017 [label="FullWidth 154664"];
3018 [label="return 'switch'; 154665"];
3019 [label="FullWidth = this.Text.Length; 154666"];
3020 [label="FullWidth 154667"];
3021 [label="this.AdjustFlagsAndWidth(leading); 154668"];
3022 [label="return 'switch'; 154669"];
3023 [label="FullWidth = this.Text.Length; 154670"];
3024 [label="FullWidth 154671"];
3025 [label="this.AdjustFlagsAndWidth(trailing); 154672"];
3026 [label="return 'switch'; 154673"];
3027 [label="FullWidth = this.Text.Length; 154674"];
3028 [label="FullWidth 154675"];
3029 [label="this.AdjustFlagsAndWidth(trailing); 154676"];
3030 [label="return 'case'; 154677"];
3031 [label="FullWidth = this.Text.Length; 154678"];
3032 [label="FullWidth 154679"];
3033 [label="return 'case'; 154680"];
3034 [label="FullWidth = this.Text.Length; 154681"];
3035 [label="FullWidth 154682"];
3036 [label="this.AdjustFlagsAndWidth(leading); 154683"];
3037 [label="return 'case'; 154684"];
3038 [label="FullWidth = this.Text.Length; 154685"];
3039 [label="FullWidth 154686"];
3040 [label="this.AdjustFlagsAndWidth(trailing); 154687"];
3041 [label="return 'case'; 154688"];
3042 [label="FullWidth = this.Text.Length; 154689"];
3043 [label="FullWidth 154690"];
3044 [label="this.AdjustFlagsAndWidth(trailing); 154691"];
3045 [label="return 'default'; 154692"];
3046 [label="FullWidth = this.Text.Length; 154693"];
3047 [label="FullWidth 154694"];
3048 [label="return 'default'; 154695"];
3049 [label="FullWidth = this.Text.Length; 154696"];
3050 [label="FullWidth 154697"];
3051 [label="this.AdjustFlagsAndWidth(leading); 154698"];
3052 [label="return 'default'; 154699"];
3053 [label="FullWidth = this.Text.Length; 154700"];
3054 [label="FullWidth 154701"];
3055 [label="this.AdjustFlagsAndWidth(trailing); 154702"];
3056 [label="return 'default'; 154703"];
3057 [label="FullWidth = this.Text.Length; 154704"];
3058 [label="FullWidth 154705"];
3059 [label="this.AdjustFlagsAndWidth(trailing); 154706"];
3060 [label="return 'try'; 154707"];
3061 [label="FullWidth = this.Text.Length; 154708"];
3062 [label="FullWidth 154709"];
3063 [label="return 'try'; 154710"];
3064 [label="FullWidth = this.Text.Length; 154711"];
3065 [label="FullWidth 154712"];
3066 [label="this.AdjustFlagsAndWidth(leading); 154713"];
3067 [label="return 'try'; 154714"];
3068 [label="FullWidth = this.Text.Length; 154715"];
3069 [label="FullWidth 154716"];
3070 [label="this.AdjustFlagsAndWidth(trailing); 154717"];
3071 [label="return 'try'; 154718"];
3072 [label="FullWidth = this.Text.Length; 154719"];
3073 [label="FullWidth 154720"];
3074 [label="this.AdjustFlagsAndWidth(trailing); 154721"];
3075 [label="return 'catch'; 154722"];
3076 [label="FullWidth = this.Text.Length; 154723"];
3077 [label="FullWidth 154724"];
3078 [label="return 'catch'; 154725"];
3079 [label="FullWidth = this.Text.Length; 154726"];
3080 [label="FullWidth 154727"];
3081 [label="this.AdjustFlagsAndWidth(leading); 154728"];
3082 [label="return 'catch'; 154729"];
3083 [label="FullWidth = this.Text.Length; 154730"];
3084 [label="FullWidth 154731"];
3085 [label="this.AdjustFlagsAndWidth(trailing); 154732"];
3086 [label="return 'catch'; 154733"];
3087 [label="FullWidth = this.Text.Length; 154734"];
3088 [label="FullWidth 154735"];
3089 [label="this.AdjustFlagsAndWidth(trailing); 154736"];
3090 [label="return 'finally'; 154737"];
3091 [label="FullWidth = this.Text.Length; 154738"];
3092 [label="FullWidth 154739"];
3093 [label="return 'finally'; 154740"];
3094 [label="FullWidth = this.Text.Length; 154741"];
3095 [label="FullWidth 154742"];
3096 [label="this.AdjustFlagsAndWidth(leading); 154743"];
3097 [label="return 'finally'; 154744"];
3098 [label="FullWidth = this.Text.Length; 154745"];
3099 [label="FullWidth 154746"];
3100 [label="this.AdjustFlagsAndWidth(trailing); 154747"];
3101 [label="return 'finally'; 154748"];
3102 [label="FullWidth = this.Text.Length; 154749"];
3103 [label="FullWidth 154750"];
3104 [label="this.AdjustFlagsAndWidth(trailing); 154751"];
3105 [label="return 'lock'; 154752"];
3106 [label="FullWidth = this.Text.Length; 154753"];
3107 [label="FullWidth 154754"];
3108 [label="return 'lock'; 154755"];
3109 [label="FullWidth = this.Text.Length; 154756"];
3110 [label="FullWidth 154757"];
3111 [label="this.AdjustFlagsAndWidth(leading); 154758"];
3112 [label="return 'lock'; 154759"];
3113 [label="FullWidth = this.Text.Length; 154760"];
3114 [label="FullWidth 154761"];
3115 [label="this.AdjustFlagsAndWidth(trailing); 154762"];
3116 [label="return 'lock'; 154763"];
3117 [label="FullWidth = this.Text.Length; 154764"];
3118 [label="FullWidth 154765"];
3119 [label="this.AdjustFlagsAndWidth(trailing); 154766"];
3120 [label="return 'goto'; 154767"];
3121 [label="FullWidth = this.Text.Length; 154768"];
3122 [label="FullWidth 154769"];
3123 [label="return 'goto'; 154770"];
3124 [label="FullWidth = this.Text.Length; 154771"];
3125 [label="FullWidth 154772"];
3126 [label="this.AdjustFlagsAndWidth(leading); 154773"];
3127 [label="return 'goto'; 154774"];
3128 [label="FullWidth = this.Text.Length; 154775"];
3129 [label="FullWidth 154776"];
3130 [label="this.AdjustFlagsAndWidth(trailing); 154777"];
3131 [label="return 'goto'; 154778"];
3132 [label="FullWidth = this.Text.Length; 154779"];
3133 [label="FullWidth 154780"];
3134 [label="this.AdjustFlagsAndWidth(trailing); 154781"];
3135 [label="return 'break'; 154782"];
3136 [label="FullWidth = this.Text.Length; 154783"];
3137 [label="FullWidth 154784"];
3138 [label="return 'break'; 154785"];
3139 [label="FullWidth = this.Text.Length; 154786"];
3140 [label="FullWidth 154787"];
3141 [label="this.AdjustFlagsAndWidth(leading); 154788"];
3142 [label="return 'break'; 154789"];
3143 [label="FullWidth = this.Text.Length; 154790"];
3144 [label="FullWidth 154791"];
3145 [label="this.AdjustFlagsAndWidth(trailing); 154792"];
3146 [label="return 'break'; 154793"];
3147 [label="FullWidth = this.Text.Length; 154794"];
3148 [label="FullWidth 154795"];
3149 [label="this.AdjustFlagsAndWidth(trailing); 154796"];
3150 [label="return 'continue'; 154797"];
3151 [label="FullWidth = this.Text.Length; 154798"];
3152 [label="FullWidth 154799"];
3153 [label="return 'continue'; 154800"];
3154 [label="FullWidth = this.Text.Length; 154801"];
3155 [label="FullWidth 154802"];
3156 [label="this.AdjustFlagsAndWidth(leading); 154803"];
3157 [label="return 'continue'; 154804"];
3158 [label="FullWidth = this.Text.Length; 154805"];
3159 [label="FullWidth 154806"];
3160 [label="this.AdjustFlagsAndWidth(trailing); 154807"];
3161 [label="return 'continue'; 154808"];
3162 [label="FullWidth = this.Text.Length; 154809"];
3163 [label="FullWidth 154810"];
3164 [label="this.AdjustFlagsAndWidth(trailing); 154811"];
3165 [label="return 'return'; 154812"];
3166 [label="FullWidth = this.Text.Length; 154813"];
3167 [label="FullWidth 154814"];
3168 [label="return 'return'; 154815"];
3169 [label="FullWidth = this.Text.Length; 154816"];
3170 [label="FullWidth 154817"];
3171 [label="this.AdjustFlagsAndWidth(leading); 154818"];
3172 [label="return 'return'; 154819"];
3173 [label="FullWidth = this.Text.Length; 154820"];
3174 [label="FullWidth 154821"];
3175 [label="this.AdjustFlagsAndWidth(trailing); 154822"];
3176 [label="return 'return'; 154823"];
3177 [label="FullWidth = this.Text.Length; 154824"];
3178 [label="FullWidth 154825"];
3179 [label="this.AdjustFlagsAndWidth(trailing); 154826"];
3180 [label="return 'throw'; 154827"];
3181 [label="FullWidth = this.Text.Length; 154828"];
3182 [label="FullWidth 154829"];
3183 [label="return 'throw'; 154830"];
3184 [label="FullWidth = this.Text.Length; 154831"];
3185 [label="FullWidth 154832"];
3186 [label="this.AdjustFlagsAndWidth(leading); 154833"];
3187 [label="return 'throw'; 154834"];
3188 [label="FullWidth = this.Text.Length; 154835"];
3189 [label="FullWidth 154836"];
3190 [label="this.AdjustFlagsAndWidth(trailing); 154837"];
3191 [label="return 'throw'; 154838"];
3192 [label="FullWidth = this.Text.Length; 154839"];
3193 [label="FullWidth 154840"];
3194 [label="this.AdjustFlagsAndWidth(trailing); 154841"];
3195 [label="return 'public'; 154842"];
3196 [label="FullWidth = this.Text.Length; 154843"];
3197 [label="FullWidth 154844"];
3198 [label="return 'public'; 154845"];
3199 [label="FullWidth = this.Text.Length; 154846"];
3200 [label="FullWidth 154847"];
3201 [label="this.AdjustFlagsAndWidth(leading); 154848"];
3202 [label="return 'public'; 154849"];
3203 [label="FullWidth = this.Text.Length; 154850"];
3204 [label="FullWidth 154851"];
3205 [label="this.AdjustFlagsAndWidth(trailing); 154852"];
3206 [label="return 'public'; 154853"];
3207 [label="FullWidth = this.Text.Length; 154854"];
3208 [label="FullWidth 154855"];
3209 [label="this.AdjustFlagsAndWidth(trailing); 154856"];
3210 [label="return 'private'; 154857"];
3211 [label="FullWidth = this.Text.Length; 154858"];
3212 [label="FullWidth 154859"];
3213 [label="return 'private'; 154860"];
3214 [label="FullWidth = this.Text.Length; 154861"];
3215 [label="FullWidth 154862"];
3216 [label="this.AdjustFlagsAndWidth(leading); 154863"];
3217 [label="return 'private'; 154864"];
3218 [label="FullWidth = this.Text.Length; 154865"];
3219 [label="FullWidth 154866"];
3220 [label="this.AdjustFlagsAndWidth(trailing); 154867"];
3221 [label="return 'private'; 154868"];
3222 [label="FullWidth = this.Text.Length; 154869"];
3223 [label="FullWidth 154870"];
3224 [label="this.AdjustFlagsAndWidth(trailing); 154871"];
3225 [label="return 'internal'; 154872"];
3226 [label="FullWidth = this.Text.Length; 154873"];
3227 [label="FullWidth 154874"];
3228 [label="return 'internal'; 154875"];
3229 [label="FullWidth = this.Text.Length; 154876"];
3230 [label="FullWidth 154877"];
3231 [label="this.AdjustFlagsAndWidth(leading); 154878"];
3232 [label="return 'internal'; 154879"];
3233 [label="FullWidth = this.Text.Length; 154880"];
3234 [label="FullWidth 154881"];
3235 [label="this.AdjustFlagsAndWidth(trailing); 154882"];
3236 [label="return 'internal'; 154883"];
3237 [label="FullWidth = this.Text.Length; 154884"];
3238 [label="FullWidth 154885"];
3239 [label="this.AdjustFlagsAndWidth(trailing); 154886"];
3240 [label="return 'protected'; 154887"];
3241 [label="FullWidth = this.Text.Length; 154888"];
3242 [label="FullWidth 154889"];
3243 [label="return 'protected'; 154890"];
3244 [label="FullWidth = this.Text.Length; 154891"];
3245 [label="FullWidth 154892"];
3246 [label="this.AdjustFlagsAndWidth(leading); 154893"];
3247 [label="return 'protected'; 154894"];
3248 [label="FullWidth = this.Text.Length; 154895"];
3249 [label="FullWidth 154896"];
3250 [label="this.AdjustFlagsAndWidth(trailing); 154897"];
3251 [label="return 'protected'; 154898"];
3252 [label="FullWidth = this.Text.Length; 154899"];
3253 [label="FullWidth 154900"];
3254 [label="this.AdjustFlagsAndWidth(trailing); 154901"];
3255 [label="return 'static'; 154902"];
3256 [label="FullWidth = this.Text.Length; 154903"];
3257 [label="FullWidth 154904"];
3258 [label="return 'static'; 154905"];
3259 [label="FullWidth = this.Text.Length; 154906"];
3260 [label="FullWidth 154907"];
3261 [label="this.AdjustFlagsAndWidth(leading); 154908"];
3262 [label="return 'static'; 154909"];
3263 [label="FullWidth = this.Text.Length; 154910"];
3264 [label="FullWidth 154911"];
3265 [label="this.AdjustFlagsAndWidth(trailing); 154912"];
3266 [label="return 'static'; 154913"];
3267 [label="FullWidth = this.Text.Length; 154914"];
3268 [label="FullWidth 154915"];
3269 [label="this.AdjustFlagsAndWidth(trailing); 154916"];
3270 [label="return 'readonly'; 154917"];
3271 [label="FullWidth = this.Text.Length; 154918"];
3272 [label="FullWidth 154919"];
3273 [label="return 'readonly'; 154920"];
3274 [label="FullWidth = this.Text.Length; 154921"];
3275 [label="FullWidth 154922"];
3276 [label="this.AdjustFlagsAndWidth(leading); 154923"];
3277 [label="return 'readonly'; 154924"];
3278 [label="FullWidth = this.Text.Length; 154925"];
3279 [label="FullWidth 154926"];
3280 [label="this.AdjustFlagsAndWidth(trailing); 154927"];
3281 [label="return 'readonly'; 154928"];
3282 [label="FullWidth = this.Text.Length; 154929"];
3283 [label="FullWidth 154930"];
3284 [label="this.AdjustFlagsAndWidth(trailing); 154931"];
3285 [label="return 'sealed'; 154932"];
3286 [label="FullWidth = this.Text.Length; 154933"];
3287 [label="FullWidth 154934"];
3288 [label="return 'sealed'; 154935"];
3289 [label="FullWidth = this.Text.Length; 154936"];
3290 [label="FullWidth 154937"];
3291 [label="this.AdjustFlagsAndWidth(leading); 154938"];
3292 [label="return 'sealed'; 154939"];
3293 [label="FullWidth = this.Text.Length; 154940"];
3294 [label="FullWidth 154941"];
3295 [label="this.AdjustFlagsAndWidth(trailing); 154942"];
3296 [label="return 'sealed'; 154943"];
3297 [label="FullWidth = this.Text.Length; 154944"];
3298 [label="FullWidth 154945"];
3299 [label="this.AdjustFlagsAndWidth(trailing); 154946"];
3300 [label="return 'const'; 154947"];
3301 [label="FullWidth = this.Text.Length; 154948"];
3302 [label="FullWidth 154949"];
3303 [label="return 'const'; 154950"];
3304 [label="FullWidth = this.Text.Length; 154951"];
3305 [label="FullWidth 154952"];
3306 [label="this.AdjustFlagsAndWidth(leading); 154953"];
3307 [label="return 'const'; 154954"];
3308 [label="FullWidth = this.Text.Length; 154955"];
3309 [label="FullWidth 154956"];
3310 [label="this.AdjustFlagsAndWidth(trailing); 154957"];
3311 [label="return 'const'; 154958"];
3312 [label="FullWidth = this.Text.Length; 154959"];
3313 [label="FullWidth 154960"];
3314 [label="this.AdjustFlagsAndWidth(trailing); 154961"];
3315 [label="return 'fixed'; 154962"];
3316 [label="FullWidth = this.Text.Length; 154963"];
3317 [label="FullWidth 154964"];
3318 [label="return 'fixed'; 154965"];
3319 [label="FullWidth = this.Text.Length; 154966"];
3320 [label="FullWidth 154967"];
3321 [label="this.AdjustFlagsAndWidth(leading); 154968"];
3322 [label="return 'fixed'; 154969"];
3323 [label="FullWidth = this.Text.Length; 154970"];
3324 [label="FullWidth 154971"];
3325 [label="this.AdjustFlagsAndWidth(trailing); 154972"];
3326 [label="return 'fixed'; 154973"];
3327 [label="FullWidth = this.Text.Length; 154974"];
3328 [label="FullWidth 154975"];
3329 [label="this.AdjustFlagsAndWidth(trailing); 154976"];
3330 [label="return 'stackalloc'; 154977"];
3331 [label="FullWidth = this.Text.Length; 154978"];
3332 [label="FullWidth 154979"];
3333 [label="return 'stackalloc'; 154980"];
3334 [label="FullWidth = this.Text.Length; 154981"];
3335 [label="FullWidth 154982"];
3336 [label="this.AdjustFlagsAndWidth(leading); 154983"];
3337 [label="return 'stackalloc'; 154984"];
3338 [label="FullWidth = this.Text.Length; 154985"];
3339 [label="FullWidth 154986"];
3340 [label="this.AdjustFlagsAndWidth(trailing); 154987"];
3341 [label="return 'stackalloc'; 154988"];
3342 [label="FullWidth = this.Text.Length; 154989"];
3343 [label="FullWidth 154990"];
3344 [label="this.AdjustFlagsAndWidth(trailing); 154991"];
3345 [label="return 'volatile'; 154992"];
3346 [label="FullWidth = this.Text.Length; 154993"];
3347 [label="FullWidth 154994"];
3348 [label="return 'volatile'; 154995"];
3349 [label="FullWidth = this.Text.Length; 154996"];
3350 [label="FullWidth 154997"];
3351 [label="this.AdjustFlagsAndWidth(leading); 154998"];
3352 [label="return 'volatile'; 154999"];
3353 [label="FullWidth = this.Text.Length; 155000"];
3354 [label="FullWidth 155001"];
3355 [label="this.AdjustFlagsAndWidth(trailing); 155002"];
3356 [label="return 'volatile'; 155003"];
3357 [label="FullWidth = this.Text.Length; 155004"];
3358 [label="FullWidth 155005"];
3359 [label="this.AdjustFlagsAndWidth(trailing); 155006"];
3360 [label="return 'new'; 155007"];
3361 [label="FullWidth = this.Text.Length; 155008"];
3362 [label="FullWidth 155009"];
3363 [label="return 'new'; 155010"];
3364 [label="FullWidth = this.Text.Length; 155011"];
3365 [label="FullWidth 155012"];
3366 [label="this.AdjustFlagsAndWidth(leading); 155013"];
3367 [label="return 'new'; 155014"];
3368 [label="FullWidth = this.Text.Length; 155015"];
3369 [label="FullWidth 155016"];
3370 [label="this.AdjustFlagsAndWidth(trailing); 155017"];
3371 [label="return 'new'; 155018"];
3372 [label="FullWidth = this.Text.Length; 155019"];
3373 [label="FullWidth 155020"];
3374 [label="this.AdjustFlagsAndWidth(trailing); 155021"];
3375 [label="return 'override'; 155022"];
3376 [label="FullWidth = this.Text.Length; 155023"];
3377 [label="FullWidth 155024"];
3378 [label="return 'override'; 155025"];
3379 [label="FullWidth = this.Text.Length; 155026"];
3380 [label="FullWidth 155027"];
3381 [label="this.AdjustFlagsAndWidth(leading); 155028"];
3382 [label="return 'override'; 155029"];
3383 [label="FullWidth = this.Text.Length; 155030"];
3384 [label="FullWidth 155031"];
3385 [label="this.AdjustFlagsAndWidth(trailing); 155032"];
3386 [label="return 'override'; 155033"];
3387 [label="FullWidth = this.Text.Length; 155034"];
3388 [label="FullWidth 155035"];
3389 [label="this.AdjustFlagsAndWidth(trailing); 155036"];
3390 [label="return 'abstract'; 155037"];
3391 [label="FullWidth = this.Text.Length; 155038"];
3392 [label="FullWidth 155039"];
3393 [label="return 'abstract'; 155040"];
3394 [label="FullWidth = this.Text.Length; 155041"];
3395 [label="FullWidth 155042"];
3396 [label="this.AdjustFlagsAndWidth(leading); 155043"];
3397 [label="return 'abstract'; 155044"];
3398 [label="FullWidth = this.Text.Length; 155045"];
3399 [label="FullWidth 155046"];
3400 [label="this.AdjustFlagsAndWidth(trailing); 155047"];
3401 [label="return 'abstract'; 155048"];
3402 [label="FullWidth = this.Text.Length; 155049"];
3403 [label="FullWidth 155050"];
3404 [label="this.AdjustFlagsAndWidth(trailing); 155051"];
3405 [label="return 'virtual'; 155052"];
3406 [label="FullWidth = this.Text.Length; 155053"];
3407 [label="FullWidth 155054"];
3408 [label="return 'virtual'; 155055"];
3409 [label="FullWidth = this.Text.Length; 155056"];
3410 [label="FullWidth 155057"];
3411 [label="this.AdjustFlagsAndWidth(leading); 155058"];
3412 [label="return 'virtual'; 155059"];
3413 [label="FullWidth = this.Text.Length; 155060"];
3414 [label="FullWidth 155061"];
3415 [label="this.AdjustFlagsAndWidth(trailing); 155062"];
3416 [label="return 'virtual'; 155063"];
3417 [label="FullWidth = this.Text.Length; 155064"];
3418 [label="FullWidth 155065"];
3419 [label="this.AdjustFlagsAndWidth(trailing); 155066"];
3420 [label="return 'event'; 155067"];
3421 [label="FullWidth = this.Text.Length; 155068"];
3422 [label="FullWidth 155069"];
3423 [label="return 'event'; 155070"];
3424 [label="FullWidth = this.Text.Length; 155071"];
3425 [label="FullWidth 155072"];
3426 [label="this.AdjustFlagsAndWidth(leading); 155073"];
3427 [label="return 'event'; 155074"];
3428 [label="FullWidth = this.Text.Length; 155075"];
3429 [label="FullWidth 155076"];
3430 [label="this.AdjustFlagsAndWidth(trailing); 155077"];
3431 [label="return 'event'; 155078"];
3432 [label="FullWidth = this.Text.Length; 155079"];
3433 [label="FullWidth 155080"];
3434 [label="this.AdjustFlagsAndWidth(trailing); 155081"];
3435 [label="return 'extern'; 155082"];
3436 [label="FullWidth = this.Text.Length; 155083"];
3437 [label="FullWidth 155084"];
3438 [label="return 'extern'; 155085"];
3439 [label="FullWidth = this.Text.Length; 155086"];
3440 [label="FullWidth 155087"];
3441 [label="this.AdjustFlagsAndWidth(leading); 155088"];
3442 [label="return 'extern'; 155089"];
3443 [label="FullWidth = this.Text.Length; 155090"];
3444 [label="FullWidth 155091"];
3445 [label="this.AdjustFlagsAndWidth(trailing); 155092"];
3446 [label="return 'extern'; 155093"];
3447 [label="FullWidth = this.Text.Length; 155094"];
3448 [label="FullWidth 155095"];
3449 [label="this.AdjustFlagsAndWidth(trailing); 155096"];
3450 [label="return 'ref'; 155097"];
3451 [label="FullWidth = this.Text.Length; 155098"];
3452 [label="FullWidth 155099"];
3453 [label="return 'ref'; 155100"];
3454 [label="FullWidth = this.Text.Length; 155101"];
3455 [label="FullWidth 155102"];
3456 [label="this.AdjustFlagsAndWidth(leading); 155103"];
3457 [label="return 'ref'; 155104"];
3458 [label="FullWidth = this.Text.Length; 155105"];
3459 [label="FullWidth 155106"];
3460 [label="this.AdjustFlagsAndWidth(trailing); 155107"];
3461 [label="return 'ref'; 155108"];
3462 [label="FullWidth = this.Text.Length; 155109"];
3463 [label="FullWidth 155110"];
3464 [label="this.AdjustFlagsAndWidth(trailing); 155111"];
3465 [label="return 'out'; 155112"];
3466 [label="FullWidth = this.Text.Length; 155113"];
3467 [label="FullWidth 155114"];
3468 [label="return 'out'; 155115"];
3469 [label="FullWidth = this.Text.Length; 155116"];
3470 [label="FullWidth 155117"];
3471 [label="this.AdjustFlagsAndWidth(leading); 155118"];
3472 [label="return 'out'; 155119"];
3473 [label="FullWidth = this.Text.Length; 155120"];
3474 [label="FullWidth 155121"];
3475 [label="this.AdjustFlagsAndWidth(trailing); 155122"];
3476 [label="return 'out'; 155123"];
3477 [label="FullWidth = this.Text.Length; 155124"];
3478 [label="FullWidth 155125"];
3479 [label="this.AdjustFlagsAndWidth(trailing); 155126"];
3480 [label="return 'in'; 155127"];
3481 [label="FullWidth = this.Text.Length; 155128"];
3482 [label="FullWidth 155129"];
3483 [label="return 'in'; 155130"];
3484 [label="FullWidth = this.Text.Length; 155131"];
3485 [label="FullWidth 155132"];
3486 [label="this.AdjustFlagsAndWidth(leading); 155133"];
3487 [label="return 'in'; 155134"];
3488 [label="FullWidth = this.Text.Length; 155135"];
3489 [label="FullWidth 155136"];
3490 [label="this.AdjustFlagsAndWidth(trailing); 155137"];
3491 [label="return 'in'; 155138"];
3492 [label="FullWidth = this.Text.Length; 155139"];
3493 [label="FullWidth 155140"];
3494 [label="this.AdjustFlagsAndWidth(trailing); 155141"];
3495 [label="return 'is'; 155142"];
3496 [label="FullWidth = this.Text.Length; 155143"];
3497 [label="FullWidth 155144"];
3498 [label="return 'is'; 155145"];
3499 [label="FullWidth = this.Text.Length; 155146"];
3500 [label="FullWidth 155147"];
3501 [label="this.AdjustFlagsAndWidth(leading); 155148"];
3502 [label="return 'is'; 155149"];
3503 [label="FullWidth = this.Text.Length; 155150"];
3504 [label="FullWidth 155151"];
3505 [label="this.AdjustFlagsAndWidth(trailing); 155152"];
3506 [label="return 'is'; 155153"];
3507 [label="FullWidth = this.Text.Length; 155154"];
3508 [label="FullWidth 155155"];
3509 [label="this.AdjustFlagsAndWidth(trailing); 155156"];
3510 [label="return 'as'; 155157"];
3511 [label="FullWidth = this.Text.Length; 155158"];
3512 [label="FullWidth 155159"];
3513 [label="return 'as'; 155160"];
3514 [label="FullWidth = this.Text.Length; 155161"];
3515 [label="FullWidth 155162"];
3516 [label="this.AdjustFlagsAndWidth(leading); 155163"];
3517 [label="return 'as'; 155164"];
3518 [label="FullWidth = this.Text.Length; 155165"];
3519 [label="FullWidth 155166"];
3520 [label="this.AdjustFlagsAndWidth(trailing); 155167"];
3521 [label="return 'as'; 155168"];
3522 [label="FullWidth = this.Text.Length; 155169"];
3523 [label="FullWidth 155170"];
3524 [label="this.AdjustFlagsAndWidth(trailing); 155171"];
3525 [label="return 'params'; 155172"];
3526 [label="FullWidth = this.Text.Length; 155173"];
3527 [label="FullWidth 155174"];
3528 [label="return 'params'; 155175"];
3529 [label="FullWidth = this.Text.Length; 155176"];
3530 [label="FullWidth 155177"];
3531 [label="this.AdjustFlagsAndWidth(leading); 155178"];
3532 [label="return 'params'; 155179"];
3533 [label="FullWidth = this.Text.Length; 155180"];
3534 [label="FullWidth 155181"];
3535 [label="this.AdjustFlagsAndWidth(trailing); 155182"];
3536 [label="return 'params'; 155183"];
3537 [label="FullWidth = this.Text.Length; 155184"];
3538 [label="FullWidth 155185"];
3539 [label="this.AdjustFlagsAndWidth(trailing); 155186"];
3540 [label="return '__arglist'; 155187"];
3541 [label="FullWidth = this.Text.Length; 155188"];
3542 [label="FullWidth 155189"];
3543 [label="return '__arglist'; 155190"];
3544 [label="FullWidth = this.Text.Length; 155191"];
3545 [label="FullWidth 155192"];
3546 [label="this.AdjustFlagsAndWidth(leading); 155193"];
3547 [label="return '__arglist'; 155194"];
3548 [label="FullWidth = this.Text.Length; 155195"];
3549 [label="FullWidth 155196"];
3550 [label="this.AdjustFlagsAndWidth(trailing); 155197"];
3551 [label="return '__arglist'; 155198"];
3552 [label="FullWidth = this.Text.Length; 155199"];
3553 [label="FullWidth 155200"];
3554 [label="this.AdjustFlagsAndWidth(trailing); 155201"];
3555 [label="return '__makeref'; 155202"];
3556 [label="FullWidth = this.Text.Length; 155203"];
3557 [label="FullWidth 155204"];
3558 [label="return '__makeref'; 155205"];
3559 [label="FullWidth = this.Text.Length; 155206"];
3560 [label="FullWidth 155207"];
3561 [label="this.AdjustFlagsAndWidth(leading); 155208"];
3562 [label="return '__makeref'; 155209"];
3563 [label="FullWidth = this.Text.Length; 155210"];
3564 [label="FullWidth 155211"];
3565 [label="this.AdjustFlagsAndWidth(trailing); 155212"];
3566 [label="return '__makeref'; 155213"];
3567 [label="FullWidth = this.Text.Length; 155214"];
3568 [label="FullWidth 155215"];
3569 [label="this.AdjustFlagsAndWidth(trailing); 155216"];
3570 [label="return '__reftype'; 155217"];
3571 [label="FullWidth = this.Text.Length; 155218"];
3572 [label="FullWidth 155219"];
3573 [label="return '__reftype'; 155220"];
3574 [label="FullWidth = this.Text.Length; 155221"];
3575 [label="FullWidth 155222"];
3576 [label="this.AdjustFlagsAndWidth(leading); 155223"];
3577 [label="return '__reftype'; 155224"];
3578 [label="FullWidth = this.Text.Length; 155225"];
3579 [label="FullWidth 155226"];
3580 [label="this.AdjustFlagsAndWidth(trailing); 155227"];
3581 [label="return '__reftype'; 155228"];
3582 [label="FullWidth = this.Text.Length; 155229"];
3583 [label="FullWidth 155230"];
3584 [label="this.AdjustFlagsAndWidth(trailing); 155231"];
3585 [label="return '__refvalue'; 155232"];
3586 [label="FullWidth = this.Text.Length; 155233"];
3587 [label="FullWidth 155234"];
3588 [label="return '__refvalue'; 155235"];
3589 [label="FullWidth = this.Text.Length; 155236"];
3590 [label="FullWidth 155237"];
3591 [label="this.AdjustFlagsAndWidth(leading); 155238"];
3592 [label="return '__refvalue'; 155239"];
3593 [label="FullWidth = this.Text.Length; 155240"];
3594 [label="FullWidth 155241"];
3595 [label="this.AdjustFlagsAndWidth(trailing); 155242"];
3596 [label="return '__refvalue'; 155243"];
3597 [label="FullWidth = this.Text.Length; 155244"];
3598 [label="FullWidth 155245"];
3599 [label="this.AdjustFlagsAndWidth(trailing); 155246"];
3600 [label="return 'this'; 155247"];
3601 [label="FullWidth = this.Text.Length; 155248"];
3602 [label="FullWidth 155249"];
3603 [label="return 'this'; 155250"];
3604 [label="FullWidth = this.Text.Length; 155251"];
3605 [label="FullWidth 155252"];
3606 [label="this.AdjustFlagsAndWidth(leading); 155253"];
3607 [label="return 'this'; 155254"];
3608 [label="FullWidth = this.Text.Length; 155255"];
3609 [label="FullWidth 155256"];
3610 [label="this.AdjustFlagsAndWidth(trailing); 155257"];
3611 [label="return 'this'; 155258"];
3612 [label="FullWidth = this.Text.Length; 155259"];
3613 [label="FullWidth 155260"];
3614 [label="this.AdjustFlagsAndWidth(trailing); 155261"];
3615 [label="return 'base'; 155262"];
3616 [label="FullWidth = this.Text.Length; 155263"];
3617 [label="FullWidth 155264"];
3618 [label="return 'base'; 155265"];
3619 [label="FullWidth = this.Text.Length; 155266"];
3620 [label="FullWidth 155267"];
3621 [label="this.AdjustFlagsAndWidth(leading); 155268"];
3622 [label="return 'base'; 155269"];
3623 [label="FullWidth = this.Text.Length; 155270"];
3624 [label="FullWidth 155271"];
3625 [label="this.AdjustFlagsAndWidth(trailing); 155272"];
3626 [label="return 'base'; 155273"];
3627 [label="FullWidth = this.Text.Length; 155274"];
3628 [label="FullWidth 155275"];
3629 [label="this.AdjustFlagsAndWidth(trailing); 155276"];
3630 [label="return 'namespace'; 155277"];
3631 [label="FullWidth = this.Text.Length; 155278"];
3632 [label="FullWidth 155279"];
3633 [label="return 'namespace'; 155280"];
3634 [label="FullWidth = this.Text.Length; 155281"];
3635 [label="FullWidth 155282"];
3636 [label="this.AdjustFlagsAndWidth(leading); 155283"];
3637 [label="return 'namespace'; 155284"];
3638 [label="FullWidth = this.Text.Length; 155285"];
3639 [label="FullWidth 155286"];
3640 [label="this.AdjustFlagsAndWidth(trailing); 155287"];
3641 [label="return 'namespace'; 155288"];
3642 [label="FullWidth = this.Text.Length; 155289"];
3643 [label="FullWidth 155290"];
3644 [label="this.AdjustFlagsAndWidth(trailing); 155291"];
3645 [label="return 'using'; 155292"];
3646 [label="FullWidth = this.Text.Length; 155293"];
3647 [label="FullWidth 155294"];
3648 [label="return 'using'; 155295"];
3649 [label="FullWidth = this.Text.Length; 155296"];
3650 [label="FullWidth 155297"];
3651 [label="this.AdjustFlagsAndWidth(leading); 155298"];
3652 [label="return 'using'; 155299"];
3653 [label="FullWidth = this.Text.Length; 155300"];
3654 [label="FullWidth 155301"];
3655 [label="this.AdjustFlagsAndWidth(trailing); 155302"];
3656 [label="return 'using'; 155303"];
3657 [label="FullWidth = this.Text.Length; 155304"];
3658 [label="FullWidth 155305"];
3659 [label="this.AdjustFlagsAndWidth(trailing); 155306"];
3660 [label="return 'class'; 155307"];
3661 [label="FullWidth = this.Text.Length; 155308"];
3662 [label="FullWidth 155309"];
3663 [label="return 'class'; 155310"];
3664 [label="FullWidth = this.Text.Length; 155311"];
3665 [label="FullWidth 155312"];
3666 [label="this.AdjustFlagsAndWidth(leading); 155313"];
3667 [label="return 'class'; 155314"];
3668 [label="FullWidth = this.Text.Length; 155315"];
3669 [label="FullWidth 155316"];
3670 [label="this.AdjustFlagsAndWidth(trailing); 155317"];
3671 [label="return 'class'; 155318"];
3672 [label="FullWidth = this.Text.Length; 155319"];
3673 [label="FullWidth 155320"];
3674 [label="this.AdjustFlagsAndWidth(trailing); 155321"];
3675 [label="return 'struct'; 155322"];
3676 [label="FullWidth = this.Text.Length; 155323"];
3677 [label="FullWidth 155324"];
3678 [label="return 'struct'; 155325"];
3679 [label="FullWidth = this.Text.Length; 155326"];
3680 [label="FullWidth 155327"];
3681 [label="this.AdjustFlagsAndWidth(leading); 155328"];
3682 [label="return 'struct'; 155329"];
3683 [label="FullWidth = this.Text.Length; 155330"];
3684 [label="FullWidth 155331"];
3685 [label="this.AdjustFlagsAndWidth(trailing); 155332"];
3686 [label="return 'struct'; 155333"];
3687 [label="FullWidth = this.Text.Length; 155334"];
3688 [label="FullWidth 155335"];
3689 [label="this.AdjustFlagsAndWidth(trailing); 155336"];
3690 [label="return 'interface'; 155337"];
3691 [label="FullWidth = this.Text.Length; 155338"];
3692 [label="FullWidth 155339"];
3693 [label="return 'interface'; 155340"];
3694 [label="FullWidth = this.Text.Length; 155341"];
3695 [label="FullWidth 155342"];
3696 [label="this.AdjustFlagsAndWidth(leading); 155343"];
3697 [label="return 'interface'; 155344"];
3698 [label="FullWidth = this.Text.Length; 155345"];
3699 [label="FullWidth 155346"];
3700 [label="this.AdjustFlagsAndWidth(trailing); 155347"];
3701 [label="return 'interface'; 155348"];
3702 [label="FullWidth = this.Text.Length; 155349"];
3703 [label="FullWidth 155350"];
3704 [label="this.AdjustFlagsAndWidth(trailing); 155351"];
3705 [label="return 'enum'; 155352"];
3706 [label="FullWidth = this.Text.Length; 155353"];
3707 [label="FullWidth 155354"];
3708 [label="return 'enum'; 155355"];
3709 [label="FullWidth = this.Text.Length; 155356"];
3710 [label="FullWidth 155357"];
3711 [label="this.AdjustFlagsAndWidth(leading); 155358"];
3712 [label="return 'enum'; 155359"];
3713 [label="FullWidth = this.Text.Length; 155360"];
3714 [label="FullWidth 155361"];
3715 [label="this.AdjustFlagsAndWidth(trailing); 155362"];
3716 [label="return 'enum'; 155363"];
3717 [label="FullWidth = this.Text.Length; 155364"];
3718 [label="FullWidth 155365"];
3719 [label="this.AdjustFlagsAndWidth(trailing); 155366"];
3720 [label="return 'delegate'; 155367"];
3721 [label="FullWidth = this.Text.Length; 155368"];
3722 [label="FullWidth 155369"];
3723 [label="return 'delegate'; 155370"];
3724 [label="FullWidth = this.Text.Length; 155371"];
3725 [label="FullWidth 155372"];
3726 [label="this.AdjustFlagsAndWidth(leading); 155373"];
3727 [label="return 'delegate'; 155374"];
3728 [label="FullWidth = this.Text.Length; 155375"];
3729 [label="FullWidth 155376"];
3730 [label="this.AdjustFlagsAndWidth(trailing); 155377"];
3731 [label="return 'delegate'; 155378"];
3732 [label="FullWidth = this.Text.Length; 155379"];
3733 [label="FullWidth 155380"];
3734 [label="this.AdjustFlagsAndWidth(trailing); 155381"];
3735 [label="return 'checked'; 155382"];
3736 [label="FullWidth = this.Text.Length; 155383"];
3737 [label="FullWidth 155384"];
3738 [label="return 'checked'; 155385"];
3739 [label="FullWidth = this.Text.Length; 155386"];
3740 [label="FullWidth 155387"];
3741 [label="this.AdjustFlagsAndWidth(leading); 155388"];
3742 [label="return 'checked'; 155389"];
3743 [label="FullWidth = this.Text.Length; 155390"];
3744 [label="FullWidth 155391"];
3745 [label="this.AdjustFlagsAndWidth(trailing); 155392"];
3746 [label="return 'checked'; 155393"];
3747 [label="FullWidth = this.Text.Length; 155394"];
3748 [label="FullWidth 155395"];
3749 [label="this.AdjustFlagsAndWidth(trailing); 155396"];
3750 [label="return 'unchecked'; 155397"];
3751 [label="FullWidth = this.Text.Length; 155398"];
3752 [label="FullWidth 155399"];
3753 [label="return 'unchecked'; 155400"];
3754 [label="FullWidth = this.Text.Length; 155401"];
3755 [label="FullWidth 155402"];
3756 [label="this.AdjustFlagsAndWidth(leading); 155403"];
3757 [label="return 'unchecked'; 155404"];
3758 [label="FullWidth = this.Text.Length; 155405"];
3759 [label="FullWidth 155406"];
3760 [label="this.AdjustFlagsAndWidth(trailing); 155407"];
3761 [label="return 'unchecked'; 155408"];
3762 [label="FullWidth = this.Text.Length; 155409"];
3763 [label="FullWidth 155410"];
3764 [label="this.AdjustFlagsAndWidth(trailing); 155411"];
3765 [label="return 'unsafe'; 155412"];
3766 [label="FullWidth = this.Text.Length; 155413"];
3767 [label="FullWidth 155414"];
3768 [label="return 'unsafe'; 155415"];
3769 [label="FullWidth = this.Text.Length; 155416"];
3770 [label="FullWidth 155417"];
3771 [label="this.AdjustFlagsAndWidth(leading); 155418"];
3772 [label="return 'unsafe'; 155419"];
3773 [label="FullWidth = this.Text.Length; 155420"];
3774 [label="FullWidth 155421"];
3775 [label="this.AdjustFlagsAndWidth(trailing); 155422"];
3776 [label="return 'unsafe'; 155423"];
3777 [label="FullWidth = this.Text.Length; 155424"];
3778 [label="FullWidth 155425"];
3779 [label="this.AdjustFlagsAndWidth(trailing); 155426"];
3780 [label="return 'operator'; 155427"];
3781 [label="FullWidth = this.Text.Length; 155428"];
3782 [label="FullWidth 155429"];
3783 [label="return 'operator'; 155430"];
3784 [label="FullWidth = this.Text.Length; 155431"];
3785 [label="FullWidth 155432"];
3786 [label="this.AdjustFlagsAndWidth(leading); 155433"];
3787 [label="return 'operator'; 155434"];
3788 [label="FullWidth = this.Text.Length; 155435"];
3789 [label="FullWidth 155436"];
3790 [label="this.AdjustFlagsAndWidth(trailing); 155437"];
3791 [label="return 'operator'; 155438"];
3792 [label="FullWidth = this.Text.Length; 155439"];
3793 [label="FullWidth 155440"];
3794 [label="this.AdjustFlagsAndWidth(trailing); 155441"];
3795 [label="return 'explicit'; 155442"];
3796 [label="FullWidth = this.Text.Length; 155443"];
3797 [label="FullWidth 155444"];
3798 [label="return 'explicit'; 155445"];
3799 [label="FullWidth = this.Text.Length; 155446"];
3800 [label="FullWidth 155447"];
3801 [label="this.AdjustFlagsAndWidth(leading); 155448"];
3802 [label="return 'explicit'; 155449"];
3803 [label="FullWidth = this.Text.Length; 155450"];
3804 [label="FullWidth 155451"];
3805 [label="this.AdjustFlagsAndWidth(trailing); 155452"];
3806 [label="return 'explicit'; 155453"];
3807 [label="FullWidth = this.Text.Length; 155454"];
3808 [label="FullWidth 155455"];
3809 [label="this.AdjustFlagsAndWidth(trailing); 155456"];
3810 [label="return 'implicit'; 155457"];
3811 [label="FullWidth = this.Text.Length; 155458"];
3812 [label="FullWidth 155459"];
3813 [label="return 'implicit'; 155460"];
3814 [label="FullWidth = this.Text.Length; 155461"];
3815 [label="FullWidth 155462"];
3816 [label="this.AdjustFlagsAndWidth(leading); 155463"];
3817 [label="return 'implicit'; 155464"];
3818 [label="FullWidth = this.Text.Length; 155465"];
3819 [label="FullWidth 155466"];
3820 [label="this.AdjustFlagsAndWidth(trailing); 155467"];
3821 [label="return 'implicit'; 155468"];
3822 [label="FullWidth = this.Text.Length; 155469"];
3823 [label="FullWidth 155470"];
3824 [label="this.AdjustFlagsAndWidth(trailing); 155471"];
3825 [label="return 'yield'; 155472"];
3826 [label="FullWidth = this.Text.Length; 155473"];
3827 [label="FullWidth 155474"];
3828 [label="return 'yield'; 155475"];
3829 [label="FullWidth = this.Text.Length; 155476"];
3830 [label="FullWidth 155477"];
3831 [label="this.AdjustFlagsAndWidth(leading); 155478"];
3832 [label="return 'yield'; 155479"];
3833 [label="FullWidth = this.Text.Length; 155480"];
3834 [label="FullWidth 155481"];
3835 [label="this.AdjustFlagsAndWidth(trailing); 155482"];
3836 [label="return 'yield'; 155483"];
3837 [label="FullWidth = this.Text.Length; 155484"];
3838 [label="FullWidth 155485"];
3839 [label="this.AdjustFlagsAndWidth(trailing); 155486"];
3840 [label="return 'partial'; 155487"];
3841 [label="FullWidth = this.Text.Length; 155488"];
3842 [label="FullWidth 155489"];
3843 [label="return 'partial'; 155490"];
3844 [label="FullWidth = this.Text.Length; 155491"];
3845 [label="FullWidth 155492"];
3846 [label="this.AdjustFlagsAndWidth(leading); 155493"];
3847 [label="return 'partial'; 155494"];
3848 [label="FullWidth = this.Text.Length; 155495"];
3849 [label="FullWidth 155496"];
3850 [label="this.AdjustFlagsAndWidth(trailing); 155497"];
3851 [label="return 'partial'; 155498"];
3852 [label="FullWidth = this.Text.Length; 155499"];
3853 [label="FullWidth 155500"];
3854 [label="this.AdjustFlagsAndWidth(trailing); 155501"];
3855 [label="return 'alias'; 155502"];
3856 [label="FullWidth = this.Text.Length; 155503"];
3857 [label="FullWidth 155504"];
3858 [label="return 'alias'; 155505"];
3859 [label="FullWidth = this.Text.Length; 155506"];
3860 [label="FullWidth 155507"];
3861 [label="this.AdjustFlagsAndWidth(leading); 155508"];
3862 [label="return 'alias'; 155509"];
3863 [label="FullWidth = this.Text.Length; 155510"];
3864 [label="FullWidth 155511"];
3865 [label="this.AdjustFlagsAndWidth(trailing); 155512"];
3866 [label="return 'alias'; 155513"];
3867 [label="FullWidth = this.Text.Length; 155514"];
3868 [label="FullWidth 155515"];
3869 [label="this.AdjustFlagsAndWidth(trailing); 155516"];
3870 [label="return 'global'; 155517"];
3871 [label="FullWidth = this.Text.Length; 155518"];
3872 [label="FullWidth 155519"];
3873 [label="return 'global'; 155520"];
3874 [label="FullWidth = this.Text.Length; 155521"];
3875 [label="FullWidth 155522"];
3876 [label="this.AdjustFlagsAndWidth(leading); 155523"];
3877 [label="return 'global'; 155524"];
3878 [label="FullWidth = this.Text.Length; 155525"];
3879 [label="FullWidth 155526"];
3880 [label="this.AdjustFlagsAndWidth(trailing); 155527"];
3881 [label="return 'global'; 155528"];
3882 [label="FullWidth = this.Text.Length; 155529"];
3883 [label="FullWidth 155530"];
3884 [label="this.AdjustFlagsAndWidth(trailing); 155531"];
3885 [label="return 'assembly'; 155532"];
3886 [label="FullWidth = this.Text.Length; 155533"];
3887 [label="FullWidth 155534"];
3888 [label="return 'assembly'; 155535"];
3889 [label="FullWidth = this.Text.Length; 155536"];
3890 [label="FullWidth 155537"];
3891 [label="this.AdjustFlagsAndWidth(leading); 155538"];
3892 [label="return 'assembly'; 155539"];
3893 [label="FullWidth = this.Text.Length; 155540"];
3894 [label="FullWidth 155541"];
3895 [label="this.AdjustFlagsAndWidth(trailing); 155542"];
3896 [label="return 'assembly'; 155543"];
3897 [label="FullWidth = this.Text.Length; 155544"];
3898 [label="FullWidth 155545"];
3899 [label="this.AdjustFlagsAndWidth(trailing); 155546"];
3900 [label="return 'module'; 155547"];
3901 [label="FullWidth = this.Text.Length; 155548"];
3902 [label="FullWidth 155549"];
3903 [label="return 'module'; 155550"];
3904 [label="FullWidth = this.Text.Length; 155551"];
3905 [label="FullWidth 155552"];
3906 [label="this.AdjustFlagsAndWidth(leading); 155553"];
3907 [label="return 'module'; 155554"];
3908 [label="FullWidth = this.Text.Length; 155555"];
3909 [label="FullWidth 155556"];
3910 [label="this.AdjustFlagsAndWidth(trailing); 155557"];
3911 [label="return 'module'; 155558"];
3912 [label="FullWidth = this.Text.Length; 155559"];
3913 [label="FullWidth 155560"];
3914 [label="this.AdjustFlagsAndWidth(trailing); 155561"];
3915 [label="return 'type'; 155562"];
3916 [label="FullWidth = this.Text.Length; 155563"];
3917 [label="FullWidth 155564"];
3918 [label="return 'type'; 155565"];
3919 [label="FullWidth = this.Text.Length; 155566"];
3920 [label="FullWidth 155567"];
3921 [label="this.AdjustFlagsAndWidth(leading); 155568"];
3922 [label="return 'type'; 155569"];
3923 [label="FullWidth = this.Text.Length; 155570"];
3924 [label="FullWidth 155571"];
3925 [label="this.AdjustFlagsAndWidth(trailing); 155572"];
3926 [label="return 'type'; 155573"];
3927 [label="FullWidth = this.Text.Length; 155574"];
3928 [label="FullWidth 155575"];
3929 [label="this.AdjustFlagsAndWidth(trailing); 155576"];
3930 [label="return 'field'; 155577"];
3931 [label="FullWidth = this.Text.Length; 155578"];
3932 [label="FullWidth 155579"];
3933 [label="return 'field'; 155580"];
3934 [label="FullWidth = this.Text.Length; 155581"];
3935 [label="FullWidth 155582"];
3936 [label="this.AdjustFlagsAndWidth(leading); 155583"];
3937 [label="return 'field'; 155584"];
3938 [label="FullWidth = this.Text.Length; 155585"];
3939 [label="FullWidth 155586"];
3940 [label="this.AdjustFlagsAndWidth(trailing); 155587"];
3941 [label="return 'field'; 155588"];
3942 [label="FullWidth = this.Text.Length; 155589"];
3943 [label="FullWidth 155590"];
3944 [label="this.AdjustFlagsAndWidth(trailing); 155591"];
3945 [label="return 'method'; 155592"];
3946 [label="FullWidth = this.Text.Length; 155593"];
3947 [label="FullWidth 155594"];
3948 [label="return 'method'; 155595"];
3949 [label="FullWidth = this.Text.Length; 155596"];
3950 [label="FullWidth 155597"];
3951 [label="this.AdjustFlagsAndWidth(leading); 155598"];
3952 [label="return 'method'; 155599"];
3953 [label="FullWidth = this.Text.Length; 155600"];
3954 [label="FullWidth 155601"];
3955 [label="this.AdjustFlagsAndWidth(trailing); 155602"];
3956 [label="return 'method'; 155603"];
3957 [label="FullWidth = this.Text.Length; 155604"];
3958 [label="FullWidth 155605"];
3959 [label="this.AdjustFlagsAndWidth(trailing); 155606"];
3960 [label="return 'param'; 155607"];
3961 [label="FullWidth = this.Text.Length; 155608"];
3962 [label="FullWidth 155609"];
3963 [label="return 'param'; 155610"];
3964 [label="FullWidth = this.Text.Length; 155611"];
3965 [label="FullWidth 155612"];
3966 [label="this.AdjustFlagsAndWidth(leading); 155613"];
3967 [label="return 'param'; 155614"];
3968 [label="FullWidth = this.Text.Length; 155615"];
3969 [label="FullWidth 155616"];
3970 [label="this.AdjustFlagsAndWidth(trailing); 155617"];
3971 [label="return 'param'; 155618"];
3972 [label="FullWidth = this.Text.Length; 155619"];
3973 [label="FullWidth 155620"];
3974 [label="this.AdjustFlagsAndWidth(trailing); 155621"];
3975 [label="return 'property'; 155622"];
3976 [label="FullWidth = this.Text.Length; 155623"];
3977 [label="FullWidth 155624"];
3978 [label="return 'property'; 155625"];
3979 [label="FullWidth = this.Text.Length; 155626"];
3980 [label="FullWidth 155627"];
3981 [label="this.AdjustFlagsAndWidth(leading); 155628"];
3982 [label="return 'property'; 155629"];
3983 [label="FullWidth = this.Text.Length; 155630"];
3984 [label="FullWidth 155631"];
3985 [label="this.AdjustFlagsAndWidth(trailing); 155632"];
3986 [label="return 'property'; 155633"];
3987 [label="FullWidth = this.Text.Length; 155634"];
3988 [label="FullWidth 155635"];
3989 [label="this.AdjustFlagsAndWidth(trailing); 155636"];
3990 [label="return 'typevar'; 155637"];
3991 [label="FullWidth = this.Text.Length; 155638"];
3992 [label="FullWidth 155639"];
3993 [label="return 'typevar'; 155640"];
3994 [label="FullWidth = this.Text.Length; 155641"];
3995 [label="FullWidth 155642"];
3996 [label="this.AdjustFlagsAndWidth(leading); 155643"];
3997 [label="return 'typevar'; 155644"];
3998 [label="FullWidth = this.Text.Length; 155645"];
3999 [label="FullWidth 155646"];
4000 [label="this.AdjustFlagsAndWidth(trailing); 155647"];
4001 [label="return 'typevar'; 155648"];
4002 [label="FullWidth = this.Text.Length; 155649"];
4003 [label="FullWidth 155650"];
4004 [label="this.AdjustFlagsAndWidth(trailing); 155651"];
4005 [label="return 'get'; 155652"];
4006 [label="FullWidth = this.Text.Length; 155653"];
4007 [label="FullWidth 155654"];
4008 [label="return 'get'; 155655"];
4009 [label="FullWidth = this.Text.Length; 155656"];
4010 [label="FullWidth 155657"];
4011 [label="this.AdjustFlagsAndWidth(leading); 155658"];
4012 [label="return 'get'; 155659"];
4013 [label="FullWidth = this.Text.Length; 155660"];
4014 [label="FullWidth 155661"];
4015 [label="this.AdjustFlagsAndWidth(trailing); 155662"];
4016 [label="return 'get'; 155663"];
4017 [label="FullWidth = this.Text.Length; 155664"];
4018 [label="FullWidth 155665"];
4019 [label="this.AdjustFlagsAndWidth(trailing); 155666"];
4020 [label="return 'set'; 155667"];
4021 [label="FullWidth = this.Text.Length; 155668"];
4022 [label="FullWidth 155669"];
4023 [label="return 'set'; 155670"];
4024 [label="FullWidth = this.Text.Length; 155671"];
4025 [label="FullWidth 155672"];
4026 [label="this.AdjustFlagsAndWidth(leading); 155673"];
4027 [label="return 'set'; 155674"];
4028 [label="FullWidth = this.Text.Length; 155675"];
4029 [label="FullWidth 155676"];
4030 [label="this.AdjustFlagsAndWidth(trailing); 155677"];
4031 [label="return 'set'; 155678"];
4032 [label="FullWidth = this.Text.Length; 155679"];
4033 [label="FullWidth 155680"];
4034 [label="this.AdjustFlagsAndWidth(trailing); 155681"];
4035 [label="return 'add'; 155682"];
4036 [label="FullWidth = this.Text.Length; 155683"];
4037 [label="FullWidth 155684"];
4038 [label="return 'add'; 155685"];
4039 [label="FullWidth = this.Text.Length; 155686"];
4040 [label="FullWidth 155687"];
4041 [label="this.AdjustFlagsAndWidth(leading); 155688"];
4042 [label="return 'add'; 155689"];
4043 [label="FullWidth = this.Text.Length; 155690"];
4044 [label="FullWidth 155691"];
4045 [label="this.AdjustFlagsAndWidth(trailing); 155692"];
4046 [label="return 'add'; 155693"];
4047 [label="FullWidth = this.Text.Length; 155694"];
4048 [label="FullWidth 155695"];
4049 [label="this.AdjustFlagsAndWidth(trailing); 155696"];
4050 [label="return 'remove'; 155697"];
4051 [label="FullWidth = this.Text.Length; 155698"];
4052 [label="FullWidth 155699"];
4053 [label="return 'remove'; 155700"];
4054 [label="FullWidth = this.Text.Length; 155701"];
4055 [label="FullWidth 155702"];
4056 [label="this.AdjustFlagsAndWidth(leading); 155703"];
4057 [label="return 'remove'; 155704"];
4058 [label="FullWidth = this.Text.Length; 155705"];
4059 [label="FullWidth 155706"];
4060 [label="this.AdjustFlagsAndWidth(trailing); 155707"];
4061 [label="return 'remove'; 155708"];
4062 [label="FullWidth = this.Text.Length; 155709"];
4063 [label="FullWidth 155710"];
4064 [label="this.AdjustFlagsAndWidth(trailing); 155711"];
4065 [label="return 'where'; 155712"];
4066 [label="FullWidth = this.Text.Length; 155713"];
4067 [label="FullWidth 155714"];
4068 [label="return 'where'; 155715"];
4069 [label="FullWidth = this.Text.Length; 155716"];
4070 [label="FullWidth 155717"];
4071 [label="this.AdjustFlagsAndWidth(leading); 155718"];
4072 [label="return 'where'; 155719"];
4073 [label="FullWidth = this.Text.Length; 155720"];
4074 [label="FullWidth 155721"];
4075 [label="this.AdjustFlagsAndWidth(trailing); 155722"];
4076 [label="return 'where'; 155723"];
4077 [label="FullWidth = this.Text.Length; 155724"];
4078 [label="FullWidth 155725"];
4079 [label="this.AdjustFlagsAndWidth(trailing); 155726"];
4080 [label="return 'from'; 155727"];
4081 [label="FullWidth = this.Text.Length; 155728"];
4082 [label="FullWidth 155729"];
4083 [label="return 'from'; 155730"];
4084 [label="FullWidth = this.Text.Length; 155731"];
4085 [label="FullWidth 155732"];
4086 [label="this.AdjustFlagsAndWidth(leading); 155733"];
4087 [label="return 'from'; 155734"];
4088 [label="FullWidth = this.Text.Length; 155735"];
4089 [label="FullWidth 155736"];
4090 [label="this.AdjustFlagsAndWidth(trailing); 155737"];
4091 [label="return 'from'; 155738"];
4092 [label="FullWidth = this.Text.Length; 155739"];
4093 [label="FullWidth 155740"];
4094 [label="this.AdjustFlagsAndWidth(trailing); 155741"];
4095 [label="return 'group'; 155742"];
4096 [label="FullWidth = this.Text.Length; 155743"];
4097 [label="FullWidth 155744"];
4098 [label="return 'group'; 155745"];
4099 [label="FullWidth = this.Text.Length; 155746"];
4100 [label="FullWidth 155747"];
4101 [label="this.AdjustFlagsAndWidth(leading); 155748"];
4102 [label="return 'group'; 155749"];
4103 [label="FullWidth = this.Text.Length; 155750"];
4104 [label="FullWidth 155751"];
4105 [label="this.AdjustFlagsAndWidth(trailing); 155752"];
4106 [label="return 'group'; 155753"];
4107 [label="FullWidth = this.Text.Length; 155754"];
4108 [label="FullWidth 155755"];
4109 [label="this.AdjustFlagsAndWidth(trailing); 155756"];
4110 [label="return 'join'; 155757"];
4111 [label="FullWidth = this.Text.Length; 155758"];
4112 [label="FullWidth 155759"];
4113 [label="return 'join'; 155760"];
4114 [label="FullWidth = this.Text.Length; 155761"];
4115 [label="FullWidth 155762"];
4116 [label="this.AdjustFlagsAndWidth(leading); 155763"];
4117 [label="return 'join'; 155764"];
4118 [label="FullWidth = this.Text.Length; 155765"];
4119 [label="FullWidth 155766"];
4120 [label="this.AdjustFlagsAndWidth(trailing); 155767"];
4121 [label="return 'join'; 155768"];
4122 [label="FullWidth = this.Text.Length; 155769"];
4123 [label="FullWidth 155770"];
4124 [label="this.AdjustFlagsAndWidth(trailing); 155771"];
4125 [label="return 'into'; 155772"];
4126 [label="FullWidth = this.Text.Length; 155773"];
4127 [label="FullWidth 155774"];
4128 [label="return 'into'; 155775"];
4129 [label="FullWidth = this.Text.Length; 155776"];
4130 [label="FullWidth 155777"];
4131 [label="this.AdjustFlagsAndWidth(leading); 155778"];
4132 [label="return 'into'; 155779"];
4133 [label="FullWidth = this.Text.Length; 155780"];
4134 [label="FullWidth 155781"];
4135 [label="this.AdjustFlagsAndWidth(trailing); 155782"];
4136 [label="return 'into'; 155783"];
4137 [label="FullWidth = this.Text.Length; 155784"];
4138 [label="FullWidth 155785"];
4139 [label="this.AdjustFlagsAndWidth(trailing); 155786"];
4140 [label="return 'let'; 155787"];
4141 [label="FullWidth = this.Text.Length; 155788"];
4142 [label="FullWidth 155789"];
4143 [label="return 'let'; 155790"];
4144 [label="FullWidth = this.Text.Length; 155791"];
4145 [label="FullWidth 155792"];
4146 [label="this.AdjustFlagsAndWidth(leading); 155793"];
4147 [label="return 'let'; 155794"];
4148 [label="FullWidth = this.Text.Length; 155795"];
4149 [label="FullWidth 155796"];
4150 [label="this.AdjustFlagsAndWidth(trailing); 155797"];
4151 [label="return 'let'; 155798"];
4152 [label="FullWidth = this.Text.Length; 155799"];
4153 [label="FullWidth 155800"];
4154 [label="this.AdjustFlagsAndWidth(trailing); 155801"];
4155 [label="return 'by'; 155802"];
4156 [label="FullWidth = this.Text.Length; 155803"];
4157 [label="FullWidth 155804"];
4158 [label="return 'by'; 155805"];
4159 [label="FullWidth = this.Text.Length; 155806"];
4160 [label="FullWidth 155807"];
4161 [label="this.AdjustFlagsAndWidth(leading); 155808"];
4162 [label="return 'by'; 155809"];
4163 [label="FullWidth = this.Text.Length; 155810"];
4164 [label="FullWidth 155811"];
4165 [label="this.AdjustFlagsAndWidth(trailing); 155812"];
4166 [label="return 'by'; 155813"];
4167 [label="FullWidth = this.Text.Length; 155814"];
4168 [label="FullWidth 155815"];
4169 [label="this.AdjustFlagsAndWidth(trailing); 155816"];
4170 [label="return 'select'; 155817"];
4171 [label="FullWidth = this.Text.Length; 155818"];
4172 [label="FullWidth 155819"];
4173 [label="return 'select'; 155820"];
4174 [label="FullWidth = this.Text.Length; 155821"];
4175 [label="FullWidth 155822"];
4176 [label="this.AdjustFlagsAndWidth(leading); 155823"];
4177 [label="return 'select'; 155824"];
4178 [label="FullWidth = this.Text.Length; 155825"];
4179 [label="FullWidth 155826"];
4180 [label="this.AdjustFlagsAndWidth(trailing); 155827"];
4181 [label="return 'select'; 155828"];
4182 [label="FullWidth = this.Text.Length; 155829"];
4183 [label="FullWidth 155830"];
4184 [label="this.AdjustFlagsAndWidth(trailing); 155831"];
4185 [label="return 'orderby'; 155832"];
4186 [label="FullWidth = this.Text.Length; 155833"];
4187 [label="FullWidth 155834"];
4188 [label="return 'orderby'; 155835"];
4189 [label="FullWidth = this.Text.Length; 155836"];
4190 [label="FullWidth 155837"];
4191 [label="this.AdjustFlagsAndWidth(leading); 155838"];
4192 [label="return 'orderby'; 155839"];
4193 [label="FullWidth = this.Text.Length; 155840"];
4194 [label="FullWidth 155841"];
4195 [label="this.AdjustFlagsAndWidth(trailing); 155842"];
4196 [label="return 'orderby'; 155843"];
4197 [label="FullWidth = this.Text.Length; 155844"];
4198 [label="FullWidth 155845"];
4199 [label="this.AdjustFlagsAndWidth(trailing); 155846"];
4200 [label="return 'on'; 155847"];
4201 [label="FullWidth = this.Text.Length; 155848"];
4202 [label="FullWidth 155849"];
4203 [label="return 'on'; 155850"];
4204 [label="FullWidth = this.Text.Length; 155851"];
4205 [label="FullWidth 155852"];
4206 [label="this.AdjustFlagsAndWidth(leading); 155853"];
4207 [label="return 'on'; 155854"];
4208 [label="FullWidth = this.Text.Length; 155855"];
4209 [label="FullWidth 155856"];
4210 [label="this.AdjustFlagsAndWidth(trailing); 155857"];
4211 [label="return 'on'; 155858"];
4212 [label="FullWidth = this.Text.Length; 155859"];
4213 [label="FullWidth 155860"];
4214 [label="this.AdjustFlagsAndWidth(trailing); 155861"];
4215 [label="return 'equals'; 155862"];
4216 [label="FullWidth = this.Text.Length; 155863"];
4217 [label="FullWidth 155864"];
4218 [label="return 'equals'; 155865"];
4219 [label="FullWidth = this.Text.Length; 155866"];
4220 [label="FullWidth 155867"];
4221 [label="this.AdjustFlagsAndWidth(leading); 155868"];
4222 [label="return 'equals'; 155869"];
4223 [label="FullWidth = this.Text.Length; 155870"];
4224 [label="FullWidth 155871"];
4225 [label="this.AdjustFlagsAndWidth(trailing); 155872"];
4226 [label="return 'equals'; 155873"];
4227 [label="FullWidth = this.Text.Length; 155874"];
4228 [label="FullWidth 155875"];
4229 [label="this.AdjustFlagsAndWidth(trailing); 155876"];
4230 [label="return 'ascending'; 155877"];
4231 [label="FullWidth = this.Text.Length; 155878"];
4232 [label="FullWidth 155879"];
4233 [label="return 'ascending'; 155880"];
4234 [label="FullWidth = this.Text.Length; 155881"];
4235 [label="FullWidth 155882"];
4236 [label="this.AdjustFlagsAndWidth(leading); 155883"];
4237 [label="return 'ascending'; 155884"];
4238 [label="FullWidth = this.Text.Length; 155885"];
4239 [label="FullWidth 155886"];
4240 [label="this.AdjustFlagsAndWidth(trailing); 155887"];
4241 [label="return 'ascending'; 155888"];
4242 [label="FullWidth = this.Text.Length; 155889"];
4243 [label="FullWidth 155890"];
4244 [label="this.AdjustFlagsAndWidth(trailing); 155891"];
4245 [label="return 'descending'; 155892"];
4246 [label="FullWidth = this.Text.Length; 155893"];
4247 [label="FullWidth 155894"];
4248 [label="return 'descending'; 155895"];
4249 [label="FullWidth = this.Text.Length; 155896"];
4250 [label="FullWidth 155897"];
4251 [label="this.AdjustFlagsAndWidth(leading); 155898"];
4252 [label="return 'descending'; 155899"];
4253 [label="FullWidth = this.Text.Length; 155900"];
4254 [label="FullWidth 155901"];
4255 [label="this.AdjustFlagsAndWidth(trailing); 155902"];
4256 [label="return 'descending'; 155903"];
4257 [label="FullWidth = this.Text.Length; 155904"];
4258 [label="FullWidth 155905"];
4259 [label="this.AdjustFlagsAndWidth(trailing); 155906"];
4260 [label="return 'nameof'; 155907"];
4261 [label="FullWidth = this.Text.Length; 155908"];
4262 [label="FullWidth 155909"];
4263 [label="return 'nameof'; 155910"];
4264 [label="FullWidth = this.Text.Length; 155911"];
4265 [label="FullWidth 155912"];
4266 [label="this.AdjustFlagsAndWidth(leading); 155913"];
4267 [label="return 'nameof'; 155914"];
4268 [label="FullWidth = this.Text.Length; 155915"];
4269 [label="FullWidth 155916"];
4270 [label="this.AdjustFlagsAndWidth(trailing); 155917"];
4271 [label="return 'nameof'; 155918"];
4272 [label="FullWidth = this.Text.Length; 155919"];
4273 [label="FullWidth 155920"];
4274 [label="this.AdjustFlagsAndWidth(trailing); 155921"];
4275 [label="return 'async'; 155922"];
4276 [label="FullWidth = this.Text.Length; 155923"];
4277 [label="FullWidth 155924"];
4278 [label="return 'async'; 155925"];
4279 [label="FullWidth = this.Text.Length; 155926"];
4280 [label="FullWidth 155927"];
4281 [label="this.AdjustFlagsAndWidth(leading); 155928"];
4282 [label="return 'async'; 155929"];
4283 [label="FullWidth = this.Text.Length; 155930"];
4284 [label="FullWidth 155931"];
4285 [label="this.AdjustFlagsAndWidth(trailing); 155932"];
4286 [label="return 'async'; 155933"];
4287 [label="FullWidth = this.Text.Length; 155934"];
4288 [label="FullWidth 155935"];
4289 [label="this.AdjustFlagsAndWidth(trailing); 155936"];
4290 [label="return 'await'; 155937"];
4291 [label="FullWidth = this.Text.Length; 155938"];
4292 [label="FullWidth 155939"];
4293 [label="return 'await'; 155940"];
4294 [label="FullWidth = this.Text.Length; 155941"];
4295 [label="FullWidth 155942"];
4296 [label="this.AdjustFlagsAndWidth(leading); 155943"];
4297 [label="return 'await'; 155944"];
4298 [label="FullWidth = this.Text.Length; 155945"];
4299 [label="FullWidth 155946"];
4300 [label="this.AdjustFlagsAndWidth(trailing); 155947"];
4301 [label="return 'await'; 155948"];
4302 [label="FullWidth = this.Text.Length; 155949"];
4303 [label="FullWidth 155950"];
4304 [label="this.AdjustFlagsAndWidth(trailing); 155951"];
4305 [label="return 'when'; 155952"];
4306 [label="FullWidth = this.Text.Length; 155953"];
4307 [label="FullWidth 155954"];
4308 [label="return 'when'; 155955"];
4309 [label="FullWidth = this.Text.Length; 155956"];
4310 [label="FullWidth 155957"];
4311 [label="this.AdjustFlagsAndWidth(leading); 155958"];
4312 [label="return 'when'; 155959"];
4313 [label="FullWidth = this.Text.Length; 155960"];
4314 [label="FullWidth 155961"];
4315 [label="this.AdjustFlagsAndWidth(trailing); 155962"];
4316 [label="return 'when'; 155963"];
4317 [label="FullWidth = this.Text.Length; 155964"];
4318 [label="FullWidth 155965"];
4319 [label="this.AdjustFlagsAndWidth(trailing); 155966"];
4320 [label="return 'or'; 155967"];
4321 [label="FullWidth = this.Text.Length; 155968"];
4322 [label="FullWidth 155969"];
4323 [label="return 'or'; 155970"];
4324 [label="FullWidth = this.Text.Length; 155971"];
4325 [label="FullWidth 155972"];
4326 [label="this.AdjustFlagsAndWidth(leading); 155973"];
4327 [label="return 'or'; 155974"];
4328 [label="FullWidth = this.Text.Length; 155975"];
4329 [label="FullWidth 155976"];
4330 [label="this.AdjustFlagsAndWidth(trailing); 155977"];
4331 [label="return 'or'; 155978"];
4332 [label="FullWidth = this.Text.Length; 155979"];
4333 [label="FullWidth 155980"];
4334 [label="this.AdjustFlagsAndWidth(trailing); 155981"];
4335 [label="return 'and'; 155982"];
4336 [label="FullWidth = this.Text.Length; 155983"];
4337 [label="FullWidth 155984"];
4338 [label="return 'and'; 155985"];
4339 [label="FullWidth = this.Text.Length; 155986"];
4340 [label="FullWidth 155987"];
4341 [label="this.AdjustFlagsAndWidth(leading); 155988"];
4342 [label="return 'and'; 155989"];
4343 [label="FullWidth = this.Text.Length; 155990"];
4344 [label="FullWidth 155991"];
4345 [label="this.AdjustFlagsAndWidth(trailing); 155992"];
4346 [label="return 'and'; 155993"];
4347 [label="FullWidth = this.Text.Length; 155994"];
4348 [label="FullWidth 155995"];
4349 [label="this.AdjustFlagsAndWidth(trailing); 155996"];
4350 [label="return 'not'; 155997"];
4351 [label="FullWidth = this.Text.Length; 155998"];
4352 [label="FullWidth 155999"];
4353 [label="return 'not'; 156000"];
4354 [label="FullWidth = this.Text.Length; 156001"];
4355 [label="FullWidth 156002"];
4356 [label="this.AdjustFlagsAndWidth(leading); 156003"];
4357 [label="return 'not'; 156004"];
4358 [label="FullWidth = this.Text.Length; 156005"];
4359 [label="FullWidth 156006"];
4360 [label="this.AdjustFlagsAndWidth(trailing); 156007"];
4361 [label="return 'not'; 156008"];
4362 [label="FullWidth = this.Text.Length; 156009"];
4363 [label="FullWidth 156010"];
4364 [label="this.AdjustFlagsAndWidth(trailing); 156011"];
4365 [label="return 'data'; 156012"];
4366 [label="FullWidth = this.Text.Length; 156013"];
4367 [label="FullWidth 156014"];
4368 [label="return 'data'; 156015"];
4369 [label="FullWidth = this.Text.Length; 156016"];
4370 [label="FullWidth 156017"];
4371 [label="this.AdjustFlagsAndWidth(leading); 156018"];
4372 [label="return 'data'; 156019"];
4373 [label="FullWidth = this.Text.Length; 156020"];
4374 [label="FullWidth 156021"];
4375 [label="this.AdjustFlagsAndWidth(trailing); 156022"];
4376 [label="return 'data'; 156023"];
4377 [label="FullWidth = this.Text.Length; 156024"];
4378 [label="FullWidth 156025"];
4379 [label="this.AdjustFlagsAndWidth(trailing); 156026"];
4380 [label="return 'with'; 156027"];
4381 [label="FullWidth = this.Text.Length; 156028"];
4382 [label="FullWidth 156029"];
4383 [label="return 'with'; 156030"];
4384 [label="FullWidth = this.Text.Length; 156031"];
4385 [label="FullWidth 156032"];
4386 [label="this.AdjustFlagsAndWidth(leading); 156033"];
4387 [label="return 'with'; 156034"];
4388 [label="FullWidth = this.Text.Length; 156035"];
4389 [label="FullWidth 156036"];
4390 [label="this.AdjustFlagsAndWidth(trailing); 156037"];
4391 [label="return 'with'; 156038"];
4392 [label="FullWidth = this.Text.Length; 156039"];
4393 [label="FullWidth 156040"];
4394 [label="this.AdjustFlagsAndWidth(trailing); 156041"];
4395 [label="return 'init'; 156042"];
4396 [label="FullWidth = this.Text.Length; 156043"];
4397 [label="FullWidth 156044"];
4398 [label="return 'init'; 156045"];
4399 [label="FullWidth = this.Text.Length; 156046"];
4400 [label="FullWidth 156047"];
4401 [label="this.AdjustFlagsAndWidth(leading); 156048"];
4402 [label="return 'init'; 156049"];
4403 [label="FullWidth = this.Text.Length; 156050"];
4404 [label="FullWidth 156051"];
4405 [label="this.AdjustFlagsAndWidth(trailing); 156052"];
4406 [label="return 'init'; 156053"];
4407 [label="FullWidth = this.Text.Length; 156054"];
4408 [label="FullWidth 156055"];
4409 [label="this.AdjustFlagsAndWidth(trailing); 156056"];
4410 [label="return 'record'; 156057"];
4411 [label="FullWidth = this.Text.Length; 156058"];
4412 [label="FullWidth 156059"];
4413 [label="return 'record'; 156060"];
4414 [label="FullWidth = this.Text.Length; 156061"];
4415 [label="FullWidth 156062"];
4416 [label="this.AdjustFlagsAndWidth(leading); 156063"];
4417 [label="return 'record'; 156064"];
4418 [label="FullWidth = this.Text.Length; 156065"];
4419 [label="FullWidth 156066"];
4420 [label="this.AdjustFlagsAndWidth(trailing); 156067"];
4421 [label="return 'record'; 156068"];
4422 [label="FullWidth = this.Text.Length; 156069"];
4423 [label="FullWidth 156070"];
4424 [label="this.AdjustFlagsAndWidth(trailing); 156071"];
4425 [label="return 'managed'; 156072"];
4426 [label="FullWidth = this.Text.Length; 156073"];
4427 [label="FullWidth 156074"];
4428 [label="return 'managed'; 156075"];
4429 [label="FullWidth = this.Text.Length; 156076"];
4430 [label="FullWidth 156077"];
4431 [label="this.AdjustFlagsAndWidth(leading); 156078"];
4432 [label="return 'managed'; 156079"];
4433 [label="FullWidth = this.Text.Length; 156080"];
4434 [label="FullWidth 156081"];
4435 [label="this.AdjustFlagsAndWidth(trailing); 156082"];
4436 [label="return 'managed'; 156083"];
4437 [label="FullWidth = this.Text.Length; 156084"];
4438 [label="FullWidth 156085"];
4439 [label="this.AdjustFlagsAndWidth(trailing); 156086"];
4440 [label="return 'unmanaged'; 156087"];
4441 [label="FullWidth = this.Text.Length; 156088"];
4442 [label="FullWidth 156089"];
4443 [label="return 'unmanaged'; 156090"];
4444 [label="FullWidth = this.Text.Length; 156091"];
4445 [label="FullWidth 156092"];
4446 [label="this.AdjustFlagsAndWidth(leading); 156093"];
4447 [label="return 'unmanaged'; 156094"];
4448 [label="FullWidth = this.Text.Length; 156095"];
4449 [label="FullWidth 156096"];
4450 [label="this.AdjustFlagsAndWidth(trailing); 156097"];
4451 [label="return 'unmanaged'; 156098"];
4452 [label="FullWidth = this.Text.Length; 156099"];
4453 [label="FullWidth 156100"];
4454 [label="this.AdjustFlagsAndWidth(trailing); 156101"];
4455 [label="return 'elif'; 156102"];
4456 [label="FullWidth = this.Text.Length; 156103"];
4457 [label="FullWidth 156104"];
4458 [label="return 'elif'; 156105"];
4459 [label="FullWidth = this.Text.Length; 156106"];
4460 [label="FullWidth 156107"];
4461 [label="this.AdjustFlagsAndWidth(leading); 156108"];
4462 [label="return 'elif'; 156109"];
4463 [label="FullWidth = this.Text.Length; 156110"];
4464 [label="FullWidth 156111"];
4465 [label="this.AdjustFlagsAndWidth(trailing); 156112"];
4466 [label="return 'elif'; 156113"];
4467 [label="FullWidth = this.Text.Length; 156114"];
4468 [label="FullWidth 156115"];
4469 [label="this.AdjustFlagsAndWidth(trailing); 156116"];
4470 [label="return 'endif'; 156117"];
4471 [label="FullWidth = this.Text.Length; 156118"];
4472 [label="FullWidth 156119"];
4473 [label="return 'endif'; 156120"];
4474 [label="FullWidth = this.Text.Length; 156121"];
4475 [label="FullWidth 156122"];
4476 [label="this.AdjustFlagsAndWidth(leading); 156123"];
4477 [label="return 'endif'; 156124"];
4478 [label="FullWidth = this.Text.Length; 156125"];
4479 [label="FullWidth 156126"];
4480 [label="this.AdjustFlagsAndWidth(trailing); 156127"];
4481 [label="return 'endif'; 156128"];
4482 [label="FullWidth = this.Text.Length; 156129"];
4483 [label="FullWidth 156130"];
4484 [label="this.AdjustFlagsAndWidth(trailing); 156131"];
4485 [label="return 'region'; 156132"];
4486 [label="FullWidth = this.Text.Length; 156133"];
4487 [label="FullWidth 156134"];
4488 [label="return 'region'; 156135"];
4489 [label="FullWidth = this.Text.Length; 156136"];
4490 [label="FullWidth 156137"];
4491 [label="this.AdjustFlagsAndWidth(leading); 156138"];
4492 [label="return 'region'; 156139"];
4493 [label="FullWidth = this.Text.Length; 156140"];
4494 [label="FullWidth 156141"];
4495 [label="this.AdjustFlagsAndWidth(trailing); 156142"];
4496 [label="return 'region'; 156143"];
4497 [label="FullWidth = this.Text.Length; 156144"];
4498 [label="FullWidth 156145"];
4499 [label="this.AdjustFlagsAndWidth(trailing); 156146"];
4500 [label="return 'endregion'; 156147"];
4501 [label="FullWidth = this.Text.Length; 156148"];
4502 [label="FullWidth 156149"];
4503 [label="return 'endregion'; 156150"];
4504 [label="FullWidth = this.Text.Length; 156151"];
4505 [label="FullWidth 156152"];
4506 [label="this.AdjustFlagsAndWidth(leading); 156153"];
4507 [label="return 'endregion'; 156154"];
4508 [label="FullWidth = this.Text.Length; 156155"];
4509 [label="FullWidth 156156"];
4510 [label="this.AdjustFlagsAndWidth(trailing); 156157"];
4511 [label="return 'endregion'; 156158"];
4512 [label="FullWidth = this.Text.Length; 156159"];
4513 [label="FullWidth 156160"];
4514 [label="this.AdjustFlagsAndWidth(trailing); 156161"];
4515 [label="return 'define'; 156162"];
4516 [label="FullWidth = this.Text.Length; 156163"];
4517 [label="FullWidth 156164"];
4518 [label="return 'define'; 156165"];
4519 [label="FullWidth = this.Text.Length; 156166"];
4520 [label="FullWidth 156167"];
4521 [label="this.AdjustFlagsAndWidth(leading); 156168"];
4522 [label="return 'define'; 156169"];
4523 [label="FullWidth = this.Text.Length; 156170"];
4524 [label="FullWidth 156171"];
4525 [label="this.AdjustFlagsAndWidth(trailing); 156172"];
4526 [label="return 'define'; 156173"];
4527 [label="FullWidth = this.Text.Length; 156174"];
4528 [label="FullWidth 156175"];
4529 [label="this.AdjustFlagsAndWidth(trailing); 156176"];
4530 [label="return 'undef'; 156177"];
4531 [label="FullWidth = this.Text.Length; 156178"];
4532 [label="FullWidth 156179"];
4533 [label="return 'undef'; 156180"];
4534 [label="FullWidth = this.Text.Length; 156181"];
4535 [label="FullWidth 156182"];
4536 [label="this.AdjustFlagsAndWidth(leading); 156183"];
4537 [label="return 'undef'; 156184"];
4538 [label="FullWidth = this.Text.Length; 156185"];
4539 [label="FullWidth 156186"];
4540 [label="this.AdjustFlagsAndWidth(trailing); 156187"];
4541 [label="return 'undef'; 156188"];
4542 [label="FullWidth = this.Text.Length; 156189"];
4543 [label="FullWidth 156190"];
4544 [label="this.AdjustFlagsAndWidth(trailing); 156191"];
4545 [label="return 'warning'; 156192"];
4546 [label="FullWidth = this.Text.Length; 156193"];
4547 [label="FullWidth 156194"];
4548 [label="return 'warning'; 156195"];
4549 [label="FullWidth = this.Text.Length; 156196"];
4550 [label="FullWidth 156197"];
4551 [label="this.AdjustFlagsAndWidth(leading); 156198"];
4552 [label="return 'warning'; 156199"];
4553 [label="FullWidth = this.Text.Length; 156200"];
4554 [label="FullWidth 156201"];
4555 [label="this.AdjustFlagsAndWidth(trailing); 156202"];
4556 [label="return 'warning'; 156203"];
4557 [label="FullWidth = this.Text.Length; 156204"];
4558 [label="FullWidth 156205"];
4559 [label="this.AdjustFlagsAndWidth(trailing); 156206"];
4560 [label="return 'error'; 156207"];
4561 [label="FullWidth = this.Text.Length; 156208"];
4562 [label="FullWidth 156209"];
4563 [label="return 'error'; 156210"];
4564 [label="FullWidth = this.Text.Length; 156211"];
4565 [label="FullWidth 156212"];
4566 [label="this.AdjustFlagsAndWidth(leading); 156213"];
4567 [label="return 'error'; 156214"];
4568 [label="FullWidth = this.Text.Length; 156215"];
4569 [label="FullWidth 156216"];
4570 [label="this.AdjustFlagsAndWidth(trailing); 156217"];
4571 [label="return 'error'; 156218"];
4572 [label="FullWidth = this.Text.Length; 156219"];
4573 [label="FullWidth 156220"];
4574 [label="this.AdjustFlagsAndWidth(trailing); 156221"];
4575 [label="return 'line'; 156222"];
4576 [label="FullWidth = this.Text.Length; 156223"];
4577 [label="FullWidth 156224"];
4578 [label="return 'line'; 156225"];
4579 [label="FullWidth = this.Text.Length; 156226"];
4580 [label="FullWidth 156227"];
4581 [label="this.AdjustFlagsAndWidth(leading); 156228"];
4582 [label="return 'line'; 156229"];
4583 [label="FullWidth = this.Text.Length; 156230"];
4584 [label="FullWidth 156231"];
4585 [label="this.AdjustFlagsAndWidth(trailing); 156232"];
4586 [label="return 'line'; 156233"];
4587 [label="FullWidth = this.Text.Length; 156234"];
4588 [label="FullWidth 156235"];
4589 [label="this.AdjustFlagsAndWidth(trailing); 156236"];
4590 [label="return 'pragma'; 156237"];
4591 [label="FullWidth = this.Text.Length; 156238"];
4592 [label="FullWidth 156239"];
4593 [label="return 'pragma'; 156240"];
4594 [label="FullWidth = this.Text.Length; 156241"];
4595 [label="FullWidth 156242"];
4596 [label="this.AdjustFlagsAndWidth(leading); 156243"];
4597 [label="return 'pragma'; 156244"];
4598 [label="FullWidth = this.Text.Length; 156245"];
4599 [label="FullWidth 156246"];
4600 [label="this.AdjustFlagsAndWidth(trailing); 156247"];
4601 [label="return 'pragma'; 156248"];
4602 [label="FullWidth = this.Text.Length; 156249"];
4603 [label="FullWidth 156250"];
4604 [label="this.AdjustFlagsAndWidth(trailing); 156251"];
4605 [label="return 'hidden'; 156252"];
4606 [label="FullWidth = this.Text.Length; 156253"];
4607 [label="FullWidth 156254"];
4608 [label="return 'hidden'; 156255"];
4609 [label="FullWidth = this.Text.Length; 156256"];
4610 [label="FullWidth 156257"];
4611 [label="this.AdjustFlagsAndWidth(leading); 156258"];
4612 [label="return 'hidden'; 156259"];
4613 [label="FullWidth = this.Text.Length; 156260"];
4614 [label="FullWidth 156261"];
4615 [label="this.AdjustFlagsAndWidth(trailing); 156262"];
4616 [label="return 'hidden'; 156263"];
4617 [label="FullWidth = this.Text.Length; 156264"];
4618 [label="FullWidth 156265"];
4619 [label="this.AdjustFlagsAndWidth(trailing); 156266"];
4620 [label="return 'checksum'; 156267"];
4621 [label="FullWidth = this.Text.Length; 156268"];
4622 [label="FullWidth 156269"];
4623 [label="return 'checksum'; 156270"];
4624 [label="FullWidth = this.Text.Length; 156271"];
4625 [label="FullWidth 156272"];
4626 [label="this.AdjustFlagsAndWidth(leading); 156273"];
4627 [label="return 'checksum'; 156274"];
4628 [label="FullWidth = this.Text.Length; 156275"];
4629 [label="FullWidth 156276"];
4630 [label="this.AdjustFlagsAndWidth(trailing); 156277"];
4631 [label="return 'checksum'; 156278"];
4632 [label="FullWidth = this.Text.Length; 156279"];
4633 [label="FullWidth 156280"];
4634 [label="this.AdjustFlagsAndWidth(trailing); 156281"];
4635 [label="return 'disable'; 156282"];
4636 [label="FullWidth = this.Text.Length; 156283"];
4637 [label="FullWidth 156284"];
4638 [label="return 'disable'; 156285"];
4639 [label="FullWidth = this.Text.Length; 156286"];
4640 [label="FullWidth 156287"];
4641 [label="this.AdjustFlagsAndWidth(leading); 156288"];
4642 [label="return 'disable'; 156289"];
4643 [label="FullWidth = this.Text.Length; 156290"];
4644 [label="FullWidth 156291"];
4645 [label="this.AdjustFlagsAndWidth(trailing); 156292"];
4646 [label="return 'disable'; 156293"];
4647 [label="FullWidth = this.Text.Length; 156294"];
4648 [label="FullWidth 156295"];
4649 [label="this.AdjustFlagsAndWidth(trailing); 156296"];
4650 [label="return 'restore'; 156297"];
4651 [label="FullWidth = this.Text.Length; 156298"];
4652 [label="FullWidth 156299"];
4653 [label="return 'restore'; 156300"];
4654 [label="FullWidth = this.Text.Length; 156301"];
4655 [label="FullWidth 156302"];
4656 [label="this.AdjustFlagsAndWidth(leading); 156303"];
4657 [label="return 'restore'; 156304"];
4658 [label="FullWidth = this.Text.Length; 156305"];
4659 [label="FullWidth 156306"];
4660 [label="this.AdjustFlagsAndWidth(trailing); 156307"];
4661 [label="return 'restore'; 156308"];
4662 [label="FullWidth = this.Text.Length; 156309"];
4663 [label="FullWidth 156310"];
4664 [label="this.AdjustFlagsAndWidth(trailing); 156311"];
4665 [label="return 'r'; 156312"];
4666 [label="FullWidth = this.Text.Length; 156313"];
4667 [label="FullWidth 156314"];
4668 [label="return 'r'; 156315"];
4669 [label="FullWidth = this.Text.Length; 156316"];
4670 [label="FullWidth 156317"];
4671 [label="this.AdjustFlagsAndWidth(leading); 156318"];
4672 [label="return 'r'; 156319"];
4673 [label="FullWidth = this.Text.Length; 156320"];
4674 [label="FullWidth 156321"];
4675 [label="this.AdjustFlagsAndWidth(trailing); 156322"];
4676 [label="return 'r'; 156323"];
4677 [label="FullWidth = this.Text.Length; 156324"];
4678 [label="FullWidth 156325"];
4679 [label="this.AdjustFlagsAndWidth(trailing); 156326"];
4680 [label="return '$\\''; 156327"];
4681 [label="FullWidth = this.Text.Length; 156328"];
4682 [label="FullWidth 156329"];
4683 [label="return '$\\''; 156330"];
4684 [label="FullWidth = this.Text.Length; 156331"];
4685 [label="FullWidth 156332"];
4686 [label="this.AdjustFlagsAndWidth(leading); 156333"];
4687 [label="return '$\\''; 156334"];
4688 [label="FullWidth = this.Text.Length; 156335"];
4689 [label="FullWidth 156336"];
4690 [label="this.AdjustFlagsAndWidth(trailing); 156337"];
4691 [label="return '$\\''; 156338"];
4692 [label="FullWidth = this.Text.Length; 156339"];
4693 [label="FullWidth 156340"];
4694 [label="this.AdjustFlagsAndWidth(trailing); 156341"];
4695 [label="return '\\''; 156342"];
4696 [label="FullWidth = this.Text.Length; 156343"];
4697 [label="FullWidth 156344"];
4698 [label="return '\\''; 156345"];
4699 [label="FullWidth = this.Text.Length; 156346"];
4700 [label="FullWidth 156347"];
4701 [label="this.AdjustFlagsAndWidth(leading); 156348"];
4702 [label="return '\\''; 156349"];
4703 [label="FullWidth = this.Text.Length; 156350"];
4704 [label="FullWidth 156351"];
4705 [label="this.AdjustFlagsAndWidth(trailing); 156352"];
4706 [label="return '\\''; 156353"];
4707 [label="FullWidth = this.Text.Length; 156354"];
4708 [label="FullWidth 156355"];
4709 [label="this.AdjustFlagsAndWidth(trailing); 156356"];
4710 [label="return '$@\\''; 156357"];
4711 [label="FullWidth = this.Text.Length; 156358"];
4712 [label="FullWidth 156359"];
4713 [label="return '$@\\''; 156360"];
4714 [label="FullWidth = this.Text.Length; 156361"];
4715 [label="FullWidth 156362"];
4716 [label="this.AdjustFlagsAndWidth(leading); 156363"];
4717 [label="return '$@\\''; 156364"];
4718 [label="FullWidth = this.Text.Length; 156365"];
4719 [label="FullWidth 156366"];
4720 [label="this.AdjustFlagsAndWidth(trailing); 156367"];
4721 [label="return '$@\\''; 156368"];
4722 [label="FullWidth = this.Text.Length; 156369"];
4723 [label="FullWidth 156370"];
4724 [label="this.AdjustFlagsAndWidth(trailing); 156371"];
4725 [label="return 'load'; 156372"];
4726 [label="FullWidth = this.Text.Length; 156373"];
4727 [label="FullWidth 156374"];
4728 [label="return 'load'; 156375"];
4729 [label="FullWidth = this.Text.Length; 156376"];
4730 [label="FullWidth 156377"];
4731 [label="this.AdjustFlagsAndWidth(leading); 156378"];
4732 [label="return 'load'; 156379"];
4733 [label="FullWidth = this.Text.Length; 156380"];
4734 [label="FullWidth 156381"];
4735 [label="this.AdjustFlagsAndWidth(trailing); 156382"];
4736 [label="return 'load'; 156383"];
4737 [label="FullWidth = this.Text.Length; 156384"];
4738 [label="FullWidth 156385"];
4739 [label="this.AdjustFlagsAndWidth(trailing); 156386"];
4740 [label="return 'nullable'; 156387"];
4741 [label="FullWidth = this.Text.Length; 156388"];
4742 [label="FullWidth 156389"];
4743 [label="return 'nullable'; 156390"];
4744 [label="FullWidth = this.Text.Length; 156391"];
4745 [label="FullWidth 156392"];
4746 [label="this.AdjustFlagsAndWidth(leading); 156393"];
4747 [label="return 'nullable'; 156394"];
4748 [label="FullWidth = this.Text.Length; 156395"];
4749 [label="FullWidth 156396"];
4750 [label="this.AdjustFlagsAndWidth(trailing); 156397"];
4751 [label="return 'nullable'; 156398"];
4752 [label="FullWidth = this.Text.Length; 156399"];
4753 [label="FullWidth 156400"];
4754 [label="this.AdjustFlagsAndWidth(trailing); 156401"];
4755 [label="return 'enable'; 156402"];
4756 [label="FullWidth = this.Text.Length; 156403"];
4757 [label="FullWidth 156404"];
4758 [label="return 'enable'; 156405"];
4759 [label="FullWidth = this.Text.Length; 156406"];
4760 [label="FullWidth 156407"];
4761 [label="this.AdjustFlagsAndWidth(leading); 156408"];
4762 [label="return 'enable'; 156409"];
4763 [label="FullWidth = this.Text.Length; 156410"];
4764 [label="FullWidth 156411"];
4765 [label="this.AdjustFlagsAndWidth(trailing); 156412"];
4766 [label="return 'enable'; 156413"];
4767 [label="FullWidth = this.Text.Length; 156414"];
4768 [label="FullWidth 156415"];
4769 [label="this.AdjustFlagsAndWidth(trailing); 156416"];
4770 [label="return 'warnings'; 156417"];
4771 [label="FullWidth = this.Text.Length; 156418"];
4772 [label="FullWidth 156419"];
4773 [label="return 'warnings'; 156420"];
4774 [label="FullWidth = this.Text.Length; 156421"];
4775 [label="FullWidth 156422"];
4776 [label="this.AdjustFlagsAndWidth(leading); 156423"];
4777 [label="return 'warnings'; 156424"];
4778 [label="FullWidth = this.Text.Length; 156425"];
4779 [label="FullWidth 156426"];
4780 [label="this.AdjustFlagsAndWidth(trailing); 156427"];
4781 [label="return 'warnings'; 156428"];
4782 [label="FullWidth = this.Text.Length; 156429"];
4783 [label="FullWidth 156430"];
4784 [label="this.AdjustFlagsAndWidth(trailing); 156431"];
4785 [label="return 'annotations'; 156432"];
4786 [label="FullWidth = this.Text.Length; 156433"];
4787 [label="FullWidth 156434"];
4788 [label="return 'annotations'; 156435"];
4789 [label="FullWidth = this.Text.Length; 156436"];
4790 [label="FullWidth 156437"];
4791 [label="this.AdjustFlagsAndWidth(leading); 156438"];
4792 [label="return 'annotations'; 156439"];
4793 [label="FullWidth = this.Text.Length; 156440"];
4794 [label="FullWidth 156441"];
4795 [label="this.AdjustFlagsAndWidth(trailing); 156442"];
4796 [label="return 'annotations'; 156443"];
4797 [label="FullWidth = this.Text.Length; 156444"];
4798 [label="FullWidth 156445"];
4799 [label="this.AdjustFlagsAndWidth(trailing); 156446"];
4800 [label="return 'var'; 156447"];
4801 [label="FullWidth = this.Text.Length; 156448"];
4802 [label="FullWidth 156449"];
4803 [label="return 'var'; 156450"];
4804 [label="FullWidth = this.Text.Length; 156451"];
4805 [label="FullWidth 156452"];
4806 [label="this.AdjustFlagsAndWidth(leading); 156453"];
4807 [label="return 'var'; 156454"];
4808 [label="FullWidth = this.Text.Length; 156455"];
4809 [label="FullWidth 156456"];
4810 [label="this.AdjustFlagsAndWidth(trailing); 156457"];
4811 [label="return 'var'; 156458"];
4812 [label="FullWidth = this.Text.Length; 156459"];
4813 [label="FullWidth 156460"];
4814 [label="this.AdjustFlagsAndWidth(trailing); 156461"];
4815 [label="return '_'; 156462"];
4816 [label="FullWidth = this.Text.Length; 156463"];
4817 [label="FullWidth 156464"];
4818 [label="return '_'; 156465"];
4819 [label="FullWidth = this.Text.Length; 156466"];
4820 [label="FullWidth 156467"];
4821 [label="this.AdjustFlagsAndWidth(leading); 156468"];
4822 [label="return '_'; 156469"];
4823 [label="FullWidth = this.Text.Length; 156470"];
4824 [label="FullWidth 156471"];
4825 [label="this.AdjustFlagsAndWidth(trailing); 156472"];
4826 [label="return '_'; 156473"];
4827 [label="FullWidth = this.Text.Length; 156474"];
4828 [label="FullWidth 156475"];
4829 [label="this.AdjustFlagsAndWidth(trailing); 156476"];
4830 [label="return SyntaxToken.Create(kind, leading, trailing); 156477"];
4831 [label="return SyntaxToken.Create(kind, leading, trailing); 156478"];
4832 [label="return SyntaxToken.Create(kind, leading, trailing); 156479"];
4833 [label="SyntaxToken.Create(kind, leading, trailing) 156480"];
4834 [label="param Create(SyntaxKind kind) 156481"];
4835 [label="param Create(GreenNode leading) 156482"];
4836 [label="param Create(GreenNode trailing) 156483"];
4837 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 156484"];
4838 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 156485"];
4839 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 156486"];
4840 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 156487"];
4841 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 156488"];
4842 [label="if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 156489"];
4843 [label="return s_tokensWithSingleTrailingSpace[(int)kind].Value; 156490"];
4844 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 156491"];
4845 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 156492"];
4846 [label="return token; 156493"];
4847 [label="this.AddLexedToken(token); 156494"];
4848 [label="this.AddLexedToken(token) 156495"];
4849 [label="param AddLexedToken(SyntaxToken token) 156496"];
4850 [label="param AddLexedToken(this) 156497"];
4851 [label="Debug.Assert(token != null); 156498"];
4852 [label="Debug.Assert(token != null); 156499"];
4853 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 156500"];
4854 [label="_lexedTokens[_tokenCount].Value = token; 156501"];
4855 [label="_lexedTokens[_tokenCount].Value 156502"];
4856 [label="_tokenCount 156503"];
4857 [label="this.AddLexedToken(token); 156504"];
4858 [label="token.Kind 156505"];
4859 [label="get { return (SyntaxKind)this.RawKind; } 156506"];
4860 [label="return (SyntaxKind)this.RawKind; 156507"];
4861 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 156508"];
4862 [label="TextWindow.Start(); 156509"];
4863 [label="get\n            {\n                return _lexemeStart;\n            } 156510"];
4864 [label="return _lexemeStart; 156511"];
4865 [label="param LookupToken(char[] textBuffer) 156512"];
4866 [label="param LookupToken(int keyStart) 156513"];
4867 [label="param LookupToken(int keyLength) 156514"];
4868 [label="param LookupToken(int hashCode) 156515"];
4869 [label="param LookupToken(Func<SyntaxToken> createTokenFunction) 156516"];
4870 [label="param LookupToken(this) 156517"];
4871 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 156518"];
4872 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 156519"];
4873 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 156520"];
4874 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 156521"];
4875 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 156522"];
4876 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 156523"];
4877 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 156524"];
4878 [label="value = createTokenFunction(); 156525"];
4879 [label="value = createTokenFunction(); 156526"];
4880 [label="param CreateQuickToken(this) 156527"];
4881 [label="TextWindow.Width 156528"];
4882 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 156529"];
4883 [label="var quickWidth = TextWindow.Width; 156530"];
4884 [label="TextWindow.LexemeStartPosition 156531"];
4885 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 156532"];
4886 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 156533"];
4887 [label="TextWindow.Reset(TextWindow.LexemeStartPosition) 156534"];
4888 [label="param Reset(int position) 156535"];
4889 [label="param Reset(this) 156536"];
4890 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 156537"];
4891 [label="this.LexSyntaxToken() 156538"];
4892 [label="param LexSyntaxToken(this) 156539"];
4893 [label="_leadingTriviaCache.Clear(); 156540"];
4894 [label="TextWindow.Position 156541"];
4895 [label="get\n            {\n                return _basis + _offset;\n            } 156542"];
4896 [label="param LexSyntaxTrivia(bool afterFirstToken) 156543"];
4897 [label="param LexSyntaxTrivia(bool isTrailing) 156544"];
4898 [label="bool onlyWhitespaceOnLine = !isTrailing; 156545"];
4899 [label="TextWindow.Start(); 156546"];
4900 [label="this.Start(); 156547"];
4901 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 156548"];
4902 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 156549"];
4903 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 156550"];
4904 [label="return; 156551"];
4905 [label="this.Start(); 156552"];
4906 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156553"];
4907 [label="GetFullWidth(leading) 156554"];
4908 [label="param GetFullWidth(SyntaxListBuilder builder) 156555"];
4909 [label="int width = 0; 156556"];
4910 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 156557"];
4911 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 156558"];
4912 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 156559"];
4913 [label="return width; 156560"];
4914 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156561"];
4915 [label="this.GetErrors(GetFullWidth(leading)) 156562"];
4916 [label="param GetErrors(int leadingTriviaWidth) 156563"];
4917 [label="param GetErrors(this) 156564"];
4918 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 156565"];
4919 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 156566"];
4920 [label="return null; 156567"];
4921 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156568"];
4922 [label="param LexSyntaxTrivia(bool afterFirstToken) 156569"];
4923 [label="param Create(ref TokenInfo info) 156570"];
4924 [label="param Create(SyntaxDiagnosticInfo[] errors) 156571"];
4925 [label="param Create(this) 156572"];
4926 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 156573"];
4927 [label="SyntaxToken token; 156574"];
4928 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 156575"];
4929 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 156576"];
4930 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 156577"];
4931 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 156578"];
4932 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 156579"];
4933 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 156580"];
4934 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 156581"];
4935 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 156582"];
4936 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 156583"];
4937 [label="param Token(GreenNode leading) 156584"];
4938 [label="param Token(SyntaxKind kind) 156585"];
4939 [label="param Token(GreenNode trailing) 156586"];
4940 [label="return SyntaxToken.Create(kind, leading, trailing); 156587"];
4941 [label="return SyntaxToken.Create(kind, leading, trailing); 156588"];
4942 [label="return SyntaxToken.Create(kind, leading, trailing); 156589"];
4943 [label="SyntaxToken.Create(kind, leading, trailing) 156590"];
4944 [label="param Create(SyntaxKind kind) 156591"];
4945 [label="param Create(GreenNode leading) 156592"];
4946 [label="param Create(GreenNode trailing) 156593"];
4947 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 156594"];
4948 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 156595"];
4949 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 156596"];
4950 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 156597"];
4951 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 156598"];
4952 [label="return s_tokensWithNoTrivia[(int)kind].Value; 156599"];
4953 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 156600"];
4954 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 156601"];
4955 [label="return token; 156602"];
4956 [label="var token = this.LexSyntaxToken(); 156603"];
4957 [label="Debug.Assert(quickWidth == token.FullWidth); 156604"];
4958 [label="return token; 156605"];
4959 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 156606"];
4960 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 156607"];
4961 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 156608"];
4962 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 156609"];
4963 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 156610"];
4964 [label="return value; 156611"];
4965 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 156612"];
4966 [label="this.AddLexedToken(token); 156613"];
4967 [label="param AddLexedToken(SyntaxToken token) 156614"];
4968 [label="Debug.Assert(token != null); 156615"];
4969 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 156616"];
4970 [label="_lexedTokens[_tokenCount].Value = token; 156617"];
4971 [label="_lexedTokens[_tokenCount].Value 156618"];
4972 [label="get { return (SyntaxKind)this.RawKind; } 156619"];
4973 [label="return (SyntaxKind)this.RawKind; 156620"];
4974 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 156621"];
4975 [label="TextWindow.Start(); 156622"];
4976 [label="TextWindow.Width 156623"];
4977 [label="var quickWidth = TextWindow.Width; 156624"];
4978 [label="TextWindow.Position 156625"];
4979 [label="param LexSyntaxTrivia(bool afterFirstToken) 156626"];
4980 [label="param LexSyntaxTrivia(bool isTrailing) 156627"];
4981 [label="bool onlyWhitespaceOnLine = !isTrailing; 156628"];
4982 [label="this.Start(); 156629"];
4983 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 156630"];
4984 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 156631"];
4985 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 156632"];
4986 [label="return; 156633"];
4987 [label="this.Start(); 156634"];
4988 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 156635"];
4989 [label="param TryGetKeywordKind(out SyntaxKind kind) 156636"];
4990 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 156637"];
4991 [label="return SyntaxKind.None; 156638"];
4992 [label="param GetContextualKeywordKind(string text) 156639"];
4993 [label="switch (text)\n            {\n                case 'yield':\n                    return SyntaxKind.YieldKeyword;\n                case 'partial':\n                    return SyntaxKind.PartialKeyword;\n                case 'from':\n                    return SyntaxKind.FromKeyword;\n                case 'group':\n                    return SyntaxKind.GroupKeyword;\n                case 'join':\n                    return SyntaxKind.JoinKeyword;\n                case 'into':\n                    return SyntaxKind.IntoKeyword;\n                case 'let':\n                    return SyntaxKind.LetKeyword;\n                case 'by':\n                    return SyntaxKind.ByKeyword;\n                case 'where':\n                    return SyntaxKind.WhereKeyword;\n                case 'select':\n                    return SyntaxKind.SelectKeyword;\n                case 'get':\n                    return SyntaxKind.GetKeyword;\n                case 'set':\n                    return SyntaxKind.SetKeyword;\n                case 'add':\n                    return SyntaxKind.AddKeyword;\n                case 'remove':\n                    return SyntaxKind.RemoveKeyword;\n                case 'orderby':\n                    return SyntaxKind.OrderByKeyword;\n                case 'alias':\n                    return SyntaxKind.AliasKeyword;\n                case 'on':\n                    return SyntaxKind.OnKeyword;\n                case 'equals':\n                    return SyntaxKind.EqualsKeyword;\n                case 'ascending':\n                    return SyntaxKind.AscendingKeyword;\n                case 'descending':\n                    return SyntaxKind.DescendingKeyword;\n                case 'assembly':\n                    return SyntaxKind.AssemblyKeyword;\n                case 'module':\n                    return SyntaxKind.ModuleKeyword;\n                case 'type':\n                    return SyntaxKind.TypeKeyword;\n                case 'field':\n                    return SyntaxKind.FieldKeyword;\n                case 'method':\n                    return SyntaxKind.MethodKeyword;\n                case 'param':\n                    return SyntaxKind.ParamKeyword;\n                case 'property':\n                    return SyntaxKind.PropertyKeyword;\n                case 'typevar':\n                    return SyntaxKind.TypeVarKeyword;\n                case 'global':\n                    return SyntaxKind.GlobalKeyword;\n                case 'async':\n                    return SyntaxKind.AsyncKeyword;\n                case 'await':\n                    return SyntaxKind.AwaitKeyword;\n                case 'when':\n                    return SyntaxKind.WhenKeyword;\n                case 'nameof':\n                    return SyntaxKind.NameOfKeyword;\n                case '_':\n                    return SyntaxKind.UnderscoreToken;\n                case 'var':\n                    return SyntaxKind.VarKeyword;\n                case 'and':\n                    return SyntaxKind.AndKeyword;\n                case 'or':\n                    return SyntaxKind.OrKeyword;\n                case 'not':\n                    return SyntaxKind.NotKeyword;\n                case 'data':\n                    return SyntaxKind.DataKeyword;\n                case 'with':\n                    return SyntaxKind.WithKeyword;\n                case 'init':\n                    return SyntaxKind.InitKeyword;\n                case 'record':\n                    return SyntaxKind.RecordKeyword;\n                case 'managed':\n                    return SyntaxKind.ManagedKeyword;\n                case 'unmanaged':\n                    return SyntaxKind.UnmanagedKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 156640"];
4994 [label="return SyntaxKind.None; 156641"];
4995 [label="kind = _keywordKindMap.GetOrMakeValue(key); 156642"];
4996 [label="return kind != SyntaxKind.None; 156643"];
4997 [label="info.Kind 156644"];
4998 [label="info.ContextualKind 156645"];
4999 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 156646"];
5000 [label="this.ScanSyntaxToken(ref tokenInfo); 156647"];
5001 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156648"];
5002 [label="GetFullWidth(leading) 156649"];
5003 [label="param GetFullWidth(SyntaxListBuilder builder) 156650"];
5004 [label="int width = 0; 156651"];
5005 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 156652"];
5006 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 156653"];
5007 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 156654"];
5008 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 156655"];
5009 [label="return width; 156656"];
5010 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156657"];
5011 [label="this.GetErrors(GetFullWidth(leading)) 156658"];
5012 [label="param GetErrors(int leadingTriviaWidth) 156659"];
5013 [label="param GetErrors(this) 156660"];
5014 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 156661"];
5015 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 156662"];
5016 [label="return null; 156663"];
5017 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156664"];
5018 [label="param LexSyntaxTrivia(bool afterFirstToken) 156665"];
5019 [label="param LexSyntaxTrivia(bool isTrailing) 156666"];
5020 [label="bool onlyWhitespaceOnLine = !isTrailing; 156667"];
5021 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 156668"];
5022 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 156669"];
5023 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 156670"];
5024 [label="return; 156671"];
5025 [label="param Create(SyntaxDiagnosticInfo[] errors) 156672"];
5026 [label="param Create(this) 156673"];
5027 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 156674"];
5028 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 156675"];
5029 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 156676"];
5030 [label="SyntaxToken token; 156677"];
5031 [label="token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode); 156678"];
5032 [label="SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode) 156679"];
5033 [label="param Identifier(SyntaxKind contextualKind) 156680"];
5034 [label="param Identifier(GreenNode leading) 156681"];
5035 [label="param Identifier(string text) 156682"];
5036 [label="param Identifier(string valueText) 156683"];
5037 [label="param Identifier(GreenNode trailing) 156684"];
5038 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 156685"];
5039 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 156686"];
5040 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 156687"];
5041 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 156688"];
5042 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 156689"];
5043 [label="SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing) 156690"];
5044 [label="param Identifier(SyntaxKind contextualKind) 156691"];
5045 [label="param Identifier(GreenNode leading) 156692"];
5046 [label="param Identifier(string text) 156693"];
5047 [label="param Identifier(string valueText) 156694"];
5048 [label="param Identifier(GreenNode trailing) 156695"];
5049 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 156696"];
5050 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 156697"];
5051 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 156698"];
5052 [label="return Identifier(leading, text, trailing); 156699"];
5053 [label="return Identifier(leading, text, trailing); 156700"];
5054 [label="return Identifier(leading, text, trailing); 156701"];
5055 [label="Identifier(leading, text, trailing) 156702"];
5056 [label="param Identifier(GreenNode leading) 156703"];
5057 [label="param Identifier(string text) 156704"];
5058 [label="param Identifier(GreenNode trailing) 156705"];
5059 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 156706"];
5060 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 156707"];
5061 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 156708"];
5062 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 156709"];
5063 [label="return Identifier(text); 156710"];
5064 [label="Identifier(text) 156711"];
5065 [label="param Identifier(string text) 156712"];
5066 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifier), r => new SyntaxIdentifier(r)); 156713"];
5067 [label="return new SyntaxIdentifier(text); 156714"];
5068 [label="return new SyntaxIdentifier(text); 156715"];
5069 [label="new SyntaxIdentifier(text) 156716"];
5070 [label="param SyntaxIdentifier(string text) 156717"];
5071 [label="param SyntaxIdentifier(this) 156718"];
5072 [label="SyntaxKind.IdentifierToken 156719"];
5073 [label="text 156720"];
5074 [label="param SyntaxIdentifier(this) 156721"];
5075 [label="param SyntaxToken(SyntaxKind kind) 156722"];
5076 [label="param SyntaxToken(int fullWidth) 156723"];
5077 [label="param SyntaxToken(this) 156724"];
5078 [label="kind 156725"];
5079 [label="fullWidth 156726"];
5080 [label="param SyntaxToken(this) 156727"];
5081 [label="param CSharpSyntaxNode(SyntaxKind kind) 156728"];
5082 [label="param CSharpSyntaxNode(int fullWidth) 156729"];
5083 [label="param CSharpSyntaxNode(this) 156730"];
5084 [label="kind 156731"];
5085 [label="fullWidth 156732"];
5086 [label="param CSharpSyntaxNode(this) 156733"];
5087 [label="param CSharpSyntaxNode(this) 156734"];
5088 [label="GreenStats.NoteGreen(this); 156735"];
5089 [label="GreenStats.NoteGreen(this); 156736"];
5090 [label="this.flags |= NodeFlags.IsNotMissing; 156737"];
5091 [label="this.flags 156738"];
5092 [label="TextField 156739"];
5093 [label="this.TextField 156740"];
5094 [label="return Identifier(text); 156741"];
5095 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 156742"];
5096 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 156743"];
5097 [label="Debug.Assert(quickWidth == token.FullWidth); 156744"];
5098 [label="value = createTokenFunction(); 156745"];
5099 [label="this.AddLexedToken(token); 156746"];
5100 [label="param AddLexedToken(SyntaxToken token) 156747"];
5101 [label="Debug.Assert(token != null); 156748"];
5102 [label="_lexedTokens[_tokenCount].Value 156749"];
5103 [label="get { return (SyntaxKind)this.RawKind; } 156750"];
5104 [label="return (SyntaxKind)this.RawKind; 156751"];
5105 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 156752"];
5106 [label="TextWindow.Start(); 156753"];
5107 [label="TextWindow.Width 156754"];
5108 [label="var quickWidth = TextWindow.Width; 156755"];
5109 [label="param LexSyntaxTrivia(bool afterFirstToken) 156756"];
5110 [label="param LexSyntaxTrivia(bool isTrailing) 156757"];
5111 [label="bool onlyWhitespaceOnLine = !isTrailing; 156758"];
5112 [label="this.Start(); 156759"];
5113 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 156760"];
5114 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 156761"];
5115 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 156762"];
5116 [label="return; 156763"];
5117 [label="this.Start(); 156764"];
5118 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156765"];
5119 [label="GetFullWidth(leading) 156766"];
5120 [label="param GetFullWidth(SyntaxListBuilder builder) 156767"];
5121 [label="int width = 0; 156768"];
5122 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 156769"];
5123 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 156770"];
5124 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 156771"];
5125 [label="return width; 156772"];
5126 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156773"];
5127 [label="this.GetErrors(GetFullWidth(leading)) 156774"];
5128 [label="param GetErrors(int leadingTriviaWidth) 156775"];
5129 [label="param GetErrors(this) 156776"];
5130 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 156777"];
5131 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 156778"];
5132 [label="return null; 156779"];
5133 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156780"];
5134 [label="param AddTrivia(this) 156781"];
5135 [label="this.HasErrors 156782"];
5136 [label="get { return _errors != null; } 156783"];
5137 [label="return _errors != null; 156784"];
5138 [label="return _errors != null; 156785"];
5139 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 156786"];
5140 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 156787"];
5141 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 156788"];
5142 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 156789"];
5143 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 156790"];
5144 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 156791"];
5145 [label="return; 156792"];
5146 [label="param Create(SyntaxDiagnosticInfo[] errors) 156793"];
5147 [label="param Create(this) 156794"];
5148 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 156795"];
5149 [label="SyntaxToken token; 156796"];
5150 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 156797"];
5151 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 156798"];
5152 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 156799"];
5153 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 156800"];
5154 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 156801"];
5155 [label="if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 156802"];
5156 [label="return s_tokensWithSingleTrailingSpace[(int)kind].Value; 156803"];
5157 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 156804"];
5158 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 156805"];
5159 [label="Debug.Assert(quickWidth == token.FullWidth); 156806"];
5160 [label="this.AddLexedToken(token); 156807"];
5161 [label="param AddLexedToken(SyntaxToken token) 156808"];
5162 [label="Debug.Assert(token != null); 156809"];
5163 [label="_lexedTokens[_tokenCount].Value 156810"];
5164 [label="get { return (SyntaxKind)this.RawKind; } 156811"];
5165 [label="return (SyntaxKind)this.RawKind; 156812"];
5166 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 156813"];
5167 [label="TextWindow.Start(); 156814"];
5168 [label="var quickWidth = TextWindow.Width; 156815"];
5169 [label="param LexSyntaxTrivia(bool afterFirstToken) 156816"];
5170 [label="param LexSyntaxTrivia(bool isTrailing) 156817"];
5171 [label="bool onlyWhitespaceOnLine = !isTrailing; 156818"];
5172 [label="this.Start(); 156819"];
5173 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 156820"];
5174 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 156821"];
5175 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 156822"];
5176 [label="return; 156823"];
5177 [label="this.Start(); 156824"];
5178 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156825"];
5179 [label="GetFullWidth(leading) 156826"];
5180 [label="param GetFullWidth(SyntaxListBuilder builder) 156827"];
5181 [label="int width = 0; 156828"];
5182 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 156829"];
5183 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 156830"];
5184 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 156831"];
5185 [label="return width; 156832"];
5186 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156833"];
5187 [label="this.GetErrors(GetFullWidth(leading)) 156834"];
5188 [label="param GetErrors(int leadingTriviaWidth) 156835"];
5189 [label="param GetErrors(this) 156836"];
5190 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 156837"];
5191 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 156838"];
5192 [label="return null; 156839"];
5193 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156840"];
5194 [label="param AddTrivia(this) 156841"];
5195 [label="this.HasErrors 156842"];
5196 [label="get { return _errors != null; } 156843"];
5197 [label="return _errors != null; 156844"];
5198 [label="return _errors != null; 156845"];
5199 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 156846"];
5200 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 156847"];
5201 [label="param Create(SyntaxDiagnosticInfo[] errors) 156848"];
5202 [label="param Create(this) 156849"];
5203 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 156850"];
5204 [label="SyntaxToken token; 156851"];
5205 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 156852"];
5206 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 156853"];
5207 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 156854"];
5208 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 156855"];
5209 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 156856"];
5210 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 156857"];
5211 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 156858"];
5212 [label="Debug.Assert(quickWidth == token.FullWidth); 156859"];
5213 [label="param TryGetKeywordKind(out SyntaxKind kind) 156860"];
5214 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 156861"];
5215 [label="return SyntaxKind.CaseKeyword; 156862"];
5216 [label="if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 156863"];
5217 [label="SyntaxFacts.IsContextualKeyword(info.Kind) 156864"];
5218 [label="param IsContextualKeyword(SyntaxKind kind) 156865"];
5219 [label="switch (kind)\n            {\n                case SyntaxKind.YieldKeyword:\n                case SyntaxKind.PartialKeyword:\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.LetKeyword:\n                case SyntaxKind.ByKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                case SyntaxKind.AddKeyword:\n                case SyntaxKind.RemoveKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.AliasKeyword:\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.AssemblyKeyword:\n                case SyntaxKind.ModuleKeyword:\n                case SyntaxKind.TypeKeyword:\n                case SyntaxKind.GlobalKeyword:\n                case SyntaxKind.FieldKeyword:\n                case SyntaxKind.MethodKeyword:\n                case SyntaxKind.ParamKeyword:\n                case SyntaxKind.PropertyKeyword:\n                case SyntaxKind.TypeVarKeyword:\n                case SyntaxKind.NameOfKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.AwaitKeyword:\n                case SyntaxKind.WhenKeyword:\n                case SyntaxKind.UnderscoreToken:\n                case SyntaxKind.VarKeyword:\n                case SyntaxKind.OrKeyword:\n                case SyntaxKind.AndKeyword:\n                case SyntaxKind.NotKeyword:\n                case SyntaxKind.DataKeyword:\n                case SyntaxKind.WithKeyword:\n                case SyntaxKind.InitKeyword:\n                case SyntaxKind.RecordKeyword:\n                case SyntaxKind.ManagedKeyword:\n                case SyntaxKind.UnmanagedKeyword:\n                    return true;\n                default:\n                    return false;\n            } 156866"];
5220 [label="return false; 156867"];
5221 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 156868"];
5222 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 156869"];
5223 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 156870"];
5224 [label="return null; 156871"];
5225 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156872"];
5226 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 156873"];
5227 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 156874"];
5228 [label="param AddTrivia(this) 156875"];
5229 [label="this.HasErrors 156876"];
5230 [label="get { return _errors != null; } 156877"];
5231 [label="return _errors != null; 156878"];
5232 [label="return _errors != null; 156879"];
5233 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 156880"];
5234 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 156881"];
5235 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 156882"];
5236 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 156883"];
5237 [label="return; 156884"];
5238 [label="param Create(SyntaxDiagnosticInfo[] errors) 156885"];
5239 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 156886"];
5240 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 156887"];
5241 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 156888"];
5242 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 156889"];
5243 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 156890"];
5244 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 156891"];
5245 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 156892"];
5246 [label="Debug.Assert(quickWidth == token.FullWidth); 156893"];
5247 [label="this.AddLexedToken(token); 156894"];
5248 [label="param AddLexedToken(SyntaxToken token) 156895"];
5249 [label="Debug.Assert(token != null); 156896"];
5250 [label="_lexedTokens[_tokenCount].Value 156897"];
5251 [label="get { return (SyntaxKind)this.RawKind; } 156898"];
5252 [label="return (SyntaxKind)this.RawKind; 156899"];
5253 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 156900"];
5254 [label="TextWindow.Start(); 156901"];
5255 [label="var quickWidth = TextWindow.Width; 156902"];
5256 [label="param LexSyntaxTrivia(bool afterFirstToken) 156903"];
5257 [label="param LexSyntaxTrivia(bool isTrailing) 156904"];
5258 [label="bool onlyWhitespaceOnLine = !isTrailing; 156905"];
5259 [label="this.Start(); 156906"];
5260 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 156907"];
5261 [label="return; 156908"];
5262 [label="this.Start(); 156909"];
5263 [label="param TryGetKeywordKind(out SyntaxKind kind) 156910"];
5264 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 156911"];
5265 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 156912"];
5266 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156913"];
5267 [label="GetFullWidth(leading) 156914"];
5268 [label="param GetFullWidth(SyntaxListBuilder builder) 156915"];
5269 [label="int width = 0; 156916"];
5270 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 156917"];
5271 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 156918"];
5272 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 156919"];
5273 [label="return width; 156920"];
5274 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156921"];
5275 [label="this.GetErrors(GetFullWidth(leading)) 156922"];
5276 [label="param GetErrors(int leadingTriviaWidth) 156923"];
5277 [label="param GetErrors(this) 156924"];
5278 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 156925"];
5279 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 156926"];
5280 [label="return null; 156927"];
5281 [label="var errors = this.GetErrors(GetFullWidth(leading)); 156928"];
5282 [label="param Create(SyntaxDiagnosticInfo[] errors) 156929"];
5283 [label="param Create(this) 156930"];
5284 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 156931"];
5285 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 156932"];
5286 [label="SyntaxToken token; 156933"];
5287 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 156934"];
5288 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 156935"];
5289 [label="Debug.Assert(quickWidth == token.FullWidth); 156936"];
5290 [label="return (SyntaxKind)this.RawKind; 156937"];
5291 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 156938"];
5292 [label="param AddTrivia(this) 156939"];
5293 [label="get { return _errors != null; } 156940"];
5294 [label="return _errors != null; 156941"];
5295 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 156942"];
5296 [label="this.Position 156943"];
5297 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 156944"];
5298 [label="return false; 156945"];
5299 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 156946"];
5300 [label="return InvalidCharacter; 156947"];
5301 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 156948"];
5302 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 156949"];
5303 [label="SyntaxFacts.IsWhitespace(ch) 156950"];
5304 [label="param IsWhitespace(char ch) 156951"];
5305 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 156952"];
5306 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 156953"];
5307 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 156954"];
5308 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 156955"];
5309 [label="SyntaxFacts.IsNewLine(ch) 156956"];
5310 [label="param IsNewLine(char ch) 156957"];
5311 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 156958"];
5312 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 156959"];
5313 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 156960"];
5314 [label="return; 156961"];
5315 [label="param LexSyntaxTrivia(bool afterFirstToken) 156962"];
5316 [label="param LexSyntaxTrivia(bool isTrailing) 156963"];
5317 [label="bool onlyWhitespaceOnLine = !isTrailing; 156964"];
5318 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 156965"];
5319 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 156966"];
5320 [label="return false; 156967"];
5321 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 156968"];
5322 [label="return InvalidCharacter; 156969"];
5323 [label="param IsReallyAtEnd(this) 156970"];
5324 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 156971"];
5325 [label="Position 156972"];
5326 [label="get\n            {\n                return _basis + _offset;\n            } 156973"];
5327 [label="return _basis + _offset; 156974"];
5328 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 156975"];
5329 [label="ConsList<Directive>.Empty 156976"];
5330 [label="new DirectiveStack(ConsList<Directive>.Empty) 156977"];
5331 [label="param DirectiveStack(ConsList<Directive> directives) 156978"];
5332 [label="param DirectiveStack(this) 156979"];
5333 [label="_directives 156980"];
5334 [label="Empty = new DirectiveStack(ConsList<Directive>.Empty) 156981"];
5335 [label="null 156982"];
5336 [label="new DirectiveStack(null) 156983"];
5337 [label="param DirectiveStack(ConsList<Directive> directives) 156984"];
5338 [label="param DirectiveStack(this) 156985"];
5339 [label="_directives 156986"];
5340 [label="Null = new DirectiveStack(null) 156987"];
5341 [label="param HasUnfinishedIf(this) 156988"];
5342 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 156989"];
5343 [label="GetPreviousIfElifElseOrRegion(_directives) 156990"];
5344 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 156991"];
5345 [label="var current = directives; 156992"];
5346 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 156993"];
5347 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 156994"];
5348 [label="return current; 156995"];
5349 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 156996"];
5350 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 156997"];
5351 [label="param HasUnfinishedRegion(this) 156998"];
5352 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 156999"];
5353 [label="GetPreviousIfElifElseOrRegion(_directives) 157000"];
5354 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 157001"];
5355 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 157002"];
5356 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 157003"];
5357 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 157004"];
5358 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 157005"];
5359 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157006"];
5360 [label="param GetFullWidth(SyntaxListBuilder builder) 157007"];
5361 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 157008"];
5362 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 157009"];
5363 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 157010"];
5364 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 157011"];
5365 [label="return null; 157012"];
5366 [label="var errors = this.GetErrors(GetFullWidth(leading)); 157013"];
5367 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 157014"];
5368 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 157015"];
5369 [label="SyntaxFacts.IsWhitespace(ch) 157016"];
5370 [label="param IsWhitespace(char ch) 157017"];
5371 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 157018"];
5372 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 157019"];
5373 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 157020"];
5374 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 157021"];
5375 [label="SyntaxFacts.IsNewLine(ch) 157022"];
5376 [label="param IsNewLine(char ch) 157023"];
5377 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 157024"];
5378 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 157025"];
5379 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 157026"];
5380 [label="return; 157027"];
5381 [label="param Create(SyntaxDiagnosticInfo[] errors) 157028"];
5382 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 157029"];
5383 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 157030"];
5384 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 157031"];
5385 [label="param Token(GreenNode leading) 157032"];
5386 [label="param Token(SyntaxKind kind) 157033"];
5387 [label="param Token(GreenNode trailing) 157034"];
5388 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 157035"];
5389 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 157036"];
5390 [label="this.AddLexedToken(token); 157037"];
5391 [label="param AddLexedToken(SyntaxToken token) 157038"];
5392 [label="Debug.Assert(token != null); 157039"];
5393 [label="_lexedTokens[_tokenCount].Value 157040"];
5394 [label="get { return (SyntaxKind)this.RawKind; } 157041"];
5395 [label="return (SyntaxKind)this.RawKind; 157042"];
5396 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 157043"];
5397 [label="this.PreLex(); 157044"];
5398 [label="new SyntaxListPool() 157045"];
5399 [label="_pool = new SyntaxListPool() 157046"];
5400 [label="_syntaxFactoryContext 157047"];
5401 [label="_syntaxFactory 157048"];
5402 [label="_recursionDepth 157049"];
5403 [label="_termState 157050"];
5404 [label="_isInTry 157051"];
5405 [label="_checkedTopLevelStatementsFeatureAvailability 157052"];
5406 [label="_syntaxFactoryContext = new SyntaxFactoryContext(); 157053"];
5407 [label="_syntaxFactoryContext 157054"];
5408 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 157055"];
5409 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 157056"];
5410 [label="_syntaxFactory 157057"];
5411 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 157058"];
5412 [label="parser.ParseStatement() 157059"];
5413 [label="param ParseStatement(this) 157060"];
5414 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 157061"];
5415 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 157062"];
5416 [label="ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))) 157063"];
5417 [label="param ParseWithStackGuard(Func<TNode> parseFunc) 157064"];
5418 [label="param ParseWithStackGuard(Func<TNode> createEmptyNodeFunc) 157065"];
5419 [label="param ParseWithStackGuard(this) 157066"];
5420 [label="Debug.Assert(_recursionDepth == 0); 157067"];
5421 [label="Debug.Assert(_recursionDepth == 0); 157068"];
5422 [label="return parseFunc(); 157069"];
5423 [label="return parseFunc(); 157070"];
5424 [label="=> ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 157071"];
5425 [label="ParseAttributeDeclarations() 157072"];
5426 [label="param ParseAttributeDeclarations(this) 157073"];
5427 [label="var attributes = _pool.Allocate<AttributeListSyntax>(); 157074"];
5428 [label="var saveTerm = _termState; 157075"];
5429 [label="_termState |= TerminatorState.IsAttributeDeclarationTerminator; 157076"];
5430 [label="_termState 157077"];
5431 [label="this.IsPossibleAttributeDeclaration() 157078"];
5432 [label="param IsPossibleAttributeDeclaration(this) 157079"];
5433 [label="this.CurrentToken 157080"];
5434 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157081"];
5435 [label="this.FetchCurrentToken() 157082"];
5436 [label="param FetchCurrentToken(this) 157083"];
5437 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157084"];
5438 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 157085"];
5439 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 157086"];
5440 [label="return _lexedTokens[_tokenOffset]; 157087"];
5441 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157088"];
5442 [label="_currentToken 157089"];
5443 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 157090"];
5444 [label="this.CurrentToken.Kind 157091"];
5445 [label="get { return (SyntaxKind)this.RawKind; } 157092"];
5446 [label="return (SyntaxKind)this.RawKind; 157093"];
5447 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 157094"];
5448 [label="_termState 157095"];
5449 [label="return attributes.ToList(); 157096"];
5450 [label="_pool.Free(attributes); 157097"];
5451 [label="_pool.Free(attributes); 157098"];
5452 [label="false 157099"];
5453 [label="isGlobal: false 157100"];
5454 [label="ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 157101"];
5455 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 157102"];
5456 [label="param ParseStatementCore(bool isGlobal) 157103"];
5457 [label="param ParseStatementCore(this) 157104"];
5458 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 157105"];
5459 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 157106"];
5460 [label="canReuseStatement(attributes, isGlobal) 157107"];
5461 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 157108"];
5462 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 157109"];
5463 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 157110"];
5464 [label="this.IsIncrementalAndFactoryContextMatches 157111"];
5465 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 157112"];
5466 [label="base.IsIncremental 157113"];
5467 [label="get\n            {\n                return _isIncremental;\n            } 157114"];
5468 [label="return _isIncremental; 157115"];
5469 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 157116"];
5470 [label="return false; 157117"];
5471 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 157118"];
5472 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 157119"];
5473 [label="this.GetResetPoint() 157120"];
5474 [label="param GetResetPoint(this) 157121"];
5475 [label="base.GetResetPoint() 157122"];
5476 [label="param GetResetPoint(this) 157123"];
5477 [label="CurrentTokenPosition 157124"];
5478 [label="=> _firstToken + _tokenOffset 157125"];
5479 [label="_firstToken + _tokenOffset 157126"];
5480 [label="var pos = CurrentTokenPosition; 157127"];
5481 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 157128"];
5482 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 157129"];
5483 [label="_resetStart 157130"];
5484 [label="_resetCount 157131"];
5485 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 157132"];
5486 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 157133"];
5487 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 157134"];
5488 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 157135"];
5489 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 157136"];
5490 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 157137"];
5491 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 157138"];
5492 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 157139"];
5493 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 157140"];
5494 [label="param ResetPoint(TerminatorState terminatorState) 157141"];
5495 [label="param ResetPoint(bool isInTry) 157142"];
5496 [label="param ResetPoint(bool isInAsync) 157143"];
5497 [label="param ResetPoint(int queryDepth) 157144"];
5498 [label="param ResetPoint(this) 157145"];
5499 [label="this.BaseResetPoint 157146"];
5500 [label="this.TerminatorState 157147"];
5501 [label="this.IsInTry 157148"];
5502 [label="this.IsInAsync 157149"];
5503 [label="this.QueryDepth 157150"];
5504 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 157151"];
5505 [label="_recursionDepth 157152"];
5506 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 157153"];
5507 [label="StatementSyntax result; 157154"];
5508 [label="this.CurrentToken 157155"];
5509 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157156"];
5510 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157157"];
5511 [label="switch (this.CurrentToken.Kind)\n                {\n                    case SyntaxKind.FixedKeyword:\n                        return this.ParseFixedStatement(attributes);\n                    case SyntaxKind.BreakKeyword:\n                        return this.ParseBreakStatement(attributes);\n                    case SyntaxKind.ContinueKeyword:\n                        return this.ParseContinueStatement(attributes);\n                    case SyntaxKind.TryKeyword:\n                    case SyntaxKind.CatchKeyword:\n                    case SyntaxKind.FinallyKeyword:\n                        return this.ParseTryStatement(attributes);\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                        return this.ParseCheckedStatement(attributes);\n                    case SyntaxKind.DoKeyword:\n                        return this.ParseDoStatement(attributes);\n                    case SyntaxKind.ForKeyword:\n                        return this.ParseForOrForEachStatement(attributes);\n                    case SyntaxKind.ForEachKeyword:\n                        return this.ParseForEachStatement(attributes, awaitTokenOpt: null);\n                    case SyntaxKind.GotoKeyword:\n                        return this.ParseGotoStatement(attributes);\n                    case SyntaxKind.IfKeyword:\n                        return this.ParseIfStatement(attributes);\n                    case SyntaxKind.ElseKeyword:\n                        // Including 'else' keyword to handle 'else without if' error cases \n                        return this.ParseMisplacedElse(attributes);\n                    case SyntaxKind.LockKeyword:\n                        return this.ParseLockStatement(attributes);\n                    case SyntaxKind.ReturnKeyword:\n                        return this.ParseReturnStatement(attributes);\n                    case SyntaxKind.SwitchKeyword:\n                        return this.ParseSwitchStatement(attributes);\n                    case SyntaxKind.ThrowKeyword:\n                        return this.ParseThrowStatement(attributes);\n                    case SyntaxKind.UnsafeKeyword:\n                        result = TryParseStatementStartingWithUnsafe(attributes);\n                        if (result != null)\n                            return result;\n                        break;\n                    case SyntaxKind.UsingKeyword:\n                        return ParseStatementStartingWithUsing(attributes);\n                    case SyntaxKind.WhileKeyword:\n                        return this.ParseWhileStatement(attributes);\n                    case SyntaxKind.OpenBraceToken:\n                        return this.ParseBlock(attributes);\n                    case SyntaxKind.SemicolonToken:\n                        return _syntaxFactory.EmptyStatement(attributes, this.EatToken());\n                    case SyntaxKind.IdentifierToken:\n                        result = TryParseStatementStartingWithIdentifier(attributes, isGlobal);\n                        if (result != null)\n                            return result;\n                        break;\n                } 157158"];
5512 [label="this.CurrentToken.Kind 157159"];
5513 [label="get { return (SyntaxKind)this.RawKind; } 157160"];
5514 [label="return (SyntaxKind)this.RawKind; 157161"];
5515 [label="return this.ParseSwitchStatement(attributes); 157162"];
5516 [label="this.ParseSwitchStatement(attributes) 157163"];
5517 [label="param ParseSwitchStatement(SyntaxList<AttributeListSyntax> attributes) 157164"];
5518 [label="param ParseSwitchStatement(this) 157165"];
5519 [label="this.CurrentToken 157166"];
5520 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157167"];
5521 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.SwitchKeyword); 157168"];
5522 [label="this.CurrentToken.Kind 157169"];
5523 [label="get { return (SyntaxKind)this.RawKind; } 157170"];
5524 [label="var @switch = this.EatToken(SyntaxKind.SwitchKeyword); 157171"];
5525 [label="this.EatToken(SyntaxKind.SwitchKeyword) 157172"];
5526 [label="param EatToken(SyntaxKind kind) 157173"];
5527 [label="param EatToken(this) 157174"];
5528 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 157175"];
5529 [label="SyntaxFacts.IsAnyToken(kind) 157176"];
5530 [label="param IsAnyToken(SyntaxKind kind) 157177"];
5531 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 157178"];
5532 [label="return true; 157179"];
5533 [label="this.CurrentToken 157180"];
5534 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157181"];
5535 [label="var ct = this.CurrentToken; 157182"];
5536 [label="ct.Kind 157183"];
5537 [label="get { return (SyntaxKind)this.RawKind; } 157184"];
5538 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 157185"];
5539 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 157186"];
5540 [label="MoveToNextToken() 157187"];
5541 [label="param MoveToNextToken(this) 157188"];
5542 [label="_currentToken.GetTrailingTrivia() 157189"];
5543 [label="param GetTrailingTrivia(this) 157190"];
5544 [label="return this.TrailingField; 157191"];
5545 [label="_prevTokenTrailingTrivia = _currentToken.GetTrailingTrivia(); 157192"];
5546 [label="_prevTokenTrailingTrivia 157193"];
5547 [label="_currentToken = null; 157194"];
5548 [label="_currentToken 157195"];
5549 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157196"];
5550 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157197"];
5551 [label="_tokenOffset 157198"];
5552 [label="MoveToNextToken(); 157199"];
5553 [label="return ct; 157200"];
5554 [label="this.ParseExpressionCore() 157201"];
5555 [label="param ParseExpressionCore(this) 157202"];
5556 [label="return this.ParseSubExpression(Precedence.Expression); 157203"];
5557 [label="this.ParseSubExpression(Precedence.Expression) 157204"];
5558 [label="param ParseSubExpression(Precedence precedence) 157205"];
5559 [label="param ParseSubExpression(this) 157206"];
5560 [label="_recursionDepth 157207"];
5561 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 157208"];
5562 [label="var result = ParseSubExpressionCore(precedence); 157209"];
5563 [label="ParseSubExpressionCore(precedence) 157210"];
5564 [label="param ParseSubExpressionCore(Precedence precedence) 157211"];
5565 [label="param ParseSubExpressionCore(this) 157212"];
5566 [label="ExpressionSyntax leftOperand; 157213"];
5567 [label="Precedence newPrecedence = 0; 157214"];
5568 [label="this.CurrentToken 157215"];
5569 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157216"];
5570 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157217"];
5571 [label="return _lexedTokens[_tokenOffset]; 157218"];
5572 [label="var tk = this.CurrentToken.Kind; 157219"];
5573 [label="this.CurrentToken.Kind 157220"];
5574 [label="get { return (SyntaxKind)this.RawKind; } 157221"];
5575 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 157222"];
5576 [label="IsInvalidSubExpression(tk) 157223"];
5577 [label="param IsInvalidSubExpression(SyntaxKind kind) 157224"];
5578 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 157225"];
5579 [label="return false; 157226"];
5580 [label="if (IsExpectedPrefixUnaryOperator(tk))\n            {\n                var opKind = SyntaxFacts.GetPrefixUnaryExpression(tk);\n                newPrecedence = GetPrecedence(opKind);\n                var opToken = this.EatToken();\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.PrefixUnaryExpression(opKind, opToken, operand);\n            }\n            else if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 157227"];
5581 [label="IsExpectedPrefixUnaryOperator(tk) 157228"];
5582 [label="param IsExpectedPrefixUnaryOperator(SyntaxKind kind) 157229"];
5583 [label="return SyntaxFacts.IsPrefixUnaryExpression(kind) && kind != SyntaxKind.RefKeyword && kind != SyntaxKind.OutKeyword; 157230"];
5584 [label="SyntaxFacts.IsPrefixUnaryExpression(kind) 157231"];
5585 [label="param IsPrefixUnaryExpression(SyntaxKind token) 157232"];
5586 [label="return GetPrefixUnaryExpression(token) != SyntaxKind.None; 157233"];
5587 [label="GetPrefixUnaryExpression(token) 157234"];
5588 [label="param GetPrefixUnaryExpression(SyntaxKind token) 157235"];
5589 [label="switch (token)\n            {\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.UnaryPlusExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.UnaryMinusExpression;\n                case SyntaxKind.TildeToken:\n                    return SyntaxKind.BitwiseNotExpression;\n                case SyntaxKind.ExclamationToken:\n                    return SyntaxKind.LogicalNotExpression;\n                case SyntaxKind.PlusPlusToken:\n                    return SyntaxKind.PreIncrementExpression;\n                case SyntaxKind.MinusMinusToken:\n                    return SyntaxKind.PreDecrementExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.AddressOfExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.PointerIndirectionExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.IndexExpression;\n                default:\n                    return SyntaxKind.None;\n            } 157236"];
5590 [label="return SyntaxKind.None; 157237"];
5591 [label="if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 157238"];
5592 [label="IsAwaitExpression() 157239"];
5593 [label="param IsAwaitExpression(this) 157240"];
5594 [label="this.CurrentToken 157241"];
5595 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157242"];
5596 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 157243"];
5597 [label="this.CurrentToken.ContextualKind 157244"];
5598 [label="get\n            {\n                return this.Kind;\n            } 157245"];
5599 [label="this.Kind 157246"];
5600 [label="get { return (SyntaxKind)this.RawKind; } 157247"];
5601 [label="return this.Kind; 157248"];
5602 [label="return false; 157249"];
5603 [label="if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 157250"];
5604 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 157251"];
5605 [label="this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false) 157252"];
5606 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 157253"];
5607 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 157254"];
5608 [label="param IsQueryExpression(this) 157255"];
5609 [label="this.CurrentToken 157256"];
5610 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157257"];
5611 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 157258"];
5612 [label="this.CurrentToken.ContextualKind 157259"];
5613 [label="get\n            {\n                return this.Kind;\n            } 157260"];
5614 [label="this.Kind 157261"];
5615 [label="get { return (SyntaxKind)this.RawKind; } 157262"];
5616 [label="return this.Kind; 157263"];
5617 [label="return false; 157264"];
5618 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 157265"];
5619 [label="this.CurrentToken 157266"];
5620 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 157267"];
5621 [label="this.CurrentToken.ContextualKind 157268"];
5622 [label="get\n            {\n                return this.Kind;\n            } 157269"];
5623 [label="this.Kind 157270"];
5624 [label="get { return (SyntaxKind)this.RawKind; } 157271"];
5625 [label="return this.Kind; 157272"];
5626 [label="if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 157273"];
5627 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 157274"];
5628 [label="this.IsPossibleDeconstructionLeft(precedence) 157275"];
5629 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 157276"];
5630 [label="param IsPossibleDeconstructionLeft(this) 157277"];
5631 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 157278"];
5632 [label="this.CurrentToken 157279"];
5633 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157280"];
5634 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 157281"];
5635 [label="this.CurrentToken.IsIdentifierVar() 157282"];
5636 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 157283"];
5637 [label="node.ContextualKind 157284"];
5638 [label="get\n            {\n                return this.Kind;\n            } 157285"];
5639 [label="return node.ContextualKind == SyntaxKind.VarKeyword; 157286"];
5640 [label="this.CurrentToken 157287"];
5641 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157288"];
5642 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 157289"];
5643 [label="this.CurrentToken.Kind 157290"];
5644 [label="get { return (SyntaxKind)this.RawKind; } 157291"];
5645 [label="IsPredefinedType(this.CurrentToken.Kind) 157292"];
5646 [label="param IsPredefinedType(SyntaxKind keyword) 157293"];
5647 [label="return SyntaxFacts.IsPredefinedType(keyword); 157294"];
5648 [label="SyntaxFacts.IsPredefinedType(keyword) 157295"];
5649 [label="param IsPredefinedType(SyntaxKind kind) 157296"];
5650 [label="switch (kind)\n            {\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.VoidKeyword:\n                    return true;\n                default:\n                    return false;\n            } 157297"];
5651 [label="return false; 157298"];
5652 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 157299"];
5653 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 157300"];
5654 [label="return false; 157301"];
5655 [label="leftOperand = this.ParseTerm(precedence); 157302"];
5656 [label="this.ParseTerm(precedence) 157303"];
5657 [label="param ParseTerm(Precedence precedence) 157304"];
5658 [label="=> this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 157305"];
5659 [label="precedence 157306"];
5660 [label="ParseTermWithoutPostfix(precedence) 157307"];
5661 [label="param ParseTermWithoutPostfix(Precedence precedence) 157308"];
5662 [label="param ParseTermWithoutPostfix(this) 157309"];
5663 [label="this.CurrentToken 157310"];
5664 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157311"];
5665 [label="var tk = this.CurrentToken.Kind; 157312"];
5666 [label="this.CurrentToken.Kind 157313"];
5667 [label="get { return (SyntaxKind)this.RawKind; } 157314"];
5668 [label="switch (tk)\n            {\n                case SyntaxKind.TypeOfKeyword:\n                    return this.ParseTypeOfExpression();\n                case SyntaxKind.DefaultKeyword:\n                    return this.ParseDefaultExpression();\n                case SyntaxKind.SizeOfKeyword:\n                    return this.ParseSizeOfExpression();\n                case SyntaxKind.MakeRefKeyword:\n                    return this.ParseMakeRefExpression();\n                case SyntaxKind.RefTypeKeyword:\n                    return this.ParseRefTypeExpression();\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                    return this.ParseCheckedOrUncheckedExpression();\n                case SyntaxKind.RefValueKeyword:\n                    return this.ParseRefValueExpression();\n                case SyntaxKind.ColonColonToken:\n                    // misplaced ::\n                    // Calling ParseAliasQualifiedName will cause us to create a missing identifier node that then\n                    // properly consumes the :: and the reset of the alias name afterwards.\n                    return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return this.ParseLambdaExpression();\n                case SyntaxKind.StaticKeyword:\n                    if (this.IsPossibleAnonymousMethodExpression())\n                    {\n                        return this.ParseAnonymousMethodExpression();\n                    }\n                    else if (this.IsPossibleLambdaExpression(precedence))\n                    {\n                        return this.ParseLambdaExpression();\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.IdentifierToken:\n                    if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.ThisKeyword:\n                    return _syntaxFactory.ThisExpression(this.EatToken());\n                case SyntaxKind.BaseKeyword:\n                    return ParseBaseExpression();\n\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.FalseKeyword:\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                    return _syntaxFactory.LiteralExpression(SyntaxFacts.GetLiteralExpression(tk), this.EatToken());\n                case SyntaxKind.InterpolatedStringStartToken:\n                    throw new NotImplementedException(); // this should not occur because these tokens are produced and parsed immediately\n                case SyntaxKind.InterpolatedStringToken:\n                    return this.ParseInterpolatedStringToken();\n                case SyntaxKind.OpenParenToken:\n                    return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence);\n                case SyntaxKind.NewKeyword:\n                    return this.ParseNewExpression();\n                case SyntaxKind.StackAllocKeyword:\n                    return this.ParseStackAllocExpression();\n                case SyntaxKind.DelegateKeyword:\n                    return this.ParseAnonymousMethodExpression();\n                case SyntaxKind.RefKeyword:\n                    // ref is not expected to appear in this position.\n                    return this.AddError(ParsePossibleRefExpression(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                default:\n                    // check for intrinsic type followed by '.'\n                    if (IsPredefinedType(tk))\n                    {\n                        var expr = _syntaxFactory.PredefinedType(this.EatToken());\n\n                        if (this.CurrentToken.Kind != SyntaxKind.DotToken || tk == SyntaxKind.VoidKeyword)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n                    else\n                    {\n                        var expr = this.CreateMissingIdentifierName();\n\n                        if (tk == SyntaxKind.EndOfFileToken)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_ExpressionExpected);\n                        }\n                        else\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n            } 157315"];
5669 [label="return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence); 157316"];
5670 [label="this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence) 157317"];
5671 [label="param ParseCastOrParenExpressionOrLambdaOrTuple(Precedence precedence) 157318"];
5672 [label="param ParseCastOrParenExpressionOrLambdaOrTuple(this) 157319"];
5673 [label="this.CurrentToken 157320"];
5674 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157321"];
5675 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.OpenParenToken); 157322"];
5676 [label="this.CurrentToken.Kind 157323"];
5677 [label="get { return (SyntaxKind)this.RawKind; } 157324"];
5678 [label="this.GetResetPoint() 157325"];
5679 [label="param GetResetPoint(this) 157326"];
5680 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 157327"];
5681 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 157328"];
5682 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 157329"];
5683 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 157330"];
5684 [label="param ResetPoint(TerminatorState terminatorState) 157331"];
5685 [label="param ResetPoint(bool isInTry) 157332"];
5686 [label="param ResetPoint(bool isInAsync) 157333"];
5687 [label="param ResetPoint(int queryDepth) 157334"];
5688 [label="param ResetPoint(this) 157335"];
5689 [label="this.BaseResetPoint 157336"];
5690 [label="this.TerminatorState 157337"];
5691 [label="this.IsInTry 157338"];
5692 [label="this.IsInAsync 157339"];
5693 [label="this.QueryDepth 157340"];
5694 [label="var resetPoint = this.GetResetPoint(); 157341"];
5695 [label="if (ScanParenthesizedImplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 157342"];
5696 [label="ScanParenthesizedImplicitlyTypedLambda(precedence) 157343"];
5697 [label="param ScanParenthesizedImplicitlyTypedLambda(Precedence precedence) 157344"];
5698 [label="param ScanParenthesizedImplicitlyTypedLambda(this) 157345"];
5699 [label="if (!(precedence <= Precedence.Lambda))\n            {\n                return false;\n            } 157346"];
5700 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 157347"];
5701 [label="this.PeekToken(1) 157348"];
5702 [label="param PeekToken(int n) 157349"];
5703 [label="param PeekToken(this) 157350"];
5704 [label="Debug.Assert(n >= 0); 157351"];
5705 [label="Debug.Assert(n >= 0); 157352"];
5706 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157353"];
5707 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157354"];
5708 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157355"];
5709 [label="return _lexedTokens[_tokenOffset + n]; 157356"];
5710 [label="this.PeekToken(1).Kind 157357"];
5711 [label="get { return (SyntaxKind)this.RawKind; } 157358"];
5712 [label="this.IsInQuery 157359"];
5713 [label="get { return _syntaxFactoryContext.IsInQuery; } 157360"];
5714 [label="return _syntaxFactoryContext.IsInQuery; 157361"];
5715 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 157362"];
5716 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 157363"];
5717 [label="this.PeekToken(2) 157364"];
5718 [label="param PeekToken(int n) 157365"];
5719 [label="param PeekToken(this) 157366"];
5720 [label="Debug.Assert(n >= 0); 157367"];
5721 [label="Debug.Assert(n >= 0); 157368"];
5722 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157369"];
5723 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157370"];
5724 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157371"];
5725 [label="return _lexedTokens[_tokenOffset + n]; 157372"];
5726 [label="this.PeekToken(2).Kind 157373"];
5727 [label="get { return (SyntaxKind)this.RawKind; } 157374"];
5728 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 157375"];
5729 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 157376"];
5730 [label="this.PeekToken(1) 157377"];
5731 [label="param PeekToken(int n) 157378"];
5732 [label="param PeekToken(this) 157379"];
5733 [label="Debug.Assert(n >= 0); 157380"];
5734 [label="Debug.Assert(n >= 0); 157381"];
5735 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157382"];
5736 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157383"];
5737 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157384"];
5738 [label="return _lexedTokens[_tokenOffset + n]; 157385"];
5739 [label="IsTrueIdentifier(this.PeekToken(1)) 157386"];
5740 [label="param IsTrueIdentifier(SyntaxToken token) 157387"];
5741 [label="param IsTrueIdentifier(this) 157388"];
5742 [label="token.Kind 157389"];
5743 [label="get { return (SyntaxKind)this.RawKind; } 157390"];
5744 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 157391"];
5745 [label="this.IsInQuery 157392"];
5746 [label="get { return _syntaxFactoryContext.IsInQuery; } 157393"];
5747 [label="return _syntaxFactoryContext.IsInQuery; 157394"];
5748 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 157395"];
5749 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 157396"];
5750 [label="this.PeekToken(2) 157397"];
5751 [label="param PeekToken(int n) 157398"];
5752 [label="param PeekToken(this) 157399"];
5753 [label="Debug.Assert(n >= 0); 157400"];
5754 [label="Debug.Assert(n >= 0); 157401"];
5755 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157402"];
5756 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157403"];
5757 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157404"];
5758 [label="return _lexedTokens[_tokenOffset + n]; 157405"];
5759 [label="this.PeekToken(2).Kind 157406"];
5760 [label="get { return (SyntaxKind)this.RawKind; } 157407"];
5761 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 157408"];
5762 [label="this.PeekToken(3) 157409"];
5763 [label="param PeekToken(int n) 157410"];
5764 [label="param PeekToken(this) 157411"];
5765 [label="Debug.Assert(n >= 0); 157412"];
5766 [label="Debug.Assert(n >= 0); 157413"];
5767 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157414"];
5768 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157415"];
5769 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157416"];
5770 [label="return _lexedTokens[_tokenOffset + n]; 157417"];
5771 [label="this.PeekToken(3).Kind 157418"];
5772 [label="get { return (SyntaxKind)this.RawKind; } 157419"];
5773 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 157420"];
5774 [label="if (this.PeekToken(1).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(2).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 157421"];
5775 [label="this.PeekToken(1) 157422"];
5776 [label="param PeekToken(int n) 157423"];
5777 [label="param PeekToken(this) 157424"];
5778 [label="Debug.Assert(n >= 0); 157425"];
5779 [label="Debug.Assert(n >= 0); 157426"];
5780 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157427"];
5781 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157428"];
5782 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157429"];
5783 [label="return _lexedTokens[_tokenOffset + n]; 157430"];
5784 [label="this.PeekToken(1).Kind 157431"];
5785 [label="get { return (SyntaxKind)this.RawKind; } 157432"];
5786 [label="if (this.PeekToken(1).Kind == SyntaxKind.ParamsKeyword)\n            {\n                return true;\n            } 157433"];
5787 [label="this.PeekToken(1) 157434"];
5788 [label="param PeekToken(int n) 157435"];
5789 [label="param PeekToken(this) 157436"];
5790 [label="Debug.Assert(n >= 0); 157437"];
5791 [label="Debug.Assert(n >= 0); 157438"];
5792 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157439"];
5793 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157440"];
5794 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157441"];
5795 [label="return _lexedTokens[_tokenOffset + n]; 157442"];
5796 [label="this.PeekToken(1).Kind 157443"];
5797 [label="get { return (SyntaxKind)this.RawKind; } 157444"];
5798 [label="return false; 157445"];
5799 [label="if (ScanParenthesizedImplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 157446"];
5800 [label="if (this.ScanCast())\n                {\n                    if (!IsCurrentTokenQueryKeywordInQuery())\n                    {\n                        // Looks like a cast, so parse it as one.\n                        this.Reset(ref resetPoint);\n                        var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                        var type = this.ParseType();\n                        var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                        var expr = this.ParseSubExpression(Precedence.Cast);\n                        return _syntaxFactory.CastExpression(openParen, type, closeParen, expr);\n                    }\n                } 157447"];
5801 [label="this.ScanCast() 157448"];
5802 [label="param ScanCast(bool forPattern = false) 157449"];
5803 [label="param ScanCast(this) 157450"];
5804 [label="this.CurrentToken 157451"];
5805 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157452"];
5806 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157453"];
5807 [label="if (this.CurrentToken.Kind != SyntaxKind.OpenParenToken)\n            {\n                return false;\n            } 157454"];
5808 [label="this.CurrentToken.Kind 157455"];
5809 [label="get { return (SyntaxKind)this.RawKind; } 157456"];
5810 [label="this.EatToken() 157457"];
5811 [label="param EatToken(this) 157458"];
5812 [label="this.CurrentToken 157459"];
5813 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157460"];
5814 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157461"];
5815 [label="var ct = this.CurrentToken; 157462"];
5816 [label="MoveToNextToken() 157463"];
5817 [label="param MoveToNextToken(this) 157464"];
5818 [label="param GetTrailingTrivia(this) 157465"];
5819 [label="return null; 157466"];
5820 [label="_prevTokenTrailingTrivia 157467"];
5821 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157468"];
5822 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157469"];
5823 [label="_tokenOffset 157470"];
5824 [label="MoveToNextToken(); 157471"];
5825 [label="return ct; 157472"];
5826 [label="this.EatToken(); 157473"];
5827 [label="var type = this.ScanType(forPattern: forPattern); 157474"];
5828 [label="this.ScanType(forPattern: forPattern) 157475"];
5829 [label="param ScanType(bool forPattern = false) 157476"];
5830 [label="param ScanType(this) 157477"];
5831 [label="return ScanType(out _, forPattern); 157478"];
5832 [label="return ScanType(out _, forPattern); 157479"];
5833 [label="ScanType(out _, forPattern) 157480"];
5834 [label="param ScanType(out SyntaxToken lastTokenOfType) 157481"];
5835 [label="param ScanType(bool forPattern = false) 157482"];
5836 [label="param ScanType(this) 157483"];
5837 [label="forPattern 157484"];
5838 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 157485"];
5839 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 157486"];
5840 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 157487"];
5841 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 157488"];
5842 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157489"];
5843 [label="param PeekToken(int n) 157490"];
5844 [label="param PeekToken(this) 157491"];
5845 [label="Debug.Assert(n >= 0); 157492"];
5846 [label="Debug.Assert(n >= 0); 157493"];
5847 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157494"];
5848 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157495"];
5849 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157496"];
5850 [label="return _lexedTokens[_tokenOffset + n]; 157497"];
5851 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 157498"];
5852 [label="param ScanNamedTypePart(this) 157499"];
5853 [label="this.CurrentToken 157500"];
5854 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157501"];
5855 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157502"];
5856 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 157503"];
5857 [label="this.CurrentToken.Kind 157504"];
5858 [label="get { return (SyntaxKind)this.RawKind; } 157505"];
5859 [label="this.IsTrueIdentifier() 157506"];
5860 [label="param IsTrueIdentifier(this) 157507"];
5861 [label="this.CurrentToken 157508"];
5862 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157509"];
5863 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157510"];
5864 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 157511"];
5865 [label="this.CurrentToken.Kind 157512"];
5866 [label="get { return (SyntaxKind)this.RawKind; } 157513"];
5867 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 157514"];
5868 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 157515"];
5869 [label="this.CurrentToken 157516"];
5870 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157517"];
5871 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 157518"];
5872 [label="this.CurrentToken.ContextualKind 157519"];
5873 [label="get\n            {\n                return this.Kind;\n            } 157520"];
5874 [label="return false; 157521"];
5875 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157522"];
5876 [label="IsCurrentTokenQueryKeywordInQuery() 157523"];
5877 [label="param IsCurrentTokenQueryKeywordInQuery(this) 157524"];
5878 [label="this.IsInQuery 157525"];
5879 [label="get { return _syntaxFactoryContext.IsInQuery; } 157526"];
5880 [label="return _syntaxFactoryContext.IsInQuery; 157527"];
5881 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 157528"];
5882 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157529"];
5883 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157530"];
5884 [label="IsCurrentTokenWhereOfConstraintClause() 157531"];
5885 [label="param IsCurrentTokenWhereOfConstraintClause(this) 157532"];
5886 [label="this.CurrentToken 157533"];
5887 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157534"];
5888 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 157535"];
5889 [label="this.CurrentToken.ContextualKind 157536"];
5890 [label="get\n            {\n                return this.Kind;\n            } 157537"];
5891 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157538"];
5892 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157539"];
5893 [label="return true; 157540"];
5894 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 157541"];
5895 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 157542"];
5896 [label="this.EatToken() 157543"];
5897 [label="param EatToken(this) 157544"];
5898 [label="this.CurrentToken 157545"];
5899 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157546"];
5900 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157547"];
5901 [label="var ct = this.CurrentToken; 157548"];
5902 [label="MoveToNextToken() 157549"];
5903 [label="param GetTrailingTrivia(this) 157550"];
5904 [label="return null; 157551"];
5905 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157552"];
5906 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157553"];
5907 [label="_tokenOffset 157554"];
5908 [label="MoveToNextToken(); 157555"];
5909 [label="return ct; 157556"];
5910 [label="lastTokenOfType = this.EatToken(); 157557"];
5911 [label="this.CurrentToken 157558"];
5912 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157559"];
5913 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157560"];
5914 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 157561"];
5915 [label="return _lexedTokens[_tokenOffset]; 157562"];
5916 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                return this.ScanPossibleTypeArgumentList(ref lastTokenOfType, out _);\n            }\n            else\n            {\n                return ScanTypeFlags.NonGenericTypeOrExpression;\n            } 157563"];
5917 [label="this.CurrentToken.Kind 157564"];
5918 [label="get { return (SyntaxKind)this.RawKind; } 157565"];
5919 [label="return ScanTypeFlags.NonGenericTypeOrExpression; 157566"];
5920 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 157567"];
5921 [label="param IsDotOrColonColon(this) 157568"];
5922 [label="this.CurrentToken 157569"];
5923 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157570"];
5924 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157571"];
5925 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 157572"];
5926 [label="this.CurrentToken.Kind 157573"];
5927 [label="get { return (SyntaxKind)this.RawKind; } 157574"];
5928 [label="this.CurrentToken 157575"];
5929 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157576"];
5930 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157577"];
5931 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 157578"];
5932 [label="this.CurrentToken.Kind 157579"];
5933 [label="get { return (SyntaxKind)this.RawKind; } 157580"];
5934 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 157581"];
5935 [label="param IsMakingProgress(ref int lastTokenPosition) 157582"];
5936 [label="param IsMakingProgress(bool assertIfFalse = true) 157583"];
5937 [label="param IsMakingProgress(this) 157584"];
5938 [label="CurrentTokenPosition 157585"];
5939 [label="=> _firstToken + _tokenOffset 157586"];
5940 [label="_firstToken + _tokenOffset 157587"];
5941 [label="var pos = CurrentTokenPosition; 157588"];
5942 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 157589"];
5943 [label="lastTokenPosition = pos; 157590"];
5944 [label="return true; 157591"];
5945 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 157592"];
5946 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 157593"];
5947 [label="if (type == ScanTypeFlags.NotType)\n            {\n                return false;\n            } 157594"];
5948 [label="this.CurrentToken 157595"];
5949 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157596"];
5950 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157597"];
5951 [label="if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n            {\n                return false;\n            } 157598"];
5952 [label="this.CurrentToken.Kind 157599"];
5953 [label="get { return (SyntaxKind)this.RawKind; } 157600"];
5954 [label="this.EatToken() 157601"];
5955 [label="param EatToken(this) 157602"];
5956 [label="this.CurrentToken 157603"];
5957 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157604"];
5958 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157605"];
5959 [label="MoveToNextToken() 157606"];
5960 [label="param MoveToNextToken(this) 157607"];
5961 [label="param GetTrailingTrivia(this) 157608"];
5962 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157609"];
5963 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157610"];
5964 [label="_tokenOffset 157611"];
5965 [label="MoveToNextToken(); 157612"];
5966 [label="this.EatToken(); 157613"];
5967 [label="switch (type)\n            {\n                // If we have any of the following, we know it must be a cast:\n                // 1) (Goo*)bar;\n                // 2) (Goo?)bar;\n                // 3) '(int)bar' or '(int[])bar'\n                // 4) (G::Goo)bar\n                case ScanTypeFlags.PointerOrMultiplication:\n                case ScanTypeFlags.NullableType:\n                case ScanTypeFlags.MustBeType:\n                case ScanTypeFlags.AliasQualifiedName:\n                    // The thing between parens is unambiguously a type.\n                    // In a pattern, we need more lookahead to confirm it is a cast and not\n                    // a parenthesized type pattern.  In this case the tokens that\n                    // have both unary and binary operator forms may appear in their unary form\n                    // following a cast.\n                    return !forPattern || this.CurrentToken.Kind switch\n                    {\n                        SyntaxKind.PlusToken => true,\n                        SyntaxKind.MinusToken => true,\n                        SyntaxKind.AmpersandToken => true,\n                        SyntaxKind.AsteriskToken => true,\n                        SyntaxKind.DotDotToken => true,\n                        _ => CanFollowCast(this.CurrentToken.Kind)\n                    };\n\n                case ScanTypeFlags.GenericTypeOrMethod:\n                case ScanTypeFlags.GenericTypeOrExpression:\n                case ScanTypeFlags.NonGenericTypeOrExpression:\n                case ScanTypeFlags.TupleType:\n                    // check for ambiguous type or expression followed by disambiguating token.  i.e.\n                    //\n                    // '(A)b' is a cast.  But '(A)+b' is not a cast.  \n                    return CanFollowCast(this.CurrentToken.Kind);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(type);\n            } 157614"];
5968 [label="this.CurrentToken 157615"];
5969 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157616"];
5970 [label="return _lexedTokens[_tokenOffset]; 157617"];
5971 [label="return CanFollowCast(this.CurrentToken.Kind); 157618"];
5972 [label="this.CurrentToken.Kind 157619"];
5973 [label="get { return (SyntaxKind)this.RawKind; } 157620"];
5974 [label="CanFollowCast(this.CurrentToken.Kind) 157621"];
5975 [label="param CanFollowCast(SyntaxKind kind) 157622"];
5976 [label="switch (kind)\n            {\n                case SyntaxKind.AsKeyword:\n                case SyntaxKind.IsKeyword:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.EqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.QuestionToken:\n                case SyntaxKind.ColonToken:\n                case SyntaxKind.BarBarToken:\n                case SyntaxKind.AmpersandAmpersandToken:\n                case SyntaxKind.BarToken:\n                case SyntaxKind.CaretToken:\n                case SyntaxKind.AmpersandToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.LessThanLessThanToken:\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                case SyntaxKind.PlusToken:\n                case SyntaxKind.MinusToken:\n                case SyntaxKind.AsteriskToken:\n                case SyntaxKind.SlashToken:\n                case SyntaxKind.PercentToken:\n                case SyntaxKind.PlusPlusToken:\n                case SyntaxKind.MinusMinusToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.DotToken:\n                case SyntaxKind.MinusGreaterThanToken:\n                case SyntaxKind.QuestionQuestionToken:\n                case SyntaxKind.EndOfFileToken:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.EqualsGreaterThanToken:\n                case SyntaxKind.DotDotToken:\n                    return false;\n                default:\n                    return true;\n            } 157623"];
5977 [label="return false; 157624"];
5978 [label="this.Reset(ref resetPoint); 157625"];
5979 [label="this.Reset(ref resetPoint) 157626"];
5980 [label="param Reset(ref ResetPoint state) 157627"];
5981 [label="param Reset(this) 157628"];
5982 [label="_termState 157629"];
5983 [label="_isInTry 157630"];
5984 [label="_syntaxFactoryContext.IsInAsync 157631"];
5985 [label="_syntaxFactoryContext.QueryDepth 157632"];
5986 [label="base.Reset(ref state.BaseResetPoint); 157633"];
5987 [label="base.Reset(ref state.BaseResetPoint) 157634"];
5988 [label="param Reset(ref ResetPoint point) 157635"];
5989 [label="param Reset(this) 157636"];
5990 [label="var offset = point.Position - _firstToken; 157637"];
5991 [label="Debug.Assert(offset >= 0); 157638"];
5992 [label="Debug.Assert(offset >= 0); 157639"];
5993 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 157640"];
5994 [label="_mode 157641"];
5995 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 157642"];
5996 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 157643"];
5997 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 157644"];
5998 [label="_tokenOffset 157645"];
5999 [label="_currentToken = null; 157646"];
6000 [label="_currentToken 157647"];
6001 [label="_currentNode = default(BlendedNode); 157648"];
6002 [label="_currentNode 157649"];
6003 [label="_prevTokenTrailingTrivia 157650"];
6004 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 157651"];
6005 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 157652"];
6006 [label="base.Reset(ref state.BaseResetPoint); 157653"];
6007 [label="this.Reset(ref resetPoint); 157654"];
6008 [label="if (this.ScanExplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 157655"];
6009 [label="this.ScanExplicitlyTypedLambda(precedence) 157656"];
6010 [label="param ScanExplicitlyTypedLambda(Precedence precedence) 157657"];
6011 [label="param ScanExplicitlyTypedLambda(this) 157658"];
6012 [label="if (!(precedence <= Precedence.Lambda))\n            {\n                return false;\n            } 157659"];
6013 [label="this.GetResetPoint() 157660"];
6014 [label="param GetResetPoint(this) 157661"];
6015 [label="_firstToken + _tokenOffset 157662"];
6016 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 157663"];
6017 [label="_resetCount 157664"];
6018 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 157665"];
6019 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 157666"];
6020 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 157667"];
6021 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 157668"];
6022 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 157669"];
6023 [label="param ResetPoint(this) 157670"];
6024 [label="var resetPoint = this.GetResetPoint(); 157671"];
6025 [label="bool foundParameterModifier = false; 157672"];
6026 [label="while (true)\n                {\n                    // Advance past the open paren or comma.\n                    this.EatToken();\n\n                    // Eat 'out' or 'ref' for cases [3, 6]. Even though not allowed in a lambda,\n                    // we treat `params` similarly for better error recovery.\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.RefKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                            {\n                                this.EatToken();\n                            }\n                            break;\n                        case SyntaxKind.OutKeyword:\n                        case SyntaxKind.InKeyword:\n                        case SyntaxKind.ParamsKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            break;\n                    }\n\n                    if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        return foundParameterModifier;\n                    }\n\n                    // NOTE: advances CurrentToken\n                    if (this.ScanType() == ScanTypeFlags.NotType)\n                    {\n                        return false;\n                    }\n\n                    if (this.IsTrueIdentifier())\n                    {\n                        // eat the identifier\n                        this.EatToken();\n                    }\n\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.EndOfFileToken:\n                            return foundParameterModifier;\n\n                        case SyntaxKind.CommaToken:\n                            if (foundParameterModifier)\n                            {\n                                return true;\n                            }\n\n                            continue;\n\n                        case SyntaxKind.CloseParenToken:\n                            return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken;\n\n                        default:\n                            return false;\n                    }\n                } 157673"];
6027 [label="this.EatToken() 157674"];
6028 [label="param EatToken(this) 157675"];
6029 [label="this.CurrentToken 157676"];
6030 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157677"];
6031 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157678"];
6032 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 157679"];
6033 [label="MoveToNextToken() 157680"];
6034 [label="param MoveToNextToken(this) 157681"];
6035 [label="param GetTrailingTrivia(this) 157682"];
6036 [label="return null; 157683"];
6037 [label="_prevTokenTrailingTrivia 157684"];
6038 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157685"];
6039 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157686"];
6040 [label="_tokenOffset 157687"];
6041 [label="MoveToNextToken(); 157688"];
6042 [label="this.EatToken(); 157689"];
6043 [label="this.CurrentToken 157690"];
6044 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157691"];
6045 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157692"];
6046 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 157693"];
6047 [label="return _lexedTokens[_tokenOffset]; 157694"];
6048 [label="switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.RefKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                            {\n                                this.EatToken();\n                            }\n                            break;\n                        case SyntaxKind.OutKeyword:\n                        case SyntaxKind.InKeyword:\n                        case SyntaxKind.ParamsKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            break;\n                    } 157695"];
6049 [label="this.CurrentToken.Kind 157696"];
6050 [label="get { return (SyntaxKind)this.RawKind; } 157697"];
6051 [label="this.CurrentToken 157698"];
6052 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157699"];
6053 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157700"];
6054 [label="if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        return foundParameterModifier;\n                    } 157701"];
6055 [label="this.CurrentToken.Kind 157702"];
6056 [label="get { return (SyntaxKind)this.RawKind; } 157703"];
6057 [label="if (this.ScanType() == ScanTypeFlags.NotType)\n                    {\n                        return false;\n                    } 157704"];
6058 [label="this.ScanType() 157705"];
6059 [label="param ScanType(bool forPattern = false) 157706"];
6060 [label="param ScanType(this) 157707"];
6061 [label="return ScanType(out _, forPattern); 157708"];
6062 [label="return ScanType(out _, forPattern); 157709"];
6063 [label="ScanType(out _, forPattern) 157710"];
6064 [label="param ScanType(out SyntaxToken lastTokenOfType) 157711"];
6065 [label="param ScanType(bool forPattern = false) 157712"];
6066 [label="param ScanType(this) 157713"];
6067 [label="forPattern 157714"];
6068 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 157715"];
6069 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 157716"];
6070 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 157717"];
6071 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 157718"];
6072 [label="Debug.Assert(n >= 0); 157719"];
6073 [label="Debug.Assert(n >= 0); 157720"];
6074 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157721"];
6075 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157722"];
6076 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 157723"];
6077 [label="this.CurrentToken 157724"];
6078 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157725"];
6079 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 157726"];
6080 [label="this.CurrentToken.Kind 157727"];
6081 [label="get { return (SyntaxKind)this.RawKind; } 157728"];
6082 [label="this.IsTrueIdentifier() 157729"];
6083 [label="param IsTrueIdentifier(this) 157730"];
6084 [label="this.CurrentToken 157731"];
6085 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157732"];
6086 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 157733"];
6087 [label="this.CurrentToken.Kind 157734"];
6088 [label="get { return (SyntaxKind)this.RawKind; } 157735"];
6089 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 157736"];
6090 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 157737"];
6091 [label="this.CurrentToken 157738"];
6092 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157739"];
6093 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 157740"];
6094 [label="this.CurrentToken.ContextualKind 157741"];
6095 [label="get\n            {\n                return this.Kind;\n            } 157742"];
6096 [label="return false; 157743"];
6097 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157744"];
6098 [label="IsCurrentTokenQueryKeywordInQuery() 157745"];
6099 [label="param IsCurrentTokenQueryKeywordInQuery(this) 157746"];
6100 [label="this.IsInQuery 157747"];
6101 [label="get { return _syntaxFactoryContext.IsInQuery; } 157748"];
6102 [label="return _syntaxFactoryContext.IsInQuery; 157749"];
6103 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 157750"];
6104 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157751"];
6105 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157752"];
6106 [label="IsCurrentTokenWhereOfConstraintClause() 157753"];
6107 [label="param IsCurrentTokenWhereOfConstraintClause(this) 157754"];
6108 [label="this.CurrentToken 157755"];
6109 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157756"];
6110 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 157757"];
6111 [label="this.CurrentToken.ContextualKind 157758"];
6112 [label="get\n            {\n                return this.Kind;\n            } 157759"];
6113 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157760"];
6114 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157761"];
6115 [label="return true; 157762"];
6116 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 157763"];
6117 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 157764"];
6118 [label="this.EatToken() 157765"];
6119 [label="this.CurrentToken 157766"];
6120 [label="MoveToNextToken() 157767"];
6121 [label="param GetTrailingTrivia(this) 157768"];
6122 [label="return null; 157769"];
6123 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157770"];
6124 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157771"];
6125 [label="MoveToNextToken(); 157772"];
6126 [label="this.CurrentToken 157773"];
6127 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157774"];
6128 [label="this.CurrentToken.Kind 157775"];
6129 [label="this.CurrentToken 157776"];
6130 [label="this.CurrentToken.Kind 157777"];
6131 [label="this.CurrentToken 157778"];
6132 [label="this.CurrentToken.Kind 157779"];
6133 [label="param IsMakingProgress(bool assertIfFalse = true) 157780"];
6134 [label="CurrentTokenPosition 157781"];
6135 [label="this.IsTrueIdentifier() 157782"];
6136 [label="param IsTrueIdentifier(this) 157783"];
6137 [label="this.CurrentToken 157784"];
6138 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157785"];
6139 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157786"];
6140 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 157787"];
6141 [label="this.CurrentToken.Kind 157788"];
6142 [label="get { return (SyntaxKind)this.RawKind; } 157789"];
6143 [label="return false; 157790"];
6144 [label="if (this.IsTrueIdentifier())\n                    {\n                        // eat the identifier\n                        this.EatToken();\n                    } 157791"];
6145 [label="this.CurrentToken 157792"];
6146 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157793"];
6147 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157794"];
6148 [label="switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.EndOfFileToken:\n                            return foundParameterModifier;\n\n                        case SyntaxKind.CommaToken:\n                            if (foundParameterModifier)\n                            {\n                                return true;\n                            }\n\n                            continue;\n\n                        case SyntaxKind.CloseParenToken:\n                            return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken;\n\n                        default:\n                            return false;\n                    } 157795"];
6149 [label="this.CurrentToken.Kind 157796"];
6150 [label="get { return (SyntaxKind)this.RawKind; } 157797"];
6151 [label="return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken; 157798"];
6152 [label="this.PeekToken(1) 157799"];
6153 [label="param PeekToken(int n) 157800"];
6154 [label="Debug.Assert(n >= 0); 157801"];
6155 [label="Debug.Assert(n >= 0); 157802"];
6156 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157803"];
6157 [label="this.PeekToken(1).Kind 157804"];
6158 [label="get { return (SyntaxKind)this.RawKind; } 157805"];
6159 [label="this.Reset(ref resetPoint); 157806"];
6160 [label="this.Reset(ref resetPoint) 157807"];
6161 [label="param Reset(ref ResetPoint state) 157808"];
6162 [label="Debug.Assert(offset >= 0); 157809"];
6163 [label="Debug.Assert(offset >= 0); 157810"];
6164 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 157811"];
6165 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 157812"];
6166 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 157813"];
6167 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 157814"];
6168 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 157815"];
6169 [label="this.Reset(ref resetPoint); 157816"];
6170 [label="this.Release(ref resetPoint); 157817"];
6171 [label="this.Release(ref resetPoint) 157818"];
6172 [label="param Release(ref ResetPoint state) 157819"];
6173 [label="param Release(this) 157820"];
6174 [label="base.Release(ref state.BaseResetPoint); 157821"];
6175 [label="base.Release(ref state.BaseResetPoint) 157822"];
6176 [label="param Release(ref ResetPoint point) 157823"];
6177 [label="param Release(this) 157824"];
6178 [label="Debug.Assert(_resetCount == point.ResetCount); 157825"];
6179 [label="_resetCount 157826"];
6180 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 157827"];
6181 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 157828"];
6182 [label="base.Release(ref state.BaseResetPoint); 157829"];
6183 [label="this.Release(ref resetPoint); 157830"];
6184 [label="if (this.ScanExplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 157831"];
6185 [label="this.Reset(ref resetPoint); 157832"];
6186 [label="this.Reset(ref resetPoint) 157833"];
6187 [label="param Reset(ref ResetPoint state) 157834"];
6188 [label="param Reset(this) 157835"];
6189 [label="_termState 157836"];
6190 [label="_isInTry 157837"];
6191 [label="_syntaxFactoryContext.IsInAsync 157838"];
6192 [label="_syntaxFactoryContext.QueryDepth 157839"];
6193 [label="base.Reset(ref state.BaseResetPoint); 157840"];
6194 [label="base.Reset(ref state.BaseResetPoint) 157841"];
6195 [label="param Reset(this) 157842"];
6196 [label="var offset = point.Position - _firstToken; 157843"];
6197 [label="Debug.Assert(offset >= 0); 157844"];
6198 [label="Debug.Assert(offset >= 0); 157845"];
6199 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 157846"];
6200 [label="_mode 157847"];
6201 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 157848"];
6202 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 157849"];
6203 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 157850"];
6204 [label="_currentToken = null; 157851"];
6205 [label="_currentToken 157852"];
6206 [label="_currentNode = default(BlendedNode); 157853"];
6207 [label="_currentNode 157854"];
6208 [label="_prevTokenTrailingTrivia 157855"];
6209 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 157856"];
6210 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 157857"];
6211 [label="base.Reset(ref state.BaseResetPoint); 157858"];
6212 [label="this.Reset(ref resetPoint); 157859"];
6213 [label="var openParen = this.EatToken(SyntaxKind.OpenParenToken); 157860"];
6214 [label="this.EatToken(SyntaxKind.OpenParenToken) 157861"];
6215 [label="param EatToken(SyntaxKind kind) 157862"];
6216 [label="param EatToken(this) 157863"];
6217 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 157864"];
6218 [label="SyntaxFacts.IsAnyToken(kind) 157865"];
6219 [label="param IsAnyToken(SyntaxKind kind) 157866"];
6220 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 157867"];
6221 [label="return true; 157868"];
6222 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157869"];
6223 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 157870"];
6224 [label="return _lexedTokens[_tokenOffset]; 157871"];
6225 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 157872"];
6226 [label="param GetTrailingTrivia(this) 157873"];
6227 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157874"];
6228 [label="MoveToNextToken(); 157875"];
6229 [label="return ct; 157876"];
6230 [label="var expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true); 157877"];
6231 [label="var expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true); 157878"];
6232 [label="this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true) 157879"];
6233 [label="param ParseExpressionOrDeclaration(ParseTypeMode mode) 157880"];
6234 [label="param ParseExpressionOrDeclaration(MessageID feature) 157881"];
6235 [label="param ParseExpressionOrDeclaration(bool permitTupleDesignation) 157882"];
6236 [label="param ParseExpressionOrDeclaration(this) 157883"];
6237 [label="return IsPossibleDeclarationExpression(mode, permitTupleDesignation)\n                ? this.ParseDeclarationExpression(mode, feature)\n                : this.ParseSubExpression(Precedence.Expression); 157884"];
6238 [label="return IsPossibleDeclarationExpression(mode, permitTupleDesignation)\n                ? this.ParseDeclarationExpression(mode, feature)\n                : this.ParseSubExpression(Precedence.Expression); 157885"];
6239 [label="IsPossibleDeclarationExpression(mode, permitTupleDesignation) 157886"];
6240 [label="param IsPossibleDeclarationExpression(ParseTypeMode mode) 157887"];
6241 [label="param IsPossibleDeclarationExpression(bool permitTupleDesignation) 157888"];
6242 [label="param IsPossibleDeclarationExpression(this) 157889"];
6243 [label="this.IsInAsync 157890"];
6244 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 157891"];
6245 [label="return _syntaxFactoryContext.IsInAsync; 157892"];
6246 [label="if (this.IsInAsync && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                // can't be a declaration expression.\n                return false;\n            } 157893"];
6247 [label="this.GetResetPoint() 157894"];
6248 [label="param GetResetPoint(this) 157895"];
6249 [label="_firstToken + _tokenOffset 157896"];
6250 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 157897"];
6251 [label="_resetCount 157898"];
6252 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 157899"];
6253 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 157900"];
6254 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 157901"];
6255 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 157902"];
6256 [label="param ResetPoint(this) 157903"];
6257 [label="var resetPoint = this.GetResetPoint(); 157904"];
6258 [label="IsVarType() 157905"];
6259 [label="param IsVarType(this) 157906"];
6260 [label="this.CurrentToken 157907"];
6261 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157908"];
6262 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157909"];
6263 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 157910"];
6264 [label="if (!this.CurrentToken.IsIdentifierVar())\n            {\n                return false;\n            } 157911"];
6265 [label="this.CurrentToken.IsIdentifierVar() 157912"];
6266 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 157913"];
6267 [label="return false; 157914"];
6268 [label="bool typeIsVar = IsVarType(); 157915"];
6269 [label="SyntaxToken lastTokenOfType; 157916"];
6270 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 157917"];
6271 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 157918"];
6272 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 157919"];
6273 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 157920"];
6274 [label="Debug.Assert(n >= 0); 157921"];
6275 [label="Debug.Assert(n >= 0); 157922"];
6276 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157923"];
6277 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 157924"];
6278 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 157925"];
6279 [label="this.CurrentToken 157926"];
6280 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157927"];
6281 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 157928"];
6282 [label="this.CurrentToken.Kind 157929"];
6283 [label="get { return (SyntaxKind)this.RawKind; } 157930"];
6284 [label="this.IsTrueIdentifier() 157931"];
6285 [label="param IsTrueIdentifier(this) 157932"];
6286 [label="this.CurrentToken 157933"];
6287 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157934"];
6288 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 157935"];
6289 [label="this.CurrentToken.Kind 157936"];
6290 [label="get { return (SyntaxKind)this.RawKind; } 157937"];
6291 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 157938"];
6292 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 157939"];
6293 [label="this.CurrentToken 157940"];
6294 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157941"];
6295 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 157942"];
6296 [label="this.CurrentToken.ContextualKind 157943"];
6297 [label="get\n            {\n                return this.Kind;\n            } 157944"];
6298 [label="return false; 157945"];
6299 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157946"];
6300 [label="IsCurrentTokenQueryKeywordInQuery() 157947"];
6301 [label="param IsCurrentTokenQueryKeywordInQuery(this) 157948"];
6302 [label="this.IsInQuery 157949"];
6303 [label="get { return _syntaxFactoryContext.IsInQuery; } 157950"];
6304 [label="return _syntaxFactoryContext.IsInQuery; 157951"];
6305 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 157952"];
6306 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157953"];
6307 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157954"];
6308 [label="IsCurrentTokenWhereOfConstraintClause() 157955"];
6309 [label="param IsCurrentTokenWhereOfConstraintClause(this) 157956"];
6310 [label="this.CurrentToken 157957"];
6311 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157958"];
6312 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 157959"];
6313 [label="this.CurrentToken.ContextualKind 157960"];
6314 [label="get\n            {\n                return this.Kind;\n            } 157961"];
6315 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157962"];
6316 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 157963"];
6317 [label="return true; 157964"];
6318 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 157965"];
6319 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 157966"];
6320 [label="this.EatToken() 157967"];
6321 [label="this.CurrentToken 157968"];
6322 [label="MoveToNextToken() 157969"];
6323 [label="param GetTrailingTrivia(this) 157970"];
6324 [label="return null; 157971"];
6325 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157972"];
6326 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 157973"];
6327 [label="MoveToNextToken(); 157974"];
6328 [label="this.CurrentToken 157975"];
6329 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 157976"];
6330 [label="this.CurrentToken.Kind 157977"];
6331 [label="this.CurrentToken 157978"];
6332 [label="this.CurrentToken.Kind 157979"];
6333 [label="this.CurrentToken 157980"];
6334 [label="this.CurrentToken.Kind 157981"];
6335 [label="param IsMakingProgress(bool assertIfFalse = true) 157982"];
6336 [label="CurrentTokenPosition 157983"];
6337 [label="lastTokenOfType.Kind 157984"];
6338 [label="get { return (SyntaxKind)this.RawKind; } 157985"];
6339 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 157986"];
6340 [label="IsPredefinedType(lastTokenOfType.Kind) 157987"];
6341 [label="param IsPredefinedType(SyntaxKind keyword) 157988"];
6342 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 157989"];
6343 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 157990"];
6344 [label="ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))) 157991"];
6345 [label="param ScanDesignation(bool permitTuple) 157992"];
6346 [label="param ScanDesignation(this) 157993"];
6347 [label="this.CurrentToken 157994"];
6348 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 157995"];
6349 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 157996"];
6350 [label="switch (this.CurrentToken.Kind)\n            {\n                default:\n                    return false;\n                case SyntaxKind.IdentifierToken:\n                    bool result = this.IsTrueIdentifier();\n                    this.EatToken();\n                    return result;\n                case SyntaxKind.OpenParenToken:\n                    if (!permitTuple)\n                    {\n                        return false;\n                    }\n\n                    bool sawComma = false;\n                    while (true)\n                    {\n                        this.EatToken(); // consume the `(` or `,`\n                        if (!ScanDesignation(permitTuple: true))\n                        {\n                            return false;\n                        }\n                        switch (this.CurrentToken.Kind)\n                        {\n                            case SyntaxKind.CloseParenToken:\n                                this.EatToken();\n                                return sawComma;\n                            case SyntaxKind.CommaToken:\n                                sawComma = true;\n                                continue;\n                            default:\n                                return false;\n                        }\n                    }\n            } 157997"];
6351 [label="this.CurrentToken.Kind 157998"];
6352 [label="get { return (SyntaxKind)this.RawKind; } 157999"];
6353 [label="return false; 158000"];
6354 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 158001"];
6355 [label="return false; 158002"];
6356 [label="this.Reset(ref resetPoint); 158003"];
6357 [label="this.Reset(ref resetPoint) 158004"];
6358 [label="param Reset(ref ResetPoint state) 158005"];
6359 [label="Debug.Assert(offset >= 0); 158006"];
6360 [label="Debug.Assert(offset >= 0); 158007"];
6361 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 158008"];
6362 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 158009"];
6363 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 158010"];
6364 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 158011"];
6365 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 158012"];
6366 [label="this.Reset(ref resetPoint); 158013"];
6367 [label="this.Release(ref resetPoint); 158014"];
6368 [label="this.Release(ref resetPoint) 158015"];
6369 [label="param Release(ref ResetPoint state) 158016"];
6370 [label="base.Release(ref state.BaseResetPoint); 158017"];
6371 [label="param Release(ref ResetPoint point) 158018"];
6372 [label="Debug.Assert(_resetCount == point.ResetCount); 158019"];
6373 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 158020"];
6374 [label="base.Release(ref state.BaseResetPoint); 158021"];
6375 [label="this.Release(ref resetPoint); 158022"];
6376 [label="this.ParseSubExpression(Precedence.Expression) 158023"];
6377 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 158024"];
6378 [label="ExpressionSyntax leftOperand; 158025"];
6379 [label="Precedence newPrecedence = 0; 158026"];
6380 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158027"];
6381 [label="return _lexedTokens[_tokenOffset]; 158028"];
6382 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 158029"];
6383 [label="IsInvalidSubExpression(tk) 158030"];
6384 [label="param IsInvalidSubExpression(SyntaxKind kind) 158031"];
6385 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 158032"];
6386 [label="return false; 158033"];
6387 [label="param IsAwaitExpression(this) 158034"];
6388 [label="this.CurrentToken 158035"];
6389 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158036"];
6390 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 158037"];
6391 [label="this.CurrentToken.ContextualKind 158038"];
6392 [label="get\n            {\n                return this.Kind;\n            } 158039"];
6393 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 158040"];
6394 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 158041"];
6395 [label="param IsQueryExpression(this) 158042"];
6396 [label="this.CurrentToken 158043"];
6397 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158044"];
6398 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 158045"];
6399 [label="this.CurrentToken.ContextualKind 158046"];
6400 [label="get\n            {\n                return this.Kind;\n            } 158047"];
6401 [label="leftOperand = this.ParseTerm(precedence); 158048"];
6402 [label="param ParseTerm(Precedence precedence) 158049"];
6403 [label="precedence 158050"];
6404 [label="param ParseTermWithoutPostfix(Precedence precedence) 158051"];
6405 [label="this.IsTrueIdentifier() 158052"];
6406 [label="param IsTrueIdentifier(this) 158053"];
6407 [label="this.CurrentToken 158054"];
6408 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158055"];
6409 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 158056"];
6410 [label="this.CurrentToken.Kind 158057"];
6411 [label="get { return (SyntaxKind)this.RawKind; } 158058"];
6412 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 158059"];
6413 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 158060"];
6414 [label="this.CurrentToken 158061"];
6415 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158062"];
6416 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 158063"];
6417 [label="this.CurrentToken.ContextualKind 158064"];
6418 [label="get\n            {\n                return this.Kind;\n            } 158065"];
6419 [label="return false; 158066"];
6420 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158067"];
6421 [label="IsCurrentTokenQueryKeywordInQuery() 158068"];
6422 [label="param IsCurrentTokenQueryKeywordInQuery(this) 158069"];
6423 [label="this.IsInQuery 158070"];
6424 [label="get { return _syntaxFactoryContext.IsInQuery; } 158071"];
6425 [label="return _syntaxFactoryContext.IsInQuery; 158072"];
6426 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 158073"];
6427 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158074"];
6428 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158075"];
6429 [label="IsCurrentTokenWhereOfConstraintClause() 158076"];
6430 [label="param IsCurrentTokenWhereOfConstraintClause(this) 158077"];
6431 [label="this.CurrentToken 158078"];
6432 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158079"];
6433 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 158080"];
6434 [label="this.CurrentToken.ContextualKind 158081"];
6435 [label="get\n            {\n                return this.Kind;\n            } 158082"];
6436 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158083"];
6437 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 158084"];
6438 [label="return true; 158085"];
6439 [label="if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    } 158086"];
6440 [label="this.IsPossibleAnonymousMethodExpression() 158087"];
6441 [label="param IsPossibleAnonymousMethodExpression(this) 158088"];
6442 [label="var tokenIndex = 0; 158089"];
6443 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 158090"];
6444 [label="this.PeekToken(tokenIndex) 158091"];
6445 [label="param PeekToken(int n) 158092"];
6446 [label="param PeekToken(this) 158093"];
6447 [label="Debug.Assert(n >= 0); 158094"];
6448 [label="Debug.Assert(n >= 0); 158095"];
6449 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158096"];
6450 [label="return _lexedTokens[_tokenOffset + n]; 158097"];
6451 [label="this.PeekToken(tokenIndex).Kind 158098"];
6452 [label="get { return (SyntaxKind)this.RawKind; } 158099"];
6453 [label="this.PeekToken(tokenIndex) 158100"];
6454 [label="param PeekToken(int n) 158101"];
6455 [label="param PeekToken(this) 158102"];
6456 [label="Debug.Assert(n >= 0); 158103"];
6457 [label="Debug.Assert(n >= 0); 158104"];
6458 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158105"];
6459 [label="return _lexedTokens[_tokenOffset + n]; 158106"];
6460 [label="this.PeekToken(tokenIndex).ContextualKind 158107"];
6461 [label="get\n            {\n                return this.Kind;\n            } 158108"];
6462 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 158109"];
6463 [label="return this.PeekToken(tokenIndex).Kind == SyntaxKind.DelegateKeyword; 158110"];
6464 [label="this.PeekToken(tokenIndex) 158111"];
6465 [label="param PeekToken(int n) 158112"];
6466 [label="param PeekToken(this) 158113"];
6467 [label="Debug.Assert(n >= 0); 158114"];
6468 [label="Debug.Assert(n >= 0); 158115"];
6469 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158116"];
6470 [label="return _lexedTokens[_tokenOffset + n]; 158117"];
6471 [label="this.PeekToken(tokenIndex).Kind 158118"];
6472 [label="get { return (SyntaxKind)this.RawKind; } 158119"];
6473 [label="if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 158120"];
6474 [label="if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 158121"];
6475 [label="this.IsPossibleLambdaExpression(precedence) 158122"];
6476 [label="param IsPossibleLambdaExpression(Precedence precedence) 158123"];
6477 [label="param IsPossibleLambdaExpression(this) 158124"];
6478 [label="this.CurrentToken 158125"];
6479 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158126"];
6480 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 158127"];
6481 [label="this.CurrentToken.Kind 158128"];
6482 [label="get { return (SyntaxKind)this.RawKind; } 158129"];
6483 [label="this.CurrentToken 158130"];
6484 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158131"];
6485 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 158132"];
6486 [label="this.IsTrueIdentifier(this.CurrentToken) 158133"];
6487 [label="param IsTrueIdentifier(SyntaxToken token) 158134"];
6488 [label="param IsTrueIdentifier(this) 158135"];
6489 [label="token.Kind 158136"];
6490 [label="get { return (SyntaxKind)this.RawKind; } 158137"];
6491 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 158138"];
6492 [label="this.IsInQuery 158139"];
6493 [label="get { return _syntaxFactoryContext.IsInQuery; } 158140"];
6494 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 158141"];
6495 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 158142"];
6496 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 158143"];
6497 [label="if (precedence > Precedence.Lambda)\n            {\n                return false;\n            } 158144"];
6498 [label="int peekIndex; 158145"];
6499 [label="bool seenStatic; 158146"];
6500 [label="this.CurrentToken 158147"];
6501 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158148"];
6502 [label="if (this.CurrentToken.Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 1;\n                seenStatic = true;\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 2;\n                seenStatic = true;\n            }\n            else\n            {\n                peekIndex = 0;\n                seenStatic = false;\n            } 158149"];
6503 [label="this.CurrentToken.Kind 158150"];
6504 [label="get { return (SyntaxKind)this.RawKind; } 158151"];
6505 [label="this.CurrentToken 158152"];
6506 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 2;\n                seenStatic = true;\n            }\n            else\n            {\n                peekIndex = 0;\n                seenStatic = false;\n            } 158153"];
6507 [label="this.CurrentToken.ContextualKind 158154"];
6508 [label="get\n            {\n                return this.Kind;\n            } 158155"];
6509 [label="peekIndex = 0; 158156"];
6510 [label="seenStatic = false; 158157"];
6511 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on => then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static =>`\n                // 2. `async static =>`\n\n                // This is an error case, but we have enough code in front of us to be certain\n                // the user was trying to write a static lambda.\n                return true;\n            } 158158"];
6512 [label="this.PeekToken(peekIndex) 158159"];
6513 [label="param PeekToken(int n) 158160"];
6514 [label="param PeekToken(this) 158161"];
6515 [label="Debug.Assert(n >= 0); 158162"];
6516 [label="Debug.Assert(n >= 0); 158163"];
6517 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158164"];
6518 [label="this.PeekToken(peekIndex).Kind 158165"];
6519 [label="get { return (SyntaxKind)this.RawKind; } 158166"];
6520 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 158167"];
6521 [label="this.PeekToken(peekIndex) 158168"];
6522 [label="param PeekToken(int n) 158169"];
6523 [label="param PeekToken(this) 158170"];
6524 [label="Debug.Assert(n >= 0); 158171"];
6525 [label="Debug.Assert(n >= 0); 158172"];
6526 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158173"];
6527 [label="this.PeekToken(peekIndex).Kind 158174"];
6528 [label="get { return (SyntaxKind)this.RawKind; } 158175"];
6529 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 158176"];
6530 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 158177"];
6531 [label="this.PeekToken(peekIndex + 1) 158178"];
6532 [label="param PeekToken(int n) 158179"];
6533 [label="param PeekToken(this) 158180"];
6534 [label="Debug.Assert(n >= 0); 158181"];
6535 [label="Debug.Assert(n >= 0); 158182"];
6536 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158183"];
6537 [label="this.PeekToken(peekIndex + 1).Kind 158184"];
6538 [label="get { return (SyntaxKind)this.RawKind; } 158185"];
6539 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 158186"];
6540 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.OpenParenToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on ( then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static (...\n                // 2. `async static (...\n                return true;\n            } 158187"];
6541 [label="this.PeekToken(peekIndex) 158188"];
6542 [label="param PeekToken(int n) 158189"];
6543 [label="param PeekToken(this) 158190"];
6544 [label="Debug.Assert(n >= 0); 158191"];
6545 [label="Debug.Assert(n >= 0); 158192"];
6546 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158193"];
6547 [label="this.PeekToken(peekIndex).Kind 158194"];
6548 [label="get { return (SyntaxKind)this.RawKind; } 158195"];
6549 [label="if (this.PeekToken(peekIndex).ContextualKind != SyntaxKind.AsyncKeyword)\n            {\n                return false;\n            } 158196"];
6550 [label="this.PeekToken(peekIndex) 158197"];
6551 [label="param PeekToken(int n) 158198"];
6552 [label="param PeekToken(this) 158199"];
6553 [label="Debug.Assert(n >= 0); 158200"];
6554 [label="Debug.Assert(n >= 0); 158201"];
6555 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158202"];
6556 [label="this.PeekToken(peekIndex).ContextualKind 158203"];
6557 [label="get\n            {\n                return this.Kind;\n            } 158204"];
6558 [label="return false; 158205"];
6559 [label="if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 158206"];
6560 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 158207"];
6561 [label="this.IsPossibleDeconstructionLeft(precedence) 158208"];
6562 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 158209"];
6563 [label="return this.ParseAliasQualifiedName(NameOptions.InExpression); 158210"];
6564 [label="this.ParseAliasQualifiedName(NameOptions.InExpression) 158211"];
6565 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 158212"];
6566 [label="param ParseAliasQualifiedName(this) 158213"];
6567 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 158214"];
6568 [label="this.ParseSimpleName(allowedParts) 158215"];
6569 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 158216"];
6570 [label="param ParseSimpleName(this) 158217"];
6571 [label="var id = this.ParseIdentifierName(); 158218"];
6572 [label="this.ParseIdentifierName() 158219"];
6573 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 158220"];
6574 [label="param ParseIdentifierName(this) 158221"];
6575 [label="this.IsIncrementalAndFactoryContextMatches 158222"];
6576 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 158223"];
6577 [label="base.IsIncremental 158224"];
6578 [label="get\n            {\n                return _isIncremental;\n            } 158225"];
6579 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 158226"];
6580 [label="return false; 158227"];
6581 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 158228"];
6582 [label="var tk = ParseIdentifierToken(code); 158229"];
6583 [label="ParseIdentifierToken(code) 158230"];
6584 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 158231"];
6585 [label="param ParseIdentifierToken(this) 158232"];
6586 [label="this.CurrentToken 158233"];
6587 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158234"];
6588 [label="var ctk = this.CurrentToken.Kind; 158235"];
6589 [label="this.CurrentToken.Kind 158236"];
6590 [label="get { return (SyntaxKind)this.RawKind; } 158237"];
6591 [label="if (ctk == SyntaxKind.IdentifierToken)\n            {\n                // Error tolerance for IntelliSense. Consider the following case: [EditorBrowsable( partial class Goo {\n                // } Because we're parsing an attribute argument we'll end up consuming the 'partial' identifier and\n                // we'll eventually end up in a pretty confused state.  Because of that it becomes very difficult to\n                // show the correct parameter help in this case.  So, when we see 'partial' we check if it's being used\n                // as an identifier or as a contextual keyword.  If it's the latter then we bail out.  See\n                // Bug: vswhidbey/542125\n                if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                }\n\n                SyntaxToken identifierToken = this.EatToken();\n\n                if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                }\n\n                return identifierToken;\n            }\n            else\n            {\n                var name = CreateMissingIdentifierToken();\n                name = this.AddError(name, code);\n                return name;\n            } 158238"];
6592 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 158239"];
6593 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 158240"];
6594 [label="this.CurrentToken 158241"];
6595 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158242"];
6596 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 158243"];
6597 [label="this.CurrentToken.ContextualKind 158244"];
6598 [label="get\n            {\n                return this.Kind;\n            } 158245"];
6599 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 158246"];
6600 [label="IsCurrentTokenQueryKeywordInQuery() 158247"];
6601 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 158248"];
6602 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 158249"];
6603 [label="this.EatToken() 158250"];
6604 [label="param GetTrailingTrivia(this) 158251"];
6605 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158252"];
6606 [label="MoveToNextToken(); 158253"];
6607 [label="SyntaxToken identifierToken = this.EatToken(); 158254"];
6608 [label="this.IsInAsync 158255"];
6609 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 158256"];
6610 [label="return _syntaxFactoryContext.IsInAsync; 158257"];
6611 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 158258"];
6612 [label="return identifierToken; 158259"];
6613 [label="var tk = ParseIdentifierToken(code); 158260"];
6614 [label="return SyntaxFactory.IdentifierName(tk); 158261"];
6615 [label="return SyntaxFactory.IdentifierName(tk); 158262"];
6616 [label="param CSharpSyntaxNode(SyntaxKind kind) 158263"];
6617 [label="param CSharpSyntaxNode(this) 158264"];
6618 [label="kind 158265"];
6619 [label="param CSharpSyntaxNode(this) 158266"];
6620 [label="param CSharpSyntaxNode(this) 158267"];
6621 [label="GreenStats.NoteGreen(this); 158268"];
6622 [label="GreenStats.NoteGreen(this); 158269"];
6623 [label="var id = this.ParseIdentifierName(); 158270"];
6624 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 158271"];
6625 [label="SimpleNameSyntax name = id; 158272"];
6626 [label="this.CurrentToken 158273"];
6627 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158274"];
6628 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158275"];
6629 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 158276"];
6630 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 158277"];
6631 [label="this.CurrentToken.Kind 158278"];
6632 [label="get { return (SyntaxKind)this.RawKind; } 158279"];
6633 [label="return name; 158280"];
6634 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 158281"];
6635 [label="this.CurrentToken 158282"];
6636 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158283"];
6637 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158284"];
6638 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 158285"];
6639 [label="this.CurrentToken.Kind 158286"];
6640 [label="get { return (SyntaxKind)this.RawKind; } 158287"];
6641 [label="return name; 158288"];
6642 [label="return this.ParseAliasQualifiedName(NameOptions.InExpression); 158289"];
6643 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 158290"];
6644 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 158291"];
6645 [label="return ParseExpressionContinued(leftOperand, precedence); 158292"];
6646 [label="return ParseExpressionContinued(leftOperand, precedence); 158293"];
6647 [label="ParseExpressionContinued(leftOperand, precedence) 158294"];
6648 [label="param ParseExpressionContinued(ExpressionSyntax leftOperand) 158295"];
6649 [label="param ParseExpressionContinued(Precedence precedence) 158296"];
6650 [label="param ParseExpressionContinued(this) 158297"];
6651 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 158298"];
6652 [label="this.CurrentToken 158299"];
6653 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158300"];
6654 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158301"];
6655 [label="var tk = this.CurrentToken.ContextualKind; 158302"];
6656 [label="this.CurrentToken.ContextualKind 158303"];
6657 [label="get\n            {\n                return this.Kind;\n            } 158304"];
6658 [label="bool isAssignmentOperator = false; 158305"];
6659 [label="SyntaxKind opKind; 158306"];
6660 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158307"];
6661 [label="IsExpectedBinaryOperator(tk) 158308"];
6662 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 158309"];
6663 [label="return SyntaxFacts.IsBinaryExpression(kind); 158310"];
6664 [label="SyntaxFacts.IsBinaryExpression(kind) 158311"];
6665 [label="param IsBinaryExpression(SyntaxKind token) 158312"];
6666 [label="return GetBinaryExpression(token) != SyntaxKind.None; 158313"];
6667 [label="GetBinaryExpression(token) 158314"];
6668 [label="param GetBinaryExpression(SyntaxKind token) 158315"];
6669 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 158316"];
6670 [label="return SyntaxKind.None; 158317"];
6671 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158318"];
6672 [label="IsExpectedAssignmentOperator(tk) 158319"];
6673 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 158320"];
6674 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 158321"];
6675 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 158322"];
6676 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 158323"];
6677 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 158324"];
6678 [label="return false; 158325"];
6679 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158326"];
6680 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158327"];
6681 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158328"];
6682 [label="CurrentToken 158329"];
6683 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158330"];
6684 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158331"];
6685 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 158332"];
6686 [label="CurrentToken.Kind 158333"];
6687 [label="get { return (SyntaxKind)this.RawKind; } 158334"];
6688 [label="return leftOperand; 158335"];
6689 [label="_ = GetPrecedence(result.Kind); 158336"];
6690 [label="result.Kind 158337"];
6691 [label="get { return (SyntaxKind)this.RawKind; } 158338"];
6692 [label="_ = GetPrecedence(result.Kind); 158339"];
6693 [label="GetPrecedence(result.Kind) 158340"];
6694 [label="param GetPrecedence(SyntaxKind op) 158341"];
6695 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 158342"];
6696 [label="return Precedence.Primary; 158343"];
6697 [label="_recursionDepth 158344"];
6698 [label="return result; 158345"];
6699 [label="this.CurrentToken 158346"];
6700 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158347"];
6701 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158348"];
6702 [label="if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        var firstArg = _syntaxFactory.Argument(nameColon: null, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 158349"];
6703 [label="this.CurrentToken.Kind 158350"];
6704 [label="get { return (SyntaxKind)this.RawKind; } 158351"];
6705 [label="expression.Kind 158352"];
6706 [label="get { return (SyntaxKind)this.RawKind; } 158353"];
6707 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 158354"];
6708 [label="this.CurrentToken 158355"];
6709 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158356"];
6710 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158357"];
6711 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 158358"];
6712 [label="this.CurrentToken.Kind 158359"];
6713 [label="get { return (SyntaxKind)this.RawKind; } 158360"];
6714 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 158361"];
6715 [label="var closeParen = this.EatToken(SyntaxKind.CloseParenToken); 158362"];
6716 [label="this.EatToken(SyntaxKind.CloseParenToken) 158363"];
6717 [label="param EatToken(SyntaxKind kind) 158364"];
6718 [label="param EatToken(this) 158365"];
6719 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 158366"];
6720 [label="SyntaxFacts.IsAnyToken(kind) 158367"];
6721 [label="param IsAnyToken(SyntaxKind kind) 158368"];
6722 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 158369"];
6723 [label="return true; 158370"];
6724 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158371"];
6725 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 158372"];
6726 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158373"];
6727 [label="MoveToNextToken(); 158374"];
6728 [label="return ct; 158375"];
6729 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 158376"];
6730 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 158377"];
6731 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 158378"];
6732 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 158379"];
6733 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 158380"];
6734 [label="param TryGetNode(int kind) 158381"];
6735 [label="param TryGetNode(GreenNode child1) 158382"];
6736 [label="param TryGetNode(GreenNode child2) 158383"];
6737 [label="param TryGetNode(GreenNode child3) 158384"];
6738 [label="param TryGetNode(SyntaxFactoryContext context) 158385"];
6739 [label="param TryGetNode(out int hash) 158386"];
6740 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 158387"];
6741 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 158388"];
6742 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 158389"];
6743 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 158390"];
6744 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 158391"];
6745 [label="GetNodeFlags(context) 158392"];
6746 [label="param GetNodeFlags(SyntaxFactoryContext context) 158393"];
6747 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 158394"];
6748 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 158395"];
6749 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 158396"];
6750 [label="return flags; 158397"];
6751 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 158398"];
6752 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 158399"];
6753 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 158400"];
6754 [label="param CSharpSyntaxNode(this) 158401"];
6755 [label="GreenStats.NoteGreen(this); 158402"];
6756 [label="param SetFactoryContext(SyntaxFactoryContext context) 158403"];
6757 [label="param SetFactoryContext(this) 158404"];
6758 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 158405"];
6759 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 158406"];
6760 [label="this.Release(ref resetPoint); 158407"];
6761 [label="this.Release(ref resetPoint) 158408"];
6762 [label="param Release(ref ResetPoint state) 158409"];
6763 [label="param Release(this) 158410"];
6764 [label="base.Release(ref state.BaseResetPoint); 158411"];
6765 [label="base.Release(ref state.BaseResetPoint) 158412"];
6766 [label="param Release(ref ResetPoint point) 158413"];
6767 [label="param Release(this) 158414"];
6768 [label="Debug.Assert(_resetCount == point.ResetCount); 158415"];
6769 [label="_resetCount 158416"];
6770 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 158417"];
6771 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 158418"];
6772 [label="base.Release(ref state.BaseResetPoint); 158419"];
6773 [label="this.Release(ref resetPoint); 158420"];
6774 [label="return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence); 158421"];
6775 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 158422"];
6776 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 158423"];
6777 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158424"];
6778 [label="return ParseExpressionContinued(leftOperand, precedence); 158425"];
6779 [label="ParseExpressionContinued(leftOperand, precedence) 158426"];
6780 [label="param ParseExpressionContinued(Precedence precedence) 158427"];
6781 [label="param ParseExpressionContinued(this) 158428"];
6782 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 158429"];
6783 [label="this.CurrentToken 158430"];
6784 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158431"];
6785 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158432"];
6786 [label="var tk = this.CurrentToken.ContextualKind; 158433"];
6787 [label="this.CurrentToken.ContextualKind 158434"];
6788 [label="get\n            {\n                return this.Kind;\n            } 158435"];
6789 [label="this.Kind 158436"];
6790 [label="bool isAssignmentOperator = false; 158437"];
6791 [label="SyntaxKind opKind; 158438"];
6792 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158439"];
6793 [label="IsExpectedBinaryOperator(tk) 158440"];
6794 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 158441"];
6795 [label="return SyntaxFacts.IsBinaryExpression(kind); 158442"];
6796 [label="SyntaxFacts.IsBinaryExpression(kind) 158443"];
6797 [label="param IsBinaryExpression(SyntaxKind token) 158444"];
6798 [label="return GetBinaryExpression(token) != SyntaxKind.None; 158445"];
6799 [label="GetBinaryExpression(token) 158446"];
6800 [label="param GetBinaryExpression(SyntaxKind token) 158447"];
6801 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 158448"];
6802 [label="return SyntaxKind.None; 158449"];
6803 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158450"];
6804 [label="IsExpectedAssignmentOperator(tk) 158451"];
6805 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 158452"];
6806 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 158453"];
6807 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 158454"];
6808 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 158455"];
6809 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 158456"];
6810 [label="return false; 158457"];
6811 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158458"];
6812 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158459"];
6813 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158460"];
6814 [label="CurrentToken 158461"];
6815 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158462"];
6816 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158463"];
6817 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 158464"];
6818 [label="CurrentToken.Kind 158465"];
6819 [label="get { return (SyntaxKind)this.RawKind; } 158466"];
6820 [label="_ = GetPrecedence(result.Kind); 158467"];
6821 [label="result.Kind 158468"];
6822 [label="get { return (SyntaxKind)this.RawKind; } 158469"];
6823 [label="_ = GetPrecedence(result.Kind); 158470"];
6824 [label="GetPrecedence(result.Kind) 158471"];
6825 [label="param GetPrecedence(SyntaxKind op) 158472"];
6826 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 158473"];
6827 [label="return Precedence.Primary; 158474"];
6828 [label="var expression = this.ParseExpressionCore(); 158475"];
6829 [label="SyntaxToken openParen; 158476"];
6830 [label="SyntaxToken closeParen; 158477"];
6831 [label="expression.Kind 158478"];
6832 [label="get { return (SyntaxKind)this.RawKind; } 158479"];
6833 [label="if (expression.Kind == SyntaxKind.ParenthesizedExpression)\n            {\n                var parenExpression = (ParenthesizedExpressionSyntax)expression;\n                openParen = parenExpression.OpenParenToken;\n                expression = parenExpression.Expression;\n                closeParen = parenExpression.CloseParenToken;\n\n                Debug.Assert(parenExpression.GetDiagnostics().Length == 0);\n            }\n            else if (expression.Kind == SyntaxKind.TupleExpression)\n            {\n                // As a special case, when a tuple literal is the governing expression of\n                // a switch statement we permit the switch statement's own parentheses to be omitted.\n                // LDM 2018-04-04.\n                openParen = closeParen = null;\n            }\n            else\n            {\n                // Some other expression has appeared without parens. Give a syntax error.\n                openParen = SyntaxFactory.MissingToken(SyntaxKind.OpenParenToken);\n                expression = this.AddError(expression, ErrorCode.ERR_SwitchGoverningExpressionRequiresParens);\n                closeParen = SyntaxFactory.MissingToken(SyntaxKind.CloseParenToken);\n            } 158480"];
6834 [label="var parenExpression = (ParenthesizedExpressionSyntax)expression; 158481"];
6835 [label="openParen = parenExpression.OpenParenToken; 158482"];
6836 [label="expression = parenExpression.Expression; 158483"];
6837 [label="closeParen = parenExpression.CloseParenToken; 158484"];
6838 [label="Debug.Assert(parenExpression.GetDiagnostics().Length == 0); 158485"];
6839 [label="Debug.Assert(parenExpression.GetDiagnostics().Length == 0); 158486"];
6840 [label="var openBrace = this.EatToken(SyntaxKind.OpenBraceToken); 158487"];
6841 [label="this.EatToken(SyntaxKind.OpenBraceToken) 158488"];
6842 [label="param EatToken(SyntaxKind kind) 158489"];
6843 [label="param EatToken(this) 158490"];
6844 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 158491"];
6845 [label="SyntaxFacts.IsAnyToken(kind) 158492"];
6846 [label="param IsAnyToken(SyntaxKind kind) 158493"];
6847 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 158494"];
6848 [label="return true; 158495"];
6849 [label="this.CurrentToken 158496"];
6850 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158497"];
6851 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158498"];
6852 [label="ct.Kind 158499"];
6853 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 158500"];
6854 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158501"];
6855 [label="MoveToNextToken(); 158502"];
6856 [label="var sections = _pool.Allocate<SwitchSectionSyntax>(); 158503"];
6857 [label="this.IsPossibleSwitchSection() 158504"];
6858 [label="param IsPossibleSwitchSection(this) 158505"];
6859 [label="this.CurrentToken 158506"];
6860 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158507"];
6861 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158508"];
6862 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 158509"];
6863 [label="return (this.CurrentToken.Kind == SyntaxKind.CaseKeyword) ||\n                   (this.CurrentToken.Kind == SyntaxKind.DefaultKeyword && this.PeekToken(1).Kind != SyntaxKind.OpenParenToken); 158510"];
6864 [label="this.CurrentToken.Kind 158511"];
6865 [label="get { return (SyntaxKind)this.RawKind; } 158512"];
6866 [label="while (this.IsPossibleSwitchSection())\n                {\n                    var swcase = this.ParseSwitchSection();\n                    sections.Add(swcase);\n                } 158513"];
6867 [label="this.ParseSwitchSection() 158514"];
6868 [label="param ParseSwitchSection(this) 158515"];
6869 [label="this.IsPossibleSwitchSection() 158516"];
6870 [label="param IsPossibleSwitchSection(this) 158517"];
6871 [label="Debug.Assert(this.IsPossibleSwitchSection()); 158518"];
6872 [label="var labels = _pool.Allocate<SwitchLabelSyntax>(); 158519"];
6873 [label="var statements = _pool.Allocate<StatementSyntax>(); 158520"];
6874 [label="SyntaxToken specifier; 158521"];
6875 [label="SwitchLabelSyntax label; 158522"];
6876 [label="SyntaxToken colon; 158523"];
6877 [label="this.CurrentToken 158524"];
6878 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158525"];
6879 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158526"];
6880 [label="if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = _syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    } 158527"];
6881 [label="this.CurrentToken.Kind 158528"];
6882 [label="get { return (SyntaxKind)this.RawKind; } 158529"];
6883 [label="ExpressionSyntax expression; 158530"];
6884 [label="this.EatToken() 158531"];
6885 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158532"];
6886 [label="MoveToNextToken(); 158533"];
6887 [label="specifier = this.EatToken(); 158534"];
6888 [label="this.CurrentToken 158535"];
6889 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158536"];
6890 [label="return _lexedTokens[_tokenOffset]; 158537"];
6891 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        } 158538"];
6892 [label="this.CurrentToken.Kind 158539"];
6893 [label="get { return (SyntaxKind)this.RawKind; } 158540"];
6894 [label="ParseExpressionOrPatternForSwitchStatement() 158541"];
6895 [label="param ParseExpressionOrPatternForSwitchStatement(this) 158542"];
6896 [label="ParseExpressionOrPatternForSwitchStatementCore() 158543"];
6897 [label="param ParseExpressionOrPatternForSwitchStatementCore(this) 158544"];
6898 [label="var pattern = ParsePattern(Precedence.Conditional, whenIsKeyword: true); 158545"];
6899 [label="var pattern = ParsePattern(Precedence.Conditional, whenIsKeyword: true); 158546"];
6900 [label="ParsePattern(Precedence.Conditional, whenIsKeyword: true) 158547"];
6901 [label="param ParsePattern(Precedence precedence) 158548"];
6902 [label="param ParsePattern(bool afterIs = false) 158549"];
6903 [label="param ParsePattern(bool whenIsKeyword = false) 158550"];
6904 [label="param ParsePattern(this) 158551"];
6905 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 158552"];
6906 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 158553"];
6907 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 158554"];
6908 [label="ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword) 158555"];
6909 [label="param ParseDisjunctivePattern(Precedence precedence) 158556"];
6910 [label="param ParseDisjunctivePattern(bool afterIs) 158557"];
6911 [label="param ParseDisjunctivePattern(bool whenIsKeyword) 158558"];
6912 [label="param ParseDisjunctivePattern(this) 158559"];
6913 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 158560"];
6914 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 158561"];
6915 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 158562"];
6916 [label="ParseConjunctivePattern(precedence, afterIs, whenIsKeyword) 158563"];
6917 [label="param ParseConjunctivePattern(Precedence precedence) 158564"];
6918 [label="param ParseConjunctivePattern(bool afterIs) 158565"];
6919 [label="param ParseConjunctivePattern(bool whenIsKeyword) 158566"];
6920 [label="param ParseConjunctivePattern(this) 158567"];
6921 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 158568"];
6922 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 158569"];
6923 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 158570"];
6924 [label="ParseNegatedPattern(precedence, afterIs, whenIsKeyword) 158571"];
6925 [label="param ParseNegatedPattern(Precedence precedence) 158572"];
6926 [label="param ParseNegatedPattern(bool afterIs) 158573"];
6927 [label="param ParseNegatedPattern(bool whenIsKeyword) 158574"];
6928 [label="param ParseNegatedPattern(this) 158575"];
6929 [label="this.CurrentToken 158576"];
6930 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158577"];
6931 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.NotKeyword)\n            {\n                var notToken = ConvertToKeyword(this.EatToken());\n                var pattern = ParseNegatedPattern(precedence, afterIs, whenIsKeyword);\n                var result = _syntaxFactory.UnaryPattern(notToken, pattern);\n                return CheckFeatureAvailability(result, MessageID.IDS_FeatureNotPattern);\n            }\n            else\n            {\n                return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword);\n            } 158578"];
6932 [label="this.CurrentToken.ContextualKind 158579"];
6933 [label="get\n            {\n                return this.Kind;\n            } 158580"];
6934 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 158581"];
6935 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 158582"];
6936 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 158583"];
6937 [label="ParsePrimaryPattern(precedence, afterIs, whenIsKeyword) 158584"];
6938 [label="param ParsePrimaryPattern(Precedence precedence) 158585"];
6939 [label="param ParsePrimaryPattern(bool afterIs) 158586"];
6940 [label="param ParsePrimaryPattern(bool whenIsKeyword) 158587"];
6941 [label="param ParsePrimaryPattern(this) 158588"];
6942 [label="this.CurrentToken 158589"];
6943 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158590"];
6944 [label="var tk = this.CurrentToken.Kind; 158591"];
6945 [label="this.CurrentToken.Kind 158592"];
6946 [label="get { return (SyntaxKind)this.RawKind; } 158593"];
6947 [label="switch (tk)\n            {\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return _syntaxFactory.ConstantPattern(this.ParseIdentifierName(ErrorCode.ERR_MissingPattern));\n            } 158594"];
6948 [label="CurrentToken 158595"];
6949 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158596"];
6950 [label="if (CurrentToken.ContextualKind == SyntaxKind.UnderscoreToken)\n            {\n                return _syntaxFactory.DiscardPattern(this.EatContextualToken(SyntaxKind.UnderscoreToken));\n            } 158597"];
6951 [label="CurrentToken.ContextualKind 158598"];
6952 [label="get\n            {\n                return this.Kind;\n            } 158599"];
6953 [label="CurrentToken 158600"];
6954 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158601"];
6955 [label="switch (CurrentToken.Kind)\n            {\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                    // this is a relational pattern.\n                    var relationalToken = this.EatToken();\n                    Debug.Assert(precedence < Precedence.Shift);\n                    var expression = this.ParseSubExpression(Precedence.Relational);\n                    var result = _syntaxFactory.RelationalPattern(relationalToken, expression);\n                    return CheckFeatureAvailability(result, MessageID.IDS_FeatureRelationalPattern);\n            } 158602"];
6956 [label="CurrentToken.Kind 158603"];
6957 [label="get { return (SyntaxKind)this.RawKind; } 158604"];
6958 [label="this.GetResetPoint() 158605"];
6959 [label="param GetResetPoint(this) 158606"];
6960 [label="var resetPoint = this.GetResetPoint(); 158607"];
6961 [label="TypeSyntax type = null; 158608"];
6962 [label="LooksLikeTypeOfPattern() 158609"];
6963 [label="param LooksLikeTypeOfPattern(this) 158610"];
6964 [label="CurrentToken 158611"];
6965 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158612"];
6966 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158613"];
6967 [label="var tk = CurrentToken.Kind; 158614"];
6968 [label="CurrentToken.Kind 158615"];
6969 [label="get { return (SyntaxKind)this.RawKind; } 158616"];
6970 [label="if (SyntaxFacts.IsPredefinedType(tk))\n            {\n                return true;\n            } 158617"];
6971 [label="SyntaxFacts.IsPredefinedType(tk) 158618"];
6972 [label="param IsPredefinedType(SyntaxKind kind) 158619"];
6973 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 158620"];
6974 [label="this.CurrentToken 158621"];
6975 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158622"];
6976 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158623"];
6977 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 158624"];
6978 [label="this.CurrentToken.ContextualKind 158625"];
6979 [label="get\n            {\n                return this.Kind;\n            } 158626"];
6980 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 158627"];
6981 [label="this.CurrentToken 158628"];
6982 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158629"];
6983 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158630"];
6984 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 158631"];
6985 [label="this.CurrentToken.ContextualKind 158632"];
6986 [label="get\n            {\n                return this.Kind;\n            } 158633"];
6987 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 158634"];
6988 [label="return true; 158635"];
6989 [label="if (LooksLikeTypeOfPattern())\n                {\n                    type = this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern);\n                    if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    }\n                } 158636"];
6990 [label="afterIs 158637"];
6991 [label="type = this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern); 158638"];
6992 [label="this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern) 158639"];
6993 [label="param ParseType(ParseTypeMode mode = ParseTypeMode.Normal) 158640"];
6994 [label="param ParseType(this) 158641"];
6995 [label="this.CurrentToken 158642"];
6996 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158643"];
6997 [label="if (this.CurrentToken.Kind == SyntaxKind.RefKeyword)\n            {\n                var refKeyword = this.EatToken();\n                refKeyword = this.CheckFeatureAvailability(refKeyword, MessageID.IDS_FeatureRefLocalsReturns);\n\n                SyntaxToken readonlyKeyword = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                {\n                    readonlyKeyword = this.EatToken();\n                    readonlyKeyword = this.CheckFeatureAvailability(readonlyKeyword, MessageID.IDS_FeatureReadOnlyReferences);\n                }\n\n                var type = ParseTypeCore(ParseTypeMode.AfterRef);\n                return _syntaxFactory.RefType(refKeyword, readonlyKeyword, type);\n            } 158644"];
6998 [label="this.CurrentToken.Kind 158645"];
6999 [label="get { return (SyntaxKind)this.RawKind; } 158646"];
7000 [label="return ParseTypeCore(mode); 158647"];
7001 [label="return ParseTypeCore(mode); 158648"];
7002 [label="return ParseTypeCore(mode); 158649"];
7003 [label="param ParseUnderlyingType(ParseTypeMode mode) 158650"];
7004 [label="param ParseUnderlyingType(NameOptions options = NameOptions.None) 158651"];
7005 [label="param ParseUnderlyingType(this) 158652"];
7006 [label="this.CurrentToken 158653"];
7007 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158654"];
7008 [label="if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, mode == ParseTypeMode.Parameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return _syntaxFactory.PredefinedType(token);\n            } 158655"];
7009 [label="this.CurrentToken.Kind 158656"];
7010 [label="get { return (SyntaxKind)this.RawKind; } 158657"];
7011 [label="IsPredefinedType(this.CurrentToken.Kind) 158658"];
7012 [label="param IsPredefinedType(SyntaxKind keyword) 158659"];
7013 [label="IsTrueIdentifier() 158660"];
7014 [label="param IsTrueIdentifier(this) 158661"];
7015 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 158662"];
7016 [label="this.CurrentToken 158663"];
7017 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158664"];
7018 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 158665"];
7019 [label="this.CurrentToken.ContextualKind 158666"];
7020 [label="get\n            {\n                return this.Kind;\n            } 158667"];
7021 [label="if (IsTrueIdentifier() || this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                return this.ParseQualifiedName(options);\n            } 158668"];
7022 [label="return this.ParseQualifiedName(options); 158669"];
7023 [label="this.ParseQualifiedName(options) 158670"];
7024 [label="param ParseQualifiedName(NameOptions options = NameOptions.None) 158671"];
7025 [label="param ParseQualifiedName(this) 158672"];
7026 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 158673"];
7027 [label="this.ParseAliasQualifiedName(options) 158674"];
7028 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 158675"];
7029 [label="param ParseAliasQualifiedName(this) 158676"];
7030 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 158677"];
7031 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 158678"];
7032 [label="this.IsIncrementalAndFactoryContextMatches 158679"];
7033 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 158680"];
7034 [label="base.IsIncremental 158681"];
7035 [label="get\n            {\n                return _isIncremental;\n            } 158682"];
7036 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 158683"];
7037 [label="return false; 158684"];
7038 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 158685"];
7039 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 158686"];
7040 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 158687"];
7041 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 158688"];
7042 [label="this.CurrentToken 158689"];
7043 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158690"];
7044 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 158691"];
7045 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 158692"];
7046 [label="IsCurrentTokenQueryKeywordInQuery() 158693"];
7047 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 158694"];
7048 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 158695"];
7049 [label="param GetTrailingTrivia(this) 158696"];
7050 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158697"];
7051 [label="MoveToNextToken(); 158698"];
7052 [label="this.IsInAsync 158699"];
7053 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 158700"];
7054 [label="return _syntaxFactoryContext.IsInAsync; 158701"];
7055 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 158702"];
7056 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 158703"];
7057 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158704"];
7058 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 158705"];
7059 [label="this.CurrentToken.Kind 158706"];
7060 [label="get { return (SyntaxKind)this.RawKind; } 158707"];
7061 [label="this.CurrentToken 158708"];
7062 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158709"];
7063 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 158710"];
7064 [label="this.CurrentToken.Kind 158711"];
7065 [label="get { return (SyntaxKind)this.RawKind; } 158712"];
7066 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 158713"];
7067 [label="this.IsDotOrColonColon() 158714"];
7068 [label="param IsDotOrColonColon(this) 158715"];
7069 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158716"];
7070 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 158717"];
7071 [label="this.CurrentToken 158718"];
7072 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158719"];
7073 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158720"];
7074 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 158721"];
7075 [label="this.CurrentToken.Kind 158722"];
7076 [label="get { return (SyntaxKind)this.RawKind; } 158723"];
7077 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 158724"];
7078 [label="return name; 158725"];
7079 [label="return this.ParseQualifiedName(options); 158726"];
7080 [label="param IsMakingProgress(bool assertIfFalse = true) 158727"];
7081 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 158728"];
7082 [label="CanTokenFollowTypeInPattern(precedence) 158729"];
7083 [label="param CanTokenFollowTypeInPattern(Precedence precedence) 158730"];
7084 [label="param CanTokenFollowTypeInPattern(this) 158731"];
7085 [label="this.CurrentToken 158732"];
7086 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158733"];
7087 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158734"];
7088 [label="switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.CloseBraceToken:   // for efficiency, test some tokens that can follow a type pattern\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                    return true;\n                case SyntaxKind.DotToken:\n                    // int.MaxValue is an expression, not a type.\n                    return false;\n                case var kind:\n                    // If we find what looks like a continuation of an expression, it is not a type.\n                    return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence;\n            } 158735"];
7089 [label="this.CurrentToken.Kind 158736"];
7090 [label="get { return (SyntaxKind)this.RawKind; } 158737"];
7091 [label="return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence; 158738"];
7092 [label="SyntaxFacts.IsBinaryExpressionOperatorToken(kind) 158739"];
7093 [label="param IsBinaryExpressionOperatorToken(SyntaxKind token) 158740"];
7094 [label="return GetBinaryExpression(token) != SyntaxKind.None; 158741"];
7095 [label="GetBinaryExpression(token) 158742"];
7096 [label="param GetBinaryExpression(SyntaxKind token) 158743"];
7097 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 158744"];
7098 [label="return SyntaxKind.None; 158745"];
7099 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 158746"];
7100 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 158747"];
7101 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 158748"];
7102 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 158749"];
7103 [label="ParsePatternContinued(type, precedence, whenIsKeyword) 158750"];
7104 [label="param ParsePatternContinued(TypeSyntax type) 158751"];
7105 [label="param ParsePatternContinued(Precedence precedence) 158752"];
7106 [label="param ParsePatternContinued(bool whenIsKeyword) 158753"];
7107 [label="param ParsePatternContinued(this) 158754"];
7108 [label=".Kind 158755"];
7109 [label="get { return (SyntaxKind)this.RawKind; } 158756"];
7110 [label="if (type?.Kind == SyntaxKind.IdentifierName)\n            {\n                var typeIdentifier = (IdentifierNameSyntax)type;\n                var typeIdentifierToken = typeIdentifier.Identifier;\n                if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                }\n            } 158757"];
7111 [label="var typeIdentifier = (IdentifierNameSyntax)type; 158758"];
7112 [label="var typeIdentifierToken = typeIdentifier.Identifier; 158759"];
7113 [label="typeIdentifierToken.ContextualKind 158760"];
7114 [label="get\n            {\n                return this.Kind;\n            } 158761"];
7115 [label="if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                } 158762"];
7116 [label="this.CurrentToken 158763"];
7117 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158764"];
7118 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158765"];
7119 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken && (type != null || !looksLikeCast()))\n            {\n                // It is possible this is a parenthesized (constant) expression.\n                // We normalize later.\n                ParseSubpatternList(\n                    openToken: out SyntaxToken openParenToken,\n                    subPatterns: out SeparatedSyntaxList<SubpatternSyntax> subPatterns,\n                    closeToken: out SyntaxToken closeParenToken,\n                    openKind: SyntaxKind.OpenParenToken,\n                    closeKind: SyntaxKind.CloseParenToken);\n\n                parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause0);\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n\n                if (type == null &&\n                    propertyPatternClause0 == null &&\n                    designation0 == null &&\n                    subPatterns.Count == 1 &&\n                    subPatterns.SeparatorCount == 0 &&\n                    subPatterns[0].NameColon == null)\n                {\n                    var subpattern = subPatterns[0].Pattern;\n                    switch (subpattern)\n                    {\n                        case ConstantPatternSyntax cp:\n                            // There is an ambiguity between a positional pattern `(` pattern `)`\n                            // and a constant expression pattern that happens to be parenthesized.\n                            // Per 2017-11-20 LDM we treat such syntax as a parenthesized expression always.\n                            ExpressionSyntax expression = _syntaxFactory.ParenthesizedExpression(openParenToken, cp.Expression, closeParenToken);\n                            expression = ParseExpressionContinued(expression, precedence);\n                            return _syntaxFactory.ConstantPattern(expression);\n                        default:\n                            var parenthesizedPattern = _syntaxFactory.ParenthesizedPattern(openParenToken, subPatterns[0].Pattern, closeParenToken);\n                            return CheckFeatureAvailability(parenthesizedPattern, MessageID.IDS_FeatureParenthesizedPattern);\n                    }\n                }\n\n                var positionalPatternClause = _syntaxFactory.PositionalPatternClause(openParenToken, subPatterns, closeParenToken);\n                var result = _syntaxFactory.RecursivePattern(type, positionalPatternClause, propertyPatternClause0, designation0);\n                return result;\n            } 158766"];
7120 [label="this.CurrentToken.Kind 158767"];
7121 [label="get { return (SyntaxKind)this.RawKind; } 158768"];
7122 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 158769"];
7123 [label="parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause) 158770"];
7124 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 158771"];
7125 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 158772"];
7126 [label="propertyPatternClauseResult = null; 158773"];
7127 [label="this.CurrentToken 158774"];
7128 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158775"];
7129 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158776"];
7130 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                } 158777"];
7131 [label="this.CurrentToken.Kind 158778"];
7132 [label="get { return (SyntaxKind)this.RawKind; } 158779"];
7133 [label="return false; 158780"];
7134 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 158781"];
7135 [label="if (type != null)\n            {\n                if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                }\n            } 158782"];
7136 [label="if (type != null)\n            {\n                if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                }\n            } 158783"];
7137 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 158784"];
7138 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 158785"];
7139 [label="parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation) 158786"];
7140 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 158787"];
7141 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 158788"];
7142 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 158789"];
7143 [label="designationResult = null; 158790"];
7144 [label="this.IsTrueIdentifier() 158791"];
7145 [label="param IsTrueIdentifier(this) 158792"];
7146 [label="return false; 158793"];
7147 [label="if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                } 158794"];
7148 [label="return false; 158795"];
7149 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 158796"];
7150 [label="if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    } 158797"];
7151 [label="if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    } 158798"];
7152 [label="ConvertTypeToExpression(type, out var expression) 158799"];
7153 [label="param ConvertTypeToExpression(TypeSyntax type) 158800"];
7154 [label="param ConvertTypeToExpression(out ExpressionSyntax expr) 158801"];
7155 [label="param ConvertTypeToExpression(bool permitTypeArguments = false) 158802"];
7156 [label="param ConvertTypeToExpression(this) 158803"];
7157 [label="expr = null; 158804"];
7158 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 158805"];
7159 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 158806"];
7160 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 158807"];
7161 [label="expr = s; 158808"];
7162 [label="return true; 158809"];
7163 [label="expression = ParseExpressionContinued(expression, precedence); 158810"];
7164 [label="expression = ParseExpressionContinued(expression, precedence); 158811"];
7165 [label="ParseExpressionContinued(expression, precedence) 158812"];
7166 [label="param ParseExpressionContinued(ExpressionSyntax leftOperand) 158813"];
7167 [label="param ParseExpressionContinued(Precedence precedence) 158814"];
7168 [label="param ParseExpressionContinued(this) 158815"];
7169 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 158816"];
7170 [label="this.CurrentToken 158817"];
7171 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158818"];
7172 [label="var tk = this.CurrentToken.ContextualKind; 158819"];
7173 [label="this.CurrentToken.ContextualKind 158820"];
7174 [label="get\n            {\n                return this.Kind;\n            } 158821"];
7175 [label="bool isAssignmentOperator = false; 158822"];
7176 [label="SyntaxKind opKind; 158823"];
7177 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158824"];
7178 [label="IsExpectedBinaryOperator(tk) 158825"];
7179 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 158826"];
7180 [label="return SyntaxFacts.IsBinaryExpression(kind); 158827"];
7181 [label="SyntaxFacts.IsBinaryExpression(kind) 158828"];
7182 [label="param IsBinaryExpression(SyntaxKind token) 158829"];
7183 [label="return GetBinaryExpression(token) != SyntaxKind.None; 158830"];
7184 [label="GetBinaryExpression(token) 158831"];
7185 [label="param GetBinaryExpression(SyntaxKind token) 158832"];
7186 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 158833"];
7187 [label="return SyntaxKind.None; 158834"];
7188 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158835"];
7189 [label="IsExpectedAssignmentOperator(tk) 158836"];
7190 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 158837"];
7191 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 158838"];
7192 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 158839"];
7193 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 158840"];
7194 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 158841"];
7195 [label="return false; 158842"];
7196 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158843"];
7197 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158844"];
7198 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 158845"];
7199 [label="CurrentToken 158846"];
7200 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158847"];
7201 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 158848"];
7202 [label="CurrentToken.Kind 158849"];
7203 [label="get { return (SyntaxKind)this.RawKind; } 158850"];
7204 [label="return _syntaxFactory.ConstantPattern(expression); 158851"];
7205 [label="return _syntaxFactory.ConstantPattern(expression); 158852"];
7206 [label="return _syntaxFactory.ConstantPattern(expression); 158853"];
7207 [label="param TryGetNode(int kind) 158854"];
7208 [label="param TryGetNode(GreenNode child1) 158855"];
7209 [label="param TryGetNode(SyntaxFactoryContext context) 158856"];
7210 [label="param TryGetNode(out int hash) 158857"];
7211 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 158858"];
7212 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 158859"];
7213 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 158860"];
7214 [label="GetNodeFlags(context) 158861"];
7215 [label="param GetNodeFlags(SyntaxFactoryContext context) 158862"];
7216 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 158863"];
7217 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 158864"];
7218 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 158865"];
7219 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 158866"];
7220 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 158867"];
7221 [label="param SetFactoryContext(SyntaxFactoryContext context) 158868"];
7222 [label="param SetFactoryContext(this) 158869"];
7223 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 158870"];
7224 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 158871"];
7225 [label="if (p != null)\n                    return p; 158872"];
7226 [label="if (p != null)\n                    return p; 158873"];
7227 [label="return p; 158874"];
7228 [label="this.Release(ref resetPoint); 158875"];
7229 [label="this.Release(ref resetPoint) 158876"];
7230 [label="param Release(ref ResetPoint state) 158877"];
7231 [label="base.Release(ref state.BaseResetPoint); 158878"];
7232 [label="param Release(ref ResetPoint point) 158879"];
7233 [label="Debug.Assert(_resetCount == point.ResetCount); 158880"];
7234 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 158881"];
7235 [label="base.Release(ref state.BaseResetPoint); 158882"];
7236 [label="this.Release(ref resetPoint); 158883"];
7237 [label="this.CurrentToken 158884"];
7238 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158885"];
7239 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158886"];
7240 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.AndKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseNegatedPattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.AndPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureAndPattern);\n            } 158887"];
7241 [label="this.CurrentToken.ContextualKind 158888"];
7242 [label="get\n            {\n                return this.Kind;\n            } 158889"];
7243 [label="return result; 158890"];
7244 [label="this.CurrentToken 158891"];
7245 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158892"];
7246 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158893"];
7247 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.OrKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.OrPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureOrPattern);\n            } 158894"];
7248 [label="this.CurrentToken.ContextualKind 158895"];
7249 [label="get\n            {\n                return this.Kind;\n            } 158896"];
7250 [label="return result; 158897"];
7251 [label="pattern switch\n            {\n                ConstantPatternSyntax cp => cp.Expression,\n                TypePatternSyntax tp when ConvertTypeToExpression(tp.Type, out ExpressionSyntax expr) => expr,\n                DiscardPatternSyntax dp => _syntaxFactory.IdentifierName(ConvertToIdentifier(dp.UnderscoreToken)),\n                var p => p,\n            } 158898"];
7252 [label="return pattern switch\n            {\n                ConstantPatternSyntax cp => cp.Expression,\n                TypePatternSyntax tp when ConvertTypeToExpression(tp.Type, out ExpressionSyntax expr) => expr,\n                DiscardPatternSyntax dp => _syntaxFactory.IdentifierName(ConvertToIdentifier(dp.UnderscoreToken)),\n                var p => p,\n            }; 158899"];
7253 [label="return CheckRecursivePatternFeature(ParseExpressionOrPatternForSwitchStatementCore()); 158900"];
7254 [label="CheckRecursivePatternFeature(ParseExpressionOrPatternForSwitchStatementCore()) 158901"];
7255 [label="param CheckRecursivePatternFeature(CSharpSyntaxNode node) 158902"];
7256 [label="param CheckRecursivePatternFeature(this) 158903"];
7257 [label="node.Kind 158904"];
7258 [label="get { return (SyntaxKind)this.RawKind; } 158905"];
7259 [label="switch (node.Kind)\n            {\n                case SyntaxKind.RecursivePattern:\n                case SyntaxKind.DiscardPattern:\n                case SyntaxKind.VarPattern when ((VarPatternSyntax)node).Designation.Kind == SyntaxKind.ParenthesizedVariableDesignation:\n                    return this.CheckFeatureAvailability(node, MessageID.IDS_FeatureRecursivePatterns);\n                default:\n                    return node;\n            } 158906"];
7260 [label="return node; 158907"];
7261 [label="var node = ParseExpressionOrPatternForSwitchStatement(); 158908"];
7262 [label="this.CurrentToken 158909"];
7263 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158910"];
7264 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex); 158911"];
7265 [label="this.CurrentToken.ContextualKind 158912"];
7266 [label="get\n            {\n                return this.Kind;\n            } 158913"];
7267 [label="node.Kind 158914"];
7268 [label="get { return (SyntaxKind)this.RawKind; } 158915"];
7269 [label="if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement); 158916"];
7270 [label="if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            } 158917"];
7271 [label="colon = this.EatToken(SyntaxKind.ColonToken); 158918"];
7272 [label="this.EatToken(SyntaxKind.ColonToken) 158919"];
7273 [label="param EatToken(SyntaxKind kind) 158920"];
7274 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 158921"];
7275 [label="SyntaxFacts.IsAnyToken(kind) 158922"];
7276 [label="param IsAnyToken(SyntaxKind kind) 158923"];
7277 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 158924"];
7278 [label="return true; 158925"];
7279 [label="param GetTrailingTrivia(this) 158926"];
7280 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 158927"];
7281 [label="MoveToNextToken(); 158928"];
7282 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 158929"];
7283 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 158930"];
7284 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 158931"];
7285 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 158932"];
7286 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 158933"];
7287 [label="param TryGetNode(SyntaxFactoryContext context) 158934"];
7288 [label="param GetNodeFlags(SyntaxFactoryContext context) 158935"];
7289 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 158936"];
7290 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 158937"];
7291 [label="param SetFactoryContext(SyntaxFactoryContext context) 158938"];
7292 [label="param SetFactoryContext(this) 158939"];
7293 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 158940"];
7294 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 158941"];
7295 [label="labels.Add(label); 158942"];
7296 [label="IsPossibleSwitchSection() 158943"];
7297 [label="param IsPossibleSwitchSection(this) 158944"];
7298 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 158945"];
7299 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 158946"];
7300 [label="this.CurrentToken 158947"];
7301 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158948"];
7302 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158949"];
7303 [label="this.CurrentToken.Kind 158950"];
7304 [label="get { return (SyntaxKind)this.RawKind; } 158951"];
7305 [label="do\n                {\n                    SyntaxToken specifier;\n                    SwitchLabelSyntax label;\n                    SyntaxToken colon;\n                    if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = _syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    }\n\n                    labels.Add(label);\n                }\n                while (IsPossibleSwitchSection()); 158952"];
7306 [label="CSharpSyntaxNode tmp = labels[labels.Count - 1]; 158953"];
7307 [label="CSharpSyntaxNode tmp = labels[labels.Count - 1]; 158954"];
7308 [label="CSharpSyntaxNode tmp = labels[labels.Count - 1]; 158955"];
7309 [label="this.ParseStatements(ref tmp, statements, true); 158956"];
7310 [label="this.ParseStatements(ref tmp, statements, true); 158957"];
7311 [label="this.ParseStatements(ref tmp, statements, true); 158958"];
7312 [label="this.ParseStatements(ref tmp, statements, true) 158959"];
7313 [label="param ParseStatements(ref CSharpSyntaxNode previousNode) 158960"];
7314 [label="param ParseStatements(SyntaxListBuilder<StatementSyntax> statements) 158961"];
7315 [label="param ParseStatements(bool stopOnSwitchSections) 158962"];
7316 [label="param ParseStatements(this) 158963"];
7317 [label="var saveTerm = _termState; 158964"];
7318 [label="_termState |= TerminatorState.IsPossibleStatementStartOrStop; 158965"];
7319 [label="_termState 158966"];
7320 [label="if (stopOnSwitchSections)\n            {\n                _termState |= TerminatorState.IsSwitchSectionStart;\n            } 158967"];
7321 [label="_termState |= TerminatorState.IsSwitchSectionStart; 158968"];
7322 [label="_termState 158969"];
7323 [label="int lastTokenPosition = -1; 158970"];
7324 [label="this.CurrentToken 158971"];
7325 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158972"];
7326 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158973"];
7327 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 158974"];
7328 [label="this.CurrentToken.Kind 158975"];
7329 [label="get { return (SyntaxKind)this.RawKind; } 158976"];
7330 [label="this.CurrentToken 158977"];
7331 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158978"];
7332 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158979"];
7333 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 158980"];
7334 [label="this.CurrentToken.Kind 158981"];
7335 [label="get { return (SyntaxKind)this.RawKind; } 158982"];
7336 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 158983"];
7337 [label="this.IsPossibleSwitchSection() 158984"];
7338 [label="param IsPossibleSwitchSection(this) 158985"];
7339 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158986"];
7340 [label="this.CurrentToken 158987"];
7341 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 158988"];
7342 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 158989"];
7343 [label="this.CurrentToken.Kind 158990"];
7344 [label="get { return (SyntaxKind)this.RawKind; } 158991"];
7345 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 158992"];
7346 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 158993"];
7347 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 158994"];
7348 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 158995"];
7349 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 158996"];
7350 [label="IsMakingProgress(ref lastTokenPosition) 158997"];
7351 [label="param IsMakingProgress(ref int lastTokenPosition) 158998"];
7352 [label="param IsMakingProgress(bool assertIfFalse = true) 158999"];
7353 [label="param IsMakingProgress(this) 159000"];
7354 [label="_firstToken + _tokenOffset 159001"];
7355 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 159002"];
7356 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 159003"];
7357 [label="if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                } 159004"];
7358 [label="this.IsPossibleStatement(acceptAccessibilityMods: true) 159005"];
7359 [label="param IsPossibleStatement(bool acceptAccessibilityMods) 159006"];
7360 [label="param IsPossibleStatement(this) 159007"];
7361 [label="this.CurrentToken 159008"];
7362 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159009"];
7363 [label="var tk = this.CurrentToken.Kind; 159010"];
7364 [label="this.CurrentToken.Kind 159011"];
7365 [label="get { return (SyntaxKind)this.RawKind; } 159012"];
7366 [label="switch (tk)\n            {\n                case SyntaxKind.FixedKeyword:\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.ThrowKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                case SyntaxKind.RefKeyword:\n                case SyntaxKind.ExternKeyword:\n                case SyntaxKind.OpenBracketToken:\n                    return true;\n\n                case SyntaxKind.IdentifierToken:\n                    return IsTrueIdentifier();\n\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.FinallyKeyword:\n                    return !_isInTry;\n\n                // Accessibility modifiers are not legal in a statement,\n                // but a common mistake for local functions. Parse to give a\n                // better error message.\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PrivateKeyword:\n                    return acceptAccessibilityMods;\n                default:\n                    return IsPredefinedType(tk)\n                        || IsPossibleExpression();\n            } 159013"];
7367 [label="return true; 159014"];
7368 [label="if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                } 159015"];
7369 [label="this.ParsePossiblyAttributedStatement() 159016"];
7370 [label="var attributes = _pool.Allocate<AttributeListSyntax>(); 159017"];
7371 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 159018"];
7372 [label="this.CurrentToken.Kind 159019"];
7373 [label="get { return (SyntaxKind)this.RawKind; } 159020"];
7374 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 159021"];
7375 [label="false 159022"];
7376 [label="isGlobal: false 159023"];
7377 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 159024"];
7378 [label="param ParseStatementCore(bool isGlobal) 159025"];
7379 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 159026"];
7380 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 159027"];
7381 [label="canReuseStatement(attributes, isGlobal) 159028"];
7382 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 159029"];
7383 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 159030"];
7384 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 159031"];
7385 [label="this.IsIncrementalAndFactoryContextMatches 159032"];
7386 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 159033"];
7387 [label="base.IsIncremental 159034"];
7388 [label="get\n            {\n                return _isIncremental;\n            } 159035"];
7389 [label="return _isIncremental; 159036"];
7390 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 159037"];
7391 [label="return false; 159038"];
7392 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 159039"];
7393 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 159040"];
7394 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 159041"];
7395 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 159042"];
7396 [label="StatementSyntax result; 159043"];
7397 [label="return _syntaxFactory.EmptyStatement(attributes, this.EatToken()); 159044"];
7398 [label="this.EatToken() 159045"];
7399 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 159046"];
7400 [label="MoveToNextToken(); 159047"];
7401 [label="return _syntaxFactory.EmptyStatement(attributes, this.EatToken()); 159048"];
7402 [label="return _syntaxFactory.EmptyStatement(attributes, this.EatToken()); 159049"];
7403 [label="return _syntaxFactory.EmptyStatement(attributes, this.EatToken()); 159050"];
7404 [label="param TryGetNode(int kind) 159051"];
7405 [label="param TryGetNode(GreenNode child1) 159052"];
7406 [label="param TryGetNode(GreenNode child2) 159053"];
7407 [label="param TryGetNode(SyntaxFactoryContext context) 159054"];
7408 [label="param TryGetNode(out int hash) 159055"];
7409 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 159056"];
7410 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 159057"];
7411 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 159058"];
7412 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 159059"];
7413 [label="GetNodeFlags(context) 159060"];
7414 [label="param GetNodeFlags(SyntaxFactoryContext context) 159061"];
7415 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 159062"];
7416 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 159063"];
7417 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 159064"];
7418 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 159065"];
7419 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 159066"];
7420 [label="param SetFactoryContext(SyntaxFactoryContext context) 159067"];
7421 [label="param SetFactoryContext(this) 159068"];
7422 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 159069"];
7423 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 159070"];
7424 [label="_recursionDepth 159071"];
7425 [label="this.Release(ref resetPointBeforeStatement); 159072"];
7426 [label="this.Release(ref resetPointBeforeStatement) 159073"];
7427 [label="param Release(ref ResetPoint state) 159074"];
7428 [label="base.Release(ref state.BaseResetPoint); 159075"];
7429 [label="param Release(ref ResetPoint point) 159076"];
7430 [label="Debug.Assert(_resetCount == point.ResetCount); 159077"];
7431 [label="_resetCount 159078"];
7432 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 159079"];
7433 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 159080"];
7434 [label="base.Release(ref state.BaseResetPoint); 159081"];
7435 [label="this.Release(ref resetPointBeforeStatement); 159082"];
7436 [label="var statement = this.ParsePossiblyAttributedStatement(); 159083"];
7437 [label="if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    } 159084"];
7438 [label="if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    } 159085"];
7439 [label="statements.Add(statement); 159086"];
7440 [label="statements.Add(statement); 159087"];
7441 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159088"];
7442 [label="_termState 159089"];
7443 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 159090"];
7444 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 159091"];
7445 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 159092"];
7446 [label="return _syntaxFactory.SwitchSection(labels, statements); 159093"];
7447 [label="return _syntaxFactory.SwitchSection(labels, statements); 159094"];
7448 [label="return _syntaxFactory.SwitchSection(labels, statements); 159095"];
7449 [label="return _syntaxFactory.SwitchSection(labels, statements); 159096"];
7450 [label="param TryGetNode(SyntaxFactoryContext context) 159097"];
7451 [label="GetNodeFlags(context) 159098"];
7452 [label="param GetNodeFlags(SyntaxFactoryContext context) 159099"];
7453 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 159100"];
7454 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 159101"];
7455 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 159102"];
7456 [label="param SetFactoryContext(SyntaxFactoryContext context) 159103"];
7457 [label="param SetFactoryContext(this) 159104"];
7458 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 159105"];
7459 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 159106"];
7460 [label="_pool.Free(statements); 159107"];
7461 [label="_pool.Free(statements); 159108"];
7462 [label="_pool.Free(labels); 159109"];
7463 [label="_pool.Free(labels); 159110"];
7464 [label="var swcase = this.ParseSwitchSection(); 159111"];
7465 [label="sections.Add(swcase); 159112"];
7466 [label="sections.Add(swcase); 159113"];
7467 [label="this.IsPossibleSwitchSection() 159114"];
7468 [label="Debug.Assert(this.IsPossibleSwitchSection()); 159115"];
7469 [label="SyntaxToken specifier; 159116"];
7470 [label="SwitchLabelSyntax label; 159117"];
7471 [label="SyntaxToken colon; 159118"];
7472 [label="ExpressionSyntax expression; 159119"];
7473 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 159120"];
7474 [label="MoveToNextToken(); 159121"];
7475 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159122"];
7476 [label="param ParsePattern(Precedence precedence) 159123"];
7477 [label="param ParsePattern(bool whenIsKeyword = false) 159124"];
7478 [label="param ParseDisjunctivePattern(Precedence precedence) 159125"];
7479 [label="param ParseDisjunctivePattern(bool whenIsKeyword) 159126"];
7480 [label="param ParseConjunctivePattern(Precedence precedence) 159127"];
7481 [label="param ParseConjunctivePattern(bool whenIsKeyword) 159128"];
7482 [label="param ParseNegatedPattern(Precedence precedence) 159129"];
7483 [label="param ParseNegatedPattern(bool whenIsKeyword) 159130"];
7484 [label="param ParsePrimaryPattern(Precedence precedence) 159131"];
7485 [label="param ParsePrimaryPattern(bool whenIsKeyword) 159132"];
7486 [label="this.CurrentToken 159133"];
7487 [label="var tk = this.CurrentToken.Kind; 159134"];
7488 [label="this.CurrentToken.Kind 159135"];
7489 [label="get { return (SyntaxKind)this.RawKind; } 159136"];
7490 [label="switch (tk)\n            {\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return _syntaxFactory.ConstantPattern(this.ParseIdentifierName(ErrorCode.ERR_MissingPattern));\n            } 159137"];
7491 [label="CurrentToken 159138"];
7492 [label="if (CurrentToken.ContextualKind == SyntaxKind.UnderscoreToken)\n            {\n                return _syntaxFactory.DiscardPattern(this.EatContextualToken(SyntaxKind.UnderscoreToken));\n            } 159139"];
7493 [label="CurrentToken.ContextualKind 159140"];
7494 [label="get\n            {\n                return this.Kind;\n            } 159141"];
7495 [label="CurrentToken 159142"];
7496 [label="switch (CurrentToken.Kind)\n            {\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                    // this is a relational pattern.\n                    var relationalToken = this.EatToken();\n                    Debug.Assert(precedence < Precedence.Shift);\n                    var expression = this.ParseSubExpression(Precedence.Relational);\n                    var result = _syntaxFactory.RelationalPattern(relationalToken, expression);\n                    return CheckFeatureAvailability(result, MessageID.IDS_FeatureRelationalPattern);\n            } 159143"];
7497 [label="CurrentToken.Kind 159144"];
7498 [label="get { return (SyntaxKind)this.RawKind; } 159145"];
7499 [label="var resetPoint = this.GetResetPoint(); 159146"];
7500 [label="TypeSyntax type = null; 159147"];
7501 [label="if (SyntaxFacts.IsPredefinedType(tk))\n            {\n                return true;\n            } 159148"];
7502 [label="SyntaxFacts.IsPredefinedType(tk) 159149"];
7503 [label="param IsPredefinedType(SyntaxKind kind) 159150"];
7504 [label="get { return (SyntaxKind)this.RawKind; } 159151"];
7505 [label="afterIs 159152"];
7506 [label="this.CurrentToken 159153"];
7507 [label="if (this.CurrentToken.Kind == SyntaxKind.RefKeyword)\n            {\n                var refKeyword = this.EatToken();\n                refKeyword = this.CheckFeatureAvailability(refKeyword, MessageID.IDS_FeatureRefLocalsReturns);\n\n                SyntaxToken readonlyKeyword = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                {\n                    readonlyKeyword = this.EatToken();\n                    readonlyKeyword = this.CheckFeatureAvailability(readonlyKeyword, MessageID.IDS_FeatureReadOnlyReferences);\n                }\n\n                var type = ParseTypeCore(ParseTypeMode.AfterRef);\n                return _syntaxFactory.RefType(refKeyword, readonlyKeyword, type);\n            } 159154"];
7508 [label="this.CurrentToken.Kind 159155"];
7509 [label="get { return (SyntaxKind)this.RawKind; } 159156"];
7510 [label="param ParseUnderlyingType(ParseTypeMode mode) 159157"];
7511 [label="param ParseUnderlyingType(NameOptions options = NameOptions.None) 159158"];
7512 [label="this.CurrentToken 159159"];
7513 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159160"];
7514 [label="if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, mode == ParseTypeMode.Parameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return _syntaxFactory.PredefinedType(token);\n            } 159161"];
7515 [label="this.CurrentToken.Kind 159162"];
7516 [label="get { return (SyntaxKind)this.RawKind; } 159163"];
7517 [label="IsPredefinedType(this.CurrentToken.Kind) 159164"];
7518 [label="param IsPredefinedType(SyntaxKind keyword) 159165"];
7519 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 159166"];
7520 [label="this.CurrentToken 159167"];
7521 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159168"];
7522 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 159169"];
7523 [label="param ParseQualifiedName(NameOptions options = NameOptions.None) 159170"];
7524 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 159171"];
7525 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 159172"];
7526 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 159173"];
7527 [label="this.IsIncrementalAndFactoryContextMatches 159174"];
7528 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 159175"];
7529 [label="base.IsIncremental 159176"];
7530 [label="get\n            {\n                return _isIncremental;\n            } 159177"];
7531 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 159178"];
7532 [label="return false; 159179"];
7533 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 159180"];
7534 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 159181"];
7535 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 159182"];
7536 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 159183"];
7537 [label="this.CurrentToken 159184"];
7538 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159185"];
7539 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 159186"];
7540 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 159187"];
7541 [label="IsCurrentTokenQueryKeywordInQuery() 159188"];
7542 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 159189"];
7543 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 159190"];
7544 [label="param GetTrailingTrivia(this) 159191"];
7545 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 159192"];
7546 [label="MoveToNextToken(); 159193"];
7547 [label="this.IsInAsync 159194"];
7548 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 159195"];
7549 [label="return _syntaxFactoryContext.IsInAsync; 159196"];
7550 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 159197"];
7551 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 159198"];
7552 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159199"];
7553 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 159200"];
7554 [label="this.CurrentToken.Kind 159201"];
7555 [label="get { return (SyntaxKind)this.RawKind; } 159202"];
7556 [label="this.CurrentToken 159203"];
7557 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159204"];
7558 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 159205"];
7559 [label="this.CurrentToken.Kind 159206"];
7560 [label="get { return (SyntaxKind)this.RawKind; } 159207"];
7561 [label="this.IsDotOrColonColon() 159208"];
7562 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159209"];
7563 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 159210"];
7564 [label="this.CurrentToken 159211"];
7565 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159212"];
7566 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 159213"];
7567 [label="this.CurrentToken.Kind 159214"];
7568 [label="get { return (SyntaxKind)this.RawKind; } 159215"];
7569 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 159216"];
7570 [label="param IsMakingProgress(bool assertIfFalse = true) 159217"];
7571 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 159218"];
7572 [label="CanTokenFollowTypeInPattern(precedence) 159219"];
7573 [label="param CanTokenFollowTypeInPattern(Precedence precedence) 159220"];
7574 [label="param CanTokenFollowTypeInPattern(this) 159221"];
7575 [label="this.CurrentToken 159222"];
7576 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159223"];
7577 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159224"];
7578 [label="switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.CloseBraceToken:   // for efficiency, test some tokens that can follow a type pattern\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                    return true;\n                case SyntaxKind.DotToken:\n                    // int.MaxValue is an expression, not a type.\n                    return false;\n                case var kind:\n                    // If we find what looks like a continuation of an expression, it is not a type.\n                    return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence;\n            } 159225"];
7579 [label="this.CurrentToken.Kind 159226"];
7580 [label="get { return (SyntaxKind)this.RawKind; } 159227"];
7581 [label="return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence; 159228"];
7582 [label="SyntaxFacts.IsBinaryExpressionOperatorToken(kind) 159229"];
7583 [label="param IsBinaryExpressionOperatorToken(SyntaxKind token) 159230"];
7584 [label="return GetBinaryExpression(token) != SyntaxKind.None; 159231"];
7585 [label="GetBinaryExpression(token) 159232"];
7586 [label="param GetBinaryExpression(SyntaxKind token) 159233"];
7587 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 159234"];
7588 [label="return SyntaxKind.None; 159235"];
7589 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 159236"];
7590 [label="param ParsePatternContinued(Precedence precedence) 159237"];
7591 [label="param ParsePatternContinued(bool whenIsKeyword) 159238"];
7592 [label=".Kind 159239"];
7593 [label="get { return (SyntaxKind)this.RawKind; } 159240"];
7594 [label="if (type?.Kind == SyntaxKind.IdentifierName)\n            {\n                var typeIdentifier = (IdentifierNameSyntax)type;\n                var typeIdentifierToken = typeIdentifier.Identifier;\n                if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                }\n            } 159241"];
7595 [label="var typeIdentifier = (IdentifierNameSyntax)type; 159242"];
7596 [label="var typeIdentifierToken = typeIdentifier.Identifier; 159243"];
7597 [label="typeIdentifierToken.ContextualKind 159244"];
7598 [label="get\n            {\n                return this.Kind;\n            } 159245"];
7599 [label="if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                } 159246"];
7600 [label="this.CurrentToken 159247"];
7601 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159248"];
7602 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken && (type != null || !looksLikeCast()))\n            {\n                // It is possible this is a parenthesized (constant) expression.\n                // We normalize later.\n                ParseSubpatternList(\n                    openToken: out SyntaxToken openParenToken,\n                    subPatterns: out SeparatedSyntaxList<SubpatternSyntax> subPatterns,\n                    closeToken: out SyntaxToken closeParenToken,\n                    openKind: SyntaxKind.OpenParenToken,\n                    closeKind: SyntaxKind.CloseParenToken);\n\n                parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause0);\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n\n                if (type == null &&\n                    propertyPatternClause0 == null &&\n                    designation0 == null &&\n                    subPatterns.Count == 1 &&\n                    subPatterns.SeparatorCount == 0 &&\n                    subPatterns[0].NameColon == null)\n                {\n                    var subpattern = subPatterns[0].Pattern;\n                    switch (subpattern)\n                    {\n                        case ConstantPatternSyntax cp:\n                            // There is an ambiguity between a positional pattern `(` pattern `)`\n                            // and a constant expression pattern that happens to be parenthesized.\n                            // Per 2017-11-20 LDM we treat such syntax as a parenthesized expression always.\n                            ExpressionSyntax expression = _syntaxFactory.ParenthesizedExpression(openParenToken, cp.Expression, closeParenToken);\n                            expression = ParseExpressionContinued(expression, precedence);\n                            return _syntaxFactory.ConstantPattern(expression);\n                        default:\n                            var parenthesizedPattern = _syntaxFactory.ParenthesizedPattern(openParenToken, subPatterns[0].Pattern, closeParenToken);\n                            return CheckFeatureAvailability(parenthesizedPattern, MessageID.IDS_FeatureParenthesizedPattern);\n                    }\n                }\n\n                var positionalPatternClause = _syntaxFactory.PositionalPatternClause(openParenToken, subPatterns, closeParenToken);\n                var result = _syntaxFactory.RecursivePattern(type, positionalPatternClause, propertyPatternClause0, designation0);\n                return result;\n            } 159249"];
7603 [label="this.CurrentToken.Kind 159250"];
7604 [label="get { return (SyntaxKind)this.RawKind; } 159251"];
7605 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 159252"];
7606 [label="parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause) 159253"];
7607 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 159254"];
7608 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 159255"];
7609 [label="propertyPatternClauseResult = null; 159256"];
7610 [label="this.CurrentToken 159257"];
7611 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159258"];
7612 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159259"];
7613 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                } 159260"];
7614 [label="this.CurrentToken.Kind 159261"];
7615 [label="get { return (SyntaxKind)this.RawKind; } 159262"];
7616 [label="return false; 159263"];
7617 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 159264"];
7618 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 159265"];
7619 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 159266"];
7620 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 159267"];
7621 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 159268"];
7622 [label="designationResult = null; 159269"];
7623 [label="this.IsTrueIdentifier() 159270"];
7624 [label="param IsTrueIdentifier(this) 159271"];
7625 [label="return false; 159272"];
7626 [label="if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                } 159273"];
7627 [label="param ConvertTypeToExpression(out ExpressionSyntax expr) 159274"];
7628 [label="param ConvertTypeToExpression(bool permitTypeArguments = false) 159275"];
7629 [label="param ConvertTypeToExpression(this) 159276"];
7630 [label="expr = null; 159277"];
7631 [label="expression = ParseExpressionContinued(expression, precedence); 159278"];
7632 [label="param ParseExpressionContinued(Precedence precedence) 159279"];
7633 [label="param ParseExpressionContinued(this) 159280"];
7634 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 159281"];
7635 [label="this.CurrentToken 159282"];
7636 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159283"];
7637 [label="var tk = this.CurrentToken.ContextualKind; 159284"];
7638 [label="this.CurrentToken.ContextualKind 159285"];
7639 [label="get\n            {\n                return this.Kind;\n            } 159286"];
7640 [label="bool isAssignmentOperator = false; 159287"];
7641 [label="SyntaxKind opKind; 159288"];
7642 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 159289"];
7643 [label="IsExpectedBinaryOperator(tk) 159290"];
7644 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 159291"];
7645 [label="return SyntaxFacts.IsBinaryExpression(kind); 159292"];
7646 [label="SyntaxFacts.IsBinaryExpression(kind) 159293"];
7647 [label="param IsBinaryExpression(SyntaxKind token) 159294"];
7648 [label="return GetBinaryExpression(token) != SyntaxKind.None; 159295"];
7649 [label="GetBinaryExpression(token) 159296"];
7650 [label="param GetBinaryExpression(SyntaxKind token) 159297"];
7651 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 159298"];
7652 [label="return SyntaxKind.None; 159299"];
7653 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 159300"];
7654 [label="IsExpectedAssignmentOperator(tk) 159301"];
7655 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 159302"];
7656 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 159303"];
7657 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 159304"];
7658 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 159305"];
7659 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 159306"];
7660 [label="return false; 159307"];
7661 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 159308"];
7662 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 159309"];
7663 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 159310"];
7664 [label="CurrentToken 159311"];
7665 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159312"];
7666 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 159313"];
7667 [label="CurrentToken.Kind 159314"];
7668 [label="get { return (SyntaxKind)this.RawKind; } 159315"];
7669 [label="param TryGetNode(SyntaxFactoryContext context) 159316"];
7670 [label="param GetNodeFlags(SyntaxFactoryContext context) 159317"];
7671 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 159318"];
7672 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 159319"];
7673 [label="param SetFactoryContext(SyntaxFactoryContext context) 159320"];
7674 [label="param SetFactoryContext(this) 159321"];
7675 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 159322"];
7676 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 159323"];
7677 [label="this.Release(ref resetPoint); 159324"];
7678 [label="param Release(ref ResetPoint state) 159325"];
7679 [label="base.Release(ref state.BaseResetPoint); 159326"];
7680 [label="param Release(ref ResetPoint point) 159327"];
7681 [label="Debug.Assert(_resetCount == point.ResetCount); 159328"];
7682 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 159329"];
7683 [label="base.Release(ref state.BaseResetPoint); 159330"];
7684 [label="this.Release(ref resetPoint); 159331"];
7685 [label="this.CurrentToken 159332"];
7686 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159333"];
7687 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.AndKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseNegatedPattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.AndPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureAndPattern);\n            } 159334"];
7688 [label="this.CurrentToken.ContextualKind 159335"];
7689 [label="get\n            {\n                return this.Kind;\n            } 159336"];
7690 [label="this.CurrentToken 159337"];
7691 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159338"];
7692 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.OrKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.OrPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureOrPattern);\n            } 159339"];
7693 [label="this.CurrentToken.ContextualKind 159340"];
7694 [label="get\n            {\n                return this.Kind;\n            } 159341"];
7695 [label="pattern switch\n            {\n                ConstantPatternSyntax cp => cp.Expression,\n                TypePatternSyntax tp when ConvertTypeToExpression(tp.Type, out ExpressionSyntax expr) => expr,\n                DiscardPatternSyntax dp => _syntaxFactory.IdentifierName(ConvertToIdentifier(dp.UnderscoreToken)),\n                var p => p,\n            } 159342"];
7696 [label="param CheckRecursivePatternFeature(this) 159343"];
7697 [label="this.CurrentToken 159344"];
7698 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159345"];
7699 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex); 159346"];
7700 [label="this.CurrentToken.ContextualKind 159347"];
7701 [label="get\n            {\n                return this.Kind;\n            } 159348"];
7702 [label="node.Kind 159349"];
7703 [label="get { return (SyntaxKind)this.RawKind; } 159350"];
7704 [label="if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement); 159351"];
7705 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 159352"];
7706 [label="SyntaxFacts.IsAnyToken(kind) 159353"];
7707 [label="param IsAnyToken(SyntaxKind kind) 159354"];
7708 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 159355"];
7709 [label="return true; 159356"];
7710 [label="param GetTrailingTrivia(this) 159357"];
7711 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 159358"];
7712 [label="MoveToNextToken(); 159359"];
7713 [label="param GetNodeFlags(SyntaxFactoryContext context) 159360"];
7714 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 159361"];
7715 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 159362"];
7716 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159363"];
7717 [label="do\n                {\n                    SyntaxToken specifier;\n                    SwitchLabelSyntax label;\n                    SyntaxToken colon;\n                    if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = _syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    }\n\n                    labels.Add(label);\n                }\n                while (IsPossibleSwitchSection()); 159364"];
7718 [label="param IsMakingProgress(bool assertIfFalse = true) 159365"];
7719 [label="param IsPossibleStatement(bool acceptAccessibilityMods) 159366"];
7720 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 159367"];
7721 [label="this.CurrentToken.Kind 159368"];
7722 [label="get { return (SyntaxKind)this.RawKind; } 159369"];
7723 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 159370"];
7724 [label="false 159371"];
7725 [label="isGlobal: false 159372"];
7726 [label="param ParseStatementCore(bool isGlobal) 159373"];
7727 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 159374"];
7728 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 159375"];
7729 [label="canReuseStatement(attributes, isGlobal) 159376"];
7730 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 159377"];
7731 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 159378"];
7732 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 159379"];
7733 [label="this.IsIncrementalAndFactoryContextMatches 159380"];
7734 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 159381"];
7735 [label="base.IsIncremental 159382"];
7736 [label="get\n            {\n                return _isIncremental;\n            } 159383"];
7737 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 159384"];
7738 [label="return false; 159385"];
7739 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 159386"];
7740 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 159387"];
7741 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 159388"];
7742 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 159389"];
7743 [label="StatementSyntax result; 159390"];
7744 [label="MoveToNextToken(); 159391"];
7745 [label="this.Release(ref resetPointBeforeStatement); 159392"];
7746 [label="param Release(ref ResetPoint state) 159393"];
7747 [label="base.Release(ref state.BaseResetPoint); 159394"];
7748 [label="param Release(ref ResetPoint point) 159395"];
7749 [label="Debug.Assert(_resetCount == point.ResetCount); 159396"];
7750 [label="this.Release(ref resetPointBeforeStatement); 159397"];
7751 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159398"];
7752 [label="param GetNodeFlags(SyntaxFactoryContext context) 159399"];
7753 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 159400"];
7754 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 159401"];
7755 [label="param SetFactoryContext(SyntaxFactoryContext context) 159402"];
7756 [label="param SetFactoryContext(this) 159403"];
7757 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 159404"];
7758 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 159405"];
7759 [label="this.CurrentToken 159406"];
7760 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159407"];
7761 [label="this.CurrentToken.Kind 159408"];
7762 [label="var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken); 159409"];
7763 [label="this.EatToken(SyntaxKind.CloseBraceToken) 159410"];
7764 [label="param EatToken(SyntaxKind kind) 159411"];
7765 [label="param EatToken(this) 159412"];
7766 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 159413"];
7767 [label="SyntaxFacts.IsAnyToken(kind) 159414"];
7768 [label="param IsAnyToken(SyntaxKind kind) 159415"];
7769 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 159416"];
7770 [label="return true; 159417"];
7771 [label="this.CurrentToken 159418"];
7772 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159419"];
7773 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 159420"];
7774 [label="ct.Kind 159421"];
7775 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 159422"];
7776 [label="param GetTrailingTrivia(this) 159423"];
7777 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 159424"];
7778 [label="MoveToNextToken(); 159425"];
7779 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 159426"];
7780 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 159427"];
7781 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 159428"];
7782 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 159429"];
7783 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 159430"];
7784 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 159431"];
7785 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 159432"];
7786 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 159433"];
7787 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 159434"];
7788 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 159435"];
7789 [label="param CSharpSyntaxNode(this) 159436"];
7790 [label="GreenStats.NoteGreen(this); 159437"];
7791 [label="param SetFactoryContext(SyntaxFactoryContext context) 159438"];
7792 [label="param SetFactoryContext(this) 159439"];
7793 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 159440"];
7794 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 159441"];
7795 [label="_pool.Free(sections); 159442"];
7796 [label="_pool.Free(sections); 159443"];
7797 [label="this.Release(ref resetPointBeforeStatement); 159444"];
7798 [label="this.Release(ref resetPointBeforeStatement) 159445"];
7799 [label="param Release(ref ResetPoint state) 159446"];
7800 [label="param Release(this) 159447"];
7801 [label="base.Release(ref state.BaseResetPoint); 159448"];
7802 [label="base.Release(ref state.BaseResetPoint) 159449"];
7803 [label="param Release(ref ResetPoint point) 159450"];
7804 [label="param Release(this) 159451"];
7805 [label="Debug.Assert(_resetCount == point.ResetCount); 159452"];
7806 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 159453"];
7807 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 159454"];
7808 [label="_resetStart = -1; 159455"];
7809 [label="_resetStart 159456"];
7810 [label="base.Release(ref state.BaseResetPoint); 159457"];
7811 [label="this.Release(ref resetPointBeforeStatement); 159458"];
7812 [label="var node = parser.ParseStatement(); 159459"];
7813 [label="if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node); 159460"];
7814 [label="node = parser.ConsumeUnexpectedTokens(node); 159461"];
7815 [label="parser.ConsumeUnexpectedTokens(node) 159462"];
7816 [label="param ConsumeUnexpectedTokens(TNode node) 159463"];
7817 [label="param ConsumeUnexpectedTokens(this) 159464"];
7818 [label="this.CurrentToken 159465"];
7819 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 159466"];
7820 [label="this.FetchCurrentToken() 159467"];
7821 [label="param FetchCurrentToken(this) 159468"];
7822 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 159469"];
7823 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 159470"];
7824 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 159471"];
7825 [label="if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken) return node; 159472"];
7826 [label="this.CurrentToken.Kind 159473"];
7827 [label="get { return (SyntaxKind)this.RawKind; } 159474"];
7828 [label="return node; 159475"];
7829 [label="return (StatementSyntax)node.CreateRed(); 159476"];
7830 [label="return (StatementSyntax)node.CreateRed(); 159477"];
7831 [label="return (StatementSyntax)node.CreateRed(); 159478"];
7832 [label="param CSharpSyntaxNode(GreenNode green) 159479"];
7833 [label="param CSharpSyntaxNode(SyntaxNode? parent) 159480"];
7834 [label="param CSharpSyntaxNode(int position) 159481"];
7835 [label="param CSharpSyntaxNode(this) 159482"];
7836 [label="green 159483"];
7837 [label="parent 159484"];
7838 [label="position 159485"];
7839 [label="param CSharpSyntaxNode(this) 159486"];
7840 [label="param CSharpSyntaxNode(this) 159487"];
7841 [label="CustomAssert.NotNull(statement); 159488"];
7842 [label="CustomAssert.Equal(SyntaxKind.SwitchStatement, statement.Kind()); 159489"];
7843 [label="statement.Kind() 159490"];
7844 [label="param Kind(this) 159491"];
7845 [label="return (SyntaxKind)this.Green.RawKind; 159492"];
7846 [label="CustomAssert.Equal(SyntaxKind.SwitchStatement, statement.Kind()); 159493"];
7847 [label="CustomAssert.Equal(text, statement.ToString()); 159494"];
7848 [label="CustomAssert.Equal(text, statement.ToString()); 159495"];
7849 [label="CustomAssert.Equal(text, statement.ToString()); 159496"];
7850 [label="=> true 159497"];
7851 [label="true 159498"];
7852 [label="CustomAssert.Equal(text, statement.ToString()); 159499"];
7853 [label="param WriteTokenTo(System.IO.TextWriter writer) 159500"];
7854 [label="param WriteTokenTo(bool leading) 159501"];
7855 [label="param WriteTokenTo(bool trailing) 159502"];
7856 [label="param WriteTokenTo(this) 159503"];
7857 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 159504"];
7858 [label="this.Text 159505"];
7859 [label="get { return SyntaxFacts.GetText(this.Kind); } 159506"];
7860 [label="this.Kind 159507"];
7861 [label="get { return (SyntaxKind)this.RawKind; } 159508"];
7862 [label="return (SyntaxKind)this.RawKind; 159509"];
7863 [label="return SyntaxFacts.GetText(this.Kind); 159510"];
7864 [label="SyntaxFacts.GetText(this.Kind) 159511"];
7865 [label="param GetText(SyntaxKind kind) 159512"];
7866 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 159513"];
7867 [label="return 'switch'; 159514"];
7868 [label="writer.Write(this.Text); 159515"];
7869 [label="writer.Write(this.Text); 159516"];
7870 [label="if (trailing)\n            {\n                var trivia = this.GetTrailingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 159517"];
7871 [label="this.GetTrailingTrivia() 159518"];
7872 [label="param GetTrailingTrivia(this) 159519"];
7873 [label="return this.TrailingField; 159520"];
7874 [label="var trivia = this.GetTrailingTrivia(); 159521"];
7875 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 159522"];
7876 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 159523"];
7877 [label="trivia.WriteTo(writer, true, true); 159524"];
7878 [label="trivia.WriteTo(writer, true, true); 159525"];
7879 [label="=> true 159526"];
7880 [label="true 159527"];
7881 [label="param WriteTriviaTo(System.IO.TextWriter writer) 159528"];
7882 [label="param WriteTriviaTo(this) 159529"];
7883 [label="writer.Write(Text); 159530"];
7884 [label="writer.Write(Text); 159531"];
7885 [label="this.GetLeadingTrivia() 159532"];
7886 [label="param GetLeadingTrivia(this) 159533"];
7887 [label="return null; 159534"];
7888 [label="var trivia = this.GetLeadingTrivia(); 159535"];
7889 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 159536"];
7890 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 159537"];
7891 [label="return '('; 159538"];
7892 [label="param GetTrailingTrivia(this) 159539"];
7893 [label="var trivia = this.GetTrailingTrivia(); 159540"];
7894 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 159541"];
7895 [label="get { return this.TextField; } 159542"];
7896 [label="return this.TextField; 159543"];
7897 [label="param GetLeadingTrivia(this) 159544"];
7898 [label="return this.LeadingField; 159545"];
7899 [label="var trivia = this.GetLeadingTrivia(); 159546"];
7900 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 159547"];
7901 [label="return ')'; 159548"];
7902 [label="=> true 159549"];
7903 [label="return this.LeadingField; 159550"];
7904 [label="var trivia = this.GetLeadingTrivia(); 159551"];
7905 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 159552"];
7906 [label="return '{'; 159553"];
7907 [label="=> true 159554"];
7908 [label="return this.LeadingField; 159555"];
7909 [label="var trivia = this.GetLeadingTrivia(); 159556"];
7910 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 159557"];
7911 [label="return 'case'; 159558"];
7912 [label="=> true 159559"];
7913 [label="return ':'; 159560"];
7914 [label="return this.LeadingField; 159561"];
7915 [label="var trivia = this.GetLeadingTrivia(); 159562"];
7916 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 159563"];
7917 [label="return ';'; 159564"];
7918 [label="=> true 159565"];
7919 [label="return this.LeadingField; 159566"];
7920 [label="var trivia = this.GetLeadingTrivia(); 159567"];
7921 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 159568"];
7922 [label="return '}'; 159569"];
7923 [label="CustomAssert.Equal(0, statement.Errors().Length); 159570"];
7924 [label="CustomAssert.Equal(0, statement.Errors().Length); 159571"];
7925 [label="statement.Errors() 159572"];
7926 [label="param Errors(this SyntaxNode node) 159573"];
7927 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 159574"];
7928 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 159575"];
7929 [label="node.Green.ErrorsOrWarnings(errorsOnly: true) 159576"];
7930 [label="param ErrorsOrWarnings(this GreenNode node) 159577"];
7931 [label="param ErrorsOrWarnings(bool errorsOnly) 159578"];
7932 [label="ArrayBuilder<DiagnosticInfo> b = ArrayBuilder<DiagnosticInfo>.GetInstance(); 159579"];
7933 [label="var l = new SyntaxDiagnosticInfoList(node); 159580"];
7934 [label="foreach (var item in l)\n            {\n                if (item.Severity == (errorsOnly ? DiagnosticSeverity.Error : DiagnosticSeverity.Warning))\n                    b.Add(item);\n            } 159581"];
7935 [label="return b.ToImmutableAndFree(); 159582"];
7936 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 159583"];
7937 [label="CustomAssert.Equal(0, statement.Errors().Length); 159584"];
7938 [label="var ss = (SwitchStatementSyntax)statement; 159585"];
7939 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 159586"];
7940 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 159587"];
7941 [label="ss.SwitchKeyword 159588"];
7942 [label="=> true 159589"];
7943 [label="true 159590"];
7944 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 159591"];
7945 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 159592"];
7946 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 159593"];
7947 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 159594"];
7948 [label="ss.SwitchKeyword 159595"];
7949 [label="=> true 159596"];
7950 [label="true 159597"];
7951 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 159598"];
7952 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 159599"];
7953 [label="param Kind(this SyntaxToken token) 159600"];
7954 [label="var rawKind = token.RawKind; 159601"];
7955 [label="return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None; 159602"];
7956 [label="IsCSharpKind(rawKind) 159603"];
7957 [label="param IsCSharpKind(int rawKind) 159604"];
7958 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 159605"];
7959 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 159606"];
7960 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 159607"];
7961 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 159608"];
7962 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 159609"];
7963 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 159610"];
7964 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 159611"];
7965 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 159612"];
7966 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 159613"];
7967 [label="ss.OpenParenToken 159614"];
7968 [label="=> true 159615"];
7969 [label="true 159616"];
7970 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 159617"];
7971 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 159618"];
7972 [label="CustomAssert.NotNull(ss.Expression); 159619"];
7973 [label="ss.Expression 159620"];
7974 [label="param CSharpSyntaxNode(GreenNode green) 159621"];
7975 [label="param CSharpSyntaxNode(SyntaxNode? parent) 159622"];
7976 [label="param CSharpSyntaxNode(int position) 159623"];
7977 [label="param CSharpSyntaxNode(this) 159624"];
7978 [label="param CSharpSyntaxNode(this) 159625"];
7979 [label="CustomAssert.Equal('a', ss.Expression.ToString()); 159626"];
7980 [label="ss.Expression.ToString() 159627"];
7981 [label="param ToString(this) 159628"];
7982 [label="this.Identifier.Text 159629"];
7983 [label="get { return this.TextField; } 159630"];
7984 [label="return this.Identifier.Text; 159631"];
7985 [label="CustomAssert.Equal('a', ss.Expression.ToString()); 159632"];
7986 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 159633"];
7987 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 159634"];
7988 [label="ss.CloseParenToken 159635"];
7989 [label="=> true 159636"];
7990 [label="true 159637"];
7991 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 159638"];
7992 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 159639"];
7993 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 159640"];
7994 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 159641"];
7995 [label="ss.OpenBraceToken 159642"];
7996 [label="=> true 159643"];
7997 [label="true 159644"];
7998 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 159645"];
7999 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 159646"];
8000 [label="CustomAssert.Equal(2, ss.Sections.Count); 159647"];
8001 [label="CustomAssert.Equal(2, ss.Sections.Count); 159648"];
8002 [label="CustomAssert.Equal(1, ss.Sections[0].Labels.Count); 159649"];
8003 [label="CustomAssert.Equal(1, ss.Sections[0].Labels.Count); 159650"];
8004 [label="ss.Sections[0].Labels 159651"];
8005 [label="param CSharpSyntaxNode(GreenNode green) 159652"];
8006 [label="param CSharpSyntaxNode(SyntaxNode? parent) 159653"];
8007 [label="param CSharpSyntaxNode(int position) 159654"];
8008 [label="param CSharpSyntaxNode(this) 159655"];
8009 [label="param CSharpSyntaxNode(this) 159656"];
8010 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 159657"];
8011 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 159658"];
8012 [label="ss.Sections[0].Labels[0].Keyword 159659"];
8013 [label="=> true 159660"];
8014 [label="true 159661"];
8015 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 159662"];
8016 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 159663"];
8017 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 159664"];
8018 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 159665"];
8019 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 159666"];
8020 [label="ss.Sections[0].Labels[0].Keyword 159667"];
8021 [label="=> true 159668"];
8022 [label="true 159669"];
8023 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 159670"];
8024 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 159671"];
8025 [label="param Kind(this SyntaxToken token) 159672"];
8026 [label="IsCSharpKind(rawKind) 159673"];
8027 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 159674"];
8028 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 159675"];
8029 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 159676"];
8030 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 159677"];
8031 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 159678"];
8032 [label="var caseLabelSyntax = ss.Sections[0].Labels[0] as CaseSwitchLabelSyntax; 159679"];
8033 [label="var caseLabelSyntax = ss.Sections[0].Labels[0] as CaseSwitchLabelSyntax; 159680"];
8034 [label="CustomAssert.NotNull(caseLabelSyntax); 159681"];
8035 [label="CustomAssert.NotNull(caseLabelSyntax.Value); 159682"];
8036 [label="caseLabelSyntax.Value 159683"];
8037 [label="param CSharpSyntaxNode(GreenNode green) 159684"];
8038 [label="param CSharpSyntaxNode(SyntaxNode? parent) 159685"];
8039 [label="param CSharpSyntaxNode(int position) 159686"];
8040 [label="param CSharpSyntaxNode(this) 159687"];
8041 [label="param CSharpSyntaxNode(this) 159688"];
8042 [label="CustomAssert.Equal('b', caseLabelSyntax.Value.ToString()); 159689"];
8043 [label="caseLabelSyntax.Value.ToString() 159690"];
8044 [label="param ToString(this) 159691"];
8045 [label="this.Identifier.Text 159692"];
8046 [label="get { return this.TextField; } 159693"];
8047 [label="return this.Identifier.Text; 159694"];
8048 [label="CustomAssert.Equal('b', caseLabelSyntax.Value.ToString()); 159695"];
8049 [label="CustomAssert.NotEqual(default, caseLabelSyntax.ColonToken); 159696"];
8050 [label="CustomAssert.NotEqual(default, caseLabelSyntax.ColonToken); 159697"];
8051 [label="caseLabelSyntax.ColonToken 159698"];
8052 [label="=> true 159699"];
8053 [label="true 159700"];
8054 [label="CustomAssert.NotEqual(default, caseLabelSyntax.ColonToken); 159701"];
8055 [label="CustomAssert.NotEqual(default, caseLabelSyntax.ColonToken); 159702"];
8056 [label="CustomAssert.Equal(1, ss.Sections[0].Statements.Count); 159703"];
8057 [label="CustomAssert.Equal(1, ss.Sections[0].Statements.Count); 159704"];
8058 [label="ss.Sections[0].Statements 159705"];
8059 [label="param CSharpSyntaxNode(GreenNode green) 159706"];
8060 [label="param CSharpSyntaxNode(SyntaxNode? parent) 159707"];
8061 [label="param CSharpSyntaxNode(int position) 159708"];
8062 [label="param CSharpSyntaxNode(this) 159709"];
8063 [label="param CSharpSyntaxNode(this) 159710"];
8064 [label="CustomAssert.Equal(';', ss.Sections[0].Statements[0].ToString()); 159711"];
8065 [label="CustomAssert.Equal(';', ss.Sections[0].Statements[0].ToString()); 159712"];
8066 [label="=> true 159713"];
8067 [label="true 159714"];
8068 [label="param WriteTokenTo(bool leading) 159715"];
8069 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 159716"];
8070 [label="this.Text 159717"];
8071 [label="this.Kind 159718"];
8072 [label="SyntaxFacts.GetText(this.Kind) 159719"];
8073 [label="CustomAssert.Equal(1, ss.Sections[1].Labels.Count); 159720"];
8074 [label="CustomAssert.Equal(1, ss.Sections[1].Labels.Count); 159721"];
8075 [label="ss.Sections[1].Labels 159722"];
8076 [label="param CSharpSyntaxNode(GreenNode green) 159723"];
8077 [label="param CSharpSyntaxNode(SyntaxNode? parent) 159724"];
8078 [label="param CSharpSyntaxNode(int position) 159725"];
8079 [label="param CSharpSyntaxNode(this) 159726"];
8080 [label="param CSharpSyntaxNode(this) 159727"];
8081 [label="CustomAssert.NotEqual(default, ss.Sections[1].Labels[0].Keyword); 159728"];
8082 [label="CustomAssert.NotEqual(default, ss.Sections[1].Labels[0].Keyword); 159729"];
8083 [label="ss.Sections[1].Labels[0].Keyword 159730"];
8084 [label="=> true 159731"];
8085 [label="true 159732"];
8086 [label="CustomAssert.NotEqual(default, ss.Sections[1].Labels[0].Keyword); 159733"];
8087 [label="CustomAssert.NotEqual(default, ss.Sections[1].Labels[0].Keyword); 159734"];
8088 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[1].Labels[0].Keyword.Kind()); 159735"];
8089 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[1].Labels[0].Keyword.Kind()); 159736"];
8090 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[1].Labels[0].Keyword.Kind()); 159737"];
8091 [label="ss.Sections[1].Labels[0].Keyword 159738"];
8092 [label="=> true 159739"];
8093 [label="true 159740"];
8094 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[1].Labels[0].Keyword.Kind()); 159741"];
8095 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[1].Labels[0].Keyword.Kind()); 159742"];
8096 [label="param Kind(this SyntaxToken token) 159743"];
8097 [label="IsCSharpKind(rawKind) 159744"];
8098 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 159745"];
8099 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 159746"];
8100 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 159747"];
8101 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 159748"];
8102 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 159749"];
8103 [label="var caseLabelSyntax2 = ss.Sections[1].Labels[0] as CaseSwitchLabelSyntax; 159750"];
8104 [label="var caseLabelSyntax2 = ss.Sections[1].Labels[0] as CaseSwitchLabelSyntax; 159751"];
8105 [label="CustomAssert.NotNull(caseLabelSyntax2); 159752"];
8106 [label="CustomAssert.NotNull(caseLabelSyntax2.Value); 159753"];
8107 [label="caseLabelSyntax2.Value 159754"];
8108 [label="param CSharpSyntaxNode(GreenNode green) 159755"];
8109 [label="param CSharpSyntaxNode(SyntaxNode? parent) 159756"];
8110 [label="param CSharpSyntaxNode(int position) 159757"];
8111 [label="param CSharpSyntaxNode(this) 159758"];
8112 [label="param CSharpSyntaxNode(this) 159759"];
8113 [label="CustomAssert.Equal('c', caseLabelSyntax2.Value.ToString()); 159760"];
8114 [label="caseLabelSyntax2.Value.ToString() 159761"];
8115 [label="param ToString(this) 159762"];
8116 [label="this.Identifier.Text 159763"];
8117 [label="get { return this.TextField; } 159764"];
8118 [label="return this.Identifier.Text; 159765"];
8119 [label="CustomAssert.Equal('c', caseLabelSyntax2.Value.ToString()); 159766"];
8120 [label="CustomAssert.NotEqual(default, caseLabelSyntax2.ColonToken); 159767"];
8121 [label="CustomAssert.NotEqual(default, caseLabelSyntax2.ColonToken); 159768"];
8122 [label="caseLabelSyntax2.ColonToken 159769"];
8123 [label="=> true 159770"];
8124 [label="true 159771"];
8125 [label="CustomAssert.NotEqual(default, caseLabelSyntax2.ColonToken); 159772"];
8126 [label="CustomAssert.NotEqual(default, caseLabelSyntax2.ColonToken); 159773"];
8127 [label="CustomAssert.Equal(1, ss.Sections[1].Statements.Count); 159774"];
8128 [label="CustomAssert.Equal(1, ss.Sections[1].Statements.Count); 159775"];
8129 [label="ss.Sections[1].Statements 159776"];
8130 [label="param CSharpSyntaxNode(GreenNode green) 159777"];
8131 [label="param CSharpSyntaxNode(SyntaxNode? parent) 159778"];
8132 [label="param CSharpSyntaxNode(int position) 159779"];
8133 [label="param CSharpSyntaxNode(this) 159780"];
8134 [label="param CSharpSyntaxNode(this) 159781"];
8135 [label="CustomAssert.Equal(';', ss.Sections[0].Statements[0].ToString()); 159782"];
8136 [label="CustomAssert.Equal(';', ss.Sections[0].Statements[0].ToString()); 159783"];
8137 [label="=> true 159784"];
8138 [label="true 159785"];
8139 [label="param WriteTokenTo(bool leading) 159786"];
8140 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 159787"];
8141 [label="this.Text 159788"];
8142 [label="this.Kind 159789"];
8143 [label="SyntaxFacts.GetText(this.Kind) 159790"];
8144 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 159791"];
8145 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 159792"];
8146 [label="ss.CloseBraceToken 159793"];
8147 [label="=> true 159794"];
8148 [label="true 159795"];
8149 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 159796"];
8150 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 159797"];
2 -> 0;
2 -> 1;
3 -> 1;
5 -> 4;
7 -> 6;
9 -> 8;
11 -> 10;
13 -> 12;
15 -> 14;
17 -> 16;
19 -> 18;
21 -> 20;
23 -> 22;
25 -> 24;
27 -> 26;
29 -> 28;
31 -> 30;
33 -> 32;
35 -> 34;
37 -> 36;
39 -> 38;
41 -> 40;
42 -> 0;
43 -> 0;
44 -> 42;
44 -> 43;
44 -> 0;
45 -> 44;
46 -> 0;
47 -> 0;
48 -> 46;
48 -> 47;
48 -> 44;
49 -> 48;
50 -> 0;
51 -> 50;
52 -> 51;
52 -> 50;
53 -> 52;
55 -> 0;
56 -> 54;
56 -> 55;
57 -> 56;
58 -> 0;
59 -> 0;
60 -> 58;
60 -> 59;
60 -> 0;
61 -> 60;
62 -> 0;
63 -> 0;
64 -> 62;
64 -> 63;
64 -> 48;
65 -> 64;
66 -> 0;
67 -> 0;
68 -> 66;
68 -> 67;
68 -> 64;
69 -> 68;
70 -> 0;
71 -> 0;
72 -> 70;
72 -> 71;
72 -> 68;
73 -> 72;
74 -> 0;
75 -> 0;
76 -> 74;
76 -> 75;
76 -> 0;
77 -> 76;
78 -> 0;
79 -> 0;
80 -> 78;
80 -> 79;
80 -> 0;
81 -> 80;
82 -> 0;
83 -> 0;
84 -> 82;
84 -> 83;
84 -> 0;
85 -> 84;
86 -> 0;
87 -> 0;
88 -> 86;
88 -> 87;
88 -> 72;
89 -> 88;
90 -> 0;
91 -> 0;
92 -> 90;
92 -> 91;
92 -> 0;
93 -> 92;
95 -> 0;
96 -> 94;
96 -> 95;
97 -> 96;
98 -> 0;
99 -> 0;
100 -> 98;
100 -> 99;
100 -> 88;
101 -> 100;
102 -> 0;
103 -> 0;
104 -> 102;
104 -> 103;
104 -> 0;
105 -> 104;
106 -> 0;
107 -> 0;
108 -> 106;
108 -> 107;
108 -> 0;
109 -> 108;
110 -> 0;
111 -> 0;
112 -> 110;
112 -> 111;
112 -> 0;
113 -> 112;
114 -> 0;
115 -> 0;
116 -> 114;
116 -> 115;
116 -> 0;
117 -> 116;
118 -> 0;
119 -> 0;
120 -> 118;
120 -> 119;
120 -> 0;
121 -> 120;
122 -> 0;
123 -> 0;
124 -> 122;
124 -> 123;
124 -> 100;
125 -> 124;
126 -> 0;
127 -> 0;
128 -> 126;
128 -> 127;
128 -> 124;
129 -> 128;
130 -> 0;
131 -> 0;
132 -> 130;
132 -> 131;
132 -> 128;
133 -> 132;
134 -> 0;
135 -> 0;
136 -> 134;
136 -> 135;
136 -> 132;
137 -> 136;
138 -> 0;
139 -> 0;
140 -> 138;
140 -> 139;
140 -> 0;
141 -> 140;
142 -> 0;
143 -> 0;
144 -> 142;
144 -> 143;
144 -> 0;
145 -> 144;
146 -> 0;
147 -> 0;
148 -> 146;
148 -> 147;
148 -> 136;
149 -> 148;
150 -> 0;
151 -> 0;
152 -> 150;
152 -> 151;
152 -> 0;
153 -> 152;
154 -> 0;
155 -> 0;
156 -> 154;
156 -> 155;
156 -> 0;
157 -> 156;
158 -> 0;
159 -> 0;
160 -> 158;
160 -> 159;
160 -> 0;
161 -> 160;
162 -> 0;
163 -> 0;
164 -> 162;
164 -> 163;
164 -> 148;
165 -> 164;
166 -> 0;
167 -> 0;
168 -> 166;
168 -> 167;
168 -> 0;
169 -> 168;
170 -> 0;
171 -> 0;
172 -> 170;
172 -> 171;
172 -> 0;
173 -> 172;
175 -> 174;
177 -> 175;
177 -> 176;
178 -> 177;
180 -> 0;
180 -> 179;
181 -> 180;
181 -> 0;
182 -> 181;
184 -> 183;
186 -> 185;
188 -> 187;
190 -> 189;
191 -> 1;
192 -> 1;
193 -> 191;
193 -> 1;
194 -> 193;
194 -> 192;
195 -> 192;
196 -> 195;
197 -> 196;
198 -> 197;
199 -> 198;
199 -> 197;
200 -> 195;
200 -> 192;
201 -> 195;
201 -> 192;
202 -> 195;
202 -> 192;
203 -> 194;
203 -> 195;
203 -> 192;
204 -> 1;
204 -> 2;
204 -> 199;
204 -> 200;
204 -> 201;
204 -> 203;
205 -> 1;
206 -> 1;
207 -> 206;
207 -> 1;
208 -> 1;
209 -> 1;
210 -> 207;
210 -> 209;
211 -> 208;
211 -> 209;
212 -> 208;
212 -> 209;
213 -> 205;
213 -> 209;
215 -> 214;
216 -> 215;
218 -> 216;
218 -> 217;
219 -> 217;
220 -> 217;
221 -> 218;
221 -> 217;
222 -> 219;
222 -> 221;
223 -> 0;
223 -> 222;
224 -> 217;
225 -> 223;
225 -> 224;
225 -> 217;
227 -> 0;
227 -> 217;
228 -> 218;
228 -> 217;
229 -> 217;
230 -> 227;
230 -> 229;
231 -> 228;
231 -> 229;
232 -> 230;
232 -> 229;
233 -> 231;
233 -> 229;
234 -> 229;
235 -> 229;
236 -> 232;
236 -> 235;
237 -> 233;
237 -> 235;
238 -> 234;
238 -> 235;
239 -> 234;
239 -> 235;
240 -> 234;
240 -> 235;
241 -> 236;
241 -> 235;
242 -> 238;
242 -> 235;
243 -> 239;
243 -> 235;
245 -> 244;
246 -> 237;
246 -> 235;
247 -> 235;
248 -> 241;
248 -> 247;
249 -> 242;
249 -> 247;
250 -> 243;
250 -> 247;
251 -> 246;
251 -> 247;
252 -> 240;
252 -> 247;
253 -> 248;
253 -> 247;
254 -> 249;
254 -> 247;
255 -> 250;
255 -> 247;
256 -> 251;
256 -> 247;
257 -> 247;
258 -> 257;
258 -> 253;
258 -> 254;
258 -> 255;
258 -> 256;
258 -> 247;
259 -> 257;
259 -> 247;
260 -> 259;
260 -> 258;
260 -> 247;
261 -> 240;
261 -> 235;
262 -> 237;
262 -> 240;
262 -> 235;
263 -> 236;
263 -> 0;
263 -> 235;
264 -> 234;
264 -> 217;
265 -> 219;
265 -> 217;
266 -> 264;
266 -> 265;
267 -> 266;
270 -> 268;
270 -> 269;
271 -> 269;
272 -> 269;
273 -> 270;
273 -> 269;
274 -> 271;
274 -> 273;
275 -> 0;
275 -> 274;
276 -> 269;
277 -> 275;
277 -> 276;
277 -> 269;
278 -> 0;
278 -> 269;
279 -> 270;
279 -> 269;
280 -> 269;
281 -> 278;
281 -> 280;
282 -> 279;
282 -> 280;
283 -> 281;
283 -> 280;
284 -> 282;
284 -> 280;
285 -> 280;
286 -> 280;
287 -> 283;
287 -> 286;
288 -> 284;
288 -> 286;
289 -> 285;
289 -> 286;
290 -> 285;
290 -> 286;
291 -> 285;
291 -> 286;
292 -> 287;
292 -> 286;
293 -> 289;
293 -> 286;
294 -> 290;
294 -> 286;
295 -> 288;
295 -> 286;
296 -> 286;
297 -> 292;
297 -> 296;
298 -> 293;
298 -> 296;
299 -> 294;
299 -> 296;
300 -> 295;
300 -> 296;
301 -> 291;
301 -> 296;
302 -> 297;
302 -> 296;
303 -> 298;
303 -> 296;
304 -> 299;
304 -> 296;
305 -> 300;
305 -> 296;
306 -> 296;
307 -> 306;
307 -> 302;
307 -> 303;
307 -> 304;
307 -> 305;
307 -> 296;
308 -> 306;
308 -> 296;
309 -> 308;
309 -> 307;
309 -> 296;
310 -> 291;
310 -> 286;
311 -> 288;
311 -> 291;
311 -> 286;
312 -> 287;
312 -> 0;
312 -> 286;
313 -> 285;
313 -> 269;
314 -> 271;
314 -> 269;
315 -> 313;
315 -> 314;
316 -> 315;
319 -> 317;
319 -> 318;
320 -> 318;
321 -> 318;
322 -> 319;
322 -> 318;
323 -> 320;
323 -> 322;
324 -> 0;
324 -> 323;
325 -> 318;
326 -> 324;
326 -> 325;
326 -> 318;
327 -> 0;
327 -> 318;
328 -> 319;
328 -> 318;
329 -> 318;
330 -> 327;
330 -> 329;
331 -> 328;
331 -> 329;
332 -> 330;
332 -> 329;
333 -> 331;
333 -> 329;
334 -> 329;
335 -> 329;
336 -> 332;
336 -> 335;
337 -> 333;
337 -> 335;
338 -> 334;
338 -> 335;
339 -> 334;
339 -> 335;
340 -> 334;
340 -> 335;
341 -> 336;
341 -> 335;
342 -> 338;
342 -> 335;
343 -> 339;
343 -> 335;
344 -> 337;
344 -> 335;
345 -> 335;
346 -> 341;
346 -> 345;
347 -> 342;
347 -> 345;
348 -> 343;
348 -> 345;
349 -> 344;
349 -> 345;
350 -> 340;
350 -> 345;
351 -> 346;
351 -> 345;
352 -> 347;
352 -> 345;
353 -> 348;
353 -> 345;
354 -> 349;
354 -> 345;
355 -> 345;
356 -> 355;
356 -> 351;
356 -> 352;
356 -> 353;
356 -> 354;
356 -> 345;
357 -> 355;
357 -> 345;
358 -> 357;
358 -> 356;
358 -> 345;
359 -> 340;
359 -> 335;
360 -> 337;
360 -> 340;
360 -> 335;
361 -> 336;
361 -> 0;
361 -> 335;
362 -> 334;
362 -> 318;
363 -> 320;
363 -> 318;
364 -> 362;
364 -> 363;
365 -> 364;
368 -> 366;
368 -> 367;
369 -> 367;
370 -> 0;
370 -> 367;
371 -> 368;
371 -> 367;
372 -> 367;
373 -> 370;
373 -> 372;
374 -> 371;
374 -> 372;
375 -> 373;
375 -> 372;
376 -> 374;
376 -> 372;
377 -> 372;
378 -> 372;
379 -> 375;
379 -> 378;
380 -> 376;
380 -> 378;
381 -> 377;
381 -> 378;
382 -> 377;
382 -> 378;
383 -> 377;
383 -> 378;
384 -> 379;
384 -> 378;
385 -> 381;
385 -> 378;
386 -> 382;
386 -> 378;
387 -> 380;
387 -> 378;
388 -> 378;
389 -> 384;
389 -> 388;
390 -> 385;
390 -> 388;
391 -> 386;
391 -> 388;
392 -> 387;
392 -> 388;
393 -> 383;
393 -> 388;
394 -> 389;
394 -> 388;
395 -> 390;
395 -> 388;
396 -> 391;
396 -> 388;
397 -> 392;
397 -> 388;
398 -> 388;
399 -> 398;
399 -> 394;
399 -> 395;
399 -> 396;
399 -> 397;
399 -> 388;
400 -> 398;
400 -> 388;
401 -> 400;
401 -> 399;
401 -> 388;
402 -> 383;
402 -> 378;
403 -> 380;
403 -> 383;
403 -> 378;
404 -> 379;
404 -> 0;
404 -> 378;
405 -> 377;
405 -> 367;
406 -> 369;
406 -> 367;
407 -> 405;
407 -> 406;
408 -> 407;
411 -> 409;
411 -> 410;
412 -> 410;
413 -> 0;
413 -> 410;
414 -> 411;
414 -> 410;
415 -> 410;
416 -> 413;
416 -> 415;
417 -> 414;
417 -> 415;
418 -> 416;
418 -> 415;
419 -> 417;
419 -> 415;
420 -> 415;
421 -> 415;
422 -> 418;
422 -> 421;
423 -> 419;
423 -> 421;
424 -> 420;
424 -> 421;
425 -> 420;
425 -> 421;
426 -> 420;
426 -> 421;
427 -> 422;
427 -> 421;
428 -> 424;
428 -> 421;
429 -> 425;
429 -> 421;
430 -> 423;
430 -> 421;
431 -> 421;
432 -> 427;
432 -> 431;
433 -> 428;
433 -> 431;
434 -> 429;
434 -> 431;
435 -> 430;
435 -> 431;
436 -> 426;
436 -> 431;
437 -> 432;
437 -> 431;
438 -> 433;
438 -> 431;
439 -> 434;
439 -> 431;
440 -> 435;
440 -> 431;
441 -> 431;
442 -> 441;
442 -> 437;
442 -> 438;
442 -> 439;
442 -> 440;
442 -> 431;
443 -> 441;
443 -> 431;
444 -> 443;
444 -> 442;
444 -> 431;
445 -> 426;
445 -> 421;
446 -> 423;
446 -> 426;
446 -> 421;
447 -> 422;
447 -> 0;
447 -> 421;
448 -> 420;
448 -> 410;
449 -> 412;
449 -> 410;
450 -> 448;
450 -> 449;
451 -> 450;
452 -> 215;
454 -> 453;
456 -> 452;
456 -> 455;
457 -> 454;
457 -> 455;
458 -> 455;
459 -> 456;
459 -> 455;
460 -> 457;
460 -> 459;
461 -> 0;
461 -> 460;
462 -> 455;
463 -> 461;
463 -> 462;
463 -> 455;
464 -> 0;
464 -> 455;
465 -> 456;
465 -> 455;
466 -> 455;
467 -> 464;
467 -> 466;
468 -> 465;
468 -> 466;
469 -> 467;
469 -> 466;
470 -> 468;
470 -> 466;
471 -> 466;
472 -> 466;
473 -> 469;
473 -> 472;
474 -> 470;
474 -> 472;
475 -> 471;
475 -> 472;
476 -> 471;
476 -> 472;
477 -> 471;
477 -> 472;
478 -> 473;
478 -> 472;
479 -> 475;
479 -> 472;
480 -> 476;
480 -> 472;
481 -> 474;
481 -> 472;
482 -> 472;
483 -> 478;
483 -> 482;
484 -> 479;
484 -> 482;
485 -> 480;
485 -> 482;
486 -> 481;
486 -> 482;
487 -> 477;
487 -> 482;
488 -> 483;
488 -> 482;
489 -> 484;
489 -> 482;
490 -> 485;
490 -> 482;
491 -> 486;
491 -> 482;
492 -> 482;
493 -> 492;
493 -> 488;
493 -> 489;
493 -> 490;
493 -> 491;
493 -> 482;
494 -> 492;
494 -> 482;
495 -> 494;
495 -> 493;
495 -> 482;
496 -> 477;
496 -> 472;
497 -> 474;
497 -> 477;
497 -> 472;
498 -> 473;
498 -> 0;
498 -> 472;
499 -> 471;
499 -> 455;
500 -> 457;
500 -> 455;
501 -> 499;
501 -> 455;
502 -> 455;
503 -> 0;
503 -> 502;
503 -> 455;
504 -> 501;
504 -> 502;
504 -> 495;
504 -> 496;
504 -> 497;
504 -> 503;
504 -> 0;
504 -> 455;
505 -> 504;
505 -> 502;
506 -> 504;
506 -> 502;
507 -> 502;
508 -> 506;
508 -> 507;
509 -> 508;
509 -> 504;
509 -> 507;
510 -> 509;
510 -> 502;
511 -> 506;
511 -> 504;
511 -> 502;
512 -> 505;
512 -> 502;
513 -> 502;
514 -> 502;
515 -> 510;
515 -> 514;
516 -> 511;
516 -> 514;
517 -> 511;
517 -> 514;
518 -> 512;
518 -> 514;
519 -> 513;
519 -> 514;
520 -> 514;
521 -> 519;
521 -> 520;
522 -> 520;
523 -> 522;
523 -> 515;
523 -> 517;
523 -> 518;
523 -> 516;
523 -> 511;
523 -> 520;
524 -> 522;
524 -> 520;
525 -> 519;
525 -> 514;
526 -> 515;
526 -> 0;
526 -> 514;
527 -> 523;
530 -> 529;
532 -> 528;
532 -> 531;
533 -> 530;
533 -> 531;
534 -> 531;
535 -> 532;
535 -> 531;
536 -> 533;
536 -> 535;
537 -> 0;
537 -> 536;
538 -> 531;
539 -> 537;
539 -> 538;
539 -> 531;
540 -> 0;
540 -> 531;
541 -> 532;
541 -> 531;
542 -> 531;
543 -> 540;
543 -> 542;
544 -> 541;
544 -> 542;
545 -> 543;
545 -> 542;
546 -> 544;
546 -> 542;
547 -> 542;
548 -> 542;
549 -> 545;
549 -> 548;
550 -> 546;
550 -> 548;
551 -> 547;
551 -> 548;
552 -> 547;
552 -> 548;
553 -> 547;
553 -> 548;
554 -> 549;
554 -> 548;
555 -> 551;
555 -> 548;
556 -> 552;
556 -> 548;
557 -> 550;
557 -> 548;
558 -> 548;
559 -> 554;
559 -> 558;
560 -> 555;
560 -> 558;
561 -> 556;
561 -> 558;
562 -> 557;
562 -> 558;
563 -> 553;
563 -> 558;
564 -> 559;
564 -> 558;
565 -> 560;
565 -> 558;
566 -> 561;
566 -> 558;
567 -> 562;
567 -> 558;
568 -> 558;
569 -> 568;
569 -> 564;
569 -> 565;
569 -> 566;
569 -> 567;
569 -> 558;
570 -> 568;
570 -> 558;
571 -> 570;
571 -> 569;
571 -> 558;
572 -> 553;
572 -> 548;
573 -> 550;
573 -> 553;
573 -> 548;
574 -> 549;
574 -> 0;
574 -> 548;
575 -> 547;
575 -> 531;
576 -> 533;
576 -> 531;
577 -> 575;
577 -> 531;
578 -> 531;
579 -> 0;
579 -> 578;
579 -> 531;
580 -> 577;
580 -> 578;
580 -> 571;
580 -> 572;
580 -> 573;
580 -> 579;
580 -> 523;
580 -> 531;
581 -> 578;
582 -> 578;
583 -> 578;
584 -> 582;
584 -> 583;
585 -> 583;
586 -> 584;
586 -> 585;
587 -> 585;
588 -> 587;
588 -> 585;
589 -> 584;
589 -> 583;
590 -> 580;
590 -> 0;
590 -> 583;
591 -> 580;
594 -> 593;
596 -> 592;
596 -> 595;
597 -> 594;
597 -> 595;
598 -> 595;
599 -> 596;
599 -> 595;
600 -> 597;
600 -> 599;
601 -> 0;
601 -> 600;
602 -> 595;
603 -> 601;
603 -> 602;
603 -> 595;
604 -> 0;
604 -> 595;
605 -> 596;
605 -> 595;
606 -> 595;
607 -> 604;
607 -> 606;
608 -> 605;
608 -> 606;
609 -> 607;
609 -> 606;
610 -> 608;
610 -> 606;
611 -> 606;
612 -> 606;
613 -> 609;
613 -> 612;
614 -> 610;
614 -> 612;
615 -> 611;
615 -> 612;
616 -> 611;
616 -> 612;
617 -> 611;
617 -> 612;
618 -> 613;
618 -> 612;
619 -> 615;
619 -> 612;
620 -> 616;
620 -> 612;
621 -> 614;
621 -> 612;
622 -> 612;
623 -> 618;
623 -> 622;
624 -> 619;
624 -> 622;
625 -> 620;
625 -> 622;
626 -> 621;
626 -> 622;
627 -> 617;
627 -> 622;
628 -> 623;
628 -> 622;
629 -> 624;
629 -> 622;
630 -> 625;
630 -> 622;
631 -> 626;
631 -> 622;
632 -> 622;
633 -> 632;
633 -> 628;
633 -> 629;
633 -> 630;
633 -> 631;
633 -> 622;
634 -> 632;
634 -> 622;
635 -> 634;
635 -> 633;
635 -> 622;
636 -> 617;
636 -> 612;
637 -> 614;
637 -> 617;
637 -> 612;
638 -> 613;
638 -> 0;
638 -> 612;
639 -> 611;
639 -> 595;
640 -> 597;
640 -> 595;
641 -> 639;
641 -> 595;
642 -> 595;
643 -> 0;
643 -> 642;
643 -> 595;
644 -> 641;
644 -> 642;
644 -> 635;
644 -> 636;
644 -> 637;
644 -> 643;
644 -> 580;
644 -> 595;
645 -> 642;
646 -> 642;
647 -> 642;
648 -> 646;
648 -> 647;
649 -> 647;
650 -> 648;
650 -> 649;
651 -> 649;
652 -> 651;
652 -> 649;
653 -> 648;
653 -> 647;
654 -> 644;
654 -> 0;
654 -> 647;
655 -> 644;
658 -> 657;
660 -> 656;
660 -> 659;
661 -> 658;
661 -> 659;
662 -> 0;
662 -> 659;
663 -> 660;
663 -> 659;
664 -> 659;
665 -> 662;
665 -> 664;
666 -> 663;
666 -> 664;
667 -> 665;
667 -> 664;
668 -> 666;
668 -> 664;
669 -> 664;
670 -> 664;
671 -> 667;
671 -> 670;
672 -> 668;
672 -> 670;
673 -> 669;
673 -> 670;
674 -> 669;
674 -> 670;
675 -> 669;
675 -> 670;
676 -> 671;
676 -> 670;
677 -> 673;
677 -> 670;
678 -> 674;
678 -> 670;
679 -> 672;
679 -> 670;
680 -> 670;
681 -> 676;
681 -> 680;
682 -> 677;
682 -> 680;
683 -> 678;
683 -> 680;
684 -> 679;
684 -> 680;
685 -> 675;
685 -> 680;
686 -> 681;
686 -> 680;
687 -> 682;
687 -> 680;
688 -> 683;
688 -> 680;
689 -> 684;
689 -> 680;
690 -> 680;
691 -> 690;
691 -> 686;
691 -> 687;
691 -> 688;
691 -> 689;
691 -> 680;
692 -> 690;
692 -> 680;
693 -> 692;
693 -> 691;
693 -> 680;
694 -> 675;
694 -> 670;
695 -> 672;
695 -> 675;
695 -> 670;
696 -> 671;
696 -> 0;
696 -> 670;
697 -> 669;
697 -> 659;
698 -> 661;
698 -> 659;
699 -> 697;
699 -> 659;
700 -> 659;
701 -> 0;
701 -> 700;
701 -> 659;
702 -> 699;
702 -> 700;
702 -> 693;
702 -> 694;
702 -> 695;
702 -> 701;
702 -> 644;
702 -> 659;
703 -> 700;
704 -> 700;
705 -> 700;
706 -> 704;
706 -> 705;
707 -> 705;
708 -> 706;
708 -> 707;
709 -> 707;
710 -> 709;
710 -> 707;
711 -> 706;
711 -> 705;
712 -> 702;
712 -> 0;
712 -> 705;
713 -> 702;
716 -> 715;
718 -> 714;
718 -> 717;
719 -> 716;
719 -> 717;
720 -> 0;
720 -> 717;
721 -> 718;
721 -> 717;
722 -> 717;
723 -> 720;
723 -> 722;
724 -> 721;
724 -> 722;
725 -> 723;
725 -> 722;
726 -> 724;
726 -> 722;
727 -> 722;
728 -> 722;
729 -> 725;
729 -> 728;
730 -> 726;
730 -> 728;
731 -> 727;
731 -> 728;
732 -> 727;
732 -> 728;
733 -> 727;
733 -> 728;
734 -> 729;
734 -> 728;
735 -> 731;
735 -> 728;
736 -> 732;
736 -> 728;
737 -> 730;
737 -> 728;
738 -> 728;
739 -> 734;
739 -> 738;
740 -> 735;
740 -> 738;
741 -> 736;
741 -> 738;
742 -> 737;
742 -> 738;
743 -> 733;
743 -> 738;
744 -> 739;
744 -> 738;
745 -> 740;
745 -> 738;
746 -> 741;
746 -> 738;
747 -> 742;
747 -> 738;
748 -> 738;
749 -> 748;
749 -> 744;
749 -> 745;
749 -> 746;
749 -> 747;
749 -> 738;
750 -> 748;
750 -> 738;
751 -> 750;
751 -> 749;
751 -> 738;
752 -> 733;
752 -> 728;
753 -> 730;
753 -> 733;
753 -> 728;
754 -> 729;
754 -> 0;
754 -> 728;
755 -> 727;
755 -> 717;
756 -> 719;
756 -> 717;
757 -> 755;
757 -> 717;
758 -> 717;
759 -> 0;
759 -> 758;
759 -> 717;
760 -> 757;
760 -> 758;
760 -> 751;
760 -> 752;
760 -> 753;
760 -> 759;
760 -> 702;
760 -> 717;
761 -> 758;
762 -> 758;
763 -> 758;
764 -> 762;
764 -> 763;
765 -> 763;
766 -> 764;
766 -> 765;
767 -> 765;
768 -> 767;
768 -> 765;
769 -> 764;
769 -> 763;
770 -> 760;
770 -> 0;
770 -> 763;
771 -> 760;
772 -> 0;
774 -> 773;
776 -> 772;
776 -> 775;
777 -> 774;
777 -> 775;
778 -> 0;
778 -> 775;
779 -> 776;
779 -> 775;
780 -> 775;
781 -> 778;
781 -> 780;
782 -> 779;
782 -> 780;
783 -> 781;
783 -> 780;
784 -> 782;
784 -> 780;
785 -> 780;
786 -> 780;
787 -> 783;
787 -> 786;
788 -> 784;
788 -> 786;
789 -> 785;
789 -> 786;
790 -> 785;
790 -> 786;
791 -> 785;
791 -> 786;
792 -> 787;
792 -> 786;
793 -> 789;
793 -> 786;
794 -> 790;
794 -> 786;
795 -> 788;
795 -> 786;
796 -> 786;
797 -> 792;
797 -> 796;
798 -> 793;
798 -> 796;
799 -> 794;
799 -> 796;
800 -> 795;
800 -> 796;
801 -> 791;
801 -> 796;
802 -> 797;
802 -> 796;
803 -> 798;
803 -> 796;
804 -> 799;
804 -> 796;
805 -> 800;
805 -> 796;
806 -> 796;
807 -> 806;
807 -> 802;
807 -> 803;
807 -> 804;
807 -> 805;
807 -> 796;
808 -> 806;
808 -> 796;
809 -> 808;
809 -> 807;
809 -> 796;
810 -> 791;
810 -> 786;
811 -> 788;
811 -> 791;
811 -> 786;
812 -> 787;
812 -> 0;
812 -> 786;
813 -> 785;
813 -> 775;
814 -> 777;
814 -> 775;
815 -> 813;
815 -> 775;
816 -> 775;
817 -> 0;
817 -> 816;
817 -> 775;
818 -> 815;
818 -> 816;
818 -> 809;
818 -> 810;
818 -> 811;
818 -> 817;
818 -> 760;
818 -> 775;
819 -> 816;
820 -> 816;
821 -> 816;
822 -> 820;
822 -> 821;
823 -> 821;
824 -> 822;
824 -> 823;
825 -> 823;
826 -> 825;
826 -> 823;
827 -> 822;
827 -> 821;
828 -> 818;
828 -> 0;
828 -> 821;
829 -> 818;
832 -> 267;
832 -> 831;
833 -> 831;
834 -> 832;
834 -> 831;
835 -> 833;
835 -> 834;
835 -> 260;
835 -> 261;
835 -> 262;
835 -> 831;
837 -> 316;
837 -> 836;
838 -> 836;
839 -> 837;
839 -> 836;
840 -> 838;
840 -> 839;
840 -> 309;
840 -> 310;
840 -> 311;
840 -> 836;
842 -> 365;
842 -> 841;
843 -> 841;
844 -> 842;
844 -> 841;
845 -> 843;
845 -> 844;
845 -> 358;
845 -> 359;
845 -> 360;
845 -> 841;
847 -> 408;
847 -> 846;
848 -> 846;
849 -> 847;
849 -> 846;
850 -> 848;
850 -> 849;
850 -> 401;
850 -> 402;
850 -> 403;
850 -> 846;
852 -> 451;
852 -> 851;
853 -> 851;
854 -> 852;
854 -> 851;
855 -> 853;
855 -> 854;
855 -> 444;
855 -> 445;
855 -> 446;
855 -> 851;
857 -> 527;
857 -> 856;
858 -> 856;
859 -> 857;
859 -> 856;
860 -> 858;
860 -> 859;
860 -> 818;
860 -> 856;
862 -> 591;
862 -> 861;
863 -> 861;
864 -> 862;
864 -> 861;
865 -> 863;
865 -> 864;
865 -> 860;
865 -> 861;
867 -> 655;
867 -> 866;
868 -> 866;
869 -> 867;
869 -> 866;
870 -> 868;
870 -> 869;
870 -> 865;
870 -> 866;
872 -> 713;
872 -> 871;
873 -> 871;
874 -> 872;
874 -> 871;
875 -> 873;
875 -> 874;
875 -> 870;
875 -> 871;
877 -> 771;
877 -> 876;
878 -> 876;
879 -> 877;
879 -> 876;
880 -> 878;
880 -> 879;
880 -> 875;
880 -> 876;
882 -> 829;
882 -> 881;
883 -> 881;
884 -> 882;
884 -> 881;
885 -> 883;
885 -> 884;
885 -> 880;
885 -> 881;
886 -> 210;
886 -> 209;
887 -> 211;
887 -> 209;
888 -> 212;
888 -> 209;
889 -> 209;
890 -> 209;
891 -> 886;
891 -> 890;
892 -> 887;
892 -> 890;
893 -> 888;
893 -> 890;
894 -> 889;
894 -> 890;
895 -> 891;
895 -> 890;
896 -> 892;
896 -> 890;
897 -> 893;
897 -> 890;
898 -> 890;
899 -> 895;
899 -> 898;
900 -> 896;
900 -> 898;
901 -> 897;
901 -> 898;
902 -> 899;
902 -> 898;
903 -> 900;
903 -> 898;
904 -> 898;
905 -> 902;
905 -> 904;
906 -> 903;
906 -> 904;
907 -> 905;
907 -> 904;
908 -> 0;
908 -> 904;
909 -> 904;
910 -> 906;
910 -> 904;
911 -> 907;
911 -> 910;
911 -> 904;
913 -> 912;
914 -> 912;
915 -> 912;
916 -> 912;
917 -> 912;
918 -> 913;
918 -> 912;
919 -> 914;
919 -> 912;
920 -> 915;
920 -> 912;
921 -> 916;
921 -> 912;
922 -> 921;
922 -> 912;
923 -> 0;
923 -> 912;
924 -> 918;
924 -> 917;
925 -> 919;
925 -> 917;
926 -> 920;
926 -> 917;
927 -> 922;
927 -> 917;
928 -> 923;
928 -> 917;
929 -> 917;
930 -> 926;
930 -> 917;
931 -> 925;
931 -> 917;
932 -> 929;
932 -> 930;
932 -> 931;
932 -> 917;
933 -> 929;
933 -> 917;
934 -> 929;
934 -> 917;
935 -> 929;
935 -> 917;
936 -> 924;
936 -> 929;
936 -> 917;
937 -> 924;
937 -> 917;
938 -> 917;
939 -> 937;
939 -> 938;
940 -> 939;
940 -> 938;
941 -> 0;
941 -> 940;
942 -> 941;
942 -> 929;
942 -> 917;
943 -> 927;
943 -> 917;
944 -> 943;
944 -> 929;
944 -> 917;
945 -> 928;
945 -> 917;
946 -> 0;
946 -> 917;
947 -> 945;
947 -> 929;
947 -> 917;
948 -> 912;
950 -> 949;
953 -> 952;
955 -> 954;
966 -> 957;
966 -> 956;
967 -> 958;
967 -> 956;
968 -> 959;
968 -> 956;
969 -> 960;
969 -> 956;
970 -> 961;
970 -> 956;
971 -> 962;
971 -> 956;
972 -> 963;
972 -> 956;
973 -> 964;
973 -> 956;
974 -> 965;
974 -> 956;
975 -> 956;
977 -> 976;
978 -> 948;
978 -> 898;
979 -> 978;
979 -> 901;
979 -> 898;
980 -> 898;
981 -> 898;
982 -> 911;
982 -> 981;
983 -> 979;
983 -> 981;
984 -> 980;
984 -> 981;
985 -> 980;
985 -> 981;
986 -> 980;
986 -> 981;
987 -> 982;
987 -> 981;
988 -> 981;
989 -> 987;
989 -> 988;
990 -> 986;
990 -> 988;
991 -> 990;
991 -> 988;
992 -> 990;
992 -> 988;
993 -> 0;
995 -> 994;
997 -> 996;
998 -> 997;
999 -> 989;
999 -> 988;
1000 -> 988;
1001 -> 988;
1002 -> 999;
1002 -> 1001;
1003 -> 1000;
1003 -> 1001;
1004 -> 1003;
1004 -> 1001;
1005 -> 1003;
1005 -> 1001;
1006 -> 1003;
1006 -> 1001;
1007 -> 1003;
1007 -> 1001;
1008 -> 1003;
1008 -> 1001;
1009 -> 1003;
1009 -> 1001;
1010 -> 1003;
1010 -> 1001;
1011 -> 1003;
1011 -> 1001;
1012 -> 1002;
1012 -> 1003;
1012 -> 1001;
1013 -> 1001;
1014 -> 1013;
1014 -> 1003;
1014 -> 1001;
1015 -> 1001;
1016 -> 1015;
1016 -> 1003;
1016 -> 1001;
1017 -> 1002;
1017 -> 911;
1017 -> 1003;
1017 -> 1001;
1018 -> 1001;
1019 -> 1018;
1019 -> 1003;
1019 -> 1001;
1020 -> 998;
1020 -> 997;
1020 -> 1001;
1021 -> 1020;
1021 -> 1003;
1021 -> 1001;
1022 -> 1001;
1023 -> 1022;
1023 -> 1003;
1023 -> 1001;
1024 -> 1000;
1024 -> 990;
1024 -> 988;
1025 -> 986;
1025 -> 981;
1026 -> 986;
1026 -> 981;
1027 -> 986;
1027 -> 981;
1028 -> 986;
1028 -> 981;
1029 -> 986;
1029 -> 981;
1030 -> 986;
1030 -> 981;
1031 -> 986;
1031 -> 981;
1032 -> 986;
1032 -> 981;
1033 -> 986;
1033 -> 981;
1034 -> 986;
1034 -> 981;
1035 -> 981;
1036 -> 1035;
1036 -> 981;
1037 -> 1036;
1037 -> 986;
1037 -> 981;
1038 -> 981;
1039 -> 1038;
1039 -> 981;
1040 -> 1039;
1040 -> 986;
1040 -> 981;
1041 -> 986;
1041 -> 981;
1042 -> 986;
1042 -> 981;
1043 -> 981;
1044 -> 983;
1044 -> 1043;
1044 -> 981;
1045 -> 983;
1045 -> 986;
1045 -> 981;
1046 -> 981;
1047 -> 1046;
1047 -> 986;
1047 -> 981;
1048 -> 981;
1049 -> 1048;
1049 -> 986;
1049 -> 981;
1052 -> 1050;
1052 -> 1051;
1053 -> 1052;
1055 -> 1054;
1056 -> 981;
1057 -> 981;
1058 -> 1056;
1058 -> 1057;
1059 -> 1058;
1059 -> 1057;
1060 -> 1058;
1060 -> 1057;
1061 -> 1058;
1061 -> 1057;
1062 -> 1057;
1063 -> 1062;
1063 -> 1058;
1063 -> 1057;
1064 -> 1057;
1065 -> 1064;
1065 -> 1058;
1065 -> 1057;
1066 -> 1053;
1066 -> 1052;
1066 -> 1057;
1067 -> 1066;
1067 -> 1058;
1067 -> 1057;
1068 -> 1056;
1068 -> 986;
1068 -> 981;
1069 -> 986;
1069 -> 981;
1070 -> 984;
1070 -> 986;
1070 -> 981;
1071 -> 985;
1071 -> 986;
1071 -> 981;
1072 -> 980;
1072 -> 890;
1073 -> 1072;
1073 -> 890;
1074 -> 890;
1075 -> 1073;
1075 -> 1074;
1076 -> 0;
1077 -> 1075;
1077 -> 1074;
1078 -> 1074;
1079 -> 1074;
1080 -> 1077;
1080 -> 1079;
1081 -> 1078;
1081 -> 1079;
1082 -> 1078;
1082 -> 1079;
1083 -> 1078;
1083 -> 1079;
1084 -> 1078;
1084 -> 1079;
1085 -> 1078;
1085 -> 1079;
1088 -> 1086;
1088 -> 1087;
1089 -> 1088;
1090 -> 1080;
1090 -> 1079;
1091 -> 1083;
1091 -> 1079;
1092 -> 1081;
1092 -> 1079;
1093 -> 1082;
1093 -> 1079;
1094 -> 1079;
1095 -> 1079;
1096 -> 1084;
1096 -> 1079;
1097 -> 1079;
1098 -> 1090;
1098 -> 1097;
1099 -> 1091;
1099 -> 1097;
1100 -> 1092;
1100 -> 1097;
1101 -> 1093;
1101 -> 1097;
1102 -> 1094;
1102 -> 1097;
1103 -> 1095;
1103 -> 1097;
1104 -> 1096;
1104 -> 1097;
1105 -> 1085;
1105 -> 1097;
1106 -> 1105;
1106 -> 1097;
1107 -> 1105;
1107 -> 1097;
1108 -> 1105;
1108 -> 1097;
1109 -> 1105;
1109 -> 1097;
1110 -> 1105;
1110 -> 1097;
1111 -> 1105;
1111 -> 1097;
1112 -> 1105;
1112 -> 1097;
1113 -> 1105;
1113 -> 1097;
1114 -> 1105;
1114 -> 1097;
1115 -> 1105;
1115 -> 1097;
1116 -> 1105;
1116 -> 1097;
1117 -> 1105;
1117 -> 1097;
1118 -> 1105;
1118 -> 1097;
1119 -> 1098;
1119 -> 1105;
1119 -> 1097;
1120 -> 1099;
1120 -> 1105;
1120 -> 1097;
1121 -> 1102;
1121 -> 1105;
1121 -> 1097;
1122 -> 1104;
1122 -> 1105;
1122 -> 1097;
1123 -> 1097;
1124 -> 1123;
1124 -> 1105;
1124 -> 1097;
1125 -> 1097;
1126 -> 1100;
1126 -> 1125;
1126 -> 1097;
1127 -> 1126;
1127 -> 1105;
1127 -> 1097;
1128 -> 1097;
1129 -> 1105;
1129 -> 1128;
1130 -> 1129;
1130 -> 1127;
1130 -> 1128;
1131 -> 1130;
1131 -> 1097;
1132 -> 1131;
1132 -> 1102;
1132 -> 1097;
1133 -> 1132;
1134 -> 1133;
1134 -> 1105;
1134 -> 1132;
1135 -> 1132;
1136 -> 1135;
1136 -> 1105;
1136 -> 1132;
1137 -> 1097;
1138 -> 1105;
1138 -> 1137;
1139 -> 1138;
1139 -> 1127;
1139 -> 1137;
1140 -> 1139;
1140 -> 1097;
1141 -> 1103;
1141 -> 1140;
1141 -> 1097;
1142 -> 1141;
1142 -> 1104;
1142 -> 1078;
1142 -> 1097;
1143 -> 1142;
1144 -> 1105;
1144 -> 1143;
1145 -> 1143;
1146 -> 1143;
1147 -> 1144;
1147 -> 1119;
1147 -> 1024;
1147 -> 1146;
1148 -> 1147;
1148 -> 1012;
1148 -> 1146;
1149 -> 1148;
1149 -> 1143;
1150 -> 1149;
1150 -> 1143;
1151 -> 1150;
1151 -> 1144;
1151 -> 1143;
1152 -> 1144;
1152 -> 1119;
1152 -> 1143;
1153 -> 1144;
1153 -> 1120;
1153 -> 1143;
1154 -> 1143;
1155 -> 1154;
1155 -> 1149;
1155 -> 1143;
1156 -> 1153;
1156 -> 1155;
1157 -> 1155;
1158 -> 1156;
1158 -> 1157;
1159 -> 1152;
1159 -> 1157;
1160 -> 951;
1160 -> 1157;
1161 -> 1158;
1161 -> 1159;
1161 -> 1157;
1162 -> 1159;
1162 -> 1161;
1162 -> 1157;
1163 -> 1159;
1163 -> 1024;
1163 -> 992;
1163 -> 1045;
1163 -> 1161;
1163 -> 1047;
1163 -> 1049;
1163 -> 1029;
1163 -> 1068;
1163 -> 1070;
1163 -> 1071;
1163 -> 1033;
1163 -> 1034;
1163 -> 1037;
1163 -> 1040;
1163 -> 1041;
1163 -> 1069;
1163 -> 1012;
1163 -> 1014;
1163 -> 1016;
1163 -> 1017;
1163 -> 1021;
1163 -> 1009;
1163 -> 1023;
1163 -> 1019;
1163 -> 911;
1163 -> 1036;
1163 -> 1039;
1163 -> 932;
1163 -> 933;
1163 -> 947;
1163 -> 934;
1163 -> 942;
1163 -> 935;
1163 -> 936;
1163 -> 944;
1163 -> 945;
1163 -> 943;
1163 -> 1046;
1163 -> 1048;
1163 -> 1063;
1163 -> 1065;
1163 -> 1067;
1163 -> 1066;
1163 -> 1064;
1163 -> 1062;
1163 -> 1018;
1163 -> 1020;
1163 -> 1162;
1164 -> 1162;
1165 -> 1163;
1165 -> 1164;
1166 -> 1164;
1167 -> 1165;
1167 -> 1163;
1167 -> 1166;
1168 -> 1167;
1168 -> 1163;
1168 -> 1166;
1169 -> 1164;
1170 -> 1164;
1171 -> 1170;
1171 -> 1165;
1171 -> 1164;
1172 -> 1163;
1172 -> 1164;
1173 -> 1172;
1173 -> 1163;
1173 -> 1164;
1174 -> 1163;
1174 -> 1173;
1174 -> 1168;
1174 -> 1171;
1174 -> 1162;
1175 -> 1163;
1175 -> 1164;
1176 -> 1175;
1176 -> 1174;
1176 -> 1164;
1177 -> 1163;
1177 -> 1164;
1178 -> 1177;
1178 -> 1176;
1178 -> 1164;
1179 -> 1163;
1179 -> 1164;
1180 -> 1163;
1180 -> 1164;
1181 -> 1180;
1181 -> 1178;
1181 -> 1179;
1181 -> 1164;
1182 -> 1181;
1182 -> 1180;
1182 -> 1164;
1183 -> 1163;
1183 -> 1164;
1184 -> 1183;
1184 -> 1178;
1184 -> 1164;
1185 -> 1163;
1185 -> 1184;
1185 -> 1178;
1185 -> 1182;
1185 -> 1162;
1186 -> 1163;
1186 -> 1164;
1187 -> 1163;
1187 -> 1164;
1188 -> 1186;
1188 -> 1187;
1188 -> 1185;
1188 -> 1164;
1189 -> 1164;
1190 -> 1188;
1190 -> 1189;
1190 -> 1164;
1191 -> 1188;
1191 -> 1187;
1191 -> 1185;
1191 -> 1164;
1192 -> 1188;
1192 -> 1187;
1192 -> 1190;
1193 -> 1162;
1194 -> 1159;
1194 -> 1193;
1195 -> 1194;
1195 -> 1192;
1195 -> 1193;
1196 -> 1193;
1197 -> 1194;
1197 -> 1195;
1197 -> 1196;
1198 -> 1197;
1198 -> 1195;
1198 -> 1196;
1199 -> 1198;
1199 -> 1193;
1200 -> 1193;
1201 -> 1194;
1201 -> 1195;
1201 -> 1193;
1202 -> 1193;
1203 -> 1199;
1203 -> 1202;
1204 -> 1200;
1204 -> 1202;
1205 -> 1201;
1205 -> 1202;
1206 -> 1194;
1206 -> 1202;
1207 -> 1204;
1207 -> 1202;
1208 -> 1202;
1209 -> 1208;
1210 -> 1206;
1210 -> 1209;
1211 -> 1209;
1212 -> 1210;
1212 -> 1195;
1212 -> 1211;
1213 -> 1209;
1214 -> 1209;
1215 -> 1214;
1215 -> 1210;
1215 -> 1209;
1216 -> 1208;
1217 -> 1208;
1218 -> 1206;
1218 -> 1195;
1218 -> 1217;
1219 -> 1218;
1219 -> 1195;
1219 -> 1217;
1220 -> 1217;
1221 -> 1218;
1221 -> 1220;
1222 -> 1221;
1222 -> 1195;
1222 -> 1220;
1223 -> 1222;
1224 -> 1221;
1224 -> 1223;
1225 -> 1224;
1225 -> 1195;
1225 -> 1223;
1226 -> 1225;
1226 -> 1222;
1227 -> 1222;
1228 -> 1221;
1228 -> 1195;
1228 -> 1212;
1228 -> 1227;
1228 -> 1222;
1229 -> 1221;
1229 -> 1195;
1229 -> 1212;
1229 -> 1215;
1229 -> 1222;
1230 -> 1221;
1230 -> 1195;
1230 -> 1222;
1231 -> 1221;
1231 -> 1195;
1231 -> 1212;
1231 -> 1215;
1231 -> 1222;
1232 -> 1221;
1232 -> 1195;
1232 -> 1222;
1233 -> 1231;
1233 -> 1222;
1234 -> 1221;
1234 -> 1233;
1234 -> 1231;
1234 -> 1222;
1235 -> 1234;
1235 -> 1221;
1235 -> 1222;
1236 -> 1222;
1237 -> 1231;
1237 -> 1236;
1237 -> 1222;
1238 -> 1237;
1238 -> 1217;
1239 -> 1218;
1239 -> 1233;
1239 -> 1235;
1239 -> 1217;
1240 -> 1239;
1240 -> 1208;
1241 -> 1208;
1242 -> 1240;
1242 -> 1241;
1242 -> 1208;
1243 -> 1242;
1244 -> 1240;
1244 -> 1208;
1245 -> 1244;
1246 -> 1194;
1246 -> 1233;
1246 -> 1205;
1246 -> 1193;
1247 -> 1193;
1248 -> 1193;
1249 -> 1194;
1249 -> 1248;
1250 -> 1248;
1251 -> 1249;
1251 -> 1233;
1251 -> 1250;
1252 -> 1248;
1253 -> 1248;
1254 -> 1253;
1254 -> 1249;
1254 -> 1248;
1255 -> 1193;
1256 -> 1247;
1256 -> 1193;
1257 -> 1256;
1257 -> 1194;
1257 -> 1233;
1257 -> 1235;
1257 -> 1205;
1257 -> 1251;
1257 -> 1254;
1257 -> 1247;
1257 -> 1193;
1258 -> 1193;
1259 -> 1257;
1259 -> 1258;
1260 -> 1259;
1260 -> 1257;
1260 -> 1258;
1261 -> 1257;
1261 -> 1260;
1261 -> 1258;
1262 -> 1257;
1262 -> 1260;
1262 -> 1258;
1263 -> 1257;
1263 -> 1258;
1264 -> 1257;
1264 -> 1258;
1265 -> 0;
1265 -> 1263;
1265 -> 1258;
1266 -> 1263;
1266 -> 1258;
1267 -> 1258;
1268 -> 1266;
1268 -> 1267;
1269 -> 1264;
1269 -> 1267;
1270 -> 1268;
1270 -> 1267;
1271 -> 1270;
1271 -> 1269;
1271 -> 1262;
1271 -> 1265;
1271 -> 1267;
1272 -> 1267;
1273 -> 1271;
1273 -> 1272;
1274 -> 1271;
1274 -> 1272;
1275 -> 1271;
1275 -> 1272;
1276 -> 1271;
1276 -> 1272;
1277 -> 1273;
1277 -> 1272;
1278 -> 1274;
1278 -> 1272;
1279 -> 1275;
1279 -> 1272;
1280 -> 1276;
1280 -> 1271;
1280 -> 1277;
1280 -> 1278;
1280 -> 1279;
1280 -> 1272;
1281 -> 1280;
1282 -> 0;
1282 -> 1281;
1283 -> 1281;
1284 -> 1282;
1284 -> 1283;
1285 -> 1264;
1285 -> 1283;
1286 -> 1285;
1286 -> 1280;
1286 -> 1283;
1287 -> 1283;
1288 -> 1286;
1288 -> 1287;
1289 -> 1288;
1289 -> 0;
1289 -> 1287;
1290 -> 1289;
1290 -> 1284;
1290 -> 1283;
1291 -> 1280;
1291 -> 1290;
1292 -> 1290;
1293 -> 1291;
1293 -> 1292;
1294 -> 1291;
1294 -> 1292;
1295 -> 1264;
1295 -> 1280;
1295 -> 1292;
1296 -> 1293;
1296 -> 1055;
1296 -> 1292;
1298 -> 1297;
1299 -> 1297;
1300 -> 1293;
1300 -> 1292;
1301 -> 1300;
1301 -> 1295;
1301 -> 1280;
1301 -> 1292;
1302 -> 1292;
1303 -> 1301;
1303 -> 1302;
1304 -> 1303;
1304 -> 1302;
1305 -> 0;
1305 -> 1304;
1306 -> 1305;
1306 -> 0;
1306 -> 1292;
1307 -> 1280;
1307 -> 1305;
1307 -> 1306;
1308 -> 1306;
1309 -> 1307;
1309 -> 1308;
1310 -> 1309;
1310 -> 1308;
1311 -> 1310;
1312 -> 1280;
1312 -> 1305;
1312 -> 0;
1312 -> 1281;
1313 -> 1280;
1314 -> 1280;
1314 -> 1313;
1314 -> 1305;
1314 -> 1193;
1315 -> 1246;
1315 -> 1193;
1316 -> 1193;
1317 -> 1315;
1317 -> 1316;
1318 -> 1316;
1319 -> 1316;
1320 -> 1317;
1320 -> 1319;
1320 -> 1316;
1321 -> 1320;
1322 -> 1321;
1322 -> 1317;
1322 -> 1314;
1322 -> 1320;
1323 -> 1318;
1323 -> 1316;
1324 -> 1323;
1324 -> 1193;
1325 -> 1193;
1326 -> 1324;
1326 -> 1325;
1327 -> 1194;
1327 -> 1325;
1328 -> 1325;
1329 -> 1327;
1329 -> 1314;
1329 -> 1328;
1329 -> 1325;
1330 -> 1329;
1331 -> 1330;
1331 -> 1193;
1332 -> 1194;
1332 -> 1314;
1332 -> 1193;
1333 -> 1193;
1334 -> 1194;
1334 -> 1332;
1334 -> 1193;
1335 -> 1193;
1336 -> 1333;
1336 -> 1335;
1337 -> 1333;
1337 -> 1335;
1338 -> 1334;
1338 -> 1335;
1339 -> 1194;
1339 -> 1335;
1340 -> 1337;
1340 -> 1335;
1341 -> 1335;
1342 -> 1341;
1343 -> 1339;
1343 -> 1342;
1344 -> 1342;
1345 -> 1343;
1345 -> 1332;
1345 -> 1344;
1346 -> 1342;
1347 -> 1342;
1348 -> 1347;
1348 -> 1343;
1348 -> 1342;
1349 -> 1341;
1350 -> 1341;
1351 -> 1339;
1351 -> 1332;
1351 -> 1350;
1352 -> 1351;
1352 -> 1332;
1352 -> 1350;
1353 -> 1351;
1353 -> 1341;
1354 -> 1341;
1355 -> 1353;
1355 -> 1354;
1355 -> 1341;
1356 -> 1339;
1356 -> 1332;
1356 -> 1345;
1356 -> 1348;
1356 -> 1355;
1357 -> 1355;
1358 -> 1356;
1358 -> 1357;
1359 -> 1356;
1359 -> 1357;
1360 -> 1359;
1360 -> 1356;
1360 -> 1357;
1361 -> 1356;
1361 -> 1360;
1361 -> 1357;
1362 -> 1356;
1362 -> 1357;
1363 -> 1362;
1363 -> 1360;
1363 -> 1357;
1364 -> 1338;
1364 -> 1355;
1365 -> 1355;
1366 -> 1363;
1366 -> 1365;
1367 -> 1364;
1367 -> 1365;
1368 -> 1339;
1368 -> 1365;
1369 -> 1365;
1370 -> 1368;
1370 -> 1369;
1371 -> 1369;
1372 -> 1370;
1372 -> 1363;
1372 -> 1371;
1372 -> 1369;
1373 -> 1372;
1373 -> 1365;
1374 -> 1365;
1375 -> 1367;
1375 -> 1374;
1375 -> 1365;
1376 -> 1366;
1376 -> 1365;
1377 -> 1367;
1377 -> 1376;
1377 -> 1363;
1377 -> 1365;
1378 -> 1377;
1378 -> 1350;
1379 -> 1377;
1380 -> 1377;
1380 -> 1341;
1381 -> 1380;
1382 -> 1194;
1382 -> 1377;
1382 -> 1367;
1382 -> 1193;
1383 -> 1314;
1383 -> 1193;
1384 -> 1246;
1384 -> 1193;
1385 -> 1382;
1385 -> 1193;
1386 -> 1331;
1386 -> 1193;
1387 -> 1193;
1388 -> 1383;
1388 -> 1387;
1389 -> 1384;
1389 -> 1387;
1390 -> 1385;
1390 -> 1387;
1391 -> 1386;
1391 -> 1387;
1392 -> 1194;
1392 -> 1387;
1393 -> 1388;
1393 -> 1314;
1393 -> 0;
1393 -> 1387;
1394 -> 1389;
1394 -> 1377;
1394 -> 1348;
1394 -> 1367;
1394 -> 1387;
1395 -> 1390;
1395 -> 1394;
1395 -> 1387;
1396 -> 1387;
1397 -> 1388;
1397 -> 1314;
1397 -> 1387;
1398 -> 1388;
1398 -> 1314;
1398 -> 1397;
1399 -> 1388;
1399 -> 1314;
1399 -> 1398;
1400 -> 1398;
1401 -> 1399;
1401 -> 1400;
1402 -> 1401;
1402 -> 0;
1402 -> 1400;
1403 -> 1394;
1403 -> 1398;
1404 -> 1388;
1404 -> 1314;
1404 -> 1398;
1405 -> 1395;
1405 -> 1398;
1406 -> 1398;
1407 -> 1403;
1407 -> 1406;
1408 -> 1404;
1408 -> 1406;
1409 -> 1405;
1409 -> 1406;
1410 -> 0;
1411 -> 0;
1413 -> 1411;
1413 -> 1412;
1414 -> 1413;
1415 -> 1414;
1417 -> 1411;
1417 -> 1416;
1418 -> 1417;
1419 -> 1418;
1421 -> 1411;
1421 -> 1420;
1422 -> 1421;
1423 -> 1422;
1425 -> 1411;
1425 -> 1424;
1426 -> 1425;
1427 -> 1426;
1429 -> 1410;
1430 -> 1429;
1430 -> 1411;
1431 -> 1415;
1431 -> 1414;
1431 -> 1429;
1431 -> 1430;
1432 -> 1429;
1432 -> 1430;
1433 -> 1430;
1434 -> 1430;
1435 -> 1432;
1435 -> 1434;
1436 -> 1433;
1436 -> 1434;
1437 -> 1435;
1437 -> 1434;
1438 -> 1434;
1439 -> 1437;
1439 -> 1438;
1440 -> 1436;
1440 -> 1438;
1441 -> 1439;
1441 -> 1438;
1442 -> 1438;
1443 -> 1442;
1443 -> 1441;
1443 -> 1438;
1444 -> 1442;
1444 -> 1438;
1445 -> 1444;
1445 -> 1443;
1445 -> 1438;
1446 -> 1434;
1447 -> 1436;
1447 -> 1446;
1448 -> 1446;
1449 -> 1447;
1449 -> 1448;
1450 -> 1449;
1450 -> 1445;
1450 -> 1448;
1451 -> 1450;
1451 -> 1446;
1452 -> 1446;
1453 -> 1451;
1453 -> 1452;
1454 -> 1453;
1454 -> 1452;
1455 -> 1454;
1456 -> 1455;
1456 -> 1434;
1457 -> 1456;
1457 -> 1436;
1457 -> 1434;
1458 -> 1436;
1458 -> 1445;
1458 -> 0;
1458 -> 1434;
1459 -> 1458;
1459 -> 1436;
1459 -> 1434;
1460 -> 1433;
1460 -> 1431;
1460 -> 1430;
1462 -> 1419;
1462 -> 1418;
1462 -> 1429;
1462 -> 1430;
1463 -> 1429;
1463 -> 1430;
1464 -> 829;
1464 -> 1430;
1465 -> 1430;
1466 -> 1430;
1467 -> 1463;
1467 -> 1466;
1468 -> 1464;
1468 -> 1466;
1469 -> 1464;
1469 -> 1466;
1470 -> 1465;
1470 -> 1466;
1471 -> 1467;
1471 -> 1466;
1472 -> 1466;
1473 -> 1471;
1473 -> 1472;
1474 -> 1470;
1474 -> 1472;
1475 -> 1473;
1475 -> 1472;
1476 -> 1472;
1477 -> 1475;
1477 -> 1476;
1478 -> 1474;
1478 -> 1476;
1479 -> 1477;
1479 -> 1476;
1480 -> 1476;
1481 -> 1480;
1481 -> 1479;
1481 -> 1476;
1482 -> 1480;
1482 -> 1476;
1483 -> 1482;
1483 -> 1481;
1483 -> 1476;
1484 -> 1472;
1485 -> 1474;
1485 -> 1484;
1486 -> 1484;
1487 -> 1485;
1487 -> 1486;
1488 -> 1487;
1488 -> 1483;
1488 -> 1486;
1489 -> 1488;
1489 -> 1484;
1490 -> 1484;
1491 -> 1489;
1491 -> 1490;
1492 -> 1491;
1492 -> 1490;
1493 -> 1492;
1494 -> 1493;
1494 -> 1472;
1495 -> 1494;
1495 -> 1474;
1495 -> 1472;
1496 -> 1474;
1496 -> 1483;
1496 -> 0;
1496 -> 1472;
1497 -> 1496;
1497 -> 1474;
1497 -> 1472;
1498 -> 1470;
1498 -> 1466;
1499 -> 1470;
1499 -> 1466;
1500 -> 1466;
1501 -> 1468;
1501 -> 1500;
1501 -> 1466;
1502 -> 1468;
1502 -> 1501;
1503 -> 1470;
1503 -> 1502;
1503 -> 1483;
1503 -> 1495;
1503 -> 1497;
1503 -> 1498;
1503 -> 1499;
1503 -> 885;
1503 -> 1501;
1504 -> 1468;
1504 -> 1470;
1504 -> 1501;
1505 -> 1466;
1506 -> 1469;
1506 -> 1505;
1506 -> 1466;
1507 -> 1469;
1507 -> 1506;
1508 -> 1470;
1508 -> 1507;
1508 -> 1503;
1508 -> 1504;
1508 -> 1506;
1509 -> 1469;
1509 -> 1470;
1509 -> 1506;
1510 -> 1465;
1510 -> 1462;
1510 -> 1430;
1511 -> 1423;
1511 -> 1422;
1511 -> 1429;
1511 -> 1430;
1512 -> 1429;
1512 -> 1430;
1513 -> 1430;
1514 -> 408;
1514 -> 1430;
1515 -> 1430;
1516 -> 1512;
1516 -> 1515;
1517 -> 1513;
1517 -> 1515;
1518 -> 1514;
1518 -> 1515;
1519 -> 1513;
1519 -> 1515;
1520 -> 1516;
1520 -> 1515;
1521 -> 1515;
1522 -> 1520;
1522 -> 1521;
1523 -> 1519;
1523 -> 1521;
1524 -> 1522;
1524 -> 1521;
1525 -> 1521;
1526 -> 1524;
1526 -> 1525;
1527 -> 1523;
1527 -> 1525;
1528 -> 1526;
1528 -> 1525;
1529 -> 1525;
1530 -> 1529;
1530 -> 1528;
1530 -> 1525;
1531 -> 1529;
1531 -> 1525;
1532 -> 1531;
1532 -> 1530;
1532 -> 1525;
1533 -> 1521;
1534 -> 1523;
1534 -> 1533;
1535 -> 1533;
1536 -> 1534;
1536 -> 1535;
1537 -> 1536;
1537 -> 1532;
1537 -> 1535;
1538 -> 1537;
1538 -> 1533;
1539 -> 1533;
1540 -> 1538;
1540 -> 1539;
1541 -> 1540;
1541 -> 1539;
1542 -> 1541;
1543 -> 1542;
1543 -> 1521;
1544 -> 1543;
1544 -> 1523;
1544 -> 1521;
1545 -> 1523;
1545 -> 1532;
1545 -> 0;
1545 -> 1521;
1546 -> 1545;
1546 -> 1523;
1546 -> 1521;
1547 -> 1519;
1547 -> 1515;
1548 -> 1519;
1548 -> 1515;
1549 -> 1515;
1550 -> 1517;
1550 -> 1549;
1550 -> 1515;
1551 -> 1515;
1552 -> 1518;
1552 -> 1551;
1552 -> 1515;
1553 -> 1518;
1553 -> 1552;
1554 -> 1519;
1554 -> 1553;
1554 -> 1532;
1554 -> 1544;
1554 -> 1546;
1554 -> 1547;
1554 -> 1548;
1554 -> 850;
1554 -> 1552;
1555 -> 1518;
1555 -> 1519;
1555 -> 1552;
1556 -> 1513;
1556 -> 1511;
1556 -> 1430;
1557 -> 1427;
1557 -> 1426;
1557 -> 1429;
1557 -> 1430;
1558 -> 1429;
1558 -> 1430;
1559 -> 1430;
1560 -> 267;
1560 -> 1430;
1561 -> 1430;
1562 -> 1558;
1562 -> 1561;
1563 -> 1559;
1563 -> 1561;
1564 -> 1560;
1564 -> 1561;
1565 -> 1559;
1565 -> 1561;
1566 -> 1562;
1566 -> 1561;
1567 -> 1561;
1568 -> 1566;
1568 -> 1567;
1569 -> 1565;
1569 -> 1567;
1570 -> 1568;
1570 -> 1567;
1571 -> 1567;
1572 -> 1570;
1572 -> 1571;
1573 -> 1569;
1573 -> 1571;
1574 -> 1572;
1574 -> 1571;
1575 -> 1571;
1576 -> 1575;
1576 -> 1574;
1576 -> 1571;
1577 -> 1575;
1577 -> 1571;
1578 -> 1577;
1578 -> 1576;
1578 -> 1571;
1579 -> 1567;
1580 -> 1569;
1580 -> 1579;
1581 -> 1579;
1582 -> 1580;
1582 -> 1581;
1583 -> 1582;
1583 -> 1578;
1583 -> 1581;
1584 -> 1583;
1584 -> 1579;
1585 -> 1579;
1586 -> 1584;
1586 -> 1585;
1587 -> 1586;
1587 -> 1585;
1588 -> 1587;
1589 -> 1588;
1589 -> 1567;
1590 -> 1589;
1590 -> 1569;
1590 -> 1567;
1591 -> 1569;
1591 -> 1578;
1591 -> 0;
1591 -> 1567;
1592 -> 1591;
1592 -> 1569;
1592 -> 1567;
1593 -> 1565;
1593 -> 1561;
1594 -> 1565;
1594 -> 1561;
1595 -> 1561;
1596 -> 1563;
1596 -> 1595;
1596 -> 1561;
1597 -> 1561;
1598 -> 1564;
1598 -> 1597;
1598 -> 1561;
1599 -> 1564;
1599 -> 1598;
1600 -> 1565;
1600 -> 1599;
1600 -> 1578;
1600 -> 1590;
1600 -> 1592;
1600 -> 1593;
1600 -> 1594;
1600 -> 835;
1600 -> 1598;
1601 -> 1564;
1601 -> 1565;
1601 -> 1598;
1602 -> 1559;
1602 -> 1557;
1602 -> 1430;
1603 -> 1415;
1603 -> 1414;
1603 -> 1430;
1604 -> 1433;
1604 -> 1434;
1605 -> 1604;
1605 -> 1434;
1606 -> 1605;
1606 -> 1438;
1607 -> 1606;
1607 -> 1438;
1608 -> 1442;
1608 -> 1607;
1608 -> 1438;
1609 -> 1444;
1609 -> 1608;
1609 -> 1438;
1610 -> 1449;
1610 -> 1609;
1610 -> 1448;
1611 -> 1610;
1611 -> 1446;
1612 -> 1611;
1612 -> 1452;
1613 -> 1612;
1613 -> 1452;
1614 -> 1613;
1615 -> 1614;
1615 -> 1434;
1616 -> 1615;
1616 -> 1436;
1616 -> 1434;
1617 -> 1436;
1617 -> 1609;
1617 -> 0;
1617 -> 1434;
1618 -> 1617;
1618 -> 1436;
1618 -> 1434;
1619 -> 1433;
1619 -> 1603;
1619 -> 1430;
1620 -> 1419;
1620 -> 1418;
1620 -> 1430;
1621 -> 1465;
1621 -> 1466;
1622 -> 1621;
1622 -> 1466;
1623 -> 1622;
1623 -> 1472;
1624 -> 1623;
1624 -> 1472;
1625 -> 1624;
1625 -> 1476;
1626 -> 1625;
1626 -> 1476;
1627 -> 1480;
1627 -> 1626;
1627 -> 1476;
1628 -> 1482;
1628 -> 1627;
1628 -> 1476;
1629 -> 1487;
1629 -> 1628;
1629 -> 1486;
1630 -> 1629;
1630 -> 1484;
1631 -> 1630;
1631 -> 1490;
1632 -> 1631;
1632 -> 1490;
1633 -> 1632;
1634 -> 1633;
1634 -> 1472;
1635 -> 1634;
1635 -> 1474;
1635 -> 1472;
1636 -> 1474;
1636 -> 1628;
1636 -> 0;
1636 -> 1472;
1637 -> 1636;
1637 -> 1474;
1637 -> 1472;
1638 -> 1470;
1638 -> 1502;
1638 -> 1628;
1638 -> 1635;
1638 -> 1637;
1638 -> 1498;
1638 -> 1499;
1638 -> 1508;
1638 -> 1509;
1638 -> 1501;
1639 -> 1465;
1639 -> 1620;
1639 -> 1430;
1640 -> 1423;
1640 -> 1422;
1640 -> 1430;
1641 -> 1513;
1641 -> 1515;
1642 -> 1641;
1642 -> 1515;
1643 -> 1642;
1643 -> 1521;
1644 -> 1643;
1644 -> 1521;
1645 -> 1644;
1645 -> 1525;
1646 -> 1645;
1646 -> 1525;
1647 -> 1529;
1647 -> 1646;
1647 -> 1525;
1648 -> 1531;
1648 -> 1647;
1648 -> 1525;
1649 -> 1536;
1649 -> 1648;
1649 -> 1535;
1650 -> 1649;
1650 -> 1533;
1651 -> 1650;
1651 -> 1539;
1652 -> 1651;
1652 -> 1539;
1653 -> 1652;
1654 -> 1653;
1654 -> 1521;
1655 -> 1654;
1655 -> 1523;
1655 -> 1521;
1656 -> 1523;
1656 -> 1648;
1656 -> 0;
1656 -> 1521;
1657 -> 1656;
1657 -> 1523;
1657 -> 1521;
1658 -> 1519;
1658 -> 1553;
1658 -> 1648;
1658 -> 1655;
1658 -> 1657;
1658 -> 1547;
1658 -> 1548;
1658 -> 1554;
1658 -> 1555;
1658 -> 1552;
1659 -> 1513;
1659 -> 1640;
1659 -> 1430;
1660 -> 1427;
1660 -> 1426;
1660 -> 1430;
1661 -> 1559;
1661 -> 1561;
1662 -> 1661;
1662 -> 1561;
1663 -> 1662;
1663 -> 1567;
1664 -> 1663;
1664 -> 1567;
1665 -> 1664;
1665 -> 1571;
1666 -> 1665;
1666 -> 1571;
1667 -> 1575;
1667 -> 1666;
1667 -> 1571;
1668 -> 1577;
1668 -> 1667;
1668 -> 1571;
1669 -> 1582;
1669 -> 1668;
1669 -> 1581;
1670 -> 1669;
1670 -> 1579;
1671 -> 1670;
1671 -> 1585;
1672 -> 1671;
1672 -> 1585;
1673 -> 1672;
1674 -> 1673;
1674 -> 1567;
1675 -> 1674;
1675 -> 1569;
1675 -> 1567;
1676 -> 1569;
1676 -> 1668;
1676 -> 0;
1676 -> 1567;
1677 -> 1676;
1677 -> 1569;
1677 -> 1567;
1678 -> 1565;
1678 -> 1599;
1678 -> 1668;
1678 -> 1675;
1678 -> 1677;
1678 -> 1593;
1678 -> 1594;
1678 -> 1600;
1678 -> 1601;
1678 -> 1598;
1679 -> 1559;
1679 -> 1660;
1679 -> 1430;
1680 -> 1613;
1681 -> 1680;
1681 -> 1434;
1682 -> 1681;
1682 -> 1436;
1682 -> 1434;
1683 -> 1632;
1684 -> 1683;
1684 -> 1472;
1685 -> 1684;
1685 -> 1474;
1685 -> 1472;
1686 -> 1470;
1686 -> 1502;
1686 -> 1628;
1686 -> 1685;
1686 -> 1637;
1686 -> 1498;
1686 -> 1499;
1686 -> 1638;
1686 -> 1509;
1686 -> 1501;
1687 -> 1652;
1688 -> 1687;
1688 -> 1521;
1689 -> 1688;
1689 -> 1523;
1689 -> 1521;
1690 -> 1519;
1690 -> 1553;
1690 -> 1648;
1690 -> 1689;
1690 -> 1657;
1690 -> 1547;
1690 -> 1548;
1690 -> 1658;
1690 -> 1555;
1690 -> 1552;
1691 -> 1672;
1692 -> 1691;
1692 -> 1567;
1693 -> 1692;
1693 -> 1569;
1693 -> 1567;
1694 -> 1565;
1694 -> 1599;
1694 -> 1668;
1694 -> 1693;
1694 -> 1677;
1694 -> 1593;
1694 -> 1594;
1694 -> 1678;
1694 -> 1601;
1694 -> 1598;
1695 -> 1613;
1696 -> 1695;
1696 -> 1434;
1697 -> 1696;
1697 -> 1436;
1697 -> 1434;
1698 -> 1632;
1699 -> 1698;
1699 -> 1472;
1700 -> 1699;
1700 -> 1474;
1700 -> 1472;
1701 -> 1470;
1701 -> 1502;
1701 -> 1628;
1701 -> 1700;
1701 -> 1637;
1701 -> 1498;
1701 -> 1499;
1701 -> 1686;
1701 -> 1509;
1701 -> 1501;
1702 -> 1652;
1703 -> 1702;
1703 -> 1521;
1704 -> 1703;
1704 -> 1523;
1704 -> 1521;
1705 -> 1519;
1705 -> 1553;
1705 -> 1648;
1705 -> 1704;
1705 -> 1657;
1705 -> 1547;
1705 -> 1548;
1705 -> 1690;
1705 -> 1555;
1705 -> 1552;
1706 -> 1672;
1707 -> 1706;
1707 -> 1567;
1708 -> 1707;
1708 -> 1569;
1708 -> 1567;
1709 -> 1565;
1709 -> 1599;
1709 -> 1668;
1709 -> 1708;
1709 -> 1677;
1709 -> 1593;
1709 -> 1594;
1709 -> 1694;
1709 -> 1601;
1709 -> 1598;
1710 -> 1613;
1711 -> 1710;
1711 -> 1434;
1712 -> 1711;
1712 -> 1436;
1712 -> 1434;
1713 -> 1632;
1714 -> 1713;
1714 -> 1472;
1715 -> 1714;
1715 -> 1474;
1715 -> 1472;
1716 -> 1470;
1716 -> 1502;
1716 -> 1628;
1716 -> 1715;
1716 -> 1637;
1716 -> 1498;
1716 -> 1499;
1716 -> 1701;
1716 -> 1509;
1716 -> 1501;
1717 -> 1652;
1718 -> 1717;
1718 -> 1521;
1719 -> 1718;
1719 -> 1523;
1719 -> 1521;
1720 -> 1519;
1720 -> 1553;
1720 -> 1648;
1720 -> 1719;
1720 -> 1657;
1720 -> 1547;
1720 -> 1548;
1720 -> 1705;
1720 -> 1555;
1720 -> 1552;
1721 -> 1672;
1722 -> 1721;
1722 -> 1567;
1723 -> 1722;
1723 -> 1569;
1723 -> 1567;
1724 -> 1565;
1724 -> 1599;
1724 -> 1668;
1724 -> 1723;
1724 -> 1677;
1724 -> 1593;
1724 -> 1594;
1724 -> 1709;
1724 -> 1601;
1724 -> 1598;
1725 -> 1613;
1726 -> 1725;
1726 -> 1434;
1727 -> 1726;
1727 -> 1436;
1727 -> 1434;
1728 -> 1632;
1729 -> 1728;
1729 -> 1472;
1730 -> 1729;
1730 -> 1474;
1730 -> 1472;
1731 -> 1470;
1731 -> 1502;
1731 -> 1628;
1731 -> 1730;
1731 -> 1637;
1731 -> 1498;
1731 -> 1499;
1731 -> 1716;
1731 -> 1509;
1731 -> 1501;
1732 -> 1652;
1733 -> 1732;
1733 -> 1521;
1734 -> 1733;
1734 -> 1523;
1734 -> 1521;
1735 -> 1519;
1735 -> 1553;
1735 -> 1648;
1735 -> 1734;
1735 -> 1657;
1735 -> 1547;
1735 -> 1548;
1735 -> 1720;
1735 -> 1555;
1735 -> 1552;
1736 -> 1672;
1737 -> 1736;
1737 -> 1567;
1738 -> 1737;
1738 -> 1569;
1738 -> 1567;
1739 -> 1565;
1739 -> 1599;
1739 -> 1668;
1739 -> 1738;
1739 -> 1677;
1739 -> 1593;
1739 -> 1594;
1739 -> 1724;
1739 -> 1601;
1739 -> 1598;
1740 -> 1613;
1741 -> 1740;
1741 -> 1434;
1742 -> 1741;
1742 -> 1436;
1742 -> 1434;
1743 -> 1632;
1744 -> 1743;
1744 -> 1472;
1745 -> 1744;
1745 -> 1474;
1745 -> 1472;
1746 -> 1470;
1746 -> 1502;
1746 -> 1628;
1746 -> 1745;
1746 -> 1637;
1746 -> 1498;
1746 -> 1499;
1746 -> 1731;
1746 -> 1509;
1746 -> 1501;
1747 -> 1652;
1748 -> 1747;
1748 -> 1521;
1749 -> 1748;
1749 -> 1523;
1749 -> 1521;
1750 -> 1519;
1750 -> 1553;
1750 -> 1648;
1750 -> 1749;
1750 -> 1657;
1750 -> 1547;
1750 -> 1548;
1750 -> 1735;
1750 -> 1555;
1750 -> 1552;
1751 -> 1672;
1752 -> 1751;
1752 -> 1567;
1753 -> 1752;
1753 -> 1569;
1753 -> 1567;
1754 -> 1565;
1754 -> 1599;
1754 -> 1668;
1754 -> 1753;
1754 -> 1677;
1754 -> 1593;
1754 -> 1594;
1754 -> 1739;
1754 -> 1601;
1754 -> 1598;
1755 -> 1613;
1756 -> 1755;
1756 -> 1434;
1757 -> 1756;
1757 -> 1436;
1757 -> 1434;
1758 -> 1632;
1759 -> 1758;
1759 -> 1472;
1760 -> 1759;
1760 -> 1474;
1760 -> 1472;
1761 -> 1470;
1761 -> 1502;
1761 -> 1628;
1761 -> 1760;
1761 -> 1637;
1761 -> 1498;
1761 -> 1499;
1761 -> 1746;
1761 -> 1509;
1761 -> 1501;
1762 -> 1652;
1763 -> 1762;
1763 -> 1521;
1764 -> 1763;
1764 -> 1523;
1764 -> 1521;
1765 -> 1519;
1765 -> 1553;
1765 -> 1648;
1765 -> 1764;
1765 -> 1657;
1765 -> 1547;
1765 -> 1548;
1765 -> 1750;
1765 -> 1555;
1765 -> 1552;
1766 -> 1672;
1767 -> 1766;
1767 -> 1567;
1768 -> 1767;
1768 -> 1569;
1768 -> 1567;
1769 -> 1565;
1769 -> 1599;
1769 -> 1668;
1769 -> 1768;
1769 -> 1677;
1769 -> 1593;
1769 -> 1594;
1769 -> 1754;
1769 -> 1601;
1769 -> 1598;
1770 -> 1613;
1771 -> 1770;
1771 -> 1434;
1772 -> 1771;
1772 -> 1436;
1772 -> 1434;
1773 -> 1632;
1774 -> 1773;
1774 -> 1472;
1775 -> 1774;
1775 -> 1474;
1775 -> 1472;
1776 -> 1470;
1776 -> 1502;
1776 -> 1628;
1776 -> 1775;
1776 -> 1637;
1776 -> 1498;
1776 -> 1499;
1776 -> 1761;
1776 -> 1509;
1776 -> 1501;
1777 -> 1652;
1778 -> 1777;
1778 -> 1521;
1779 -> 1778;
1779 -> 1523;
1779 -> 1521;
1780 -> 1519;
1780 -> 1553;
1780 -> 1648;
1780 -> 1779;
1780 -> 1657;
1780 -> 1547;
1780 -> 1548;
1780 -> 1765;
1780 -> 1555;
1780 -> 1552;
1781 -> 1672;
1782 -> 1781;
1782 -> 1567;
1783 -> 1782;
1783 -> 1569;
1783 -> 1567;
1784 -> 1565;
1784 -> 1599;
1784 -> 1668;
1784 -> 1783;
1784 -> 1677;
1784 -> 1593;
1784 -> 1594;
1784 -> 1769;
1784 -> 1601;
1784 -> 1598;
1785 -> 1613;
1786 -> 1785;
1786 -> 1434;
1787 -> 1786;
1787 -> 1436;
1787 -> 1434;
1788 -> 1632;
1789 -> 1788;
1789 -> 1472;
1790 -> 1789;
1790 -> 1474;
1790 -> 1472;
1791 -> 1470;
1791 -> 1502;
1791 -> 1628;
1791 -> 1790;
1791 -> 1637;
1791 -> 1498;
1791 -> 1499;
1791 -> 1776;
1791 -> 1509;
1791 -> 1501;
1792 -> 1652;
1793 -> 1792;
1793 -> 1521;
1794 -> 1793;
1794 -> 1523;
1794 -> 1521;
1795 -> 1519;
1795 -> 1553;
1795 -> 1648;
1795 -> 1794;
1795 -> 1657;
1795 -> 1547;
1795 -> 1548;
1795 -> 1780;
1795 -> 1555;
1795 -> 1552;
1796 -> 1672;
1797 -> 1796;
1797 -> 1567;
1798 -> 1797;
1798 -> 1569;
1798 -> 1567;
1799 -> 1565;
1799 -> 1599;
1799 -> 1668;
1799 -> 1798;
1799 -> 1677;
1799 -> 1593;
1799 -> 1594;
1799 -> 1784;
1799 -> 1601;
1799 -> 1598;
1800 -> 1613;
1801 -> 1800;
1801 -> 1434;
1802 -> 1801;
1802 -> 1436;
1802 -> 1434;
1803 -> 1632;
1804 -> 1803;
1804 -> 1472;
1805 -> 1804;
1805 -> 1474;
1805 -> 1472;
1806 -> 1470;
1806 -> 1502;
1806 -> 1628;
1806 -> 1805;
1806 -> 1637;
1806 -> 1498;
1806 -> 1499;
1806 -> 1791;
1806 -> 1509;
1806 -> 1501;
1807 -> 1652;
1808 -> 1807;
1808 -> 1521;
1809 -> 1808;
1809 -> 1523;
1809 -> 1521;
1810 -> 1519;
1810 -> 1553;
1810 -> 1648;
1810 -> 1809;
1810 -> 1657;
1810 -> 1547;
1810 -> 1548;
1810 -> 1795;
1810 -> 1555;
1810 -> 1552;
1811 -> 1672;
1812 -> 1811;
1812 -> 1567;
1813 -> 1812;
1813 -> 1569;
1813 -> 1567;
1814 -> 1565;
1814 -> 1599;
1814 -> 1668;
1814 -> 1813;
1814 -> 1677;
1814 -> 1593;
1814 -> 1594;
1814 -> 1799;
1814 -> 1601;
1814 -> 1598;
1815 -> 1613;
1816 -> 1815;
1816 -> 1434;
1817 -> 1816;
1817 -> 1436;
1817 -> 1434;
1818 -> 1632;
1819 -> 1818;
1819 -> 1472;
1820 -> 1819;
1820 -> 1474;
1820 -> 1472;
1821 -> 1470;
1821 -> 1502;
1821 -> 1628;
1821 -> 1820;
1821 -> 1637;
1821 -> 1498;
1821 -> 1499;
1821 -> 1806;
1821 -> 1509;
1821 -> 1501;
1822 -> 1652;
1823 -> 1822;
1823 -> 1521;
1824 -> 1823;
1824 -> 1523;
1824 -> 1521;
1825 -> 1519;
1825 -> 1553;
1825 -> 1648;
1825 -> 1824;
1825 -> 1657;
1825 -> 1547;
1825 -> 1548;
1825 -> 1810;
1825 -> 1555;
1825 -> 1552;
1826 -> 1672;
1827 -> 1826;
1827 -> 1567;
1828 -> 1827;
1828 -> 1569;
1828 -> 1567;
1829 -> 1565;
1829 -> 1599;
1829 -> 1668;
1829 -> 1828;
1829 -> 1677;
1829 -> 1593;
1829 -> 1594;
1829 -> 1814;
1829 -> 1601;
1829 -> 1598;
1830 -> 1613;
1831 -> 1830;
1831 -> 1434;
1832 -> 1831;
1832 -> 1436;
1832 -> 1434;
1833 -> 1632;
1834 -> 1833;
1834 -> 1472;
1835 -> 1834;
1835 -> 1474;
1835 -> 1472;
1836 -> 1470;
1836 -> 1502;
1836 -> 1628;
1836 -> 1835;
1836 -> 1637;
1836 -> 1498;
1836 -> 1499;
1836 -> 1821;
1836 -> 1509;
1836 -> 1501;
1837 -> 1652;
1838 -> 1837;
1838 -> 1521;
1839 -> 1838;
1839 -> 1523;
1839 -> 1521;
1840 -> 1519;
1840 -> 1553;
1840 -> 1648;
1840 -> 1839;
1840 -> 1657;
1840 -> 1547;
1840 -> 1548;
1840 -> 1825;
1840 -> 1555;
1840 -> 1552;
1841 -> 1672;
1842 -> 1841;
1842 -> 1567;
1843 -> 1842;
1843 -> 1569;
1843 -> 1567;
1844 -> 1565;
1844 -> 1599;
1844 -> 1668;
1844 -> 1843;
1844 -> 1677;
1844 -> 1593;
1844 -> 1594;
1844 -> 1829;
1844 -> 1601;
1844 -> 1598;
1845 -> 1613;
1846 -> 1845;
1846 -> 1434;
1847 -> 1846;
1847 -> 1436;
1847 -> 1434;
1848 -> 1632;
1849 -> 1848;
1849 -> 1472;
1850 -> 1849;
1850 -> 1474;
1850 -> 1472;
1851 -> 1470;
1851 -> 1502;
1851 -> 1628;
1851 -> 1850;
1851 -> 1637;
1851 -> 1498;
1851 -> 1499;
1851 -> 1836;
1851 -> 1509;
1851 -> 1501;
1852 -> 1652;
1853 -> 1852;
1853 -> 1521;
1854 -> 1853;
1854 -> 1523;
1854 -> 1521;
1855 -> 1519;
1855 -> 1553;
1855 -> 1648;
1855 -> 1854;
1855 -> 1657;
1855 -> 1547;
1855 -> 1548;
1855 -> 1840;
1855 -> 1555;
1855 -> 1552;
1856 -> 1672;
1857 -> 1856;
1857 -> 1567;
1858 -> 1857;
1858 -> 1569;
1858 -> 1567;
1859 -> 1565;
1859 -> 1599;
1859 -> 1668;
1859 -> 1858;
1859 -> 1677;
1859 -> 1593;
1859 -> 1594;
1859 -> 1844;
1859 -> 1601;
1859 -> 1598;
1860 -> 1613;
1861 -> 1860;
1861 -> 1434;
1862 -> 1861;
1862 -> 1436;
1862 -> 1434;
1863 -> 1632;
1864 -> 1863;
1864 -> 1472;
1865 -> 1864;
1865 -> 1474;
1865 -> 1472;
1866 -> 1470;
1866 -> 1502;
1866 -> 1628;
1866 -> 1865;
1866 -> 1637;
1866 -> 1498;
1866 -> 1499;
1866 -> 1851;
1866 -> 1509;
1866 -> 1501;
1867 -> 1652;
1868 -> 1867;
1868 -> 1521;
1869 -> 1868;
1869 -> 1523;
1869 -> 1521;
1870 -> 1519;
1870 -> 1553;
1870 -> 1648;
1870 -> 1869;
1870 -> 1657;
1870 -> 1547;
1870 -> 1548;
1870 -> 1855;
1870 -> 1555;
1870 -> 1552;
1871 -> 1672;
1872 -> 1871;
1872 -> 1567;
1873 -> 1872;
1873 -> 1569;
1873 -> 1567;
1874 -> 1565;
1874 -> 1599;
1874 -> 1668;
1874 -> 1873;
1874 -> 1677;
1874 -> 1593;
1874 -> 1594;
1874 -> 1859;
1874 -> 1601;
1874 -> 1598;
1875 -> 1613;
1876 -> 1875;
1876 -> 1434;
1877 -> 1876;
1877 -> 1436;
1877 -> 1434;
1878 -> 1632;
1879 -> 1878;
1879 -> 1472;
1880 -> 1879;
1880 -> 1474;
1880 -> 1472;
1881 -> 1470;
1881 -> 1502;
1881 -> 1628;
1881 -> 1880;
1881 -> 1637;
1881 -> 1498;
1881 -> 1499;
1881 -> 1866;
1881 -> 1509;
1881 -> 1501;
1882 -> 1652;
1883 -> 1882;
1883 -> 1521;
1884 -> 1883;
1884 -> 1523;
1884 -> 1521;
1885 -> 1519;
1885 -> 1553;
1885 -> 1648;
1885 -> 1884;
1885 -> 1657;
1885 -> 1547;
1885 -> 1548;
1885 -> 1870;
1885 -> 1555;
1885 -> 1552;
1886 -> 1672;
1887 -> 1886;
1887 -> 1567;
1888 -> 1887;
1888 -> 1569;
1888 -> 1567;
1889 -> 1565;
1889 -> 1599;
1889 -> 1668;
1889 -> 1888;
1889 -> 1677;
1889 -> 1593;
1889 -> 1594;
1889 -> 1874;
1889 -> 1601;
1889 -> 1598;
1890 -> 1613;
1891 -> 1890;
1891 -> 1434;
1892 -> 1891;
1892 -> 1436;
1892 -> 1434;
1893 -> 1632;
1894 -> 1893;
1894 -> 1472;
1895 -> 1894;
1895 -> 1474;
1895 -> 1472;
1896 -> 1470;
1896 -> 1502;
1896 -> 1628;
1896 -> 1895;
1896 -> 1637;
1896 -> 1498;
1896 -> 1499;
1896 -> 1881;
1896 -> 1509;
1896 -> 1501;
1897 -> 1652;
1898 -> 1897;
1898 -> 1521;
1899 -> 1898;
1899 -> 1523;
1899 -> 1521;
1900 -> 1519;
1900 -> 1553;
1900 -> 1648;
1900 -> 1899;
1900 -> 1657;
1900 -> 1547;
1900 -> 1548;
1900 -> 1885;
1900 -> 1555;
1900 -> 1552;
1901 -> 1672;
1902 -> 1901;
1902 -> 1567;
1903 -> 1902;
1903 -> 1569;
1903 -> 1567;
1904 -> 1565;
1904 -> 1599;
1904 -> 1668;
1904 -> 1903;
1904 -> 1677;
1904 -> 1593;
1904 -> 1594;
1904 -> 1889;
1904 -> 1601;
1904 -> 1598;
1905 -> 1613;
1906 -> 1905;
1906 -> 1434;
1907 -> 1906;
1907 -> 1436;
1907 -> 1434;
1908 -> 1632;
1909 -> 1908;
1909 -> 1472;
1910 -> 1909;
1910 -> 1474;
1910 -> 1472;
1911 -> 1470;
1911 -> 1502;
1911 -> 1628;
1911 -> 1910;
1911 -> 1637;
1911 -> 1498;
1911 -> 1499;
1911 -> 1896;
1911 -> 1509;
1911 -> 1501;
1912 -> 1652;
1913 -> 1912;
1913 -> 1521;
1914 -> 1913;
1914 -> 1523;
1914 -> 1521;
1915 -> 1519;
1915 -> 1553;
1915 -> 1648;
1915 -> 1914;
1915 -> 1657;
1915 -> 1547;
1915 -> 1548;
1915 -> 1900;
1915 -> 1555;
1915 -> 1552;
1916 -> 1672;
1917 -> 1916;
1917 -> 1567;
1918 -> 1917;
1918 -> 1569;
1918 -> 1567;
1919 -> 1565;
1919 -> 1599;
1919 -> 1668;
1919 -> 1918;
1919 -> 1677;
1919 -> 1593;
1919 -> 1594;
1919 -> 1904;
1919 -> 1601;
1919 -> 1598;
1920 -> 1613;
1921 -> 1920;
1921 -> 1434;
1922 -> 1921;
1922 -> 1436;
1922 -> 1434;
1923 -> 1632;
1924 -> 1923;
1924 -> 1472;
1925 -> 1924;
1925 -> 1474;
1925 -> 1472;
1926 -> 1470;
1926 -> 1502;
1926 -> 1628;
1926 -> 1925;
1926 -> 1637;
1926 -> 1498;
1926 -> 1499;
1926 -> 1911;
1926 -> 1509;
1926 -> 1501;
1927 -> 1652;
1928 -> 1927;
1928 -> 1521;
1929 -> 1928;
1929 -> 1523;
1929 -> 1521;
1930 -> 1519;
1930 -> 1553;
1930 -> 1648;
1930 -> 1929;
1930 -> 1657;
1930 -> 1547;
1930 -> 1548;
1930 -> 1915;
1930 -> 1555;
1930 -> 1552;
1931 -> 1672;
1932 -> 1931;
1932 -> 1567;
1933 -> 1932;
1933 -> 1569;
1933 -> 1567;
1934 -> 1565;
1934 -> 1599;
1934 -> 1668;
1934 -> 1933;
1934 -> 1677;
1934 -> 1593;
1934 -> 1594;
1934 -> 1919;
1934 -> 1601;
1934 -> 1598;
1935 -> 1613;
1936 -> 1935;
1936 -> 1434;
1937 -> 1936;
1937 -> 1436;
1937 -> 1434;
1938 -> 1632;
1939 -> 1938;
1939 -> 1472;
1940 -> 1939;
1940 -> 1474;
1940 -> 1472;
1941 -> 1470;
1941 -> 1502;
1941 -> 1628;
1941 -> 1940;
1941 -> 1637;
1941 -> 1498;
1941 -> 1499;
1941 -> 1926;
1941 -> 1509;
1941 -> 1501;
1942 -> 1652;
1943 -> 1942;
1943 -> 1521;
1944 -> 1943;
1944 -> 1523;
1944 -> 1521;
1945 -> 1519;
1945 -> 1553;
1945 -> 1648;
1945 -> 1944;
1945 -> 1657;
1945 -> 1547;
1945 -> 1548;
1945 -> 1930;
1945 -> 1555;
1945 -> 1552;
1946 -> 1672;
1947 -> 1946;
1947 -> 1567;
1948 -> 1947;
1948 -> 1569;
1948 -> 1567;
1949 -> 1565;
1949 -> 1599;
1949 -> 1668;
1949 -> 1948;
1949 -> 1677;
1949 -> 1593;
1949 -> 1594;
1949 -> 1934;
1949 -> 1601;
1949 -> 1598;
1950 -> 1613;
1951 -> 1950;
1951 -> 1434;
1952 -> 1951;
1952 -> 1436;
1952 -> 1434;
1953 -> 1632;
1954 -> 1953;
1954 -> 1472;
1955 -> 1954;
1955 -> 1474;
1955 -> 1472;
1956 -> 1470;
1956 -> 1502;
1956 -> 1628;
1956 -> 1955;
1956 -> 1637;
1956 -> 1498;
1956 -> 1499;
1956 -> 1941;
1956 -> 1509;
1956 -> 1501;
1957 -> 1652;
1958 -> 1957;
1958 -> 1521;
1959 -> 1958;
1959 -> 1523;
1959 -> 1521;
1960 -> 1519;
1960 -> 1553;
1960 -> 1648;
1960 -> 1959;
1960 -> 1657;
1960 -> 1547;
1960 -> 1548;
1960 -> 1945;
1960 -> 1555;
1960 -> 1552;
1961 -> 1672;
1962 -> 1961;
1962 -> 1567;
1963 -> 1962;
1963 -> 1569;
1963 -> 1567;
1964 -> 1565;
1964 -> 1599;
1964 -> 1668;
1964 -> 1963;
1964 -> 1677;
1964 -> 1593;
1964 -> 1594;
1964 -> 1949;
1964 -> 1601;
1964 -> 1598;
1965 -> 1613;
1966 -> 1965;
1966 -> 1434;
1967 -> 1966;
1967 -> 1436;
1967 -> 1434;
1968 -> 1632;
1969 -> 1968;
1969 -> 1472;
1970 -> 1969;
1970 -> 1474;
1970 -> 1472;
1971 -> 1470;
1971 -> 1502;
1971 -> 1628;
1971 -> 1970;
1971 -> 1637;
1971 -> 1498;
1971 -> 1499;
1971 -> 1956;
1971 -> 1509;
1971 -> 1501;
1972 -> 1652;
1973 -> 1972;
1973 -> 1521;
1974 -> 1973;
1974 -> 1523;
1974 -> 1521;
1975 -> 1519;
1975 -> 1553;
1975 -> 1648;
1975 -> 1974;
1975 -> 1657;
1975 -> 1547;
1975 -> 1548;
1975 -> 1960;
1975 -> 1555;
1975 -> 1552;
1976 -> 1672;
1977 -> 1976;
1977 -> 1567;
1978 -> 1977;
1978 -> 1569;
1978 -> 1567;
1979 -> 1565;
1979 -> 1599;
1979 -> 1668;
1979 -> 1978;
1979 -> 1677;
1979 -> 1593;
1979 -> 1594;
1979 -> 1964;
1979 -> 1601;
1979 -> 1598;
1980 -> 1613;
1981 -> 1980;
1981 -> 1434;
1982 -> 1981;
1982 -> 1436;
1982 -> 1434;
1983 -> 1632;
1984 -> 1983;
1984 -> 1472;
1985 -> 1984;
1985 -> 1474;
1985 -> 1472;
1986 -> 1470;
1986 -> 1502;
1986 -> 1628;
1986 -> 1985;
1986 -> 1637;
1986 -> 1498;
1986 -> 1499;
1986 -> 1971;
1986 -> 1509;
1986 -> 1501;
1987 -> 1652;
1988 -> 1987;
1988 -> 1521;
1989 -> 1988;
1989 -> 1523;
1989 -> 1521;
1990 -> 1519;
1990 -> 1553;
1990 -> 1648;
1990 -> 1989;
1990 -> 1657;
1990 -> 1547;
1990 -> 1548;
1990 -> 1975;
1990 -> 1555;
1990 -> 1552;
1991 -> 1672;
1992 -> 1991;
1992 -> 1567;
1993 -> 1992;
1993 -> 1569;
1993 -> 1567;
1994 -> 1565;
1994 -> 1599;
1994 -> 1668;
1994 -> 1993;
1994 -> 1677;
1994 -> 1593;
1994 -> 1594;
1994 -> 1979;
1994 -> 1601;
1994 -> 1598;
1995 -> 1613;
1996 -> 1995;
1996 -> 1434;
1997 -> 1996;
1997 -> 1436;
1997 -> 1434;
1998 -> 1632;
1999 -> 1998;
1999 -> 1472;
2000 -> 1999;
2000 -> 1474;
2000 -> 1472;
2001 -> 1470;
2001 -> 1502;
2001 -> 1628;
2001 -> 2000;
2001 -> 1637;
2001 -> 1498;
2001 -> 1499;
2001 -> 1986;
2001 -> 1509;
2001 -> 1501;
2002 -> 1652;
2003 -> 2002;
2003 -> 1521;
2004 -> 2003;
2004 -> 1523;
2004 -> 1521;
2005 -> 1519;
2005 -> 1553;
2005 -> 1648;
2005 -> 2004;
2005 -> 1657;
2005 -> 1547;
2005 -> 1548;
2005 -> 1990;
2005 -> 1555;
2005 -> 1552;
2006 -> 1672;
2007 -> 2006;
2007 -> 1567;
2008 -> 2007;
2008 -> 1569;
2008 -> 1567;
2009 -> 1565;
2009 -> 1599;
2009 -> 1668;
2009 -> 2008;
2009 -> 1677;
2009 -> 1593;
2009 -> 1594;
2009 -> 1994;
2009 -> 1601;
2009 -> 1598;
2010 -> 1613;
2011 -> 2010;
2011 -> 1434;
2012 -> 2011;
2012 -> 1436;
2012 -> 1434;
2013 -> 1632;
2014 -> 2013;
2014 -> 1472;
2015 -> 2014;
2015 -> 1474;
2015 -> 1472;
2016 -> 1470;
2016 -> 1502;
2016 -> 1628;
2016 -> 2015;
2016 -> 1637;
2016 -> 1498;
2016 -> 1499;
2016 -> 2001;
2016 -> 1509;
2016 -> 1501;
2017 -> 1652;
2018 -> 2017;
2018 -> 1521;
2019 -> 2018;
2019 -> 1523;
2019 -> 1521;
2020 -> 1519;
2020 -> 1553;
2020 -> 1648;
2020 -> 2019;
2020 -> 1657;
2020 -> 1547;
2020 -> 1548;
2020 -> 2005;
2020 -> 1555;
2020 -> 1552;
2021 -> 1672;
2022 -> 2021;
2022 -> 1567;
2023 -> 2022;
2023 -> 1569;
2023 -> 1567;
2024 -> 1565;
2024 -> 1599;
2024 -> 1668;
2024 -> 2023;
2024 -> 1677;
2024 -> 1593;
2024 -> 1594;
2024 -> 2009;
2024 -> 1601;
2024 -> 1598;
2025 -> 1613;
2026 -> 2025;
2026 -> 1434;
2027 -> 2026;
2027 -> 1436;
2027 -> 1434;
2028 -> 1632;
2029 -> 2028;
2029 -> 1472;
2030 -> 2029;
2030 -> 1474;
2030 -> 1472;
2031 -> 1470;
2031 -> 1502;
2031 -> 1628;
2031 -> 2030;
2031 -> 1637;
2031 -> 1498;
2031 -> 1499;
2031 -> 2016;
2031 -> 1509;
2031 -> 1501;
2032 -> 1652;
2033 -> 2032;
2033 -> 1521;
2034 -> 2033;
2034 -> 1523;
2034 -> 1521;
2035 -> 1519;
2035 -> 1553;
2035 -> 1648;
2035 -> 2034;
2035 -> 1657;
2035 -> 1547;
2035 -> 1548;
2035 -> 2020;
2035 -> 1555;
2035 -> 1552;
2036 -> 1672;
2037 -> 2036;
2037 -> 1567;
2038 -> 2037;
2038 -> 1569;
2038 -> 1567;
2039 -> 1565;
2039 -> 1599;
2039 -> 1668;
2039 -> 2038;
2039 -> 1677;
2039 -> 1593;
2039 -> 1594;
2039 -> 2024;
2039 -> 1601;
2039 -> 1598;
2040 -> 1613;
2041 -> 2040;
2041 -> 1434;
2042 -> 2041;
2042 -> 1436;
2042 -> 1434;
2043 -> 1632;
2044 -> 2043;
2044 -> 1472;
2045 -> 2044;
2045 -> 1474;
2045 -> 1472;
2046 -> 1470;
2046 -> 1502;
2046 -> 1628;
2046 -> 2045;
2046 -> 1637;
2046 -> 1498;
2046 -> 1499;
2046 -> 2031;
2046 -> 1509;
2046 -> 1501;
2047 -> 1652;
2048 -> 2047;
2048 -> 1521;
2049 -> 2048;
2049 -> 1523;
2049 -> 1521;
2050 -> 1519;
2050 -> 1553;
2050 -> 1648;
2050 -> 2049;
2050 -> 1657;
2050 -> 1547;
2050 -> 1548;
2050 -> 2035;
2050 -> 1555;
2050 -> 1552;
2051 -> 1672;
2052 -> 2051;
2052 -> 1567;
2053 -> 2052;
2053 -> 1569;
2053 -> 1567;
2054 -> 1565;
2054 -> 1599;
2054 -> 1668;
2054 -> 2053;
2054 -> 1677;
2054 -> 1593;
2054 -> 1594;
2054 -> 2039;
2054 -> 1601;
2054 -> 1598;
2055 -> 1613;
2056 -> 2055;
2056 -> 1434;
2057 -> 2056;
2057 -> 1436;
2057 -> 1434;
2058 -> 1632;
2059 -> 2058;
2059 -> 1472;
2060 -> 2059;
2060 -> 1474;
2060 -> 1472;
2061 -> 1470;
2061 -> 1502;
2061 -> 1628;
2061 -> 2060;
2061 -> 1637;
2061 -> 1498;
2061 -> 1499;
2061 -> 2046;
2061 -> 1509;
2061 -> 1501;
2062 -> 1652;
2063 -> 2062;
2063 -> 1521;
2064 -> 2063;
2064 -> 1523;
2064 -> 1521;
2065 -> 1519;
2065 -> 1553;
2065 -> 1648;
2065 -> 2064;
2065 -> 1657;
2065 -> 1547;
2065 -> 1548;
2065 -> 2050;
2065 -> 1555;
2065 -> 1552;
2066 -> 1672;
2067 -> 2066;
2067 -> 1567;
2068 -> 2067;
2068 -> 1569;
2068 -> 1567;
2069 -> 1565;
2069 -> 1599;
2069 -> 1668;
2069 -> 2068;
2069 -> 1677;
2069 -> 1593;
2069 -> 1594;
2069 -> 2054;
2069 -> 1601;
2069 -> 1598;
2070 -> 1613;
2071 -> 2070;
2071 -> 1434;
2072 -> 2071;
2072 -> 1436;
2072 -> 1434;
2073 -> 1632;
2074 -> 2073;
2074 -> 1472;
2075 -> 2074;
2075 -> 1474;
2075 -> 1472;
2076 -> 1470;
2076 -> 1502;
2076 -> 1628;
2076 -> 2075;
2076 -> 1637;
2076 -> 1498;
2076 -> 1499;
2076 -> 2061;
2076 -> 1509;
2076 -> 1501;
2077 -> 1652;
2078 -> 2077;
2078 -> 1521;
2079 -> 2078;
2079 -> 1523;
2079 -> 1521;
2080 -> 1519;
2080 -> 1553;
2080 -> 1648;
2080 -> 2079;
2080 -> 1657;
2080 -> 1547;
2080 -> 1548;
2080 -> 2065;
2080 -> 1555;
2080 -> 1552;
2081 -> 1672;
2082 -> 2081;
2082 -> 1567;
2083 -> 2082;
2083 -> 1569;
2083 -> 1567;
2084 -> 1565;
2084 -> 1599;
2084 -> 1668;
2084 -> 2083;
2084 -> 1677;
2084 -> 1593;
2084 -> 1594;
2084 -> 2069;
2084 -> 1601;
2084 -> 1598;
2085 -> 1613;
2086 -> 2085;
2086 -> 1434;
2087 -> 2086;
2087 -> 1436;
2087 -> 1434;
2088 -> 1632;
2089 -> 2088;
2089 -> 1472;
2090 -> 2089;
2090 -> 1474;
2090 -> 1472;
2091 -> 1470;
2091 -> 1502;
2091 -> 1628;
2091 -> 2090;
2091 -> 1637;
2091 -> 1498;
2091 -> 1499;
2091 -> 2076;
2091 -> 1509;
2091 -> 1501;
2092 -> 1652;
2093 -> 2092;
2093 -> 1521;
2094 -> 2093;
2094 -> 1523;
2094 -> 1521;
2095 -> 1519;
2095 -> 1553;
2095 -> 1648;
2095 -> 2094;
2095 -> 1657;
2095 -> 1547;
2095 -> 1548;
2095 -> 2080;
2095 -> 1555;
2095 -> 1552;
2096 -> 1672;
2097 -> 2096;
2097 -> 1567;
2098 -> 2097;
2098 -> 1569;
2098 -> 1567;
2099 -> 1565;
2099 -> 1599;
2099 -> 1668;
2099 -> 2098;
2099 -> 1677;
2099 -> 1593;
2099 -> 1594;
2099 -> 2084;
2099 -> 1601;
2099 -> 1598;
2100 -> 0;
2100 -> 1613;
2101 -> 2100;
2101 -> 1434;
2102 -> 2101;
2102 -> 1436;
2102 -> 1434;
2103 -> 0;
2103 -> 1632;
2104 -> 2103;
2104 -> 1472;
2105 -> 2104;
2105 -> 1474;
2105 -> 1472;
2106 -> 1470;
2106 -> 1502;
2106 -> 1628;
2106 -> 2105;
2106 -> 1637;
2106 -> 1498;
2106 -> 1499;
2106 -> 2091;
2106 -> 1509;
2106 -> 1501;
2107 -> 0;
2107 -> 1652;
2108 -> 2107;
2108 -> 1521;
2109 -> 2108;
2109 -> 1523;
2109 -> 1521;
2110 -> 1519;
2110 -> 1553;
2110 -> 1648;
2110 -> 2109;
2110 -> 1657;
2110 -> 1547;
2110 -> 1548;
2110 -> 2095;
2110 -> 1555;
2110 -> 1552;
2111 -> 0;
2111 -> 1672;
2112 -> 2111;
2112 -> 1567;
2113 -> 2112;
2113 -> 1569;
2113 -> 1567;
2114 -> 1565;
2114 -> 1599;
2114 -> 1668;
2114 -> 2113;
2114 -> 1677;
2114 -> 1593;
2114 -> 1594;
2114 -> 2099;
2114 -> 1601;
2114 -> 1598;
2115 -> 1613;
2116 -> 2115;
2116 -> 1434;
2117 -> 2116;
2117 -> 1436;
2117 -> 1434;
2118 -> 1632;
2119 -> 2118;
2119 -> 1472;
2120 -> 2119;
2120 -> 1474;
2120 -> 1472;
2121 -> 1470;
2121 -> 1502;
2121 -> 1628;
2121 -> 2120;
2121 -> 1637;
2121 -> 1498;
2121 -> 1499;
2121 -> 2106;
2121 -> 1509;
2121 -> 1501;
2122 -> 1652;
2123 -> 2122;
2123 -> 1521;
2124 -> 2123;
2124 -> 1523;
2124 -> 1521;
2125 -> 1519;
2125 -> 1553;
2125 -> 1648;
2125 -> 2124;
2125 -> 1657;
2125 -> 1547;
2125 -> 1548;
2125 -> 2110;
2125 -> 1555;
2125 -> 1552;
2126 -> 1672;
2127 -> 2126;
2127 -> 1567;
2128 -> 2127;
2128 -> 1569;
2128 -> 1567;
2129 -> 1565;
2129 -> 1599;
2129 -> 1668;
2129 -> 2128;
2129 -> 1677;
2129 -> 1593;
2129 -> 1594;
2129 -> 2114;
2129 -> 1601;
2129 -> 1598;
2130 -> 1613;
2131 -> 2130;
2131 -> 1434;
2132 -> 2131;
2132 -> 1436;
2132 -> 1434;
2133 -> 1632;
2134 -> 2133;
2134 -> 1472;
2135 -> 2134;
2135 -> 1474;
2135 -> 1472;
2136 -> 1470;
2136 -> 1502;
2136 -> 1628;
2136 -> 2135;
2136 -> 1637;
2136 -> 1498;
2136 -> 1499;
2136 -> 2121;
2136 -> 1509;
2136 -> 1501;
2137 -> 1652;
2138 -> 2137;
2138 -> 1521;
2139 -> 2138;
2139 -> 1523;
2139 -> 1521;
2140 -> 1519;
2140 -> 1553;
2140 -> 1648;
2140 -> 2139;
2140 -> 1657;
2140 -> 1547;
2140 -> 1548;
2140 -> 2125;
2140 -> 1555;
2140 -> 1552;
2141 -> 1672;
2142 -> 2141;
2142 -> 1567;
2143 -> 2142;
2143 -> 1569;
2143 -> 1567;
2144 -> 1565;
2144 -> 1599;
2144 -> 1668;
2144 -> 2143;
2144 -> 1677;
2144 -> 1593;
2144 -> 1594;
2144 -> 2129;
2144 -> 1601;
2144 -> 1598;
2145 -> 1613;
2146 -> 2145;
2146 -> 1434;
2147 -> 2146;
2147 -> 1436;
2147 -> 1434;
2148 -> 1632;
2149 -> 2148;
2149 -> 1472;
2150 -> 2149;
2150 -> 1474;
2150 -> 1472;
2151 -> 1470;
2151 -> 1502;
2151 -> 1628;
2151 -> 2150;
2151 -> 1637;
2151 -> 1498;
2151 -> 1499;
2151 -> 2136;
2151 -> 1509;
2151 -> 1501;
2152 -> 1652;
2153 -> 2152;
2153 -> 1521;
2154 -> 2153;
2154 -> 1523;
2154 -> 1521;
2155 -> 1519;
2155 -> 1553;
2155 -> 1648;
2155 -> 2154;
2155 -> 1657;
2155 -> 1547;
2155 -> 1548;
2155 -> 2140;
2155 -> 1555;
2155 -> 1552;
2156 -> 1672;
2157 -> 2156;
2157 -> 1567;
2158 -> 2157;
2158 -> 1569;
2158 -> 1567;
2159 -> 1565;
2159 -> 1599;
2159 -> 1668;
2159 -> 2158;
2159 -> 1677;
2159 -> 1593;
2159 -> 1594;
2159 -> 2144;
2159 -> 1601;
2159 -> 1598;
2160 -> 1613;
2161 -> 2160;
2161 -> 1434;
2162 -> 2161;
2162 -> 1436;
2162 -> 1434;
2163 -> 1632;
2164 -> 2163;
2164 -> 1472;
2165 -> 2164;
2165 -> 1474;
2165 -> 1472;
2166 -> 1470;
2166 -> 1502;
2166 -> 1628;
2166 -> 2165;
2166 -> 1637;
2166 -> 1498;
2166 -> 1499;
2166 -> 2151;
2166 -> 1509;
2166 -> 1501;
2167 -> 1652;
2168 -> 2167;
2168 -> 1521;
2169 -> 2168;
2169 -> 1523;
2169 -> 1521;
2170 -> 1519;
2170 -> 1553;
2170 -> 1648;
2170 -> 2169;
2170 -> 1657;
2170 -> 1547;
2170 -> 1548;
2170 -> 2155;
2170 -> 1555;
2170 -> 1552;
2171 -> 1672;
2172 -> 2171;
2172 -> 1567;
2173 -> 2172;
2173 -> 1569;
2173 -> 1567;
2174 -> 1565;
2174 -> 1599;
2174 -> 1668;
2174 -> 2173;
2174 -> 1677;
2174 -> 1593;
2174 -> 1594;
2174 -> 2159;
2174 -> 1601;
2174 -> 1598;
2175 -> 1613;
2176 -> 2175;
2176 -> 1434;
2177 -> 2176;
2177 -> 1436;
2177 -> 1434;
2178 -> 1632;
2179 -> 2178;
2179 -> 1472;
2180 -> 2179;
2180 -> 1474;
2180 -> 1472;
2181 -> 1470;
2181 -> 1502;
2181 -> 1628;
2181 -> 2180;
2181 -> 1637;
2181 -> 1498;
2181 -> 1499;
2181 -> 2166;
2181 -> 1509;
2181 -> 1501;
2182 -> 1652;
2183 -> 2182;
2183 -> 1521;
2184 -> 2183;
2184 -> 1523;
2184 -> 1521;
2185 -> 1519;
2185 -> 1553;
2185 -> 1648;
2185 -> 2184;
2185 -> 1657;
2185 -> 1547;
2185 -> 1548;
2185 -> 2170;
2185 -> 1555;
2185 -> 1552;
2186 -> 1672;
2187 -> 2186;
2187 -> 1567;
2188 -> 2187;
2188 -> 1569;
2188 -> 1567;
2189 -> 1565;
2189 -> 1599;
2189 -> 1668;
2189 -> 2188;
2189 -> 1677;
2189 -> 1593;
2189 -> 1594;
2189 -> 2174;
2189 -> 1601;
2189 -> 1598;
2190 -> 1613;
2191 -> 2190;
2191 -> 1434;
2192 -> 2191;
2192 -> 1436;
2192 -> 1434;
2193 -> 1632;
2194 -> 2193;
2194 -> 1472;
2195 -> 2194;
2195 -> 1474;
2195 -> 1472;
2196 -> 1470;
2196 -> 1502;
2196 -> 1628;
2196 -> 2195;
2196 -> 1637;
2196 -> 1498;
2196 -> 1499;
2196 -> 2181;
2196 -> 1509;
2196 -> 1501;
2197 -> 1652;
2198 -> 2197;
2198 -> 1521;
2199 -> 2198;
2199 -> 1523;
2199 -> 1521;
2200 -> 1519;
2200 -> 1553;
2200 -> 1648;
2200 -> 2199;
2200 -> 1657;
2200 -> 1547;
2200 -> 1548;
2200 -> 2185;
2200 -> 1555;
2200 -> 1552;
2201 -> 1672;
2202 -> 2201;
2202 -> 1567;
2203 -> 2202;
2203 -> 1569;
2203 -> 1567;
2204 -> 1565;
2204 -> 1599;
2204 -> 1668;
2204 -> 2203;
2204 -> 1677;
2204 -> 1593;
2204 -> 1594;
2204 -> 2189;
2204 -> 1601;
2204 -> 1598;
2205 -> 1613;
2206 -> 2205;
2206 -> 1434;
2207 -> 2206;
2207 -> 1436;
2207 -> 1434;
2208 -> 1632;
2209 -> 2208;
2209 -> 1472;
2210 -> 2209;
2210 -> 1474;
2210 -> 1472;
2211 -> 1470;
2211 -> 1502;
2211 -> 1628;
2211 -> 2210;
2211 -> 1637;
2211 -> 1498;
2211 -> 1499;
2211 -> 2196;
2211 -> 1509;
2211 -> 1501;
2212 -> 1652;
2213 -> 2212;
2213 -> 1521;
2214 -> 2213;
2214 -> 1523;
2214 -> 1521;
2215 -> 1519;
2215 -> 1553;
2215 -> 1648;
2215 -> 2214;
2215 -> 1657;
2215 -> 1547;
2215 -> 1548;
2215 -> 2200;
2215 -> 1555;
2215 -> 1552;
2216 -> 1672;
2217 -> 2216;
2217 -> 1567;
2218 -> 2217;
2218 -> 1569;
2218 -> 1567;
2219 -> 1565;
2219 -> 1599;
2219 -> 1668;
2219 -> 2218;
2219 -> 1677;
2219 -> 1593;
2219 -> 1594;
2219 -> 2204;
2219 -> 1601;
2219 -> 1598;
2220 -> 1613;
2221 -> 2220;
2221 -> 1434;
2222 -> 2221;
2222 -> 1436;
2222 -> 1434;
2223 -> 1632;
2224 -> 2223;
2224 -> 1472;
2225 -> 2224;
2225 -> 1474;
2225 -> 1472;
2226 -> 1470;
2226 -> 1502;
2226 -> 1628;
2226 -> 2225;
2226 -> 1637;
2226 -> 1498;
2226 -> 1499;
2226 -> 2211;
2226 -> 1509;
2226 -> 1501;
2227 -> 1652;
2228 -> 2227;
2228 -> 1521;
2229 -> 2228;
2229 -> 1523;
2229 -> 1521;
2230 -> 1519;
2230 -> 1553;
2230 -> 1648;
2230 -> 2229;
2230 -> 1657;
2230 -> 1547;
2230 -> 1548;
2230 -> 2215;
2230 -> 1555;
2230 -> 1552;
2231 -> 1672;
2232 -> 2231;
2232 -> 1567;
2233 -> 2232;
2233 -> 1569;
2233 -> 1567;
2234 -> 1565;
2234 -> 1599;
2234 -> 1668;
2234 -> 2233;
2234 -> 1677;
2234 -> 1593;
2234 -> 1594;
2234 -> 2219;
2234 -> 1601;
2234 -> 1598;
2235 -> 1613;
2236 -> 2235;
2236 -> 1434;
2237 -> 2236;
2237 -> 1436;
2237 -> 1434;
2238 -> 1632;
2239 -> 2238;
2239 -> 1472;
2240 -> 2239;
2240 -> 1474;
2240 -> 1472;
2241 -> 1470;
2241 -> 1502;
2241 -> 1628;
2241 -> 2240;
2241 -> 1637;
2241 -> 1498;
2241 -> 1499;
2241 -> 2226;
2241 -> 1509;
2241 -> 1501;
2242 -> 1652;
2243 -> 2242;
2243 -> 1521;
2244 -> 2243;
2244 -> 1523;
2244 -> 1521;
2245 -> 1519;
2245 -> 1553;
2245 -> 1648;
2245 -> 2244;
2245 -> 1657;
2245 -> 1547;
2245 -> 1548;
2245 -> 2230;
2245 -> 1555;
2245 -> 1552;
2246 -> 1672;
2247 -> 2246;
2247 -> 1567;
2248 -> 2247;
2248 -> 1569;
2248 -> 1567;
2249 -> 1565;
2249 -> 1599;
2249 -> 1668;
2249 -> 2248;
2249 -> 1677;
2249 -> 1593;
2249 -> 1594;
2249 -> 2234;
2249 -> 1601;
2249 -> 1598;
2250 -> 1613;
2251 -> 2250;
2251 -> 1434;
2252 -> 2251;
2252 -> 1436;
2252 -> 1434;
2253 -> 1632;
2254 -> 2253;
2254 -> 1472;
2255 -> 2254;
2255 -> 1474;
2255 -> 1472;
2256 -> 1470;
2256 -> 1502;
2256 -> 1628;
2256 -> 2255;
2256 -> 1637;
2256 -> 1498;
2256 -> 1499;
2256 -> 2241;
2256 -> 1509;
2256 -> 1501;
2257 -> 1652;
2258 -> 2257;
2258 -> 1521;
2259 -> 2258;
2259 -> 1523;
2259 -> 1521;
2260 -> 1519;
2260 -> 1553;
2260 -> 1648;
2260 -> 2259;
2260 -> 1657;
2260 -> 1547;
2260 -> 1548;
2260 -> 2245;
2260 -> 1555;
2260 -> 1552;
2261 -> 1672;
2262 -> 2261;
2262 -> 1567;
2263 -> 2262;
2263 -> 1569;
2263 -> 1567;
2264 -> 1565;
2264 -> 1599;
2264 -> 1668;
2264 -> 2263;
2264 -> 1677;
2264 -> 1593;
2264 -> 1594;
2264 -> 2249;
2264 -> 1601;
2264 -> 1598;
2265 -> 1613;
2266 -> 2265;
2266 -> 1434;
2267 -> 2266;
2267 -> 1436;
2267 -> 1434;
2268 -> 1632;
2269 -> 2268;
2269 -> 1472;
2270 -> 2269;
2270 -> 1474;
2270 -> 1472;
2271 -> 1470;
2271 -> 1502;
2271 -> 1628;
2271 -> 2270;
2271 -> 1637;
2271 -> 1498;
2271 -> 1499;
2271 -> 2256;
2271 -> 1509;
2271 -> 1501;
2272 -> 1652;
2273 -> 2272;
2273 -> 1521;
2274 -> 2273;
2274 -> 1523;
2274 -> 1521;
2275 -> 1519;
2275 -> 1553;
2275 -> 1648;
2275 -> 2274;
2275 -> 1657;
2275 -> 1547;
2275 -> 1548;
2275 -> 2260;
2275 -> 1555;
2275 -> 1552;
2276 -> 1672;
2277 -> 2276;
2277 -> 1567;
2278 -> 2277;
2278 -> 1569;
2278 -> 1567;
2279 -> 1565;
2279 -> 1599;
2279 -> 1668;
2279 -> 2278;
2279 -> 1677;
2279 -> 1593;
2279 -> 1594;
2279 -> 2264;
2279 -> 1601;
2279 -> 1598;
2280 -> 1613;
2281 -> 2280;
2281 -> 1434;
2282 -> 2281;
2282 -> 1436;
2282 -> 1434;
2283 -> 1632;
2284 -> 2283;
2284 -> 1472;
2285 -> 2284;
2285 -> 1474;
2285 -> 1472;
2286 -> 1470;
2286 -> 1502;
2286 -> 1628;
2286 -> 2285;
2286 -> 1637;
2286 -> 1498;
2286 -> 1499;
2286 -> 2271;
2286 -> 1509;
2286 -> 1501;
2287 -> 1652;
2288 -> 2287;
2288 -> 1521;
2289 -> 2288;
2289 -> 1523;
2289 -> 1521;
2290 -> 1519;
2290 -> 1553;
2290 -> 1648;
2290 -> 2289;
2290 -> 1657;
2290 -> 1547;
2290 -> 1548;
2290 -> 2275;
2290 -> 1555;
2290 -> 1552;
2291 -> 1672;
2292 -> 2291;
2292 -> 1567;
2293 -> 2292;
2293 -> 1569;
2293 -> 1567;
2294 -> 1565;
2294 -> 1599;
2294 -> 1668;
2294 -> 2293;
2294 -> 1677;
2294 -> 1593;
2294 -> 1594;
2294 -> 2279;
2294 -> 1601;
2294 -> 1598;
2295 -> 1613;
2296 -> 2295;
2296 -> 1434;
2297 -> 2296;
2297 -> 1436;
2297 -> 1434;
2298 -> 1632;
2299 -> 2298;
2299 -> 1472;
2300 -> 2299;
2300 -> 1474;
2300 -> 1472;
2301 -> 1470;
2301 -> 1502;
2301 -> 1628;
2301 -> 2300;
2301 -> 1637;
2301 -> 1498;
2301 -> 1499;
2301 -> 2286;
2301 -> 1509;
2301 -> 1501;
2302 -> 1652;
2303 -> 2302;
2303 -> 1521;
2304 -> 2303;
2304 -> 1523;
2304 -> 1521;
2305 -> 1519;
2305 -> 1553;
2305 -> 1648;
2305 -> 2304;
2305 -> 1657;
2305 -> 1547;
2305 -> 1548;
2305 -> 2290;
2305 -> 1555;
2305 -> 1552;
2306 -> 1672;
2307 -> 2306;
2307 -> 1567;
2308 -> 2307;
2308 -> 1569;
2308 -> 1567;
2309 -> 1565;
2309 -> 1599;
2309 -> 1668;
2309 -> 2308;
2309 -> 1677;
2309 -> 1593;
2309 -> 1594;
2309 -> 2294;
2309 -> 1601;
2309 -> 1598;
2310 -> 1613;
2311 -> 2310;
2311 -> 1434;
2312 -> 2311;
2312 -> 1436;
2312 -> 1434;
2313 -> 1632;
2314 -> 2313;
2314 -> 1472;
2315 -> 2314;
2315 -> 1474;
2315 -> 1472;
2316 -> 1470;
2316 -> 1502;
2316 -> 1628;
2316 -> 2315;
2316 -> 1637;
2316 -> 1498;
2316 -> 1499;
2316 -> 2301;
2316 -> 1509;
2316 -> 1501;
2317 -> 1652;
2318 -> 2317;
2318 -> 1521;
2319 -> 2318;
2319 -> 1523;
2319 -> 1521;
2320 -> 1519;
2320 -> 1553;
2320 -> 1648;
2320 -> 2319;
2320 -> 1657;
2320 -> 1547;
2320 -> 1548;
2320 -> 2305;
2320 -> 1555;
2320 -> 1552;
2321 -> 1672;
2322 -> 2321;
2322 -> 1567;
2323 -> 2322;
2323 -> 1569;
2323 -> 1567;
2324 -> 1565;
2324 -> 1599;
2324 -> 1668;
2324 -> 2323;
2324 -> 1677;
2324 -> 1593;
2324 -> 1594;
2324 -> 2309;
2324 -> 1601;
2324 -> 1598;
2325 -> 1613;
2326 -> 2325;
2326 -> 1434;
2327 -> 2326;
2327 -> 1436;
2327 -> 1434;
2328 -> 1632;
2329 -> 2328;
2329 -> 1472;
2330 -> 2329;
2330 -> 1474;
2330 -> 1472;
2331 -> 1470;
2331 -> 1502;
2331 -> 1628;
2331 -> 2330;
2331 -> 1637;
2331 -> 1498;
2331 -> 1499;
2331 -> 2316;
2331 -> 1509;
2331 -> 1501;
2332 -> 1652;
2333 -> 2332;
2333 -> 1521;
2334 -> 2333;
2334 -> 1523;
2334 -> 1521;
2335 -> 1519;
2335 -> 1553;
2335 -> 1648;
2335 -> 2334;
2335 -> 1657;
2335 -> 1547;
2335 -> 1548;
2335 -> 2320;
2335 -> 1555;
2335 -> 1552;
2336 -> 1672;
2337 -> 2336;
2337 -> 1567;
2338 -> 2337;
2338 -> 1569;
2338 -> 1567;
2339 -> 1565;
2339 -> 1599;
2339 -> 1668;
2339 -> 2338;
2339 -> 1677;
2339 -> 1593;
2339 -> 1594;
2339 -> 2324;
2339 -> 1601;
2339 -> 1598;
2340 -> 1613;
2341 -> 2340;
2341 -> 1434;
2342 -> 2341;
2342 -> 1436;
2342 -> 1434;
2343 -> 1632;
2344 -> 2343;
2344 -> 1472;
2345 -> 2344;
2345 -> 1474;
2345 -> 1472;
2346 -> 1470;
2346 -> 1502;
2346 -> 1628;
2346 -> 2345;
2346 -> 1637;
2346 -> 1498;
2346 -> 1499;
2346 -> 2331;
2346 -> 1509;
2346 -> 1501;
2347 -> 1652;
2348 -> 2347;
2348 -> 1521;
2349 -> 2348;
2349 -> 1523;
2349 -> 1521;
2350 -> 1519;
2350 -> 1553;
2350 -> 1648;
2350 -> 2349;
2350 -> 1657;
2350 -> 1547;
2350 -> 1548;
2350 -> 2335;
2350 -> 1555;
2350 -> 1552;
2351 -> 1672;
2352 -> 2351;
2352 -> 1567;
2353 -> 2352;
2353 -> 1569;
2353 -> 1567;
2354 -> 1565;
2354 -> 1599;
2354 -> 1668;
2354 -> 2353;
2354 -> 1677;
2354 -> 1593;
2354 -> 1594;
2354 -> 2339;
2354 -> 1601;
2354 -> 1598;
2355 -> 1613;
2356 -> 2355;
2356 -> 1434;
2357 -> 2356;
2357 -> 1436;
2357 -> 1434;
2358 -> 1632;
2359 -> 2358;
2359 -> 1472;
2360 -> 2359;
2360 -> 1474;
2360 -> 1472;
2361 -> 1470;
2361 -> 1502;
2361 -> 1628;
2361 -> 2360;
2361 -> 1637;
2361 -> 1498;
2361 -> 1499;
2361 -> 2346;
2361 -> 1509;
2361 -> 1501;
2362 -> 1652;
2363 -> 2362;
2363 -> 1521;
2364 -> 2363;
2364 -> 1523;
2364 -> 1521;
2365 -> 1519;
2365 -> 1553;
2365 -> 1648;
2365 -> 2364;
2365 -> 1657;
2365 -> 1547;
2365 -> 1548;
2365 -> 2350;
2365 -> 1555;
2365 -> 1552;
2366 -> 1672;
2367 -> 2366;
2367 -> 1567;
2368 -> 2367;
2368 -> 1569;
2368 -> 1567;
2369 -> 1565;
2369 -> 1599;
2369 -> 1668;
2369 -> 2368;
2369 -> 1677;
2369 -> 1593;
2369 -> 1594;
2369 -> 2354;
2369 -> 1601;
2369 -> 1598;
2370 -> 1613;
2371 -> 2370;
2371 -> 1434;
2372 -> 2371;
2372 -> 1436;
2372 -> 1434;
2373 -> 1632;
2374 -> 2373;
2374 -> 1472;
2375 -> 2374;
2375 -> 1474;
2375 -> 1472;
2376 -> 1470;
2376 -> 1502;
2376 -> 1628;
2376 -> 2375;
2376 -> 1637;
2376 -> 1498;
2376 -> 1499;
2376 -> 2361;
2376 -> 1509;
2376 -> 1501;
2377 -> 1652;
2378 -> 2377;
2378 -> 1521;
2379 -> 2378;
2379 -> 1523;
2379 -> 1521;
2380 -> 1519;
2380 -> 1553;
2380 -> 1648;
2380 -> 2379;
2380 -> 1657;
2380 -> 1547;
2380 -> 1548;
2380 -> 2365;
2380 -> 1555;
2380 -> 1552;
2381 -> 1672;
2382 -> 2381;
2382 -> 1567;
2383 -> 2382;
2383 -> 1569;
2383 -> 1567;
2384 -> 1565;
2384 -> 1599;
2384 -> 1668;
2384 -> 2383;
2384 -> 1677;
2384 -> 1593;
2384 -> 1594;
2384 -> 2369;
2384 -> 1601;
2384 -> 1598;
2385 -> 1613;
2386 -> 2385;
2386 -> 1434;
2387 -> 2386;
2387 -> 1436;
2387 -> 1434;
2388 -> 1632;
2389 -> 2388;
2389 -> 1472;
2390 -> 2389;
2390 -> 1474;
2390 -> 1472;
2391 -> 1470;
2391 -> 1502;
2391 -> 1628;
2391 -> 2390;
2391 -> 1637;
2391 -> 1498;
2391 -> 1499;
2391 -> 2376;
2391 -> 1509;
2391 -> 1501;
2392 -> 1652;
2393 -> 2392;
2393 -> 1521;
2394 -> 2393;
2394 -> 1523;
2394 -> 1521;
2395 -> 1519;
2395 -> 1553;
2395 -> 1648;
2395 -> 2394;
2395 -> 1657;
2395 -> 1547;
2395 -> 1548;
2395 -> 2380;
2395 -> 1555;
2395 -> 1552;
2396 -> 1672;
2397 -> 2396;
2397 -> 1567;
2398 -> 2397;
2398 -> 1569;
2398 -> 1567;
2399 -> 1565;
2399 -> 1599;
2399 -> 1668;
2399 -> 2398;
2399 -> 1677;
2399 -> 1593;
2399 -> 1594;
2399 -> 2384;
2399 -> 1601;
2399 -> 1598;
2400 -> 1613;
2401 -> 2400;
2401 -> 1434;
2402 -> 2401;
2402 -> 1436;
2402 -> 1434;
2403 -> 1632;
2404 -> 2403;
2404 -> 1472;
2405 -> 2404;
2405 -> 1474;
2405 -> 1472;
2406 -> 1470;
2406 -> 1502;
2406 -> 1628;
2406 -> 2405;
2406 -> 1637;
2406 -> 1498;
2406 -> 1499;
2406 -> 2391;
2406 -> 1509;
2406 -> 1501;
2407 -> 1652;
2408 -> 2407;
2408 -> 1521;
2409 -> 2408;
2409 -> 1523;
2409 -> 1521;
2410 -> 1519;
2410 -> 1553;
2410 -> 1648;
2410 -> 2409;
2410 -> 1657;
2410 -> 1547;
2410 -> 1548;
2410 -> 2395;
2410 -> 1555;
2410 -> 1552;
2411 -> 1672;
2412 -> 2411;
2412 -> 1567;
2413 -> 2412;
2413 -> 1569;
2413 -> 1567;
2414 -> 1565;
2414 -> 1599;
2414 -> 1668;
2414 -> 2413;
2414 -> 1677;
2414 -> 1593;
2414 -> 1594;
2414 -> 2399;
2414 -> 1601;
2414 -> 1598;
2415 -> 1613;
2416 -> 2415;
2416 -> 1434;
2417 -> 2416;
2417 -> 1436;
2417 -> 1434;
2418 -> 1632;
2419 -> 2418;
2419 -> 1472;
2420 -> 2419;
2420 -> 1474;
2420 -> 1472;
2421 -> 1470;
2421 -> 1502;
2421 -> 1628;
2421 -> 2420;
2421 -> 1637;
2421 -> 1498;
2421 -> 1499;
2421 -> 2406;
2421 -> 1509;
2421 -> 1501;
2422 -> 1652;
2423 -> 2422;
2423 -> 1521;
2424 -> 2423;
2424 -> 1523;
2424 -> 1521;
2425 -> 1519;
2425 -> 1553;
2425 -> 1648;
2425 -> 2424;
2425 -> 1657;
2425 -> 1547;
2425 -> 1548;
2425 -> 2410;
2425 -> 1555;
2425 -> 1552;
2426 -> 1672;
2427 -> 2426;
2427 -> 1567;
2428 -> 2427;
2428 -> 1569;
2428 -> 1567;
2429 -> 1565;
2429 -> 1599;
2429 -> 1668;
2429 -> 2428;
2429 -> 1677;
2429 -> 1593;
2429 -> 1594;
2429 -> 2414;
2429 -> 1601;
2429 -> 1598;
2430 -> 1613;
2431 -> 2430;
2431 -> 1434;
2432 -> 2431;
2432 -> 1436;
2432 -> 1434;
2433 -> 1632;
2434 -> 2433;
2434 -> 1472;
2435 -> 2434;
2435 -> 1474;
2435 -> 1472;
2436 -> 1470;
2436 -> 1502;
2436 -> 1628;
2436 -> 2435;
2436 -> 1637;
2436 -> 1498;
2436 -> 1499;
2436 -> 2421;
2436 -> 1509;
2436 -> 1501;
2437 -> 1652;
2438 -> 2437;
2438 -> 1521;
2439 -> 2438;
2439 -> 1523;
2439 -> 1521;
2440 -> 1519;
2440 -> 1553;
2440 -> 1648;
2440 -> 2439;
2440 -> 1657;
2440 -> 1547;
2440 -> 1548;
2440 -> 2425;
2440 -> 1555;
2440 -> 1552;
2441 -> 1672;
2442 -> 2441;
2442 -> 1567;
2443 -> 2442;
2443 -> 1569;
2443 -> 1567;
2444 -> 1565;
2444 -> 1599;
2444 -> 1668;
2444 -> 2443;
2444 -> 1677;
2444 -> 1593;
2444 -> 1594;
2444 -> 2429;
2444 -> 1601;
2444 -> 1598;
2445 -> 1613;
2446 -> 2445;
2446 -> 1434;
2447 -> 2446;
2447 -> 1436;
2447 -> 1434;
2448 -> 1632;
2449 -> 2448;
2449 -> 1472;
2450 -> 2449;
2450 -> 1474;
2450 -> 1472;
2451 -> 1470;
2451 -> 1502;
2451 -> 1628;
2451 -> 2450;
2451 -> 1637;
2451 -> 1498;
2451 -> 1499;
2451 -> 2436;
2451 -> 1509;
2451 -> 1501;
2452 -> 1652;
2453 -> 2452;
2453 -> 1521;
2454 -> 2453;
2454 -> 1523;
2454 -> 1521;
2455 -> 1519;
2455 -> 1553;
2455 -> 1648;
2455 -> 2454;
2455 -> 1657;
2455 -> 1547;
2455 -> 1548;
2455 -> 2440;
2455 -> 1555;
2455 -> 1552;
2456 -> 1672;
2457 -> 2456;
2457 -> 1567;
2458 -> 2457;
2458 -> 1569;
2458 -> 1567;
2459 -> 1565;
2459 -> 1599;
2459 -> 1668;
2459 -> 2458;
2459 -> 1677;
2459 -> 1593;
2459 -> 1594;
2459 -> 2444;
2459 -> 1601;
2459 -> 1598;
2460 -> 1613;
2461 -> 2460;
2461 -> 1434;
2462 -> 2461;
2462 -> 1436;
2462 -> 1434;
2463 -> 1632;
2464 -> 2463;
2464 -> 1472;
2465 -> 2464;
2465 -> 1474;
2465 -> 1472;
2466 -> 1470;
2466 -> 1502;
2466 -> 1628;
2466 -> 2465;
2466 -> 1637;
2466 -> 1498;
2466 -> 1499;
2466 -> 2451;
2466 -> 1509;
2466 -> 1501;
2467 -> 1652;
2468 -> 2467;
2468 -> 1521;
2469 -> 2468;
2469 -> 1523;
2469 -> 1521;
2470 -> 1519;
2470 -> 1553;
2470 -> 1648;
2470 -> 2469;
2470 -> 1657;
2470 -> 1547;
2470 -> 1548;
2470 -> 2455;
2470 -> 1555;
2470 -> 1552;
2471 -> 1672;
2472 -> 2471;
2472 -> 1567;
2473 -> 2472;
2473 -> 1569;
2473 -> 1567;
2474 -> 1565;
2474 -> 1599;
2474 -> 1668;
2474 -> 2473;
2474 -> 1677;
2474 -> 1593;
2474 -> 1594;
2474 -> 2459;
2474 -> 1601;
2474 -> 1598;
2475 -> 1613;
2476 -> 2475;
2476 -> 1434;
2477 -> 2476;
2477 -> 1436;
2477 -> 1434;
2478 -> 1632;
2479 -> 2478;
2479 -> 1472;
2480 -> 2479;
2480 -> 1474;
2480 -> 1472;
2481 -> 1470;
2481 -> 1502;
2481 -> 1628;
2481 -> 2480;
2481 -> 1637;
2481 -> 1498;
2481 -> 1499;
2481 -> 2466;
2481 -> 1509;
2481 -> 1501;
2482 -> 1652;
2483 -> 2482;
2483 -> 1521;
2484 -> 2483;
2484 -> 1523;
2484 -> 1521;
2485 -> 1519;
2485 -> 1553;
2485 -> 1648;
2485 -> 2484;
2485 -> 1657;
2485 -> 1547;
2485 -> 1548;
2485 -> 2470;
2485 -> 1555;
2485 -> 1552;
2486 -> 1672;
2487 -> 2486;
2487 -> 1567;
2488 -> 2487;
2488 -> 1569;
2488 -> 1567;
2489 -> 1565;
2489 -> 1599;
2489 -> 1668;
2489 -> 2488;
2489 -> 1677;
2489 -> 1593;
2489 -> 1594;
2489 -> 2474;
2489 -> 1601;
2489 -> 1598;
2490 -> 1613;
2491 -> 2490;
2491 -> 1434;
2492 -> 2491;
2492 -> 1436;
2492 -> 1434;
2493 -> 1632;
2494 -> 2493;
2494 -> 1472;
2495 -> 2494;
2495 -> 1474;
2495 -> 1472;
2496 -> 1470;
2496 -> 1502;
2496 -> 1628;
2496 -> 2495;
2496 -> 1637;
2496 -> 1498;
2496 -> 1499;
2496 -> 2481;
2496 -> 1509;
2496 -> 1501;
2497 -> 1652;
2498 -> 2497;
2498 -> 1521;
2499 -> 2498;
2499 -> 1523;
2499 -> 1521;
2500 -> 1519;
2500 -> 1553;
2500 -> 1648;
2500 -> 2499;
2500 -> 1657;
2500 -> 1547;
2500 -> 1548;
2500 -> 2485;
2500 -> 1555;
2500 -> 1552;
2501 -> 1672;
2502 -> 2501;
2502 -> 1567;
2503 -> 2502;
2503 -> 1569;
2503 -> 1567;
2504 -> 1565;
2504 -> 1599;
2504 -> 1668;
2504 -> 2503;
2504 -> 1677;
2504 -> 1593;
2504 -> 1594;
2504 -> 2489;
2504 -> 1601;
2504 -> 1598;
2505 -> 1613;
2506 -> 2505;
2506 -> 1434;
2507 -> 2506;
2507 -> 1436;
2507 -> 1434;
2508 -> 1632;
2509 -> 2508;
2509 -> 1472;
2510 -> 2509;
2510 -> 1474;
2510 -> 1472;
2511 -> 1470;
2511 -> 1502;
2511 -> 1628;
2511 -> 2510;
2511 -> 1637;
2511 -> 1498;
2511 -> 1499;
2511 -> 2496;
2511 -> 1509;
2511 -> 1501;
2512 -> 1652;
2513 -> 2512;
2513 -> 1521;
2514 -> 2513;
2514 -> 1523;
2514 -> 1521;
2515 -> 1519;
2515 -> 1553;
2515 -> 1648;
2515 -> 2514;
2515 -> 1657;
2515 -> 1547;
2515 -> 1548;
2515 -> 2500;
2515 -> 1555;
2515 -> 1552;
2516 -> 1672;
2517 -> 2516;
2517 -> 1567;
2518 -> 2517;
2518 -> 1569;
2518 -> 1567;
2519 -> 1565;
2519 -> 1599;
2519 -> 1668;
2519 -> 2518;
2519 -> 1677;
2519 -> 1593;
2519 -> 1594;
2519 -> 2504;
2519 -> 1601;
2519 -> 1598;
2520 -> 1613;
2521 -> 2520;
2521 -> 1434;
2522 -> 2521;
2522 -> 1436;
2522 -> 1434;
2523 -> 1632;
2524 -> 2523;
2524 -> 1472;
2525 -> 2524;
2525 -> 1474;
2525 -> 1472;
2526 -> 1470;
2526 -> 1502;
2526 -> 1628;
2526 -> 2525;
2526 -> 1637;
2526 -> 1498;
2526 -> 1499;
2526 -> 2511;
2526 -> 1509;
2526 -> 1501;
2527 -> 1652;
2528 -> 2527;
2528 -> 1521;
2529 -> 2528;
2529 -> 1523;
2529 -> 1521;
2530 -> 1519;
2530 -> 1553;
2530 -> 1648;
2530 -> 2529;
2530 -> 1657;
2530 -> 1547;
2530 -> 1548;
2530 -> 2515;
2530 -> 1555;
2530 -> 1552;
2531 -> 1672;
2532 -> 2531;
2532 -> 1567;
2533 -> 2532;
2533 -> 1569;
2533 -> 1567;
2534 -> 1565;
2534 -> 1599;
2534 -> 1668;
2534 -> 2533;
2534 -> 1677;
2534 -> 1593;
2534 -> 1594;
2534 -> 2519;
2534 -> 1601;
2534 -> 1598;
2535 -> 1613;
2536 -> 2535;
2536 -> 1434;
2537 -> 2536;
2537 -> 1436;
2537 -> 1434;
2538 -> 1632;
2539 -> 2538;
2539 -> 1472;
2540 -> 2539;
2540 -> 1474;
2540 -> 1472;
2541 -> 1470;
2541 -> 1502;
2541 -> 1628;
2541 -> 2540;
2541 -> 1637;
2541 -> 1498;
2541 -> 1499;
2541 -> 2526;
2541 -> 1509;
2541 -> 1501;
2542 -> 1652;
2543 -> 2542;
2543 -> 1521;
2544 -> 2543;
2544 -> 1523;
2544 -> 1521;
2545 -> 1519;
2545 -> 1553;
2545 -> 1648;
2545 -> 2544;
2545 -> 1657;
2545 -> 1547;
2545 -> 1548;
2545 -> 2530;
2545 -> 1555;
2545 -> 1552;
2546 -> 1672;
2547 -> 2546;
2547 -> 1567;
2548 -> 2547;
2548 -> 1569;
2548 -> 1567;
2549 -> 1565;
2549 -> 1599;
2549 -> 1668;
2549 -> 2548;
2549 -> 1677;
2549 -> 1593;
2549 -> 1594;
2549 -> 2534;
2549 -> 1601;
2549 -> 1598;
2550 -> 1613;
2551 -> 2550;
2551 -> 1434;
2552 -> 2551;
2552 -> 1436;
2552 -> 1434;
2553 -> 1632;
2554 -> 2553;
2554 -> 1472;
2555 -> 2554;
2555 -> 1474;
2555 -> 1472;
2556 -> 1470;
2556 -> 1502;
2556 -> 1628;
2556 -> 2555;
2556 -> 1637;
2556 -> 1498;
2556 -> 1499;
2556 -> 2541;
2556 -> 1509;
2556 -> 1501;
2557 -> 1652;
2558 -> 2557;
2558 -> 1521;
2559 -> 2558;
2559 -> 1523;
2559 -> 1521;
2560 -> 1519;
2560 -> 1553;
2560 -> 1648;
2560 -> 2559;
2560 -> 1657;
2560 -> 1547;
2560 -> 1548;
2560 -> 2545;
2560 -> 1555;
2560 -> 1552;
2561 -> 1672;
2562 -> 2561;
2562 -> 1567;
2563 -> 2562;
2563 -> 1569;
2563 -> 1567;
2564 -> 1565;
2564 -> 1599;
2564 -> 1668;
2564 -> 2563;
2564 -> 1677;
2564 -> 1593;
2564 -> 1594;
2564 -> 2549;
2564 -> 1601;
2564 -> 1598;
2565 -> 1613;
2566 -> 2565;
2566 -> 1434;
2567 -> 2566;
2567 -> 1436;
2567 -> 1434;
2568 -> 1632;
2569 -> 2568;
2569 -> 1472;
2570 -> 2569;
2570 -> 1474;
2570 -> 1472;
2571 -> 1470;
2571 -> 1502;
2571 -> 1628;
2571 -> 2570;
2571 -> 1637;
2571 -> 1498;
2571 -> 1499;
2571 -> 2556;
2571 -> 1509;
2571 -> 1501;
2572 -> 1652;
2573 -> 2572;
2573 -> 1521;
2574 -> 2573;
2574 -> 1523;
2574 -> 1521;
2575 -> 1519;
2575 -> 1553;
2575 -> 1648;
2575 -> 2574;
2575 -> 1657;
2575 -> 1547;
2575 -> 1548;
2575 -> 2560;
2575 -> 1555;
2575 -> 1552;
2576 -> 1672;
2577 -> 2576;
2577 -> 1567;
2578 -> 2577;
2578 -> 1569;
2578 -> 1567;
2579 -> 1565;
2579 -> 1599;
2579 -> 1668;
2579 -> 2578;
2579 -> 1677;
2579 -> 1593;
2579 -> 1594;
2579 -> 2564;
2579 -> 1601;
2579 -> 1598;
2580 -> 1613;
2581 -> 2580;
2581 -> 1434;
2582 -> 2581;
2582 -> 1436;
2582 -> 1434;
2583 -> 1632;
2584 -> 2583;
2584 -> 1472;
2585 -> 2584;
2585 -> 1474;
2585 -> 1472;
2586 -> 1470;
2586 -> 1502;
2586 -> 1628;
2586 -> 2585;
2586 -> 1637;
2586 -> 1498;
2586 -> 1499;
2586 -> 2571;
2586 -> 1509;
2586 -> 1501;
2587 -> 1652;
2588 -> 2587;
2588 -> 1521;
2589 -> 2588;
2589 -> 1523;
2589 -> 1521;
2590 -> 1519;
2590 -> 1553;
2590 -> 1648;
2590 -> 2589;
2590 -> 1657;
2590 -> 1547;
2590 -> 1548;
2590 -> 2575;
2590 -> 1555;
2590 -> 1552;
2591 -> 1672;
2592 -> 2591;
2592 -> 1567;
2593 -> 2592;
2593 -> 1569;
2593 -> 1567;
2594 -> 1565;
2594 -> 1599;
2594 -> 1668;
2594 -> 2593;
2594 -> 1677;
2594 -> 1593;
2594 -> 1594;
2594 -> 2579;
2594 -> 1601;
2594 -> 1598;
2595 -> 1613;
2596 -> 2595;
2596 -> 1434;
2597 -> 2596;
2597 -> 1436;
2597 -> 1434;
2598 -> 1632;
2599 -> 2598;
2599 -> 1472;
2600 -> 2599;
2600 -> 1474;
2600 -> 1472;
2601 -> 1470;
2601 -> 1502;
2601 -> 1628;
2601 -> 2600;
2601 -> 1637;
2601 -> 1498;
2601 -> 1499;
2601 -> 2586;
2601 -> 1509;
2601 -> 1501;
2602 -> 1652;
2603 -> 2602;
2603 -> 1521;
2604 -> 2603;
2604 -> 1523;
2604 -> 1521;
2605 -> 1519;
2605 -> 1553;
2605 -> 1648;
2605 -> 2604;
2605 -> 1657;
2605 -> 1547;
2605 -> 1548;
2605 -> 2590;
2605 -> 1555;
2605 -> 1552;
2606 -> 1672;
2607 -> 2606;
2607 -> 1567;
2608 -> 2607;
2608 -> 1569;
2608 -> 1567;
2609 -> 1565;
2609 -> 1599;
2609 -> 1668;
2609 -> 2608;
2609 -> 1677;
2609 -> 1593;
2609 -> 1594;
2609 -> 2594;
2609 -> 1601;
2609 -> 1598;
2610 -> 1613;
2611 -> 2610;
2611 -> 1434;
2612 -> 2611;
2612 -> 1436;
2612 -> 1434;
2613 -> 1632;
2614 -> 2613;
2614 -> 1472;
2615 -> 2614;
2615 -> 1474;
2615 -> 1472;
2616 -> 1470;
2616 -> 1502;
2616 -> 1628;
2616 -> 2615;
2616 -> 1637;
2616 -> 1498;
2616 -> 1499;
2616 -> 2601;
2616 -> 1509;
2616 -> 1501;
2617 -> 1652;
2618 -> 2617;
2618 -> 1521;
2619 -> 2618;
2619 -> 1523;
2619 -> 1521;
2620 -> 1519;
2620 -> 1553;
2620 -> 1648;
2620 -> 2619;
2620 -> 1657;
2620 -> 1547;
2620 -> 1548;
2620 -> 2605;
2620 -> 1555;
2620 -> 1552;
2621 -> 1672;
2622 -> 2621;
2622 -> 1567;
2623 -> 2622;
2623 -> 1569;
2623 -> 1567;
2624 -> 1565;
2624 -> 1599;
2624 -> 1668;
2624 -> 2623;
2624 -> 1677;
2624 -> 1593;
2624 -> 1594;
2624 -> 2609;
2624 -> 1601;
2624 -> 1598;
2625 -> 1613;
2626 -> 2625;
2626 -> 1434;
2627 -> 2626;
2627 -> 1436;
2627 -> 1434;
2628 -> 1632;
2629 -> 2628;
2629 -> 1472;
2630 -> 2629;
2630 -> 1474;
2630 -> 1472;
2631 -> 1470;
2631 -> 1502;
2631 -> 1628;
2631 -> 2630;
2631 -> 1637;
2631 -> 1498;
2631 -> 1499;
2631 -> 2616;
2631 -> 1509;
2631 -> 1501;
2632 -> 1652;
2633 -> 2632;
2633 -> 1521;
2634 -> 2633;
2634 -> 1523;
2634 -> 1521;
2635 -> 1519;
2635 -> 1553;
2635 -> 1648;
2635 -> 2634;
2635 -> 1657;
2635 -> 1547;
2635 -> 1548;
2635 -> 2620;
2635 -> 1555;
2635 -> 1552;
2636 -> 1672;
2637 -> 2636;
2637 -> 1567;
2638 -> 2637;
2638 -> 1569;
2638 -> 1567;
2639 -> 1565;
2639 -> 1599;
2639 -> 1668;
2639 -> 2638;
2639 -> 1677;
2639 -> 1593;
2639 -> 1594;
2639 -> 2624;
2639 -> 1601;
2639 -> 1598;
2640 -> 1613;
2641 -> 2640;
2641 -> 1434;
2642 -> 2641;
2642 -> 1436;
2642 -> 1434;
2643 -> 1632;
2644 -> 2643;
2644 -> 1472;
2645 -> 2644;
2645 -> 1474;
2645 -> 1472;
2646 -> 1470;
2646 -> 1502;
2646 -> 1628;
2646 -> 2645;
2646 -> 1637;
2646 -> 1498;
2646 -> 1499;
2646 -> 2631;
2646 -> 1509;
2646 -> 1501;
2647 -> 1652;
2648 -> 2647;
2648 -> 1521;
2649 -> 2648;
2649 -> 1523;
2649 -> 1521;
2650 -> 1519;
2650 -> 1553;
2650 -> 1648;
2650 -> 2649;
2650 -> 1657;
2650 -> 1547;
2650 -> 1548;
2650 -> 2635;
2650 -> 1555;
2650 -> 1552;
2651 -> 1672;
2652 -> 2651;
2652 -> 1567;
2653 -> 2652;
2653 -> 1569;
2653 -> 1567;
2654 -> 1565;
2654 -> 1599;
2654 -> 1668;
2654 -> 2653;
2654 -> 1677;
2654 -> 1593;
2654 -> 1594;
2654 -> 2639;
2654 -> 1601;
2654 -> 1598;
2655 -> 1613;
2656 -> 2655;
2656 -> 1434;
2657 -> 2656;
2657 -> 1436;
2657 -> 1434;
2658 -> 1632;
2659 -> 2658;
2659 -> 1472;
2660 -> 2659;
2660 -> 1474;
2660 -> 1472;
2661 -> 1470;
2661 -> 1502;
2661 -> 1628;
2661 -> 2660;
2661 -> 1637;
2661 -> 1498;
2661 -> 1499;
2661 -> 2646;
2661 -> 1509;
2661 -> 1501;
2662 -> 1652;
2663 -> 2662;
2663 -> 1521;
2664 -> 2663;
2664 -> 1523;
2664 -> 1521;
2665 -> 1519;
2665 -> 1553;
2665 -> 1648;
2665 -> 2664;
2665 -> 1657;
2665 -> 1547;
2665 -> 1548;
2665 -> 2650;
2665 -> 1555;
2665 -> 1552;
2666 -> 1672;
2667 -> 2666;
2667 -> 1567;
2668 -> 2667;
2668 -> 1569;
2668 -> 1567;
2669 -> 1565;
2669 -> 1599;
2669 -> 1668;
2669 -> 2668;
2669 -> 1677;
2669 -> 1593;
2669 -> 1594;
2669 -> 2654;
2669 -> 1601;
2669 -> 1598;
2670 -> 1613;
2671 -> 2670;
2671 -> 1434;
2672 -> 2671;
2672 -> 1436;
2672 -> 1434;
2673 -> 1632;
2674 -> 2673;
2674 -> 1472;
2675 -> 2674;
2675 -> 1474;
2675 -> 1472;
2676 -> 1470;
2676 -> 1502;
2676 -> 1628;
2676 -> 2675;
2676 -> 1637;
2676 -> 1498;
2676 -> 1499;
2676 -> 2661;
2676 -> 1509;
2676 -> 1501;
2677 -> 1652;
2678 -> 2677;
2678 -> 1521;
2679 -> 2678;
2679 -> 1523;
2679 -> 1521;
2680 -> 1519;
2680 -> 1553;
2680 -> 1648;
2680 -> 2679;
2680 -> 1657;
2680 -> 1547;
2680 -> 1548;
2680 -> 2665;
2680 -> 1555;
2680 -> 1552;
2681 -> 1672;
2682 -> 2681;
2682 -> 1567;
2683 -> 2682;
2683 -> 1569;
2683 -> 1567;
2684 -> 1565;
2684 -> 1599;
2684 -> 1668;
2684 -> 2683;
2684 -> 1677;
2684 -> 1593;
2684 -> 1594;
2684 -> 2669;
2684 -> 1601;
2684 -> 1598;
2685 -> 1613;
2686 -> 2685;
2686 -> 1434;
2687 -> 2686;
2687 -> 1436;
2687 -> 1434;
2688 -> 1632;
2689 -> 2688;
2689 -> 1472;
2690 -> 2689;
2690 -> 1474;
2690 -> 1472;
2691 -> 1470;
2691 -> 1502;
2691 -> 1628;
2691 -> 2690;
2691 -> 1637;
2691 -> 1498;
2691 -> 1499;
2691 -> 2676;
2691 -> 1509;
2691 -> 1501;
2692 -> 1652;
2693 -> 2692;
2693 -> 1521;
2694 -> 2693;
2694 -> 1523;
2694 -> 1521;
2695 -> 1519;
2695 -> 1553;
2695 -> 1648;
2695 -> 2694;
2695 -> 1657;
2695 -> 1547;
2695 -> 1548;
2695 -> 2680;
2695 -> 1555;
2695 -> 1552;
2696 -> 1672;
2697 -> 2696;
2697 -> 1567;
2698 -> 2697;
2698 -> 1569;
2698 -> 1567;
2699 -> 1565;
2699 -> 1599;
2699 -> 1668;
2699 -> 2698;
2699 -> 1677;
2699 -> 1593;
2699 -> 1594;
2699 -> 2684;
2699 -> 1601;
2699 -> 1598;
2700 -> 1613;
2701 -> 2700;
2701 -> 1434;
2702 -> 2701;
2702 -> 1436;
2702 -> 1434;
2703 -> 1632;
2704 -> 2703;
2704 -> 1472;
2705 -> 2704;
2705 -> 1474;
2705 -> 1472;
2706 -> 1470;
2706 -> 1502;
2706 -> 1628;
2706 -> 2705;
2706 -> 1637;
2706 -> 1498;
2706 -> 1499;
2706 -> 2691;
2706 -> 1509;
2706 -> 1501;
2707 -> 1652;
2708 -> 2707;
2708 -> 1521;
2709 -> 2708;
2709 -> 1523;
2709 -> 1521;
2710 -> 1519;
2710 -> 1553;
2710 -> 1648;
2710 -> 2709;
2710 -> 1657;
2710 -> 1547;
2710 -> 1548;
2710 -> 2695;
2710 -> 1555;
2710 -> 1552;
2711 -> 1672;
2712 -> 2711;
2712 -> 1567;
2713 -> 2712;
2713 -> 1569;
2713 -> 1567;
2714 -> 1565;
2714 -> 1599;
2714 -> 1668;
2714 -> 2713;
2714 -> 1677;
2714 -> 1593;
2714 -> 1594;
2714 -> 2699;
2714 -> 1601;
2714 -> 1598;
2715 -> 1613;
2716 -> 2715;
2716 -> 1434;
2717 -> 2716;
2717 -> 1436;
2717 -> 1434;
2718 -> 1632;
2719 -> 2718;
2719 -> 1472;
2720 -> 2719;
2720 -> 1474;
2720 -> 1472;
2721 -> 1470;
2721 -> 1502;
2721 -> 1628;
2721 -> 2720;
2721 -> 1637;
2721 -> 1498;
2721 -> 1499;
2721 -> 2706;
2721 -> 1509;
2721 -> 1501;
2722 -> 1652;
2723 -> 2722;
2723 -> 1521;
2724 -> 2723;
2724 -> 1523;
2724 -> 1521;
2725 -> 1519;
2725 -> 1553;
2725 -> 1648;
2725 -> 2724;
2725 -> 1657;
2725 -> 1547;
2725 -> 1548;
2725 -> 2710;
2725 -> 1555;
2725 -> 1552;
2726 -> 1672;
2727 -> 2726;
2727 -> 1567;
2728 -> 2727;
2728 -> 1569;
2728 -> 1567;
2729 -> 1565;
2729 -> 1599;
2729 -> 1668;
2729 -> 2728;
2729 -> 1677;
2729 -> 1593;
2729 -> 1594;
2729 -> 2714;
2729 -> 1601;
2729 -> 1598;
2730 -> 1613;
2731 -> 2730;
2731 -> 1434;
2732 -> 2731;
2732 -> 1436;
2732 -> 1434;
2733 -> 1632;
2734 -> 2733;
2734 -> 1472;
2735 -> 2734;
2735 -> 1474;
2735 -> 1472;
2736 -> 1470;
2736 -> 1502;
2736 -> 1628;
2736 -> 2735;
2736 -> 1637;
2736 -> 1498;
2736 -> 1499;
2736 -> 2721;
2736 -> 1509;
2736 -> 1501;
2737 -> 1652;
2738 -> 2737;
2738 -> 1521;
2739 -> 2738;
2739 -> 1523;
2739 -> 1521;
2740 -> 1519;
2740 -> 1553;
2740 -> 1648;
2740 -> 2739;
2740 -> 1657;
2740 -> 1547;
2740 -> 1548;
2740 -> 2725;
2740 -> 1555;
2740 -> 1552;
2741 -> 1672;
2742 -> 2741;
2742 -> 1567;
2743 -> 2742;
2743 -> 1569;
2743 -> 1567;
2744 -> 1565;
2744 -> 1599;
2744 -> 1668;
2744 -> 2743;
2744 -> 1677;
2744 -> 1593;
2744 -> 1594;
2744 -> 2729;
2744 -> 1601;
2744 -> 1598;
2745 -> 1613;
2746 -> 2745;
2746 -> 1434;
2747 -> 2746;
2747 -> 1436;
2747 -> 1434;
2748 -> 1632;
2749 -> 2748;
2749 -> 1472;
2750 -> 2749;
2750 -> 1474;
2750 -> 1472;
2751 -> 1470;
2751 -> 1502;
2751 -> 1628;
2751 -> 2750;
2751 -> 1637;
2751 -> 1498;
2751 -> 1499;
2751 -> 2736;
2751 -> 1509;
2751 -> 1501;
2752 -> 1652;
2753 -> 2752;
2753 -> 1521;
2754 -> 2753;
2754 -> 1523;
2754 -> 1521;
2755 -> 1519;
2755 -> 1553;
2755 -> 1648;
2755 -> 2754;
2755 -> 1657;
2755 -> 1547;
2755 -> 1548;
2755 -> 2740;
2755 -> 1555;
2755 -> 1552;
2756 -> 1672;
2757 -> 2756;
2757 -> 1567;
2758 -> 2757;
2758 -> 1569;
2758 -> 1567;
2759 -> 1565;
2759 -> 1599;
2759 -> 1668;
2759 -> 2758;
2759 -> 1677;
2759 -> 1593;
2759 -> 1594;
2759 -> 2744;
2759 -> 1601;
2759 -> 1598;
2760 -> 1613;
2761 -> 2760;
2761 -> 1434;
2762 -> 2761;
2762 -> 1436;
2762 -> 1434;
2763 -> 1632;
2764 -> 2763;
2764 -> 1472;
2765 -> 2764;
2765 -> 1474;
2765 -> 1472;
2766 -> 1470;
2766 -> 1502;
2766 -> 1628;
2766 -> 2765;
2766 -> 1637;
2766 -> 1498;
2766 -> 1499;
2766 -> 2751;
2766 -> 1509;
2766 -> 1501;
2767 -> 1652;
2768 -> 2767;
2768 -> 1521;
2769 -> 2768;
2769 -> 1523;
2769 -> 1521;
2770 -> 1519;
2770 -> 1553;
2770 -> 1648;
2770 -> 2769;
2770 -> 1657;
2770 -> 1547;
2770 -> 1548;
2770 -> 2755;
2770 -> 1555;
2770 -> 1552;
2771 -> 1672;
2772 -> 2771;
2772 -> 1567;
2773 -> 2772;
2773 -> 1569;
2773 -> 1567;
2774 -> 1565;
2774 -> 1599;
2774 -> 1668;
2774 -> 2773;
2774 -> 1677;
2774 -> 1593;
2774 -> 1594;
2774 -> 2759;
2774 -> 1601;
2774 -> 1598;
2775 -> 1613;
2776 -> 2775;
2776 -> 1434;
2777 -> 2776;
2777 -> 1436;
2777 -> 1434;
2778 -> 1632;
2779 -> 2778;
2779 -> 1472;
2780 -> 2779;
2780 -> 1474;
2780 -> 1472;
2781 -> 1470;
2781 -> 1502;
2781 -> 1628;
2781 -> 2780;
2781 -> 1637;
2781 -> 1498;
2781 -> 1499;
2781 -> 2766;
2781 -> 1509;
2781 -> 1501;
2782 -> 1652;
2783 -> 2782;
2783 -> 1521;
2784 -> 2783;
2784 -> 1523;
2784 -> 1521;
2785 -> 1519;
2785 -> 1553;
2785 -> 1648;
2785 -> 2784;
2785 -> 1657;
2785 -> 1547;
2785 -> 1548;
2785 -> 2770;
2785 -> 1555;
2785 -> 1552;
2786 -> 1672;
2787 -> 2786;
2787 -> 1567;
2788 -> 2787;
2788 -> 1569;
2788 -> 1567;
2789 -> 1565;
2789 -> 1599;
2789 -> 1668;
2789 -> 2788;
2789 -> 1677;
2789 -> 1593;
2789 -> 1594;
2789 -> 2774;
2789 -> 1601;
2789 -> 1598;
2790 -> 1613;
2791 -> 2790;
2791 -> 1434;
2792 -> 2791;
2792 -> 1436;
2792 -> 1434;
2793 -> 1632;
2794 -> 2793;
2794 -> 1472;
2795 -> 2794;
2795 -> 1474;
2795 -> 1472;
2796 -> 1470;
2796 -> 1502;
2796 -> 1628;
2796 -> 2795;
2796 -> 1637;
2796 -> 1498;
2796 -> 1499;
2796 -> 2781;
2796 -> 1509;
2796 -> 1501;
2797 -> 1652;
2798 -> 2797;
2798 -> 1521;
2799 -> 2798;
2799 -> 1523;
2799 -> 1521;
2800 -> 1519;
2800 -> 1553;
2800 -> 1648;
2800 -> 2799;
2800 -> 1657;
2800 -> 1547;
2800 -> 1548;
2800 -> 2785;
2800 -> 1555;
2800 -> 1552;
2801 -> 1672;
2802 -> 2801;
2802 -> 1567;
2803 -> 2802;
2803 -> 1569;
2803 -> 1567;
2804 -> 1565;
2804 -> 1599;
2804 -> 1668;
2804 -> 2803;
2804 -> 1677;
2804 -> 1593;
2804 -> 1594;
2804 -> 2789;
2804 -> 1601;
2804 -> 1598;
2805 -> 1613;
2806 -> 2805;
2806 -> 1434;
2807 -> 2806;
2807 -> 1436;
2807 -> 1434;
2808 -> 1632;
2809 -> 2808;
2809 -> 1472;
2810 -> 2809;
2810 -> 1474;
2810 -> 1472;
2811 -> 1470;
2811 -> 1502;
2811 -> 1628;
2811 -> 2810;
2811 -> 1637;
2811 -> 1498;
2811 -> 1499;
2811 -> 2796;
2811 -> 1509;
2811 -> 1501;
2812 -> 1652;
2813 -> 2812;
2813 -> 1521;
2814 -> 2813;
2814 -> 1523;
2814 -> 1521;
2815 -> 1519;
2815 -> 1553;
2815 -> 1648;
2815 -> 2814;
2815 -> 1657;
2815 -> 1547;
2815 -> 1548;
2815 -> 2800;
2815 -> 1555;
2815 -> 1552;
2816 -> 1672;
2817 -> 2816;
2817 -> 1567;
2818 -> 2817;
2818 -> 1569;
2818 -> 1567;
2819 -> 1565;
2819 -> 1599;
2819 -> 1668;
2819 -> 2818;
2819 -> 1677;
2819 -> 1593;
2819 -> 1594;
2819 -> 2804;
2819 -> 1601;
2819 -> 1598;
2820 -> 1613;
2821 -> 2820;
2821 -> 1434;
2822 -> 2821;
2822 -> 1436;
2822 -> 1434;
2823 -> 1632;
2824 -> 2823;
2824 -> 1472;
2825 -> 2824;
2825 -> 1474;
2825 -> 1472;
2826 -> 1470;
2826 -> 1502;
2826 -> 1628;
2826 -> 2825;
2826 -> 1637;
2826 -> 1498;
2826 -> 1499;
2826 -> 2811;
2826 -> 1509;
2826 -> 1501;
2827 -> 1652;
2828 -> 2827;
2828 -> 1521;
2829 -> 2828;
2829 -> 1523;
2829 -> 1521;
2830 -> 1519;
2830 -> 1553;
2830 -> 1648;
2830 -> 2829;
2830 -> 1657;
2830 -> 1547;
2830 -> 1548;
2830 -> 2815;
2830 -> 1555;
2830 -> 1552;
2831 -> 1672;
2832 -> 2831;
2832 -> 1567;
2833 -> 2832;
2833 -> 1569;
2833 -> 1567;
2834 -> 1565;
2834 -> 1599;
2834 -> 1668;
2834 -> 2833;
2834 -> 1677;
2834 -> 1593;
2834 -> 1594;
2834 -> 2819;
2834 -> 1601;
2834 -> 1598;
2835 -> 1613;
2836 -> 2835;
2836 -> 1434;
2837 -> 2836;
2837 -> 1436;
2837 -> 1434;
2838 -> 1632;
2839 -> 2838;
2839 -> 1472;
2840 -> 2839;
2840 -> 1474;
2840 -> 1472;
2841 -> 1470;
2841 -> 1502;
2841 -> 1628;
2841 -> 2840;
2841 -> 1637;
2841 -> 1498;
2841 -> 1499;
2841 -> 2826;
2841 -> 1509;
2841 -> 1501;
2842 -> 1652;
2843 -> 2842;
2843 -> 1521;
2844 -> 2843;
2844 -> 1523;
2844 -> 1521;
2845 -> 1519;
2845 -> 1553;
2845 -> 1648;
2845 -> 2844;
2845 -> 1657;
2845 -> 1547;
2845 -> 1548;
2845 -> 2830;
2845 -> 1555;
2845 -> 1552;
2846 -> 1672;
2847 -> 2846;
2847 -> 1567;
2848 -> 2847;
2848 -> 1569;
2848 -> 1567;
2849 -> 1565;
2849 -> 1599;
2849 -> 1668;
2849 -> 2848;
2849 -> 1677;
2849 -> 1593;
2849 -> 1594;
2849 -> 2834;
2849 -> 1601;
2849 -> 1598;
2850 -> 1613;
2851 -> 2850;
2851 -> 1434;
2852 -> 2851;
2852 -> 1436;
2852 -> 1434;
2853 -> 1632;
2854 -> 2853;
2854 -> 1472;
2855 -> 2854;
2855 -> 1474;
2855 -> 1472;
2856 -> 1470;
2856 -> 1502;
2856 -> 1628;
2856 -> 2855;
2856 -> 1637;
2856 -> 1498;
2856 -> 1499;
2856 -> 2841;
2856 -> 1509;
2856 -> 1501;
2857 -> 1652;
2858 -> 2857;
2858 -> 1521;
2859 -> 2858;
2859 -> 1523;
2859 -> 1521;
2860 -> 1519;
2860 -> 1553;
2860 -> 1648;
2860 -> 2859;
2860 -> 1657;
2860 -> 1547;
2860 -> 1548;
2860 -> 2845;
2860 -> 1555;
2860 -> 1552;
2861 -> 1672;
2862 -> 2861;
2862 -> 1567;
2863 -> 2862;
2863 -> 1569;
2863 -> 1567;
2864 -> 1565;
2864 -> 1599;
2864 -> 1668;
2864 -> 2863;
2864 -> 1677;
2864 -> 1593;
2864 -> 1594;
2864 -> 2849;
2864 -> 1601;
2864 -> 1598;
2865 -> 1613;
2866 -> 2865;
2866 -> 1434;
2867 -> 2866;
2867 -> 1436;
2867 -> 1434;
2868 -> 1632;
2869 -> 2868;
2869 -> 1472;
2870 -> 2869;
2870 -> 1474;
2870 -> 1472;
2871 -> 1470;
2871 -> 1502;
2871 -> 1628;
2871 -> 2870;
2871 -> 1637;
2871 -> 1498;
2871 -> 1499;
2871 -> 2856;
2871 -> 1509;
2871 -> 1501;
2872 -> 1652;
2873 -> 2872;
2873 -> 1521;
2874 -> 2873;
2874 -> 1523;
2874 -> 1521;
2875 -> 1519;
2875 -> 1553;
2875 -> 1648;
2875 -> 2874;
2875 -> 1657;
2875 -> 1547;
2875 -> 1548;
2875 -> 2860;
2875 -> 1555;
2875 -> 1552;
2876 -> 1672;
2877 -> 2876;
2877 -> 1567;
2878 -> 2877;
2878 -> 1569;
2878 -> 1567;
2879 -> 1565;
2879 -> 1599;
2879 -> 1668;
2879 -> 2878;
2879 -> 1677;
2879 -> 1593;
2879 -> 1594;
2879 -> 2864;
2879 -> 1601;
2879 -> 1598;
2880 -> 1613;
2881 -> 2880;
2881 -> 1434;
2882 -> 2881;
2882 -> 1436;
2882 -> 1434;
2883 -> 1632;
2884 -> 2883;
2884 -> 1472;
2885 -> 2884;
2885 -> 1474;
2885 -> 1472;
2886 -> 1470;
2886 -> 1502;
2886 -> 1628;
2886 -> 2885;
2886 -> 1637;
2886 -> 1498;
2886 -> 1499;
2886 -> 2871;
2886 -> 1509;
2886 -> 1501;
2887 -> 1652;
2888 -> 2887;
2888 -> 1521;
2889 -> 2888;
2889 -> 1523;
2889 -> 1521;
2890 -> 1519;
2890 -> 1553;
2890 -> 1648;
2890 -> 2889;
2890 -> 1657;
2890 -> 1547;
2890 -> 1548;
2890 -> 2875;
2890 -> 1555;
2890 -> 1552;
2891 -> 1672;
2892 -> 2891;
2892 -> 1567;
2893 -> 2892;
2893 -> 1569;
2893 -> 1567;
2894 -> 1565;
2894 -> 1599;
2894 -> 1668;
2894 -> 2893;
2894 -> 1677;
2894 -> 1593;
2894 -> 1594;
2894 -> 2879;
2894 -> 1601;
2894 -> 1598;
2895 -> 1613;
2896 -> 2895;
2896 -> 1434;
2897 -> 2896;
2897 -> 1436;
2897 -> 1434;
2898 -> 1632;
2899 -> 2898;
2899 -> 1472;
2900 -> 2899;
2900 -> 1474;
2900 -> 1472;
2901 -> 1470;
2901 -> 1502;
2901 -> 1628;
2901 -> 2900;
2901 -> 1637;
2901 -> 1498;
2901 -> 1499;
2901 -> 2886;
2901 -> 1509;
2901 -> 1501;
2902 -> 1652;
2903 -> 2902;
2903 -> 1521;
2904 -> 2903;
2904 -> 1523;
2904 -> 1521;
2905 -> 1519;
2905 -> 1553;
2905 -> 1648;
2905 -> 2904;
2905 -> 1657;
2905 -> 1547;
2905 -> 1548;
2905 -> 2890;
2905 -> 1555;
2905 -> 1552;
2906 -> 1672;
2907 -> 2906;
2907 -> 1567;
2908 -> 2907;
2908 -> 1569;
2908 -> 1567;
2909 -> 1565;
2909 -> 1599;
2909 -> 1668;
2909 -> 2908;
2909 -> 1677;
2909 -> 1593;
2909 -> 1594;
2909 -> 2894;
2909 -> 1601;
2909 -> 1598;
2910 -> 1613;
2911 -> 2910;
2911 -> 1434;
2912 -> 2911;
2912 -> 1436;
2912 -> 1434;
2913 -> 1632;
2914 -> 2913;
2914 -> 1472;
2915 -> 2914;
2915 -> 1474;
2915 -> 1472;
2916 -> 1470;
2916 -> 1502;
2916 -> 1628;
2916 -> 2915;
2916 -> 1637;
2916 -> 1498;
2916 -> 1499;
2916 -> 2901;
2916 -> 1509;
2916 -> 1501;
2917 -> 1652;
2918 -> 2917;
2918 -> 1521;
2919 -> 2918;
2919 -> 1523;
2919 -> 1521;
2920 -> 1519;
2920 -> 1553;
2920 -> 1648;
2920 -> 2919;
2920 -> 1657;
2920 -> 1547;
2920 -> 1548;
2920 -> 2905;
2920 -> 1555;
2920 -> 1552;
2921 -> 1672;
2922 -> 2921;
2922 -> 1567;
2923 -> 2922;
2923 -> 1569;
2923 -> 1567;
2924 -> 1565;
2924 -> 1599;
2924 -> 1668;
2924 -> 2923;
2924 -> 1677;
2924 -> 1593;
2924 -> 1594;
2924 -> 2909;
2924 -> 1601;
2924 -> 1598;
2925 -> 1613;
2926 -> 2925;
2926 -> 1434;
2927 -> 2926;
2927 -> 1436;
2927 -> 1434;
2928 -> 1632;
2929 -> 2928;
2929 -> 1472;
2930 -> 2929;
2930 -> 1474;
2930 -> 1472;
2931 -> 1470;
2931 -> 1502;
2931 -> 1628;
2931 -> 2930;
2931 -> 1637;
2931 -> 1498;
2931 -> 1499;
2931 -> 2916;
2931 -> 1509;
2931 -> 1501;
2932 -> 1652;
2933 -> 2932;
2933 -> 1521;
2934 -> 2933;
2934 -> 1523;
2934 -> 1521;
2935 -> 1519;
2935 -> 1553;
2935 -> 1648;
2935 -> 2934;
2935 -> 1657;
2935 -> 1547;
2935 -> 1548;
2935 -> 2920;
2935 -> 1555;
2935 -> 1552;
2936 -> 1672;
2937 -> 2936;
2937 -> 1567;
2938 -> 2937;
2938 -> 1569;
2938 -> 1567;
2939 -> 1565;
2939 -> 1599;
2939 -> 1668;
2939 -> 2938;
2939 -> 1677;
2939 -> 1593;
2939 -> 1594;
2939 -> 2924;
2939 -> 1601;
2939 -> 1598;
2940 -> 1613;
2941 -> 2940;
2941 -> 1434;
2942 -> 2941;
2942 -> 1436;
2942 -> 1434;
2943 -> 1632;
2944 -> 2943;
2944 -> 1472;
2945 -> 2944;
2945 -> 1474;
2945 -> 1472;
2946 -> 1470;
2946 -> 1502;
2946 -> 1628;
2946 -> 2945;
2946 -> 1637;
2946 -> 1498;
2946 -> 1499;
2946 -> 2931;
2946 -> 1509;
2946 -> 1501;
2947 -> 1652;
2948 -> 2947;
2948 -> 1521;
2949 -> 2948;
2949 -> 1523;
2949 -> 1521;
2950 -> 1519;
2950 -> 1553;
2950 -> 1648;
2950 -> 2949;
2950 -> 1657;
2950 -> 1547;
2950 -> 1548;
2950 -> 2935;
2950 -> 1555;
2950 -> 1552;
2951 -> 1672;
2952 -> 2951;
2952 -> 1567;
2953 -> 2952;
2953 -> 1569;
2953 -> 1567;
2954 -> 1565;
2954 -> 1599;
2954 -> 1668;
2954 -> 2953;
2954 -> 1677;
2954 -> 1593;
2954 -> 1594;
2954 -> 2939;
2954 -> 1601;
2954 -> 1598;
2955 -> 1613;
2956 -> 2955;
2956 -> 1434;
2957 -> 2956;
2957 -> 1436;
2957 -> 1434;
2958 -> 1632;
2959 -> 2958;
2959 -> 1472;
2960 -> 2959;
2960 -> 1474;
2960 -> 1472;
2961 -> 1470;
2961 -> 1502;
2961 -> 1628;
2961 -> 2960;
2961 -> 1637;
2961 -> 1498;
2961 -> 1499;
2961 -> 2946;
2961 -> 1509;
2961 -> 1501;
2962 -> 1652;
2963 -> 2962;
2963 -> 1521;
2964 -> 2963;
2964 -> 1523;
2964 -> 1521;
2965 -> 1519;
2965 -> 1553;
2965 -> 1648;
2965 -> 2964;
2965 -> 1657;
2965 -> 1547;
2965 -> 1548;
2965 -> 2950;
2965 -> 1555;
2965 -> 1552;
2966 -> 1672;
2967 -> 2966;
2967 -> 1567;
2968 -> 2967;
2968 -> 1569;
2968 -> 1567;
2969 -> 1565;
2969 -> 1599;
2969 -> 1668;
2969 -> 2968;
2969 -> 1677;
2969 -> 1593;
2969 -> 1594;
2969 -> 2954;
2969 -> 1601;
2969 -> 1598;
2970 -> 1613;
2971 -> 2970;
2971 -> 1434;
2972 -> 2971;
2972 -> 1436;
2972 -> 1434;
2973 -> 1632;
2974 -> 2973;
2974 -> 1472;
2975 -> 2974;
2975 -> 1474;
2975 -> 1472;
2976 -> 1470;
2976 -> 1502;
2976 -> 1628;
2976 -> 2975;
2976 -> 1637;
2976 -> 1498;
2976 -> 1499;
2976 -> 2961;
2976 -> 1509;
2976 -> 1501;
2977 -> 1652;
2978 -> 2977;
2978 -> 1521;
2979 -> 2978;
2979 -> 1523;
2979 -> 1521;
2980 -> 1519;
2980 -> 1553;
2980 -> 1648;
2980 -> 2979;
2980 -> 1657;
2980 -> 1547;
2980 -> 1548;
2980 -> 2965;
2980 -> 1555;
2980 -> 1552;
2981 -> 1672;
2982 -> 2981;
2982 -> 1567;
2983 -> 2982;
2983 -> 1569;
2983 -> 1567;
2984 -> 1565;
2984 -> 1599;
2984 -> 1668;
2984 -> 2983;
2984 -> 1677;
2984 -> 1593;
2984 -> 1594;
2984 -> 2969;
2984 -> 1601;
2984 -> 1598;
2985 -> 1613;
2986 -> 2985;
2986 -> 1434;
2987 -> 2986;
2987 -> 1436;
2987 -> 1434;
2988 -> 1632;
2989 -> 2988;
2989 -> 1472;
2990 -> 2989;
2990 -> 1474;
2990 -> 1472;
2991 -> 1470;
2991 -> 1502;
2991 -> 1628;
2991 -> 2990;
2991 -> 1637;
2991 -> 1498;
2991 -> 1499;
2991 -> 2976;
2991 -> 1509;
2991 -> 1501;
2992 -> 1652;
2993 -> 2992;
2993 -> 1521;
2994 -> 2993;
2994 -> 1523;
2994 -> 1521;
2995 -> 1519;
2995 -> 1553;
2995 -> 1648;
2995 -> 2994;
2995 -> 1657;
2995 -> 1547;
2995 -> 1548;
2995 -> 2980;
2995 -> 1555;
2995 -> 1552;
2996 -> 1672;
2997 -> 2996;
2997 -> 1567;
2998 -> 2997;
2998 -> 1569;
2998 -> 1567;
2999 -> 1565;
2999 -> 1599;
2999 -> 1668;
2999 -> 2998;
2999 -> 1677;
2999 -> 1593;
2999 -> 1594;
2999 -> 2984;
2999 -> 1601;
2999 -> 1598;
3000 -> 1613;
3001 -> 3000;
3001 -> 1434;
3002 -> 3001;
3002 -> 1436;
3002 -> 1434;
3003 -> 1632;
3004 -> 3003;
3004 -> 1472;
3005 -> 3004;
3005 -> 1474;
3005 -> 1472;
3006 -> 1470;
3006 -> 1502;
3006 -> 1628;
3006 -> 3005;
3006 -> 1637;
3006 -> 1498;
3006 -> 1499;
3006 -> 2991;
3006 -> 1509;
3006 -> 1501;
3007 -> 1652;
3008 -> 3007;
3008 -> 1521;
3009 -> 3008;
3009 -> 1523;
3009 -> 1521;
3010 -> 1519;
3010 -> 1553;
3010 -> 1648;
3010 -> 3009;
3010 -> 1657;
3010 -> 1547;
3010 -> 1548;
3010 -> 2995;
3010 -> 1555;
3010 -> 1552;
3011 -> 1672;
3012 -> 3011;
3012 -> 1567;
3013 -> 3012;
3013 -> 1569;
3013 -> 1567;
3014 -> 1565;
3014 -> 1599;
3014 -> 1668;
3014 -> 3013;
3014 -> 1677;
3014 -> 1593;
3014 -> 1594;
3014 -> 2999;
3014 -> 1601;
3014 -> 1598;
3015 -> 1613;
3016 -> 3015;
3016 -> 1434;
3017 -> 3016;
3017 -> 1436;
3017 -> 1434;
3018 -> 1632;
3019 -> 3018;
3019 -> 1472;
3020 -> 3019;
3020 -> 1474;
3020 -> 1472;
3021 -> 1470;
3021 -> 1502;
3021 -> 1628;
3021 -> 3020;
3021 -> 1637;
3021 -> 1498;
3021 -> 1499;
3021 -> 3006;
3021 -> 1509;
3021 -> 1501;
3022 -> 1652;
3023 -> 3022;
3023 -> 1521;
3024 -> 3023;
3024 -> 1523;
3024 -> 1521;
3025 -> 1519;
3025 -> 1553;
3025 -> 1648;
3025 -> 3024;
3025 -> 1657;
3025 -> 1547;
3025 -> 1548;
3025 -> 3010;
3025 -> 1555;
3025 -> 1552;
3026 -> 1672;
3027 -> 3026;
3027 -> 1567;
3028 -> 3027;
3028 -> 1569;
3028 -> 1567;
3029 -> 1565;
3029 -> 1599;
3029 -> 1668;
3029 -> 3028;
3029 -> 1677;
3029 -> 1593;
3029 -> 1594;
3029 -> 3014;
3029 -> 1601;
3029 -> 1598;
3030 -> 1613;
3031 -> 3030;
3031 -> 1434;
3032 -> 3031;
3032 -> 1436;
3032 -> 1434;
3033 -> 1632;
3034 -> 3033;
3034 -> 1472;
3035 -> 3034;
3035 -> 1474;
3035 -> 1472;
3036 -> 1470;
3036 -> 1502;
3036 -> 1628;
3036 -> 3035;
3036 -> 1637;
3036 -> 1498;
3036 -> 1499;
3036 -> 3021;
3036 -> 1509;
3036 -> 1501;
3037 -> 1652;
3038 -> 3037;
3038 -> 1521;
3039 -> 3038;
3039 -> 1523;
3039 -> 1521;
3040 -> 1519;
3040 -> 1553;
3040 -> 1648;
3040 -> 3039;
3040 -> 1657;
3040 -> 1547;
3040 -> 1548;
3040 -> 3025;
3040 -> 1555;
3040 -> 1552;
3041 -> 1672;
3042 -> 3041;
3042 -> 1567;
3043 -> 3042;
3043 -> 1569;
3043 -> 1567;
3044 -> 1565;
3044 -> 1599;
3044 -> 1668;
3044 -> 3043;
3044 -> 1677;
3044 -> 1593;
3044 -> 1594;
3044 -> 3029;
3044 -> 1601;
3044 -> 1598;
3045 -> 1613;
3046 -> 3045;
3046 -> 1434;
3047 -> 3046;
3047 -> 1436;
3047 -> 1434;
3048 -> 1632;
3049 -> 3048;
3049 -> 1472;
3050 -> 3049;
3050 -> 1474;
3050 -> 1472;
3051 -> 1470;
3051 -> 1502;
3051 -> 1628;
3051 -> 3050;
3051 -> 1637;
3051 -> 1498;
3051 -> 1499;
3051 -> 3036;
3051 -> 1509;
3051 -> 1501;
3052 -> 1652;
3053 -> 3052;
3053 -> 1521;
3054 -> 3053;
3054 -> 1523;
3054 -> 1521;
3055 -> 1519;
3055 -> 1553;
3055 -> 1648;
3055 -> 3054;
3055 -> 1657;
3055 -> 1547;
3055 -> 1548;
3055 -> 3040;
3055 -> 1555;
3055 -> 1552;
3056 -> 1672;
3057 -> 3056;
3057 -> 1567;
3058 -> 3057;
3058 -> 1569;
3058 -> 1567;
3059 -> 1565;
3059 -> 1599;
3059 -> 1668;
3059 -> 3058;
3059 -> 1677;
3059 -> 1593;
3059 -> 1594;
3059 -> 3044;
3059 -> 1601;
3059 -> 1598;
3060 -> 1613;
3061 -> 3060;
3061 -> 1434;
3062 -> 3061;
3062 -> 1436;
3062 -> 1434;
3063 -> 1632;
3064 -> 3063;
3064 -> 1472;
3065 -> 3064;
3065 -> 1474;
3065 -> 1472;
3066 -> 1470;
3066 -> 1502;
3066 -> 1628;
3066 -> 3065;
3066 -> 1637;
3066 -> 1498;
3066 -> 1499;
3066 -> 3051;
3066 -> 1509;
3066 -> 1501;
3067 -> 1652;
3068 -> 3067;
3068 -> 1521;
3069 -> 3068;
3069 -> 1523;
3069 -> 1521;
3070 -> 1519;
3070 -> 1553;
3070 -> 1648;
3070 -> 3069;
3070 -> 1657;
3070 -> 1547;
3070 -> 1548;
3070 -> 3055;
3070 -> 1555;
3070 -> 1552;
3071 -> 1672;
3072 -> 3071;
3072 -> 1567;
3073 -> 3072;
3073 -> 1569;
3073 -> 1567;
3074 -> 1565;
3074 -> 1599;
3074 -> 1668;
3074 -> 3073;
3074 -> 1677;
3074 -> 1593;
3074 -> 1594;
3074 -> 3059;
3074 -> 1601;
3074 -> 1598;
3075 -> 1613;
3076 -> 3075;
3076 -> 1434;
3077 -> 3076;
3077 -> 1436;
3077 -> 1434;
3078 -> 1632;
3079 -> 3078;
3079 -> 1472;
3080 -> 3079;
3080 -> 1474;
3080 -> 1472;
3081 -> 1470;
3081 -> 1502;
3081 -> 1628;
3081 -> 3080;
3081 -> 1637;
3081 -> 1498;
3081 -> 1499;
3081 -> 3066;
3081 -> 1509;
3081 -> 1501;
3082 -> 1652;
3083 -> 3082;
3083 -> 1521;
3084 -> 3083;
3084 -> 1523;
3084 -> 1521;
3085 -> 1519;
3085 -> 1553;
3085 -> 1648;
3085 -> 3084;
3085 -> 1657;
3085 -> 1547;
3085 -> 1548;
3085 -> 3070;
3085 -> 1555;
3085 -> 1552;
3086 -> 1672;
3087 -> 3086;
3087 -> 1567;
3088 -> 3087;
3088 -> 1569;
3088 -> 1567;
3089 -> 1565;
3089 -> 1599;
3089 -> 1668;
3089 -> 3088;
3089 -> 1677;
3089 -> 1593;
3089 -> 1594;
3089 -> 3074;
3089 -> 1601;
3089 -> 1598;
3090 -> 1613;
3091 -> 3090;
3091 -> 1434;
3092 -> 3091;
3092 -> 1436;
3092 -> 1434;
3093 -> 1632;
3094 -> 3093;
3094 -> 1472;
3095 -> 3094;
3095 -> 1474;
3095 -> 1472;
3096 -> 1470;
3096 -> 1502;
3096 -> 1628;
3096 -> 3095;
3096 -> 1637;
3096 -> 1498;
3096 -> 1499;
3096 -> 3081;
3096 -> 1509;
3096 -> 1501;
3097 -> 1652;
3098 -> 3097;
3098 -> 1521;
3099 -> 3098;
3099 -> 1523;
3099 -> 1521;
3100 -> 1519;
3100 -> 1553;
3100 -> 1648;
3100 -> 3099;
3100 -> 1657;
3100 -> 1547;
3100 -> 1548;
3100 -> 3085;
3100 -> 1555;
3100 -> 1552;
3101 -> 1672;
3102 -> 3101;
3102 -> 1567;
3103 -> 3102;
3103 -> 1569;
3103 -> 1567;
3104 -> 1565;
3104 -> 1599;
3104 -> 1668;
3104 -> 3103;
3104 -> 1677;
3104 -> 1593;
3104 -> 1594;
3104 -> 3089;
3104 -> 1601;
3104 -> 1598;
3105 -> 1613;
3106 -> 3105;
3106 -> 1434;
3107 -> 3106;
3107 -> 1436;
3107 -> 1434;
3108 -> 1632;
3109 -> 3108;
3109 -> 1472;
3110 -> 3109;
3110 -> 1474;
3110 -> 1472;
3111 -> 1470;
3111 -> 1502;
3111 -> 1628;
3111 -> 3110;
3111 -> 1637;
3111 -> 1498;
3111 -> 1499;
3111 -> 3096;
3111 -> 1509;
3111 -> 1501;
3112 -> 1652;
3113 -> 3112;
3113 -> 1521;
3114 -> 3113;
3114 -> 1523;
3114 -> 1521;
3115 -> 1519;
3115 -> 1553;
3115 -> 1648;
3115 -> 3114;
3115 -> 1657;
3115 -> 1547;
3115 -> 1548;
3115 -> 3100;
3115 -> 1555;
3115 -> 1552;
3116 -> 1672;
3117 -> 3116;
3117 -> 1567;
3118 -> 3117;
3118 -> 1569;
3118 -> 1567;
3119 -> 1565;
3119 -> 1599;
3119 -> 1668;
3119 -> 3118;
3119 -> 1677;
3119 -> 1593;
3119 -> 1594;
3119 -> 3104;
3119 -> 1601;
3119 -> 1598;
3120 -> 1613;
3121 -> 3120;
3121 -> 1434;
3122 -> 3121;
3122 -> 1436;
3122 -> 1434;
3123 -> 1632;
3124 -> 3123;
3124 -> 1472;
3125 -> 3124;
3125 -> 1474;
3125 -> 1472;
3126 -> 1470;
3126 -> 1502;
3126 -> 1628;
3126 -> 3125;
3126 -> 1637;
3126 -> 1498;
3126 -> 1499;
3126 -> 3111;
3126 -> 1509;
3126 -> 1501;
3127 -> 1652;
3128 -> 3127;
3128 -> 1521;
3129 -> 3128;
3129 -> 1523;
3129 -> 1521;
3130 -> 1519;
3130 -> 1553;
3130 -> 1648;
3130 -> 3129;
3130 -> 1657;
3130 -> 1547;
3130 -> 1548;
3130 -> 3115;
3130 -> 1555;
3130 -> 1552;
3131 -> 1672;
3132 -> 3131;
3132 -> 1567;
3133 -> 3132;
3133 -> 1569;
3133 -> 1567;
3134 -> 1565;
3134 -> 1599;
3134 -> 1668;
3134 -> 3133;
3134 -> 1677;
3134 -> 1593;
3134 -> 1594;
3134 -> 3119;
3134 -> 1601;
3134 -> 1598;
3135 -> 1613;
3136 -> 3135;
3136 -> 1434;
3137 -> 3136;
3137 -> 1436;
3137 -> 1434;
3138 -> 1632;
3139 -> 3138;
3139 -> 1472;
3140 -> 3139;
3140 -> 1474;
3140 -> 1472;
3141 -> 1470;
3141 -> 1502;
3141 -> 1628;
3141 -> 3140;
3141 -> 1637;
3141 -> 1498;
3141 -> 1499;
3141 -> 3126;
3141 -> 1509;
3141 -> 1501;
3142 -> 1652;
3143 -> 3142;
3143 -> 1521;
3144 -> 3143;
3144 -> 1523;
3144 -> 1521;
3145 -> 1519;
3145 -> 1553;
3145 -> 1648;
3145 -> 3144;
3145 -> 1657;
3145 -> 1547;
3145 -> 1548;
3145 -> 3130;
3145 -> 1555;
3145 -> 1552;
3146 -> 1672;
3147 -> 3146;
3147 -> 1567;
3148 -> 3147;
3148 -> 1569;
3148 -> 1567;
3149 -> 1565;
3149 -> 1599;
3149 -> 1668;
3149 -> 3148;
3149 -> 1677;
3149 -> 1593;
3149 -> 1594;
3149 -> 3134;
3149 -> 1601;
3149 -> 1598;
3150 -> 1613;
3151 -> 3150;
3151 -> 1434;
3152 -> 3151;
3152 -> 1436;
3152 -> 1434;
3153 -> 1632;
3154 -> 3153;
3154 -> 1472;
3155 -> 3154;
3155 -> 1474;
3155 -> 1472;
3156 -> 1470;
3156 -> 1502;
3156 -> 1628;
3156 -> 3155;
3156 -> 1637;
3156 -> 1498;
3156 -> 1499;
3156 -> 3141;
3156 -> 1509;
3156 -> 1501;
3157 -> 1652;
3158 -> 3157;
3158 -> 1521;
3159 -> 3158;
3159 -> 1523;
3159 -> 1521;
3160 -> 1519;
3160 -> 1553;
3160 -> 1648;
3160 -> 3159;
3160 -> 1657;
3160 -> 1547;
3160 -> 1548;
3160 -> 3145;
3160 -> 1555;
3160 -> 1552;
3161 -> 1672;
3162 -> 3161;
3162 -> 1567;
3163 -> 3162;
3163 -> 1569;
3163 -> 1567;
3164 -> 1565;
3164 -> 1599;
3164 -> 1668;
3164 -> 3163;
3164 -> 1677;
3164 -> 1593;
3164 -> 1594;
3164 -> 3149;
3164 -> 1601;
3164 -> 1598;
3165 -> 1613;
3166 -> 3165;
3166 -> 1434;
3167 -> 3166;
3167 -> 1436;
3167 -> 1434;
3168 -> 1632;
3169 -> 3168;
3169 -> 1472;
3170 -> 3169;
3170 -> 1474;
3170 -> 1472;
3171 -> 1470;
3171 -> 1502;
3171 -> 1628;
3171 -> 3170;
3171 -> 1637;
3171 -> 1498;
3171 -> 1499;
3171 -> 3156;
3171 -> 1509;
3171 -> 1501;
3172 -> 1652;
3173 -> 3172;
3173 -> 1521;
3174 -> 3173;
3174 -> 1523;
3174 -> 1521;
3175 -> 1519;
3175 -> 1553;
3175 -> 1648;
3175 -> 3174;
3175 -> 1657;
3175 -> 1547;
3175 -> 1548;
3175 -> 3160;
3175 -> 1555;
3175 -> 1552;
3176 -> 1672;
3177 -> 3176;
3177 -> 1567;
3178 -> 3177;
3178 -> 1569;
3178 -> 1567;
3179 -> 1565;
3179 -> 1599;
3179 -> 1668;
3179 -> 3178;
3179 -> 1677;
3179 -> 1593;
3179 -> 1594;
3179 -> 3164;
3179 -> 1601;
3179 -> 1598;
3180 -> 1613;
3181 -> 3180;
3181 -> 1434;
3182 -> 3181;
3182 -> 1436;
3182 -> 1434;
3183 -> 1632;
3184 -> 3183;
3184 -> 1472;
3185 -> 3184;
3185 -> 1474;
3185 -> 1472;
3186 -> 1470;
3186 -> 1502;
3186 -> 1628;
3186 -> 3185;
3186 -> 1637;
3186 -> 1498;
3186 -> 1499;
3186 -> 3171;
3186 -> 1509;
3186 -> 1501;
3187 -> 1652;
3188 -> 3187;
3188 -> 1521;
3189 -> 3188;
3189 -> 1523;
3189 -> 1521;
3190 -> 1519;
3190 -> 1553;
3190 -> 1648;
3190 -> 3189;
3190 -> 1657;
3190 -> 1547;
3190 -> 1548;
3190 -> 3175;
3190 -> 1555;
3190 -> 1552;
3191 -> 1672;
3192 -> 3191;
3192 -> 1567;
3193 -> 3192;
3193 -> 1569;
3193 -> 1567;
3194 -> 1565;
3194 -> 1599;
3194 -> 1668;
3194 -> 3193;
3194 -> 1677;
3194 -> 1593;
3194 -> 1594;
3194 -> 3179;
3194 -> 1601;
3194 -> 1598;
3195 -> 1613;
3196 -> 3195;
3196 -> 1434;
3197 -> 3196;
3197 -> 1436;
3197 -> 1434;
3198 -> 1632;
3199 -> 3198;
3199 -> 1472;
3200 -> 3199;
3200 -> 1474;
3200 -> 1472;
3201 -> 1470;
3201 -> 1502;
3201 -> 1628;
3201 -> 3200;
3201 -> 1637;
3201 -> 1498;
3201 -> 1499;
3201 -> 3186;
3201 -> 1509;
3201 -> 1501;
3202 -> 1652;
3203 -> 3202;
3203 -> 1521;
3204 -> 3203;
3204 -> 1523;
3204 -> 1521;
3205 -> 1519;
3205 -> 1553;
3205 -> 1648;
3205 -> 3204;
3205 -> 1657;
3205 -> 1547;
3205 -> 1548;
3205 -> 3190;
3205 -> 1555;
3205 -> 1552;
3206 -> 1672;
3207 -> 3206;
3207 -> 1567;
3208 -> 3207;
3208 -> 1569;
3208 -> 1567;
3209 -> 1565;
3209 -> 1599;
3209 -> 1668;
3209 -> 3208;
3209 -> 1677;
3209 -> 1593;
3209 -> 1594;
3209 -> 3194;
3209 -> 1601;
3209 -> 1598;
3210 -> 1613;
3211 -> 3210;
3211 -> 1434;
3212 -> 3211;
3212 -> 1436;
3212 -> 1434;
3213 -> 1632;
3214 -> 3213;
3214 -> 1472;
3215 -> 3214;
3215 -> 1474;
3215 -> 1472;
3216 -> 1470;
3216 -> 1502;
3216 -> 1628;
3216 -> 3215;
3216 -> 1637;
3216 -> 1498;
3216 -> 1499;
3216 -> 3201;
3216 -> 1509;
3216 -> 1501;
3217 -> 1652;
3218 -> 3217;
3218 -> 1521;
3219 -> 3218;
3219 -> 1523;
3219 -> 1521;
3220 -> 1519;
3220 -> 1553;
3220 -> 1648;
3220 -> 3219;
3220 -> 1657;
3220 -> 1547;
3220 -> 1548;
3220 -> 3205;
3220 -> 1555;
3220 -> 1552;
3221 -> 1672;
3222 -> 3221;
3222 -> 1567;
3223 -> 3222;
3223 -> 1569;
3223 -> 1567;
3224 -> 1565;
3224 -> 1599;
3224 -> 1668;
3224 -> 3223;
3224 -> 1677;
3224 -> 1593;
3224 -> 1594;
3224 -> 3209;
3224 -> 1601;
3224 -> 1598;
3225 -> 1613;
3226 -> 3225;
3226 -> 1434;
3227 -> 3226;
3227 -> 1436;
3227 -> 1434;
3228 -> 1632;
3229 -> 3228;
3229 -> 1472;
3230 -> 3229;
3230 -> 1474;
3230 -> 1472;
3231 -> 1470;
3231 -> 1502;
3231 -> 1628;
3231 -> 3230;
3231 -> 1637;
3231 -> 1498;
3231 -> 1499;
3231 -> 3216;
3231 -> 1509;
3231 -> 1501;
3232 -> 1652;
3233 -> 3232;
3233 -> 1521;
3234 -> 3233;
3234 -> 1523;
3234 -> 1521;
3235 -> 1519;
3235 -> 1553;
3235 -> 1648;
3235 -> 3234;
3235 -> 1657;
3235 -> 1547;
3235 -> 1548;
3235 -> 3220;
3235 -> 1555;
3235 -> 1552;
3236 -> 1672;
3237 -> 3236;
3237 -> 1567;
3238 -> 3237;
3238 -> 1569;
3238 -> 1567;
3239 -> 1565;
3239 -> 1599;
3239 -> 1668;
3239 -> 3238;
3239 -> 1677;
3239 -> 1593;
3239 -> 1594;
3239 -> 3224;
3239 -> 1601;
3239 -> 1598;
3240 -> 1613;
3241 -> 3240;
3241 -> 1434;
3242 -> 3241;
3242 -> 1436;
3242 -> 1434;
3243 -> 1632;
3244 -> 3243;
3244 -> 1472;
3245 -> 3244;
3245 -> 1474;
3245 -> 1472;
3246 -> 1470;
3246 -> 1502;
3246 -> 1628;
3246 -> 3245;
3246 -> 1637;
3246 -> 1498;
3246 -> 1499;
3246 -> 3231;
3246 -> 1509;
3246 -> 1501;
3247 -> 1652;
3248 -> 3247;
3248 -> 1521;
3249 -> 3248;
3249 -> 1523;
3249 -> 1521;
3250 -> 1519;
3250 -> 1553;
3250 -> 1648;
3250 -> 3249;
3250 -> 1657;
3250 -> 1547;
3250 -> 1548;
3250 -> 3235;
3250 -> 1555;
3250 -> 1552;
3251 -> 1672;
3252 -> 3251;
3252 -> 1567;
3253 -> 3252;
3253 -> 1569;
3253 -> 1567;
3254 -> 1565;
3254 -> 1599;
3254 -> 1668;
3254 -> 3253;
3254 -> 1677;
3254 -> 1593;
3254 -> 1594;
3254 -> 3239;
3254 -> 1601;
3254 -> 1598;
3255 -> 1613;
3256 -> 3255;
3256 -> 1434;
3257 -> 3256;
3257 -> 1436;
3257 -> 1434;
3258 -> 1632;
3259 -> 3258;
3259 -> 1472;
3260 -> 3259;
3260 -> 1474;
3260 -> 1472;
3261 -> 1470;
3261 -> 1502;
3261 -> 1628;
3261 -> 3260;
3261 -> 1637;
3261 -> 1498;
3261 -> 1499;
3261 -> 3246;
3261 -> 1509;
3261 -> 1501;
3262 -> 1652;
3263 -> 3262;
3263 -> 1521;
3264 -> 3263;
3264 -> 1523;
3264 -> 1521;
3265 -> 1519;
3265 -> 1553;
3265 -> 1648;
3265 -> 3264;
3265 -> 1657;
3265 -> 1547;
3265 -> 1548;
3265 -> 3250;
3265 -> 1555;
3265 -> 1552;
3266 -> 1672;
3267 -> 3266;
3267 -> 1567;
3268 -> 3267;
3268 -> 1569;
3268 -> 1567;
3269 -> 1565;
3269 -> 1599;
3269 -> 1668;
3269 -> 3268;
3269 -> 1677;
3269 -> 1593;
3269 -> 1594;
3269 -> 3254;
3269 -> 1601;
3269 -> 1598;
3270 -> 1613;
3271 -> 3270;
3271 -> 1434;
3272 -> 3271;
3272 -> 1436;
3272 -> 1434;
3273 -> 1632;
3274 -> 3273;
3274 -> 1472;
3275 -> 3274;
3275 -> 1474;
3275 -> 1472;
3276 -> 1470;
3276 -> 1502;
3276 -> 1628;
3276 -> 3275;
3276 -> 1637;
3276 -> 1498;
3276 -> 1499;
3276 -> 3261;
3276 -> 1509;
3276 -> 1501;
3277 -> 1652;
3278 -> 3277;
3278 -> 1521;
3279 -> 3278;
3279 -> 1523;
3279 -> 1521;
3280 -> 1519;
3280 -> 1553;
3280 -> 1648;
3280 -> 3279;
3280 -> 1657;
3280 -> 1547;
3280 -> 1548;
3280 -> 3265;
3280 -> 1555;
3280 -> 1552;
3281 -> 1672;
3282 -> 3281;
3282 -> 1567;
3283 -> 3282;
3283 -> 1569;
3283 -> 1567;
3284 -> 1565;
3284 -> 1599;
3284 -> 1668;
3284 -> 3283;
3284 -> 1677;
3284 -> 1593;
3284 -> 1594;
3284 -> 3269;
3284 -> 1601;
3284 -> 1598;
3285 -> 1613;
3286 -> 3285;
3286 -> 1434;
3287 -> 3286;
3287 -> 1436;
3287 -> 1434;
3288 -> 1632;
3289 -> 3288;
3289 -> 1472;
3290 -> 3289;
3290 -> 1474;
3290 -> 1472;
3291 -> 1470;
3291 -> 1502;
3291 -> 1628;
3291 -> 3290;
3291 -> 1637;
3291 -> 1498;
3291 -> 1499;
3291 -> 3276;
3291 -> 1509;
3291 -> 1501;
3292 -> 1652;
3293 -> 3292;
3293 -> 1521;
3294 -> 3293;
3294 -> 1523;
3294 -> 1521;
3295 -> 1519;
3295 -> 1553;
3295 -> 1648;
3295 -> 3294;
3295 -> 1657;
3295 -> 1547;
3295 -> 1548;
3295 -> 3280;
3295 -> 1555;
3295 -> 1552;
3296 -> 1672;
3297 -> 3296;
3297 -> 1567;
3298 -> 3297;
3298 -> 1569;
3298 -> 1567;
3299 -> 1565;
3299 -> 1599;
3299 -> 1668;
3299 -> 3298;
3299 -> 1677;
3299 -> 1593;
3299 -> 1594;
3299 -> 3284;
3299 -> 1601;
3299 -> 1598;
3300 -> 1613;
3301 -> 3300;
3301 -> 1434;
3302 -> 3301;
3302 -> 1436;
3302 -> 1434;
3303 -> 1632;
3304 -> 3303;
3304 -> 1472;
3305 -> 3304;
3305 -> 1474;
3305 -> 1472;
3306 -> 1470;
3306 -> 1502;
3306 -> 1628;
3306 -> 3305;
3306 -> 1637;
3306 -> 1498;
3306 -> 1499;
3306 -> 3291;
3306 -> 1509;
3306 -> 1501;
3307 -> 1652;
3308 -> 3307;
3308 -> 1521;
3309 -> 3308;
3309 -> 1523;
3309 -> 1521;
3310 -> 1519;
3310 -> 1553;
3310 -> 1648;
3310 -> 3309;
3310 -> 1657;
3310 -> 1547;
3310 -> 1548;
3310 -> 3295;
3310 -> 1555;
3310 -> 1552;
3311 -> 1672;
3312 -> 3311;
3312 -> 1567;
3313 -> 3312;
3313 -> 1569;
3313 -> 1567;
3314 -> 1565;
3314 -> 1599;
3314 -> 1668;
3314 -> 3313;
3314 -> 1677;
3314 -> 1593;
3314 -> 1594;
3314 -> 3299;
3314 -> 1601;
3314 -> 1598;
3315 -> 1613;
3316 -> 3315;
3316 -> 1434;
3317 -> 3316;
3317 -> 1436;
3317 -> 1434;
3318 -> 1632;
3319 -> 3318;
3319 -> 1472;
3320 -> 3319;
3320 -> 1474;
3320 -> 1472;
3321 -> 1470;
3321 -> 1502;
3321 -> 1628;
3321 -> 3320;
3321 -> 1637;
3321 -> 1498;
3321 -> 1499;
3321 -> 3306;
3321 -> 1509;
3321 -> 1501;
3322 -> 1652;
3323 -> 3322;
3323 -> 1521;
3324 -> 3323;
3324 -> 1523;
3324 -> 1521;
3325 -> 1519;
3325 -> 1553;
3325 -> 1648;
3325 -> 3324;
3325 -> 1657;
3325 -> 1547;
3325 -> 1548;
3325 -> 3310;
3325 -> 1555;
3325 -> 1552;
3326 -> 1672;
3327 -> 3326;
3327 -> 1567;
3328 -> 3327;
3328 -> 1569;
3328 -> 1567;
3329 -> 1565;
3329 -> 1599;
3329 -> 1668;
3329 -> 3328;
3329 -> 1677;
3329 -> 1593;
3329 -> 1594;
3329 -> 3314;
3329 -> 1601;
3329 -> 1598;
3330 -> 1613;
3331 -> 3330;
3331 -> 1434;
3332 -> 3331;
3332 -> 1436;
3332 -> 1434;
3333 -> 1632;
3334 -> 3333;
3334 -> 1472;
3335 -> 3334;
3335 -> 1474;
3335 -> 1472;
3336 -> 1470;
3336 -> 1502;
3336 -> 1628;
3336 -> 3335;
3336 -> 1637;
3336 -> 1498;
3336 -> 1499;
3336 -> 3321;
3336 -> 1509;
3336 -> 1501;
3337 -> 1652;
3338 -> 3337;
3338 -> 1521;
3339 -> 3338;
3339 -> 1523;
3339 -> 1521;
3340 -> 1519;
3340 -> 1553;
3340 -> 1648;
3340 -> 3339;
3340 -> 1657;
3340 -> 1547;
3340 -> 1548;
3340 -> 3325;
3340 -> 1555;
3340 -> 1552;
3341 -> 1672;
3342 -> 3341;
3342 -> 1567;
3343 -> 3342;
3343 -> 1569;
3343 -> 1567;
3344 -> 1565;
3344 -> 1599;
3344 -> 1668;
3344 -> 3343;
3344 -> 1677;
3344 -> 1593;
3344 -> 1594;
3344 -> 3329;
3344 -> 1601;
3344 -> 1598;
3345 -> 1613;
3346 -> 3345;
3346 -> 1434;
3347 -> 3346;
3347 -> 1436;
3347 -> 1434;
3348 -> 1632;
3349 -> 3348;
3349 -> 1472;
3350 -> 3349;
3350 -> 1474;
3350 -> 1472;
3351 -> 1470;
3351 -> 1502;
3351 -> 1628;
3351 -> 3350;
3351 -> 1637;
3351 -> 1498;
3351 -> 1499;
3351 -> 3336;
3351 -> 1509;
3351 -> 1501;
3352 -> 1652;
3353 -> 3352;
3353 -> 1521;
3354 -> 3353;
3354 -> 1523;
3354 -> 1521;
3355 -> 1519;
3355 -> 1553;
3355 -> 1648;
3355 -> 3354;
3355 -> 1657;
3355 -> 1547;
3355 -> 1548;
3355 -> 3340;
3355 -> 1555;
3355 -> 1552;
3356 -> 1672;
3357 -> 3356;
3357 -> 1567;
3358 -> 3357;
3358 -> 1569;
3358 -> 1567;
3359 -> 1565;
3359 -> 1599;
3359 -> 1668;
3359 -> 3358;
3359 -> 1677;
3359 -> 1593;
3359 -> 1594;
3359 -> 3344;
3359 -> 1601;
3359 -> 1598;
3360 -> 1613;
3361 -> 3360;
3361 -> 1434;
3362 -> 3361;
3362 -> 1436;
3362 -> 1434;
3363 -> 1632;
3364 -> 3363;
3364 -> 1472;
3365 -> 3364;
3365 -> 1474;
3365 -> 1472;
3366 -> 1470;
3366 -> 1502;
3366 -> 1628;
3366 -> 3365;
3366 -> 1637;
3366 -> 1498;
3366 -> 1499;
3366 -> 3351;
3366 -> 1509;
3366 -> 1501;
3367 -> 1652;
3368 -> 3367;
3368 -> 1521;
3369 -> 3368;
3369 -> 1523;
3369 -> 1521;
3370 -> 1519;
3370 -> 1553;
3370 -> 1648;
3370 -> 3369;
3370 -> 1657;
3370 -> 1547;
3370 -> 1548;
3370 -> 3355;
3370 -> 1555;
3370 -> 1552;
3371 -> 1672;
3372 -> 3371;
3372 -> 1567;
3373 -> 3372;
3373 -> 1569;
3373 -> 1567;
3374 -> 1565;
3374 -> 1599;
3374 -> 1668;
3374 -> 3373;
3374 -> 1677;
3374 -> 1593;
3374 -> 1594;
3374 -> 3359;
3374 -> 1601;
3374 -> 1598;
3375 -> 1613;
3376 -> 3375;
3376 -> 1434;
3377 -> 3376;
3377 -> 1436;
3377 -> 1434;
3378 -> 1632;
3379 -> 3378;
3379 -> 1472;
3380 -> 3379;
3380 -> 1474;
3380 -> 1472;
3381 -> 1470;
3381 -> 1502;
3381 -> 1628;
3381 -> 3380;
3381 -> 1637;
3381 -> 1498;
3381 -> 1499;
3381 -> 3366;
3381 -> 1509;
3381 -> 1501;
3382 -> 1652;
3383 -> 3382;
3383 -> 1521;
3384 -> 3383;
3384 -> 1523;
3384 -> 1521;
3385 -> 1519;
3385 -> 1553;
3385 -> 1648;
3385 -> 3384;
3385 -> 1657;
3385 -> 1547;
3385 -> 1548;
3385 -> 3370;
3385 -> 1555;
3385 -> 1552;
3386 -> 1672;
3387 -> 3386;
3387 -> 1567;
3388 -> 3387;
3388 -> 1569;
3388 -> 1567;
3389 -> 1565;
3389 -> 1599;
3389 -> 1668;
3389 -> 3388;
3389 -> 1677;
3389 -> 1593;
3389 -> 1594;
3389 -> 3374;
3389 -> 1601;
3389 -> 1598;
3390 -> 1613;
3391 -> 3390;
3391 -> 1434;
3392 -> 3391;
3392 -> 1436;
3392 -> 1434;
3393 -> 1632;
3394 -> 3393;
3394 -> 1472;
3395 -> 3394;
3395 -> 1474;
3395 -> 1472;
3396 -> 1470;
3396 -> 1502;
3396 -> 1628;
3396 -> 3395;
3396 -> 1637;
3396 -> 1498;
3396 -> 1499;
3396 -> 3381;
3396 -> 1509;
3396 -> 1501;
3397 -> 1652;
3398 -> 3397;
3398 -> 1521;
3399 -> 3398;
3399 -> 1523;
3399 -> 1521;
3400 -> 1519;
3400 -> 1553;
3400 -> 1648;
3400 -> 3399;
3400 -> 1657;
3400 -> 1547;
3400 -> 1548;
3400 -> 3385;
3400 -> 1555;
3400 -> 1552;
3401 -> 1672;
3402 -> 3401;
3402 -> 1567;
3403 -> 3402;
3403 -> 1569;
3403 -> 1567;
3404 -> 1565;
3404 -> 1599;
3404 -> 1668;
3404 -> 3403;
3404 -> 1677;
3404 -> 1593;
3404 -> 1594;
3404 -> 3389;
3404 -> 1601;
3404 -> 1598;
3405 -> 1613;
3406 -> 3405;
3406 -> 1434;
3407 -> 3406;
3407 -> 1436;
3407 -> 1434;
3408 -> 1632;
3409 -> 3408;
3409 -> 1472;
3410 -> 3409;
3410 -> 1474;
3410 -> 1472;
3411 -> 1470;
3411 -> 1502;
3411 -> 1628;
3411 -> 3410;
3411 -> 1637;
3411 -> 1498;
3411 -> 1499;
3411 -> 3396;
3411 -> 1509;
3411 -> 1501;
3412 -> 1652;
3413 -> 3412;
3413 -> 1521;
3414 -> 3413;
3414 -> 1523;
3414 -> 1521;
3415 -> 1519;
3415 -> 1553;
3415 -> 1648;
3415 -> 3414;
3415 -> 1657;
3415 -> 1547;
3415 -> 1548;
3415 -> 3400;
3415 -> 1555;
3415 -> 1552;
3416 -> 1672;
3417 -> 3416;
3417 -> 1567;
3418 -> 3417;
3418 -> 1569;
3418 -> 1567;
3419 -> 1565;
3419 -> 1599;
3419 -> 1668;
3419 -> 3418;
3419 -> 1677;
3419 -> 1593;
3419 -> 1594;
3419 -> 3404;
3419 -> 1601;
3419 -> 1598;
3420 -> 1613;
3421 -> 3420;
3421 -> 1434;
3422 -> 3421;
3422 -> 1436;
3422 -> 1434;
3423 -> 1632;
3424 -> 3423;
3424 -> 1472;
3425 -> 3424;
3425 -> 1474;
3425 -> 1472;
3426 -> 1470;
3426 -> 1502;
3426 -> 1628;
3426 -> 3425;
3426 -> 1637;
3426 -> 1498;
3426 -> 1499;
3426 -> 3411;
3426 -> 1509;
3426 -> 1501;
3427 -> 1652;
3428 -> 3427;
3428 -> 1521;
3429 -> 3428;
3429 -> 1523;
3429 -> 1521;
3430 -> 1519;
3430 -> 1553;
3430 -> 1648;
3430 -> 3429;
3430 -> 1657;
3430 -> 1547;
3430 -> 1548;
3430 -> 3415;
3430 -> 1555;
3430 -> 1552;
3431 -> 1672;
3432 -> 3431;
3432 -> 1567;
3433 -> 3432;
3433 -> 1569;
3433 -> 1567;
3434 -> 1565;
3434 -> 1599;
3434 -> 1668;
3434 -> 3433;
3434 -> 1677;
3434 -> 1593;
3434 -> 1594;
3434 -> 3419;
3434 -> 1601;
3434 -> 1598;
3435 -> 1613;
3436 -> 3435;
3436 -> 1434;
3437 -> 3436;
3437 -> 1436;
3437 -> 1434;
3438 -> 1632;
3439 -> 3438;
3439 -> 1472;
3440 -> 3439;
3440 -> 1474;
3440 -> 1472;
3441 -> 1470;
3441 -> 1502;
3441 -> 1628;
3441 -> 3440;
3441 -> 1637;
3441 -> 1498;
3441 -> 1499;
3441 -> 3426;
3441 -> 1509;
3441 -> 1501;
3442 -> 1652;
3443 -> 3442;
3443 -> 1521;
3444 -> 3443;
3444 -> 1523;
3444 -> 1521;
3445 -> 1519;
3445 -> 1553;
3445 -> 1648;
3445 -> 3444;
3445 -> 1657;
3445 -> 1547;
3445 -> 1548;
3445 -> 3430;
3445 -> 1555;
3445 -> 1552;
3446 -> 1672;
3447 -> 3446;
3447 -> 1567;
3448 -> 3447;
3448 -> 1569;
3448 -> 1567;
3449 -> 1565;
3449 -> 1599;
3449 -> 1668;
3449 -> 3448;
3449 -> 1677;
3449 -> 1593;
3449 -> 1594;
3449 -> 3434;
3449 -> 1601;
3449 -> 1598;
3450 -> 1613;
3451 -> 3450;
3451 -> 1434;
3452 -> 3451;
3452 -> 1436;
3452 -> 1434;
3453 -> 1632;
3454 -> 3453;
3454 -> 1472;
3455 -> 3454;
3455 -> 1474;
3455 -> 1472;
3456 -> 1470;
3456 -> 1502;
3456 -> 1628;
3456 -> 3455;
3456 -> 1637;
3456 -> 1498;
3456 -> 1499;
3456 -> 3441;
3456 -> 1509;
3456 -> 1501;
3457 -> 1652;
3458 -> 3457;
3458 -> 1521;
3459 -> 3458;
3459 -> 1523;
3459 -> 1521;
3460 -> 1519;
3460 -> 1553;
3460 -> 1648;
3460 -> 3459;
3460 -> 1657;
3460 -> 1547;
3460 -> 1548;
3460 -> 3445;
3460 -> 1555;
3460 -> 1552;
3461 -> 1672;
3462 -> 3461;
3462 -> 1567;
3463 -> 3462;
3463 -> 1569;
3463 -> 1567;
3464 -> 1565;
3464 -> 1599;
3464 -> 1668;
3464 -> 3463;
3464 -> 1677;
3464 -> 1593;
3464 -> 1594;
3464 -> 3449;
3464 -> 1601;
3464 -> 1598;
3465 -> 1613;
3466 -> 3465;
3466 -> 1434;
3467 -> 3466;
3467 -> 1436;
3467 -> 1434;
3468 -> 1632;
3469 -> 3468;
3469 -> 1472;
3470 -> 3469;
3470 -> 1474;
3470 -> 1472;
3471 -> 1470;
3471 -> 1502;
3471 -> 1628;
3471 -> 3470;
3471 -> 1637;
3471 -> 1498;
3471 -> 1499;
3471 -> 3456;
3471 -> 1509;
3471 -> 1501;
3472 -> 1652;
3473 -> 3472;
3473 -> 1521;
3474 -> 3473;
3474 -> 1523;
3474 -> 1521;
3475 -> 1519;
3475 -> 1553;
3475 -> 1648;
3475 -> 3474;
3475 -> 1657;
3475 -> 1547;
3475 -> 1548;
3475 -> 3460;
3475 -> 1555;
3475 -> 1552;
3476 -> 1672;
3477 -> 3476;
3477 -> 1567;
3478 -> 3477;
3478 -> 1569;
3478 -> 1567;
3479 -> 1565;
3479 -> 1599;
3479 -> 1668;
3479 -> 3478;
3479 -> 1677;
3479 -> 1593;
3479 -> 1594;
3479 -> 3464;
3479 -> 1601;
3479 -> 1598;
3480 -> 1613;
3481 -> 3480;
3481 -> 1434;
3482 -> 3481;
3482 -> 1436;
3482 -> 1434;
3483 -> 1632;
3484 -> 3483;
3484 -> 1472;
3485 -> 3484;
3485 -> 1474;
3485 -> 1472;
3486 -> 1470;
3486 -> 1502;
3486 -> 1628;
3486 -> 3485;
3486 -> 1637;
3486 -> 1498;
3486 -> 1499;
3486 -> 3471;
3486 -> 1509;
3486 -> 1501;
3487 -> 1652;
3488 -> 3487;
3488 -> 1521;
3489 -> 3488;
3489 -> 1523;
3489 -> 1521;
3490 -> 1519;
3490 -> 1553;
3490 -> 1648;
3490 -> 3489;
3490 -> 1657;
3490 -> 1547;
3490 -> 1548;
3490 -> 3475;
3490 -> 1555;
3490 -> 1552;
3491 -> 1672;
3492 -> 3491;
3492 -> 1567;
3493 -> 3492;
3493 -> 1569;
3493 -> 1567;
3494 -> 1565;
3494 -> 1599;
3494 -> 1668;
3494 -> 3493;
3494 -> 1677;
3494 -> 1593;
3494 -> 1594;
3494 -> 3479;
3494 -> 1601;
3494 -> 1598;
3495 -> 1613;
3496 -> 3495;
3496 -> 1434;
3497 -> 3496;
3497 -> 1436;
3497 -> 1434;
3498 -> 1632;
3499 -> 3498;
3499 -> 1472;
3500 -> 3499;
3500 -> 1474;
3500 -> 1472;
3501 -> 1470;
3501 -> 1502;
3501 -> 1628;
3501 -> 3500;
3501 -> 1637;
3501 -> 1498;
3501 -> 1499;
3501 -> 3486;
3501 -> 1509;
3501 -> 1501;
3502 -> 1652;
3503 -> 3502;
3503 -> 1521;
3504 -> 3503;
3504 -> 1523;
3504 -> 1521;
3505 -> 1519;
3505 -> 1553;
3505 -> 1648;
3505 -> 3504;
3505 -> 1657;
3505 -> 1547;
3505 -> 1548;
3505 -> 3490;
3505 -> 1555;
3505 -> 1552;
3506 -> 1672;
3507 -> 3506;
3507 -> 1567;
3508 -> 3507;
3508 -> 1569;
3508 -> 1567;
3509 -> 1565;
3509 -> 1599;
3509 -> 1668;
3509 -> 3508;
3509 -> 1677;
3509 -> 1593;
3509 -> 1594;
3509 -> 3494;
3509 -> 1601;
3509 -> 1598;
3510 -> 1613;
3511 -> 3510;
3511 -> 1434;
3512 -> 3511;
3512 -> 1436;
3512 -> 1434;
3513 -> 1632;
3514 -> 3513;
3514 -> 1472;
3515 -> 3514;
3515 -> 1474;
3515 -> 1472;
3516 -> 1470;
3516 -> 1502;
3516 -> 1628;
3516 -> 3515;
3516 -> 1637;
3516 -> 1498;
3516 -> 1499;
3516 -> 3501;
3516 -> 1509;
3516 -> 1501;
3517 -> 1652;
3518 -> 3517;
3518 -> 1521;
3519 -> 3518;
3519 -> 1523;
3519 -> 1521;
3520 -> 1519;
3520 -> 1553;
3520 -> 1648;
3520 -> 3519;
3520 -> 1657;
3520 -> 1547;
3520 -> 1548;
3520 -> 3505;
3520 -> 1555;
3520 -> 1552;
3521 -> 1672;
3522 -> 3521;
3522 -> 1567;
3523 -> 3522;
3523 -> 1569;
3523 -> 1567;
3524 -> 1565;
3524 -> 1599;
3524 -> 1668;
3524 -> 3523;
3524 -> 1677;
3524 -> 1593;
3524 -> 1594;
3524 -> 3509;
3524 -> 1601;
3524 -> 1598;
3525 -> 1613;
3526 -> 3525;
3526 -> 1434;
3527 -> 3526;
3527 -> 1436;
3527 -> 1434;
3528 -> 1632;
3529 -> 3528;
3529 -> 1472;
3530 -> 3529;
3530 -> 1474;
3530 -> 1472;
3531 -> 1470;
3531 -> 1502;
3531 -> 1628;
3531 -> 3530;
3531 -> 1637;
3531 -> 1498;
3531 -> 1499;
3531 -> 3516;
3531 -> 1509;
3531 -> 1501;
3532 -> 1652;
3533 -> 3532;
3533 -> 1521;
3534 -> 3533;
3534 -> 1523;
3534 -> 1521;
3535 -> 1519;
3535 -> 1553;
3535 -> 1648;
3535 -> 3534;
3535 -> 1657;
3535 -> 1547;
3535 -> 1548;
3535 -> 3520;
3535 -> 1555;
3535 -> 1552;
3536 -> 1672;
3537 -> 3536;
3537 -> 1567;
3538 -> 3537;
3538 -> 1569;
3538 -> 1567;
3539 -> 1565;
3539 -> 1599;
3539 -> 1668;
3539 -> 3538;
3539 -> 1677;
3539 -> 1593;
3539 -> 1594;
3539 -> 3524;
3539 -> 1601;
3539 -> 1598;
3540 -> 1613;
3541 -> 3540;
3541 -> 1434;
3542 -> 3541;
3542 -> 1436;
3542 -> 1434;
3543 -> 1632;
3544 -> 3543;
3544 -> 1472;
3545 -> 3544;
3545 -> 1474;
3545 -> 1472;
3546 -> 1470;
3546 -> 1502;
3546 -> 1628;
3546 -> 3545;
3546 -> 1637;
3546 -> 1498;
3546 -> 1499;
3546 -> 3531;
3546 -> 1509;
3546 -> 1501;
3547 -> 1652;
3548 -> 3547;
3548 -> 1521;
3549 -> 3548;
3549 -> 1523;
3549 -> 1521;
3550 -> 1519;
3550 -> 1553;
3550 -> 1648;
3550 -> 3549;
3550 -> 1657;
3550 -> 1547;
3550 -> 1548;
3550 -> 3535;
3550 -> 1555;
3550 -> 1552;
3551 -> 1672;
3552 -> 3551;
3552 -> 1567;
3553 -> 3552;
3553 -> 1569;
3553 -> 1567;
3554 -> 1565;
3554 -> 1599;
3554 -> 1668;
3554 -> 3553;
3554 -> 1677;
3554 -> 1593;
3554 -> 1594;
3554 -> 3539;
3554 -> 1601;
3554 -> 1598;
3555 -> 1613;
3556 -> 3555;
3556 -> 1434;
3557 -> 3556;
3557 -> 1436;
3557 -> 1434;
3558 -> 1632;
3559 -> 3558;
3559 -> 1472;
3560 -> 3559;
3560 -> 1474;
3560 -> 1472;
3561 -> 1470;
3561 -> 1502;
3561 -> 1628;
3561 -> 3560;
3561 -> 1637;
3561 -> 1498;
3561 -> 1499;
3561 -> 3546;
3561 -> 1509;
3561 -> 1501;
3562 -> 1652;
3563 -> 3562;
3563 -> 1521;
3564 -> 3563;
3564 -> 1523;
3564 -> 1521;
3565 -> 1519;
3565 -> 1553;
3565 -> 1648;
3565 -> 3564;
3565 -> 1657;
3565 -> 1547;
3565 -> 1548;
3565 -> 3550;
3565 -> 1555;
3565 -> 1552;
3566 -> 1672;
3567 -> 3566;
3567 -> 1567;
3568 -> 3567;
3568 -> 1569;
3568 -> 1567;
3569 -> 1565;
3569 -> 1599;
3569 -> 1668;
3569 -> 3568;
3569 -> 1677;
3569 -> 1593;
3569 -> 1594;
3569 -> 3554;
3569 -> 1601;
3569 -> 1598;
3570 -> 1613;
3571 -> 3570;
3571 -> 1434;
3572 -> 3571;
3572 -> 1436;
3572 -> 1434;
3573 -> 1632;
3574 -> 3573;
3574 -> 1472;
3575 -> 3574;
3575 -> 1474;
3575 -> 1472;
3576 -> 1470;
3576 -> 1502;
3576 -> 1628;
3576 -> 3575;
3576 -> 1637;
3576 -> 1498;
3576 -> 1499;
3576 -> 3561;
3576 -> 1509;
3576 -> 1501;
3577 -> 1652;
3578 -> 3577;
3578 -> 1521;
3579 -> 3578;
3579 -> 1523;
3579 -> 1521;
3580 -> 1519;
3580 -> 1553;
3580 -> 1648;
3580 -> 3579;
3580 -> 1657;
3580 -> 1547;
3580 -> 1548;
3580 -> 3565;
3580 -> 1555;
3580 -> 1552;
3581 -> 1672;
3582 -> 3581;
3582 -> 1567;
3583 -> 3582;
3583 -> 1569;
3583 -> 1567;
3584 -> 1565;
3584 -> 1599;
3584 -> 1668;
3584 -> 3583;
3584 -> 1677;
3584 -> 1593;
3584 -> 1594;
3584 -> 3569;
3584 -> 1601;
3584 -> 1598;
3585 -> 1613;
3586 -> 3585;
3586 -> 1434;
3587 -> 3586;
3587 -> 1436;
3587 -> 1434;
3588 -> 1632;
3589 -> 3588;
3589 -> 1472;
3590 -> 3589;
3590 -> 1474;
3590 -> 1472;
3591 -> 1470;
3591 -> 1502;
3591 -> 1628;
3591 -> 3590;
3591 -> 1637;
3591 -> 1498;
3591 -> 1499;
3591 -> 3576;
3591 -> 1509;
3591 -> 1501;
3592 -> 1652;
3593 -> 3592;
3593 -> 1521;
3594 -> 3593;
3594 -> 1523;
3594 -> 1521;
3595 -> 1519;
3595 -> 1553;
3595 -> 1648;
3595 -> 3594;
3595 -> 1657;
3595 -> 1547;
3595 -> 1548;
3595 -> 3580;
3595 -> 1555;
3595 -> 1552;
3596 -> 1672;
3597 -> 3596;
3597 -> 1567;
3598 -> 3597;
3598 -> 1569;
3598 -> 1567;
3599 -> 1565;
3599 -> 1599;
3599 -> 1668;
3599 -> 3598;
3599 -> 1677;
3599 -> 1593;
3599 -> 1594;
3599 -> 3584;
3599 -> 1601;
3599 -> 1598;
3600 -> 1613;
3601 -> 3600;
3601 -> 1434;
3602 -> 3601;
3602 -> 1436;
3602 -> 1434;
3603 -> 1632;
3604 -> 3603;
3604 -> 1472;
3605 -> 3604;
3605 -> 1474;
3605 -> 1472;
3606 -> 1470;
3606 -> 1502;
3606 -> 1628;
3606 -> 3605;
3606 -> 1637;
3606 -> 1498;
3606 -> 1499;
3606 -> 3591;
3606 -> 1509;
3606 -> 1501;
3607 -> 1652;
3608 -> 3607;
3608 -> 1521;
3609 -> 3608;
3609 -> 1523;
3609 -> 1521;
3610 -> 1519;
3610 -> 1553;
3610 -> 1648;
3610 -> 3609;
3610 -> 1657;
3610 -> 1547;
3610 -> 1548;
3610 -> 3595;
3610 -> 1555;
3610 -> 1552;
3611 -> 1672;
3612 -> 3611;
3612 -> 1567;
3613 -> 3612;
3613 -> 1569;
3613 -> 1567;
3614 -> 1565;
3614 -> 1599;
3614 -> 1668;
3614 -> 3613;
3614 -> 1677;
3614 -> 1593;
3614 -> 1594;
3614 -> 3599;
3614 -> 1601;
3614 -> 1598;
3615 -> 1613;
3616 -> 3615;
3616 -> 1434;
3617 -> 3616;
3617 -> 1436;
3617 -> 1434;
3618 -> 1632;
3619 -> 3618;
3619 -> 1472;
3620 -> 3619;
3620 -> 1474;
3620 -> 1472;
3621 -> 1470;
3621 -> 1502;
3621 -> 1628;
3621 -> 3620;
3621 -> 1637;
3621 -> 1498;
3621 -> 1499;
3621 -> 3606;
3621 -> 1509;
3621 -> 1501;
3622 -> 1652;
3623 -> 3622;
3623 -> 1521;
3624 -> 3623;
3624 -> 1523;
3624 -> 1521;
3625 -> 1519;
3625 -> 1553;
3625 -> 1648;
3625 -> 3624;
3625 -> 1657;
3625 -> 1547;
3625 -> 1548;
3625 -> 3610;
3625 -> 1555;
3625 -> 1552;
3626 -> 1672;
3627 -> 3626;
3627 -> 1567;
3628 -> 3627;
3628 -> 1569;
3628 -> 1567;
3629 -> 1565;
3629 -> 1599;
3629 -> 1668;
3629 -> 3628;
3629 -> 1677;
3629 -> 1593;
3629 -> 1594;
3629 -> 3614;
3629 -> 1601;
3629 -> 1598;
3630 -> 1613;
3631 -> 3630;
3631 -> 1434;
3632 -> 3631;
3632 -> 1436;
3632 -> 1434;
3633 -> 1632;
3634 -> 3633;
3634 -> 1472;
3635 -> 3634;
3635 -> 1474;
3635 -> 1472;
3636 -> 1470;
3636 -> 1502;
3636 -> 1628;
3636 -> 3635;
3636 -> 1637;
3636 -> 1498;
3636 -> 1499;
3636 -> 3621;
3636 -> 1509;
3636 -> 1501;
3637 -> 1652;
3638 -> 3637;
3638 -> 1521;
3639 -> 3638;
3639 -> 1523;
3639 -> 1521;
3640 -> 1519;
3640 -> 1553;
3640 -> 1648;
3640 -> 3639;
3640 -> 1657;
3640 -> 1547;
3640 -> 1548;
3640 -> 3625;
3640 -> 1555;
3640 -> 1552;
3641 -> 1672;
3642 -> 3641;
3642 -> 1567;
3643 -> 3642;
3643 -> 1569;
3643 -> 1567;
3644 -> 1565;
3644 -> 1599;
3644 -> 1668;
3644 -> 3643;
3644 -> 1677;
3644 -> 1593;
3644 -> 1594;
3644 -> 3629;
3644 -> 1601;
3644 -> 1598;
3645 -> 1613;
3646 -> 3645;
3646 -> 1434;
3647 -> 3646;
3647 -> 1436;
3647 -> 1434;
3648 -> 1632;
3649 -> 3648;
3649 -> 1472;
3650 -> 3649;
3650 -> 1474;
3650 -> 1472;
3651 -> 1470;
3651 -> 1502;
3651 -> 1628;
3651 -> 3650;
3651 -> 1637;
3651 -> 1498;
3651 -> 1499;
3651 -> 3636;
3651 -> 1509;
3651 -> 1501;
3652 -> 1652;
3653 -> 3652;
3653 -> 1521;
3654 -> 3653;
3654 -> 1523;
3654 -> 1521;
3655 -> 1519;
3655 -> 1553;
3655 -> 1648;
3655 -> 3654;
3655 -> 1657;
3655 -> 1547;
3655 -> 1548;
3655 -> 3640;
3655 -> 1555;
3655 -> 1552;
3656 -> 1672;
3657 -> 3656;
3657 -> 1567;
3658 -> 3657;
3658 -> 1569;
3658 -> 1567;
3659 -> 1565;
3659 -> 1599;
3659 -> 1668;
3659 -> 3658;
3659 -> 1677;
3659 -> 1593;
3659 -> 1594;
3659 -> 3644;
3659 -> 1601;
3659 -> 1598;
3660 -> 1613;
3661 -> 3660;
3661 -> 1434;
3662 -> 3661;
3662 -> 1436;
3662 -> 1434;
3663 -> 1632;
3664 -> 3663;
3664 -> 1472;
3665 -> 3664;
3665 -> 1474;
3665 -> 1472;
3666 -> 1470;
3666 -> 1502;
3666 -> 1628;
3666 -> 3665;
3666 -> 1637;
3666 -> 1498;
3666 -> 1499;
3666 -> 3651;
3666 -> 1509;
3666 -> 1501;
3667 -> 1652;
3668 -> 3667;
3668 -> 1521;
3669 -> 3668;
3669 -> 1523;
3669 -> 1521;
3670 -> 1519;
3670 -> 1553;
3670 -> 1648;
3670 -> 3669;
3670 -> 1657;
3670 -> 1547;
3670 -> 1548;
3670 -> 3655;
3670 -> 1555;
3670 -> 1552;
3671 -> 1672;
3672 -> 3671;
3672 -> 1567;
3673 -> 3672;
3673 -> 1569;
3673 -> 1567;
3674 -> 1565;
3674 -> 1599;
3674 -> 1668;
3674 -> 3673;
3674 -> 1677;
3674 -> 1593;
3674 -> 1594;
3674 -> 3659;
3674 -> 1601;
3674 -> 1598;
3675 -> 1613;
3676 -> 3675;
3676 -> 1434;
3677 -> 3676;
3677 -> 1436;
3677 -> 1434;
3678 -> 1632;
3679 -> 3678;
3679 -> 1472;
3680 -> 3679;
3680 -> 1474;
3680 -> 1472;
3681 -> 1470;
3681 -> 1502;
3681 -> 1628;
3681 -> 3680;
3681 -> 1637;
3681 -> 1498;
3681 -> 1499;
3681 -> 3666;
3681 -> 1509;
3681 -> 1501;
3682 -> 1652;
3683 -> 3682;
3683 -> 1521;
3684 -> 3683;
3684 -> 1523;
3684 -> 1521;
3685 -> 1519;
3685 -> 1553;
3685 -> 1648;
3685 -> 3684;
3685 -> 1657;
3685 -> 1547;
3685 -> 1548;
3685 -> 3670;
3685 -> 1555;
3685 -> 1552;
3686 -> 1672;
3687 -> 3686;
3687 -> 1567;
3688 -> 3687;
3688 -> 1569;
3688 -> 1567;
3689 -> 1565;
3689 -> 1599;
3689 -> 1668;
3689 -> 3688;
3689 -> 1677;
3689 -> 1593;
3689 -> 1594;
3689 -> 3674;
3689 -> 1601;
3689 -> 1598;
3690 -> 1613;
3691 -> 3690;
3691 -> 1434;
3692 -> 3691;
3692 -> 1436;
3692 -> 1434;
3693 -> 1632;
3694 -> 3693;
3694 -> 1472;
3695 -> 3694;
3695 -> 1474;
3695 -> 1472;
3696 -> 1470;
3696 -> 1502;
3696 -> 1628;
3696 -> 3695;
3696 -> 1637;
3696 -> 1498;
3696 -> 1499;
3696 -> 3681;
3696 -> 1509;
3696 -> 1501;
3697 -> 1652;
3698 -> 3697;
3698 -> 1521;
3699 -> 3698;
3699 -> 1523;
3699 -> 1521;
3700 -> 1519;
3700 -> 1553;
3700 -> 1648;
3700 -> 3699;
3700 -> 1657;
3700 -> 1547;
3700 -> 1548;
3700 -> 3685;
3700 -> 1555;
3700 -> 1552;
3701 -> 1672;
3702 -> 3701;
3702 -> 1567;
3703 -> 3702;
3703 -> 1569;
3703 -> 1567;
3704 -> 1565;
3704 -> 1599;
3704 -> 1668;
3704 -> 3703;
3704 -> 1677;
3704 -> 1593;
3704 -> 1594;
3704 -> 3689;
3704 -> 1601;
3704 -> 1598;
3705 -> 1613;
3706 -> 3705;
3706 -> 1434;
3707 -> 3706;
3707 -> 1436;
3707 -> 1434;
3708 -> 1632;
3709 -> 3708;
3709 -> 1472;
3710 -> 3709;
3710 -> 1474;
3710 -> 1472;
3711 -> 1470;
3711 -> 1502;
3711 -> 1628;
3711 -> 3710;
3711 -> 1637;
3711 -> 1498;
3711 -> 1499;
3711 -> 3696;
3711 -> 1509;
3711 -> 1501;
3712 -> 1652;
3713 -> 3712;
3713 -> 1521;
3714 -> 3713;
3714 -> 1523;
3714 -> 1521;
3715 -> 1519;
3715 -> 1553;
3715 -> 1648;
3715 -> 3714;
3715 -> 1657;
3715 -> 1547;
3715 -> 1548;
3715 -> 3700;
3715 -> 1555;
3715 -> 1552;
3716 -> 1672;
3717 -> 3716;
3717 -> 1567;
3718 -> 3717;
3718 -> 1569;
3718 -> 1567;
3719 -> 1565;
3719 -> 1599;
3719 -> 1668;
3719 -> 3718;
3719 -> 1677;
3719 -> 1593;
3719 -> 1594;
3719 -> 3704;
3719 -> 1601;
3719 -> 1598;
3720 -> 1613;
3721 -> 3720;
3721 -> 1434;
3722 -> 3721;
3722 -> 1436;
3722 -> 1434;
3723 -> 1632;
3724 -> 3723;
3724 -> 1472;
3725 -> 3724;
3725 -> 1474;
3725 -> 1472;
3726 -> 1470;
3726 -> 1502;
3726 -> 1628;
3726 -> 3725;
3726 -> 1637;
3726 -> 1498;
3726 -> 1499;
3726 -> 3711;
3726 -> 1509;
3726 -> 1501;
3727 -> 1652;
3728 -> 3727;
3728 -> 1521;
3729 -> 3728;
3729 -> 1523;
3729 -> 1521;
3730 -> 1519;
3730 -> 1553;
3730 -> 1648;
3730 -> 3729;
3730 -> 1657;
3730 -> 1547;
3730 -> 1548;
3730 -> 3715;
3730 -> 1555;
3730 -> 1552;
3731 -> 1672;
3732 -> 3731;
3732 -> 1567;
3733 -> 3732;
3733 -> 1569;
3733 -> 1567;
3734 -> 1565;
3734 -> 1599;
3734 -> 1668;
3734 -> 3733;
3734 -> 1677;
3734 -> 1593;
3734 -> 1594;
3734 -> 3719;
3734 -> 1601;
3734 -> 1598;
3735 -> 1613;
3736 -> 3735;
3736 -> 1434;
3737 -> 3736;
3737 -> 1436;
3737 -> 1434;
3738 -> 1632;
3739 -> 3738;
3739 -> 1472;
3740 -> 3739;
3740 -> 1474;
3740 -> 1472;
3741 -> 1470;
3741 -> 1502;
3741 -> 1628;
3741 -> 3740;
3741 -> 1637;
3741 -> 1498;
3741 -> 1499;
3741 -> 3726;
3741 -> 1509;
3741 -> 1501;
3742 -> 1652;
3743 -> 3742;
3743 -> 1521;
3744 -> 3743;
3744 -> 1523;
3744 -> 1521;
3745 -> 1519;
3745 -> 1553;
3745 -> 1648;
3745 -> 3744;
3745 -> 1657;
3745 -> 1547;
3745 -> 1548;
3745 -> 3730;
3745 -> 1555;
3745 -> 1552;
3746 -> 1672;
3747 -> 3746;
3747 -> 1567;
3748 -> 3747;
3748 -> 1569;
3748 -> 1567;
3749 -> 1565;
3749 -> 1599;
3749 -> 1668;
3749 -> 3748;
3749 -> 1677;
3749 -> 1593;
3749 -> 1594;
3749 -> 3734;
3749 -> 1601;
3749 -> 1598;
3750 -> 1613;
3751 -> 3750;
3751 -> 1434;
3752 -> 3751;
3752 -> 1436;
3752 -> 1434;
3753 -> 1632;
3754 -> 3753;
3754 -> 1472;
3755 -> 3754;
3755 -> 1474;
3755 -> 1472;
3756 -> 1470;
3756 -> 1502;
3756 -> 1628;
3756 -> 3755;
3756 -> 1637;
3756 -> 1498;
3756 -> 1499;
3756 -> 3741;
3756 -> 1509;
3756 -> 1501;
3757 -> 1652;
3758 -> 3757;
3758 -> 1521;
3759 -> 3758;
3759 -> 1523;
3759 -> 1521;
3760 -> 1519;
3760 -> 1553;
3760 -> 1648;
3760 -> 3759;
3760 -> 1657;
3760 -> 1547;
3760 -> 1548;
3760 -> 3745;
3760 -> 1555;
3760 -> 1552;
3761 -> 1672;
3762 -> 3761;
3762 -> 1567;
3763 -> 3762;
3763 -> 1569;
3763 -> 1567;
3764 -> 1565;
3764 -> 1599;
3764 -> 1668;
3764 -> 3763;
3764 -> 1677;
3764 -> 1593;
3764 -> 1594;
3764 -> 3749;
3764 -> 1601;
3764 -> 1598;
3765 -> 1613;
3766 -> 3765;
3766 -> 1434;
3767 -> 3766;
3767 -> 1436;
3767 -> 1434;
3768 -> 1632;
3769 -> 3768;
3769 -> 1472;
3770 -> 3769;
3770 -> 1474;
3770 -> 1472;
3771 -> 1470;
3771 -> 1502;
3771 -> 1628;
3771 -> 3770;
3771 -> 1637;
3771 -> 1498;
3771 -> 1499;
3771 -> 3756;
3771 -> 1509;
3771 -> 1501;
3772 -> 1652;
3773 -> 3772;
3773 -> 1521;
3774 -> 3773;
3774 -> 1523;
3774 -> 1521;
3775 -> 1519;
3775 -> 1553;
3775 -> 1648;
3775 -> 3774;
3775 -> 1657;
3775 -> 1547;
3775 -> 1548;
3775 -> 3760;
3775 -> 1555;
3775 -> 1552;
3776 -> 1672;
3777 -> 3776;
3777 -> 1567;
3778 -> 3777;
3778 -> 1569;
3778 -> 1567;
3779 -> 1565;
3779 -> 1599;
3779 -> 1668;
3779 -> 3778;
3779 -> 1677;
3779 -> 1593;
3779 -> 1594;
3779 -> 3764;
3779 -> 1601;
3779 -> 1598;
3780 -> 1613;
3781 -> 3780;
3781 -> 1434;
3782 -> 3781;
3782 -> 1436;
3782 -> 1434;
3783 -> 1632;
3784 -> 3783;
3784 -> 1472;
3785 -> 3784;
3785 -> 1474;
3785 -> 1472;
3786 -> 1470;
3786 -> 1502;
3786 -> 1628;
3786 -> 3785;
3786 -> 1637;
3786 -> 1498;
3786 -> 1499;
3786 -> 3771;
3786 -> 1509;
3786 -> 1501;
3787 -> 1652;
3788 -> 3787;
3788 -> 1521;
3789 -> 3788;
3789 -> 1523;
3789 -> 1521;
3790 -> 1519;
3790 -> 1553;
3790 -> 1648;
3790 -> 3789;
3790 -> 1657;
3790 -> 1547;
3790 -> 1548;
3790 -> 3775;
3790 -> 1555;
3790 -> 1552;
3791 -> 1672;
3792 -> 3791;
3792 -> 1567;
3793 -> 3792;
3793 -> 1569;
3793 -> 1567;
3794 -> 1565;
3794 -> 1599;
3794 -> 1668;
3794 -> 3793;
3794 -> 1677;
3794 -> 1593;
3794 -> 1594;
3794 -> 3779;
3794 -> 1601;
3794 -> 1598;
3795 -> 1613;
3796 -> 3795;
3796 -> 1434;
3797 -> 3796;
3797 -> 1436;
3797 -> 1434;
3798 -> 1632;
3799 -> 3798;
3799 -> 1472;
3800 -> 3799;
3800 -> 1474;
3800 -> 1472;
3801 -> 1470;
3801 -> 1502;
3801 -> 1628;
3801 -> 3800;
3801 -> 1637;
3801 -> 1498;
3801 -> 1499;
3801 -> 3786;
3801 -> 1509;
3801 -> 1501;
3802 -> 1652;
3803 -> 3802;
3803 -> 1521;
3804 -> 3803;
3804 -> 1523;
3804 -> 1521;
3805 -> 1519;
3805 -> 1553;
3805 -> 1648;
3805 -> 3804;
3805 -> 1657;
3805 -> 1547;
3805 -> 1548;
3805 -> 3790;
3805 -> 1555;
3805 -> 1552;
3806 -> 1672;
3807 -> 3806;
3807 -> 1567;
3808 -> 3807;
3808 -> 1569;
3808 -> 1567;
3809 -> 1565;
3809 -> 1599;
3809 -> 1668;
3809 -> 3808;
3809 -> 1677;
3809 -> 1593;
3809 -> 1594;
3809 -> 3794;
3809 -> 1601;
3809 -> 1598;
3810 -> 1613;
3811 -> 3810;
3811 -> 1434;
3812 -> 3811;
3812 -> 1436;
3812 -> 1434;
3813 -> 1632;
3814 -> 3813;
3814 -> 1472;
3815 -> 3814;
3815 -> 1474;
3815 -> 1472;
3816 -> 1470;
3816 -> 1502;
3816 -> 1628;
3816 -> 3815;
3816 -> 1637;
3816 -> 1498;
3816 -> 1499;
3816 -> 3801;
3816 -> 1509;
3816 -> 1501;
3817 -> 1652;
3818 -> 3817;
3818 -> 1521;
3819 -> 3818;
3819 -> 1523;
3819 -> 1521;
3820 -> 1519;
3820 -> 1553;
3820 -> 1648;
3820 -> 3819;
3820 -> 1657;
3820 -> 1547;
3820 -> 1548;
3820 -> 3805;
3820 -> 1555;
3820 -> 1552;
3821 -> 1672;
3822 -> 3821;
3822 -> 1567;
3823 -> 3822;
3823 -> 1569;
3823 -> 1567;
3824 -> 1565;
3824 -> 1599;
3824 -> 1668;
3824 -> 3823;
3824 -> 1677;
3824 -> 1593;
3824 -> 1594;
3824 -> 3809;
3824 -> 1601;
3824 -> 1598;
3825 -> 1613;
3826 -> 3825;
3826 -> 1434;
3827 -> 3826;
3827 -> 1436;
3827 -> 1434;
3828 -> 1632;
3829 -> 3828;
3829 -> 1472;
3830 -> 3829;
3830 -> 1474;
3830 -> 1472;
3831 -> 1470;
3831 -> 1502;
3831 -> 1628;
3831 -> 3830;
3831 -> 1637;
3831 -> 1498;
3831 -> 1499;
3831 -> 3816;
3831 -> 1509;
3831 -> 1501;
3832 -> 1652;
3833 -> 3832;
3833 -> 1521;
3834 -> 3833;
3834 -> 1523;
3834 -> 1521;
3835 -> 1519;
3835 -> 1553;
3835 -> 1648;
3835 -> 3834;
3835 -> 1657;
3835 -> 1547;
3835 -> 1548;
3835 -> 3820;
3835 -> 1555;
3835 -> 1552;
3836 -> 1672;
3837 -> 3836;
3837 -> 1567;
3838 -> 3837;
3838 -> 1569;
3838 -> 1567;
3839 -> 1565;
3839 -> 1599;
3839 -> 1668;
3839 -> 3838;
3839 -> 1677;
3839 -> 1593;
3839 -> 1594;
3839 -> 3824;
3839 -> 1601;
3839 -> 1598;
3840 -> 1613;
3841 -> 3840;
3841 -> 1434;
3842 -> 3841;
3842 -> 1436;
3842 -> 1434;
3843 -> 1632;
3844 -> 3843;
3844 -> 1472;
3845 -> 3844;
3845 -> 1474;
3845 -> 1472;
3846 -> 1470;
3846 -> 1502;
3846 -> 1628;
3846 -> 3845;
3846 -> 1637;
3846 -> 1498;
3846 -> 1499;
3846 -> 3831;
3846 -> 1509;
3846 -> 1501;
3847 -> 1652;
3848 -> 3847;
3848 -> 1521;
3849 -> 3848;
3849 -> 1523;
3849 -> 1521;
3850 -> 1519;
3850 -> 1553;
3850 -> 1648;
3850 -> 3849;
3850 -> 1657;
3850 -> 1547;
3850 -> 1548;
3850 -> 3835;
3850 -> 1555;
3850 -> 1552;
3851 -> 1672;
3852 -> 3851;
3852 -> 1567;
3853 -> 3852;
3853 -> 1569;
3853 -> 1567;
3854 -> 1565;
3854 -> 1599;
3854 -> 1668;
3854 -> 3853;
3854 -> 1677;
3854 -> 1593;
3854 -> 1594;
3854 -> 3839;
3854 -> 1601;
3854 -> 1598;
3855 -> 1613;
3856 -> 3855;
3856 -> 1434;
3857 -> 3856;
3857 -> 1436;
3857 -> 1434;
3858 -> 1632;
3859 -> 3858;
3859 -> 1472;
3860 -> 3859;
3860 -> 1474;
3860 -> 1472;
3861 -> 1470;
3861 -> 1502;
3861 -> 1628;
3861 -> 3860;
3861 -> 1637;
3861 -> 1498;
3861 -> 1499;
3861 -> 3846;
3861 -> 1509;
3861 -> 1501;
3862 -> 1652;
3863 -> 3862;
3863 -> 1521;
3864 -> 3863;
3864 -> 1523;
3864 -> 1521;
3865 -> 1519;
3865 -> 1553;
3865 -> 1648;
3865 -> 3864;
3865 -> 1657;
3865 -> 1547;
3865 -> 1548;
3865 -> 3850;
3865 -> 1555;
3865 -> 1552;
3866 -> 1672;
3867 -> 3866;
3867 -> 1567;
3868 -> 3867;
3868 -> 1569;
3868 -> 1567;
3869 -> 1565;
3869 -> 1599;
3869 -> 1668;
3869 -> 3868;
3869 -> 1677;
3869 -> 1593;
3869 -> 1594;
3869 -> 3854;
3869 -> 1601;
3869 -> 1598;
3870 -> 1613;
3871 -> 3870;
3871 -> 1434;
3872 -> 3871;
3872 -> 1436;
3872 -> 1434;
3873 -> 1632;
3874 -> 3873;
3874 -> 1472;
3875 -> 3874;
3875 -> 1474;
3875 -> 1472;
3876 -> 1470;
3876 -> 1502;
3876 -> 1628;
3876 -> 3875;
3876 -> 1637;
3876 -> 1498;
3876 -> 1499;
3876 -> 3861;
3876 -> 1509;
3876 -> 1501;
3877 -> 1652;
3878 -> 3877;
3878 -> 1521;
3879 -> 3878;
3879 -> 1523;
3879 -> 1521;
3880 -> 1519;
3880 -> 1553;
3880 -> 1648;
3880 -> 3879;
3880 -> 1657;
3880 -> 1547;
3880 -> 1548;
3880 -> 3865;
3880 -> 1555;
3880 -> 1552;
3881 -> 1672;
3882 -> 3881;
3882 -> 1567;
3883 -> 3882;
3883 -> 1569;
3883 -> 1567;
3884 -> 1565;
3884 -> 1599;
3884 -> 1668;
3884 -> 3883;
3884 -> 1677;
3884 -> 1593;
3884 -> 1594;
3884 -> 3869;
3884 -> 1601;
3884 -> 1598;
3885 -> 1613;
3886 -> 3885;
3886 -> 1434;
3887 -> 3886;
3887 -> 1436;
3887 -> 1434;
3888 -> 1632;
3889 -> 3888;
3889 -> 1472;
3890 -> 3889;
3890 -> 1474;
3890 -> 1472;
3891 -> 1470;
3891 -> 1502;
3891 -> 1628;
3891 -> 3890;
3891 -> 1637;
3891 -> 1498;
3891 -> 1499;
3891 -> 3876;
3891 -> 1509;
3891 -> 1501;
3892 -> 1652;
3893 -> 3892;
3893 -> 1521;
3894 -> 3893;
3894 -> 1523;
3894 -> 1521;
3895 -> 1519;
3895 -> 1553;
3895 -> 1648;
3895 -> 3894;
3895 -> 1657;
3895 -> 1547;
3895 -> 1548;
3895 -> 3880;
3895 -> 1555;
3895 -> 1552;
3896 -> 1672;
3897 -> 3896;
3897 -> 1567;
3898 -> 3897;
3898 -> 1569;
3898 -> 1567;
3899 -> 1565;
3899 -> 1599;
3899 -> 1668;
3899 -> 3898;
3899 -> 1677;
3899 -> 1593;
3899 -> 1594;
3899 -> 3884;
3899 -> 1601;
3899 -> 1598;
3900 -> 1613;
3901 -> 3900;
3901 -> 1434;
3902 -> 3901;
3902 -> 1436;
3902 -> 1434;
3903 -> 1632;
3904 -> 3903;
3904 -> 1472;
3905 -> 3904;
3905 -> 1474;
3905 -> 1472;
3906 -> 1470;
3906 -> 1502;
3906 -> 1628;
3906 -> 3905;
3906 -> 1637;
3906 -> 1498;
3906 -> 1499;
3906 -> 3891;
3906 -> 1509;
3906 -> 1501;
3907 -> 1652;
3908 -> 3907;
3908 -> 1521;
3909 -> 3908;
3909 -> 1523;
3909 -> 1521;
3910 -> 1519;
3910 -> 1553;
3910 -> 1648;
3910 -> 3909;
3910 -> 1657;
3910 -> 1547;
3910 -> 1548;
3910 -> 3895;
3910 -> 1555;
3910 -> 1552;
3911 -> 1672;
3912 -> 3911;
3912 -> 1567;
3913 -> 3912;
3913 -> 1569;
3913 -> 1567;
3914 -> 1565;
3914 -> 1599;
3914 -> 1668;
3914 -> 3913;
3914 -> 1677;
3914 -> 1593;
3914 -> 1594;
3914 -> 3899;
3914 -> 1601;
3914 -> 1598;
3915 -> 1613;
3916 -> 3915;
3916 -> 1434;
3917 -> 3916;
3917 -> 1436;
3917 -> 1434;
3918 -> 1632;
3919 -> 3918;
3919 -> 1472;
3920 -> 3919;
3920 -> 1474;
3920 -> 1472;
3921 -> 1470;
3921 -> 1502;
3921 -> 1628;
3921 -> 3920;
3921 -> 1637;
3921 -> 1498;
3921 -> 1499;
3921 -> 3906;
3921 -> 1509;
3921 -> 1501;
3922 -> 1652;
3923 -> 3922;
3923 -> 1521;
3924 -> 3923;
3924 -> 1523;
3924 -> 1521;
3925 -> 1519;
3925 -> 1553;
3925 -> 1648;
3925 -> 3924;
3925 -> 1657;
3925 -> 1547;
3925 -> 1548;
3925 -> 3910;
3925 -> 1555;
3925 -> 1552;
3926 -> 1672;
3927 -> 3926;
3927 -> 1567;
3928 -> 3927;
3928 -> 1569;
3928 -> 1567;
3929 -> 1565;
3929 -> 1599;
3929 -> 1668;
3929 -> 3928;
3929 -> 1677;
3929 -> 1593;
3929 -> 1594;
3929 -> 3914;
3929 -> 1601;
3929 -> 1598;
3930 -> 1613;
3931 -> 3930;
3931 -> 1434;
3932 -> 3931;
3932 -> 1436;
3932 -> 1434;
3933 -> 1632;
3934 -> 3933;
3934 -> 1472;
3935 -> 3934;
3935 -> 1474;
3935 -> 1472;
3936 -> 1470;
3936 -> 1502;
3936 -> 1628;
3936 -> 3935;
3936 -> 1637;
3936 -> 1498;
3936 -> 1499;
3936 -> 3921;
3936 -> 1509;
3936 -> 1501;
3937 -> 1652;
3938 -> 3937;
3938 -> 1521;
3939 -> 3938;
3939 -> 1523;
3939 -> 1521;
3940 -> 1519;
3940 -> 1553;
3940 -> 1648;
3940 -> 3939;
3940 -> 1657;
3940 -> 1547;
3940 -> 1548;
3940 -> 3925;
3940 -> 1555;
3940 -> 1552;
3941 -> 1672;
3942 -> 3941;
3942 -> 1567;
3943 -> 3942;
3943 -> 1569;
3943 -> 1567;
3944 -> 1565;
3944 -> 1599;
3944 -> 1668;
3944 -> 3943;
3944 -> 1677;
3944 -> 1593;
3944 -> 1594;
3944 -> 3929;
3944 -> 1601;
3944 -> 1598;
3945 -> 1613;
3946 -> 3945;
3946 -> 1434;
3947 -> 3946;
3947 -> 1436;
3947 -> 1434;
3948 -> 1632;
3949 -> 3948;
3949 -> 1472;
3950 -> 3949;
3950 -> 1474;
3950 -> 1472;
3951 -> 1470;
3951 -> 1502;
3951 -> 1628;
3951 -> 3950;
3951 -> 1637;
3951 -> 1498;
3951 -> 1499;
3951 -> 3936;
3951 -> 1509;
3951 -> 1501;
3952 -> 1652;
3953 -> 3952;
3953 -> 1521;
3954 -> 3953;
3954 -> 1523;
3954 -> 1521;
3955 -> 1519;
3955 -> 1553;
3955 -> 1648;
3955 -> 3954;
3955 -> 1657;
3955 -> 1547;
3955 -> 1548;
3955 -> 3940;
3955 -> 1555;
3955 -> 1552;
3956 -> 1672;
3957 -> 3956;
3957 -> 1567;
3958 -> 3957;
3958 -> 1569;
3958 -> 1567;
3959 -> 1565;
3959 -> 1599;
3959 -> 1668;
3959 -> 3958;
3959 -> 1677;
3959 -> 1593;
3959 -> 1594;
3959 -> 3944;
3959 -> 1601;
3959 -> 1598;
3960 -> 1613;
3961 -> 3960;
3961 -> 1434;
3962 -> 3961;
3962 -> 1436;
3962 -> 1434;
3963 -> 1632;
3964 -> 3963;
3964 -> 1472;
3965 -> 3964;
3965 -> 1474;
3965 -> 1472;
3966 -> 1470;
3966 -> 1502;
3966 -> 1628;
3966 -> 3965;
3966 -> 1637;
3966 -> 1498;
3966 -> 1499;
3966 -> 3951;
3966 -> 1509;
3966 -> 1501;
3967 -> 1652;
3968 -> 3967;
3968 -> 1521;
3969 -> 3968;
3969 -> 1523;
3969 -> 1521;
3970 -> 1519;
3970 -> 1553;
3970 -> 1648;
3970 -> 3969;
3970 -> 1657;
3970 -> 1547;
3970 -> 1548;
3970 -> 3955;
3970 -> 1555;
3970 -> 1552;
3971 -> 1672;
3972 -> 3971;
3972 -> 1567;
3973 -> 3972;
3973 -> 1569;
3973 -> 1567;
3974 -> 1565;
3974 -> 1599;
3974 -> 1668;
3974 -> 3973;
3974 -> 1677;
3974 -> 1593;
3974 -> 1594;
3974 -> 3959;
3974 -> 1601;
3974 -> 1598;
3975 -> 1613;
3976 -> 3975;
3976 -> 1434;
3977 -> 3976;
3977 -> 1436;
3977 -> 1434;
3978 -> 1632;
3979 -> 3978;
3979 -> 1472;
3980 -> 3979;
3980 -> 1474;
3980 -> 1472;
3981 -> 1470;
3981 -> 1502;
3981 -> 1628;
3981 -> 3980;
3981 -> 1637;
3981 -> 1498;
3981 -> 1499;
3981 -> 3966;
3981 -> 1509;
3981 -> 1501;
3982 -> 1652;
3983 -> 3982;
3983 -> 1521;
3984 -> 3983;
3984 -> 1523;
3984 -> 1521;
3985 -> 1519;
3985 -> 1553;
3985 -> 1648;
3985 -> 3984;
3985 -> 1657;
3985 -> 1547;
3985 -> 1548;
3985 -> 3970;
3985 -> 1555;
3985 -> 1552;
3986 -> 1672;
3987 -> 3986;
3987 -> 1567;
3988 -> 3987;
3988 -> 1569;
3988 -> 1567;
3989 -> 1565;
3989 -> 1599;
3989 -> 1668;
3989 -> 3988;
3989 -> 1677;
3989 -> 1593;
3989 -> 1594;
3989 -> 3974;
3989 -> 1601;
3989 -> 1598;
3990 -> 1613;
3991 -> 3990;
3991 -> 1434;
3992 -> 3991;
3992 -> 1436;
3992 -> 1434;
3993 -> 1632;
3994 -> 3993;
3994 -> 1472;
3995 -> 3994;
3995 -> 1474;
3995 -> 1472;
3996 -> 1470;
3996 -> 1502;
3996 -> 1628;
3996 -> 3995;
3996 -> 1637;
3996 -> 1498;
3996 -> 1499;
3996 -> 3981;
3996 -> 1509;
3996 -> 1501;
3997 -> 1652;
3998 -> 3997;
3998 -> 1521;
3999 -> 3998;
3999 -> 1523;
3999 -> 1521;
4000 -> 1519;
4000 -> 1553;
4000 -> 1648;
4000 -> 3999;
4000 -> 1657;
4000 -> 1547;
4000 -> 1548;
4000 -> 3985;
4000 -> 1555;
4000 -> 1552;
4001 -> 1672;
4002 -> 4001;
4002 -> 1567;
4003 -> 4002;
4003 -> 1569;
4003 -> 1567;
4004 -> 1565;
4004 -> 1599;
4004 -> 1668;
4004 -> 4003;
4004 -> 1677;
4004 -> 1593;
4004 -> 1594;
4004 -> 3989;
4004 -> 1601;
4004 -> 1598;
4005 -> 1613;
4006 -> 4005;
4006 -> 1434;
4007 -> 4006;
4007 -> 1436;
4007 -> 1434;
4008 -> 1632;
4009 -> 4008;
4009 -> 1472;
4010 -> 4009;
4010 -> 1474;
4010 -> 1472;
4011 -> 1470;
4011 -> 1502;
4011 -> 1628;
4011 -> 4010;
4011 -> 1637;
4011 -> 1498;
4011 -> 1499;
4011 -> 3996;
4011 -> 1509;
4011 -> 1501;
4012 -> 1652;
4013 -> 4012;
4013 -> 1521;
4014 -> 4013;
4014 -> 1523;
4014 -> 1521;
4015 -> 1519;
4015 -> 1553;
4015 -> 1648;
4015 -> 4014;
4015 -> 1657;
4015 -> 1547;
4015 -> 1548;
4015 -> 4000;
4015 -> 1555;
4015 -> 1552;
4016 -> 1672;
4017 -> 4016;
4017 -> 1567;
4018 -> 4017;
4018 -> 1569;
4018 -> 1567;
4019 -> 1565;
4019 -> 1599;
4019 -> 1668;
4019 -> 4018;
4019 -> 1677;
4019 -> 1593;
4019 -> 1594;
4019 -> 4004;
4019 -> 1601;
4019 -> 1598;
4020 -> 1613;
4021 -> 4020;
4021 -> 1434;
4022 -> 4021;
4022 -> 1436;
4022 -> 1434;
4023 -> 1632;
4024 -> 4023;
4024 -> 1472;
4025 -> 4024;
4025 -> 1474;
4025 -> 1472;
4026 -> 1470;
4026 -> 1502;
4026 -> 1628;
4026 -> 4025;
4026 -> 1637;
4026 -> 1498;
4026 -> 1499;
4026 -> 4011;
4026 -> 1509;
4026 -> 1501;
4027 -> 1652;
4028 -> 4027;
4028 -> 1521;
4029 -> 4028;
4029 -> 1523;
4029 -> 1521;
4030 -> 1519;
4030 -> 1553;
4030 -> 1648;
4030 -> 4029;
4030 -> 1657;
4030 -> 1547;
4030 -> 1548;
4030 -> 4015;
4030 -> 1555;
4030 -> 1552;
4031 -> 1672;
4032 -> 4031;
4032 -> 1567;
4033 -> 4032;
4033 -> 1569;
4033 -> 1567;
4034 -> 1565;
4034 -> 1599;
4034 -> 1668;
4034 -> 4033;
4034 -> 1677;
4034 -> 1593;
4034 -> 1594;
4034 -> 4019;
4034 -> 1601;
4034 -> 1598;
4035 -> 1613;
4036 -> 4035;
4036 -> 1434;
4037 -> 4036;
4037 -> 1436;
4037 -> 1434;
4038 -> 1632;
4039 -> 4038;
4039 -> 1472;
4040 -> 4039;
4040 -> 1474;
4040 -> 1472;
4041 -> 1470;
4041 -> 1502;
4041 -> 1628;
4041 -> 4040;
4041 -> 1637;
4041 -> 1498;
4041 -> 1499;
4041 -> 4026;
4041 -> 1509;
4041 -> 1501;
4042 -> 1652;
4043 -> 4042;
4043 -> 1521;
4044 -> 4043;
4044 -> 1523;
4044 -> 1521;
4045 -> 1519;
4045 -> 1553;
4045 -> 1648;
4045 -> 4044;
4045 -> 1657;
4045 -> 1547;
4045 -> 1548;
4045 -> 4030;
4045 -> 1555;
4045 -> 1552;
4046 -> 1672;
4047 -> 4046;
4047 -> 1567;
4048 -> 4047;
4048 -> 1569;
4048 -> 1567;
4049 -> 1565;
4049 -> 1599;
4049 -> 1668;
4049 -> 4048;
4049 -> 1677;
4049 -> 1593;
4049 -> 1594;
4049 -> 4034;
4049 -> 1601;
4049 -> 1598;
4050 -> 1613;
4051 -> 4050;
4051 -> 1434;
4052 -> 4051;
4052 -> 1436;
4052 -> 1434;
4053 -> 1632;
4054 -> 4053;
4054 -> 1472;
4055 -> 4054;
4055 -> 1474;
4055 -> 1472;
4056 -> 1470;
4056 -> 1502;
4056 -> 1628;
4056 -> 4055;
4056 -> 1637;
4056 -> 1498;
4056 -> 1499;
4056 -> 4041;
4056 -> 1509;
4056 -> 1501;
4057 -> 1652;
4058 -> 4057;
4058 -> 1521;
4059 -> 4058;
4059 -> 1523;
4059 -> 1521;
4060 -> 1519;
4060 -> 1553;
4060 -> 1648;
4060 -> 4059;
4060 -> 1657;
4060 -> 1547;
4060 -> 1548;
4060 -> 4045;
4060 -> 1555;
4060 -> 1552;
4061 -> 1672;
4062 -> 4061;
4062 -> 1567;
4063 -> 4062;
4063 -> 1569;
4063 -> 1567;
4064 -> 1565;
4064 -> 1599;
4064 -> 1668;
4064 -> 4063;
4064 -> 1677;
4064 -> 1593;
4064 -> 1594;
4064 -> 4049;
4064 -> 1601;
4064 -> 1598;
4065 -> 1613;
4066 -> 4065;
4066 -> 1434;
4067 -> 4066;
4067 -> 1436;
4067 -> 1434;
4068 -> 1632;
4069 -> 4068;
4069 -> 1472;
4070 -> 4069;
4070 -> 1474;
4070 -> 1472;
4071 -> 1470;
4071 -> 1502;
4071 -> 1628;
4071 -> 4070;
4071 -> 1637;
4071 -> 1498;
4071 -> 1499;
4071 -> 4056;
4071 -> 1509;
4071 -> 1501;
4072 -> 1652;
4073 -> 4072;
4073 -> 1521;
4074 -> 4073;
4074 -> 1523;
4074 -> 1521;
4075 -> 1519;
4075 -> 1553;
4075 -> 1648;
4075 -> 4074;
4075 -> 1657;
4075 -> 1547;
4075 -> 1548;
4075 -> 4060;
4075 -> 1555;
4075 -> 1552;
4076 -> 1672;
4077 -> 4076;
4077 -> 1567;
4078 -> 4077;
4078 -> 1569;
4078 -> 1567;
4079 -> 1565;
4079 -> 1599;
4079 -> 1668;
4079 -> 4078;
4079 -> 1677;
4079 -> 1593;
4079 -> 1594;
4079 -> 4064;
4079 -> 1601;
4079 -> 1598;
4080 -> 1613;
4081 -> 4080;
4081 -> 1434;
4082 -> 4081;
4082 -> 1436;
4082 -> 1434;
4083 -> 1632;
4084 -> 4083;
4084 -> 1472;
4085 -> 4084;
4085 -> 1474;
4085 -> 1472;
4086 -> 1470;
4086 -> 1502;
4086 -> 1628;
4086 -> 4085;
4086 -> 1637;
4086 -> 1498;
4086 -> 1499;
4086 -> 4071;
4086 -> 1509;
4086 -> 1501;
4087 -> 1652;
4088 -> 4087;
4088 -> 1521;
4089 -> 4088;
4089 -> 1523;
4089 -> 1521;
4090 -> 1519;
4090 -> 1553;
4090 -> 1648;
4090 -> 4089;
4090 -> 1657;
4090 -> 1547;
4090 -> 1548;
4090 -> 4075;
4090 -> 1555;
4090 -> 1552;
4091 -> 1672;
4092 -> 4091;
4092 -> 1567;
4093 -> 4092;
4093 -> 1569;
4093 -> 1567;
4094 -> 1565;
4094 -> 1599;
4094 -> 1668;
4094 -> 4093;
4094 -> 1677;
4094 -> 1593;
4094 -> 1594;
4094 -> 4079;
4094 -> 1601;
4094 -> 1598;
4095 -> 1613;
4096 -> 4095;
4096 -> 1434;
4097 -> 4096;
4097 -> 1436;
4097 -> 1434;
4098 -> 1632;
4099 -> 4098;
4099 -> 1472;
4100 -> 4099;
4100 -> 1474;
4100 -> 1472;
4101 -> 1470;
4101 -> 1502;
4101 -> 1628;
4101 -> 4100;
4101 -> 1637;
4101 -> 1498;
4101 -> 1499;
4101 -> 4086;
4101 -> 1509;
4101 -> 1501;
4102 -> 1652;
4103 -> 4102;
4103 -> 1521;
4104 -> 4103;
4104 -> 1523;
4104 -> 1521;
4105 -> 1519;
4105 -> 1553;
4105 -> 1648;
4105 -> 4104;
4105 -> 1657;
4105 -> 1547;
4105 -> 1548;
4105 -> 4090;
4105 -> 1555;
4105 -> 1552;
4106 -> 1672;
4107 -> 4106;
4107 -> 1567;
4108 -> 4107;
4108 -> 1569;
4108 -> 1567;
4109 -> 1565;
4109 -> 1599;
4109 -> 1668;
4109 -> 4108;
4109 -> 1677;
4109 -> 1593;
4109 -> 1594;
4109 -> 4094;
4109 -> 1601;
4109 -> 1598;
4110 -> 1613;
4111 -> 4110;
4111 -> 1434;
4112 -> 4111;
4112 -> 1436;
4112 -> 1434;
4113 -> 1632;
4114 -> 4113;
4114 -> 1472;
4115 -> 4114;
4115 -> 1474;
4115 -> 1472;
4116 -> 1470;
4116 -> 1502;
4116 -> 1628;
4116 -> 4115;
4116 -> 1637;
4116 -> 1498;
4116 -> 1499;
4116 -> 4101;
4116 -> 1509;
4116 -> 1501;
4117 -> 1652;
4118 -> 4117;
4118 -> 1521;
4119 -> 4118;
4119 -> 1523;
4119 -> 1521;
4120 -> 1519;
4120 -> 1553;
4120 -> 1648;
4120 -> 4119;
4120 -> 1657;
4120 -> 1547;
4120 -> 1548;
4120 -> 4105;
4120 -> 1555;
4120 -> 1552;
4121 -> 1672;
4122 -> 4121;
4122 -> 1567;
4123 -> 4122;
4123 -> 1569;
4123 -> 1567;
4124 -> 1565;
4124 -> 1599;
4124 -> 1668;
4124 -> 4123;
4124 -> 1677;
4124 -> 1593;
4124 -> 1594;
4124 -> 4109;
4124 -> 1601;
4124 -> 1598;
4125 -> 1613;
4126 -> 4125;
4126 -> 1434;
4127 -> 4126;
4127 -> 1436;
4127 -> 1434;
4128 -> 1632;
4129 -> 4128;
4129 -> 1472;
4130 -> 4129;
4130 -> 1474;
4130 -> 1472;
4131 -> 1470;
4131 -> 1502;
4131 -> 1628;
4131 -> 4130;
4131 -> 1637;
4131 -> 1498;
4131 -> 1499;
4131 -> 4116;
4131 -> 1509;
4131 -> 1501;
4132 -> 1652;
4133 -> 4132;
4133 -> 1521;
4134 -> 4133;
4134 -> 1523;
4134 -> 1521;
4135 -> 1519;
4135 -> 1553;
4135 -> 1648;
4135 -> 4134;
4135 -> 1657;
4135 -> 1547;
4135 -> 1548;
4135 -> 4120;
4135 -> 1555;
4135 -> 1552;
4136 -> 1672;
4137 -> 4136;
4137 -> 1567;
4138 -> 4137;
4138 -> 1569;
4138 -> 1567;
4139 -> 1565;
4139 -> 1599;
4139 -> 1668;
4139 -> 4138;
4139 -> 1677;
4139 -> 1593;
4139 -> 1594;
4139 -> 4124;
4139 -> 1601;
4139 -> 1598;
4140 -> 1613;
4141 -> 4140;
4141 -> 1434;
4142 -> 4141;
4142 -> 1436;
4142 -> 1434;
4143 -> 1632;
4144 -> 4143;
4144 -> 1472;
4145 -> 4144;
4145 -> 1474;
4145 -> 1472;
4146 -> 1470;
4146 -> 1502;
4146 -> 1628;
4146 -> 4145;
4146 -> 1637;
4146 -> 1498;
4146 -> 1499;
4146 -> 4131;
4146 -> 1509;
4146 -> 1501;
4147 -> 1652;
4148 -> 4147;
4148 -> 1521;
4149 -> 4148;
4149 -> 1523;
4149 -> 1521;
4150 -> 1519;
4150 -> 1553;
4150 -> 1648;
4150 -> 4149;
4150 -> 1657;
4150 -> 1547;
4150 -> 1548;
4150 -> 4135;
4150 -> 1555;
4150 -> 1552;
4151 -> 1672;
4152 -> 4151;
4152 -> 1567;
4153 -> 4152;
4153 -> 1569;
4153 -> 1567;
4154 -> 1565;
4154 -> 1599;
4154 -> 1668;
4154 -> 4153;
4154 -> 1677;
4154 -> 1593;
4154 -> 1594;
4154 -> 4139;
4154 -> 1601;
4154 -> 1598;
4155 -> 1613;
4156 -> 4155;
4156 -> 1434;
4157 -> 4156;
4157 -> 1436;
4157 -> 1434;
4158 -> 1632;
4159 -> 4158;
4159 -> 1472;
4160 -> 4159;
4160 -> 1474;
4160 -> 1472;
4161 -> 1470;
4161 -> 1502;
4161 -> 1628;
4161 -> 4160;
4161 -> 1637;
4161 -> 1498;
4161 -> 1499;
4161 -> 4146;
4161 -> 1509;
4161 -> 1501;
4162 -> 1652;
4163 -> 4162;
4163 -> 1521;
4164 -> 4163;
4164 -> 1523;
4164 -> 1521;
4165 -> 1519;
4165 -> 1553;
4165 -> 1648;
4165 -> 4164;
4165 -> 1657;
4165 -> 1547;
4165 -> 1548;
4165 -> 4150;
4165 -> 1555;
4165 -> 1552;
4166 -> 1672;
4167 -> 4166;
4167 -> 1567;
4168 -> 4167;
4168 -> 1569;
4168 -> 1567;
4169 -> 1565;
4169 -> 1599;
4169 -> 1668;
4169 -> 4168;
4169 -> 1677;
4169 -> 1593;
4169 -> 1594;
4169 -> 4154;
4169 -> 1601;
4169 -> 1598;
4170 -> 1613;
4171 -> 4170;
4171 -> 1434;
4172 -> 4171;
4172 -> 1436;
4172 -> 1434;
4173 -> 1632;
4174 -> 4173;
4174 -> 1472;
4175 -> 4174;
4175 -> 1474;
4175 -> 1472;
4176 -> 1470;
4176 -> 1502;
4176 -> 1628;
4176 -> 4175;
4176 -> 1637;
4176 -> 1498;
4176 -> 1499;
4176 -> 4161;
4176 -> 1509;
4176 -> 1501;
4177 -> 1652;
4178 -> 4177;
4178 -> 1521;
4179 -> 4178;
4179 -> 1523;
4179 -> 1521;
4180 -> 1519;
4180 -> 1553;
4180 -> 1648;
4180 -> 4179;
4180 -> 1657;
4180 -> 1547;
4180 -> 1548;
4180 -> 4165;
4180 -> 1555;
4180 -> 1552;
4181 -> 1672;
4182 -> 4181;
4182 -> 1567;
4183 -> 4182;
4183 -> 1569;
4183 -> 1567;
4184 -> 1565;
4184 -> 1599;
4184 -> 1668;
4184 -> 4183;
4184 -> 1677;
4184 -> 1593;
4184 -> 1594;
4184 -> 4169;
4184 -> 1601;
4184 -> 1598;
4185 -> 1613;
4186 -> 4185;
4186 -> 1434;
4187 -> 4186;
4187 -> 1436;
4187 -> 1434;
4188 -> 1632;
4189 -> 4188;
4189 -> 1472;
4190 -> 4189;
4190 -> 1474;
4190 -> 1472;
4191 -> 1470;
4191 -> 1502;
4191 -> 1628;
4191 -> 4190;
4191 -> 1637;
4191 -> 1498;
4191 -> 1499;
4191 -> 4176;
4191 -> 1509;
4191 -> 1501;
4192 -> 1652;
4193 -> 4192;
4193 -> 1521;
4194 -> 4193;
4194 -> 1523;
4194 -> 1521;
4195 -> 1519;
4195 -> 1553;
4195 -> 1648;
4195 -> 4194;
4195 -> 1657;
4195 -> 1547;
4195 -> 1548;
4195 -> 4180;
4195 -> 1555;
4195 -> 1552;
4196 -> 1672;
4197 -> 4196;
4197 -> 1567;
4198 -> 4197;
4198 -> 1569;
4198 -> 1567;
4199 -> 1565;
4199 -> 1599;
4199 -> 1668;
4199 -> 4198;
4199 -> 1677;
4199 -> 1593;
4199 -> 1594;
4199 -> 4184;
4199 -> 1601;
4199 -> 1598;
4200 -> 1613;
4201 -> 4200;
4201 -> 1434;
4202 -> 4201;
4202 -> 1436;
4202 -> 1434;
4203 -> 1632;
4204 -> 4203;
4204 -> 1472;
4205 -> 4204;
4205 -> 1474;
4205 -> 1472;
4206 -> 1470;
4206 -> 1502;
4206 -> 1628;
4206 -> 4205;
4206 -> 1637;
4206 -> 1498;
4206 -> 1499;
4206 -> 4191;
4206 -> 1509;
4206 -> 1501;
4207 -> 1652;
4208 -> 4207;
4208 -> 1521;
4209 -> 4208;
4209 -> 1523;
4209 -> 1521;
4210 -> 1519;
4210 -> 1553;
4210 -> 1648;
4210 -> 4209;
4210 -> 1657;
4210 -> 1547;
4210 -> 1548;
4210 -> 4195;
4210 -> 1555;
4210 -> 1552;
4211 -> 1672;
4212 -> 4211;
4212 -> 1567;
4213 -> 4212;
4213 -> 1569;
4213 -> 1567;
4214 -> 1565;
4214 -> 1599;
4214 -> 1668;
4214 -> 4213;
4214 -> 1677;
4214 -> 1593;
4214 -> 1594;
4214 -> 4199;
4214 -> 1601;
4214 -> 1598;
4215 -> 1613;
4216 -> 4215;
4216 -> 1434;
4217 -> 4216;
4217 -> 1436;
4217 -> 1434;
4218 -> 1632;
4219 -> 4218;
4219 -> 1472;
4220 -> 4219;
4220 -> 1474;
4220 -> 1472;
4221 -> 1470;
4221 -> 1502;
4221 -> 1628;
4221 -> 4220;
4221 -> 1637;
4221 -> 1498;
4221 -> 1499;
4221 -> 4206;
4221 -> 1509;
4221 -> 1501;
4222 -> 1652;
4223 -> 4222;
4223 -> 1521;
4224 -> 4223;
4224 -> 1523;
4224 -> 1521;
4225 -> 1519;
4225 -> 1553;
4225 -> 1648;
4225 -> 4224;
4225 -> 1657;
4225 -> 1547;
4225 -> 1548;
4225 -> 4210;
4225 -> 1555;
4225 -> 1552;
4226 -> 1672;
4227 -> 4226;
4227 -> 1567;
4228 -> 4227;
4228 -> 1569;
4228 -> 1567;
4229 -> 1565;
4229 -> 1599;
4229 -> 1668;
4229 -> 4228;
4229 -> 1677;
4229 -> 1593;
4229 -> 1594;
4229 -> 4214;
4229 -> 1601;
4229 -> 1598;
4230 -> 1613;
4231 -> 4230;
4231 -> 1434;
4232 -> 4231;
4232 -> 1436;
4232 -> 1434;
4233 -> 1632;
4234 -> 4233;
4234 -> 1472;
4235 -> 4234;
4235 -> 1474;
4235 -> 1472;
4236 -> 1470;
4236 -> 1502;
4236 -> 1628;
4236 -> 4235;
4236 -> 1637;
4236 -> 1498;
4236 -> 1499;
4236 -> 4221;
4236 -> 1509;
4236 -> 1501;
4237 -> 1652;
4238 -> 4237;
4238 -> 1521;
4239 -> 4238;
4239 -> 1523;
4239 -> 1521;
4240 -> 1519;
4240 -> 1553;
4240 -> 1648;
4240 -> 4239;
4240 -> 1657;
4240 -> 1547;
4240 -> 1548;
4240 -> 4225;
4240 -> 1555;
4240 -> 1552;
4241 -> 1672;
4242 -> 4241;
4242 -> 1567;
4243 -> 4242;
4243 -> 1569;
4243 -> 1567;
4244 -> 1565;
4244 -> 1599;
4244 -> 1668;
4244 -> 4243;
4244 -> 1677;
4244 -> 1593;
4244 -> 1594;
4244 -> 4229;
4244 -> 1601;
4244 -> 1598;
4245 -> 1613;
4246 -> 4245;
4246 -> 1434;
4247 -> 4246;
4247 -> 1436;
4247 -> 1434;
4248 -> 1632;
4249 -> 4248;
4249 -> 1472;
4250 -> 4249;
4250 -> 1474;
4250 -> 1472;
4251 -> 1470;
4251 -> 1502;
4251 -> 1628;
4251 -> 4250;
4251 -> 1637;
4251 -> 1498;
4251 -> 1499;
4251 -> 4236;
4251 -> 1509;
4251 -> 1501;
4252 -> 1652;
4253 -> 4252;
4253 -> 1521;
4254 -> 4253;
4254 -> 1523;
4254 -> 1521;
4255 -> 1519;
4255 -> 1553;
4255 -> 1648;
4255 -> 4254;
4255 -> 1657;
4255 -> 1547;
4255 -> 1548;
4255 -> 4240;
4255 -> 1555;
4255 -> 1552;
4256 -> 1672;
4257 -> 4256;
4257 -> 1567;
4258 -> 4257;
4258 -> 1569;
4258 -> 1567;
4259 -> 1565;
4259 -> 1599;
4259 -> 1668;
4259 -> 4258;
4259 -> 1677;
4259 -> 1593;
4259 -> 1594;
4259 -> 4244;
4259 -> 1601;
4259 -> 1598;
4260 -> 1613;
4261 -> 4260;
4261 -> 1434;
4262 -> 4261;
4262 -> 1436;
4262 -> 1434;
4263 -> 1632;
4264 -> 4263;
4264 -> 1472;
4265 -> 4264;
4265 -> 1474;
4265 -> 1472;
4266 -> 1470;
4266 -> 1502;
4266 -> 1628;
4266 -> 4265;
4266 -> 1637;
4266 -> 1498;
4266 -> 1499;
4266 -> 4251;
4266 -> 1509;
4266 -> 1501;
4267 -> 1652;
4268 -> 4267;
4268 -> 1521;
4269 -> 4268;
4269 -> 1523;
4269 -> 1521;
4270 -> 1519;
4270 -> 1553;
4270 -> 1648;
4270 -> 4269;
4270 -> 1657;
4270 -> 1547;
4270 -> 1548;
4270 -> 4255;
4270 -> 1555;
4270 -> 1552;
4271 -> 1672;
4272 -> 4271;
4272 -> 1567;
4273 -> 4272;
4273 -> 1569;
4273 -> 1567;
4274 -> 1565;
4274 -> 1599;
4274 -> 1668;
4274 -> 4273;
4274 -> 1677;
4274 -> 1593;
4274 -> 1594;
4274 -> 4259;
4274 -> 1601;
4274 -> 1598;
4275 -> 1613;
4276 -> 4275;
4276 -> 1434;
4277 -> 4276;
4277 -> 1436;
4277 -> 1434;
4278 -> 1632;
4279 -> 4278;
4279 -> 1472;
4280 -> 4279;
4280 -> 1474;
4280 -> 1472;
4281 -> 1470;
4281 -> 1502;
4281 -> 1628;
4281 -> 4280;
4281 -> 1637;
4281 -> 1498;
4281 -> 1499;
4281 -> 4266;
4281 -> 1509;
4281 -> 1501;
4282 -> 1652;
4283 -> 4282;
4283 -> 1521;
4284 -> 4283;
4284 -> 1523;
4284 -> 1521;
4285 -> 1519;
4285 -> 1553;
4285 -> 1648;
4285 -> 4284;
4285 -> 1657;
4285 -> 1547;
4285 -> 1548;
4285 -> 4270;
4285 -> 1555;
4285 -> 1552;
4286 -> 1672;
4287 -> 4286;
4287 -> 1567;
4288 -> 4287;
4288 -> 1569;
4288 -> 1567;
4289 -> 1565;
4289 -> 1599;
4289 -> 1668;
4289 -> 4288;
4289 -> 1677;
4289 -> 1593;
4289 -> 1594;
4289 -> 4274;
4289 -> 1601;
4289 -> 1598;
4290 -> 1613;
4291 -> 4290;
4291 -> 1434;
4292 -> 4291;
4292 -> 1436;
4292 -> 1434;
4293 -> 1632;
4294 -> 4293;
4294 -> 1472;
4295 -> 4294;
4295 -> 1474;
4295 -> 1472;
4296 -> 1470;
4296 -> 1502;
4296 -> 1628;
4296 -> 4295;
4296 -> 1637;
4296 -> 1498;
4296 -> 1499;
4296 -> 4281;
4296 -> 1509;
4296 -> 1501;
4297 -> 1652;
4298 -> 4297;
4298 -> 1521;
4299 -> 4298;
4299 -> 1523;
4299 -> 1521;
4300 -> 1519;
4300 -> 1553;
4300 -> 1648;
4300 -> 4299;
4300 -> 1657;
4300 -> 1547;
4300 -> 1548;
4300 -> 4285;
4300 -> 1555;
4300 -> 1552;
4301 -> 1672;
4302 -> 4301;
4302 -> 1567;
4303 -> 4302;
4303 -> 1569;
4303 -> 1567;
4304 -> 1565;
4304 -> 1599;
4304 -> 1668;
4304 -> 4303;
4304 -> 1677;
4304 -> 1593;
4304 -> 1594;
4304 -> 4289;
4304 -> 1601;
4304 -> 1598;
4305 -> 1613;
4306 -> 4305;
4306 -> 1434;
4307 -> 4306;
4307 -> 1436;
4307 -> 1434;
4308 -> 1632;
4309 -> 4308;
4309 -> 1472;
4310 -> 4309;
4310 -> 1474;
4310 -> 1472;
4311 -> 1470;
4311 -> 1502;
4311 -> 1628;
4311 -> 4310;
4311 -> 1637;
4311 -> 1498;
4311 -> 1499;
4311 -> 4296;
4311 -> 1509;
4311 -> 1501;
4312 -> 1652;
4313 -> 4312;
4313 -> 1521;
4314 -> 4313;
4314 -> 1523;
4314 -> 1521;
4315 -> 1519;
4315 -> 1553;
4315 -> 1648;
4315 -> 4314;
4315 -> 1657;
4315 -> 1547;
4315 -> 1548;
4315 -> 4300;
4315 -> 1555;
4315 -> 1552;
4316 -> 1672;
4317 -> 4316;
4317 -> 1567;
4318 -> 4317;
4318 -> 1569;
4318 -> 1567;
4319 -> 1565;
4319 -> 1599;
4319 -> 1668;
4319 -> 4318;
4319 -> 1677;
4319 -> 1593;
4319 -> 1594;
4319 -> 4304;
4319 -> 1601;
4319 -> 1598;
4320 -> 1613;
4321 -> 4320;
4321 -> 1434;
4322 -> 4321;
4322 -> 1436;
4322 -> 1434;
4323 -> 1632;
4324 -> 4323;
4324 -> 1472;
4325 -> 4324;
4325 -> 1474;
4325 -> 1472;
4326 -> 1470;
4326 -> 1502;
4326 -> 1628;
4326 -> 4325;
4326 -> 1637;
4326 -> 1498;
4326 -> 1499;
4326 -> 4311;
4326 -> 1509;
4326 -> 1501;
4327 -> 1652;
4328 -> 4327;
4328 -> 1521;
4329 -> 4328;
4329 -> 1523;
4329 -> 1521;
4330 -> 1519;
4330 -> 1553;
4330 -> 1648;
4330 -> 4329;
4330 -> 1657;
4330 -> 1547;
4330 -> 1548;
4330 -> 4315;
4330 -> 1555;
4330 -> 1552;
4331 -> 1672;
4332 -> 4331;
4332 -> 1567;
4333 -> 4332;
4333 -> 1569;
4333 -> 1567;
4334 -> 1565;
4334 -> 1599;
4334 -> 1668;
4334 -> 4333;
4334 -> 1677;
4334 -> 1593;
4334 -> 1594;
4334 -> 4319;
4334 -> 1601;
4334 -> 1598;
4335 -> 1613;
4336 -> 4335;
4336 -> 1434;
4337 -> 4336;
4337 -> 1436;
4337 -> 1434;
4338 -> 1632;
4339 -> 4338;
4339 -> 1472;
4340 -> 4339;
4340 -> 1474;
4340 -> 1472;
4341 -> 1470;
4341 -> 1502;
4341 -> 1628;
4341 -> 4340;
4341 -> 1637;
4341 -> 1498;
4341 -> 1499;
4341 -> 4326;
4341 -> 1509;
4341 -> 1501;
4342 -> 1652;
4343 -> 4342;
4343 -> 1521;
4344 -> 4343;
4344 -> 1523;
4344 -> 1521;
4345 -> 1519;
4345 -> 1553;
4345 -> 1648;
4345 -> 4344;
4345 -> 1657;
4345 -> 1547;
4345 -> 1548;
4345 -> 4330;
4345 -> 1555;
4345 -> 1552;
4346 -> 1672;
4347 -> 4346;
4347 -> 1567;
4348 -> 4347;
4348 -> 1569;
4348 -> 1567;
4349 -> 1565;
4349 -> 1599;
4349 -> 1668;
4349 -> 4348;
4349 -> 1677;
4349 -> 1593;
4349 -> 1594;
4349 -> 4334;
4349 -> 1601;
4349 -> 1598;
4350 -> 1613;
4351 -> 4350;
4351 -> 1434;
4352 -> 4351;
4352 -> 1436;
4352 -> 1434;
4353 -> 1632;
4354 -> 4353;
4354 -> 1472;
4355 -> 4354;
4355 -> 1474;
4355 -> 1472;
4356 -> 1470;
4356 -> 1502;
4356 -> 1628;
4356 -> 4355;
4356 -> 1637;
4356 -> 1498;
4356 -> 1499;
4356 -> 4341;
4356 -> 1509;
4356 -> 1501;
4357 -> 1652;
4358 -> 4357;
4358 -> 1521;
4359 -> 4358;
4359 -> 1523;
4359 -> 1521;
4360 -> 1519;
4360 -> 1553;
4360 -> 1648;
4360 -> 4359;
4360 -> 1657;
4360 -> 1547;
4360 -> 1548;
4360 -> 4345;
4360 -> 1555;
4360 -> 1552;
4361 -> 1672;
4362 -> 4361;
4362 -> 1567;
4363 -> 4362;
4363 -> 1569;
4363 -> 1567;
4364 -> 1565;
4364 -> 1599;
4364 -> 1668;
4364 -> 4363;
4364 -> 1677;
4364 -> 1593;
4364 -> 1594;
4364 -> 4349;
4364 -> 1601;
4364 -> 1598;
4365 -> 1613;
4366 -> 4365;
4366 -> 1434;
4367 -> 4366;
4367 -> 1436;
4367 -> 1434;
4368 -> 1632;
4369 -> 4368;
4369 -> 1472;
4370 -> 4369;
4370 -> 1474;
4370 -> 1472;
4371 -> 1470;
4371 -> 1502;
4371 -> 1628;
4371 -> 4370;
4371 -> 1637;
4371 -> 1498;
4371 -> 1499;
4371 -> 4356;
4371 -> 1509;
4371 -> 1501;
4372 -> 1652;
4373 -> 4372;
4373 -> 1521;
4374 -> 4373;
4374 -> 1523;
4374 -> 1521;
4375 -> 1519;
4375 -> 1553;
4375 -> 1648;
4375 -> 4374;
4375 -> 1657;
4375 -> 1547;
4375 -> 1548;
4375 -> 4360;
4375 -> 1555;
4375 -> 1552;
4376 -> 1672;
4377 -> 4376;
4377 -> 1567;
4378 -> 4377;
4378 -> 1569;
4378 -> 1567;
4379 -> 1565;
4379 -> 1599;
4379 -> 1668;
4379 -> 4378;
4379 -> 1677;
4379 -> 1593;
4379 -> 1594;
4379 -> 4364;
4379 -> 1601;
4379 -> 1598;
4380 -> 1613;
4381 -> 4380;
4381 -> 1434;
4382 -> 4381;
4382 -> 1436;
4382 -> 1434;
4383 -> 1632;
4384 -> 4383;
4384 -> 1472;
4385 -> 4384;
4385 -> 1474;
4385 -> 1472;
4386 -> 1470;
4386 -> 1502;
4386 -> 1628;
4386 -> 4385;
4386 -> 1637;
4386 -> 1498;
4386 -> 1499;
4386 -> 4371;
4386 -> 1509;
4386 -> 1501;
4387 -> 1652;
4388 -> 4387;
4388 -> 1521;
4389 -> 4388;
4389 -> 1523;
4389 -> 1521;
4390 -> 1519;
4390 -> 1553;
4390 -> 1648;
4390 -> 4389;
4390 -> 1657;
4390 -> 1547;
4390 -> 1548;
4390 -> 4375;
4390 -> 1555;
4390 -> 1552;
4391 -> 1672;
4392 -> 4391;
4392 -> 1567;
4393 -> 4392;
4393 -> 1569;
4393 -> 1567;
4394 -> 1565;
4394 -> 1599;
4394 -> 1668;
4394 -> 4393;
4394 -> 1677;
4394 -> 1593;
4394 -> 1594;
4394 -> 4379;
4394 -> 1601;
4394 -> 1598;
4395 -> 1613;
4396 -> 4395;
4396 -> 1434;
4397 -> 4396;
4397 -> 1436;
4397 -> 1434;
4398 -> 1632;
4399 -> 4398;
4399 -> 1472;
4400 -> 4399;
4400 -> 1474;
4400 -> 1472;
4401 -> 1470;
4401 -> 1502;
4401 -> 1628;
4401 -> 4400;
4401 -> 1637;
4401 -> 1498;
4401 -> 1499;
4401 -> 4386;
4401 -> 1509;
4401 -> 1501;
4402 -> 1652;
4403 -> 4402;
4403 -> 1521;
4404 -> 4403;
4404 -> 1523;
4404 -> 1521;
4405 -> 1519;
4405 -> 1553;
4405 -> 1648;
4405 -> 4404;
4405 -> 1657;
4405 -> 1547;
4405 -> 1548;
4405 -> 4390;
4405 -> 1555;
4405 -> 1552;
4406 -> 1672;
4407 -> 4406;
4407 -> 1567;
4408 -> 4407;
4408 -> 1569;
4408 -> 1567;
4409 -> 1565;
4409 -> 1599;
4409 -> 1668;
4409 -> 4408;
4409 -> 1677;
4409 -> 1593;
4409 -> 1594;
4409 -> 4394;
4409 -> 1601;
4409 -> 1598;
4410 -> 1613;
4411 -> 4410;
4411 -> 1434;
4412 -> 4411;
4412 -> 1436;
4412 -> 1434;
4413 -> 1632;
4414 -> 4413;
4414 -> 1472;
4415 -> 4414;
4415 -> 1474;
4415 -> 1472;
4416 -> 1470;
4416 -> 1502;
4416 -> 1628;
4416 -> 4415;
4416 -> 1637;
4416 -> 1498;
4416 -> 1499;
4416 -> 4401;
4416 -> 1509;
4416 -> 1501;
4417 -> 1652;
4418 -> 4417;
4418 -> 1521;
4419 -> 4418;
4419 -> 1523;
4419 -> 1521;
4420 -> 1519;
4420 -> 1553;
4420 -> 1648;
4420 -> 4419;
4420 -> 1657;
4420 -> 1547;
4420 -> 1548;
4420 -> 4405;
4420 -> 1555;
4420 -> 1552;
4421 -> 1672;
4422 -> 4421;
4422 -> 1567;
4423 -> 4422;
4423 -> 1569;
4423 -> 1567;
4424 -> 1565;
4424 -> 1599;
4424 -> 1668;
4424 -> 4423;
4424 -> 1677;
4424 -> 1593;
4424 -> 1594;
4424 -> 4409;
4424 -> 1601;
4424 -> 1598;
4425 -> 1613;
4426 -> 4425;
4426 -> 1434;
4427 -> 4426;
4427 -> 1436;
4427 -> 1434;
4428 -> 1632;
4429 -> 4428;
4429 -> 1472;
4430 -> 4429;
4430 -> 1474;
4430 -> 1472;
4431 -> 1470;
4431 -> 1502;
4431 -> 1628;
4431 -> 4430;
4431 -> 1637;
4431 -> 1498;
4431 -> 1499;
4431 -> 4416;
4431 -> 1509;
4431 -> 1501;
4432 -> 1652;
4433 -> 4432;
4433 -> 1521;
4434 -> 4433;
4434 -> 1523;
4434 -> 1521;
4435 -> 1519;
4435 -> 1553;
4435 -> 1648;
4435 -> 4434;
4435 -> 1657;
4435 -> 1547;
4435 -> 1548;
4435 -> 4420;
4435 -> 1555;
4435 -> 1552;
4436 -> 1672;
4437 -> 4436;
4437 -> 1567;
4438 -> 4437;
4438 -> 1569;
4438 -> 1567;
4439 -> 1565;
4439 -> 1599;
4439 -> 1668;
4439 -> 4438;
4439 -> 1677;
4439 -> 1593;
4439 -> 1594;
4439 -> 4424;
4439 -> 1601;
4439 -> 1598;
4440 -> 1613;
4441 -> 4440;
4441 -> 1434;
4442 -> 4441;
4442 -> 1436;
4442 -> 1434;
4443 -> 1632;
4444 -> 4443;
4444 -> 1472;
4445 -> 4444;
4445 -> 1474;
4445 -> 1472;
4446 -> 1470;
4446 -> 1502;
4446 -> 1628;
4446 -> 4445;
4446 -> 1637;
4446 -> 1498;
4446 -> 1499;
4446 -> 4431;
4446 -> 1509;
4446 -> 1501;
4447 -> 1652;
4448 -> 4447;
4448 -> 1521;
4449 -> 4448;
4449 -> 1523;
4449 -> 1521;
4450 -> 1519;
4450 -> 1553;
4450 -> 1648;
4450 -> 4449;
4450 -> 1657;
4450 -> 1547;
4450 -> 1548;
4450 -> 4435;
4450 -> 1555;
4450 -> 1552;
4451 -> 1672;
4452 -> 4451;
4452 -> 1567;
4453 -> 4452;
4453 -> 1569;
4453 -> 1567;
4454 -> 1565;
4454 -> 1599;
4454 -> 1668;
4454 -> 4453;
4454 -> 1677;
4454 -> 1593;
4454 -> 1594;
4454 -> 4439;
4454 -> 1601;
4454 -> 1598;
4455 -> 1613;
4456 -> 4455;
4456 -> 1434;
4457 -> 4456;
4457 -> 1436;
4457 -> 1434;
4458 -> 1632;
4459 -> 4458;
4459 -> 1472;
4460 -> 4459;
4460 -> 1474;
4460 -> 1472;
4461 -> 1470;
4461 -> 1502;
4461 -> 1628;
4461 -> 4460;
4461 -> 1637;
4461 -> 1498;
4461 -> 1499;
4461 -> 4446;
4461 -> 1509;
4461 -> 1501;
4462 -> 1652;
4463 -> 4462;
4463 -> 1521;
4464 -> 4463;
4464 -> 1523;
4464 -> 1521;
4465 -> 1519;
4465 -> 1553;
4465 -> 1648;
4465 -> 4464;
4465 -> 1657;
4465 -> 1547;
4465 -> 1548;
4465 -> 4450;
4465 -> 1555;
4465 -> 1552;
4466 -> 1672;
4467 -> 4466;
4467 -> 1567;
4468 -> 4467;
4468 -> 1569;
4468 -> 1567;
4469 -> 1565;
4469 -> 1599;
4469 -> 1668;
4469 -> 4468;
4469 -> 1677;
4469 -> 1593;
4469 -> 1594;
4469 -> 4454;
4469 -> 1601;
4469 -> 1598;
4470 -> 1613;
4471 -> 4470;
4471 -> 1434;
4472 -> 4471;
4472 -> 1436;
4472 -> 1434;
4473 -> 1632;
4474 -> 4473;
4474 -> 1472;
4475 -> 4474;
4475 -> 1474;
4475 -> 1472;
4476 -> 1470;
4476 -> 1502;
4476 -> 1628;
4476 -> 4475;
4476 -> 1637;
4476 -> 1498;
4476 -> 1499;
4476 -> 4461;
4476 -> 1509;
4476 -> 1501;
4477 -> 1652;
4478 -> 4477;
4478 -> 1521;
4479 -> 4478;
4479 -> 1523;
4479 -> 1521;
4480 -> 1519;
4480 -> 1553;
4480 -> 1648;
4480 -> 4479;
4480 -> 1657;
4480 -> 1547;
4480 -> 1548;
4480 -> 4465;
4480 -> 1555;
4480 -> 1552;
4481 -> 1672;
4482 -> 4481;
4482 -> 1567;
4483 -> 4482;
4483 -> 1569;
4483 -> 1567;
4484 -> 1565;
4484 -> 1599;
4484 -> 1668;
4484 -> 4483;
4484 -> 1677;
4484 -> 1593;
4484 -> 1594;
4484 -> 4469;
4484 -> 1601;
4484 -> 1598;
4485 -> 1613;
4486 -> 4485;
4486 -> 1434;
4487 -> 4486;
4487 -> 1436;
4487 -> 1434;
4488 -> 1632;
4489 -> 4488;
4489 -> 1472;
4490 -> 4489;
4490 -> 1474;
4490 -> 1472;
4491 -> 1470;
4491 -> 1502;
4491 -> 1628;
4491 -> 4490;
4491 -> 1637;
4491 -> 1498;
4491 -> 1499;
4491 -> 4476;
4491 -> 1509;
4491 -> 1501;
4492 -> 1652;
4493 -> 4492;
4493 -> 1521;
4494 -> 4493;
4494 -> 1523;
4494 -> 1521;
4495 -> 1519;
4495 -> 1553;
4495 -> 1648;
4495 -> 4494;
4495 -> 1657;
4495 -> 1547;
4495 -> 1548;
4495 -> 4480;
4495 -> 1555;
4495 -> 1552;
4496 -> 1672;
4497 -> 4496;
4497 -> 1567;
4498 -> 4497;
4498 -> 1569;
4498 -> 1567;
4499 -> 1565;
4499 -> 1599;
4499 -> 1668;
4499 -> 4498;
4499 -> 1677;
4499 -> 1593;
4499 -> 1594;
4499 -> 4484;
4499 -> 1601;
4499 -> 1598;
4500 -> 1613;
4501 -> 4500;
4501 -> 1434;
4502 -> 4501;
4502 -> 1436;
4502 -> 1434;
4503 -> 1632;
4504 -> 4503;
4504 -> 1472;
4505 -> 4504;
4505 -> 1474;
4505 -> 1472;
4506 -> 1470;
4506 -> 1502;
4506 -> 1628;
4506 -> 4505;
4506 -> 1637;
4506 -> 1498;
4506 -> 1499;
4506 -> 4491;
4506 -> 1509;
4506 -> 1501;
4507 -> 1652;
4508 -> 4507;
4508 -> 1521;
4509 -> 4508;
4509 -> 1523;
4509 -> 1521;
4510 -> 1519;
4510 -> 1553;
4510 -> 1648;
4510 -> 4509;
4510 -> 1657;
4510 -> 1547;
4510 -> 1548;
4510 -> 4495;
4510 -> 1555;
4510 -> 1552;
4511 -> 1672;
4512 -> 4511;
4512 -> 1567;
4513 -> 4512;
4513 -> 1569;
4513 -> 1567;
4514 -> 1565;
4514 -> 1599;
4514 -> 1668;
4514 -> 4513;
4514 -> 1677;
4514 -> 1593;
4514 -> 1594;
4514 -> 4499;
4514 -> 1601;
4514 -> 1598;
4515 -> 1613;
4516 -> 4515;
4516 -> 1434;
4517 -> 4516;
4517 -> 1436;
4517 -> 1434;
4518 -> 1632;
4519 -> 4518;
4519 -> 1472;
4520 -> 4519;
4520 -> 1474;
4520 -> 1472;
4521 -> 1470;
4521 -> 1502;
4521 -> 1628;
4521 -> 4520;
4521 -> 1637;
4521 -> 1498;
4521 -> 1499;
4521 -> 4506;
4521 -> 1509;
4521 -> 1501;
4522 -> 1652;
4523 -> 4522;
4523 -> 1521;
4524 -> 4523;
4524 -> 1523;
4524 -> 1521;
4525 -> 1519;
4525 -> 1553;
4525 -> 1648;
4525 -> 4524;
4525 -> 1657;
4525 -> 1547;
4525 -> 1548;
4525 -> 4510;
4525 -> 1555;
4525 -> 1552;
4526 -> 1672;
4527 -> 4526;
4527 -> 1567;
4528 -> 4527;
4528 -> 1569;
4528 -> 1567;
4529 -> 1565;
4529 -> 1599;
4529 -> 1668;
4529 -> 4528;
4529 -> 1677;
4529 -> 1593;
4529 -> 1594;
4529 -> 4514;
4529 -> 1601;
4529 -> 1598;
4530 -> 1613;
4531 -> 4530;
4531 -> 1434;
4532 -> 4531;
4532 -> 1436;
4532 -> 1434;
4533 -> 1632;
4534 -> 4533;
4534 -> 1472;
4535 -> 4534;
4535 -> 1474;
4535 -> 1472;
4536 -> 1470;
4536 -> 1502;
4536 -> 1628;
4536 -> 4535;
4536 -> 1637;
4536 -> 1498;
4536 -> 1499;
4536 -> 4521;
4536 -> 1509;
4536 -> 1501;
4537 -> 1652;
4538 -> 4537;
4538 -> 1521;
4539 -> 4538;
4539 -> 1523;
4539 -> 1521;
4540 -> 1519;
4540 -> 1553;
4540 -> 1648;
4540 -> 4539;
4540 -> 1657;
4540 -> 1547;
4540 -> 1548;
4540 -> 4525;
4540 -> 1555;
4540 -> 1552;
4541 -> 1672;
4542 -> 4541;
4542 -> 1567;
4543 -> 4542;
4543 -> 1569;
4543 -> 1567;
4544 -> 1565;
4544 -> 1599;
4544 -> 1668;
4544 -> 4543;
4544 -> 1677;
4544 -> 1593;
4544 -> 1594;
4544 -> 4529;
4544 -> 1601;
4544 -> 1598;
4545 -> 1613;
4546 -> 4545;
4546 -> 1434;
4547 -> 4546;
4547 -> 1436;
4547 -> 1434;
4548 -> 1632;
4549 -> 4548;
4549 -> 1472;
4550 -> 4549;
4550 -> 1474;
4550 -> 1472;
4551 -> 1470;
4551 -> 1502;
4551 -> 1628;
4551 -> 4550;
4551 -> 1637;
4551 -> 1498;
4551 -> 1499;
4551 -> 4536;
4551 -> 1509;
4551 -> 1501;
4552 -> 1652;
4553 -> 4552;
4553 -> 1521;
4554 -> 4553;
4554 -> 1523;
4554 -> 1521;
4555 -> 1519;
4555 -> 1553;
4555 -> 1648;
4555 -> 4554;
4555 -> 1657;
4555 -> 1547;
4555 -> 1548;
4555 -> 4540;
4555 -> 1555;
4555 -> 1552;
4556 -> 1672;
4557 -> 4556;
4557 -> 1567;
4558 -> 4557;
4558 -> 1569;
4558 -> 1567;
4559 -> 1565;
4559 -> 1599;
4559 -> 1668;
4559 -> 4558;
4559 -> 1677;
4559 -> 1593;
4559 -> 1594;
4559 -> 4544;
4559 -> 1601;
4559 -> 1598;
4560 -> 1613;
4561 -> 4560;
4561 -> 1434;
4562 -> 4561;
4562 -> 1436;
4562 -> 1434;
4563 -> 1632;
4564 -> 4563;
4564 -> 1472;
4565 -> 4564;
4565 -> 1474;
4565 -> 1472;
4566 -> 1470;
4566 -> 1502;
4566 -> 1628;
4566 -> 4565;
4566 -> 1637;
4566 -> 1498;
4566 -> 1499;
4566 -> 4551;
4566 -> 1509;
4566 -> 1501;
4567 -> 1652;
4568 -> 4567;
4568 -> 1521;
4569 -> 4568;
4569 -> 1523;
4569 -> 1521;
4570 -> 1519;
4570 -> 1553;
4570 -> 1648;
4570 -> 4569;
4570 -> 1657;
4570 -> 1547;
4570 -> 1548;
4570 -> 4555;
4570 -> 1555;
4570 -> 1552;
4571 -> 1672;
4572 -> 4571;
4572 -> 1567;
4573 -> 4572;
4573 -> 1569;
4573 -> 1567;
4574 -> 1565;
4574 -> 1599;
4574 -> 1668;
4574 -> 4573;
4574 -> 1677;
4574 -> 1593;
4574 -> 1594;
4574 -> 4559;
4574 -> 1601;
4574 -> 1598;
4575 -> 1613;
4576 -> 4575;
4576 -> 1434;
4577 -> 4576;
4577 -> 1436;
4577 -> 1434;
4578 -> 1632;
4579 -> 4578;
4579 -> 1472;
4580 -> 4579;
4580 -> 1474;
4580 -> 1472;
4581 -> 1470;
4581 -> 1502;
4581 -> 1628;
4581 -> 4580;
4581 -> 1637;
4581 -> 1498;
4581 -> 1499;
4581 -> 4566;
4581 -> 1509;
4581 -> 1501;
4582 -> 1652;
4583 -> 4582;
4583 -> 1521;
4584 -> 4583;
4584 -> 1523;
4584 -> 1521;
4585 -> 1519;
4585 -> 1553;
4585 -> 1648;
4585 -> 4584;
4585 -> 1657;
4585 -> 1547;
4585 -> 1548;
4585 -> 4570;
4585 -> 1555;
4585 -> 1552;
4586 -> 1672;
4587 -> 4586;
4587 -> 1567;
4588 -> 4587;
4588 -> 1569;
4588 -> 1567;
4589 -> 1565;
4589 -> 1599;
4589 -> 1668;
4589 -> 4588;
4589 -> 1677;
4589 -> 1593;
4589 -> 1594;
4589 -> 4574;
4589 -> 1601;
4589 -> 1598;
4590 -> 1613;
4591 -> 4590;
4591 -> 1434;
4592 -> 4591;
4592 -> 1436;
4592 -> 1434;
4593 -> 1632;
4594 -> 4593;
4594 -> 1472;
4595 -> 4594;
4595 -> 1474;
4595 -> 1472;
4596 -> 1470;
4596 -> 1502;
4596 -> 1628;
4596 -> 4595;
4596 -> 1637;
4596 -> 1498;
4596 -> 1499;
4596 -> 4581;
4596 -> 1509;
4596 -> 1501;
4597 -> 1652;
4598 -> 4597;
4598 -> 1521;
4599 -> 4598;
4599 -> 1523;
4599 -> 1521;
4600 -> 1519;
4600 -> 1553;
4600 -> 1648;
4600 -> 4599;
4600 -> 1657;
4600 -> 1547;
4600 -> 1548;
4600 -> 4585;
4600 -> 1555;
4600 -> 1552;
4601 -> 1672;
4602 -> 4601;
4602 -> 1567;
4603 -> 4602;
4603 -> 1569;
4603 -> 1567;
4604 -> 1565;
4604 -> 1599;
4604 -> 1668;
4604 -> 4603;
4604 -> 1677;
4604 -> 1593;
4604 -> 1594;
4604 -> 4589;
4604 -> 1601;
4604 -> 1598;
4605 -> 1613;
4606 -> 4605;
4606 -> 1434;
4607 -> 4606;
4607 -> 1436;
4607 -> 1434;
4608 -> 1632;
4609 -> 4608;
4609 -> 1472;
4610 -> 4609;
4610 -> 1474;
4610 -> 1472;
4611 -> 1470;
4611 -> 1502;
4611 -> 1628;
4611 -> 4610;
4611 -> 1637;
4611 -> 1498;
4611 -> 1499;
4611 -> 4596;
4611 -> 1509;
4611 -> 1501;
4612 -> 1652;
4613 -> 4612;
4613 -> 1521;
4614 -> 4613;
4614 -> 1523;
4614 -> 1521;
4615 -> 1519;
4615 -> 1553;
4615 -> 1648;
4615 -> 4614;
4615 -> 1657;
4615 -> 1547;
4615 -> 1548;
4615 -> 4600;
4615 -> 1555;
4615 -> 1552;
4616 -> 1672;
4617 -> 4616;
4617 -> 1567;
4618 -> 4617;
4618 -> 1569;
4618 -> 1567;
4619 -> 1565;
4619 -> 1599;
4619 -> 1668;
4619 -> 4618;
4619 -> 1677;
4619 -> 1593;
4619 -> 1594;
4619 -> 4604;
4619 -> 1601;
4619 -> 1598;
4620 -> 1613;
4621 -> 4620;
4621 -> 1434;
4622 -> 4621;
4622 -> 1436;
4622 -> 1434;
4623 -> 1632;
4624 -> 4623;
4624 -> 1472;
4625 -> 4624;
4625 -> 1474;
4625 -> 1472;
4626 -> 1470;
4626 -> 1502;
4626 -> 1628;
4626 -> 4625;
4626 -> 1637;
4626 -> 1498;
4626 -> 1499;
4626 -> 4611;
4626 -> 1509;
4626 -> 1501;
4627 -> 1652;
4628 -> 4627;
4628 -> 1521;
4629 -> 4628;
4629 -> 1523;
4629 -> 1521;
4630 -> 1519;
4630 -> 1553;
4630 -> 1648;
4630 -> 4629;
4630 -> 1657;
4630 -> 1547;
4630 -> 1548;
4630 -> 4615;
4630 -> 1555;
4630 -> 1552;
4631 -> 1672;
4632 -> 4631;
4632 -> 1567;
4633 -> 4632;
4633 -> 1569;
4633 -> 1567;
4634 -> 1565;
4634 -> 1599;
4634 -> 1668;
4634 -> 4633;
4634 -> 1677;
4634 -> 1593;
4634 -> 1594;
4634 -> 4619;
4634 -> 1601;
4634 -> 1598;
4635 -> 1613;
4636 -> 4635;
4636 -> 1434;
4637 -> 4636;
4637 -> 1436;
4637 -> 1434;
4638 -> 1632;
4639 -> 4638;
4639 -> 1472;
4640 -> 4639;
4640 -> 1474;
4640 -> 1472;
4641 -> 1470;
4641 -> 1502;
4641 -> 1628;
4641 -> 4640;
4641 -> 1637;
4641 -> 1498;
4641 -> 1499;
4641 -> 4626;
4641 -> 1509;
4641 -> 1501;
4642 -> 1652;
4643 -> 4642;
4643 -> 1521;
4644 -> 4643;
4644 -> 1523;
4644 -> 1521;
4645 -> 1519;
4645 -> 1553;
4645 -> 1648;
4645 -> 4644;
4645 -> 1657;
4645 -> 1547;
4645 -> 1548;
4645 -> 4630;
4645 -> 1555;
4645 -> 1552;
4646 -> 1672;
4647 -> 4646;
4647 -> 1567;
4648 -> 4647;
4648 -> 1569;
4648 -> 1567;
4649 -> 1565;
4649 -> 1599;
4649 -> 1668;
4649 -> 4648;
4649 -> 1677;
4649 -> 1593;
4649 -> 1594;
4649 -> 4634;
4649 -> 1601;
4649 -> 1598;
4650 -> 1613;
4651 -> 4650;
4651 -> 1434;
4652 -> 4651;
4652 -> 1436;
4652 -> 1434;
4653 -> 1632;
4654 -> 4653;
4654 -> 1472;
4655 -> 4654;
4655 -> 1474;
4655 -> 1472;
4656 -> 1470;
4656 -> 1502;
4656 -> 1628;
4656 -> 4655;
4656 -> 1637;
4656 -> 1498;
4656 -> 1499;
4656 -> 4641;
4656 -> 1509;
4656 -> 1501;
4657 -> 1652;
4658 -> 4657;
4658 -> 1521;
4659 -> 4658;
4659 -> 1523;
4659 -> 1521;
4660 -> 1519;
4660 -> 1553;
4660 -> 1648;
4660 -> 4659;
4660 -> 1657;
4660 -> 1547;
4660 -> 1548;
4660 -> 4645;
4660 -> 1555;
4660 -> 1552;
4661 -> 1672;
4662 -> 4661;
4662 -> 1567;
4663 -> 4662;
4663 -> 1569;
4663 -> 1567;
4664 -> 1565;
4664 -> 1599;
4664 -> 1668;
4664 -> 4663;
4664 -> 1677;
4664 -> 1593;
4664 -> 1594;
4664 -> 4649;
4664 -> 1601;
4664 -> 1598;
4665 -> 1613;
4666 -> 4665;
4666 -> 1434;
4667 -> 4666;
4667 -> 1436;
4667 -> 1434;
4668 -> 1632;
4669 -> 4668;
4669 -> 1472;
4670 -> 4669;
4670 -> 1474;
4670 -> 1472;
4671 -> 1470;
4671 -> 1502;
4671 -> 1628;
4671 -> 4670;
4671 -> 1637;
4671 -> 1498;
4671 -> 1499;
4671 -> 4656;
4671 -> 1509;
4671 -> 1501;
4672 -> 1652;
4673 -> 4672;
4673 -> 1521;
4674 -> 4673;
4674 -> 1523;
4674 -> 1521;
4675 -> 1519;
4675 -> 1553;
4675 -> 1648;
4675 -> 4674;
4675 -> 1657;
4675 -> 1547;
4675 -> 1548;
4675 -> 4660;
4675 -> 1555;
4675 -> 1552;
4676 -> 1672;
4677 -> 4676;
4677 -> 1567;
4678 -> 4677;
4678 -> 1569;
4678 -> 1567;
4679 -> 1565;
4679 -> 1599;
4679 -> 1668;
4679 -> 4678;
4679 -> 1677;
4679 -> 1593;
4679 -> 1594;
4679 -> 4664;
4679 -> 1601;
4679 -> 1598;
4680 -> 1613;
4681 -> 4680;
4681 -> 1434;
4682 -> 4681;
4682 -> 1436;
4682 -> 1434;
4683 -> 1632;
4684 -> 4683;
4684 -> 1472;
4685 -> 4684;
4685 -> 1474;
4685 -> 1472;
4686 -> 1470;
4686 -> 1502;
4686 -> 1628;
4686 -> 4685;
4686 -> 1637;
4686 -> 1498;
4686 -> 1499;
4686 -> 4671;
4686 -> 1509;
4686 -> 1501;
4687 -> 1652;
4688 -> 4687;
4688 -> 1521;
4689 -> 4688;
4689 -> 1523;
4689 -> 1521;
4690 -> 1519;
4690 -> 1553;
4690 -> 1648;
4690 -> 4689;
4690 -> 1657;
4690 -> 1547;
4690 -> 1548;
4690 -> 4675;
4690 -> 1555;
4690 -> 1552;
4691 -> 1672;
4692 -> 4691;
4692 -> 1567;
4693 -> 4692;
4693 -> 1569;
4693 -> 1567;
4694 -> 1565;
4694 -> 1599;
4694 -> 1668;
4694 -> 4693;
4694 -> 1677;
4694 -> 1593;
4694 -> 1594;
4694 -> 4679;
4694 -> 1601;
4694 -> 1598;
4695 -> 1613;
4696 -> 4695;
4696 -> 1434;
4697 -> 4696;
4697 -> 1436;
4697 -> 1434;
4698 -> 1632;
4699 -> 4698;
4699 -> 1472;
4700 -> 4699;
4700 -> 1474;
4700 -> 1472;
4701 -> 1470;
4701 -> 1502;
4701 -> 1628;
4701 -> 4700;
4701 -> 1637;
4701 -> 1498;
4701 -> 1499;
4701 -> 4686;
4701 -> 1509;
4701 -> 1501;
4702 -> 1652;
4703 -> 4702;
4703 -> 1521;
4704 -> 4703;
4704 -> 1523;
4704 -> 1521;
4705 -> 1519;
4705 -> 1553;
4705 -> 1648;
4705 -> 4704;
4705 -> 1657;
4705 -> 1547;
4705 -> 1548;
4705 -> 4690;
4705 -> 1555;
4705 -> 1552;
4706 -> 1672;
4707 -> 4706;
4707 -> 1567;
4708 -> 4707;
4708 -> 1569;
4708 -> 1567;
4709 -> 1565;
4709 -> 1599;
4709 -> 1668;
4709 -> 4708;
4709 -> 1677;
4709 -> 1593;
4709 -> 1594;
4709 -> 4694;
4709 -> 1601;
4709 -> 1598;
4710 -> 1613;
4711 -> 4710;
4711 -> 1434;
4712 -> 4711;
4712 -> 1436;
4712 -> 1434;
4713 -> 1632;
4714 -> 4713;
4714 -> 1472;
4715 -> 4714;
4715 -> 1474;
4715 -> 1472;
4716 -> 1470;
4716 -> 1502;
4716 -> 1628;
4716 -> 4715;
4716 -> 1637;
4716 -> 1498;
4716 -> 1499;
4716 -> 4701;
4716 -> 1509;
4716 -> 1501;
4717 -> 1652;
4718 -> 4717;
4718 -> 1521;
4719 -> 4718;
4719 -> 1523;
4719 -> 1521;
4720 -> 1519;
4720 -> 1553;
4720 -> 1648;
4720 -> 4719;
4720 -> 1657;
4720 -> 1547;
4720 -> 1548;
4720 -> 4705;
4720 -> 1555;
4720 -> 1552;
4721 -> 1672;
4722 -> 4721;
4722 -> 1567;
4723 -> 4722;
4723 -> 1569;
4723 -> 1567;
4724 -> 1565;
4724 -> 1599;
4724 -> 1668;
4724 -> 4723;
4724 -> 1677;
4724 -> 1593;
4724 -> 1594;
4724 -> 4709;
4724 -> 1601;
4724 -> 1598;
4725 -> 1613;
4726 -> 4725;
4726 -> 1434;
4727 -> 4726;
4727 -> 1436;
4727 -> 1434;
4728 -> 1632;
4729 -> 4728;
4729 -> 1472;
4730 -> 4729;
4730 -> 1474;
4730 -> 1472;
4731 -> 1470;
4731 -> 1502;
4731 -> 1628;
4731 -> 4730;
4731 -> 1637;
4731 -> 1498;
4731 -> 1499;
4731 -> 4716;
4731 -> 1509;
4731 -> 1501;
4732 -> 1652;
4733 -> 4732;
4733 -> 1521;
4734 -> 4733;
4734 -> 1523;
4734 -> 1521;
4735 -> 1519;
4735 -> 1553;
4735 -> 1648;
4735 -> 4734;
4735 -> 1657;
4735 -> 1547;
4735 -> 1548;
4735 -> 4720;
4735 -> 1555;
4735 -> 1552;
4736 -> 1672;
4737 -> 4736;
4737 -> 1567;
4738 -> 4737;
4738 -> 1569;
4738 -> 1567;
4739 -> 1565;
4739 -> 1599;
4739 -> 1668;
4739 -> 4738;
4739 -> 1677;
4739 -> 1593;
4739 -> 1594;
4739 -> 4724;
4739 -> 1601;
4739 -> 1598;
4740 -> 1613;
4741 -> 4740;
4741 -> 1434;
4742 -> 4741;
4742 -> 1436;
4742 -> 1434;
4743 -> 1632;
4744 -> 4743;
4744 -> 1472;
4745 -> 4744;
4745 -> 1474;
4745 -> 1472;
4746 -> 1470;
4746 -> 1502;
4746 -> 1628;
4746 -> 4745;
4746 -> 1637;
4746 -> 1498;
4746 -> 1499;
4746 -> 4731;
4746 -> 1509;
4746 -> 1501;
4747 -> 1652;
4748 -> 4747;
4748 -> 1521;
4749 -> 4748;
4749 -> 1523;
4749 -> 1521;
4750 -> 1519;
4750 -> 1553;
4750 -> 1648;
4750 -> 4749;
4750 -> 1657;
4750 -> 1547;
4750 -> 1548;
4750 -> 4735;
4750 -> 1555;
4750 -> 1552;
4751 -> 1672;
4752 -> 4751;
4752 -> 1567;
4753 -> 4752;
4753 -> 1569;
4753 -> 1567;
4754 -> 1565;
4754 -> 1599;
4754 -> 1668;
4754 -> 4753;
4754 -> 1677;
4754 -> 1593;
4754 -> 1594;
4754 -> 4739;
4754 -> 1601;
4754 -> 1598;
4755 -> 1613;
4756 -> 4755;
4756 -> 1434;
4757 -> 4756;
4757 -> 1436;
4757 -> 1434;
4758 -> 1632;
4759 -> 4758;
4759 -> 1472;
4760 -> 4759;
4760 -> 1474;
4760 -> 1472;
4761 -> 1470;
4761 -> 1502;
4761 -> 1628;
4761 -> 4760;
4761 -> 1637;
4761 -> 1498;
4761 -> 1499;
4761 -> 4746;
4761 -> 1509;
4761 -> 1501;
4762 -> 1652;
4763 -> 4762;
4763 -> 1521;
4764 -> 4763;
4764 -> 1523;
4764 -> 1521;
4765 -> 1519;
4765 -> 1553;
4765 -> 1648;
4765 -> 4764;
4765 -> 1657;
4765 -> 1547;
4765 -> 1548;
4765 -> 4750;
4765 -> 1555;
4765 -> 1552;
4766 -> 1672;
4767 -> 4766;
4767 -> 1567;
4768 -> 4767;
4768 -> 1569;
4768 -> 1567;
4769 -> 1565;
4769 -> 1599;
4769 -> 1668;
4769 -> 4768;
4769 -> 1677;
4769 -> 1593;
4769 -> 1594;
4769 -> 4754;
4769 -> 1601;
4769 -> 1598;
4770 -> 1613;
4771 -> 4770;
4771 -> 1434;
4772 -> 4771;
4772 -> 1436;
4772 -> 1434;
4773 -> 1632;
4774 -> 4773;
4774 -> 1472;
4775 -> 4774;
4775 -> 1474;
4775 -> 1472;
4776 -> 1470;
4776 -> 1502;
4776 -> 1628;
4776 -> 4775;
4776 -> 1637;
4776 -> 1498;
4776 -> 1499;
4776 -> 4761;
4776 -> 1509;
4776 -> 1501;
4777 -> 1652;
4778 -> 4777;
4778 -> 1521;
4779 -> 4778;
4779 -> 1523;
4779 -> 1521;
4780 -> 1519;
4780 -> 1553;
4780 -> 1648;
4780 -> 4779;
4780 -> 1657;
4780 -> 1547;
4780 -> 1548;
4780 -> 4765;
4780 -> 1555;
4780 -> 1552;
4781 -> 1672;
4782 -> 4781;
4782 -> 1567;
4783 -> 4782;
4783 -> 1569;
4783 -> 1567;
4784 -> 1565;
4784 -> 1599;
4784 -> 1668;
4784 -> 4783;
4784 -> 1677;
4784 -> 1593;
4784 -> 1594;
4784 -> 4769;
4784 -> 1601;
4784 -> 1598;
4785 -> 1613;
4786 -> 4785;
4786 -> 1434;
4787 -> 4786;
4787 -> 1436;
4787 -> 1434;
4788 -> 1632;
4789 -> 4788;
4789 -> 1472;
4790 -> 4789;
4790 -> 1474;
4790 -> 1472;
4791 -> 1470;
4791 -> 1502;
4791 -> 1628;
4791 -> 4790;
4791 -> 1637;
4791 -> 1498;
4791 -> 1499;
4791 -> 4776;
4791 -> 1509;
4791 -> 1501;
4792 -> 1652;
4793 -> 4792;
4793 -> 1521;
4794 -> 4793;
4794 -> 1523;
4794 -> 1521;
4795 -> 1519;
4795 -> 1553;
4795 -> 1648;
4795 -> 4794;
4795 -> 1657;
4795 -> 1547;
4795 -> 1548;
4795 -> 4780;
4795 -> 1555;
4795 -> 1552;
4796 -> 1672;
4797 -> 4796;
4797 -> 1567;
4798 -> 4797;
4798 -> 1569;
4798 -> 1567;
4799 -> 1565;
4799 -> 1599;
4799 -> 1668;
4799 -> 4798;
4799 -> 1677;
4799 -> 1593;
4799 -> 1594;
4799 -> 4784;
4799 -> 1601;
4799 -> 1598;
4800 -> 1613;
4801 -> 4800;
4801 -> 1434;
4802 -> 4801;
4802 -> 1436;
4802 -> 1434;
4803 -> 1632;
4804 -> 4803;
4804 -> 1472;
4805 -> 4804;
4805 -> 1474;
4805 -> 1472;
4806 -> 1470;
4806 -> 1502;
4806 -> 1628;
4806 -> 4805;
4806 -> 1637;
4806 -> 1498;
4806 -> 1499;
4806 -> 4791;
4806 -> 1509;
4806 -> 1501;
4807 -> 1652;
4808 -> 4807;
4808 -> 1521;
4809 -> 4808;
4809 -> 1523;
4809 -> 1521;
4810 -> 1519;
4810 -> 1553;
4810 -> 1648;
4810 -> 4809;
4810 -> 1657;
4810 -> 1547;
4810 -> 1548;
4810 -> 4795;
4810 -> 1555;
4810 -> 1552;
4811 -> 1672;
4812 -> 4811;
4812 -> 1567;
4813 -> 4812;
4813 -> 1569;
4813 -> 1567;
4814 -> 1565;
4814 -> 1599;
4814 -> 1668;
4814 -> 4813;
4814 -> 1677;
4814 -> 1593;
4814 -> 1594;
4814 -> 4799;
4814 -> 1601;
4814 -> 1598;
4815 -> 1613;
4816 -> 4815;
4816 -> 1434;
4817 -> 4816;
4817 -> 1436;
4817 -> 1434;
4818 -> 1632;
4819 -> 4818;
4819 -> 1472;
4820 -> 4819;
4820 -> 1474;
4820 -> 1472;
4821 -> 1470;
4821 -> 1502;
4821 -> 1628;
4821 -> 4820;
4821 -> 1637;
4821 -> 1498;
4821 -> 1499;
4821 -> 4806;
4821 -> 1509;
4821 -> 1501;
4822 -> 1652;
4823 -> 4822;
4823 -> 1521;
4824 -> 4823;
4824 -> 1523;
4824 -> 1521;
4825 -> 1519;
4825 -> 1553;
4825 -> 1648;
4825 -> 4824;
4825 -> 1657;
4825 -> 1547;
4825 -> 1548;
4825 -> 4810;
4825 -> 1555;
4825 -> 1552;
4826 -> 1672;
4827 -> 4826;
4827 -> 1567;
4828 -> 4827;
4828 -> 1569;
4828 -> 1567;
4829 -> 1565;
4829 -> 1599;
4829 -> 1668;
4829 -> 4828;
4829 -> 1677;
4829 -> 1593;
4829 -> 1594;
4829 -> 4814;
4829 -> 1601;
4829 -> 1598;
4830 -> 1408;
4830 -> 1406;
4831 -> 1407;
4831 -> 1406;
4832 -> 1409;
4832 -> 1406;
4833 -> 1406;
4834 -> 4830;
4834 -> 4833;
4835 -> 4831;
4835 -> 4833;
4836 -> 4832;
4836 -> 4833;
4837 -> 4834;
4837 -> 1411;
4837 -> 4833;
4838 -> 4833;
4839 -> 4835;
4839 -> 4838;
4839 -> 4833;
4840 -> 4839;
4841 -> 4836;
4841 -> 4840;
4841 -> 4839;
4842 -> 4836;
4842 -> 408;
4842 -> 4841;
4843 -> 1423;
4843 -> 1422;
4843 -> 4834;
4843 -> 4842;
4844 -> 1387;
4845 -> 1391;
4845 -> 4844;
4845 -> 1387;
4846 -> 4843;
4846 -> 1387;
4847 -> 4846;
4847 -> 1155;
4848 -> 1155;
4849 -> 4847;
4849 -> 4848;
4850 -> 1144;
4850 -> 4848;
4851 -> 4848;
4852 -> 4849;
4852 -> 4851;
4852 -> 4848;
4853 -> 4850;
4853 -> 1115;
4853 -> 1151;
4853 -> 1150;
4853 -> 4848;
4854 -> 4850;
4854 -> 1151;
4854 -> 1150;
4854 -> 1115;
4854 -> 4848;
4855 -> 4849;
4855 -> 4854;
4855 -> 4848;
4856 -> 4850;
4856 -> 1115;
4856 -> 4848;
4857 -> 1155;
4858 -> 1155;
4859 -> 4846;
4859 -> 4858;
4860 -> 4859;
4860 -> 4858;
4861 -> 4860;
4861 -> 1155;
4862 -> 1395;
4863 -> 1395;
4864 -> 4863;
4864 -> 1395;
4865 -> 1395;
4866 -> 1395;
4867 -> 1395;
4868 -> 1395;
4869 -> 1395;
4870 -> 1395;
4871 -> 4865;
4871 -> 1395;
4872 -> 4866;
4872 -> 1395;
4873 -> 4867;
4873 -> 1395;
4874 -> 4868;
4874 -> 1395;
4875 -> 4870;
4875 -> 4864;
4875 -> 4871;
4875 -> 4872;
4875 -> 4873;
4875 -> 4874;
4875 -> 1395;
4876 -> 1395;
4877 -> 4875;
4877 -> 4876;
4877 -> 1395;
4878 -> 4869;
4878 -> 4875;
4878 -> 4877;
4879 -> 4877;
4880 -> 4878;
4880 -> 4879;
4881 -> 4879;
4882 -> 4880;
4882 -> 4878;
4882 -> 4881;
4883 -> 4882;
4883 -> 4879;
4884 -> 4879;
4885 -> 4880;
4885 -> 4878;
4885 -> 4884;
4886 -> 4885;
4886 -> 4879;
4887 -> 4879;
4888 -> 4886;
4888 -> 4887;
4889 -> 4880;
4889 -> 4878;
4889 -> 4887;
4890 -> 4879;
4891 -> 4879;
4892 -> 4880;
4892 -> 4891;
4893 -> 4892;
4893 -> 4878;
4893 -> 4888;
4893 -> 4891;
4894 -> 4891;
4895 -> 4892;
4895 -> 4893;
4895 -> 4894;
4896 -> 4895;
4896 -> 4891;
4897 -> 4891;
4898 -> 4897;
4898 -> 4891;
4899 -> 4891;
4900 -> 4891;
4901 -> 4893;
4901 -> 4891;
4902 -> 4893;
4903 -> 4893;
4903 -> 4891;
4904 -> 4903;
4905 -> 4891;
4906 -> 4893;
4906 -> 4891;
4907 -> 4891;
4908 -> 4906;
4908 -> 4907;
4909 -> 4907;
4910 -> 4907;
4911 -> 4908;
4911 -> 4910;
4911 -> 4907;
4912 -> 4911;
4913 -> 4909;
4913 -> 4907;
4914 -> 4913;
4914 -> 4891;
4915 -> 4891;
4916 -> 4914;
4916 -> 4915;
4917 -> 4892;
4917 -> 4915;
4918 -> 4915;
4919 -> 4917;
4919 -> 4893;
4919 -> 4918;
4919 -> 4915;
4920 -> 4919;
4921 -> 4920;
4921 -> 4891;
4922 -> 4891;
4923 -> 4893;
4923 -> 4891;
4924 -> 4921;
4924 -> 4891;
4925 -> 4892;
4925 -> 4891;
4926 -> 4923;
4926 -> 4893;
4926 -> 0;
4926 -> 4891;
4927 -> 4891;
4928 -> 4923;
4928 -> 4893;
4928 -> 4891;
4929 -> 4923;
4929 -> 4893;
4929 -> 4928;
4930 -> 4923;
4930 -> 4893;
4930 -> 4929;
4931 -> 4929;
4932 -> 4930;
4932 -> 4931;
4933 -> 4932;
4933 -> 0;
4933 -> 4931;
4934 -> 4893;
4934 -> 4929;
4935 -> 4923;
4935 -> 4893;
4935 -> 4929;
4936 -> 4929;
4937 -> 4934;
4937 -> 4936;
4938 -> 4935;
4938 -> 4936;
4939 -> 4934;
4939 -> 4936;
4940 -> 4938;
4940 -> 4936;
4941 -> 4937;
4941 -> 4936;
4942 -> 4939;
4942 -> 4936;
4943 -> 4936;
4944 -> 4940;
4944 -> 4943;
4945 -> 4941;
4945 -> 4943;
4946 -> 4942;
4946 -> 4943;
4947 -> 4944;
4947 -> 1411;
4947 -> 4943;
4948 -> 4943;
4949 -> 4945;
4949 -> 4948;
4949 -> 4943;
4950 -> 4949;
4951 -> 4946;
4951 -> 4950;
4951 -> 4949;
4952 -> 1415;
4952 -> 1414;
4952 -> 4944;
4952 -> 4951;
4953 -> 4891;
4954 -> 4924;
4954 -> 4953;
4954 -> 4891;
4955 -> 4952;
4955 -> 4891;
4956 -> 4955;
4956 -> 4879;
4957 -> 4883;
4957 -> 4956;
4957 -> 4879;
4958 -> 4956;
4958 -> 4879;
4959 -> 4865;
4959 -> 4877;
4960 -> 4866;
4960 -> 4877;
4961 -> 4867;
4961 -> 4877;
4962 -> 4868;
4962 -> 4877;
4963 -> 4958;
4963 -> 4877;
4964 -> 4958;
4964 -> 1395;
4965 -> 1395;
4965 -> 4964;
4965 -> 4963;
4966 -> 4965;
4966 -> 1155;
4967 -> 4966;
4967 -> 4848;
4968 -> 4967;
4968 -> 4851;
4968 -> 4848;
4969 -> 4850;
4969 -> 4856;
4969 -> 1151;
4969 -> 1150;
4969 -> 4848;
4970 -> 4850;
4970 -> 1151;
4970 -> 1150;
4970 -> 4856;
4970 -> 4848;
4971 -> 4967;
4971 -> 4970;
4971 -> 4848;
4972 -> 4965;
4972 -> 4858;
4973 -> 4972;
4973 -> 4965;
4973 -> 4858;
4974 -> 4973;
4974 -> 1155;
4975 -> 4965;
4976 -> 4965;
4977 -> 4976;
4977 -> 4965;
4978 -> 4965;
4979 -> 4978;
4979 -> 4965;
4980 -> 4978;
4980 -> 4965;
4981 -> 4980;
4981 -> 4965;
4982 -> 4965;
4983 -> 4965;
4984 -> 4965;
4985 -> 4965;
4986 -> 4985;
4987 -> 4965;
4988 -> 4978;
4989 -> 4978;
4990 -> 4978;
4990 -> 1055;
4991 -> 0;
4991 -> 4978;
4992 -> 4978;
4993 -> 4992;
4993 -> 4978;
4994 -> 0;
4994 -> 4993;
4995 -> 4978;
4995 -> 4994;
4995 -> 4991;
4996 -> 4995;
4996 -> 0;
4996 -> 4978;
4997 -> 0;
4997 -> 4978;
4997 -> 4996;
4998 -> 0;
4998 -> 4978;
4998 -> 4996;
4999 -> 4978;
4999 -> 4995;
4999 -> 4997;
4999 -> 0;
5000 -> 4978;
5000 -> 4995;
5000 -> 4997;
5000 -> 4998;
5000 -> 4965;
5001 -> 4978;
5001 -> 4965;
5002 -> 4965;
5003 -> 5001;
5003 -> 5002;
5004 -> 5002;
5005 -> 5002;
5006 -> 5003;
5006 -> 5005;
5006 -> 5002;
5007 -> 5006;
5008 -> 5007;
5008 -> 5003;
5008 -> 5000;
5008 -> 5006;
5009 -> 5004;
5009 -> 5002;
5010 -> 5009;
5010 -> 4965;
5011 -> 4965;
5012 -> 5010;
5012 -> 5011;
5013 -> 4965;
5013 -> 5011;
5014 -> 5011;
5015 -> 5013;
5015 -> 5000;
5015 -> 5014;
5015 -> 5011;
5016 -> 5015;
5017 -> 5016;
5017 -> 4965;
5018 -> 4965;
5019 -> 4965;
5020 -> 5019;
5020 -> 4965;
5021 -> 5000;
5021 -> 4965;
5022 -> 5000;
5023 -> 5000;
5023 -> 4965;
5024 -> 5023;
5025 -> 5017;
5025 -> 4965;
5026 -> 4965;
5027 -> 5000;
5027 -> 0;
5027 -> 4965;
5028 -> 4965;
5029 -> 5000;
5029 -> 5028;
5029 -> 4965;
5030 -> 4965;
5031 -> 5000;
5032 -> 5000;
5033 -> 5031;
5033 -> 5032;
5034 -> 5031;
5034 -> 5032;
5035 -> 5031;
5035 -> 5032;
5036 -> 5031;
5036 -> 5032;
5037 -> 5031;
5037 -> 5032;
5038 -> 5033;
5038 -> 5032;
5039 -> 5034;
5039 -> 5032;
5040 -> 5035;
5040 -> 5032;
5041 -> 5036;
5041 -> 5032;
5042 -> 5037;
5042 -> 5032;
5043 -> 5032;
5044 -> 5038;
5044 -> 5043;
5045 -> 5039;
5045 -> 5043;
5046 -> 5040;
5046 -> 5043;
5047 -> 5041;
5047 -> 5043;
5048 -> 5042;
5048 -> 5043;
5049 -> 5044;
5049 -> 0;
5049 -> 5043;
5050 -> 5047;
5050 -> 5046;
5050 -> 5043;
5051 -> 5049;
5051 -> 5050;
5051 -> 5043;
5052 -> 5045;
5052 -> 5051;
5053 -> 5046;
5053 -> 5051;
5054 -> 5048;
5054 -> 5051;
5055 -> 5051;
5056 -> 5052;
5056 -> 5055;
5057 -> 5053;
5057 -> 5055;
5058 -> 5054;
5058 -> 5055;
5059 -> 5055;
5060 -> 5056;
5060 -> 5059;
5060 -> 5055;
5061 -> 5060;
5062 -> 5058;
5062 -> 5061;
5062 -> 5060;
5063 -> 5057;
5063 -> 5062;
5064 -> 5062;
5065 -> 5063;
5065 -> 5064;
5067 -> 5065;
5067 -> 5064;
5068 -> 5064;
5069 -> 5064;
5070 -> 5067;
5070 -> 5069;
5071 -> 5068;
5071 -> 5069;
5072 -> 0;
5072 -> 5069;
5073 -> 5070;
5073 -> 5069;
5074 -> 5069;
5075 -> 5072;
5075 -> 5074;
5076 -> 5073;
5076 -> 5074;
5077 -> 5071;
5077 -> 5074;
5078 -> 5075;
5078 -> 5074;
5079 -> 5076;
5079 -> 5074;
5080 -> 5074;
5081 -> 5078;
5081 -> 5080;
5082 -> 5079;
5082 -> 5080;
5083 -> 5077;
5083 -> 5080;
5084 -> 5081;
5084 -> 5080;
5085 -> 5082;
5085 -> 5080;
5086 -> 5080;
5087 -> 5086;
5087 -> 5084;
5087 -> 5085;
5087 -> 5080;
5088 -> 5086;
5088 -> 5080;
5089 -> 5088;
5089 -> 5087;
5089 -> 5080;
5090 -> 5077;
5090 -> 5089;
5090 -> 0;
5090 -> 5074;
5091 -> 5090;
5091 -> 5077;
5091 -> 5074;
5092 -> 5071;
5092 -> 5069;
5093 -> 5070;
5093 -> 5071;
5093 -> 5069;
5094 -> 5068;
5094 -> 5062;
5095 -> 4965;
5096 -> 5025;
5096 -> 5095;
5096 -> 4965;
5097 -> 4977;
5097 -> 5094;
5097 -> 5089;
5097 -> 4965;
5098 -> 4965;
5098 -> 5094;
5098 -> 5000;
5098 -> 5089;
5098 -> 5091;
5098 -> 5092;
5098 -> 5093;
5099 -> 5098;
5099 -> 1155;
5100 -> 5099;
5100 -> 4848;
5101 -> 5100;
5101 -> 4851;
5101 -> 4848;
5102 -> 5100;
5102 -> 4970;
5102 -> 4848;
5103 -> 5098;
5103 -> 4858;
5104 -> 5103;
5104 -> 5098;
5104 -> 4858;
5105 -> 5104;
5105 -> 1155;
5106 -> 5098;
5107 -> 5098;
5108 -> 5107;
5108 -> 5098;
5109 -> 5098;
5110 -> 5098;
5111 -> 5110;
5111 -> 5098;
5112 -> 5098;
5113 -> 5098;
5114 -> 5098;
5115 -> 5098;
5116 -> 5115;
5117 -> 5098;
5118 -> 5098;
5119 -> 5098;
5120 -> 5118;
5120 -> 5119;
5121 -> 5119;
5122 -> 5119;
5123 -> 5120;
5123 -> 5122;
5123 -> 5119;
5124 -> 5123;
5125 -> 5121;
5125 -> 5119;
5126 -> 5125;
5126 -> 5098;
5127 -> 5098;
5128 -> 5126;
5128 -> 5127;
5129 -> 5098;
5129 -> 5127;
5130 -> 5127;
5131 -> 5129;
5131 -> 5098;
5131 -> 5130;
5131 -> 5127;
5132 -> 5131;
5133 -> 5132;
5133 -> 5098;
5134 -> 5098;
5135 -> 5098;
5136 -> 5134;
5136 -> 5135;
5137 -> 5135;
5138 -> 5136;
5138 -> 5107;
5138 -> 5137;
5138 -> 5135;
5139 -> 5138;
5139 -> 5098;
5140 -> 5098;
5141 -> 5107;
5141 -> 5140;
5141 -> 5098;
5142 -> 5107;
5142 -> 5098;
5143 -> 5107;
5144 -> 5107;
5144 -> 5098;
5145 -> 5144;
5146 -> 5133;
5146 -> 5098;
5147 -> 5098;
5148 -> 5098;
5148 -> 0;
5149 -> 5098;
5150 -> 5098;
5151 -> 5098;
5152 -> 5150;
5152 -> 5151;
5153 -> 5152;
5153 -> 0;
5153 -> 5151;
5154 -> 5107;
5154 -> 1411;
5154 -> 5098;
5155 -> 5107;
5155 -> 408;
5156 -> 1423;
5156 -> 1422;
5156 -> 5107;
5156 -> 5155;
5157 -> 5098;
5158 -> 5146;
5158 -> 5157;
5158 -> 5098;
5159 -> 5108;
5159 -> 5156;
5159 -> 5098;
5160 -> 5156;
5160 -> 1155;
5161 -> 5160;
5161 -> 4848;
5162 -> 5161;
5162 -> 4851;
5162 -> 4848;
5163 -> 5161;
5163 -> 4970;
5163 -> 4848;
5164 -> 5156;
5164 -> 4858;
5165 -> 5164;
5165 -> 5156;
5165 -> 4858;
5166 -> 5165;
5166 -> 1155;
5167 -> 5156;
5168 -> 5156;
5169 -> 5156;
5170 -> 5156;
5171 -> 5170;
5171 -> 5156;
5172 -> 5156;
5173 -> 5156;
5174 -> 5156;
5175 -> 5156;
5176 -> 5175;
5177 -> 5156;
5178 -> 5156;
5179 -> 5156;
5180 -> 5178;
5180 -> 5179;
5181 -> 5179;
5182 -> 5179;
5183 -> 5180;
5183 -> 5182;
5183 -> 5179;
5184 -> 5183;
5185 -> 5181;
5185 -> 5179;
5186 -> 5185;
5186 -> 5156;
5187 -> 5156;
5188 -> 5186;
5188 -> 5187;
5189 -> 5156;
5189 -> 5187;
5190 -> 5187;
5191 -> 5189;
5191 -> 5156;
5191 -> 5190;
5191 -> 5187;
5192 -> 5191;
5193 -> 5192;
5193 -> 5156;
5194 -> 5156;
5195 -> 5156;
5196 -> 5194;
5196 -> 5195;
5197 -> 5195;
5198 -> 5196;
5198 -> 5156;
5198 -> 5197;
5198 -> 5195;
5199 -> 5198;
5199 -> 5156;
5200 -> 5156;
5201 -> 5193;
5201 -> 5156;
5202 -> 5156;
5203 -> 5156;
5203 -> 0;
5204 -> 5156;
5205 -> 5156;
5206 -> 5156;
5207 -> 5205;
5207 -> 5206;
5208 -> 5207;
5208 -> 0;
5208 -> 5206;
5209 -> 5156;
5209 -> 1411;
5210 -> 5156;
5211 -> 5201;
5211 -> 5210;
5211 -> 5156;
5212 -> 5168;
5212 -> 5156;
5213 -> 5156;
5214 -> 5156;
5214 -> 1055;
5215 -> 0;
5215 -> 5156;
5216 -> 5156;
5216 -> 5215;
5217 -> 5215;
5218 -> 5216;
5218 -> 5217;
5219 -> 5218;
5219 -> 5217;
5220 -> 5219;
5221 -> 5156;
5221 -> 5215;
5221 -> 0;
5222 -> 5184;
5222 -> 5180;
5222 -> 5215;
5222 -> 5183;
5223 -> 5189;
5223 -> 5215;
5223 -> 5190;
5223 -> 5187;
5224 -> 5223;
5225 -> 5224;
5225 -> 5156;
5226 -> 5215;
5226 -> 5156;
5227 -> 5215;
5228 -> 5156;
5228 -> 5215;
5229 -> 5215;
5230 -> 5228;
5230 -> 5229;
5231 -> 5229;
5232 -> 5230;
5232 -> 5215;
5232 -> 5231;
5232 -> 5229;
5233 -> 5232;
5233 -> 5215;
5234 -> 5215;
5235 -> 5215;
5236 -> 5215;
5236 -> 5156;
5237 -> 5236;
5238 -> 5225;
5238 -> 5156;
5239 -> 5215;
5239 -> 0;
5239 -> 5156;
5240 -> 5215;
5241 -> 5215;
5242 -> 5240;
5242 -> 5241;
5243 -> 5242;
5243 -> 0;
5243 -> 5241;
5244 -> 5215;
5244 -> 1411;
5245 -> 5238;
5245 -> 5210;
5245 -> 5156;
5246 -> 5168;
5246 -> 5215;
5246 -> 5156;
5247 -> 5215;
5247 -> 1155;
5248 -> 5247;
5248 -> 4848;
5249 -> 5248;
5249 -> 4851;
5249 -> 4848;
5250 -> 5248;
5250 -> 4970;
5250 -> 4848;
5251 -> 5215;
5251 -> 4858;
5252 -> 5251;
5252 -> 5215;
5252 -> 4858;
5253 -> 5252;
5253 -> 1155;
5254 -> 5215;
5255 -> 5215;
5256 -> 5215;
5257 -> 5215;
5258 -> 5257;
5258 -> 5215;
5259 -> 5215;
5260 -> 5215;
5261 -> 5260;
5262 -> 5215;
5263 -> 5215;
5264 -> 5215;
5264 -> 1055;
5265 -> 5215;
5265 -> 0;
5266 -> 5215;
5267 -> 5215;
5268 -> 5266;
5268 -> 5267;
5269 -> 5267;
5270 -> 5267;
5271 -> 5268;
5271 -> 5270;
5271 -> 5267;
5272 -> 5271;
5273 -> 5269;
5273 -> 5267;
5274 -> 5273;
5274 -> 5215;
5275 -> 5215;
5276 -> 5274;
5276 -> 5275;
5277 -> 5215;
5277 -> 5275;
5278 -> 5275;
5279 -> 5277;
5279 -> 5215;
5279 -> 5278;
5279 -> 5275;
5280 -> 5279;
5281 -> 5280;
5281 -> 5215;
5282 -> 5281;
5282 -> 5215;
5283 -> 5215;
5284 -> 5215;
5284 -> 0;
5285 -> 5215;
5286 -> 5215;
5287 -> 5215;
5288 -> 5282;
5288 -> 5287;
5288 -> 5215;
5289 -> 5255;
5289 -> 5215;
5290 -> 5251;
5290 -> 4858;
5291 -> 5290;
5291 -> 1155;
5292 -> 5215;
5293 -> 5292;
5293 -> 5229;
5294 -> 5293;
5294 -> 5215;
5294 -> 5231;
5294 -> 5229;
5295 -> 5294;
5295 -> 5215;
5296 -> 5215;
5297 -> 5296;
5297 -> 5215;
5298 -> 5297;
5299 -> 5298;
5299 -> 5215;
5300 -> 993;
5300 -> 5299;
5301 -> 5300;
5302 -> 5300;
5302 -> 5301;
5303 -> 5301;
5304 -> 5302;
5304 -> 5303;
5305 -> 5303;
5306 -> 5304;
5306 -> 5305;
5306 -> 5303;
5307 -> 5304;
5307 -> 5303;
5308 -> 5300;
5308 -> 5306;
5309 -> 5306;
5310 -> 5308;
5310 -> 5309;
5311 -> 5309;
5312 -> 5310;
5312 -> 5311;
5312 -> 5309;
5313 -> 5300;
5313 -> 5215;
5314 -> 5313;
5315 -> 5296;
5315 -> 5215;
5316 -> 5296;
5316 -> 5215;
5317 -> 5316;
5317 -> 5215;
5318 -> 5296;
5319 -> 5296;
5320 -> 5319;
5321 -> 5320;
5321 -> 5296;
5322 -> 993;
5322 -> 5321;
5323 -> 5296;
5324 -> 5323;
5324 -> 5322;
5324 -> 5296;
5325 -> 5296;
5326 -> 5323;
5326 -> 5325;
5327 -> 5326;
5327 -> 5322;
5327 -> 5325;
5328 -> 5327;
5328 -> 5296;
5329 -> 0;
5331 -> 5329;
5331 -> 5330;
5332 -> 5330;
5333 -> 5331;
5333 -> 5332;
5333 -> 5330;
5334 -> 5330;
5337 -> 5335;
5337 -> 5336;
5338 -> 5336;
5339 -> 5337;
5339 -> 5338;
5339 -> 5336;
5340 -> 5336;
5341 -> 5296;
5342 -> 5341;
5342 -> 5328;
5342 -> 5296;
5343 -> 5296;
5344 -> 5342;
5344 -> 5343;
5345 -> 5344;
5345 -> 5343;
5346 -> 5343;
5347 -> 5345;
5347 -> 5346;
5347 -> 5343;
5348 -> 5345;
5348 -> 5343;
5349 -> 5296;
5350 -> 5348;
5350 -> 5349;
5350 -> 5296;
5351 -> 5296;
5352 -> 5351;
5352 -> 5350;
5352 -> 5296;
5353 -> 5296;
5354 -> 5352;
5354 -> 5353;
5355 -> 5353;
5356 -> 5354;
5356 -> 5355;
5356 -> 5353;
5357 -> 5296;
5358 -> 5354;
5358 -> 5357;
5358 -> 5296;
5359 -> 5296;
5359 -> 5215;
5360 -> 5359;
5360 -> 5267;
5361 -> 5360;
5361 -> 5270;
5361 -> 5267;
5362 -> 5361;
5363 -> 5362;
5363 -> 5360;
5363 -> 5358;
5363 -> 5361;
5364 -> 5277;
5364 -> 5358;
5364 -> 5278;
5364 -> 5275;
5365 -> 5364;
5366 -> 5365;
5366 -> 5215;
5367 -> 5358;
5368 -> 5358;
5368 -> 5367;
5369 -> 5367;
5370 -> 5368;
5370 -> 5369;
5371 -> 5369;
5372 -> 5370;
5372 -> 5371;
5372 -> 5369;
5373 -> 5370;
5373 -> 5369;
5374 -> 5358;
5374 -> 5372;
5375 -> 5372;
5376 -> 5374;
5376 -> 5375;
5377 -> 5375;
5378 -> 5376;
5378 -> 5377;
5378 -> 5375;
5379 -> 5358;
5379 -> 5215;
5380 -> 5379;
5381 -> 5366;
5381 -> 5215;
5382 -> 5358;
5382 -> 0;
5382 -> 5215;
5383 -> 5358;
5384 -> 5358;
5385 -> 5383;
5385 -> 5384;
5386 -> 5383;
5386 -> 5384;
5387 -> 5383;
5387 -> 5384;
5388 -> 5386;
5388 -> 1411;
5388 -> 5384;
5389 -> 5381;
5389 -> 5287;
5389 -> 5215;
5390 -> 5386;
5390 -> 1155;
5391 -> 5390;
5391 -> 4848;
5392 -> 5391;
5392 -> 4851;
5392 -> 4848;
5393 -> 5391;
5393 -> 4970;
5393 -> 4848;
5394 -> 5386;
5394 -> 4858;
5395 -> 5394;
5395 -> 4858;
5396 -> 5395;
5396 -> 1155;
5397 -> 1142;
5398 -> 1079;
5399 -> 5398;
5399 -> 1085;
5399 -> 1079;
5400 -> 1085;
5400 -> 1079;
5401 -> 1085;
5401 -> 1079;
5402 -> 1085;
5402 -> 1079;
5403 -> 1085;
5403 -> 1079;
5404 -> 1085;
5404 -> 1079;
5405 -> 1085;
5405 -> 1079;
5406 -> 1079;
5407 -> 5406;
5407 -> 1085;
5407 -> 1079;
5408 -> 1085;
5408 -> 5407;
5408 -> 1079;
5409 -> 1079;
5410 -> 5409;
5410 -> 1085;
5410 -> 1079;
5411 -> 1078;
5411 -> 890;
5412 -> 890;
5413 -> 5411;
5413 -> 5412;
5414 -> 5413;
5414 -> 5412;
5415 -> 0;
5415 -> 5412;
5416 -> 5412;
5417 -> 5414;
5417 -> 5416;
5418 -> 5415;
5418 -> 5416;
5419 -> 5413;
5419 -> 5416;
5420 -> 5416;
5421 -> 5419;
5421 -> 5402;
5421 -> 5420;
5421 -> 5416;
5422 -> 5417;
5422 -> 5414;
5422 -> 1119;
5422 -> 1127;
5422 -> 1121;
5422 -> 1120;
5422 -> 1110;
5422 -> 1151;
5422 -> 1112;
5422 -> 1113;
5422 -> 1114;
5422 -> 4856;
5422 -> 1116;
5422 -> 1117;
5422 -> 1118;
5422 -> 1122;
5422 -> 1124;
5422 -> 1134;
5422 -> 5399;
5422 -> 5407;
5422 -> 5410;
5422 -> 5402;
5422 -> 5403;
5422 -> 5404;
5422 -> 5405;
5422 -> 5358;
5422 -> 1078;
5422 -> 1123;
5422 -> 1133;
5422 -> 1150;
5422 -> 5398;
5422 -> 5408;
5422 -> 5416;
5423 -> 5416;
5424 -> 5422;
5424 -> 5423;
5425 -> 5423;
5426 -> 5424;
5426 -> 5425;
5427 -> 5426;
5427 -> 5422;
5427 -> 5425;
5428 -> 5426;
5428 -> 5427;
5428 -> 5425;
5429 -> 5426;
5429 -> 5427;
5429 -> 0;
5429 -> 5425;
5430 -> 5429;
5430 -> 5426;
5430 -> 5425;
5431 -> 5425;
5432 -> 5426;
5432 -> 5431;
5433 -> 5431;
5434 -> 5432;
5434 -> 5433;
5435 -> 5433;
5436 -> 5434;
5436 -> 5435;
5437 -> 5436;
5437 -> 5427;
5437 -> 5435;
5438 -> 5435;
5439 -> 5436;
5439 -> 5427;
5439 -> 5438;
5439 -> 5435;
5440 -> 5436;
5440 -> 5427;
5440 -> 5430;
5440 -> 5439;
5441 -> 5440;
5441 -> 5433;
5442 -> 5441;
5442 -> 5434;
5442 -> 5433;
5443 -> 5442;
5443 -> 5431;
5444 -> 5431;
5445 -> 5443;
5445 -> 5444;
5446 -> 5445;
5446 -> 5427;
5446 -> 5444;
5447 -> 5446;
5447 -> 5425;
5448 -> 5428;
5448 -> 5426;
5448 -> 5425;
5449 -> 5427;
5449 -> 5430;
5449 -> 5448;
5449 -> 5442;
5449 -> 5425;
5450 -> 5427;
5450 -> 5425;
5451 -> 5426;
5451 -> 5449;
5451 -> 5450;
5451 -> 5425;
5452 -> 5423;
5453 -> 5452;
5453 -> 5423;
5454 -> 5423;
5455 -> 5449;
5455 -> 5454;
5456 -> 5453;
5456 -> 5454;
5457 -> 5424;
5457 -> 5454;
5458 -> 5455;
5458 -> 5454;
5459 -> 5456;
5459 -> 5454;
5460 -> 5454;
5461 -> 5458;
5461 -> 5460;
5462 -> 5459;
5462 -> 5460;
5463 -> 5457;
5463 -> 5460;
5464 -> 5460;
5465 -> 5463;
5465 -> 5464;
5466 -> 5464;
5467 -> 5465;
5467 -> 5466;
5468 -> 5467;
5468 -> 5451;
5468 -> 5466;
5469 -> 5468;
5469 -> 5464;
5470 -> 5469;
5471 -> 5470;
5471 -> 5460;
5472 -> 5471;
5472 -> 5454;
5473 -> 5454;
5474 -> 5457;
5474 -> 5473;
5475 -> 5473;
5476 -> 5474;
5476 -> 5475;
5477 -> 5475;
5478 -> 5476;
5478 -> 5477;
5479 -> 5478;
5479 -> 5451;
5479 -> 5477;
5480 -> 5479;
5480 -> 5475;
5481 -> 5475;
5482 -> 5476;
5482 -> 5451;
5482 -> 5481;
5482 -> 5475;
5483 -> 5480;
5483 -> 5476;
5483 -> 5482;
5484 -> 5476;
5484 -> 5451;
5484 -> 5475;
5485 -> 5476;
5485 -> 5451;
5485 -> 5484;
5485 -> 5475;
5486 -> 5476;
5486 -> 5451;
5486 -> 5475;
5487 -> 5480;
5487 -> 5475;
5488 -> 5485;
5488 -> 5486;
5488 -> 5487;
5488 -> 5451;
5488 -> 5483;
5488 -> 5484;
5488 -> 5475;
5489 -> 5488;
5489 -> 5473;
5490 -> 5474;
5490 -> 5488;
5490 -> 5473;
5491 -> 5473;
5492 -> 5473;
5493 -> 5489;
5493 -> 5492;
5494 -> 5490;
5494 -> 5492;
5495 -> 5490;
5495 -> 5492;
5496 -> 5490;
5496 -> 5492;
5497 -> 5490;
5497 -> 5492;
5498 -> 5491;
5498 -> 5492;
5499 -> 5493;
5499 -> 5498;
5499 -> 5492;
5500 -> 5494;
5500 -> 5498;
5500 -> 5492;
5501 -> 5495;
5501 -> 5498;
5501 -> 5492;
5502 -> 5496;
5502 -> 5498;
5502 -> 5492;
5503 -> 5497;
5503 -> 5498;
5503 -> 5492;
5504 -> 5491;
5504 -> 5454;
5505 -> 5457;
5505 -> 5488;
5505 -> 5454;
5506 -> 5457;
5506 -> 5488;
5506 -> 5505;
5506 -> 5454;
5507 -> 5454;
5508 -> 5454;
5509 -> 5457;
5509 -> 5508;
5510 -> 5509;
5510 -> 5488;
5510 -> 5508;
5511 -> 5510;
5511 -> 5454;
5512 -> 5454;
5513 -> 5511;
5513 -> 5512;
5514 -> 5513;
5514 -> 5488;
5514 -> 5512;
5515 -> 5455;
5515 -> 5514;
5516 -> 5514;
5517 -> 5515;
5517 -> 5516;
5518 -> 5457;
5518 -> 5516;
5519 -> 5516;
5520 -> 5518;
5520 -> 5519;
5521 -> 5520;
5521 -> 5516;
5522 -> 5516;
5523 -> 5521;
5523 -> 5522;
5524 -> 0;
5524 -> 5516;
5525 -> 5516;
5526 -> 5524;
5526 -> 5525;
5527 -> 5518;
5527 -> 5525;
5528 -> 5526;
5528 -> 5525;
5529 -> 5525;
5530 -> 5528;
5530 -> 5529;
5531 -> 5530;
5531 -> 0;
5531 -> 5529;
5532 -> 5531;
5533 -> 5525;
5534 -> 5527;
5534 -> 5533;
5535 -> 5534;
5535 -> 5525;
5536 -> 5525;
5537 -> 5535;
5537 -> 5536;
5538 -> 5537;
5538 -> 5525;
5539 -> 5538;
5539 -> 5526;
5539 -> 5525;
5540 -> 5539;
5541 -> 5527;
5541 -> 5540;
5542 -> 5540;
5543 -> 5541;
5543 -> 5488;
5543 -> 5542;
5544 -> 5543;
5544 -> 5488;
5544 -> 5542;
5545 -> 5544;
5545 -> 5540;
5546 -> 5545;
5546 -> 5541;
5546 -> 5540;
5547 -> 5540;
5548 -> 5547;
5548 -> 5541;
5548 -> 5540;
5549 -> 5540;
5550 -> 5541;
5550 -> 5488;
5550 -> 5549;
5550 -> 5540;
5551 -> 5541;
5551 -> 5488;
5551 -> 5540;
5552 -> 5539;
5553 -> 5535;
5553 -> 5539;
5554 -> 5516;
5555 -> 5518;
5555 -> 5554;
5556 -> 0;
5556 -> 5554;
5557 -> 5554;
5558 -> 5556;
5558 -> 5557;
5559 -> 5555;
5559 -> 5557;
5560 -> 5559;
5560 -> 5488;
5560 -> 5505;
5560 -> 5557;
5561 -> 5559;
5561 -> 5488;
5561 -> 5505;
5561 -> 5560;
5561 -> 5557;
5562 -> 5558;
5562 -> 5557;
5563 -> 5557;
5564 -> 5562;
5564 -> 5563;
5565 -> 5559;
5565 -> 5563;
5566 -> 5563;
5567 -> 5563;
5568 -> 5563;
5569 -> 5565;
5569 -> 5568;
5570 -> 5569;
5570 -> 5488;
5570 -> 5551;
5570 -> 5568;
5571 -> 5569;
5571 -> 5488;
5571 -> 5505;
5571 -> 5560;
5571 -> 5546;
5571 -> 5548;
5571 -> 5551;
5572 -> 5571;
5572 -> 5563;
5573 -> 5563;
5574 -> 5572;
5574 -> 5573;
5575 -> 5574;
5575 -> 5563;
5576 -> 5563;
5577 -> 5575;
5577 -> 5576;
5578 -> 5577;
5578 -> 5576;
5579 -> 5578;
5580 -> 5574;
5580 -> 5563;
5581 -> 5563;
5582 -> 5580;
5582 -> 5581;
5583 -> 5582;
5583 -> 5581;
5584 -> 5581;
5585 -> 5583;
5585 -> 5584;
5586 -> 5585;
5586 -> 5584;
5587 -> 5584;
5588 -> 5586;
5588 -> 5587;
5589 -> 5588;
5589 -> 5587;
5590 -> 0;
5590 -> 5589;
5591 -> 5574;
5591 -> 0;
5591 -> 5590;
5592 -> 5591;
5593 -> 5565;
5593 -> 5592;
5594 -> 5592;
5595 -> 5593;
5595 -> 5594;
5596 -> 5595;
5596 -> 5592;
5597 -> 5592;
5598 -> 5596;
5598 -> 5597;
5599 -> 5597;
5600 -> 5598;
5600 -> 5599;
5601 -> 5600;
5601 -> 5597;
5602 -> 5592;
5603 -> 5602;
5603 -> 5591;
5604 -> 5603;
5605 -> 5603;
5606 -> 5604;
5606 -> 5605;
5607 -> 5604;
5607 -> 5605;
5608 -> 5565;
5608 -> 5605;
5609 -> 5605;
5610 -> 5608;
5610 -> 5609;
5611 -> 5610;
5611 -> 5605;
5612 -> 5605;
5613 -> 5611;
5613 -> 5612;
5614 -> 5612;
5615 -> 5613;
5615 -> 5614;
5616 -> 5615;
5616 -> 5612;
5617 -> 5605;
5618 -> 5617;
5618 -> 5603;
5619 -> 5618;
5620 -> 5619;
5620 -> 5618;
5621 -> 5618;
5622 -> 5620;
5622 -> 5621;
5623 -> 5621;
5624 -> 5622;
5624 -> 5623;
5625 -> 5624;
5625 -> 5621;
5626 -> 5574;
5626 -> 0;
5626 -> 5625;
5627 -> 5564;
5627 -> 5626;
5628 -> 5626;
5629 -> 5627;
5629 -> 5628;
5630 -> 5565;
5630 -> 5628;
5631 -> 5629;
5631 -> 0;
5631 -> 5628;
5632 -> 5628;
5633 -> 5630;
5633 -> 5632;
5634 -> 5633;
5634 -> 5628;
5635 -> 5628;
5636 -> 5634;
5636 -> 5635;
5637 -> 5635;
5638 -> 5636;
5638 -> 5637;
5639 -> 5638;
5639 -> 5635;
5640 -> 5628;
5641 -> 5630;
5641 -> 5640;
5642 -> 5641;
5642 -> 5628;
5643 -> 5628;
5644 -> 5642;
5644 -> 5643;
5645 -> 5628;
5646 -> 5644;
5646 -> 5645;
5647 -> 5646;
5647 -> 5645;
5648 -> 5645;
5649 -> 5647;
5649 -> 5648;
5650 -> 5649;
5650 -> 5648;
5651 -> 5650;
5652 -> 5639;
5652 -> 5651;
5652 -> 5628;
5653 -> 5631;
5653 -> 5652;
5653 -> 5628;
5654 -> 5653;
5655 -> 5564;
5655 -> 5654;
5656 -> 5654;
5657 -> 5655;
5657 -> 5656;
5658 -> 5565;
5658 -> 5656;
5659 -> 5657;
5659 -> 5656;
5660 -> 5656;
5661 -> 5659;
5661 -> 5660;
5662 -> 5658;
5662 -> 5660;
5663 -> 5660;
5664 -> 5662;
5664 -> 5663;
5665 -> 5664;
5665 -> 5660;
5666 -> 5660;
5667 -> 5665;
5667 -> 5666;
5668 -> 5667;
5668 -> 5660;
5669 -> 5661;
5669 -> 5668;
5670 -> 5668;
5671 -> 5669;
5671 -> 5670;
5672 -> 5662;
5672 -> 5670;
5673 -> 5670;
5674 -> 5672;
5674 -> 5673;
5675 -> 5674;
5675 -> 5670;
5676 -> 5670;
5677 -> 5675;
5677 -> 5676;
5678 -> 5670;
5679 -> 5672;
5679 -> 5678;
5680 -> 5679;
5680 -> 5678;
5681 -> 5678;
5682 -> 5678;
5683 -> 5680;
5683 -> 5682;
5684 -> 5680;
5684 -> 5682;
5685 -> 5680;
5685 -> 5682;
5686 -> 5680;
5686 -> 5682;
5687 -> 5680;
5687 -> 5682;
5688 -> 5681;
5688 -> 5682;
5689 -> 5683;
5689 -> 5688;
5689 -> 5682;
5690 -> 5684;
5690 -> 5688;
5690 -> 5682;
5691 -> 5685;
5691 -> 5688;
5691 -> 5682;
5692 -> 5686;
5692 -> 5688;
5692 -> 5682;
5693 -> 5687;
5693 -> 5688;
5693 -> 5682;
5694 -> 5681;
5694 -> 5670;
5695 -> 5671;
5695 -> 5670;
5696 -> 5670;
5697 -> 5695;
5697 -> 5696;
5698 -> 5672;
5698 -> 5696;
5699 -> 5697;
5699 -> 0;
5699 -> 5696;
5700 -> 5696;
5701 -> 5696;
5702 -> 5700;
5702 -> 5701;
5703 -> 5698;
5703 -> 5701;
5704 -> 5701;
5705 -> 5702;
5705 -> 5704;
5705 -> 5701;
5706 -> 5703;
5706 -> 5679;
5706 -> 5702;
5706 -> 5701;
5707 -> 5701;
5708 -> 5703;
5708 -> 5679;
5708 -> 5707;
5708 -> 5701;
5709 -> 5703;
5709 -> 5679;
5709 -> 5702;
5709 -> 5708;
5710 -> 5696;
5711 -> 5709;
5711 -> 5710;
5712 -> 5696;
5713 -> 5698;
5713 -> 5712;
5714 -> 5713;
5714 -> 5679;
5714 -> 5712;
5715 -> 5714;
5715 -> 5696;
5716 -> 5711;
5716 -> 5715;
5716 -> 5696;
5717 -> 5696;
5718 -> 5700;
5718 -> 5717;
5719 -> 5698;
5719 -> 5717;
5720 -> 5717;
5721 -> 5718;
5721 -> 5720;
5721 -> 5717;
5722 -> 5719;
5722 -> 5679;
5722 -> 5718;
5722 -> 5717;
5723 -> 5717;
5724 -> 5719;
5724 -> 5679;
5724 -> 5723;
5724 -> 5717;
5725 -> 5719;
5725 -> 5679;
5725 -> 5718;
5725 -> 5724;
5726 -> 5696;
5727 -> 5725;
5727 -> 5726;
5728 -> 5716;
5728 -> 5727;
5728 -> 5696;
5729 -> 5696;
5730 -> 5696;
5731 -> 5729;
5731 -> 5730;
5732 -> 5698;
5732 -> 5730;
5733 -> 5730;
5734 -> 5731;
5734 -> 5733;
5734 -> 5730;
5735 -> 5732;
5735 -> 5679;
5735 -> 5731;
5735 -> 5730;
5736 -> 5730;
5737 -> 5732;
5737 -> 5679;
5737 -> 5736;
5737 -> 5730;
5738 -> 5732;
5738 -> 5679;
5738 -> 5731;
5738 -> 5737;
5739 -> 5696;
5740 -> 5738;
5740 -> 5739;
5741 -> 5698;
5741 -> 5739;
5742 -> 5739;
5743 -> 5740;
5743 -> 5742;
5744 -> 5743;
5744 -> 5739;
5745 -> 5739;
5746 -> 5741;
5746 -> 5745;
5747 -> 5746;
5747 -> 5679;
5747 -> 5745;
5748 -> 5747;
5748 -> 5739;
5749 -> 5744;
5749 -> 5748;
5749 -> 5739;
5750 -> 5696;
5751 -> 5729;
5751 -> 5750;
5752 -> 5698;
5752 -> 5750;
5753 -> 5750;
5754 -> 5751;
5754 -> 5753;
5754 -> 5750;
5755 -> 5752;
5755 -> 5679;
5755 -> 5751;
5755 -> 5750;
5756 -> 5750;
5757 -> 5752;
5757 -> 5679;
5757 -> 5756;
5757 -> 5750;
5758 -> 5752;
5758 -> 5679;
5758 -> 5751;
5758 -> 5757;
5759 -> 5696;
5760 -> 5758;
5760 -> 5759;
5761 -> 5749;
5761 -> 5760;
5761 -> 5696;
5762 -> 5696;
5763 -> 5729;
5763 -> 5762;
5764 -> 5698;
5764 -> 5762;
5765 -> 5762;
5766 -> 5763;
5766 -> 5765;
5766 -> 5762;
5767 -> 5764;
5767 -> 5679;
5767 -> 5763;
5767 -> 5762;
5768 -> 5762;
5769 -> 5764;
5769 -> 5679;
5769 -> 5768;
5769 -> 5762;
5770 -> 5764;
5770 -> 5679;
5770 -> 5763;
5770 -> 5769;
5771 -> 5696;
5772 -> 5770;
5772 -> 5771;
5773 -> 5761;
5773 -> 5772;
5773 -> 5696;
5774 -> 5696;
5775 -> 5696;
5776 -> 5774;
5776 -> 5775;
5777 -> 5698;
5777 -> 5775;
5778 -> 5775;
5779 -> 5776;
5779 -> 5778;
5779 -> 5775;
5780 -> 5777;
5780 -> 5679;
5780 -> 5776;
5780 -> 5775;
5781 -> 5775;
5782 -> 5777;
5782 -> 5679;
5782 -> 5781;
5782 -> 5775;
5783 -> 5777;
5783 -> 5679;
5783 -> 5776;
5783 -> 5782;
5784 -> 5696;
5785 -> 5783;
5785 -> 5784;
5786 -> 5696;
5787 -> 5696;
5788 -> 5786;
5788 -> 5787;
5789 -> 5698;
5789 -> 5787;
5790 -> 5787;
5791 -> 5788;
5791 -> 5790;
5791 -> 5787;
5792 -> 5789;
5792 -> 5679;
5792 -> 5788;
5792 -> 5787;
5793 -> 5787;
5794 -> 5789;
5794 -> 5679;
5794 -> 5793;
5794 -> 5787;
5795 -> 5789;
5795 -> 5679;
5795 -> 5788;
5795 -> 5794;
5796 -> 5696;
5797 -> 5795;
5797 -> 5796;
5798 -> 5696;
5799 -> 5798;
5799 -> 5670;
5800 -> 5670;
5801 -> 5670;
5802 -> 5800;
5802 -> 5801;
5803 -> 5672;
5803 -> 5801;
5804 -> 5801;
5805 -> 5803;
5805 -> 5804;
5806 -> 5805;
5806 -> 5679;
5806 -> 5804;
5807 -> 5806;
5807 -> 5801;
5808 -> 5801;
5809 -> 5807;
5809 -> 5808;
5810 -> 5801;
5811 -> 5803;
5811 -> 5810;
5812 -> 5810;
5813 -> 5811;
5813 -> 5812;
5814 -> 5813;
5814 -> 5679;
5814 -> 5812;
5815 -> 5814;
5815 -> 5810;
5816 -> 5810;
5817 -> 5811;
5817 -> 5816;
5818 -> 5817;
5818 -> 5679;
5818 -> 5816;
5819 -> 5816;
5820 -> 5819;
5820 -> 5817;
5820 -> 5816;
5821 -> 5816;
5822 -> 5817;
5822 -> 5679;
5822 -> 5821;
5822 -> 5816;
5823 -> 5817;
5823 -> 5679;
5823 -> 5816;
5824 -> 5810;
5825 -> 5815;
5825 -> 5810;
5826 -> 5825;
5826 -> 5801;
5827 -> 5802;
5827 -> 5801;
5828 -> 5801;
5829 -> 5827;
5829 -> 5828;
5830 -> 5803;
5830 -> 5828;
5831 -> 5828;
5832 -> 5829;
5832 -> 5828;
5833 -> 5828;
5834 -> 5831;
5834 -> 5833;
5835 -> 5832;
5835 -> 5833;
5836 -> 5830;
5836 -> 5833;
5837 -> 5835;
5837 -> 5833;
5838 -> 0;
5838 -> 5837;
5839 -> 5834;
5839 -> 5833;
5840 -> 5838;
5840 -> 5839;
5840 -> 5836;
5840 -> 5679;
5840 -> 5820;
5840 -> 5817;
5840 -> 5823;
5840 -> 5833;
5841 -> 5833;
5842 -> 5840;
5842 -> 5841;
5843 -> 5840;
5843 -> 5841;
5844 -> 5840;
5844 -> 5841;
5845 -> 5841;
5846 -> 5843;
5846 -> 5845;
5846 -> 5841;
5847 -> 5844;
5847 -> 5840;
5847 -> 5843;
5847 -> 5841;
5848 -> 5841;
5849 -> 5844;
5849 -> 5840;
5849 -> 5848;
5849 -> 5841;
5850 -> 5844;
5850 -> 5840;
5850 -> 5843;
5850 -> 5849;
5851 -> 5840;
5851 -> 5841;
5852 -> 5840;
5852 -> 5841;
5853 -> 5841;
5854 -> 5852;
5854 -> 5853;
5855 -> 5854;
5855 -> 5850;
5855 -> 5853;
5856 -> 5855;
5856 -> 5841;
5857 -> 5841;
5858 -> 5856;
5858 -> 5857;
5859 -> 5841;
5860 -> 5852;
5860 -> 5859;
5861 -> 5859;
5862 -> 5860;
5862 -> 5861;
5863 -> 5862;
5863 -> 5850;
5863 -> 5861;
5864 -> 5863;
5864 -> 5859;
5865 -> 5859;
5866 -> 5864;
5866 -> 5865;
5867 -> 5866;
5868 -> 5860;
5868 -> 5867;
5869 -> 5867;
5870 -> 5868;
5870 -> 5869;
5871 -> 5870;
5871 -> 5867;
5872 -> 5867;
5873 -> 5871;
5873 -> 5872;
5874 -> 5867;
5875 -> 5874;
5875 -> 5866;
5876 -> 5866;
5877 -> 5860;
5877 -> 5876;
5878 -> 5876;
5879 -> 5877;
5879 -> 5878;
5880 -> 5879;
5880 -> 5850;
5880 -> 5878;
5881 -> 5880;
5881 -> 5876;
5882 -> 5881;
5882 -> 5866;
5883 -> 5875;
5883 -> 5882;
5883 -> 5866;
5884 -> 5866;
5885 -> 5860;
5885 -> 5884;
5886 -> 5884;
5887 -> 5885;
5887 -> 5886;
5888 -> 5887;
5888 -> 5884;
5889 -> 5884;
5890 -> 5888;
5890 -> 5889;
5891 -> 5890;
5891 -> 5866;
5892 -> 5883;
5892 -> 5891;
5892 -> 5866;
5893 -> 5892;
5894 -> 5893;
5894 -> 5841;
5895 -> 5858;
5895 -> 5894;
5895 -> 5841;
5896 -> 5841;
5897 -> 5852;
5897 -> 5896;
5898 -> 5896;
5899 -> 5897;
5899 -> 5898;
5900 -> 5899;
5900 -> 5850;
5900 -> 5898;
5901 -> 5900;
5901 -> 5896;
5902 -> 5896;
5903 -> 5897;
5903 -> 5850;
5903 -> 5902;
5904 -> 5902;
5905 -> 5902;
5906 -> 5897;
5906 -> 5850;
5906 -> 5905;
5906 -> 5902;
5907 -> 5897;
5907 -> 5850;
5907 -> 5902;
5908 -> 5896;
5909 -> 5901;
5909 -> 5896;
5910 -> 5909;
5910 -> 5841;
5911 -> 5841;
5912 -> 5852;
5912 -> 5911;
5913 -> 5912;
5913 -> 5850;
5913 -> 5907;
5913 -> 5911;
5914 -> 5912;
5914 -> 5850;
5914 -> 5911;
5915 -> 5912;
5915 -> 5850;
5915 -> 5897;
5915 -> 5907;
5915 -> 5914;
5916 -> 5915;
5916 -> 5841;
5917 -> 5841;
5918 -> 5916;
5918 -> 5917;
5919 -> 0;
5919 -> 5918;
5920 -> 5910;
5920 -> 5919;
5920 -> 5850;
5920 -> 5897;
5920 -> 5915;
5920 -> 5907;
5920 -> 5833;
5921 -> 5910;
5921 -> 5841;
5922 -> 5841;
5923 -> 5921;
5923 -> 5922;
5924 -> 5923;
5924 -> 5920;
5924 -> 5922;
5925 -> 5924;
5925 -> 5841;
5926 -> 5841;
5927 -> 5925;
5927 -> 5926;
5928 -> 5841;
5929 -> 5921;
5929 -> 5928;
5930 -> 5929;
5930 -> 5920;
5930 -> 5928;
5931 -> 5930;
5931 -> 5841;
5932 -> 5841;
5933 -> 5931;
5933 -> 5932;
5934 -> 5927;
5934 -> 5933;
5934 -> 5841;
5935 -> 5910;
5935 -> 5841;
5936 -> 5910;
5936 -> 5841;
5937 -> 5910;
5937 -> 5841;
5938 -> 5841;
5939 -> 5937;
5939 -> 5938;
5940 -> 5939;
5940 -> 5934;
5940 -> 5938;
5941 -> 5940;
5941 -> 5841;
5942 -> 5941;
5942 -> 5935;
5942 -> 5841;
5943 -> 5941;
5943 -> 5942;
5944 -> 5942;
5945 -> 5943;
5945 -> 5944;
5945 -> 5833;
5946 -> 5836;
5946 -> 5838;
5946 -> 5839;
5946 -> 5840;
5946 -> 5850;
5946 -> 5919;
5946 -> 5934;
5946 -> 5944;
5946 -> 5943;
5946 -> 5833;
5947 -> 5946;
5947 -> 0;
5947 -> 5801;
5948 -> 5801;
5949 -> 5803;
5949 -> 5948;
5950 -> 5949;
5950 -> 5946;
5950 -> 5948;
5951 -> 5950;
5951 -> 5801;
5952 -> 5801;
5953 -> 5951;
5953 -> 5952;
5954 -> 5801;
5955 -> 5803;
5955 -> 5954;
5956 -> 5954;
5957 -> 5955;
5957 -> 5956;
5958 -> 5957;
5958 -> 5946;
5958 -> 5956;
5959 -> 5954;
5960 -> 5955;
5960 -> 5959;
5961 -> 5960;
5961 -> 5946;
5961 -> 5959;
5962 -> 5959;
5963 -> 5960;
5963 -> 5946;
5963 -> 5962;
5963 -> 5959;
5964 -> 5960;
5964 -> 5946;
5964 -> 5959;
5965 -> 5954;
5966 -> 5958;
5966 -> 5801;
5967 -> 5946;
5967 -> 5801;
5968 -> 5967;
5969 -> 5968;
5969 -> 5946;
5969 -> 5964;
5970 -> 5968;
5970 -> 5946;
5970 -> 5961;
5970 -> 5960;
5970 -> 5964;
5971 -> 5970;
5971 -> 5967;
5972 -> 5967;
5973 -> 5971;
5973 -> 5972;
5974 -> 5967;
5975 -> 5973;
5975 -> 5974;
5976 -> 5975;
5976 -> 5974;
5977 -> 5976;
5978 -> 5694;
5978 -> 5670;
5979 -> 5670;
5980 -> 5978;
5980 -> 5979;
5981 -> 5672;
5981 -> 5979;
5982 -> 5980;
5982 -> 5690;
5982 -> 5981;
5982 -> 5979;
5983 -> 5980;
5983 -> 5691;
5983 -> 5981;
5983 -> 5979;
5984 -> 5980;
5984 -> 5692;
5984 -> 5981;
5984 -> 5946;
5984 -> 5979;
5985 -> 5980;
5985 -> 5693;
5985 -> 5981;
5985 -> 5946;
5985 -> 5979;
5986 -> 5980;
5986 -> 5689;
5986 -> 5979;
5987 -> 5979;
5988 -> 5986;
5988 -> 5987;
5989 -> 5981;
5989 -> 5987;
5990 -> 5988;
5990 -> 5679;
5990 -> 5989;
5990 -> 5946;
5990 -> 5987;
5991 -> 5987;
5992 -> 5990;
5992 -> 5991;
5992 -> 5987;
5993 -> 5990;
5993 -> 5989;
5993 -> 5946;
5993 -> 5987;
5994 -> 5988;
5994 -> 5679;
5994 -> 5989;
5994 -> 5987;
5995 -> 5987;
5996 -> 5990;
5996 -> 5995;
5996 -> 5987;
5997 -> 5990;
5997 -> 5989;
5997 -> 5946;
5997 -> 5987;
5998 -> 5990;
5998 -> 5989;
5998 -> 5987;
5999 -> 5987;
6000 -> 5999;
6000 -> 5989;
6000 -> 5987;
6001 -> 5987;
6002 -> 6001;
6002 -> 5989;
6002 -> 5987;
6003 -> 5988;
6003 -> 5679;
6003 -> 5989;
6003 -> 5987;
6004 -> 5987;
6005 -> 5989;
6005 -> 5946;
6005 -> 6004;
6005 -> 5987;
6006 -> 5979;
6007 -> 5670;
6008 -> 5671;
6008 -> 5670;
6009 -> 5670;
6010 -> 6008;
6010 -> 6009;
6011 -> 5672;
6011 -> 6009;
6012 -> 6010;
6012 -> 0;
6012 -> 6009;
6013 -> 6009;
6014 -> 6011;
6014 -> 6013;
6015 -> 6014;
6015 -> 5946;
6015 -> 5964;
6015 -> 5998;
6015 -> 6013;
6016 -> 6014;
6016 -> 5946;
6016 -> 6013;
6017 -> 6014;
6017 -> 5946;
6017 -> 6013;
6018 -> 6014;
6018 -> 5946;
6018 -> 5994;
6018 -> 6013;
6019 -> 6014;
6019 -> 5946;
6019 -> 5961;
6019 -> 6003;
6019 -> 6013;
6020 -> 6017;
6020 -> 6018;
6020 -> 6015;
6020 -> 6019;
6020 -> 5946;
6020 -> 5961;
6020 -> 6003;
6020 -> 5960;
6020 -> 5970;
6020 -> 6000;
6020 -> 5964;
6020 -> 5998;
6020 -> 5982;
6020 -> 5983;
6020 -> 5984;
6020 -> 5985;
6020 -> 5994;
6020 -> 6002;
6020 -> 6001;
6020 -> 6013;
6021 -> 6013;
6022 -> 6013;
6023 -> 6021;
6023 -> 6022;
6024 -> 6021;
6024 -> 6009;
6025 -> 6009;
6026 -> 6009;
6027 -> 6026;
6028 -> 6011;
6028 -> 6027;
6029 -> 6027;
6030 -> 6028;
6030 -> 6029;
6031 -> 6030;
6031 -> 6020;
6031 -> 6029;
6032 -> 6030;
6032 -> 6020;
6032 -> 6029;
6033 -> 6027;
6034 -> 6028;
6034 -> 6033;
6035 -> 6034;
6035 -> 6020;
6035 -> 6032;
6035 -> 6033;
6036 -> 6033;
6037 -> 6036;
6037 -> 6034;
6037 -> 6033;
6038 -> 6033;
6039 -> 6034;
6039 -> 6020;
6039 -> 6038;
6039 -> 6033;
6040 -> 6034;
6040 -> 6020;
6040 -> 6033;
6041 -> 6027;
6042 -> 6032;
6042 -> 6026;
6043 -> 6026;
6044 -> 6011;
6044 -> 6043;
6045 -> 6044;
6045 -> 6020;
6045 -> 6040;
6045 -> 6043;
6046 -> 6044;
6046 -> 6020;
6046 -> 6043;
6047 -> 6044;
6047 -> 6020;
6047 -> 6032;
6047 -> 6034;
6047 -> 6037;
6047 -> 6040;
6047 -> 6046;
6048 -> 6047;
6048 -> 6026;
6049 -> 6026;
6050 -> 6048;
6050 -> 6049;
6051 -> 6026;
6052 -> 6011;
6052 -> 6051;
6053 -> 6052;
6053 -> 6020;
6053 -> 6032;
6053 -> 6034;
6053 -> 6047;
6053 -> 6051;
6054 -> 6053;
6054 -> 6026;
6055 -> 6026;
6056 -> 6054;
6056 -> 6055;
6057 -> 6026;
6058 -> 6026;
6059 -> 6057;
6059 -> 6058;
6060 -> 6011;
6060 -> 6058;
6061 -> 6058;
6062 -> 6059;
6062 -> 6058;
6063 -> 6058;
6064 -> 6061;
6064 -> 6063;
6065 -> 6062;
6065 -> 6063;
6066 -> 6060;
6066 -> 6063;
6067 -> 6065;
6067 -> 6063;
6068 -> 5838;
6068 -> 6067;
6069 -> 6064;
6069 -> 6063;
6070 -> 6068;
6070 -> 6069;
6070 -> 6066;
6070 -> 6020;
6070 -> 6032;
6070 -> 6034;
6070 -> 6047;
6070 -> 6037;
6070 -> 6040;
6070 -> 6063;
6071 -> 6063;
6072 -> 6071;
6073 -> 6070;
6073 -> 6072;
6073 -> 6071;
6074 -> 6070;
6074 -> 6071;
6075 -> 6071;
6076 -> 6070;
6076 -> 6071;
6077 -> 6071;
6078 -> 6070;
6078 -> 6077;
6079 -> 6078;
6079 -> 6071;
6080 -> 6071;
6081 -> 6079;
6081 -> 6080;
6082 -> 6071;
6083 -> 6070;
6083 -> 6082;
6084 -> 6082;
6085 -> 6083;
6085 -> 6084;
6086 -> 6085;
6086 -> 6082;
6087 -> 6082;
6088 -> 6086;
6088 -> 6087;
6089 -> 6088;
6090 -> 6083;
6090 -> 6089;
6091 -> 6089;
6092 -> 6090;
6092 -> 6091;
6093 -> 6092;
6093 -> 6089;
6094 -> 6089;
6095 -> 6093;
6095 -> 6094;
6096 -> 6089;
6097 -> 6096;
6097 -> 6088;
6098 -> 6088;
6099 -> 6083;
6099 -> 6098;
6100 -> 6098;
6101 -> 6099;
6101 -> 6100;
6102 -> 6101;
6102 -> 6070;
6102 -> 6100;
6103 -> 6102;
6103 -> 6098;
6104 -> 6103;
6104 -> 6088;
6105 -> 6097;
6105 -> 6104;
6105 -> 6088;
6106 -> 6088;
6107 -> 6083;
6107 -> 6106;
6108 -> 6106;
6109 -> 6107;
6109 -> 6108;
6110 -> 6109;
6110 -> 6106;
6111 -> 6106;
6112 -> 6110;
6112 -> 6111;
6113 -> 6112;
6113 -> 6088;
6114 -> 6105;
6114 -> 6113;
6114 -> 6088;
6115 -> 6114;
6116 -> 6115;
6116 -> 6071;
6117 -> 6081;
6117 -> 6116;
6117 -> 6071;
6118 -> 6071;
6119 -> 6118;
6120 -> 6118;
6121 -> 6070;
6121 -> 6120;
6122 -> 6120;
6123 -> 6120;
6124 -> 6070;
6124 -> 6123;
6124 -> 6120;
6125 -> 6118;
6126 -> 6071;
6127 -> 6070;
6127 -> 6126;
6128 -> 6071;
6129 -> 6071;
6130 -> 6071;
6131 -> 6071;
6132 -> 6071;
6133 -> 6070;
6133 -> 6071;
6134 -> 6071;
6135 -> 6026;
6136 -> 6011;
6136 -> 6135;
6137 -> 6135;
6138 -> 6136;
6138 -> 6137;
6139 -> 6138;
6139 -> 6070;
6139 -> 6137;
6140 -> 6139;
6140 -> 6135;
6141 -> 6135;
6142 -> 6140;
6142 -> 6141;
6143 -> 6135;
6144 -> 6143;
6144 -> 6026;
6145 -> 6026;
6146 -> 6011;
6146 -> 6145;
6147 -> 6146;
6147 -> 6070;
6147 -> 6145;
6148 -> 6147;
6148 -> 6026;
6149 -> 6026;
6150 -> 6148;
6150 -> 6149;
6151 -> 6150;
6152 -> 6150;
6153 -> 6151;
6153 -> 6152;
6154 -> 6152;
6155 -> 6153;
6155 -> 6154;
6155 -> 6152;
6156 -> 6152;
6156 -> 6070;
6156 -> 6153;
6157 -> 6150;
6158 -> 6153;
6158 -> 6157;
6159 -> 6024;
6159 -> 6150;
6160 -> 6150;
6161 -> 6159;
6161 -> 6160;
6162 -> 6160;
6163 -> 6161;
6163 -> 6162;
6163 -> 6160;
6164 -> 6161;
6164 -> 6160;
6164 -> 6070;
6165 -> 6160;
6166 -> 6161;
6166 -> 6165;
6166 -> 6160;
6167 -> 6161;
6167 -> 6160;
6167 -> 6070;
6168 -> 6160;
6169 -> 6150;
6170 -> 6161;
6170 -> 6150;
6171 -> 6150;
6172 -> 6170;
6172 -> 6171;
6173 -> 6011;
6173 -> 6171;
6174 -> 6172;
6174 -> 6161;
6174 -> 6171;
6175 -> 6171;
6176 -> 6174;
6176 -> 6175;
6177 -> 6173;
6177 -> 6175;
6178 -> 6177;
6178 -> 6070;
6178 -> 6176;
6178 -> 6020;
6178 -> 6175;
6179 -> 6177;
6179 -> 6070;
6179 -> 6175;
6180 -> 6175;
6181 -> 6177;
6181 -> 6070;
6181 -> 6179;
6181 -> 6180;
6181 -> 6175;
6182 -> 6171;
6183 -> 6150;
6184 -> 6158;
6184 -> 5670;
6185 -> 5980;
6185 -> 5670;
6186 -> 5670;
6187 -> 6185;
6187 -> 6186;
6188 -> 5672;
6188 -> 6186;
6189 -> 6187;
6189 -> 5690;
6189 -> 6188;
6189 -> 6186;
6190 -> 6187;
6190 -> 5691;
6190 -> 6188;
6190 -> 6186;
6191 -> 6187;
6191 -> 5692;
6191 -> 6188;
6191 -> 6070;
6191 -> 6186;
6192 -> 6187;
6192 -> 5693;
6192 -> 6188;
6192 -> 6070;
6192 -> 6186;
6193 -> 6187;
6193 -> 5988;
6193 -> 6186;
6194 -> 6186;
6195 -> 6188;
6195 -> 6194;
6196 -> 6193;
6196 -> 5679;
6196 -> 6195;
6196 -> 6070;
6196 -> 6194;
6197 -> 6194;
6198 -> 6196;
6198 -> 6197;
6198 -> 6194;
6199 -> 6196;
6199 -> 6195;
6199 -> 6070;
6199 -> 6194;
6200 -> 6193;
6200 -> 5679;
6200 -> 6195;
6200 -> 6194;
6201 -> 6194;
6202 -> 6196;
6202 -> 6201;
6202 -> 6194;
6203 -> 6196;
6203 -> 6195;
6203 -> 6070;
6203 -> 6194;
6204 -> 6194;
6205 -> 6204;
6205 -> 6195;
6205 -> 6194;
6206 -> 6194;
6207 -> 6206;
6207 -> 6195;
6207 -> 6194;
6208 -> 6193;
6208 -> 5679;
6208 -> 6195;
6208 -> 6194;
6209 -> 6194;
6210 -> 6195;
6210 -> 6070;
6210 -> 6209;
6210 -> 6194;
6211 -> 6186;
6212 -> 5670;
6213 -> 0;
6213 -> 5670;
6214 -> 5670;
6215 -> 6213;
6215 -> 6214;
6216 -> 5672;
6216 -> 6214;
6217 -> 6215;
6217 -> 6214;
6218 -> 6214;
6219 -> 6217;
6219 -> 6218;
6220 -> 6219;
6220 -> 0;
6220 -> 6218;
6221 -> 6220;
6222 -> 6216;
6222 -> 6070;
6222 -> 6161;
6222 -> 6196;
6222 -> 6214;
6223 -> 6216;
6223 -> 6070;
6223 -> 6214;
6224 -> 6216;
6224 -> 6070;
6224 -> 6161;
6224 -> 6189;
6224 -> 6190;
6224 -> 6191;
6224 -> 6192;
6224 -> 6200;
6224 -> 6196;
6224 -> 6160;
6224 -> 6205;
6224 -> 6207;
6224 -> 6208;
6224 -> 6179;
6224 -> 6223;
6225 -> 6224;
6225 -> 6215;
6225 -> 6214;
6226 -> 6225;
6226 -> 6070;
6226 -> 6160;
6226 -> 6205;
6226 -> 6224;
6227 -> 6225;
6228 -> 6225;
6229 -> 6224;
6229 -> 6225;
6230 -> 0;
6230 -> 5670;
6231 -> 5670;
6232 -> 5670;
6233 -> 6230;
6233 -> 6232;
6234 -> 6231;
6234 -> 6232;
6235 -> 6231;
6235 -> 6232;
6236 -> 5672;
6236 -> 6232;
6237 -> 6233;
6237 -> 6232;
6238 -> 6235;
6238 -> 6232;
6239 -> 6232;
6240 -> 6237;
6240 -> 6239;
6241 -> 6238;
6241 -> 6239;
6242 -> 6236;
6242 -> 6239;
6243 -> 6239;
6244 -> 6242;
6244 -> 6243;
6245 -> 6244;
6245 -> 6070;
6245 -> 6161;
6245 -> 6189;
6245 -> 6190;
6245 -> 6191;
6245 -> 6192;
6245 -> 6200;
6245 -> 6196;
6245 -> 6225;
6245 -> 6160;
6245 -> 6205;
6245 -> 6224;
6245 -> 6207;
6245 -> 6208;
6245 -> 6179;
6245 -> 6243;
6246 -> 6245;
6246 -> 6239;
6247 -> 6239;
6248 -> 6242;
6248 -> 6247;
6249 -> 6248;
6249 -> 6070;
6249 -> 6161;
6249 -> 6196;
6249 -> 6225;
6249 -> 6247;
6250 -> 6248;
6250 -> 6070;
6250 -> 6179;
6250 -> 6247;
6251 -> 6248;
6251 -> 6070;
6251 -> 6179;
6251 -> 6247;
6252 -> 6248;
6252 -> 6070;
6252 -> 6161;
6252 -> 6200;
6252 -> 6247;
6253 -> 6248;
6253 -> 6070;
6253 -> 6161;
6253 -> 6208;
6253 -> 6225;
6253 -> 6247;
6254 -> 6247;
6255 -> 6247;
6256 -> 6254;
6256 -> 6255;
6257 -> 6254;
6257 -> 6239;
6258 -> 6239;
6259 -> 6242;
6259 -> 6258;
6260 -> 6258;
6261 -> 6259;
6261 -> 6260;
6262 -> 6261;
6262 -> 6249;
6262 -> 6260;
6263 -> 6261;
6263 -> 6249;
6263 -> 6260;
6264 -> 6263;
6264 -> 6258;
6265 -> 6258;
6266 -> 6264;
6266 -> 6265;
6267 -> 6266;
6268 -> 6267;
6268 -> 6239;
6269 -> 6239;
6270 -> 6240;
6270 -> 6239;
6271 -> 6269;
6271 -> 6239;
6272 -> 6270;
6272 -> 6271;
6272 -> 6242;
6272 -> 6249;
6272 -> 6263;
6272 -> 6239;
6273 -> 6239;
6274 -> 6273;
6275 -> 6272;
6275 -> 6274;
6275 -> 6273;
6276 -> 6272;
6276 -> 6273;
6277 -> 6273;
6278 -> 6272;
6278 -> 6273;
6279 -> 6273;
6280 -> 6272;
6280 -> 6279;
6281 -> 6280;
6281 -> 6273;
6282 -> 6273;
6283 -> 6281;
6283 -> 6282;
6284 -> 6273;
6285 -> 6272;
6285 -> 6284;
6286 -> 6284;
6287 -> 6285;
6287 -> 6286;
6288 -> 6287;
6288 -> 6284;
6289 -> 6284;
6290 -> 6288;
6290 -> 6289;
6291 -> 6290;
6292 -> 6285;
6292 -> 6291;
6293 -> 6291;
6294 -> 6292;
6294 -> 6293;
6295 -> 6294;
6295 -> 6291;
6296 -> 6291;
6297 -> 6295;
6297 -> 6296;
6298 -> 6291;
6299 -> 6298;
6299 -> 6290;
6300 -> 6290;
6301 -> 6285;
6301 -> 6300;
6302 -> 6300;
6303 -> 6301;
6303 -> 6302;
6304 -> 6303;
6304 -> 6272;
6304 -> 6302;
6305 -> 6304;
6305 -> 6300;
6306 -> 6305;
6306 -> 6290;
6307 -> 6299;
6307 -> 6306;
6307 -> 6290;
6308 -> 6290;
6309 -> 6285;
6309 -> 6308;
6310 -> 6308;
6311 -> 6309;
6311 -> 6310;
6312 -> 6311;
6312 -> 6308;
6313 -> 6308;
6314 -> 6312;
6314 -> 6313;
6315 -> 6314;
6315 -> 6290;
6316 -> 6307;
6316 -> 6315;
6316 -> 6290;
6317 -> 6316;
6318 -> 6317;
6318 -> 6273;
6319 -> 6283;
6319 -> 6318;
6319 -> 6273;
6320 -> 6273;
6321 -> 6320;
6322 -> 6320;
6323 -> 6272;
6323 -> 6322;
6324 -> 6322;
6325 -> 6322;
6326 -> 6272;
6326 -> 6325;
6326 -> 6322;
6327 -> 6320;
6328 -> 6273;
6329 -> 6272;
6329 -> 6328;
6330 -> 6273;
6331 -> 6273;
6332 -> 6273;
6333 -> 6273;
6334 -> 6273;
6335 -> 6272;
6335 -> 6273;
6336 -> 6273;
6337 -> 6239;
6338 -> 6272;
6338 -> 6337;
6339 -> 6338;
6339 -> 6239;
6340 -> 6239;
6341 -> 6339;
6341 -> 6340;
6342 -> 6268;
6342 -> 6341;
6342 -> 6239;
6343 -> 6241;
6343 -> 6342;
6343 -> 6239;
6344 -> 6239;
6345 -> 6343;
6345 -> 6344;
6346 -> 6242;
6346 -> 6344;
6347 -> 6344;
6348 -> 6346;
6348 -> 6347;
6349 -> 6348;
6349 -> 6272;
6349 -> 6347;
6350 -> 6349;
6350 -> 6344;
6351 -> 6344;
6352 -> 6350;
6352 -> 6351;
6353 -> 6352;
6354 -> 6353;
6354 -> 6239;
6355 -> 6354;
6356 -> 6257;
6356 -> 6354;
6357 -> 6354;
6358 -> 6356;
6358 -> 6357;
6359 -> 6357;
6360 -> 6358;
6360 -> 6359;
6360 -> 6357;
6361 -> 6358;
6361 -> 6357;
6361 -> 6272;
6362 -> 6357;
6363 -> 6358;
6363 -> 6362;
6363 -> 6357;
6364 -> 6358;
6364 -> 6357;
6364 -> 6272;
6365 -> 6357;
6366 -> 6354;
6367 -> 6358;
6367 -> 6354;
6368 -> 6354;
6369 -> 6367;
6369 -> 6368;
6370 -> 6369;
6370 -> 6358;
6370 -> 6368;
6371 -> 6370;
6371 -> 6368;
6372 -> 6368;
6372 -> 6272;
6372 -> 6371;
6372 -> 6249;
6373 -> 6368;
6374 -> 6368;
6375 -> 6354;
6376 -> 6355;
6377 -> 6376;
6377 -> 6272;
6378 -> 6376;
6379 -> 6376;
6380 -> 6376;
6380 -> 6272;
6380 -> 6358;
6381 -> 6376;
6381 -> 6272;
6381 -> 6358;
6381 -> 6357;
6381 -> 6368;
6382 -> 6381;
6382 -> 6376;
6383 -> 6376;
6384 -> 6382;
6384 -> 6383;
6385 -> 6384;
6385 -> 6383;
6386 -> 6385;
6387 -> 6376;
6387 -> 6381;
6388 -> 6381;
6389 -> 6387;
6389 -> 6388;
6390 -> 6389;
6390 -> 6381;
6391 -> 6381;
6392 -> 6390;
6392 -> 6391;
6393 -> 6381;
6394 -> 6381;
6395 -> 6376;
6395 -> 6381;
6396 -> 6381;
6397 -> 6395;
6397 -> 6396;
6398 -> 6397;
6398 -> 6381;
6399 -> 6381;
6400 -> 6398;
6400 -> 6399;
6401 -> 6376;
6401 -> 6391;
6402 -> 6401;
6402 -> 6391;
6403 -> 6402;
6403 -> 6391;
6404 -> 6403;
6404 -> 6391;
6405 -> 6391;
6406 -> 6391;
6406 -> 6405;
6407 -> 6405;
6408 -> 6406;
6408 -> 6407;
6409 -> 6408;
6409 -> 6405;
6410 -> 6405;
6411 -> 6409;
6411 -> 6410;
6412 -> 6411;
6413 -> 6406;
6413 -> 6412;
6414 -> 6412;
6415 -> 6413;
6415 -> 6414;
6416 -> 6415;
6416 -> 6412;
6417 -> 6412;
6418 -> 6416;
6418 -> 6417;
6419 -> 6412;
6420 -> 6419;
6420 -> 6411;
6421 -> 6411;
6422 -> 6406;
6422 -> 6421;
6423 -> 6421;
6424 -> 6422;
6424 -> 6423;
6425 -> 6424;
6425 -> 6272;
6425 -> 6358;
6425 -> 6357;
6425 -> 6381;
6425 -> 6368;
6425 -> 6376;
6425 -> 6423;
6426 -> 6425;
6426 -> 6421;
6427 -> 6426;
6427 -> 6411;
6428 -> 6420;
6428 -> 6427;
6428 -> 6411;
6429 -> 6411;
6430 -> 6406;
6430 -> 6429;
6431 -> 6429;
6432 -> 6430;
6432 -> 6431;
6433 -> 6432;
6433 -> 6429;
6434 -> 6429;
6435 -> 6433;
6435 -> 6434;
6436 -> 6435;
6436 -> 6411;
6437 -> 6428;
6437 -> 6436;
6437 -> 6411;
6438 -> 6437;
6439 -> 6438;
6439 -> 6391;
6440 -> 6439;
6441 -> 6391;
6441 -> 6440;
6442 -> 6440;
6443 -> 6442;
6443 -> 6440;
6444 -> 6440;
6445 -> 6443;
6445 -> 6444;
6446 -> 6441;
6446 -> 6444;
6447 -> 6444;
6448 -> 6445;
6448 -> 6447;
6448 -> 6444;
6449 -> 6446;
6449 -> 6272;
6449 -> 6358;
6449 -> 6445;
6449 -> 6444;
6450 -> 6446;
6450 -> 6272;
6450 -> 6358;
6450 -> 6445;
6451 -> 6440;
6452 -> 6450;
6452 -> 6451;
6453 -> 6440;
6454 -> 6443;
6454 -> 6453;
6455 -> 6441;
6455 -> 6453;
6456 -> 6453;
6457 -> 6454;
6457 -> 6456;
6457 -> 6453;
6458 -> 6455;
6458 -> 6272;
6458 -> 6358;
6458 -> 6454;
6458 -> 6453;
6459 -> 6455;
6459 -> 6272;
6459 -> 6358;
6459 -> 6454;
6460 -> 6440;
6461 -> 6459;
6461 -> 6460;
6462 -> 6452;
6462 -> 6461;
6462 -> 6440;
6463 -> 6442;
6463 -> 6440;
6464 -> 6440;
6465 -> 6463;
6465 -> 6464;
6466 -> 6441;
6466 -> 6464;
6467 -> 6464;
6468 -> 6465;
6468 -> 6467;
6468 -> 6464;
6469 -> 6466;
6469 -> 6272;
6469 -> 6358;
6469 -> 6465;
6469 -> 6464;
6470 -> 6466;
6470 -> 6272;
6470 -> 6358;
6470 -> 6465;
6471 -> 6440;
6472 -> 6470;
6472 -> 6471;
6473 -> 6472;
6473 -> 6439;
6474 -> 6404;
6474 -> 6473;
6475 -> 6473;
6476 -> 6474;
6476 -> 6475;
6477 -> 6391;
6477 -> 6475;
6478 -> 6475;
6479 -> 6477;
6479 -> 6478;
6480 -> 6479;
6480 -> 6475;
6481 -> 6475;
6482 -> 6480;
6482 -> 6481;
6483 -> 6475;
6484 -> 6477;
6484 -> 6483;
6485 -> 6484;
6485 -> 6475;
6486 -> 6475;
6487 -> 6485;
6487 -> 6486;
6488 -> 6477;
6488 -> 6486;
6489 -> 6486;
6490 -> 6487;
6490 -> 6489;
6491 -> 6490;
6491 -> 6486;
6492 -> 6486;
6493 -> 6488;
6493 -> 6492;
6494 -> 6493;
6494 -> 6486;
6495 -> 6491;
6495 -> 6494;
6495 -> 6486;
6496 -> 6482;
6496 -> 6495;
6496 -> 6475;
6497 -> 6476;
6497 -> 0;
6497 -> 6475;
6498 -> 6475;
6499 -> 6475;
6500 -> 6475;
6501 -> 6477;
6501 -> 6500;
6502 -> 6501;
6502 -> 6475;
6503 -> 6475;
6504 -> 6502;
6504 -> 6503;
6505 -> 6504;
6506 -> 6505;
6506 -> 6504;
6507 -> 6504;
6508 -> 6506;
6508 -> 6507;
6509 -> 6508;
6510 -> 6508;
6511 -> 6509;
6511 -> 6475;
6512 -> 6475;
6513 -> 6511;
6513 -> 6512;
6514 -> 6477;
6514 -> 6512;
6515 -> 6512;
6516 -> 6513;
6516 -> 6515;
6516 -> 6512;
6517 -> 6514;
6517 -> 6272;
6517 -> 6358;
6517 -> 6513;
6517 -> 6512;
6518 -> 6475;
6519 -> 6513;
6519 -> 6518;
6520 -> 6509;
6520 -> 6475;
6521 -> 6475;
6522 -> 6520;
6522 -> 6521;
6523 -> 6477;
6523 -> 6521;
6524 -> 6521;
6525 -> 6522;
6525 -> 6524;
6525 -> 6521;
6526 -> 6523;
6526 -> 6272;
6526 -> 6358;
6526 -> 6522;
6526 -> 6521;
6527 -> 6475;
6528 -> 6522;
6528 -> 6527;
6529 -> 6475;
6530 -> 6509;
6530 -> 6529;
6530 -> 6475;
6531 -> 6475;
6532 -> 6530;
6532 -> 6531;
6533 -> 6477;
6533 -> 6531;
6534 -> 6531;
6535 -> 6532;
6535 -> 6534;
6535 -> 6531;
6536 -> 6533;
6536 -> 6272;
6536 -> 6358;
6536 -> 6532;
6536 -> 6531;
6537 -> 6475;
6538 -> 6532;
6538 -> 6537;
6539 -> 6528;
6539 -> 6538;
6539 -> 6475;
6540 -> 6509;
6540 -> 6475;
6541 -> 6475;
6542 -> 6540;
6542 -> 6541;
6543 -> 6477;
6543 -> 6541;
6544 -> 6541;
6545 -> 6542;
6545 -> 6544;
6545 -> 6541;
6546 -> 6543;
6546 -> 6272;
6546 -> 6358;
6546 -> 6542;
6546 -> 6541;
6547 -> 6475;
6548 -> 6542;
6548 -> 6547;
6549 -> 6509;
6549 -> 6475;
6550 -> 6475;
6551 -> 6549;
6551 -> 6550;
6552 -> 6477;
6552 -> 6550;
6553 -> 6550;
6554 -> 6551;
6554 -> 6553;
6554 -> 6550;
6555 -> 6552;
6555 -> 6272;
6555 -> 6358;
6555 -> 6551;
6555 -> 6550;
6556 -> 6475;
6557 -> 6551;
6557 -> 6556;
6558 -> 6557;
6559 -> 6558;
6559 -> 6473;
6560 -> 6404;
6560 -> 6559;
6561 -> 6559;
6562 -> 6560;
6562 -> 6561;
6563 -> 0;
6563 -> 6562;
6564 -> 6562;
6565 -> 6563;
6565 -> 6564;
6566 -> 6391;
6566 -> 6564;
6567 -> 6565;
6567 -> 6564;
6568 -> 6564;
6569 -> 6567;
6569 -> 6568;
6570 -> 6566;
6570 -> 6568;
6571 -> 6568;
6572 -> 6568;
6573 -> 6571;
6573 -> 6572;
6574 -> 6570;
6574 -> 6572;
6575 -> 6572;
6576 -> 6574;
6576 -> 6575;
6577 -> 6575;
6578 -> 6576;
6578 -> 6577;
6579 -> 6578;
6579 -> 6575;
6580 -> 6579;
6581 -> 6580;
6581 -> 6572;
6582 -> 6573;
6582 -> 6572;
6583 -> 6572;
6584 -> 6582;
6584 -> 6583;
6585 -> 6574;
6585 -> 6583;
6586 -> 6583;
6587 -> 6585;
6587 -> 6586;
6588 -> 6587;
6588 -> 6583;
6589 -> 6583;
6590 -> 6588;
6590 -> 6589;
6591 -> 6590;
6591 -> 0;
6591 -> 6583;
6592 -> 6591;
6593 -> 6585;
6593 -> 6592;
6594 -> 6592;
6595 -> 6593;
6595 -> 6594;
6596 -> 6595;
6596 -> 6592;
6597 -> 6592;
6598 -> 6596;
6598 -> 6597;
6599 -> 6592;
6599 -> 6591;
6600 -> 6591;
6601 -> 6600;
6601 -> 6591;
6602 -> 6599;
6602 -> 6601;
6602 -> 6591;
6603 -> 6591;
6604 -> 6603;
6604 -> 6272;
6604 -> 6357;
6604 -> 6381;
6605 -> 6603;
6606 -> 6603;
6607 -> 6603;
6607 -> 6591;
6608 -> 6591;
6609 -> 6585;
6609 -> 6608;
6610 -> 6609;
6610 -> 6272;
6610 -> 6358;
6610 -> 6603;
6610 -> 6357;
6610 -> 6381;
6610 -> 6368;
6610 -> 6376;
6610 -> 6608;
6611 -> 6610;
6611 -> 6591;
6612 -> 6607;
6612 -> 6591;
6613 -> 6612;
6613 -> 6572;
6614 -> 6613;
6614 -> 6572;
6615 -> 6572;
6616 -> 6614;
6616 -> 6615;
6617 -> 6614;
6617 -> 6615;
6618 -> 6616;
6618 -> 6615;
6619 -> 6615;
6620 -> 6619;
6620 -> 6618;
6620 -> 6615;
6621 -> 6619;
6621 -> 6615;
6622 -> 6621;
6622 -> 6620;
6622 -> 6615;
6623 -> 6622;
6623 -> 6568;
6624 -> 6623;
6624 -> 6622;
6624 -> 6568;
6625 -> 6623;
6625 -> 6568;
6626 -> 6568;
6627 -> 6570;
6627 -> 6626;
6628 -> 6627;
6628 -> 6622;
6628 -> 6626;
6629 -> 6627;
6629 -> 6622;
6629 -> 6626;
6630 -> 6629;
6630 -> 6568;
6631 -> 6568;
6632 -> 6630;
6632 -> 6631;
6633 -> 6625;
6633 -> 6568;
6634 -> 6633;
6634 -> 6564;
6635 -> 6564;
6636 -> 6566;
6636 -> 6635;
6637 -> 6636;
6637 -> 6622;
6637 -> 6629;
6637 -> 6635;
6638 -> 6637;
6638 -> 6564;
6639 -> 6564;
6640 -> 6638;
6640 -> 6639;
6641 -> 6634;
6641 -> 6564;
6642 -> 6641;
6642 -> 6562;
6643 -> 6642;
6643 -> 6391;
6643 -> 6622;
6643 -> 6629;
6644 -> 6391;
6645 -> 6643;
6645 -> 6376;
6646 -> 6376;
6647 -> 6376;
6648 -> 6645;
6648 -> 6647;
6649 -> 6646;
6649 -> 6647;
6650 -> 6376;
6650 -> 6647;
6651 -> 6647;
6652 -> 6651;
6653 -> 6650;
6653 -> 6652;
6654 -> 6653;
6654 -> 6643;
6654 -> 6652;
6655 -> 6654;
6655 -> 6651;
6656 -> 6651;
6657 -> 6655;
6657 -> 6656;
6658 -> 6651;
6659 -> 6651;
6660 -> 6657;
6660 -> 6651;
6661 -> 6651;
6662 -> 6660;
6662 -> 6661;
6663 -> 6662;
6663 -> 6661;
6664 -> 6661;
6665 -> 6663;
6665 -> 6664;
6666 -> 6665;
6666 -> 6664;
6667 -> 6664;
6668 -> 6666;
6668 -> 6667;
6669 -> 6668;
6669 -> 6667;
6670 -> 0;
6670 -> 6669;
6671 -> 6657;
6671 -> 6670;
6672 -> 6670;
6673 -> 6671;
6673 -> 6672;
6674 -> 6673;
6674 -> 6672;
6675 -> 6672;
6676 -> 6674;
6676 -> 6675;
6677 -> 6676;
6677 -> 6675;
6678 -> 6677;
6679 -> 6657;
6679 -> 0;
6679 -> 6678;
6680 -> 6657;
6680 -> 0;
6680 -> 6679;
6681 -> 6657;
6681 -> 0;
6681 -> 6680;
6682 -> 6647;
6683 -> 6650;
6683 -> 6682;
6684 -> 6683;
6684 -> 6643;
6684 -> 6682;
6685 -> 6684;
6685 -> 6647;
6686 -> 6647;
6687 -> 6685;
6687 -> 6686;
6688 -> 6648;
6688 -> 6647;
6689 -> 6376;
6690 -> 6376;
6691 -> 6688;
6691 -> 6690;
6692 -> 6691;
6692 -> 6376;
6693 -> 6376;
6694 -> 6692;
6694 -> 6693;
6695 -> 6694;
6695 -> 6693;
6696 -> 0;
6696 -> 6695;
6697 -> 6376;
6697 -> 6643;
6698 -> 6688;
6698 -> 6376;
6699 -> 5670;
6700 -> 5672;
6700 -> 6699;
6701 -> 6700;
6701 -> 6643;
6701 -> 6699;
6702 -> 6701;
6702 -> 5670;
6703 -> 5670;
6704 -> 6702;
6704 -> 6703;
6705 -> 5670;
6706 -> 6698;
6706 -> 6705;
6707 -> 6706;
6707 -> 5670;
6708 -> 5670;
6709 -> 5672;
6709 -> 6708;
6710 -> 6709;
6710 -> 6643;
6710 -> 6708;
6711 -> 6710;
6711 -> 5670;
6712 -> 5670;
6713 -> 6711;
6713 -> 6712;
6714 -> 6707;
6714 -> 6713;
6714 -> 5670;
6715 -> 0;
6715 -> 5670;
6716 -> 5670;
6717 -> 6715;
6717 -> 6716;
6718 -> 5672;
6718 -> 6716;
6719 -> 6717;
6719 -> 6716;
6720 -> 6716;
6721 -> 6719;
6721 -> 6720;
6722 -> 6721;
6722 -> 0;
6722 -> 6720;
6723 -> 6722;
6724 -> 6718;
6724 -> 6643;
6724 -> 6716;
6725 -> 6724;
6725 -> 6717;
6725 -> 6716;
6726 -> 6725;
6727 -> 6725;
6728 -> 6724;
6728 -> 6725;
6729 -> 6229;
6729 -> 5670;
6730 -> 6698;
6730 -> 5670;
6731 -> 6728;
6731 -> 5670;
6732 -> 6729;
6732 -> 6730;
6732 -> 6731;
6732 -> 5672;
6732 -> 6643;
6732 -> 6697;
6732 -> 6725;
6732 -> 5670;
6733 -> 5670;
6734 -> 6732;
6734 -> 6733;
6735 -> 6732;
6735 -> 6733;
6736 -> 6732;
6736 -> 6733;
6737 -> 6732;
6737 -> 6733;
6738 -> 6732;
6738 -> 6733;
6739 -> 6732;
6739 -> 6733;
6740 -> 6734;
6740 -> 6733;
6741 -> 6735;
6741 -> 6733;
6742 -> 6736;
6742 -> 6733;
6743 -> 6737;
6743 -> 6733;
6744 -> 6738;
6744 -> 6733;
6745 -> 6733;
6746 -> 6744;
6746 -> 6745;
6747 -> 6745;
6748 -> 6746;
6748 -> 6732;
6748 -> 6745;
6749 -> 6746;
6749 -> 6732;
6749 -> 6745;
6750 -> 6747;
6750 -> 6745;
6751 -> 6750;
6751 -> 6733;
6752 -> 6739;
6752 -> 6733;
6753 -> 6740;
6753 -> 6741;
6753 -> 6742;
6753 -> 6743;
6753 -> 6751;
6753 -> 6752;
6753 -> 6732;
6753 -> 6733;
6754 -> 6733;
6755 -> 6754;
6755 -> 6733;
6756 -> 6753;
6756 -> 6733;
6757 -> 6753;
6757 -> 6733;
6758 -> 6756;
6758 -> 6733;
6759 -> 6756;
6759 -> 6733;
6760 -> 6187;
6760 -> 5670;
6761 -> 5670;
6762 -> 6760;
6762 -> 6761;
6763 -> 5672;
6763 -> 6761;
6764 -> 6762;
6764 -> 6193;
6764 -> 6761;
6765 -> 6761;
6766 -> 6764;
6766 -> 6765;
6767 -> 6763;
6767 -> 6765;
6768 -> 6767;
6768 -> 6753;
6768 -> 6766;
6768 -> 5679;
6768 -> 6765;
6769 -> 6767;
6769 -> 6753;
6769 -> 6765;
6770 -> 6765;
6771 -> 6767;
6771 -> 6753;
6771 -> 6769;
6771 -> 6770;
6771 -> 6765;
6772 -> 6761;
6773 -> 5670;
6774 -> 6753;
6774 -> 5668;
6775 -> 6774;
6775 -> 5658;
6775 -> 6753;
6775 -> 6769;
6775 -> 5656;
6776 -> 5656;
6777 -> 6775;
6777 -> 6776;
6778 -> 5564;
6778 -> 5563;
6779 -> 5563;
6780 -> 6778;
6780 -> 6779;
6781 -> 5565;
6781 -> 6779;
6782 -> 6779;
6783 -> 6782;
6784 -> 6781;
6784 -> 6783;
6785 -> 6784;
6785 -> 6775;
6785 -> 6783;
6786 -> 6785;
6786 -> 6782;
6787 -> 6782;
6788 -> 6786;
6788 -> 6787;
6789 -> 6787;
6790 -> 6782;
6791 -> 6782;
6792 -> 6788;
6792 -> 6782;
6793 -> 6782;
6794 -> 6792;
6794 -> 6793;
6795 -> 6794;
6795 -> 6793;
6796 -> 6793;
6797 -> 6795;
6797 -> 6796;
6798 -> 6797;
6798 -> 6796;
6799 -> 6796;
6800 -> 6798;
6800 -> 6799;
6801 -> 6800;
6801 -> 6799;
6802 -> 0;
6802 -> 6801;
6803 -> 6788;
6803 -> 6802;
6804 -> 6802;
6805 -> 6803;
6805 -> 6804;
6806 -> 6805;
6806 -> 6804;
6807 -> 6804;
6808 -> 6806;
6808 -> 6807;
6809 -> 6808;
6809 -> 6807;
6810 -> 6809;
6811 -> 6788;
6811 -> 0;
6811 -> 6810;
6812 -> 6788;
6812 -> 0;
6812 -> 6811;
6813 -> 6788;
6813 -> 0;
6813 -> 6812;
6814 -> 6779;
6815 -> 6781;
6815 -> 6814;
6816 -> 6815;
6816 -> 6775;
6816 -> 6814;
6817 -> 6816;
6817 -> 6779;
6818 -> 6779;
6819 -> 6817;
6819 -> 6818;
6820 -> 5557;
6821 -> 5557;
6822 -> 6775;
6822 -> 6821;
6823 -> 6822;
6823 -> 5557;
6824 -> 5557;
6825 -> 6823;
6825 -> 6824;
6826 -> 6825;
6826 -> 6824;
6827 -> 0;
6827 -> 6826;
6828 -> 6775;
6828 -> 5516;
6829 -> 5516;
6830 -> 5516;
6831 -> 5516;
6832 -> 6828;
6832 -> 6831;
6833 -> 6832;
6833 -> 5516;
6834 -> 6828;
6834 -> 6833;
6835 -> 6834;
6835 -> 6775;
6835 -> 6833;
6836 -> 6834;
6836 -> 6775;
6836 -> 6833;
6837 -> 6834;
6837 -> 6775;
6837 -> 6833;
6838 -> 6834;
6838 -> 6775;
6838 -> 6833;
6839 -> 6833;
6840 -> 0;
6840 -> 5516;
6841 -> 5516;
6842 -> 6840;
6842 -> 6841;
6843 -> 5518;
6843 -> 6841;
6844 -> 6842;
6844 -> 6841;
6845 -> 6841;
6846 -> 6844;
6846 -> 6845;
6847 -> 6846;
6847 -> 0;
6847 -> 6845;
6848 -> 6847;
6849 -> 6841;
6850 -> 6843;
6850 -> 6849;
6851 -> 6850;
6851 -> 6838;
6851 -> 6849;
6852 -> 6841;
6853 -> 6851;
6853 -> 6842;
6853 -> 6841;
6854 -> 6853;
6855 -> 6853;
6856 -> 5518;
6856 -> 6838;
6856 -> 6853;
6856 -> 5516;
6857 -> 5516;
6858 -> 5518;
6858 -> 6857;
6859 -> 6857;
6860 -> 6858;
6860 -> 6859;
6861 -> 6860;
6861 -> 6856;
6861 -> 6859;
6862 -> 6860;
6862 -> 6856;
6862 -> 6859;
6863 -> 6862;
6863 -> 6857;
6864 -> 6857;
6865 -> 6863;
6865 -> 6864;
6866 -> 6865;
6866 -> 5516;
6867 -> 6866;
6868 -> 5518;
6868 -> 6867;
6869 -> 6867;
6870 -> 6868;
6870 -> 6869;
6871 -> 6870;
6871 -> 6867;
6872 -> 6868;
6872 -> 6856;
6872 -> 6862;
6872 -> 6867;
6873 -> 6868;
6873 -> 6872;
6873 -> 6867;
6874 -> 6867;
6875 -> 6867;
6876 -> 6867;
6877 -> 6867;
6878 -> 6868;
6878 -> 6877;
6879 -> 6878;
6879 -> 6873;
6879 -> 6877;
6880 -> 6879;
6880 -> 6867;
6881 -> 6867;
6882 -> 6880;
6882 -> 6881;
6883 -> 6882;
6884 -> 6882;
6885 -> 6884;
6886 -> 6884;
6887 -> 6884;
6887 -> 6882;
6888 -> 6882;
6889 -> 6888;
6889 -> 6873;
6889 -> 6884;
6890 -> 6888;
6890 -> 6873;
6890 -> 6884;
6891 -> 6890;
6891 -> 6882;
6892 -> 6882;
6893 -> 6891;
6893 -> 6892;
6894 -> 6893;
6895 -> 6868;
6895 -> 6894;
6896 -> 6894;
6897 -> 6895;
6897 -> 6896;
6898 -> 0;
6898 -> 6896;
6899 -> 6896;
6900 -> 6896;
6901 -> 6898;
6901 -> 6900;
6902 -> 6899;
6902 -> 6900;
6903 -> 6899;
6903 -> 6900;
6904 -> 6897;
6904 -> 6900;
6905 -> 6901;
6905 -> 6900;
6906 -> 6902;
6906 -> 6900;
6907 -> 6903;
6907 -> 6900;
6908 -> 6900;
6909 -> 6905;
6909 -> 6908;
6910 -> 6906;
6910 -> 6908;
6911 -> 6907;
6911 -> 6908;
6912 -> 6904;
6912 -> 6908;
6913 -> 6909;
6913 -> 6908;
6914 -> 6910;
6914 -> 6908;
6915 -> 6911;
6915 -> 6908;
6916 -> 6908;
6917 -> 6913;
6917 -> 6916;
6918 -> 6914;
6918 -> 6916;
6919 -> 6915;
6919 -> 6916;
6920 -> 6912;
6920 -> 6916;
6921 -> 6917;
6921 -> 6916;
6922 -> 6918;
6922 -> 6916;
6923 -> 6919;
6923 -> 6916;
6924 -> 6916;
6925 -> 6921;
6925 -> 6924;
6926 -> 6922;
6926 -> 6924;
6927 -> 6923;
6927 -> 6924;
6928 -> 6920;
6928 -> 6924;
6929 -> 6924;
6930 -> 6928;
6930 -> 6929;
6931 -> 6930;
6931 -> 6924;
6932 -> 6924;
6933 -> 6931;
6933 -> 6932;
6934 -> 6925;
6934 -> 6933;
6935 -> 6926;
6935 -> 6933;
6936 -> 6927;
6936 -> 6933;
6937 -> 6933;
6938 -> 6934;
6938 -> 6937;
6939 -> 6935;
6939 -> 6937;
6940 -> 6936;
6940 -> 6937;
6941 -> 6928;
6941 -> 6937;
6942 -> 6937;
6943 -> 6941;
6943 -> 6942;
6944 -> 6943;
6944 -> 6937;
6945 -> 6937;
6946 -> 6944;
6946 -> 6945;
6947 -> 6946;
6947 -> 6937;
6948 -> 6937;
6949 -> 6941;
6949 -> 6948;
6950 -> 6949;
6950 -> 6937;
6951 -> 6937;
6952 -> 6950;
6952 -> 6951;
6953 -> 6937;
6954 -> 6941;
6954 -> 6953;
6955 -> 6954;
6955 -> 6937;
6956 -> 6937;
6957 -> 6955;
6957 -> 6956;
6958 -> 6937;
6959 -> 6941;
6959 -> 6958;
6960 -> 6958;
6960 -> 6937;
6961 -> 6937;
6962 -> 6937;
6963 -> 6941;
6963 -> 6962;
6964 -> 6962;
6965 -> 6963;
6965 -> 6964;
6966 -> 6965;
6966 -> 6959;
6966 -> 6964;
6967 -> 6966;
6967 -> 6962;
6968 -> 6962;
6969 -> 6967;
6969 -> 6968;
6970 -> 6969;
6970 -> 6962;
6971 -> 6962;
6972 -> 6970;
6972 -> 6971;
6973 -> 6969;
6973 -> 0;
6973 -> 6962;
6974 -> 6962;
6975 -> 6963;
6975 -> 6974;
6976 -> 6975;
6976 -> 6959;
6976 -> 6974;
6977 -> 6976;
6977 -> 6962;
6978 -> 6962;
6979 -> 6977;
6979 -> 6978;
6980 -> 6973;
6980 -> 6979;
6980 -> 6962;
6981 -> 6962;
6982 -> 6963;
6982 -> 6981;
6983 -> 6982;
6983 -> 6959;
6983 -> 6981;
6984 -> 6983;
6984 -> 6962;
6985 -> 6962;
6986 -> 6984;
6986 -> 6985;
6987 -> 6980;
6987 -> 6986;
6987 -> 6962;
6988 -> 6987;
6989 -> 6988;
6989 -> 6937;
6990 -> 6939;
6990 -> 6989;
6991 -> 0;
6991 -> 6990;
6992 -> 6989;
6993 -> 6991;
6993 -> 6992;
6994 -> 6941;
6994 -> 6992;
6995 -> 6992;
6996 -> 6994;
6996 -> 6995;
6997 -> 6996;
6997 -> 6992;
6998 -> 6992;
6999 -> 6997;
6999 -> 6998;
7000 -> 6993;
7000 -> 6992;
7001 -> 7000;
7001 -> 6994;
7001 -> 6959;
7001 -> 6992;
7002 -> 6992;
7003 -> 7001;
7003 -> 7002;
7004 -> 7001;
7004 -> 7002;
7005 -> 7001;
7005 -> 7002;
7006 -> 7002;
7007 -> 7005;
7007 -> 7006;
7008 -> 7007;
7008 -> 7002;
7009 -> 7002;
7010 -> 7008;
7010 -> 7009;
7011 -> 7002;
7012 -> 7010;
7012 -> 7011;
7013 -> 7002;
7014 -> 7005;
7014 -> 7013;
7015 -> 7014;
7016 -> 7014;
7017 -> 7015;
7017 -> 7016;
7018 -> 7017;
7018 -> 7014;
7019 -> 7014;
7020 -> 7018;
7020 -> 7019;
7021 -> 7019;
7021 -> 7002;
7022 -> 7004;
7022 -> 7021;
7023 -> 7021;
7024 -> 7022;
7024 -> 7023;
7025 -> 7005;
7025 -> 7023;
7026 -> 7024;
7026 -> 7023;
7027 -> 7023;
7028 -> 7026;
7028 -> 7027;
7029 -> 7025;
7029 -> 7027;
7030 -> 7028;
7030 -> 7027;
7031 -> 7027;
7032 -> 7027;
7033 -> 7029;
7033 -> 7032;
7034 -> 7032;
7035 -> 7033;
7035 -> 7034;
7036 -> 7035;
7036 -> 7032;
7037 -> 7036;
7038 -> 7037;
7038 -> 7027;
7039 -> 7031;
7039 -> 7027;
7040 -> 7029;
7041 -> 7029;
7041 -> 7040;
7042 -> 7040;
7043 -> 7041;
7043 -> 7042;
7044 -> 7043;
7044 -> 7040;
7045 -> 7040;
7045 -> 7029;
7046 -> 7029;
7047 -> 7046;
7047 -> 7029;
7048 -> 7045;
7048 -> 7047;
7048 -> 7029;
7049 -> 7029;
7049 -> 7001;
7050 -> 7029;
7051 -> 7029;
7052 -> 7029;
7053 -> 7029;
7053 -> 7052;
7054 -> 7053;
7054 -> 7001;
7054 -> 7029;
7054 -> 7052;
7055 -> 7054;
7055 -> 7029;
7056 -> 7029;
7056 -> 7027;
7057 -> 7029;
7057 -> 7027;
7058 -> 7029;
7058 -> 7027;
7059 -> 7027;
7060 -> 7058;
7060 -> 7059;
7061 -> 7027;
7062 -> 7029;
7062 -> 7061;
7063 -> 7062;
7063 -> 7027;
7064 -> 7027;
7065 -> 7063;
7065 -> 7064;
7066 -> 7029;
7066 -> 7023;
7067 -> 7023;
7068 -> 7025;
7068 -> 7067;
7069 -> 7068;
7069 -> 7029;
7069 -> 7067;
7070 -> 7069;
7070 -> 7023;
7071 -> 7023;
7072 -> 7025;
7072 -> 7071;
7073 -> 7072;
7073 -> 7029;
7073 -> 7071;
7074 -> 7073;
7074 -> 7023;
7075 -> 7023;
7076 -> 7074;
7076 -> 7075;
7077 -> 7070;
7077 -> 7076;
7077 -> 7023;
7078 -> 7066;
7078 -> 7023;
7079 -> 7078;
7079 -> 7021;
7080 -> 7001;
7080 -> 7002;
7081 -> 6938;
7081 -> 6989;
7082 -> 6989;
7083 -> 7081;
7083 -> 7082;
7084 -> 6941;
7084 -> 7082;
7085 -> 7082;
7086 -> 7084;
7086 -> 7085;
7087 -> 7086;
7087 -> 7079;
7087 -> 7085;
7088 -> 7087;
7088 -> 7082;
7089 -> 7082;
7090 -> 7088;
7090 -> 7089;
7091 -> 7090;
7092 -> 7090;
7093 -> 7091;
7093 -> 7092;
7094 -> 7093;
7094 -> 7092;
7095 -> 7092;
7096 -> 7094;
7096 -> 7095;
7097 -> 7096;
7097 -> 7095;
7098 -> 0;
7098 -> 7097;
7099 -> 7098;
7099 -> 6989;
7100 -> 7079;
7100 -> 6937;
7101 -> 6938;
7101 -> 6937;
7102 -> 6940;
7102 -> 6937;
7103 -> 6937;
7104 -> 7100;
7104 -> 7103;
7105 -> 7101;
7105 -> 7103;
7106 -> 7102;
7106 -> 7103;
7107 -> 6941;
7107 -> 7103;
7108 -> 7103;
7109 -> 7104;
7109 -> 7108;
7110 -> 7109;
7110 -> 7103;
7111 -> 7104;
7111 -> 7110;
7112 -> 7111;
7112 -> 7079;
7112 -> 7110;
7113 -> 7110;
7114 -> 7112;
7114 -> 7113;
7115 -> 7114;
7115 -> 7110;
7116 -> 7103;
7117 -> 7107;
7117 -> 7116;
7118 -> 7117;
7118 -> 7079;
7118 -> 7116;
7119 -> 7118;
7119 -> 7103;
7120 -> 7103;
7121 -> 7119;
7121 -> 7120;
7122 -> 7103;
7123 -> 7103;
7124 -> 7122;
7124 -> 7123;
7125 -> 7107;
7125 -> 7123;
7126 -> 7123;
7127 -> 7123;
7128 -> 7125;
7128 -> 7127;
7129 -> 7128;
7129 -> 7079;
7129 -> 7127;
7130 -> 7129;
7130 -> 7123;
7131 -> 7123;
7132 -> 7130;
7132 -> 7131;
7133 -> 7123;
7134 -> 7133;
7134 -> 7103;
7135 -> 7103;
7136 -> 7104;
7136 -> 7135;
7136 -> 7103;
7137 -> 7106;
7137 -> 7136;
7138 -> 7136;
7139 -> 7136;
7140 -> 7137;
7140 -> 7139;
7141 -> 7138;
7141 -> 7139;
7142 -> 7107;
7142 -> 7139;
7143 -> 7139;
7144 -> 7139;
7145 -> 7142;
7145 -> 7144;
7146 -> 7144;
7147 -> 7146;
7147 -> 7139;
7148 -> 7139;
7149 -> 7148;
7149 -> 7136;
7150 -> 7104;
7150 -> 7149;
7151 -> 7149;
7152 -> 7149;
7153 -> 7150;
7153 -> 7152;
7154 -> 7151;
7154 -> 7152;
7155 -> 7151;
7155 -> 7152;
7156 -> 7107;
7156 -> 7152;
7157 -> 7152;
7158 -> 7153;
7158 -> 7152;
7159 -> 7153;
7159 -> 7079;
7159 -> 7152;
7160 -> 7156;
7160 -> 7079;
7160 -> 7152;
7161 -> 7158;
7161 -> 7159;
7162 -> 7159;
7163 -> 7161;
7163 -> 7162;
7164 -> 7105;
7164 -> 7162;
7165 -> 7162;
7166 -> 7163;
7166 -> 7165;
7167 -> 7164;
7167 -> 7165;
7168 -> 7107;
7168 -> 7165;
7169 -> 7165;
7170 -> 7169;
7171 -> 7168;
7171 -> 7170;
7172 -> 7171;
7172 -> 7169;
7173 -> 7169;
7174 -> 7172;
7174 -> 7173;
7175 -> 7169;
7176 -> 7169;
7177 -> 7174;
7177 -> 7169;
7178 -> 7169;
7179 -> 7177;
7179 -> 7178;
7180 -> 7179;
7180 -> 7178;
7181 -> 7178;
7182 -> 7180;
7182 -> 7181;
7183 -> 7182;
7183 -> 7181;
7184 -> 7181;
7185 -> 7183;
7185 -> 7184;
7186 -> 7185;
7186 -> 7184;
7187 -> 0;
7187 -> 7186;
7188 -> 7174;
7188 -> 7187;
7189 -> 7187;
7190 -> 7188;
7190 -> 7189;
7191 -> 7190;
7191 -> 7189;
7192 -> 7189;
7193 -> 7191;
7193 -> 7192;
7194 -> 7193;
7194 -> 7192;
7195 -> 7194;
7196 -> 7174;
7196 -> 0;
7196 -> 7195;
7197 -> 7174;
7197 -> 0;
7197 -> 7196;
7198 -> 7174;
7198 -> 0;
7198 -> 7197;
7199 -> 7165;
7200 -> 7168;
7200 -> 7199;
7201 -> 7200;
7201 -> 7165;
7202 -> 7165;
7203 -> 7201;
7203 -> 7202;
7204 -> 7166;
7204 -> 7162;
7205 -> 7204;
7205 -> 7107;
7205 -> 7079;
7205 -> 7162;
7206 -> 7162;
7207 -> 7205;
7207 -> 7206;
7208 -> 7205;
7208 -> 7206;
7209 -> 7205;
7209 -> 7206;
7210 -> 7205;
7210 -> 7206;
7211 -> 7207;
7211 -> 7206;
7212 -> 7208;
7212 -> 7206;
7213 -> 7209;
7213 -> 7206;
7214 -> 7206;
7215 -> 7213;
7215 -> 7214;
7216 -> 7215;
7216 -> 7205;
7216 -> 7214;
7217 -> 7215;
7217 -> 7205;
7217 -> 7214;
7218 -> 7214;
7218 -> 7206;
7219 -> 7210;
7219 -> 7206;
7220 -> 7211;
7220 -> 7212;
7220 -> 7218;
7220 -> 7219;
7220 -> 7205;
7220 -> 7206;
7221 -> 7220;
7221 -> 7206;
7222 -> 7220;
7222 -> 7206;
7223 -> 7221;
7223 -> 7206;
7224 -> 7221;
7224 -> 7206;
7225 -> 6937;
7226 -> 7220;
7226 -> 7225;
7226 -> 6937;
7227 -> 7220;
7227 -> 7226;
7228 -> 6960;
7228 -> 7226;
7229 -> 7226;
7230 -> 7228;
7230 -> 7229;
7231 -> 7230;
7231 -> 6959;
7231 -> 7229;
7232 -> 7231;
7232 -> 7229;
7233 -> 7229;
7233 -> 7220;
7233 -> 7232;
7233 -> 6959;
7234 -> 7229;
7235 -> 7229;
7236 -> 7226;
7237 -> 6916;
7238 -> 6920;
7238 -> 7237;
7239 -> 7238;
7239 -> 7220;
7239 -> 7237;
7240 -> 7239;
7240 -> 6916;
7241 -> 6916;
7242 -> 7240;
7242 -> 7241;
7243 -> 7227;
7243 -> 6916;
7244 -> 6908;
7245 -> 6912;
7245 -> 7244;
7246 -> 7245;
7246 -> 7220;
7246 -> 7244;
7247 -> 7246;
7247 -> 6908;
7248 -> 6908;
7249 -> 7247;
7249 -> 7248;
7250 -> 7243;
7250 -> 6908;
7251 -> 7250;
7251 -> 6896;
7252 -> 7250;
7252 -> 6896;
7253 -> 7252;
7253 -> 6894;
7254 -> 6894;
7255 -> 7253;
7255 -> 7254;
7256 -> 6895;
7256 -> 7254;
7257 -> 7254;
7258 -> 7255;
7258 -> 7257;
7259 -> 7258;
7259 -> 7254;
7260 -> 7255;
7260 -> 7259;
7261 -> 7260;
7261 -> 6893;
7262 -> 6893;
7263 -> 7262;
7263 -> 7220;
7264 -> 7263;
7264 -> 6893;
7265 -> 6893;
7266 -> 7264;
7266 -> 7265;
7267 -> 6893;
7268 -> 7261;
7268 -> 7267;
7269 -> 7268;
7269 -> 6893;
7270 -> 7261;
7270 -> 6893;
7271 -> 0;
7271 -> 7270;
7272 -> 7270;
7273 -> 7271;
7273 -> 7272;
7274 -> 7273;
7274 -> 7272;
7275 -> 7272;
7276 -> 7274;
7276 -> 7275;
7277 -> 7276;
7277 -> 0;
7277 -> 7275;
7278 -> 7277;
7279 -> 7273;
7279 -> 7220;
7280 -> 7273;
7281 -> 7273;
7282 -> 6887;
7282 -> 7270;
7283 -> 7261;
7283 -> 7270;
7284 -> 7273;
7284 -> 7270;
7285 -> 7282;
7285 -> 7283;
7285 -> 7284;
7285 -> 6868;
7285 -> 7220;
7285 -> 7229;
7285 -> 7273;
7285 -> 7270;
7286 -> 7270;
7287 -> 7285;
7287 -> 7286;
7288 -> 7287;
7288 -> 7286;
7289 -> 7288;
7289 -> 7285;
7289 -> 7286;
7290 -> 7288;
7290 -> 7285;
7290 -> 7286;
7291 -> 7287;
7291 -> 7286;
7292 -> 7287;
7292 -> 7286;
7293 -> 7291;
7293 -> 7286;
7294 -> 7291;
7294 -> 7286;
7295 -> 7287;
7295 -> 6867;
7296 -> 6867;
7297 -> 6868;
7297 -> 7296;
7298 -> 7297;
7298 -> 7295;
7298 -> 7296;
7299 -> 7297;
7299 -> 7295;
7299 -> 7296;
7300 -> 7296;
7301 -> 7297;
7301 -> 7300;
7302 -> 7301;
7302 -> 7295;
7302 -> 7299;
7302 -> 7300;
7303 -> 7296;
7304 -> 7302;
7304 -> 7303;
7305 -> 7304;
7305 -> 6867;
7306 -> 6867;
7307 -> 6872;
7307 -> 7295;
7307 -> 7306;
7307 -> 6867;
7308 -> 6872;
7308 -> 7307;
7308 -> 7295;
7308 -> 7299;
7308 -> 6867;
7309 -> 7308;
7309 -> 6867;
7310 -> 6873;
7310 -> 6867;
7311 -> 6867;
7312 -> 6867;
7313 -> 7309;
7313 -> 7312;
7314 -> 7310;
7314 -> 7312;
7315 -> 7311;
7315 -> 7312;
7316 -> 6868;
7316 -> 7312;
7317 -> 7316;
7317 -> 7308;
7317 -> 7312;
7318 -> 7316;
7318 -> 7308;
7318 -> 0;
7318 -> 7312;
7319 -> 7318;
7319 -> 7316;
7319 -> 7312;
7320 -> 7315;
7320 -> 7312;
7321 -> 7316;
7321 -> 7308;
7321 -> 7319;
7321 -> 0;
7321 -> 7320;
7322 -> 7321;
7322 -> 7316;
7322 -> 7320;
7323 -> 7312;
7324 -> 7312;
7325 -> 7316;
7325 -> 7324;
7326 -> 7325;
7326 -> 7308;
7326 -> 7324;
7327 -> 7326;
7327 -> 7312;
7328 -> 7312;
7329 -> 7327;
7329 -> 7328;
7330 -> 7312;
7331 -> 7316;
7331 -> 7330;
7332 -> 7331;
7332 -> 7308;
7332 -> 7330;
7333 -> 7332;
7333 -> 7312;
7334 -> 7312;
7335 -> 7333;
7335 -> 7334;
7336 -> 7329;
7336 -> 7335;
7336 -> 7312;
7337 -> 7312;
7338 -> 7316;
7338 -> 7337;
7339 -> 7338;
7339 -> 7308;
7339 -> 7337;
7340 -> 7337;
7341 -> 7338;
7341 -> 7340;
7342 -> 7341;
7342 -> 7308;
7342 -> 7340;
7343 -> 7337;
7344 -> 7342;
7344 -> 7343;
7345 -> 7344;
7345 -> 7312;
7346 -> 7315;
7346 -> 7345;
7346 -> 7312;
7347 -> 7336;
7347 -> 7346;
7347 -> 7312;
7348 -> 7323;
7348 -> 7312;
7349 -> 7312;
7350 -> 7312;
7351 -> 7348;
7351 -> 7350;
7352 -> 7349;
7352 -> 7350;
7353 -> 7316;
7353 -> 7350;
7354 -> 7353;
7354 -> 7308;
7354 -> 7350;
7355 -> 7354;
7355 -> 7351;
7355 -> 7350;
7356 -> 7347;
7356 -> 7355;
7356 -> 7312;
7357 -> 7356;
7358 -> 7356;
7359 -> 7357;
7359 -> 7358;
7360 -> 7316;
7360 -> 7358;
7361 -> 7358;
7362 -> 7360;
7362 -> 7361;
7363 -> 7362;
7363 -> 7358;
7364 -> 7358;
7365 -> 7363;
7365 -> 7364;
7366 -> 7365;
7366 -> 7358;
7367 -> 7366;
7368 -> 7367;
7368 -> 7356;
7369 -> 7368;
7370 -> 7369;
7370 -> 7308;
7370 -> 7319;
7370 -> 7322;
7371 -> 7370;
7371 -> 7369;
7372 -> 7369;
7373 -> 7371;
7373 -> 7372;
7374 -> 7373;
7374 -> 7369;
7375 -> 7369;
7376 -> 7375;
7376 -> 7369;
7377 -> 7370;
7377 -> 7369;
7378 -> 7376;
7378 -> 7369;
7379 -> 7377;
7379 -> 7369;
7380 -> 7378;
7380 -> 7369;
7381 -> 7369;
7382 -> 7379;
7382 -> 7381;
7383 -> 7380;
7383 -> 7381;
7384 -> 7369;
7384 -> 7381;
7385 -> 7381;
7386 -> 7384;
7386 -> 7385;
7387 -> 7385;
7388 -> 7386;
7388 -> 7387;
7389 -> 7388;
7389 -> 7370;
7389 -> 7387;
7390 -> 7389;
7390 -> 7385;
7391 -> 7390;
7392 -> 7391;
7392 -> 7381;
7393 -> 7392;
7393 -> 7369;
7394 -> 7369;
7395 -> 7369;
7395 -> 7370;
7396 -> 7369;
7397 -> 7377;
7397 -> 7370;
7398 -> 7370;
7399 -> 7398;
7400 -> 7398;
7401 -> 7398;
7401 -> 7370;
7402 -> 7397;
7402 -> 7401;
7402 -> 7369;
7402 -> 7370;
7402 -> 7398;
7403 -> 7370;
7404 -> 7402;
7404 -> 7403;
7405 -> 7402;
7405 -> 7403;
7406 -> 7402;
7406 -> 7403;
7407 -> 7402;
7407 -> 7403;
7408 -> 7402;
7408 -> 7403;
7409 -> 7404;
7409 -> 7403;
7410 -> 7405;
7410 -> 7403;
7411 -> 7406;
7411 -> 7403;
7412 -> 7407;
7412 -> 7403;
7413 -> 7403;
7414 -> 7412;
7414 -> 7413;
7415 -> 7414;
7415 -> 7402;
7415 -> 7413;
7416 -> 7414;
7416 -> 7402;
7416 -> 7413;
7417 -> 7413;
7417 -> 7403;
7418 -> 7408;
7418 -> 7403;
7419 -> 7409;
7419 -> 7410;
7419 -> 7411;
7419 -> 7417;
7419 -> 7418;
7419 -> 7402;
7419 -> 7403;
7420 -> 7419;
7420 -> 7403;
7421 -> 7419;
7421 -> 7403;
7422 -> 7420;
7422 -> 7403;
7423 -> 7420;
7423 -> 7403;
7424 -> 7369;
7424 -> 7419;
7424 -> 7370;
7425 -> 7394;
7425 -> 7370;
7426 -> 7370;
7427 -> 7425;
7427 -> 7426;
7428 -> 7427;
7428 -> 7370;
7428 -> 7426;
7429 -> 7428;
7429 -> 7426;
7430 -> 7426;
7430 -> 7419;
7430 -> 7429;
7430 -> 7370;
7431 -> 7426;
7431 -> 7419;
7432 -> 7426;
7433 -> 7426;
7433 -> 7419;
7433 -> 7431;
7433 -> 7432;
7434 -> 7426;
7435 -> 7370;
7436 -> 7419;
7436 -> 7368;
7437 -> 7368;
7438 -> 7436;
7438 -> 7437;
7438 -> 7368;
7439 -> 7436;
7439 -> 7438;
7440 -> 7314;
7440 -> 7439;
7440 -> 6873;
7440 -> 7419;
7440 -> 7424;
7440 -> 7431;
7440 -> 7438;
7441 -> 7356;
7441 -> 7440;
7442 -> 7317;
7442 -> 7316;
7442 -> 7440;
7443 -> 6867;
7444 -> 6872;
7444 -> 7440;
7444 -> 7443;
7444 -> 6867;
7445 -> 7313;
7445 -> 7444;
7445 -> 6867;
7446 -> 7445;
7446 -> 6867;
7447 -> 6873;
7447 -> 6867;
7448 -> 7446;
7448 -> 7447;
7448 -> 6868;
7448 -> 7440;
7448 -> 6873;
7448 -> 7442;
7448 -> 6867;
7449 -> 6867;
7450 -> 7448;
7450 -> 7449;
7451 -> 7449;
7452 -> 7450;
7452 -> 7451;
7453 -> 7452;
7453 -> 7448;
7453 -> 7451;
7454 -> 7452;
7454 -> 7448;
7454 -> 7451;
7455 -> 7451;
7455 -> 7449;
7456 -> 7450;
7456 -> 7449;
7457 -> 7450;
7457 -> 7449;
7458 -> 7456;
7458 -> 7449;
7459 -> 7456;
7459 -> 7449;
7460 -> 6873;
7460 -> 6867;
7461 -> 6868;
7461 -> 7450;
7461 -> 7460;
7461 -> 6873;
7461 -> 6867;
7462 -> 7445;
7462 -> 6867;
7463 -> 6868;
7463 -> 7461;
7463 -> 7462;
7463 -> 6867;
7464 -> 7450;
7464 -> 6866;
7465 -> 7464;
7465 -> 6866;
7466 -> 6856;
7466 -> 7465;
7466 -> 7463;
7466 -> 6866;
7467 -> 7466;
7468 -> 7467;
7468 -> 7466;
7469 -> 7466;
7470 -> 7466;
7471 -> 7466;
7472 -> 7467;
7473 -> 7467;
7474 -> 7467;
7475 -> 7467;
7475 -> 7466;
7476 -> 7467;
7477 -> 7467;
7478 -> 7476;
7478 -> 7467;
7479 -> 7477;
7479 -> 7467;
7480 -> 7478;
7480 -> 7467;
7481 -> 7479;
7481 -> 7467;
7482 -> 7480;
7482 -> 7467;
7483 -> 7481;
7483 -> 7467;
7484 -> 7482;
7484 -> 7467;
7485 -> 7483;
7485 -> 7467;
7486 -> 7467;
7487 -> 7486;
7487 -> 7467;
7488 -> 7467;
7489 -> 7487;
7489 -> 7488;
7490 -> 7489;
7490 -> 7467;
7491 -> 7467;
7492 -> 7491;
7492 -> 7467;
7493 -> 7467;
7494 -> 7492;
7494 -> 7493;
7495 -> 7467;
7496 -> 7495;
7496 -> 7467;
7497 -> 7467;
7498 -> 7496;
7498 -> 7497;
7499 -> 7467;
7500 -> 7467;
7501 -> 7486;
7501 -> 7467;
7502 -> 7467;
7503 -> 7501;
7503 -> 7502;
7504 -> 7486;
7504 -> 7493;
7505 -> 7482;
7505 -> 7504;
7506 -> 7504;
7507 -> 7506;
7507 -> 7504;
7508 -> 7504;
7509 -> 7507;
7509 -> 7508;
7510 -> 7505;
7510 -> 7504;
7511 -> 7505;
7511 -> 7504;
7512 -> 7504;
7513 -> 7505;
7513 -> 7512;
7514 -> 7513;
7514 -> 7504;
7515 -> 7504;
7516 -> 7514;
7516 -> 7515;
7517 -> 7504;
7518 -> 7516;
7518 -> 7517;
7519 -> 7505;
7520 -> 7505;
7521 -> 7519;
7521 -> 7520;
7522 -> 7521;
7522 -> 7505;
7523 -> 7511;
7523 -> 7505;
7524 -> 7523;
7524 -> 7505;
7525 -> 7524;
7525 -> 7505;
7526 -> 7505;
7527 -> 7505;
7528 -> 7505;
7528 -> 7527;
7529 -> 7527;
7530 -> 7528;
7530 -> 7529;
7531 -> 7530;
7531 -> 7527;
7532 -> 7531;
7533 -> 7532;
7533 -> 7505;
7534 -> 7526;
7534 -> 7505;
7535 -> 7505;
7536 -> 7505;
7536 -> 7535;
7537 -> 7535;
7538 -> 7536;
7538 -> 7537;
7539 -> 7538;
7539 -> 7535;
7540 -> 7535;
7540 -> 7505;
7541 -> 7505;
7542 -> 7541;
7542 -> 7505;
7543 -> 7540;
7543 -> 7542;
7543 -> 7505;
7544 -> 7505;
7545 -> 7505;
7546 -> 7505;
7547 -> 7505;
7548 -> 7505;
7548 -> 7547;
7549 -> 7548;
7549 -> 7505;
7549 -> 7547;
7550 -> 7549;
7550 -> 7505;
7551 -> 7526;
7551 -> 7505;
7552 -> 7505;
7552 -> 7526;
7553 -> 7526;
7553 -> 7505;
7554 -> 7505;
7555 -> 7553;
7555 -> 7554;
7556 -> 7505;
7557 -> 7556;
7557 -> 7526;
7558 -> 7557;
7558 -> 7505;
7559 -> 7505;
7560 -> 7558;
7560 -> 7559;
7561 -> 7505;
7562 -> 7561;
7562 -> 7526;
7563 -> 7562;
7563 -> 7505;
7564 -> 7505;
7565 -> 7564;
7565 -> 7526;
7566 -> 7565;
7566 -> 7505;
7567 -> 7505;
7568 -> 7566;
7568 -> 7567;
7569 -> 7563;
7569 -> 7568;
7569 -> 7505;
7570 -> 7505;
7570 -> 7504;
7571 -> 7484;
7571 -> 7504;
7572 -> 7504;
7573 -> 7571;
7573 -> 7572;
7574 -> 7467;
7574 -> 7572;
7575 -> 7572;
7576 -> 7574;
7576 -> 7575;
7577 -> 7576;
7577 -> 7526;
7577 -> 7575;
7578 -> 7577;
7578 -> 7572;
7579 -> 7572;
7580 -> 7578;
7580 -> 7579;
7581 -> 7580;
7582 -> 7580;
7583 -> 7581;
7583 -> 7582;
7584 -> 7583;
7584 -> 7582;
7585 -> 7582;
7586 -> 7584;
7586 -> 7585;
7587 -> 7586;
7587 -> 7585;
7588 -> 0;
7588 -> 7587;
7589 -> 7588;
7589 -> 7504;
7590 -> 7484;
7590 -> 7467;
7591 -> 7485;
7591 -> 7467;
7592 -> 7467;
7593 -> 7526;
7593 -> 7592;
7594 -> 7593;
7594 -> 7467;
7595 -> 7526;
7595 -> 7594;
7596 -> 7595;
7596 -> 7526;
7596 -> 7594;
7597 -> 7594;
7598 -> 7596;
7598 -> 7597;
7599 -> 7598;
7599 -> 7594;
7600 -> 7467;
7601 -> 7600;
7601 -> 7526;
7602 -> 7601;
7602 -> 7467;
7603 -> 7467;
7604 -> 7602;
7604 -> 7603;
7605 -> 7467;
7606 -> 7467;
7607 -> 7605;
7607 -> 7606;
7608 -> 7467;
7608 -> 7606;
7609 -> 7606;
7610 -> 7606;
7611 -> 7608;
7611 -> 7610;
7612 -> 7611;
7612 -> 7526;
7612 -> 7610;
7613 -> 7612;
7613 -> 7606;
7614 -> 7606;
7615 -> 7613;
7615 -> 7614;
7616 -> 7606;
7617 -> 7616;
7617 -> 7467;
7618 -> 7591;
7618 -> 7526;
7619 -> 7618;
7619 -> 7526;
7620 -> 7526;
7621 -> 7467;
7621 -> 7526;
7622 -> 7526;
7623 -> 7526;
7624 -> 7621;
7624 -> 7623;
7625 -> 7623;
7626 -> 7625;
7626 -> 7526;
7627 -> 7526;
7628 -> 7526;
7629 -> 7467;
7629 -> 7526;
7630 -> 7526;
7631 -> 7590;
7631 -> 7526;
7632 -> 7631;
7632 -> 7526;
7633 -> 7467;
7633 -> 7526;
7634 -> 7526;
7635 -> 7634;
7636 -> 7633;
7636 -> 7635;
7637 -> 7636;
7637 -> 7634;
7638 -> 7634;
7639 -> 7637;
7639 -> 7638;
7640 -> 7634;
7641 -> 7634;
7642 -> 7639;
7642 -> 7634;
7643 -> 7634;
7644 -> 7642;
7644 -> 7643;
7645 -> 7644;
7645 -> 7643;
7646 -> 7643;
7647 -> 7645;
7647 -> 7646;
7648 -> 7647;
7648 -> 7646;
7649 -> 7646;
7650 -> 7648;
7650 -> 7649;
7651 -> 7650;
7651 -> 7649;
7652 -> 0;
7652 -> 7651;
7653 -> 7639;
7653 -> 7652;
7654 -> 7652;
7655 -> 7653;
7655 -> 7654;
7656 -> 7655;
7656 -> 7654;
7657 -> 7654;
7658 -> 7656;
7658 -> 7657;
7659 -> 7658;
7659 -> 7657;
7660 -> 7659;
7661 -> 7639;
7661 -> 0;
7661 -> 7660;
7662 -> 7639;
7662 -> 0;
7662 -> 7661;
7663 -> 7639;
7663 -> 0;
7663 -> 7662;
7664 -> 7526;
7665 -> 7633;
7665 -> 7664;
7666 -> 7665;
7666 -> 7526;
7667 -> 7526;
7668 -> 7666;
7668 -> 7667;
7669 -> 7526;
7670 -> 7669;
7670 -> 7526;
7671 -> 7670;
7671 -> 7526;
7672 -> 7670;
7672 -> 7526;
7673 -> 7669;
7674 -> 7669;
7675 -> 7673;
7675 -> 7669;
7676 -> 7673;
7676 -> 7669;
7677 -> 7499;
7677 -> 7669;
7678 -> 7677;
7678 -> 7669;
7679 -> 7678;
7679 -> 7467;
7679 -> 7669;
7680 -> 7679;
7680 -> 7669;
7681 -> 7669;
7681 -> 7680;
7681 -> 7467;
7682 -> 7669;
7683 -> 7669;
7684 -> 7669;
7685 -> 7467;
7686 -> 7685;
7686 -> 7669;
7687 -> 7686;
7687 -> 7467;
7688 -> 7467;
7689 -> 7687;
7689 -> 7688;
7690 -> 7467;
7691 -> 7690;
7691 -> 7669;
7692 -> 7691;
7692 -> 7467;
7693 -> 7467;
7694 -> 7692;
7694 -> 7693;
7695 -> 7669;
7695 -> 7467;
7696 -> 7467;
7697 -> 7467;
7698 -> 7697;
7698 -> 7669;
7699 -> 7698;
7699 -> 7467;
7700 -> 7467;
7701 -> 7699;
7701 -> 7700;
7702 -> 7467;
7703 -> 7669;
7703 -> 7702;
7704 -> 7703;
7704 -> 7467;
7705 -> 7669;
7706 -> 7669;
7707 -> 7705;
7707 -> 7706;
7708 -> 7707;
7708 -> 0;
7708 -> 7706;
7709 -> 7708;
7710 -> 7669;
7711 -> 7669;
7712 -> 7669;
7713 -> 7669;
7714 -> 7713;
7714 -> 7669;
7715 -> 7713;
7715 -> 7669;
7716 -> 7486;
7716 -> 7669;
7716 -> 7467;
7717 -> 7669;
7717 -> 7466;
7718 -> 7466;
7719 -> 7669;
7720 -> 7669;
7721 -> 7669;
7722 -> 7720;
7722 -> 7721;
7723 -> 7722;
7723 -> 7669;
7724 -> 7669;
7725 -> 7724;
7725 -> 7669;
7726 -> 7725;
7726 -> 7669;
7727 -> 7669;
7728 -> 7726;
7728 -> 7669;
7729 -> 7669;
7730 -> 7727;
7730 -> 7729;
7731 -> 7728;
7731 -> 7729;
7732 -> 7669;
7732 -> 7729;
7733 -> 7729;
7734 -> 7732;
7734 -> 7733;
7735 -> 7733;
7736 -> 7734;
7736 -> 7735;
7737 -> 7736;
7737 -> 7733;
7738 -> 7737;
7739 -> 7738;
7739 -> 7729;
7740 -> 7739;
7740 -> 7669;
7741 -> 7669;
7742 -> 7669;
7743 -> 7669;
7744 -> 7669;
7745 -> 7741;
7745 -> 7669;
7746 -> 7745;
7746 -> 7669;
7747 -> 7746;
7747 -> 7669;
7748 -> 7747;
7748 -> 7669;
7749 -> 7669;
7749 -> 7748;
7750 -> 7669;
7751 -> 7669;
7752 -> 7669;
7752 -> 7466;
7753 -> 7752;
7753 -> 7669;
7753 -> 7466;
7754 -> 7752;
7754 -> 7669;
7754 -> 7466;
7755 -> 7669;
7755 -> 7466;
7756 -> 7669;
7756 -> 7466;
7757 -> 7755;
7757 -> 7466;
7758 -> 7755;
7758 -> 7466;
7759 -> 6857;
7760 -> 6858;
7760 -> 7759;
7761 -> 6857;
7762 -> 0;
7762 -> 5516;
7763 -> 5516;
7764 -> 7762;
7764 -> 7763;
7765 -> 5518;
7765 -> 7763;
7766 -> 7764;
7766 -> 7763;
7767 -> 7763;
7768 -> 7766;
7768 -> 7767;
7769 -> 7768;
7769 -> 0;
7769 -> 7767;
7770 -> 7769;
7771 -> 7763;
7772 -> 7765;
7772 -> 7771;
7773 -> 7772;
7773 -> 7669;
7773 -> 7771;
7774 -> 7763;
7775 -> 7773;
7775 -> 7764;
7775 -> 7763;
7776 -> 7775;
7776 -> 7669;
7777 -> 7775;
7778 -> 7775;
7779 -> 5517;
7779 -> 5516;
7780 -> 5553;
7780 -> 5516;
7781 -> 6835;
7781 -> 5516;
7782 -> 6836;
7782 -> 5516;
7783 -> 6837;
7783 -> 5516;
7784 -> 6853;
7784 -> 5516;
7785 -> 6856;
7785 -> 5516;
7786 -> 7775;
7786 -> 5516;
7787 -> 7779;
7787 -> 7780;
7787 -> 7781;
7787 -> 7782;
7787 -> 7783;
7787 -> 7784;
7787 -> 7785;
7787 -> 7786;
7787 -> 5518;
7787 -> 7669;
7787 -> 5449;
7787 -> 7775;
7787 -> 5516;
7788 -> 5516;
7789 -> 7788;
7790 -> 7789;
7790 -> 7788;
7791 -> 7787;
7791 -> 7788;
7792 -> 7787;
7792 -> 7788;
7793 -> 7791;
7793 -> 7787;
7793 -> 7788;
7794 -> 7791;
7794 -> 7787;
7794 -> 7788;
7795 -> 6856;
7795 -> 5516;
7796 -> 5518;
7796 -> 7787;
7796 -> 7795;
7796 -> 5516;
7797 -> 5504;
7797 -> 5514;
7798 -> 5514;
7799 -> 7797;
7799 -> 7798;
7800 -> 5457;
7800 -> 7798;
7801 -> 7799;
7801 -> 5499;
7801 -> 7798;
7802 -> 7798;
7803 -> 7801;
7803 -> 7802;
7804 -> 7800;
7804 -> 7802;
7805 -> 7804;
7805 -> 7796;
7805 -> 7803;
7805 -> 5488;
7805 -> 7802;
7806 -> 7802;
7807 -> 7804;
7807 -> 7796;
7807 -> 7806;
7807 -> 7802;
7808 -> 7807;
7809 -> 7808;
7809 -> 7804;
7809 -> 7807;
7810 -> 7798;
7811 -> 5514;
7812 -> 7809;
7812 -> 890;
7813 -> 894;
7813 -> 890;
7814 -> 7812;
7814 -> 7813;
7815 -> 7813;
7816 -> 7814;
7816 -> 7815;
7817 -> 5411;
7817 -> 7815;
7818 -> 7815;
7819 -> 7817;
7819 -> 7818;
7820 -> 7818;
7821 -> 7819;
7821 -> 7820;
7822 -> 7821;
7822 -> 7809;
7822 -> 7820;
7823 -> 7820;
7824 -> 7821;
7824 -> 7809;
7824 -> 7823;
7824 -> 7820;
7825 -> 7824;
7825 -> 7815;
7826 -> 7815;
7827 -> 7825;
7827 -> 7826;
7828 -> 7816;
7828 -> 7827;
7829 -> 7828;
7829 -> 890;
7830 -> 7828;
7830 -> 7809;
7830 -> 7824;
7830 -> 890;
7831 -> 890;
7832 -> 7830;
7832 -> 7831;
7833 -> 7830;
7833 -> 7831;
7834 -> 7830;
7834 -> 7831;
7835 -> 7829;
7835 -> 7831;
7836 -> 7832;
7836 -> 7831;
7837 -> 7833;
7837 -> 7831;
7838 -> 7834;
7838 -> 7831;
7839 -> 7831;
7840 -> 7839;
7840 -> 7836;
7840 -> 7837;
7840 -> 7838;
7840 -> 7830;
7840 -> 7831;
7841 -> 7840;
7841 -> 1;
7842 -> 0;
7842 -> 1;
7843 -> 1;
7844 -> 7840;
7844 -> 7843;
7845 -> 7844;
7845 -> 7840;
7845 -> 7843;
7846 -> 7845;
7846 -> 1;
7847 -> 206;
7847 -> 1;
7848 -> 7840;
7848 -> 1;
7849 -> 1;
7850 -> 7848;
7850 -> 7849;
7851 -> 7849;
7852 -> 7848;
7852 -> 7851;
7852 -> 1;
7853 -> 7848;
7853 -> 7849;
7854 -> 7848;
7854 -> 7849;
7855 -> 7848;
7855 -> 7849;
7856 -> 7848;
7856 -> 7849;
7857 -> 7854;
7857 -> 7849;
7858 -> 7849;
7859 -> 7856;
7859 -> 7858;
7860 -> 7858;
7861 -> 7859;
7861 -> 7860;
7862 -> 7861;
7862 -> 7852;
7862 -> 7860;
7863 -> 7862;
7863 -> 7858;
7864 -> 7858;
7865 -> 7863;
7865 -> 7864;
7866 -> 7865;
7866 -> 7864;
7867 -> 7866;
7868 -> 7867;
7868 -> 7849;
7869 -> 7853;
7869 -> 7868;
7869 -> 7852;
7869 -> 7849;
7870 -> 7855;
7870 -> 7849;
7871 -> 7870;
7872 -> 7856;
7872 -> 7871;
7873 -> 7872;
7873 -> 7869;
7873 -> 7871;
7874 -> 7873;
7874 -> 7870;
7875 -> 7870;
7876 -> 7874;
7876 -> 7875;
7876 -> 7870;
7877 -> 7853;
7877 -> 7876;
7878 -> 7876;
7879 -> 7877;
7879 -> 7878;
7880 -> 7878;
7881 -> 7877;
7881 -> 7878;
7882 -> 7877;
7882 -> 7878;
7883 -> 7882;
7883 -> 7880;
7883 -> 7878;
7884 -> 7881;
7884 -> 7883;
7884 -> 7880;
7884 -> 7878;
7885 -> 7857;
7886 -> 7856;
7886 -> 7885;
7887 -> 7885;
7888 -> 7887;
7888 -> 7857;
7889 -> 7857;
7890 -> 7888;
7890 -> 7889;
7890 -> 7857;
7891 -> 7884;
7892 -> 7856;
7892 -> 7871;
7893 -> 7871;
7893 -> 7870;
7894 -> 7893;
7894 -> 7875;
7894 -> 7870;
7895 -> 7856;
7895 -> 7858;
7896 -> 7895;
7896 -> 7891;
7896 -> 7858;
7897 -> 7856;
7897 -> 7885;
7898 -> 7897;
7898 -> 7896;
7898 -> 7885;
7899 -> 7898;
7899 -> 7857;
7900 -> 7899;
7900 -> 7889;
7900 -> 7857;
7901 -> 7896;
7902 -> 7901;
7903 -> 7897;
7903 -> 7901;
7903 -> 7885;
7904 -> 7903;
7904 -> 7857;
7905 -> 7904;
7905 -> 7889;
7905 -> 7857;
7906 -> 7901;
7907 -> 7906;
7908 -> 7897;
7908 -> 7906;
7908 -> 7885;
7909 -> 7908;
7909 -> 7857;
7910 -> 7909;
7910 -> 7889;
7910 -> 7857;
7911 -> 7906;
7912 -> 7911;
7913 -> 7911;
7914 -> 7897;
7914 -> 7913;
7914 -> 7885;
7915 -> 7914;
7915 -> 7857;
7916 -> 7915;
7916 -> 7889;
7916 -> 7857;
7917 -> 7913;
7918 -> 7917;
7919 -> 7897;
7919 -> 7917;
7919 -> 7885;
7920 -> 7919;
7920 -> 7857;
7921 -> 7920;
7921 -> 7889;
7921 -> 7857;
7922 -> 7917;
7923 -> 1;
7924 -> 7840;
7924 -> 1;
7925 -> 1;
7926 -> 7924;
7926 -> 7925;
7927 -> 7926;
7927 -> 7922;
7927 -> 7925;
7928 -> 7925;
7929 -> 7925;
7930 -> 7927;
7930 -> 7929;
7931 -> 7928;
7931 -> 7929;
7932 -> 7929;
7933 -> 7930;
7933 -> 7929;
7934 -> 7933;
7934 -> 7929;
7935 -> 7932;
7935 -> 7929;
7936 -> 7935;
7936 -> 7925;
7937 -> 7936;
7937 -> 1;
7938 -> 7840;
7938 -> 1;
7939 -> 1;
7940 -> 7938;
7940 -> 7933;
7940 -> 1;
7941 -> 1;
7942 -> 7940;
7942 -> 7941;
7943 -> 7941;
7944 -> 7943;
7944 -> 1;
7945 -> 7940;
7945 -> 7944;
7945 -> 1;
7946 -> 0;
7946 -> 1;
7947 -> 7938;
7947 -> 7945;
7947 -> 1;
7948 -> 1;
7949 -> 7947;
7949 -> 7948;
7950 -> 7948;
7951 -> 7950;
7951 -> 1;
7952 -> 7947;
7952 -> 7951;
7952 -> 1;
7953 -> 7947;
7953 -> 7948;
7954 -> 7953;
7954 -> 7952;
7954 -> 7948;
7955 -> 7954;
7955 -> 7948;
7956 -> 7948;
7957 -> 7955;
7957 -> 7956;
7958 -> 7956;
7959 -> 0;
7959 -> 7956;
7960 -> 7957;
7960 -> 7958;
7960 -> 7956;
7961 -> 7956;
7962 -> 7959;
7962 -> 7961;
7962 -> 7956;
7963 -> 7962;
7963 -> 7958;
7963 -> 7956;
7964 -> 7960;
7964 -> 7963;
7964 -> 7956;
7965 -> 1;
7966 -> 7938;
7966 -> 7964;
7966 -> 1;
7967 -> 1;
7968 -> 7966;
7968 -> 7967;
7969 -> 7967;
7970 -> 7969;
7970 -> 1;
7971 -> 7966;
7971 -> 7970;
7971 -> 1;
7972 -> 7938;
7972 -> 7971;
7972 -> 1;
7973 -> 1;
7974 -> 7972;
7974 -> 7973;
7975 -> 7972;
7975 -> 7973;
7976 -> 7972;
7976 -> 7973;
7977 -> 7972;
7977 -> 7973;
7978 -> 7973;
7979 -> 1;
7980 -> 1;
7981 -> 7938;
7981 -> 7974;
7981 -> 7980;
7982 -> 7980;
7983 -> 7981;
7983 -> 7974;
7983 -> 7982;
7984 -> 7983;
7984 -> 7980;
7985 -> 7984;
7985 -> 1;
7986 -> 1;
7987 -> 7938;
7987 -> 7974;
7987 -> 1;
7988 -> 1;
7989 -> 7987;
7989 -> 7988;
7990 -> 7988;
7991 -> 7990;
7991 -> 1;
7992 -> 7987;
7992 -> 7991;
7992 -> 1;
7993 -> 1;
7994 -> 7938;
7994 -> 7992;
7994 -> 1;
7995 -> 1;
7996 -> 7994;
7996 -> 7995;
7997 -> 7995;
7998 -> 7997;
7998 -> 1;
7999 -> 7994;
7999 -> 7998;
7999 -> 1;
8000 -> 1;
8001 -> 7938;
8001 -> 7999;
8001 -> 1;
8002 -> 1;
8003 -> 7938;
8003 -> 7999;
8003 -> 8002;
8003 -> 1;
8004 -> 1;
8005 -> 8003;
8005 -> 8004;
8006 -> 8003;
8006 -> 8004;
8007 -> 8003;
8007 -> 8004;
8008 -> 8003;
8008 -> 8004;
8009 -> 8004;
8010 -> 1;
8011 -> 7938;
8011 -> 8005;
8011 -> 8010;
8011 -> 1;
8012 -> 1;
8013 -> 8011;
8013 -> 8012;
8014 -> 8012;
8015 -> 8014;
8015 -> 1;
8016 -> 8011;
8016 -> 8015;
8016 -> 1;
8017 -> 0;
8017 -> 1;
8018 -> 1;
8019 -> 7938;
8019 -> 8016;
8019 -> 8018;
8019 -> 1;
8020 -> 1;
8021 -> 8019;
8021 -> 8020;
8022 -> 8020;
8023 -> 8022;
8023 -> 1;
8024 -> 8019;
8024 -> 8023;
8024 -> 1;
8025 -> 8019;
8025 -> 8020;
8026 -> 8020;
8027 -> 8026;
8028 -> 0;
8028 -> 8026;
8029 -> 8026;
8030 -> 8028;
8030 -> 8029;
8030 -> 8026;
8031 -> 8030;
8031 -> 8027;
8031 -> 8026;
8032 -> 1;
8033 -> 7938;
8033 -> 8025;
8033 -> 8032;
8033 -> 1;
8034 -> 8033;
8034 -> 1;
8035 -> 8033;
8035 -> 1;
8036 -> 1;
8037 -> 8035;
8037 -> 8036;
8038 -> 8035;
8038 -> 8036;
8039 -> 8035;
8039 -> 8036;
8040 -> 8035;
8040 -> 8036;
8041 -> 8036;
8042 -> 1;
8043 -> 1;
8044 -> 8033;
8044 -> 8037;
8044 -> 8043;
8045 -> 8043;
8046 -> 8044;
8046 -> 8037;
8046 -> 8045;
8047 -> 8046;
8047 -> 8043;
8048 -> 8047;
8048 -> 1;
8049 -> 1;
8050 -> 8033;
8050 -> 8037;
8050 -> 1;
8051 -> 1;
8052 -> 8050;
8052 -> 8051;
8053 -> 8051;
8054 -> 8053;
8054 -> 1;
8055 -> 8050;
8055 -> 8054;
8055 -> 1;
8056 -> 1;
8057 -> 7938;
8057 -> 8055;
8057 -> 8056;
8057 -> 1;
8058 -> 1;
8059 -> 8057;
8059 -> 8058;
8060 -> 8057;
8060 -> 8058;
8061 -> 8057;
8061 -> 8058;
8062 -> 8057;
8062 -> 8058;
8063 -> 8058;
8064 -> 1;
8065 -> 7938;
8065 -> 8059;
8065 -> 8064;
8065 -> 1;
8066 -> 8065;
8066 -> 8064;
8067 -> 8064;
8068 -> 8065;
8068 -> 8064;
8069 -> 8068;
8069 -> 8064;
8070 -> 8064;
8071 -> 8070;
8072 -> 8070;
8073 -> 1;
8074 -> 7938;
8074 -> 8065;
8074 -> 8073;
8074 -> 1;
8075 -> 1;
8076 -> 8074;
8076 -> 8075;
8077 -> 8074;
8077 -> 8075;
8078 -> 8074;
8078 -> 8075;
8079 -> 8074;
8079 -> 8075;
8080 -> 8075;
8081 -> 1;
8082 -> 7938;
8082 -> 8076;
8082 -> 8081;
8082 -> 1;
8083 -> 1;
8084 -> 8082;
8084 -> 8083;
8085 -> 8083;
8086 -> 8085;
8086 -> 1;
8087 -> 8082;
8087 -> 8086;
8087 -> 1;
8088 -> 0;
8088 -> 1;
8089 -> 1;
8090 -> 7938;
8090 -> 8087;
8090 -> 8089;
8090 -> 1;
8091 -> 1;
8092 -> 8090;
8092 -> 8091;
8093 -> 8091;
8094 -> 8093;
8094 -> 1;
8095 -> 8090;
8095 -> 8094;
8095 -> 1;
8096 -> 8090;
8096 -> 8091;
8097 -> 8091;
8098 -> 8097;
8099 -> 0;
8099 -> 8097;
8100 -> 8097;
8101 -> 8099;
8101 -> 8100;
8101 -> 8097;
8102 -> 8101;
8102 -> 8098;
8102 -> 8097;
8103 -> 1;
8104 -> 7938;
8104 -> 8096;
8104 -> 8103;
8104 -> 1;
8105 -> 8104;
8105 -> 1;
8106 -> 8104;
8106 -> 1;
8107 -> 1;
8108 -> 8106;
8108 -> 8107;
8109 -> 8106;
8109 -> 8107;
8110 -> 8106;
8110 -> 8107;
8111 -> 8106;
8111 -> 8107;
8112 -> 8107;
8113 -> 1;
8114 -> 1;
8115 -> 8104;
8115 -> 8108;
8115 -> 8114;
8116 -> 8114;
8117 -> 8115;
8117 -> 8108;
8117 -> 8116;
8118 -> 8117;
8118 -> 8114;
8119 -> 8118;
8119 -> 1;
8120 -> 1;
8121 -> 8104;
8121 -> 8108;
8121 -> 1;
8122 -> 1;
8123 -> 8121;
8123 -> 8122;
8124 -> 8122;
8125 -> 8124;
8125 -> 1;
8126 -> 8121;
8126 -> 8125;
8126 -> 1;
8127 -> 1;
8128 -> 7938;
8128 -> 8126;
8128 -> 8127;
8128 -> 1;
8129 -> 1;
8130 -> 8128;
8130 -> 8129;
8131 -> 8128;
8131 -> 8129;
8132 -> 8128;
8132 -> 8129;
8133 -> 8128;
8133 -> 8129;
8134 -> 8129;
8135 -> 1;
8136 -> 7938;
8136 -> 8130;
8136 -> 8135;
8136 -> 1;
8137 -> 8136;
8137 -> 8135;
8138 -> 8135;
8139 -> 8136;
8139 -> 8135;
8140 -> 8139;
8140 -> 8135;
8141 -> 8135;
8142 -> 8141;
8143 -> 8141;
8144 -> 1;
8145 -> 7938;
8145 -> 8136;
8145 -> 1;
8146 -> 1;
8147 -> 8145;
8147 -> 8146;
8148 -> 8146;
8149 -> 8148;
8149 -> 1;
8150 -> 8145;
8150 -> 8149;
8150 -> 1;
}